diff --git a/src/main/java/org/assertj/core/api/AbstractDateAssert.java b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
index c36e2eefd..6d90ead85 100644
--- a/src/main/java/org/assertj/core/api/AbstractDateAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
@@ -17,7 +17,11 @@ import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.concurrent.TimeUnit.MINUTES;
 import static java.util.concurrent.TimeUnit.SECONDS;
 import static java.util.stream.Collectors.toList;
-import static org.assertj.core.util.DateUtil.*;
+import static org.assertj.core.util.DateUtil.newIsoDateFormat;
+import static org.assertj.core.util.DateUtil.newIsoDateTimeFormat;
+import static org.assertj.core.util.DateUtil.newIsoDateTimeWithMsFormat;
+import static org.assertj.core.util.DateUtil.newIsoDateTimeWithUtcTimeZoneFormat;
+import static org.assertj.core.util.DateUtil.newTimestampDateFormat;
 import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.Preconditions.checkNotNull;
 
@@ -105,7 +109,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isEqualTo("2002-12-19");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -144,7 +148,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // KO : fail as day fields differ
    * assertThat("2003-04-26T14:01:35").isEqualToIgnoringHours("2003-04-27T13:02:35");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -214,7 +218,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // KO : fail as hour fields differ
    * assertThat("2003-04-26T14:01:35").isEqualToIgnoringMinutes("2003-04-26T13:02:35");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -283,7 +287,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // KO : fail as minute fields differ
    * assertThat(date1).isEqualToIgnoringMinutes("2003-04-26T13:02:00");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -351,7 +355,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // KO : fail as seconds fields differ
    * assertThat("2003-04-26T13:01:35.998").isEqualToIgnoringMinutes("2003-04-26T13:01:36.998");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -410,13 +414,13 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Beware that the default formats are expressed in the current local timezone.
    * <p>
    * Example:
-   * <pre><code class='java'> // assertion will pass 
+   * <pre><code class='java'> // assertion will pass
    * // theTwoTowers release date : 2002-12-18
    * assertThat(theTwoTowers.getReleaseDate()).isNotEqualTo("2002-12-19");
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isNotEqualTo("2002-12-18");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -455,7 +459,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isIn("2002-12-17", "2002-12-19", "2002-12-20");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -540,7 +544,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isNotIn("2002-12-17", "2002-12-18");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -583,7 +587,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isNotInWithStringDateCollection(Arrays.asList("2002-12-17", "2002-12-18"));</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -647,7 +651,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBefore("2002-12-17");
    * assertThat(theTwoTowers.getReleaseDate()).isBefore("2002-12-18");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -681,11 +685,11 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * <p>
    * Example:
    * <pre><code class='java'> SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
-   * 
+   *
    * // assertions will pass
    * assertThat(dateFormat.parse(&quot;1990-12-01&quot;)).isBeforeOrEqualsTo(dateFormat.parse(&quot;2000-12-01&quot;));
    * assertThat(dateFormat.parse(&quot;2000-12-01&quot;)).isBeforeOrEqualsTo(dateFormat.parse(&quot;2000-12-01&quot;));
-   * 
+   *
    * // assertion will fail
    * assertThat(dateFormat.parse(&quot;2000-12-01&quot;)).isBeforeOrEqualsTo(dateFormat.parse(&quot;1990-12-01&quot;));</code></pre>
    *
@@ -714,7 +718,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBeforeOrEqualsTo("2002-12-17");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -779,7 +783,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isAfter("2002-12-18");
    * assertThat(theTwoTowers.getReleaseDate()).isAfter("2002-12-19");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -813,11 +817,11 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * <p>
    * Example:
    * <pre><code class='java'> SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);
-   * 
+   *
    * // assertions will pass
    * assertThat(dateFormat.parse(&quot;2000-12-01&quot;)).isAfterOrEqualsTo(dateFormat.parse(&quot;1990-12-01&quot;));
    * assertThat(dateFormat.parse(&quot;2000-12-01&quot;)).isAfterOrEqualsTo(dateFormat.parse(&quot;2000-12-01&quot;));
-   * 
+   *
    * // assertion will fail
    * assertThat(dateFormat.parse(&quot;1990-12-01&quot;)).isAfterOrEqualsTo(dateFormat.parse(&quot;2000-12-01&quot;));</code></pre>
    *
@@ -846,7 +850,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isAfterOrEqualsTo("2002-12-19");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -911,7 +915,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBetween("2002-12-15", "2002-12-17");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -954,7 +958,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * assertThat(format.parse(&quot;2000-01-01&quot;)).isBetween(format.parse(&quot;2000-01-01&quot;), format.parse(&quot;2100-12-01&quot;), true, true);
    * assertThat(format.parse(&quot;2000-01-01&quot;)).isBetween(format.parse(&quot;1900-01-01&quot;), format.parse(&quot;2000-01-01&quot;), true, true);
    * assertThat(format.parse(&quot;2000-01-01&quot;)).isBetween(format.parse(&quot;1900-01-01&quot;), format.parse(&quot;2100-01-01&quot;), false, false);
-   * 
+   *
    * // assertions will fail
    * assertThat(format.parse(&quot;2000-01-01&quot;)).isBetween(format.parse(&quot;2000-01-01&quot;), format.parse(&quot;2100-12-01&quot;), false, true);
    * assertThat(format.parse(&quot;2000-01-01&quot;)).isBetween(format.parse(&quot;1900-01-01&quot;), format.parse(&quot;2000-01-01&quot;), true, false);</code></pre>
@@ -989,7 +993,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBetween("2002-12-17", "2002-12-18", false, false);</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -1032,7 +1036,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * // assertions will pass
    * assertThat(format.parse("2000-01-01")).isNotBetween(format.parse("2000-01-01"), format.parse("2100-12-01"), false, true);
    * assertThat(format.parse("2000-01-01")).isNotBetween(format.parse("1900-01-01"), format.parse("2000-01-01"), true, false);
-   * 
+   *
    * // assertions will fail
    * assertThat(format.parse("2000-01-01")).isNotBetween(format.parse("2000-01-01"), format.parse("2100-12-01"), true, true);
    * assertThat(format.parse("2000-01-01")).isNotBetween(format.parse("1900-01-01"), format.parse("2000-01-01"), true, true);
@@ -1068,7 +1072,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isNotBetween("2002-12-17", "2002-12-18", false, true);
    * assertThat(theTwoTowers.getReleaseDate()).isNotBetween("2002-12-18", "2002-12-19", true, false);</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -1109,7 +1113,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * assertThat(format.parse(&quot;1900-01-01&quot;)).isNotBetween(format.parse(&quot;2000-01-01&quot;), format.parse(&quot;2100-12-01&quot;));
    * assertThat(format.parse(&quot;2200-01-01&quot;)).isNotBetween(format.parse(&quot;2000-01-01&quot;), format.parse(&quot;2100-12-01&quot;));
    * assertThat(format.parse(&quot;2000-01-01&quot;)).isNotBetween(format.parse(&quot;1900-01-01&quot;), format.parse(&quot;2000-01-01&quot;));
-   * 
+   *
    * // assertions will fail
    * assertThat(format.parse(&quot;2001-12-24&quot;)).isNotBetween(format.parse(&quot;2000-01-01&quot;), format.parse(&quot;2100-01-01&quot;));
    * assertThat(format.parse(&quot;1900-01-01&quot;)).isNotBetween(format.parse(&quot;1900-01-01&quot;), format.parse(&quot;2000-01-01&quot;));</code></pre>
@@ -1139,7 +1143,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(theFellowshipOfTheRing.getReleaseDate()).isNotBetween("2002-12-01", "2002-12-19");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -1512,7 +1516,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // assertion will fail
    * assertThat(parseDatetimeWithMs("2003-04-26T13:20:35.017")).hasMillisecond(25);</code></pre>
-   * 
+   *
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
    *
    * @param millisecond the millisecond to compare actual millisecond to
@@ -1544,7 +1548,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Date date2 = parse("2003-05-27");
    *
    * assertThat(date1).isInSameYearAs(date2);</code></pre>
-   * 
+   *
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
    *
    * @param other the given {@code Date} to compare actual {@code Date} to.
@@ -1567,7 +1571,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Example:
    * <pre><code class='java'> Date date1 = parse("2003-04-26");
    * assertThat(date1).isInSameYearAs("2003-05-27");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -1603,7 +1607,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Date date2 = parse("2003-04-27");
    *
    * assertThat(date1).isInSameMonthAs(date2);</code></pre>
-   * 
+   *
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
    *
    * @param other the given {@code Date} to compare actual {@code Date} to.
@@ -1626,7 +1630,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Example:
    * <pre><code class='java'> Date date1 = parse("2003-04-26");
    * assertThat(date1).isInSameMonthAs("2003-04-27");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -1661,7 +1665,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Date date2 = parseDatetime("2003-04-26T12:30:00");
    *
    * assertThat(date1).isInSameDayAs(date2);</code></pre>
-   * 
+   *
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
    *
    * @param other the given {@code Date} to compare actual {@code Date} to.
@@ -1684,7 +1688,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Example:
    * <pre><code class='java'> Date date1 = parseDatetime("2003-04-26T23:17:00");
    * assertThat(date1).isInSameDayAs("2003-04-26");</code></pre>
-   * 
+   *
    * Defaults date format (expressed in the local time zone) are :
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -1719,21 +1723,21 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * <pre><code class='java'> Date date1 = parseDatetime("2003-04-26T13:00:00");
    * Date date2 = parseDatetime("2003-04-26T14:00:00");
    * assertThat(date1).isInSameHourWindowAs(date2);</code></pre>
-   * 
+   *
    * Two dates can have different hour fields and yet be in the same chronological hour, example:
    * <pre><code class='java'> Date date1 = parseDatetime("2003-04-26T13:00:00");
    * Date date2 = parseDatetime("2003-04-26T12:59:59");
    * // succeeds as time difference == 1s
    * assertThat(date1).isInSameHourWindowAs(date2);</code></pre>
-   * 
+   *
    * This assertion fails as time difference is more than one hour:
    * <pre><code class='java'> Date date1 = parseDatetime("2003-04-26T13:00:00");
    * Date date2 = parseDatetime("2003-04-26T14:00:01");
    * assertThat(date1).isInSameHourWindowAs(date2);</code></pre>
-   * 
+   *
    * To compare date's hour fields only (without day, month and year), you can write :
    * <pre><code class='java'> assertThat(myDate).isWithinHour(hourOfDayOf(otherDate));</code></pre>
-   * 
+   *
    * see {@link org.assertj.core.util.DateUtil#hourOfDayOf(java.util.Date) hourOfDayOf} to get the hour of a given Date.
    * <p>
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}).
@@ -1791,14 +1795,14 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // succeeds
    * assertThat(date1).isInSameHourAs(date2);</code></pre>
-   * 
+   *
    * <b>This assertion does not make a true chronological comparison</b> since two dates can have different hour fields
    * and yet be in the same chronological hour, e.g:
-   * 
+   *
    * <pre><code class='java'> // dates in the same hour time window but with different hour fields
    * Date date1 = parseDatetime("2003-01-01T12:00:00");
    * Date date2 = parseDatetime("2003-01-01T11:59:00");</code></pre>
-   * 
+   *
    * If you want to assert that two dates are chronologically in the same hour time window use
    * {@link #isInSameHourWindowAs(java.util.Date) isInSameHourWindowAs} assertion (note that if
    * <code>isInSameHourAs</code> succeeds then <code>isInSameHourWindowAs</code> will succeed too).
@@ -1862,21 +1866,21 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // succeeds because date time difference &lt; 1 min
    * assertThat(date1).isInSameMinuteWindowAs(date2);</code></pre>
-   * 
+   *
    * Two dates can have different minute fields and yet be in the same chronological minute, example:
    * <pre><code class='java'> Date date1 = parseDatetime("2003-01-01T12:01:00");
    * Date date3 = parseDatetime("2003-01-01T12:00:59");
    *
    * // succeeds as time difference == 1s even though minutes fields differ
    * assertThat(date1).isInSameMinuteWindowAs(date3);</code></pre>
-   * 
+   *
    * This assertion fails as time difference is &gt;= one minute:
    * <pre><code class='java'> Date date1 = parseDatetime("2003-01-01T12:01:00");
    * Date date2 = parseDatetime("2003-01-01T12:02:00");
    *
    * // fails, time difference should hae been &lt; 1 min
    * assertThat(date1).isInSameMinuteWindowAs(date2); // ERROR</code></pre>
-   * 
+   *
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}).
    *
    * @param other the given {@code Date} to compare actual {@code Date} to.
@@ -1932,7 +1936,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // succeeds because the all the fields up to minutes are the same
    * assertThat(date1).isInSameMinuteAs(date2);</code></pre>
-   * 
+   *
    * <b>It does not make a true chronological comparison</b> since two dates can have different minute fields and yet be
    * in the same chronological minute, e.g:
    * <pre><code class='java'> // dates in the same minute time window but with different minute fields
@@ -1941,7 +1945,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // fails because minutes fields differ even though time difference is only 1s !
    * assertThat(date1).isInSameMinuteAs(date3); // ERROR</code></pre>
-   * 
+   *
    * If you want to assert that two dates are in the same minute time window use
    * {@link #isInSameMinuteWindowAs(java.util.Date) isInSameMinuteWindowAs} assertion (note that if
    * <code>isInSameMinuteAs</code> succeeds then <code>isInSameMinuteWindowAs</code> will succeed too).
@@ -2005,14 +2009,14 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // succeeds as time difference is &lt; 1s
    * assertThat(date1).isInSameSecondWindowAs(date2);</code></pre>
-   * 
+   *
    * Two dates can have different second fields and yet be in the same chronological second, example:
    * <pre><code class='java'> Date date1 = parseDatetimeWithMs("2003-04-26T13:01:02.999");
    * Date date2 = parseDatetimeWithMs("2003-04-26T13:01:03.000");
    *
    * // succeeds as time difference is 1ms &lt; 1s
    * assertThat(date1).isInSameSecondWindowAs(date2);</code></pre>
-   * 
+   *
    * Those assertions fail as time difference is greater or equal to one second:
    * <pre><code class='java'> Date date1 = parseDatetimeWithMs("2003-04-26T13:01:01.000");
    * Date date2 = parseDatetimeWithMs("2003-04-26T13:01:02.000");
@@ -2023,7 +2027,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Date date3 = parseDatetimeWithMs("2003-04-26T13:01:02.001");
    * // fails as time difference &gt; 1s
    * assertThat(date1).isInSameSecondWindowAs(date3); // ERROR</code></pre>
-   * 
+   *
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
    *
    * @param other the given {@code Date} to compare actual {@code Date} to.
@@ -2072,13 +2076,13 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
 
   /**
    * Verifies that actual and given {@code Date} have same second, minute, hour, day, month and year fields values.
-   * 
+   *
    * <pre><code class='java'> Date date1 = parseDatetimeWithMs("2003-01-01T12:00:01.000");
    * Date date2 = parseDatetimeWithMs("2003-01-01T12:00:01.250");
    *
    * // succeeds because the all the time fields up to seconds are the same
    * assertThat(date1).isInSameSecondAs(date2);</code></pre>
-   * 
+   *
    * <b>It does not make a true chronological comparison</b> since two dates can have different second fields and yet
    * be
    * in the same chronological second, e.g:
@@ -2087,7 +2091,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    *
    * // fails because seconds fields differ even though time difference is only 1ms !
    * assertThat(date1).isInSameSecondAs(date3); // ERROR</code></pre>
-   * 
+   *
    * If you want to assert that two dates are in the same second time window use
    * {@link #isInSameSecondWindowAs(java.util.Date) isInSameSecondWindowAs} assertion.
    * <p>
@@ -2228,11 +2232,11 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * Example:
    * <pre><code class='java'> Date date = new Date();
    * Timestamp timestamp = new Timestamp(date.getTime());
-   * 
+   *
    * // Fail as date is not an instance of Timestamp
    * assertThat(date).isEqualTo(timestamp);
-   * 
-   * // Succeed as we compare date and timestamp time. 
+   *
+   * // Succeed as we compare date and timestamp time.
    * assertThat(date).hasSameTimeAs(timestamp);</code></pre>
    *
    * @param date the date to compare actual time to.
@@ -2265,7 +2269,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * // assertion will fail
    * assertThat(date).hasSameTimeAs("2003-04-26T12:00:01");
    * assertThat(date).hasSameTimeAs("2003-04-27T12:00:00");</code></pre>
-   * 
+   *
    * Default date formats (expressed in the local time zone) are:
    * <ul>
    * <li><code>yyyy-MM-dd'T'HH:mm:ss.SSS</code></li>
@@ -2363,7 +2367,7 @@ public abstract class AbstractDateAssert<SELF extends AbstractDateAssert<SELF>>
    * AbstractDateAssert.setLenientDateParsing(true);
    *
    * // assertions will pass
-   * assertThat(date).isEqualTo("2001-01-34");
+   * assertThat(date).isEqualTo("2001-02-03");
    * assertThat(date).isEqualTo("2001-02-02T24:00:00");
    * assertThat(date).isEqualTo("2001-02-04T-24:00:00.000");
    * assertThat(dateTime).isEqualTo("2001-02-03T04:05:05.1000");
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index b6c332169..1856877a8 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -1275,6 +1275,8 @@ public class Assertions {
 
   /**
    * Sets whether we remove elements related to AssertJ from assertion error stack trace.
+   * <p>
+   * Default is {@value org.assertj.core.configuration.Configuration#REMOVE_ASSERTJ_RELATED_ELEMENTS_FROM_STACK_TRACE}.
    *
    * @param removeAssertJRelatedElementsFromStackTrace flag.
    */
@@ -1492,7 +1494,7 @@ public class Assertions {
    * <code>{@link org.assertj.core.api.AbstractObjectArrayAssert#extracting(String) ObjectArrayAssert#extracting(String)}</code>
    * should be allowed to extract private fields, if not and they try it fails with exception.
    *
-   * @param allowExtractingPrivateFields allow private fields extraction. Default {@code true}.
+   * @param allowExtractingPrivateFields allow private fields extraction. Default is {@value org.assertj.core.configuration.Configuration#ALLOW_EXTRACTING_PRIVATE_FIELDS}.
    */
   public static void setAllowExtractingPrivateFields(boolean allowExtractingPrivateFields) {
     FieldSupport.extraction().setAllowUsingPrivateFields(allowExtractingPrivateFields);
@@ -1510,7 +1512,7 @@ public class Assertions {
    *
    * If the value is <code>false</code> and these methods try to compare private fields, it will fail with an exception.
    *
-   * @param allowComparingPrivateFields allow private fields comparison. Default {@code true}.
+   * @param allowComparingPrivateFields allow private fields comparison. Default is {@value org.assertj.core.configuration.Configuration#ALLOW_COMPARING_PRIVATE_FIELDS}.
    */
   public static void setAllowComparingPrivateFields(boolean allowComparingPrivateFields) {
     FieldSupport.comparison().setAllowUsingPrivateFields(allowComparingPrivateFields);
diff --git a/src/main/java/org/assertj/core/configuration/Configuration.java b/src/main/java/org/assertj/core/configuration/Configuration.java
new file mode 100644
index 000000000..49ba4d993
--- /dev/null
+++ b/src/main/java/org/assertj/core/configuration/Configuration.java
@@ -0,0 +1,194 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.configuration;
+
+import static java.lang.String.format;
+import static java.util.Collections.emptyList;
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.List;
+
+import org.assertj.core.api.Assertions;
+import org.assertj.core.presentation.Representation;
+
+/**
+ * Provider for all the configuration settings / parameters within AssertJ.
+ * <p>
+ * All the configuration possibilities are registered via an SPI.
+ *
+ * @since 3.13.0
+ */
+public class Configuration {
+
+  // default values
+  public static final Configuration DEFAULT_CONFIGURATION = new Configuration();
+
+  public static final int MAX_LENGTH_FOR_SINGLE_LINE_DESCRIPTION = 80;
+  public static final int MAX_ELEMENTS_FOR_PRINTING = 1000;
+  public static final boolean REMOVE_ASSERTJ_RELATED_ELEMENTS_FROM_STACK_TRACE = true;
+  public static final boolean ALLOW_COMPARING_PRIVATE_FIELDS = true;
+  public static final boolean ALLOW_EXTRACTING_PRIVATE_FIELDS = true;
+  public static final boolean BARE_NAME_PROPERTY_EXTRACTION_ENABLED = true;
+  public static final boolean LENIENT_DATE_PARSING = false;
+
+  /**
+   * @return the default {@link Representation} that is used within AssertJ.
+   */
+  public Representation representation() {
+    return STANDARD_REPRESENTATION;
+  }
+
+  boolean hasCustomRepresentation() {
+    return representation() != STANDARD_REPRESENTATION;
+  }
+
+  /**
+   * Returns whether private fields comparison is enabled. Default is {@value #ALLOW_COMPARING_PRIVATE_FIELDS}.
+   * <p>
+   * See {@link Assertions#setAllowComparingPrivateFields(boolean)} for a detailed description.
+   *
+   * @return whether private fields comparison is enabled. Default is {@value #ALLOW_COMPARING_PRIVATE_FIELDS}.
+   */
+  public boolean comparingPrivateFieldsEnabled() {
+    return ALLOW_COMPARING_PRIVATE_FIELDS;
+  }
+
+  /**
+   * Returns whether private fields comparison is enabled. Default is {@value #ALLOW_EXTRACTING_PRIVATE_FIELDS}.
+   * <p>
+   * See {@link Assertions#setAllowExtractingPrivateFields(boolean)} for a detailed description.
+   *
+   * @return whether private fields comparison is enabled. Default is {@value #ALLOW_EXTRACTING_PRIVATE_FIELDS}.
+   *
+   */
+  public boolean extractingPrivateFieldsEnabled() {
+    return ALLOW_EXTRACTING_PRIVATE_FIELDS;
+  }
+
+  /**
+   * Returns whether the extractor considers bare-named property methods like {@code String name()}.
+   * <p>
+   * See {@link Assertions#setExtractBareNamePropertyMethods(boolean)} for a detailed description.
+   *
+   * @return Whether the extractor considers bare-named property methods like {@code String name()}. Default is {@value #BARE_NAME_PROPERTY_EXTRACTION_ENABLED}.
+   */
+  public boolean bareNamePropertyExtractionEnabled() {
+    return true;
+  }
+
+  /**
+   * Returns whether AssertJ related elements are removed from assertion errors stack trace.
+   * <p>
+   * See {@link Assertions#setRemoveAssertJRelatedElementsFromStackTrace(boolean)} for a detailed description.
+   *
+   * @return whether AssertJ related elements are removed from assertion errors stack trace. Default is {@value #REMOVE_ASSERTJ_RELATED_ELEMENTS_FROM_STACK_TRACE}.
+   */
+  public boolean removeAssertJRelatedElementsFromStackTraceEnabled() {
+    return REMOVE_ASSERTJ_RELATED_ELEMENTS_FROM_STACK_TRACE;
+  }
+
+  /**
+   * Returns whether AssertJ will use lenient parsing mode for default date formats.
+   * <p>
+   * See {@link Assertions#setLenientDateParsing(boolean)} for a detailed description.
+   *
+   * @return whether AssertJ will use lenient parsing mode for default date formats. Default is {@value #LENIENT_DATE_PARSING}.
+   */
+  public boolean lenientDateParsingEnabled() {
+    return LENIENT_DATE_PARSING;
+  }
+
+  /**
+   * Returns the additional date formats AssertJ will use in date assertions.
+   * <p>
+   * See {@link Assertions#registerCustomDateFormat(java.text.DateFormat)} for a detailed description.
+   *
+   * @return the additional date formats AssertJ will use in date assertions. Default is none.
+   */
+  public List<DateFormat> additionalDateFormats() {
+    return emptyList();
+  }
+
+  /**
+   * Returns the maximum length for an iterable/array to be displayed on one line.
+   * <p>
+   * See {@link Assertions#setMaxLengthForSingleLineDescription(int)} for a detailed description.
+   *
+   * @return the maximum length for an iterable/array to be displayed on one line. Default is {@value #MAX_LENGTH_FOR_SINGLE_LINE_DESCRIPTION}.
+   */
+  public int maxLengthForSingleLineDescription() {
+    return MAX_LENGTH_FOR_SINGLE_LINE_DESCRIPTION;
+  }
+
+  /**
+   * Returns the maximum length for an iterable/array to be displayed on one line.
+   * <p>
+   * See {@link Assertions#setMaxLengthForSingleLineDescription(int)} for a detailed description.
+   *
+   * @return the maximum length for an iterable/array to be displayed on one line. Default is {@value #MAX_ELEMENTS_FOR_PRINTING}.
+   */
+  public int maxElementsForPrinting() {
+    return MAX_ELEMENTS_FOR_PRINTING;
+  }
+
+  /**
+   * Applies this configuration to AssertJ.
+   */
+  public void apply() {
+    Assertions.setAllowComparingPrivateFields(comparingPrivateFieldsEnabled());
+    Assertions.setAllowExtractingPrivateFields(extractingPrivateFieldsEnabled());
+    Assertions.setExtractBareNamePropertyMethods(bareNamePropertyExtractionEnabled());
+    Assertions.setLenientDateParsing(lenientDateParsingEnabled());
+    Assertions.setMaxElementsForPrinting(maxElementsForPrinting());
+    Assertions.setMaxLengthForSingleLineDescription(maxLengthForSingleLineDescription());
+    Assertions.setRemoveAssertJRelatedElementsFromStackTrace(removeAssertJRelatedElementsFromStackTraceEnabled());
+    Assertions.useRepresentation(representation());
+    additionalDateFormats().forEach(Assertions::registerCustomDateFormat);
+  }
+
+  public String describe() {
+    return format("- representation .................................. = %s%n" +
+                  "- comparingPrivateFieldsEnabled ................... = %s%n" +
+                  "- extractingPrivateFieldsEnabled .................. = %s%n" +
+                  "- bareNamePropertyExtractionEnabled ............... = %s%n" +
+                  "- lenientDateParsingEnabled ....................... = %s%n" +
+                  "- additionnal date formats ........................ = %s%n" +
+                  "- maxLengthForSingleLineDescription ............... = %s%n" +
+                  "- maxElementsForPrinting .......................... = %s%n" +
+                  "- removeAssertJRelatedElementsFromStackTraceEnabled = %s%n",
+                  representation(),
+                  comparingPrivateFieldsEnabled(),
+                  extractingPrivateFieldsEnabled(),
+                  bareNamePropertyExtractionEnabled(),
+                  lenientDateParsingEnabled(),
+                  describeAdditionalDateFormats(),
+                  maxLengthForSingleLineDescription(),
+                  maxElementsForPrinting(),
+                  removeAssertJRelatedElementsFromStackTraceEnabled());
+  }
+
+  private String describeAdditionalDateFormats() {
+    return additionalDateFormats().stream()
+                                  .map(this::describe)
+                                  .collect(toList())
+                                  .toString();
+  }
+
+  private String describe(DateFormat dateFormat) {
+    return dateFormat instanceof SimpleDateFormat ? ((SimpleDateFormat) dateFormat).toPattern() : dateFormat.toString();
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/configuration/ConfigurationProvider.java b/src/main/java/org/assertj/core/configuration/ConfigurationProvider.java
index 2da150bfc..20ce4e7f4 100644
--- a/src/main/java/org/assertj/core/configuration/ConfigurationProvider.java
+++ b/src/main/java/org/assertj/core/configuration/ConfigurationProvider.java
@@ -12,9 +12,12 @@
  */
 package org.assertj.core.configuration;
 
+import static java.lang.String.format;
+import static org.assertj.core.configuration.Configuration.DEFAULT_CONFIGURATION;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
 
 import org.assertj.core.presentation.Representation;
+import org.assertj.core.presentation.StandardRepresentation;
 
 /**
  * Provider for all the configuration settings / parameters within AssertJ.
@@ -26,19 +29,47 @@ import org.assertj.core.presentation.Representation;
  */
 public final class ConfigurationProvider {
 
+  private static final String NEWLINE = format("%n");
   public static final ConfigurationProvider CONFIGURATION_PROVIDER = new ConfigurationProvider();
-
-  private final Representation defaultRepresentation;
+  private final Representation representation;
+  private final Configuration configuration;
 
   private ConfigurationProvider() {
-    defaultRepresentation = Services.get(Representation.class, STANDARD_REPRESENTATION);
+    representation = Services.get(Representation.class, STANDARD_REPRESENTATION);
+    if (representation != STANDARD_REPRESENTATION) {
+      System.err.println(format("Although it still works, registering a Representation through a file named 'org.assertj.core.presentation.Representation' in the META-INF/services directory is deprecated.%n"
+                                + "The proper way of providing a Representation is to register a Configuration as described in the documentation (a Configuration allowing to provide a Representation and other AssertJ configuration elements)"));
+    }
+    configuration = Services.get(Configuration.class, DEFAULT_CONFIGURATION);
+    if (configuration != DEFAULT_CONFIGURATION) {
+      configuration.apply();
+      System.out.println(NEWLINE + "AssertJ has found and applied the following registered configuration: " + configuration);
+      System.out.println(configuration.describe());
+    }
   }
 
   /**
+   * Returns the default {@link Representation} that needs to be used within AssertJ, which is taken first from:
+   * <ul>
+   * <li>a registered {@link Configuration#representation()} if any </li>
+   * <li>a registered {@link Representation}</li>
+   * </ul>
+   * If no custom representation was registered, the {@link StandardRepresentation} will be used.
+   *
    * @return the default {@link Representation} that needs to be used within AssertJ
    * @since 2.9.0 / 3.9.0
    */
   public Representation representation() {
-    return defaultRepresentation;
+    return configuration.hasCustomRepresentation() ? configuration.representation() : representation;
+  }
+
+  /**
+   * Returns the configuration used in for all tests.
+   *
+   * @return the configuration applied for all tests.
+   * @since 3.13.0
+   */
+  public Configuration configuration() {
+    return configuration;
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/Failures.java b/src/main/java/org/assertj/core/internal/Failures.java
index d29ff4a7e..a88a8d304 100644
--- a/src/main/java/org/assertj/core/internal/Failures.java
+++ b/src/main/java/org/assertj/core/internal/Failures.java
@@ -20,6 +20,7 @@ import java.lang.management.ThreadInfo;
 import java.lang.management.ThreadMXBean;
 
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.configuration.Configuration;
 import org.assertj.core.description.Description;
 import org.assertj.core.error.AssertionErrorCreator;
 import org.assertj.core.error.AssertionErrorFactory;
@@ -60,7 +61,7 @@ public class Failures {
   /**
    * flag indicating whether or not we remove elements related to AssertJ from assertion error stack trace.
    */
-  private boolean removeAssertJRelatedElementsFromStackTrace = true;
+  private boolean removeAssertJRelatedElementsFromStackTrace = Configuration.REMOVE_ASSERTJ_RELATED_ELEMENTS_FROM_STACK_TRACE;
 
   /**
    * Sets whether we remove elements related to AssertJ from assertion error stack trace.
diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index a3529bc68..21fdffe0f 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -52,18 +52,20 @@ import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.concurrent.atomic.AtomicStampedReference;
 import java.util.function.Function;
 
+import org.assertj.core.configuration.Configuration;
 import org.assertj.core.data.MapEntry;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.util.Arrays;
 import org.assertj.core.util.DateUtil;
+import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.diff.ChangeDelta;
 import org.assertj.core.util.diff.DeleteDelta;
 import org.assertj.core.util.diff.InsertDelta;
 
 /**
  * Standard java object representation.
- * 
+ *
  * @author Mariusz Smykula
  */
 public class StandardRepresentation implements Representation {
@@ -89,24 +91,24 @@ public class StandardRepresentation implements Representation {
   public static final String ELEMENT_SEPARATOR = ",";
   public static final String ELEMENT_SEPARATOR_WITH_NEWLINE = ELEMENT_SEPARATOR + System.lineSeparator();
 
-  private static int maxLengthForSingleLineDescription = 80;
+  private static int maxLengthForSingleLineDescription = Configuration.MAX_LENGTH_FOR_SINGLE_LINE_DESCRIPTION;
+  private static int maxElementsForPrinting = Configuration.MAX_ELEMENTS_FOR_PRINTING;
 
   private static final Map<Class<?>, Function<?, String>> customFormatterByType = new HashMap<>();
 
-  private static int maxElementsForPrinting = 1000;
 
   /**
    * It resets the static defaults for the standard representation.
    * <p>
    * The following defaults will be reapplied:
    * <ul>
-   *   <li>{@code maxLengthForSingleLineDescription = 80}</li>
-   *   <li>{@code maxElementsForPrinting = 1000}</li>
+   *   <li>{@code maxLengthForSingleLineDescription} = {@value org.assertj.core.configuration.Configuration#MAX_LENGTH_FOR_SINGLE_LINE_DESCRIPTION} </li>
+   *   <li>{@code maxElementsForPrinting} = {@value org.assertj.core.configuration.Configuration#MAX_ELEMENTS_FOR_PRINTING} </li>
    * </ul>
    */
   public static void resetDefaults() {
-    maxLengthForSingleLineDescription = 80;
-    maxElementsForPrinting = 1000;
+    maxLengthForSingleLineDescription = Configuration.MAX_LENGTH_FOR_SINGLE_LINE_DESCRIPTION;
+    maxElementsForPrinting = Configuration.MAX_ELEMENTS_FOR_PRINTING;
   }
 
   public static void setMaxLengthForSingleLineDescription(int value) {
@@ -114,6 +116,7 @@ public class StandardRepresentation implements Representation {
     maxLengthForSingleLineDescription = value;
   }
 
+  @VisibleForTesting
   public static int getMaxLengthForSingleLineDescription() {
     return maxLengthForSingleLineDescription;
   }
@@ -123,12 +126,17 @@ public class StandardRepresentation implements Representation {
     maxElementsForPrinting = value;
   }
 
+  @VisibleForTesting
+  public static int getMaxElementsForPrinting() {
+    return maxElementsForPrinting;
+  }
+
   /**
    * Registers new formatter for the given type. All instances of the given type will be formatted with the provided formatter.
-   * 
-   * @param <T> the type to register a formatter for  
-   * @param type the class of the type to register a formatter for  
-   * @param formatter the formatter  
+   *
+   * @param <T> the type to register a formatter for
+   * @param type the class of the type to register a formatter for
+   * @param formatter the formatter
    */
   public static <T> void registerFormatterForType(Class<T> type, Function<T, String> formatter) {
     customFormatterByType.put(type, formatter);
@@ -144,7 +152,7 @@ public class StandardRepresentation implements Representation {
   /**
    * Returns standard the {@code toString} representation of the given object. It may or not the object's own
    * implementation of {@code toString}.
-   * 
+   *
    * @param object the given object.
    * @return the {@code toString} representation of the given object.
    */
diff --git a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
index c71346a54..eeb62a1b8 100644
--- a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
@@ -26,6 +26,8 @@ import java.lang.reflect.Field;
 import java.util.Collections;
 import java.util.List;
 
+import org.assertj.core.util.VisibleForTesting;
+
 /**
  * Utility methods for fields access.
  *
@@ -75,6 +77,7 @@ public enum FieldSupport {
     this.allowUsingPrivateFields = allowUsingPrivateFields;
   }
 
+  @VisibleForTesting
   public boolean isAllowedToUsePrivateFields() {
     return allowUsingPrivateFields;
   }
@@ -176,7 +179,7 @@ public enum FieldSupport {
    * <p>
    * Return null if field is nested and one of the nested value is null, ex :
    * <pre><code class='java'> fieldValue(race.name, String.class, frodo); // will return null if frodo.race is null</code></pre>
-   * 
+   *
    * @param <T> the type of the extracted value.
    * @param fieldName the name of the field. It may be a nested field. It is left to the clients to validate for
    *          {@code null} or empty.
diff --git a/src/main/java/org/assertj/core/util/introspection/Introspection.java b/src/main/java/org/assertj/core/util/introspection/Introspection.java
index b827ce23b..cdd522702 100644
--- a/src/main/java/org/assertj/core/util/introspection/Introspection.java
+++ b/src/main/java/org/assertj/core/util/introspection/Introspection.java
@@ -22,6 +22,8 @@ import static org.assertj.core.util.Strings.quote;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
 
+import org.assertj.core.util.VisibleForTesting;
+
 /**
  * Utility methods related to <a
  * href="http://java.sun.com/docs/books/tutorial/javabeans/introspection/index.html">JavaBeans Introspection</a>.
@@ -61,7 +63,12 @@ public final class Introspection {
   }
 
   public static void setExtractBareNamePropertyMethods(boolean barenamePropertyMethods) {
-    Introspection.bareNamePropertyMethods = barenamePropertyMethods;
+    bareNamePropertyMethods = barenamePropertyMethods;
+  }
+
+  @VisibleForTesting
+  public static boolean canIntrospectExtractBareNamePropertyMethods() {
+    return bareNamePropertyMethods;
   }
 
   private static String propertyNotFoundErrorMessage(String propertyName, Object target) {
diff --git a/src/test/java/org/assertj/core/configuration/Configuration_apply_Test.java b/src/test/java/org/assertj/core/configuration/Configuration_apply_Test.java
new file mode 100644
index 000000000..990928a28
--- /dev/null
+++ b/src/test/java/org/assertj/core/configuration/Configuration_apply_Test.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.configuration;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.text.SimpleDateFormat;
+import java.util.Date;
+
+import org.assertj.core.internal.Failures;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.assertj.core.util.introspection.FieldSupport;
+import org.assertj.core.util.introspection.Introspection;
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
+
+public class Configuration_apply_Test {
+
+  @Test
+  public void apply_should_change_assertj_behavior() throws Exception {
+    // GIVEN
+    Configuration configuration = new NonDefaultConfiguration();
+    // WHEN
+    configuration.apply();
+    // THEN
+    assertThat(FieldSupport.extraction().isAllowedToUsePrivateFields()).isEqualTo(configuration.extractingPrivateFieldsEnabled());
+    assertThat(FieldSupport.comparison().isAllowedToUsePrivateFields()).isEqualTo(configuration.comparingPrivateFieldsEnabled());
+    assertThat(Introspection.canIntrospectExtractBareNamePropertyMethods()).isEqualTo(configuration.bareNamePropertyExtractionEnabled());
+    assertThat(configuration.hasCustomRepresentation()).isTrue();
+    // a bit dodgy but since our custom representation inherits StandardRepresentation, changing maxElementsForPrinting amd
+    // maxLengthForSingleLineDescription will be effective.
+    assertThat(StandardRepresentation.getMaxElementsForPrinting()).isEqualTo(configuration.maxElementsForPrinting());
+    assertThat(StandardRepresentation.getMaxLengthForSingleLineDescription()).isEqualTo(configuration.maxLengthForSingleLineDescription());
+    boolean removeAssertJRelatedElementsFromStackTrace = Failures.instance().isRemoveAssertJRelatedElementsFromStackTrace();
+    assertThat(removeAssertJRelatedElementsFromStackTrace).isEqualTo(configuration.removeAssertJRelatedElementsFromStackTraceEnabled());
+    // check lenient is honored by parsing a string that would fail if the DateFormat was not lenient.
+    assertThat(configuration.lenientDateParsingEnabled()).isTrue();
+    Date dateTime = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss").parse("2001-02-03T04:05:06");
+    assertThat(dateTime).isEqualTo("2001-02-03T04:05:06") // passes whether the lenient flag is enabled or not
+                        .isEqualTo("2001-01-34T04:05:06"); // passes only when the lenient flag is enabled
+    // check that additional date formats can be used
+    Date date = new SimpleDateFormat("yyyy-MM-dd").parse("2001-02-03");
+    assertThat(date).isEqualTo("2001_02_03")
+                    .isEqualTo("2001|02|03");
+  }
+
+  @AfterEach
+  public void afterEach() {
+    // revert whatever we did in the other tests
+    Configuration.DEFAULT_CONFIGURATION.apply();
+  }
+}
diff --git a/src/test/java/org/assertj/core/configuration/Configuration_describe_Test.java b/src/test/java/org/assertj/core/configuration/Configuration_describe_Test.java
new file mode 100644
index 000000000..d8030ab7b
--- /dev/null
+++ b/src/test/java/org/assertj/core/configuration/Configuration_describe_Test.java
@@ -0,0 +1,47 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.configuration;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.jupiter.api.AfterEach;
+import org.junit.jupiter.api.Test;
+
+public class Configuration_describe_Test {
+
+  @Test
+  public void should_give_a_human_readable_description() throws Exception {
+    // GIVEN
+    Configuration configuration = new NonDefaultConfiguration();
+    // WHEN
+    String description = configuration.describe();
+    // THEN
+    assertThat(description).isEqualTo(format("- representation .................................. = BinaryRepresentation%n" +
+                                             "- comparingPrivateFieldsEnabled ................... = false%n" +
+                                             "- extractingPrivateFieldsEnabled .................. = false%n" +
+                                             "- bareNamePropertyExtractionEnabled ............... = false%n" +
+                                             "- lenientDateParsingEnabled ....................... = true%n" +
+                                             "- additionnal date formats ........................ = [yyyy_MM_dd, yyyy|MM|dd]%n" +
+                                             "- maxLengthForSingleLineDescription ............... = 81%n" +
+                                             "- maxElementsForPrinting .......................... = 1001%n" +
+                                             "- removeAssertJRelatedElementsFromStackTraceEnabled = false%n"));
+  }
+
+  @AfterEach
+  public void afterEach() {
+    // revert whatever we did in the other tests
+    Configuration.DEFAULT_CONFIGURATION.apply();
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/configuration/NonDefaultConfiguration.java b/src/test/java/org/assertj/core/configuration/NonDefaultConfiguration.java
new file mode 100644
index 000000000..8ed8802b6
--- /dev/null
+++ b/src/test/java/org/assertj/core/configuration/NonDefaultConfiguration.java
@@ -0,0 +1,73 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.configuration;
+
+import static org.assertj.core.presentation.BinaryRepresentation.BINARY_REPRESENTATION;
+import static org.assertj.core.util.Lists.list;
+
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
+import java.util.List;
+
+import org.assertj.core.presentation.Representation;
+
+class NonDefaultConfiguration extends Configuration {
+
+  private static final SimpleDateFormat DATE_FORMAT1 = new SimpleDateFormat("yyyy_MM_dd");
+  private static final SimpleDateFormat DATE_FORMAT2 = new SimpleDateFormat("yyyy|MM|dd");
+
+  @Override
+  public Representation representation() {
+    return BINARY_REPRESENTATION;
+  }
+
+  @Override
+  public boolean bareNamePropertyExtractionEnabled() {
+    return !super.bareNamePropertyExtractionEnabled();
+  }
+
+  @Override
+  public boolean comparingPrivateFieldsEnabled() {
+    return !super.comparingPrivateFieldsEnabled();
+  }
+
+  @Override
+  public boolean extractingPrivateFieldsEnabled() {
+    return !super.extractingPrivateFieldsEnabled();
+  }
+
+  @Override
+  public int maxElementsForPrinting() {
+    return super.maxElementsForPrinting() + 1;
+  }
+
+  @Override
+  public int maxLengthForSingleLineDescription() {
+    return super.maxLengthForSingleLineDescription() + 1;
+  }
+
+  @Override
+  public boolean removeAssertJRelatedElementsFromStackTraceEnabled() {
+    return !super.removeAssertJRelatedElementsFromStackTraceEnabled();
+  }
+
+  @Override
+  public boolean lenientDateParsingEnabled() {
+    return !super.lenientDateParsingEnabled();
+  }
+
+  @Override
+  public List<DateFormat> additionalDateFormats() {
+    return list(DATE_FORMAT1, DATE_FORMAT2);
+  }
+}
\ No newline at end of file
