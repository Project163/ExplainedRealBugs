diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index b545cbba5..7e1c4ef44 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -25,8 +25,10 @@ import java.util.OptionalLong;
 import java.util.function.BiPredicate;
 
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
+import org.assertj.core.api.recursive.comparison.DefaultRecursiveComparisonIntrospectionStrategy;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCalculator;
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonIntrospectionStrategy;
 import org.assertj.core.internal.TypeComparators;
 import org.assertj.core.util.CheckReturnValue;
 import org.assertj.core.util.introspection.IntrospectionError;
@@ -1454,6 +1456,24 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Defines how objects are introspected in the recursive comparison, that is:
+   * <ul>
+   *  <li>how to traverse the graph of nodes to compare</li>
+   *  <li>how to get a node value</li>
+   *  </ul>
+   * <p>
+   * Default to {@link DefaultRecursiveComparisonIntrospectionStrategy} that introspects all fields (including inherited ones).
+   *
+   * @param introspectionStrategy the {@link RecursiveComparisonIntrospectionStrategy} to use
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   */
+  @CheckReturnValue
+  public SELF withIntrospectionStrategy(RecursiveComparisonIntrospectionStrategy introspectionStrategy) {
+    recursiveComparisonConfiguration.setIntrospectionStrategy(introspectionStrategy);
+    return myself;
+  }
+
   SELF withTypeComparators(TypeComparators typeComparators) {
     Optional.ofNullable(typeComparators)
             .map(TypeComparators::comparatorByTypes)
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DefaultRecursiveComparisonIntrospectionStrategy.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DefaultRecursiveComparisonIntrospectionStrategy.java
new file mode 100644
index 000000000..8ad82bf24
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DefaultRecursiveComparisonIntrospectionStrategy.java
@@ -0,0 +1,40 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.util.introspection.PropertyOrFieldSupport.COMPARISON;
+
+import java.util.HashSet;
+import java.util.Set;
+
+import org.assertj.core.internal.Objects;
+import org.assertj.core.util.introspection.PropertyOrFieldSupport;
+
+/**
+ * Introspects all fields (including inherited ones) and get their value according to {@link PropertyOrFieldSupport#getSimpleValue(String, Object)}.
+ * <p>
+ * There is a bit of discrepancy in this strategy as it looks for fields to compare but gets the value in this order: property
+ * first, then field and finally tries as map value if the instance is a map.
+ */
+public class DefaultRecursiveComparisonIntrospectionStrategy implements RecursiveComparisonIntrospectionStrategy {
+
+  @Override
+  public Set<String> getChildrenNodeNamesOf(Object node) {
+    return node == null ? new HashSet<>() : Objects.getFieldsNames(node.getClass());
+  }
+
+  @Override
+  public Object getChildNodeValue(String childNodeName, Object instance) {
+    return COMPARISON.getSimpleValue(childNodeName, instance);
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
index 77904cbc7..5d652b019 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
@@ -132,7 +132,7 @@ public final class FieldLocation implements Comparable<FieldLocation> {
    * @return true if this has the given parent (direct or indirect), false otherwise.
    */
   public boolean hasParent(FieldLocation parent) {
-    // "." garantees that we compare path elements, this avoid making "name" a parent of "names"
+    // "." guarantees that we compare path elements, this avoids making "name" a parent of "names"
     return pathToUseInRules.startsWith(parent.pathToUseInRules + ".");
   }
 
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 26ac585b6..8146fde3b 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -22,7 +22,6 @@ import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
-import static org.assertj.core.util.introspection.PropertyOrFieldSupport.COMPARISON;
 
 import java.util.ArrayList;
 import java.util.Comparator;
@@ -37,7 +36,6 @@ import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert;
 import org.assertj.core.api.recursive.AbstractRecursiveOperationConfiguration;
-import org.assertj.core.internal.Objects;
 import org.assertj.core.internal.TypeComparators;
 import org.assertj.core.internal.TypeMessages;
 import org.assertj.core.presentation.Representation;
@@ -47,6 +45,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private static final boolean DEFAULT_IGNORE_ALL_OVERRIDDEN_EQUALS = true;
   public static final String INDENT_LEVEL_2 = "  -";
+  public static final DefaultRecursiveComparisonIntrospectionStrategy DEFAULT_RECURSIVE_COMPARISON_INTROSPECTION_STRATEGY = new DefaultRecursiveComparisonIntrospectionStrategy();
   private boolean strictTypeChecking = false;
 
   // fields to ignore section
@@ -81,7 +80,9 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   // track field locations of fields of type to compare, needed to compare child nodes
   // for example if we want to compare Person type, we must compare Person fields too event thought they are not of type Person
-  private Set<FieldLocation> fieldLocationOfFieldsOfTypesToCompare = new LinkedHashSet<>();
+  private final Set<FieldLocation> fieldLocationOfFieldsOfTypesToCompare = new LinkedHashSet<>();
+
+  private RecursiveComparisonIntrospectionStrategy introspectionStrategy = DEFAULT_RECURSIVE_COMPARISON_INTROSPECTION_STRATEGY;
 
   private RecursiveComparisonConfiguration(Builder builder) {
     super(builder);
@@ -102,6 +103,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     this.fieldComparators = builder.fieldComparators;
     this.fieldMessages = builder.fieldMessages;
     this.typeMessages = builder.typeMessages;
+    this.introspectionStrategy = builder.introspectionStrategy;
   }
 
   public RecursiveComparisonConfiguration() {
@@ -551,6 +553,21 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return fieldComparators.comparatorByFields();
   }
 
+  RecursiveComparisonIntrospectionStrategy getIntrospectionStrategy() {
+    return introspectionStrategy;
+  }
+
+  /**
+   * Defines how objects are introspected in the recursive comparison.
+   * <p>
+   * Default to {@link DefaultRecursiveComparisonIntrospectionStrategy}.
+   *
+   * @param introspectionStrategy the {@link RecursiveComparisonIntrospectionStrategy} to use
+   */
+  public void setIntrospectionStrategy(RecursiveComparisonIntrospectionStrategy introspectionStrategy) {
+    this.introspectionStrategy = introspectionStrategy;
+  }
+
   @Override
   public String toString() {
     return multiLineDescription(CONFIGURATION_PROVIDER.representation());
@@ -617,6 +634,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     describeTypeCheckingStrictness(description);
     describeRegisteredErrorMessagesForFields(description);
     describeRegisteredErrorMessagesForTypes(description);
+    describeIntrospectionStrategy(description);
     return description.toString();
   }
 
@@ -643,23 +661,31 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
                             || field.hasChild(comparedField); // ex: field "name" and "name.first" compared field
   }
 
-  Set<String> getActualFieldNamesToCompare(DualValue dualValue) {
-    Set<String> actualFieldsNames = Objects.getFieldsNames(dualValue.actual.getClass());
+  Set<String> getActualChildrenNodeNamesToCompare(DualValue dualValue) {
+    Set<String> actualChildrenNodeNames = getChildrenNodeNamesOf(dualValue.actual);
     // we are doing the same as shouldIgnore(DualValue dualValue) but in two steps for performance reasons:
-    // - we filter first ignored field by names that don't need building DualValues
-    // - then we filter field DualValues with the remaining criteria that need to get the field value
-    // DualValues are built introspecting fields which is expensive.
-    return actualFieldsNames.stream()
-                            // evaluate field name ignoring criteria
-                            .filter(fieldName -> !shouldIgnoreFieldBasedOnFieldLocation(dualValue.fieldLocation.field(fieldName)))
-                            .map(fieldName -> dualValueForField(dualValue, fieldName))
-                            // evaluate field value ignoring criteria
-                            .filter(fieldDualValue -> !shouldIgnoreFieldBasedOnFieldValue(fieldDualValue))
-                            .filter(this::shouldBeCompared)
-                            // back to field name
-                            .map(DualValue::getFieldName)
-                            .filter(fieldName -> !fieldName.isEmpty())
-                            .collect(toSet());
+    // - we filter first ignored nodes by names that don't need building DualValues
+    // - then we filter field DualValues with the remaining criteria that need to get the node value
+    // DualValues are built by introspecting node values which is expensive.
+    return actualChildrenNodeNames.stream()
+                                  // evaluate field name ignoring criteria on dualValue field location + field name
+                                  .filter(fieldName -> !shouldIgnoreFieldBasedOnFieldLocation(dualValue.fieldLocation.field(fieldName)))
+                                  .map(fieldName -> dualValueForField(dualValue, fieldName))
+                                  // evaluate field value ignoring criteria
+                                  .filter(fieldDualValue -> !shouldIgnoreFieldBasedOnFieldValue(fieldDualValue))
+                                  .filter(this::shouldBeCompared)
+                                  // back to field name
+                                  .map(DualValue::getFieldName)
+                                  .filter(fieldName -> !fieldName.isEmpty())
+                                  .collect(toSet());
+  }
+
+  Set<String> getChildrenNodeNamesOf(Object instance) {
+    return introspectionStrategy.getChildrenNodeNamesOf(instance);
+  }
+
+  Object getValue(String name, Object instance) {
+    return introspectionStrategy.getChildNodeValue(name, instance);
   }
 
   // non accessible stuff
@@ -674,12 +700,12 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return matchesAnIgnoredField(fieldLocation) || matchesAnIgnoredFieldRegex(fieldLocation);
   }
 
-  private static DualValue dualValueForField(DualValue parentDualValue, String fieldName) {
-    Object actualFieldValue = COMPARISON.getSimpleValue(fieldName, parentDualValue.actual);
+  private DualValue dualValueForField(DualValue parentDualValue, String fieldName) {
+    Object actualFieldValue = getValue(fieldName, parentDualValue.actual);
     // no guarantees we have a field in expected named as fieldName
     Object expectedFieldValue;
     try {
-      expectedFieldValue = COMPARISON.getSimpleValue(fieldName, parentDualValue.expected);
+      expectedFieldValue = getValue(fieldName, parentDualValue.expected);
     } catch (@SuppressWarnings("unused") Exception e) {
       // set the field to null to express it is absent, this not 100% accurate as the value could be null,
       // but it works to evaluate if dualValue should be ignored with matchesAnIgnoredFieldType
@@ -740,8 +766,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   protected void describeIgnoreAllActualEmptyOptionalFields(StringBuilder description) {
     if (ignoreAllActualEmptyOptionalFields)
-      description.append(format(
-        "- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n"));
+      description.append(format("- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n"));
   }
 
   private void describeIgnoreAllExpectedNullFields(StringBuilder description) {
@@ -750,8 +775,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private void describeOverriddenEqualsMethodsUsage(StringBuilder description, Representation representation) {
     String header = ignoreAllOverriddenEquals
-      ? "- no overridden equals methods were used in the comparison (except for java types)"
-      : "- overridden equals methods were used in the comparison";
+        ? "- no overridden equals methods were used in the comparison (except for java types)"
+        : "- overridden equals methods were used in the comparison";
     description.append(header);
     if (isConfiguredToIgnoreSomeButNotAllOverriddenEqualsMethods()) {
       description.append(format(" except for:%n"));
@@ -796,9 +821,12 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private void describeIgnoredCollectionOrderInFieldsMatchingRegexes(StringBuilder description) {
     if (!ignoredCollectionOrderInFieldsMatchingRegexes.isEmpty())
-      description.append(
-        format("- collection order was ignored in the fields matching the following regexes in the comparison: %s%n",
-               describeRegexes(ignoredCollectionOrderInFieldsMatchingRegexes)));
+      description.append(format("- collection order was ignored in the fields matching the following regexes in the comparison: %s%n",
+                                describeRegexes(ignoredCollectionOrderInFieldsMatchingRegexes)));
+  }
+
+  private void describeIntrospectionStrategy(StringBuilder description) {
+    description.append(format("- the introspection strategy used was: %s%n", introspectionStrategy.getDescription()));
   }
 
   private boolean matchesAnIgnoredOverriddenEqualsRegex(FieldLocation fieldLocation) {
@@ -840,7 +868,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   private boolean shouldBeComparedBasedOnFieldValue(DualValue dualValue) {
     // first check if the value has a parent of a type we need to compare, ex: we compare Person types and the value is
     // corresponds to one of the Person fields. If this is not the case, we check actual type against the types
-    // to compare, we use expected type in case actual was null as a best effort assuming expected has the same type as actual
+    // to compare, we use expected type in case actual was null assuming expected has the same type as actual
     if (fieldLocationOfFieldsOfTypesToCompare.stream().anyMatch(dualValue.fieldLocation::hasParent)
         || (dualValue.actual != null && comparedTypes.contains(dualValue.actual.getClass()))
         || (dualValue.expected != null && comparedTypes.contains(dualValue.expected.getClass()))) {
@@ -940,8 +968,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private void describeTypeCheckingStrictness(StringBuilder description) {
     String str = strictTypeChecking
-      ? "- actual and expected objects and their fields were considered different when of incompatible types (i.e. expected type does not extend actual's type) even if all their fields match, for example a Person instance will never match a PersonDto (call strictTypeChecking(false) to change that behavior).%n"
-      : "- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).%n";
+        ? "- actual and expected objects and their fields were considered different when of incompatible types (i.e. expected type does not extend actual's type) even if all their fields match, for example a Person instance will never match a PersonDto (call strictTypeChecking(false) to change that behavior).%n"
+        : "- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).%n";
     description.append(format(str));
   }
 
@@ -984,7 +1012,6 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return new Builder();
   }
 
-
   /**
    * Builder to build {@link RecursiveComparisonConfiguration}.
    */
@@ -1007,6 +1034,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     private final FieldMessages fieldMessages = new FieldMessages();
     private final TypeMessages typeMessages = new TypeMessages();
 
+    private RecursiveComparisonIntrospectionStrategy introspectionStrategy = DEFAULT_RECURSIVE_COMPARISON_INTROSPECTION_STRATEGY;
+
     private Builder() {
       super(Builder.class);
     }
@@ -1359,6 +1388,19 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
       return super.withIgnoredFieldsOfTypes(types);
     }
 
+    /**
+     * Defines how objects are introspected in the recursive comparison.
+     * <p>
+     * Default to {@link DefaultRecursiveComparisonIntrospectionStrategy}.
+     *
+     * @param introspectionStrategy the {@link RecursiveComparisonIntrospectionStrategy} to use
+     * @return This builder.
+     */
+    public RecursiveComparisonConfiguration.Builder withIntrospectionStrategy(RecursiveComparisonIntrospectionStrategy introspectionStrategy) {
+      this.introspectionStrategy = introspectionStrategy;
+      return this;
+    }
+
     public RecursiveComparisonConfiguration build() {
       return new RecursiveComparisonConfiguration(this);
     }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 46a8c215b..d9ed851f2 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -18,12 +18,10 @@ import static java.util.stream.Collectors.joining;
 import static org.assertj.core.api.recursive.comparison.ComparisonDifference.rootComparisonDifference;
 import static org.assertj.core.api.recursive.comparison.DualValue.DEFAULT_ORDERED_COLLECTION_TYPES;
 import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
-import static org.assertj.core.internal.Objects.getFieldsNames;
 import static org.assertj.core.util.IterableUtil.sizeOf;
 import static org.assertj.core.util.IterableUtil.toCollection;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newHashSet;
-import static org.assertj.core.util.introspection.PropertyOrFieldSupport.COMPARISON;
 
 import java.lang.reflect.Array;
 import java.util.ArrayList;
@@ -117,25 +115,26 @@ public class RecursiveComparisonDifferenceCalculator {
       if (!visitedDualValues.contains(dualValue)) dualValuesToCompare.addFirst(dualValue);
     }
 
-    private void initDualValuesToCompare(Object actual, Object expected, FieldLocation fieldLocation) {
-      DualValue dualValue = new DualValue(fieldLocation, actual, expected);
-      boolean mustCompareFieldsRecursively = mustCompareFieldsRecursively(dualValue);
-      if (dualValue.hasNoNullValues() && mustCompareFieldsRecursively) {
+    private void initDualValuesToCompare(Object actual, Object expected, FieldLocation nodeLocation) {
+      DualValue dualValue = new DualValue(nodeLocation, actual, expected);
+      boolean mustCompareNodesRecursively = mustCompareNodesRecursively(dualValue);
+      if (dualValue.hasNoNullValues() && mustCompareNodesRecursively) {
         // disregard the equals method and start comparing fields
         // TODO should fail if actual and expected don't have the same fields to compare (taking into account ignored/compared
         // fields)
-        Set<String> actualFieldNamesToCompare = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
-        if (!actualFieldNamesToCompare.isEmpty()) {
+        Set<String> actualChildrenNodeNamesToCompare = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
+        if (!actualChildrenNodeNamesToCompare.isEmpty()) {
           // fields to ignore are evaluated when adding their corresponding dualValues to dualValuesToCompare which filters
           // ignored fields according to recursiveComparisonConfiguration
-          Set<String> expectedFieldsNames = getFieldsNames(expected.getClass());
-          if (expectedFieldsNames.containsAll(actualFieldNamesToCompare)) {
+          Set<String> expectedChildrenNodesNames = recursiveComparisonConfiguration.getChildrenNodeNamesOf(expected);
+          if (expectedChildrenNodesNames.containsAll(actualChildrenNodeNamesToCompare)) {
             // we compare actual fields vs expected, ignoring expected additional fields
-            for (String nonIgnoredActualFieldName : actualFieldNamesToCompare) {
-              DualValue fieldDualValue = new DualValue(fieldLocation.field(nonIgnoredActualFieldName),
-                                                       COMPARISON.getSimpleValue(nonIgnoredActualFieldName, actual),
-                                                       COMPARISON.getSimpleValue(nonIgnoredActualFieldName, expected));
-              dualValuesToCompare.addFirst(fieldDualValue);
+            for (String actualChildNodeName : actualChildrenNodeNamesToCompare) {
+              Object actualChildNodeValue = recursiveComparisonConfiguration.getValue(actualChildNodeName, actual);
+              Object expectedChildNodeValue = recursiveComparisonConfiguration.getValue(actualChildNodeName, expected);
+              DualValue childNodeDualValue = new DualValue(nodeLocation.field(actualChildNodeName), actualChildNodeValue,
+                                                           expectedChildNodeValue);
+              dualValuesToCompare.addFirst(childNodeDualValue);
             }
           } else {
             dualValuesToCompare.addFirst(dualValue);
@@ -146,7 +145,7 @@ public class RecursiveComparisonDifferenceCalculator {
       } else {
         dualValuesToCompare.addFirst(dualValue);
       }
-      // We need to remove already visited fields pair to avoid infinite recursion in case parent -> set{child} with child having
+      // We need to remove already visited nodes pair to avoid infinite recursion in case parent -> set{child} with child having
       // a reference back to its parent but only for complex types can have cycle, this is not the case for primitive or enums.
       // It occurs for unordered collection where we compare all possible combination of the collection elements recursively.
       // --
@@ -157,7 +156,7 @@ public class RecursiveComparisonDifferenceCalculator {
                                                                        .ifPresent(dualValuesToCompare::remove));
     }
 
-    private boolean mustCompareFieldsRecursively(DualValue dualValue) {
+    private boolean mustCompareNodesRecursively(DualValue dualValue) {
 
       return !recursiveComparisonConfiguration.hasCustomComparator(dualValue)
              && !shouldHonorEquals(dualValue, recursiveComparisonConfiguration)
@@ -322,28 +321,29 @@ public class RecursiveComparisonDifferenceCalculator {
         continue;
       }
 
-      Set<String> actualNonIgnoredFieldsNames = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
-      Set<String> expectedFieldsNames = getFieldsNames(expectedFieldClass);
-      // Check if expected has more fields than actual, in that case the additional fields are reported as difference
-      if (!expectedFieldsNames.containsAll(actualNonIgnoredFieldsNames)) {
-        // report missing fields in actual
-        Set<String> actualFieldsNamesNotInExpected = newHashSet(actualNonIgnoredFieldsNames);
-        actualFieldsNamesNotInExpected.removeAll(expectedFieldsNames);
-        String missingFields = actualFieldsNamesNotInExpected.toString();
+      Set<String> actualChildrenNodeNamesToCompare = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
+      Set<String> expectedChildrenNodesNames = recursiveComparisonConfiguration.getChildrenNodeNamesOf(expectedFieldValue);
+      // Check if expected has more children nodes than actual, in that case the additional nodes are reported as difference
+      if (!expectedChildrenNodesNames.containsAll(actualChildrenNodeNamesToCompare)) {
+        // report missing nodes in actual
+        Set<String> actualNodesNamesNotInExpected = newHashSet(actualChildrenNodeNamesToCompare);
+        actualNodesNamesNotInExpected.removeAll(expectedChildrenNodesNames);
+        String missingNodes = actualNodesNamesNotInExpected.toString();
         String expectedClassName = expectedFieldClass.getName();
         String actualClassName = actualFieldValueClass.getName();
-        String missingFieldsDescription = format(MISSING_FIELDS, actualClassName, expectedClassName,
-                                                 expectedFieldClass.getSimpleName(), actualFieldValueClass.getSimpleName(),
-                                                 missingFields);
-        comparisonState.addDifference(dualValue, missingFieldsDescription);
+        String missingNodesDescription = format(MISSING_FIELDS, actualClassName, expectedClassName,
+                                                expectedFieldClass.getSimpleName(), actualFieldValueClass.getSimpleName(),
+                                                missingNodes);
+        comparisonState.addDifference(dualValue, missingNodesDescription);
       } else { // TODO remove else to report more diff
-        // compare actual's fields against expected :
-        // - if actual has more fields than expected, the additional fields are ignored as expected is the reference
-        for (String actualFieldName : actualNonIgnoredFieldsNames) {
-          if (expectedFieldsNames.contains(actualFieldName)) {
-            DualValue newDualValue = new DualValue(dualValue.fieldLocation.field(actualFieldName),
-                                                   COMPARISON.getSimpleValue(actualFieldName, actualFieldValue),
-                                                   COMPARISON.getSimpleValue(actualFieldName, expectedFieldValue));
+        // compare actual's children nodes against expected:
+        // - if actual has more nodes than expected, the additional nodes are ignored as expected is the reference
+        for (String actualChildNodeName : actualChildrenNodeNamesToCompare) {
+          if (expectedChildrenNodesNames.contains(actualChildNodeName)) {
+            Object actualChildNodeValue = recursiveComparisonConfiguration.getValue(actualChildNodeName, actualFieldValue);
+            Object expectedChildNodeValue = recursiveComparisonConfiguration.getValue(actualChildNodeName, expectedFieldValue);
+            DualValue newDualValue = new DualValue(dualValue.fieldLocation.field(actualChildNodeName),
+                                                   actualChildNodeValue, expectedChildNodeValue);
             comparisonState.registerForComparison(newDualValue);
           }
         }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy.java
new file mode 100644
index 000000000..ffc99e1a7
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonIntrospectionStrategy.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import java.util.Set;
+
+import org.assertj.core.annotations.Beta;
+
+/**
+ * Defines how objects are introspected in the recursive comparison, the main operations it specifies are:
+ * <ul>
+ * <li>how to traverse the graph of nodes to compare</li>
+ * <li>how to get a child node value</li>
+ * </ul>
+ */
+@Beta
+public interface RecursiveComparisonIntrospectionStrategy {
+
+  /**
+   * Returns the names of the children nodes of the given object that will be used in the recursive comparison.
+   * <p>
+   * A typical implementation could look at the object fields or properties.
+   *
+   * @param node the object to get the child nodes from
+   * @return the names of the children nodes of the given object
+   */
+  Set<String> getChildrenNodeNamesOf(Object node);
+
+  /**
+   * Returns the value of the given object child node, the child node being identified by the childNodeName parameter.
+   * <p>
+   * It's the implementor choice how to resolve the child node value, a typical implementation consists of considering
+   * childNodeName to be a field name and then use introspection to read the field value, but if the object is a Map
+   * the implementation could consider the child node name to be a key of the map.
+   *
+   * @param childNodeName the child node identifier
+   * @param object the object to read the child node from
+   * @return the object child node value
+   */
+  Object getChildNodeValue(String childNodeName, Object object);
+
+  /**
+   * Returns a human-readable description of the strategy to be used in error messages.
+   * <p>
+   * The default implementation returns {@code this.getClass().getSimpleName()}.
+   *
+   * @return a description of the strategy
+   */
+  default String getDescription() {
+    return this.getClass().getSimpleName();
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/Objects.java b/assertj-core/src/main/java/org/assertj/core/internal/Objects.java
index 169d5425f..9b30b4e93 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/Objects.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/Objects.java
@@ -815,11 +815,11 @@ public class Objects {
   public static Set<Field> getDeclaredFieldsIncludingInherited(Class<?> clazz) {
     requireNonNull(clazz, "expecting Class parameter not to be null");
     Set<Field> declaredFields = getDeclaredFieldsIgnoringSyntheticAndStatic(clazz);
-    // get fields declared in superclass
-    Class<?> superclazz = clazz.getSuperclass();
-    while (superclazz != null && !superclazz.getName().startsWith("java.lang")) {
-      declaredFields.addAll(getDeclaredFieldsIgnoringSyntheticAndStatic(superclazz));
-      superclazz = superclazz.getSuperclass();
+    // get fields declared in superClass
+    Class<?> superClass = clazz.getSuperclass();
+    while (superClass != null && !superClass.getName().startsWith("java.lang")) {
+      declaredFields.addAll(getDeclaredFieldsIgnoringSyntheticAndStatic(superClass));
+      superClass = superClass.getSuperclass();
     }
     return declaredFields;
   }
@@ -842,8 +842,7 @@ public class Objects {
    * @return the declared fields of given class excluding any synthetic fields.
    */
   private static Set<Field> getDeclaredFieldsIgnoringSyntheticAndStatic(Class<?> clazz) {
-    return stream(clazz.getDeclaredFields()).filter(field -> !(field.isSynthetic()
-                                                               || Modifier.isStatic(field.getModifiers())))
+    return stream(clazz.getDeclaredFields()).filter(field -> !(field.isSynthetic() || Modifier.isStatic(field.getModifiers())))
                                             .collect(toCollection(LinkedHashSet::new));
   }
 
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java
new file mode 100644
index 000000000..183873319
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test.java
@@ -0,0 +1,436 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static java.util.Arrays.asList;
+import static java.util.Arrays.stream;
+import static java.util.stream.Collectors.toCollection;
+import static java.util.stream.Collectors.toSet;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.introspection.PropertyOrFieldSupport.COMPARISON;
+
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.Optional;
+import java.util.Set;
+
+import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
+import org.assertj.core.internal.Objects;
+import org.assertj.core.internal.objects.data.Person;
+import org.assertj.core.util.introspection.FieldSupport;
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.assertj.core.util.introspection.PropertySupport;
+import org.junit.jupiter.api.Test;
+
+import com.google.common.base.CaseFormat;
+
+class RecursiveComparisonAssert_isEqualTo_withIntrospectionStrategy_Test
+    extends RecursiveComparisonAssert_isEqualTo_BaseTest {
+
+  RecursiveComparisonIntrospectionStrategy comparingFieldsNameContaining_o = new ComparingFieldsNameContaining_o();
+
+  @Test
+  void should_pass_with_the_specified_comparison_strategy() {
+    // GIVEN
+    Person actual = new Person("John");
+    actual.home.address.number = 1;
+    Person expected = new Person("Steve");
+    expected.home.address.number = 2;
+    // compared fields
+    actual.dateOfBirth = new Date(123);
+    expected.dateOfBirth = new Date(123);
+    actual.phone = Optional.of("6677889900");
+    expected.phone = Optional.of("6677889900");
+    actual.neighbour = new Person("John neighbour"); // names are not compared
+    expected.neighbour = new Person("Steve neighbour");
+    actual.neighbour.dateOfBirth = new Date(456);
+    expected.neighbour.dateOfBirth = new Date(456);
+    actual.neighbour.phone = Optional.of("1122334455");
+    expected.neighbour.phone = Optional.of("1122334455");
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withIntrospectionStrategy(comparingFieldsNameContaining_o)
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_report_differences_with_the_specified_comparison_strategy() {
+    // GIVEN
+    Person actual = new Person("John");
+    actual.home.address.number = 1;
+    Person expected = new Person("Steve");
+    expected.home.address.number = 2;
+    // compared fields
+    actual.dateOfBirth = new Date(123);
+    expected.dateOfBirth = new Date(123);
+    actual.phone = Optional.of("123");
+    expected.phone = Optional.of("456");
+    actual.neighbour = new Person("John neighbour"); // names are not compared
+    expected.neighbour = new Person("Steve neighbour");
+    actual.neighbour.dateOfBirth = new Date(456);
+    expected.neighbour.dateOfBirth = new Date(789);
+    actual.neighbour.phone = Optional.of("1122334455");
+    expected.neighbour.phone = Optional.of("1122334455");
+
+    recursiveComparisonConfiguration.setIntrospectionStrategy(comparingFieldsNameContaining_o);
+
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+
+    // THEN
+    ComparisonDifference phoneDifference = diff("phone.value", actual.phone.get(), expected.phone.get());
+    ComparisonDifference neighbourDateOfBirthDifference = diff("neighbour.dateOfBirth",
+                                                               actual.neighbour.dateOfBirth,
+                                                               expected.neighbour.dateOfBirth);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, neighbourDateOfBirthDifference, phoneDifference);
+  }
+
+  static class ComparingFieldsNameContaining_o implements RecursiveComparisonIntrospectionStrategy {
+
+    @Override
+    public Set<String> getChildrenNodeNamesOf(Object node) {
+      if (node == null) return new HashSet<>();
+      Set<String> fieldsNames = Objects.getFieldsNames(node.getClass());
+      return fieldsNames.stream().filter(name -> name.toLowerCase().contains("o")).collect(toSet());
+    }
+
+    @Override
+    public Object getChildNodeValue(String childNodeName, Object instance) {
+      return COMPARISON.getSimpleValue(childNodeName, instance);
+    }
+
+    @Override
+    public String getDescription() {
+      return "comparing fields containing o";
+    }
+  }
+
+  // addresses https://github.com/assertj/assertj/issues/2554
+
+  @Test
+  void should_pass_with_the_snake_case_matching_camel_case_fields() {
+    // GIVEN
+    Author martinFowler = new Author("Martin", "Fowler");
+    Book refactoring = new Book("Refactoring", martinFowler);
+    AuthorDto martinFowlerDto = new AuthorDto("Martin", "Fowler");
+    BookDto refactoringDto = new BookDto("Refactoring", martinFowlerDto);
+    RecursiveComparisonIntrospectionStrategy comparingSnakeOrCamelCaseFields = new ComparingSnakeOrCamelCaseFields();
+
+    // WHEN/THEN
+    then(refactoring).usingRecursiveComparison()
+                     .withIntrospectionStrategy(comparingSnakeOrCamelCaseFields)
+                     .isEqualTo(refactoringDto);
+  }
+
+  static class Author {
+    String firstName;
+    String lastName;
+
+    Author(String firstName, String lastName) {
+      this.firstName = firstName;
+      this.lastName = lastName;
+    }
+  }
+
+  static class Book {
+    String title;
+    Author mainAuthor;
+
+    Book(String title, Author author) {
+      this.title = title;
+      this.mainAuthor = author;
+    }
+  }
+  static class AuthorDto {
+    String first_name;
+    String last_name;
+
+    AuthorDto(String firstName, String lastName) {
+      this.first_name = firstName;
+      this.last_name = lastName;
+    }
+  }
+
+  static class BookDto {
+    String title;
+    AuthorDto main_author;
+
+    BookDto(String title, AuthorDto author) {
+      this.title = title;
+      this.main_author = author;
+    }
+  }
+  static class ComparingSnakeOrCamelCaseFields implements RecursiveComparisonIntrospectionStrategy {
+
+    @Override
+    public Set<String> getChildrenNodeNamesOf(Object node) {
+      if (node == null) return new HashSet<>();
+      Set<String> fieldsNames = Objects.getFieldsNames(node.getClass());
+      return fieldsNames.stream().map(ComparingSnakeOrCamelCaseFields::toCamelCase).collect(toSet());
+    }
+
+    static String toCamelCase(String name) {
+      return name.contains("_") ? CaseFormat.LOWER_UNDERSCORE.to(CaseFormat.LOWER_CAMEL, name) : name;
+    }
+
+    static String toSnakeCase(String name) {
+      return CaseFormat.LOWER_CAMEL.to(CaseFormat.LOWER_UNDERSCORE, name);
+    }
+
+    @Override
+    public Object getChildNodeValue(String childNodeName, Object instance) {
+      try {
+        return COMPARISON.getSimpleValue(childNodeName, instance);
+      } catch (Exception e) {
+        // try snake case
+        return COMPARISON.getSimpleValue(toSnakeCase(childNodeName), instance);
+      }
+    }
+
+    @Override
+    public String getDescription() {
+      return "comparing camel case and snake case fields";
+    }
+  }
+
+  // related to https://github.com/assertj/assertj/issues/2314 and https://github.com/assertj/assertj/issues/2108
+
+  @Test
+  void should_pass_with_property_based_introspection_for_2314() {
+    // GIVEN
+    Message actual = new HelloMessage();
+    Message expected = new GenericMessage("hello");
+    ComparingProperties comparingProperties = new ComparingProperties();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withIntrospectionStrategy(comparingProperties)
+                .isEqualTo(expected);
+
+    // note that the following assertion succeeds because the default behavior is to look for actual fields but not properties and
+    // HelloMessage does not have fields
+    // then(actual).usingRecursiveComparison().isEqualTo(expected);
+  }
+
+  static class ComparingProperties implements RecursiveComparisonIntrospectionStrategy {
+
+    static final String GET_PREFIX = "get";
+    static final String IS_PREFIX = "is";
+
+    @Override
+    public Set<String> getChildrenNodeNamesOf(Object node) {
+      return node == null ? new HashSet<>() : getPropertiesNames(node.getClass());
+    }
+
+    @Override
+    public Object getChildNodeValue(String childNodeName, Object instance) {
+      return PropertySupport.instance().propertyValueOf(childNodeName, Object.class, instance);
+    }
+
+    @Override
+    public String getDescription() {
+      return "comparing properties";
+    }
+
+    static Set<String> getPropertiesNames(Class<?> clazz) {
+      return gettersIncludingInheritedOf(clazz).stream()
+                                               .map(Method::getName)
+                                               .map(methodName -> toPropertyName(methodName))
+                                               .collect(toSet());
+    }
+
+    private static String toPropertyName(String methodName) {
+      String propertyWithCapitalLetter = methodName.startsWith(GET_PREFIX)
+          ? methodName.substring(GET_PREFIX.length())
+          : methodName.substring(IS_PREFIX.length());
+      return propertyWithCapitalLetter.toLowerCase().charAt(0) + propertyWithCapitalLetter.substring(1);
+    }
+
+    public static Set<Method> gettersIncludingInheritedOf(Class<?> clazz) {
+      Set<Method> getters = gettersOf(clazz);
+      // get fields declared in superClass
+      Class<?> superClass = clazz.getSuperclass();
+      while (superClass != null && !superClass.getName().startsWith("java.lang")) {
+        getters.addAll(gettersOf(superClass));
+        superClass = superClass.getSuperclass();
+      }
+      return getters;
+    }
+
+    private static Set<Method> gettersOf(Class<?> clazz) {
+      return stream(clazz.getDeclaredMethods()).filter(method -> !Modifier.isStatic(method.getModifiers()))
+                                               .filter(method -> method.getName().startsWith(GET_PREFIX)
+                                                                 || method.getName().startsWith(IS_PREFIX))
+                                               .collect(toCollection(LinkedHashSet::new));
+    }
+
+    private static boolean isGetters(Method method) {
+      boolean startsWithGet = method.getName().startsWith(GET_PREFIX);
+      return startsWithGet || (method.getName().startsWith(IS_PREFIX) && method.getReturnType().equals(Boolean.class));
+    }
+
+  }
+
+  interface Message {
+    String getTemplate();
+
+    boolean isEmpty();
+  }
+  class HelloMessage implements Message {
+    public final String getTemplate() {
+      return "hello";
+    }
+
+    @Override
+    public boolean isEmpty() {
+      return false;
+    }
+
+  }
+
+  class GenericMessage implements Message {
+    String template;
+    boolean empty;
+
+    public GenericMessage(String template) {
+      this.template = template;
+      this.empty = template == null || template.isEmpty();
+    }
+
+    @Override
+    public String getTemplate() {
+      return template;
+    }
+
+    @Override
+    public boolean isEmpty() {
+      return empty;
+    }
+  }
+
+  // https://github.com/assertj/assertj/issues/2108
+
+  @Test
+  void should_detect_badly_set_optional_2108() {
+    // GIVEN
+    Bean actual = new Bean();
+    Bean expected = new Bean();
+    ComparingProperties comparingProperties = new ComparingProperties();
+    // WHEN
+    Throwable throwable = catchThrowable(() -> then(actual).usingRecursiveComparison()
+                                                           .withIntrospectionStrategy(comparingProperties)
+                                                           .isEqualTo(expected));
+    // THEN fails due to getString failing as it tries to build an optional for a null value.
+    then(throwable).isInstanceOf(IntrospectionError.class);
+  }
+
+  class Bean {
+    private String string = null;
+
+    public Optional<String> getString() {
+      return Optional.of(string);
+    } // coding error here
+  }
+
+  // https://github.com/assertj/assertj/issues/2108#issuecomment-1088830619 with getEmail() added to UserDto
+
+  @Test
+  void should_pass_with_property_based_introspection_for_2108() {
+    // GIVEN
+    User user = new User();
+    UserDTO userDto = new UserDTO(user);
+    ComparingProperties comparingProperties = new ComparingProperties();
+    // WHEN/THEN
+    then(user).usingRecursiveComparison()
+              .withIntrospectionStrategy(comparingProperties)
+              .isEqualTo(userDto);
+  }
+
+  static class User {
+
+    public String getEmail() {
+      // Some complicated logic for email retrieval
+      return "a@example.com";
+    }
+  }
+
+  // Lightweight object for REST endpoint
+  static class UserDTO {
+    private String email;
+
+    UserDTO(User user) {
+      this.email = user.getEmail();
+    }
+
+    public String getEmail() {
+      return email;
+    }
+  }
+
+  // https://github.com/assertj/assertj/issues/2149
+
+  @Test
+  void should_pass_with_field_based_introspection() {
+    // GIVEN
+    Values actual = new Values("A", "B");
+    Values expected = new Values("A", "C");
+    recursiveComparisonConfiguration.setIntrospectionStrategy(new ComparingFields());
+
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+
+    // THEN
+    ComparisonDifference valuesDifference = diff("values[1]", "B", "C");
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, valuesDifference);
+
+    // Note that this succeeds when it should not:
+    // then(actual).usingRecursiveComparison().isEqualTo(expected);
+    // rationale is by default we get value by property first and field second which means that we call getValues(),
+    // which returns the first element "A" of both actual and expected.
+  }
+
+  static class ComparingFields implements RecursiveComparisonIntrospectionStrategy {
+
+    @Override
+    public Set<String> getChildrenNodeNamesOf(Object node) {
+      return node == null ? new HashSet<>() : Objects.getFieldsNames(node.getClass());
+    }
+
+    @Override
+    public Object getChildNodeValue(String childNodeName, Object instance) {
+      return FieldSupport.comparison().fieldValue(childNodeName, Object.class, instance);
+    }
+
+    @Override
+    public String getDescription() {
+      return "comparing fields";
+    }
+
+  }
+
+  static class Values {
+    Collection<String> values;
+
+    public Values(String... values) {
+      this.values = asList(values);
+    }
+
+    public String getValues() {
+      return values == null ? null : values.iterator().next();
+    }
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
index 4a282b360..8e7778d41 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
@@ -18,6 +18,7 @@ import static org.assertj.core.test.AlwaysEqualComparator.alwaysEqual;
 import static org.assertj.core.test.BiPredicates.STRING_EQUALS;
 
 import java.util.Comparator;
+import java.util.Set;
 import java.util.function.BiPredicate;
 import java.util.regex.Pattern;
 
@@ -354,6 +355,26 @@ class RecursiveComparisonConfiguration_builder_Test {
     then(configuration.getMessageForType(String.class)).isEqualTo(message);
   }
 
+  @Test
+  void should_set_introspection_strategy() {
+    // GIVEN
+    RecursiveComparisonIntrospectionStrategy myIntrospectionStrategy = new RecursiveComparisonIntrospectionStrategy() {
+      @Override
+      public Set<String> getChildrenNodeNamesOf(Object node) {
+        return null;
+      }
+
+      @Override
+      public Object getChildNodeValue(String childNodeName, Object instance) {
+        return null;
+      }
+    };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = configBuilder().withIntrospectionStrategy(myIntrospectionStrategy).build();
+    // THEN
+    then(configuration.getIntrospectionStrategy()).isSameAs(myIntrospectionStrategy);
+  }
+
   private static Builder configBuilder() {
     return RecursiveComparisonConfiguration.builder();
   }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
index 093acebc7..8169a14d5 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
@@ -50,7 +50,7 @@ class RecursiveComparisonConfiguration_getActualFieldNamesToCompare_Test {
     person2.neighbour.home.address.number = 456;
     DualValue dualValue = new DualValue(list("people"), person1, person2);
     // WHEN
-    Set<String> fields = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
+    Set<String> fields = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
     // THEN
     then(fields).doesNotContain("number", "dateOfBirth", "name");
   }
@@ -71,7 +71,7 @@ class RecursiveComparisonConfiguration_getActualFieldNamesToCompare_Test {
     person2.neighbour.home.address.number = 456;
     DualValue dualValue = new DualValue(list(), person1, person2);
     // WHEN
-    Set<String> fields = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
+    Set<String> fields = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
     // THEN
     // "home.address" is not present since getActualFieldNamesToCompare look at the direct fields
     // it registers "home" because we need to compare "home.address",
@@ -87,7 +87,7 @@ class RecursiveComparisonConfiguration_getActualFieldNamesToCompare_Test {
     PersonDtoWithPersonNeighbour person2 = new PersonDtoWithPersonNeighbour("John");
     DualValue dualValue = new DualValue(list("people"), person2, person1);
     // WHEN
-    Set<String> fields = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
+    Set<String> fields = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
     // THEN
     then(fields).containsExactly("name");
   }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index 56662a29a..fc92c95a6 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -373,7 +373,8 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                "  - bar.baz -> AlwaysDifferentComparator%n" +
                "  - foo -> AlwaysEqualComparator%n" +
                "- field comparators take precedence over type comparators.%n"+
-               "- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).%n"));
+               "- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).%n" +
+               "- the introspection strategy used was: DefaultRecursiveComparisonIntrospectionStrategy%n"));
     // @format:on
   }
 
