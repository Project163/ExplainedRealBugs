diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 6095fede1..f9e590ebf 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -17,7 +17,6 @@ import static org.assertj.core.error.ShouldNotBeEqualComparingFieldByFieldRecurs
 
 import java.util.Comparator;
 import java.util.List;
-import java.util.Map.Entry;
 import java.util.Optional;
 import java.util.OptionalDouble;
 import java.util.OptionalInt;
@@ -32,6 +31,7 @@ import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCa
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonIntrospectionStrategy;
 import org.assertj.core.internal.TypeComparators;
 import org.assertj.core.util.CheckReturnValue;
+import org.assertj.core.util.DualClass;
 import org.assertj.core.util.introspection.IntrospectionError;
 
 public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SELF>>
@@ -1734,7 +1734,8 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * Allows registering a {@link BiPredicate} to compare the fields with the given type.
    * A typical usage is to compare double/float fields with a given precision.
    * <p>
-   * BiPredicates registered with this method have less precedence than the one registered  with {@link #withEqualsForFields(BiPredicate, String...) withEqualsForFields(BiPredicate, String...)}
+   * BiPredicates registered with this method have less precedence than the one registered  with {@link #withEqualsForTypes(BiPredicate, Class, Class) withEqualsForTypes(BiPredicate, Class, Class)},
+   * {@link #withEqualsForFields(BiPredicate, String...) withEqualsForFields(BiPredicate, String...)}
    * or comparators registered with {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)}.
    * <p>
    * Note that registering a {@link BiPredicate} for a given type will override the previously registered BiPredicate/Comparator (if any).
@@ -1774,6 +1775,53 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Allows to register a {@link BiPredicate} to compare the fields with the given types.
+   * A typical usage is to compare fields belonging to different types.
+   * <p>
+   * BiPredicates registered with this method have less precedence than the one registered  with {@link #withEqualsForFields(BiPredicate, String...) withEqualsForFields(BiPredicate, String...)}
+   * or comparators registered with {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)}.
+   * <p>
+   * Note that registering a {@link BiPredicate} for a given type will override the previously registered BiPredicate/Comparator (if any).
+   * <p>
+   * Example:
+   * <pre><code class='java'> public class TolkienCharacter {
+   *   LocalDate birthday;
+   * }
+   * public class TolkienCharacterDto {
+   *    String birthday;
+   * }
+   *
+   * TolkienCharacter frodo = new TolkienCharacter(LocalDate.of(2968, Month.SEPTEMBER, 22));
+   * TolkienCharacterDto frodoDto = new TolkienCharacterDto("2968-09-22");
+   * TolkienCharacterDto bilboDto = new TolkienCharacterDto("2890-09-22");
+   *
+   * BiPredicate&lt;LocalDate, String&gt; sameDate = (d, s) -&gt; LocalDate.parse(s).equals(d);
+   *
+   * // assertion succeeds
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .withEqualsForTypes(sameDate, LocalDate.class, String.class)
+   *                  .isEqualTo(frodoDto);
+   *
+   * // assertion fails
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .withEqualsForTypes(sameDate, LocalDate.class, String.class)
+   *                  .isEqualTo(bilboDto);</code></pre>
+   *
+   * @param <T> the left element's class type to register a BiPredicate for
+   * @param <U> the right element's class type to register a BiPredicate for
+   * @param equals the {@link BiPredicate} to use to compare the given fields
+   * @param type the type of the left element to be compared with the given comparator.
+   * @param otherType the type of the right element to be compared with the given comparator.
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   * @throws NullPointerException if the given BiPredicate is null.
+   */
+  public <T, U> SELF withEqualsForTypes(BiPredicate<? super T, ? super U> equals, Class<T> type, Class<U> otherType) {
+    recursiveComparisonConfiguration.registerEqualsForTypes(equals, type, otherType);
+    return myself;
+  }
+
   /**
    * Overrides an error message which would be shown when differences in the given fields while comparison occurred
    * with the giving error message.
@@ -1949,18 +1997,19 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
-  SELF withTypeComparators(TypeComparators typeComparators) {
-    Optional.ofNullable(typeComparators)
-            .map(TypeComparators::comparatorByTypes)
-            .ifPresent(comparatorByTypes -> comparatorByTypes.forEach(this::registerComparatorForType));
+  @SuppressWarnings({ "rawtypes", "unchecked" })
+  SELF withTypeComparators(TypeComparators newTypeComparators) {
+    if (newTypeComparators != null) {
+      TypeComparators typeComparators = recursiveComparisonConfiguration.getTypeComparators();
+      newTypeComparators.comparatorByTypes().forEach(entry -> {
+        DualClass dualClass = entry.getKey();
+        Comparator comparator = entry.getValue();
+        typeComparators.registerComparator(dualClass.actual(), dualClass.expected(), comparator);
+      });
+    }
     return myself;
   }
 
-  @SuppressWarnings({ "unchecked", "rawtypes" })
-  private void registerComparatorForType(Entry<Class<?>, Comparator<?>> entry) {
-    withComparatorForType((Comparator) entry.getValue(), entry.getKey());
-  }
-
   /**
    * Returns the {@link RecursiveComparisonConfiguration} currently used.
    *
@@ -1973,5 +2022,4 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   private List<ComparisonDifference> determineDifferencesWith(Object expected) {
     return recursiveComparisonDifferenceCalculator.determineDifferences(actual, expected, recursiveComparisonConfiguration);
   }
-
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index dab13ea6d..38025cb8c 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
+import static java.lang.String.format;
 import static java.util.Arrays.stream;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.joining;
@@ -47,6 +48,7 @@ import org.assertj.core.api.recursive.AbstractRecursiveOperationConfiguration;
 import org.assertj.core.internal.TypeComparators;
 import org.assertj.core.internal.TypeMessages;
 import org.assertj.core.presentation.Representation;
+import org.assertj.core.util.DualClass;
 
 public class RecursiveComparisonConfiguration extends AbstractRecursiveOperationConfiguration {
 
@@ -164,16 +166,33 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return fieldComparators;
   }
 
-  public boolean hasComparatorForType(Class<?> keyType) {
-    return typeComparators.hasComparatorForType(keyType);
+  private boolean hasComparatorForType(Class<?> keyType) {
+    return hasComparatorForDualTypes(keyType, null);
+  }
+
+  private boolean hasComparatorForDualTypes(Class<?> type1, Class<?> type2) {
+    return typeComparators.hasComparatorForDualTypes(type1, type2);
   }
 
   public boolean hasCustomComparators() {
     return !typeComparators.isEmpty() || !fieldComparators.isEmpty();
   }
 
-  public Comparator<?> getComparatorForType(Class<?> fieldType) {
-    return typeComparators.getComparatorForType(fieldType);
+  public Comparator<?> getComparatorForDualType(Class<?> fieldType) {
+    return getComparatorForDualType(fieldType, null);
+  }
+
+  private Comparator<?> getComparatorForDualType(Class<?> fieldType, Class<?> otherFieldType) {
+    return typeComparators.getComparatorForDualTypes(fieldType, otherFieldType);
+  }
+
+  @SuppressWarnings("rawtypes")
+  Comparator getComparator(DualValue dualValue) {
+    Class expectedFieldType = dualValue.expected != null ? dualValue.expected.getClass() : null;
+    Class actualFieldType = dualValue.actual != null ? dualValue.actual.getClass() : expectedFieldType;
+    Comparator typeComparator = getComparatorForDualType(actualFieldType, expectedFieldType);
+    if (typeComparator == null) typeComparator = getComparatorForDualType(actualFieldType);
+    return typeComparator;
   }
 
   public boolean hasCustomMessageForType(Class<?> fieldType) {
@@ -188,6 +207,10 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return typeComparators;
   }
 
+  public Stream<Entry<DualClass<?, ?>, Comparator<?>>> comparatorByTypes() {
+    return typeComparators.comparatorByTypes();
+  }
+
   public boolean getIgnoreAllActualNullFields() {
     return ignoreAllActualNullFields;
   }
@@ -207,7 +230,6 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   /**
    * Makes the recursive comparison to ignore <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Concepts.doc.html#18858">transient</a> fields.
    * <p>
-   *
    * See {@link RecursiveComparisonAssert#ignoringTransientFields()} for examples.
    */
   public void ignoreTransientFields() {
@@ -488,9 +510,9 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * <p>
    * See {@link RecursiveComparisonAssert#withComparatorForType(Comparator, Class)} for examples.
    *
-   * @param <T> the class type to register a comparator for
+   * @param <T>        the class type to register a comparator for
    * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given type
-   * @param type the type to be compared with the given comparator.
+   * @param type       the type to be compared with the given comparator.
    * @throws NullPointerException if the given comparator is null.
    */
   public <T> void registerComparatorForType(Comparator<? super T> comparator, Class<T> type) {
@@ -502,16 +524,16 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * Registers the given {@link BiPredicate} to compare the fields with the given type.
    * <p>
    * BiPredicates specified with this method have less precedence than the ones registered with
-   * {@link #registerEqualsForFields(BiPredicate, String...)}
+   * {@link #registerEqualsForTypes(BiPredicate, Class, Class)}, {@link #registerEqualsForFields(BiPredicate, String...)}
    * or comparators registered with {@link #registerComparatorForFields(Comparator, String...)}.
    * <p>
    * Note that registering a {@link BiPredicate} for a given type will override the previously registered BiPredicate/Comparator (if any).
    * <p>
    * See {@link RecursiveComparisonAssert#withEqualsForType(BiPredicate, Class)} for examples.
    *
-   * @param <T> the class type to register a comparator for
+   * @param <T>    the class type to register a comparator for
    * @param equals the equals implementation to compare the given type
-   * @param type the type to be compared with the given equals implementation .
+   * @param type   the type to be compared with the given equals implementation .
    * @throws NullPointerException if the given BiPredicate is null.
    * @since 3.17.0
    */
@@ -519,6 +541,30 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     registerComparatorForType(toComparator(equals), type);
   }
 
+  /**
+   * Registers the given {@link BiPredicate} to compare the fields with the given types.
+   * <p>
+   * BiPredicates specified with this method have less precedence than the ones registered with
+   * {@link #registerEqualsForFields(BiPredicate, String...)}
+   * or comparators registered with {@link #registerComparatorForFields(Comparator, String...)}.
+   * <p>
+   * Note that registering a {@link BiPredicate} for a given types will override the previously registered BiPredicate/Comparator (if any).
+   * <p>
+   * See {@link RecursiveComparisonAssert#withEqualsForTypes(BiPredicate, Class, Class)} for examples.
+   *
+   * @param <T>       the class of the left element to register a comparator for
+   * @param <U>       the class of the right element to register a comparator for
+   * @param equals    the equals implementation to compare the given type
+   * @param type      the type of the left element to be compared with the given equals implementation.
+   * @param otherType the type of right left element to be compared with the given equals implementation.
+   * @throws NullPointerException if the given BiPredicate is null.
+   */
+  @SuppressWarnings("unchecked")
+  public <T, U> void registerEqualsForTypes(BiPredicate<? super T, ? super U> equals, Class<T> type, Class<U> otherType) {
+    requireNonNull(equals, "Expecting a non null BiPredicate");
+    typeComparators.registerComparator(type, otherType, toComparator(equals));
+  }
+
   /**
    * Registers the given {@link Comparator} to compare the fields at the given locations.
    * <p>
@@ -532,7 +578,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * <p>
    * See {@link RecursiveComparisonAssert#withComparatorForFields(Comparator, String...) RecursiveComparisonAssert#withComparatorForFields(Comparator, String...)} for examples.
    *
-   * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
+   * @param comparator     the {@link java.util.Comparator Comparator} to use to compare the given field
    * @param fieldLocations the locations from the root object of the fields the comparator should be used for
    * @throws NullPointerException if the given comparator is null.
    */
@@ -555,7 +601,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * <p>
    * See {@link RecursiveComparisonAssert#withEqualsForFields(BiPredicate, String...) RecursiveComparisonAssert#withEqualsForFields(BiPredicate, String...)} for examples.
    *
-   * @param equals the equals implementation to compare the given fields.
+   * @param equals         the equals implementation to compare the given fields.
    * @param fieldLocations the locations from the root object of the fields the comparator should be used for
    * @throws NullPointerException if the given BiPredicate is null.
    * @since 3.17.0
@@ -582,9 +628,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * <p>
    * Example: see {@link RecursiveComparisonAssert#withEqualsForFieldsMatchingRegexes(BiPredicate, String...)}
    *
-   * @param equals the {@link BiPredicate} to use to compare the fields matching the given regexes
+   * @param equals  the {@link BiPredicate} to use to compare the fields matching the given regexes
    * @param regexes the regexes from the root object of the fields location the BiPredicate should be used for
-   *
    * @throws NullPointerException if the given BiPredicate is null.
    * @since 3.24.0
    */
@@ -603,7 +648,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * <p>
    * In case of {@code null} as message the default error message will be used (See {@link ComparisonDifference#DEFAULT_TEMPLATE}).
    *
-   * @param message the error message that will be thrown when comparison error occurred
+   * @param message        the error message that will be thrown when comparison error occurred
    * @param fieldLocations the field locations the error message should be used for
    */
   public void registerErrorMessageForFields(String message, String... fieldLocations) {
@@ -619,7 +664,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * In case of {@code null} as message the default error message will be used (See {@link ComparisonDifference#DEFAULT_TEMPLATE}).
    *
    * @param message the error message that will be thrown when comparison error occurred
-   * @param clazz the type the error message should be used for
+   * @param clazz   the type the error message should be used for
    */
   public void registerErrorMessageForType(String message, Class<?> clazz) {
     typeMessages.registerMessage(clazz, message);
@@ -861,9 +906,11 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     String fieldName = dualValue.getConcatenatedPath();
     if (hasComparatorForField(fieldName)) return true;
     if (dualValue.actual == null && dualValue.expected == null) return false;
-    // best effort assuming actual and expected have the same type (not 100% true as we can compare object of different types)
-    Class<?> valueType = dualValue.actual != null ? dualValue.actual.getClass() : dualValue.expected.getClass();
-    return hasComparatorForType(valueType);
+    Class<?> expectedType = dualValue.expected != null ? dualValue.expected.getClass() : null;
+    // use expected type when actual is null, we assume here as a best effort that actual and expected have the same type
+    // even though it's not true as we can compare object of different types.
+    Class<?> actualType = dualValue.actual != null ? dualValue.actual.getClass() : expectedType;
+    return hasComparatorForDualTypes(actualType, expectedType) || hasComparatorForType(actualType);
   }
 
   // TODO reduce the visibility of the fields annotated with @VisibleForTesting
@@ -925,7 +972,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   }
 
   protected void describeIgnoreAllActualNullFields(StringBuilder description) {
-    if (ignoreAllActualNullFields) description.append("- all actual null fields were ignored in the comparison%n".formatted());
+    if (ignoreAllActualNullFields)
+      description.append("- all actual null fields were ignored in the comparison%n".formatted());
   }
 
   protected void describeIgnoreAllActualEmptyOptionalFields(StringBuilder description) {
@@ -1110,8 +1158,13 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
                    .forEach(description::append);
   }
 
-  private String formatRegisteredComparatorByType(Entry<Class<?>, Comparator<?>> next) {
-    return "%s %s -> %s%n".formatted(INDENT_LEVEL_2, next.getKey().getName(), next.getValue());
+  private String formatRegisteredComparatorByType(Entry<DualClass<?, ?>, Comparator<?>> entry) {
+    DualClass<?, ?> dualClass = entry.getKey();
+    Comparator<?> comparator = entry.getValue();
+    return dualClass.hasNoExpected()
+        ? format("%s %s -> %s%n", INDENT_LEVEL_2, dualClass.actualDescription(), comparator)
+        : format("%s [%s - %s] -> %s%n", INDENT_LEVEL_2, dualClass.actualDescription(), dualClass.expectedDescription(),
+                 comparator);
   }
 
   private void describeRegisteredComparatorForFields(StringBuilder description) {
@@ -1187,13 +1240,15 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private void describeErrorMessagesForType(StringBuilder description) {
     String types = typeMessages.messageByTypes()
-                               .map(it -> it.getKey().getName())
+                               .map(x -> x.getKey())
+                               .map(this::formatErrorMessageForDualType)
                                .collect(joining(DEFAULT_DELIMITER));
     description.append("%s %s%n".formatted(INDENT_LEVEL_2, types));
   }
 
   /**
    * Creates builder to build {@link RecursiveComparisonConfiguration}.
+   *
    * @return created builder
    */
   public static Builder builder() {
@@ -1537,9 +1592,9 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
      * <p>
      * See {@link RecursiveComparisonAssert#withComparatorForType(Comparator, Class)} for examples.
      *
-     * @param <T> the class type to register a comparator for
+     * @param <T>        the class type to register a comparator for
      * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
-     * @param type the type to be compared with the given comparator.
+     * @param type       the type to be compared with the given comparator.
      * @return this builder.
      * @throws NullPointerException if the given Comparator is null.
      */
@@ -1559,12 +1614,12 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
      * <p>
      * See {@link RecursiveComparisonAssert#withEqualsForType(BiPredicate, Class)} for examples.
      *
-     * @param <T> the class type to register a BiPredicate for
+     * @param <T>    the class type to register a BiPredicate for
      * @param equals the {@link BiPredicate} to use to compare the given field
-     * @param type the type to be compared with the given comparator.
+     * @param type   the type to be compared with the given comparator.
      * @return this builder.
-     * @since 3.17.0
      * @throws NullPointerException if the given BiPredicate is null.
+     * @since 3.17.0
      */
     public <T> Builder withEqualsForType(BiPredicate<? super T, ? super T> equals, Class<T> type) {
       return withComparatorForType(toComparator(equals), type);
@@ -1585,7 +1640,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
      * See {@link RecursiveComparisonAssert#withComparatorForFields(Comparator, String...) RecursiveComparisonAssert#withComparatorForFields(Comparator comparator, String...fields)} for examples.
      *
      * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
-     * @param fields the fields the comparator should be used for
+     * @param fields     the fields the comparator should be used for
      * @return this builder.
      * @throws NullPointerException if the given Comparator is null.
      */
@@ -1612,8 +1667,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
      * @param equals the {@link BiPredicate} to use to compare the given fields
      * @param fields the fields the BiPredicate should be used for
      * @return this builder.
-     * @since 3.17.0
      * @throws NullPointerException if the given BiPredicate is null.
+     * @since 3.17.0
      */
     public Builder withEqualsForFields(BiPredicate<?, ?> equals, String... fields) {
       return withComparatorForFields(toComparator(equals), fields);
@@ -1637,11 +1692,11 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
      * <p>
      * See {@link RecursiveComparisonAssert#withEqualsForFieldsMatchingRegexes(BiPredicate, String...) RecursiveComparisonAssert#withEqualsForFieldsMatchingRegexes(BiPredicate equals, String...fields)} for examples.
      *
-     * @param equals the {@link BiPredicate} to use to compare the fields matching the given regexes
+     * @param equals  the {@link BiPredicate} to use to compare the fields matching the given regexes
      * @param regexes the regexes to match fields against
      * @return this builder.
-     * @since 3.24.0
      * @throws NullPointerException if the given BiPredicate is null.
+     * @since 3.24.0
      */
     public Builder withEqualsForFieldsMatchingRegexes(BiPredicate<?, ?> equals, String... regexes) {
       fieldComparators.registerComparatorForFieldsMatchingRegexes(regexes, toComparator(equals));
@@ -1661,7 +1716,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
      * {@link ComparisonDifference#DEFAULT_TEMPLATE}).
      *
      * @param message the error message that will be thrown when comparison error occurred.
-     * @param fields the fields the error message should be used for.
+     * @param fields  the fields the error message should be used for.
      * @return this builder.
      * @throws NullPointerException if the giving list of arguments is null.
      */
@@ -1680,7 +1735,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
      * {@link ComparisonDifference#DEFAULT_TEMPLATE}).
      *
      * @param message the error message that will be thrown when comparison error occurred
-     * @param type the type the error message should be used for
+     * @param type    the type the error message should be used for
      * @return this builder
      */
     public Builder withErrorMessageForType(String message, Class<?> type) {
@@ -1719,7 +1774,6 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     /**
      * Makes the recursive comparison to ignore <a href="https://docs.oracle.com/javase/specs/jvms/se6/html/Concepts.doc.html#18858">transient</a> fields.
      * <p>
-     *
      * See {@link RecursiveComparisonAssert#ignoringTransientFields()} for examples.
      */
     public Builder withIgnoredTransientFields() {
@@ -1744,4 +1798,10 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return (o1, o2) -> equals.test(o1, o2) ? 0 : 1;
   }
 
+  private String formatErrorMessageForDualType(DualClass<?, ?> dualClass) {
+    return dualClass.expected() == null
+        ? dualClass.actualDescription()
+        : format("[%s - %s]", dualClass.actualDescription(), dualClass.expectedDescription());
+  }
+
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index fcd28ee95..95db240af 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -986,7 +986,7 @@ public class RecursiveComparisonDifferenceCalculator {
     return false;
   }
 
-  @SuppressWarnings({ "rawtypes" })
+  @SuppressWarnings({ "rawtypes", "unchecked" })
   private static boolean areDualValueEqual(DualValue dualValue,
                                            RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     final String fieldName = dualValue.getConcatenatedPath();
@@ -997,10 +997,8 @@ public class RecursiveComparisonDifferenceCalculator {
     if (fieldComparator != null)
       return areEqualUsingComparator(actualFieldValue, expectedFieldValue, fieldComparator, fieldName);
     // check if a type comparators exist for the field type
-    Class fieldType = actualFieldValue != null ? actualFieldValue.getClass() : expectedFieldValue.getClass();
-    Comparator typeComparator = recursiveComparisonConfiguration.getComparatorForType(fieldType);
-    if (typeComparator != null)
-      return areEqualUsingComparator(actualFieldValue, expectedFieldValue, typeComparator, fieldName);
+    Comparator typeComparator = recursiveComparisonConfiguration.getComparator(dualValue);
+    if (typeComparator != null) return areEqualUsingComparator(actualFieldValue, expectedFieldValue, typeComparator, fieldName);
     // default comparison using equals
     return deepEquals(actualFieldValue, expectedFieldValue);
   }
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/TypeComparators.java b/assertj-core/src/main/java/org/assertj/core/internal/TypeComparators.java
index 4e4ba5921..be0b639db 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/TypeComparators.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/TypeComparators.java
@@ -18,6 +18,7 @@ import java.util.Map.Entry;
 import java.util.stream.Stream;
 
 import org.assertj.core.util.DoubleComparator;
+import org.assertj.core.util.DualClass;
 import org.assertj.core.util.FloatComparator;
 import org.assertj.core.util.PathNaturalOrderComparator;
 
@@ -57,7 +58,27 @@ public class TypeComparators extends TypeHolder<Comparator<?>> {
    * @return the most relevant comparator, or {@code null} if no comparator could be found
    */
   public Comparator<?> getComparatorForType(Class<?> clazz) {
-    return super.get(clazz);
+    return getComparatorForDualTypes(clazz, null);
+  }
+
+  /**
+   * This method returns the most relevant comparator for the given class pair. The most relevant comparator is the
+   * comparator which is registered for the class pair that is closest in the inheritance chain of the given {@code clazz} and {@code otherClazz}.
+   * The order of checks is the following:
+   * 1. If there is a registered comparator for {@code clazz} and {@code otherClazz} then this one is used
+   * 2. We check if there is a registered comparator for a superclass of {@code clazz} and {@code otherClazz}
+   * 3. We check if there is a registered comparator for {@code clazz} and a superclass of {@code otherClazz}
+   * 4. We check if there is a registered comparator for a superclass of {@code clazz} and a superclass of {@code otherClazz}
+   * 5. We check if there is a registered comparator for an interface of {@code clazz} and {@code otherClazz}
+   * 6. We check if there is a registered comparator for {@code clazz} and an interface of {@code otherClazz}
+   * 7. We check if there is a registered comparator for an interface of {@code clazz} and an interface of {@code otherClazz}
+   *
+   * @param clazz the class of the left element for which to find a comparator
+   * @param otherClazz the class of the right element for which to find a comparator
+   * @return the most relevant comparator, or {@code null} if no comparator could be found
+   */
+  public Comparator<?> getComparatorForDualTypes(Class<?> clazz, Class<?> otherClazz) {
+    return super.get(clazz, otherClazz);
   }
 
   /**
@@ -67,7 +88,18 @@ public class TypeComparators extends TypeHolder<Comparator<?>> {
    * @return is the giving type associated with any custom comparator
    */
   public boolean hasComparatorForType(Class<?> type) {
-    return super.hasEntity(type);
+    return hasComparatorForDualTypes(type, null);
+  }
+
+  /**
+   * Checks, whether an any custom comparator is associated with the giving types.
+   *
+   * @param type the type of the left element for which to check a comparator
+   * @param otherType the type of the right element for which to check a comparator
+   * @return is the giving type associated with any custom comparator
+   */
+  public boolean hasComparatorForDualTypes(Class<?> type, Class<?> otherType) {
+    return super.hasEntity(type, otherType);
   }
 
   /**
@@ -81,12 +113,25 @@ public class TypeComparators extends TypeHolder<Comparator<?>> {
     super.put(clazz, comparator);
   }
 
+  /**
+   * Puts the {@code comparator} for the given {@code clazz} and {@code otherClazz}.
+   *
+   * @param clazz the class of the left element for the comparator
+   * @param otherClazz the class of the right element for the comparator
+   * @param comparator the comparator itself
+   * @param <T> the type of the left objects for the comparator
+   * @param <U> the type of the right objects for the comparator
+   */
+  public <T, U> void registerComparator(Class<T> clazz, Class<U> otherClazz, Comparator<? super T> comparator) {
+    super.put(clazz, otherClazz, comparator);
+  }
+
   /**
    * Returns a sequence of all type-comparator pairs which the current holder supplies.
    *
    * @return sequence of field-comparator pairs
    */
-  public Stream<Entry<Class<?>, Comparator<?>>> comparatorByTypes() {
+  public Stream<Entry<DualClass<?, ?>, Comparator<?>>> comparatorByTypes() {
     return super.entityByTypes();
   }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/TypeHolder.java b/assertj-core/src/main/java/org/assertj/core/internal/TypeHolder.java
index 24fc45d73..b9e623a75 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/TypeHolder.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/TypeHolder.java
@@ -12,8 +12,10 @@
  */
 package org.assertj.core.internal;
 
+import static java.lang.String.format;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toList;
+import static org.assertj.core.util.DualClass.dualClass;
 import static org.assertj.core.util.Strings.join;
 import static org.assertj.core.util.introspection.ClassUtils.getAllInterfaces;
 import static org.assertj.core.util.introspection.ClassUtils.getAllSuperclasses;
@@ -26,7 +28,10 @@ import java.util.Objects;
 import java.util.Set;
 import java.util.TreeMap;
 import java.util.stream.Stream;
+
 import org.assertj.core.util.ClassNameComparator;
+import org.assertj.core.util.DualClass;
+import org.assertj.core.util.DualClassComparator;
 
 /**
  * An abstract type holder which provides to pair a specific entities for types.
@@ -35,15 +40,16 @@ import org.assertj.core.util.ClassNameComparator;
  */
 abstract class TypeHolder<T> {
 
-  private static final Comparator<Class<?>> DEFAULT_CLASS_COMPARATOR = ClassNameComparator.INSTANCE;
+  private static final Comparator<DualClass<?, ?>> DEFAULT_DUAL_CLASS_COMPARATOR = new DualClassComparator(ClassNameComparator.INSTANCE,
+                                                                                                           ClassNameComparator.INSTANCE);
 
-  protected final Map<Class<?>, T> typeHolder;
+  protected final Map<DualClass<?, ?>, T> typeHolder;
 
   public TypeHolder() {
-    this(DEFAULT_CLASS_COMPARATOR);
+    this(DEFAULT_DUAL_CLASS_COMPARATOR);
   }
 
-  public TypeHolder(Comparator<Class<?>> comparator) {
+  public TypeHolder(Comparator<DualClass<?, ?>> comparator) {
     typeHolder = new TreeMap<>(requireNonNull(comparator, "Comparator must not be null"));
   }
 
@@ -55,22 +61,56 @@ abstract class TypeHolder<T> {
    * 2. We check if there is a registered entity for a superclass of {@code clazz}
    * 3. We check if there is a registered entity for an interface of {@code clazz}
    *
-   * @param clazz the class for which to find a entity
+   * @param clazz the class for which to find an entity
    * @return the most relevant entity, or {@code null} if on entity could be found
    */
   public T get(Class<?> clazz) {
+    return get(clazz, null);
+  }
+
+  /**
+   * This method returns the most relevant entity for the given class pair. The most relevant entity is the
+   * entity which is registered for the class pair that is closest in the inheritance chain of the given {@code clazz} and
+   * {@code otherClazz}.
+   * The order of checks is the following:
+   * 1. If there is a registered entity for {@code clazz} and {@code otherClazz} then this one is used
+   * 2. We check if there is a registered entity for a superclass of {@code clazz}
+   * 3. We check if there is a registered entity for an interface of {@code clazz}
+   * 4. Found the closest registered class for {@code clazz},
+   * We check if there is a registered entity for a superclass of {@code otherClazz}
+   * 5. We check if there is a registered entity for an interface of {@code otherClazz}
+   *
+   * @param clazz      the class for which to find an entity
+   * @param otherClazz the additional class for which to find an entity.
+   *                   This may be {@code null} to find the entity bound only to the {@code clazz}
+   * @return the most relevant entity, or {@code null} if on entity could be found
+   */
+  public T get(Class<?> clazz, Class<?> otherClazz) {
     Class<?> relevantType = getRelevantClass(clazz);
-    return relevantType == null ? null : typeHolder.get(relevantType);
+    if (relevantType == null) return null;
+    return typeHolder.get(dualClass(relevantType, getRelevantClass(relevantType, otherClazz)));
   }
 
   /**
    * Puts the {@code entity} for the given {@code clazz}.
    *
-   * @param clazz the class for the comparator
+   * @param clazz  the class for the comparator
    * @param entity the entity itself
    */
   public void put(Class<?> clazz, T entity) {
-    typeHolder.put(clazz, entity);
+    put(clazz, null, entity);
+  }
+
+  /**
+   * Puts the {@code entity} for the given {@code clazz} and {@code otherClazz}.
+   *
+   * @param clazz      the class for the comparator
+   * @param otherClazz the additional class for the comparator. This may be {@code null} if the entity is bound only to the
+   *                   {@code clazz}
+   * @param entity     the entity itself
+   */
+  public void put(Class<?> clazz, Class<?> otherClazz, T entity) {
+    typeHolder.put(dualClass(clazz, otherClazz), entity);
   }
 
   /**
@@ -80,7 +120,18 @@ abstract class TypeHolder<T> {
    * @return is the giving type associated with any entity
    */
   public boolean hasEntity(Class<?> type) {
-    return get(type) != null;
+    return hasEntity(type, null);
+  }
+
+  /**
+   * Checks, whether an entity is associated with the giving type pair.
+   *
+   * @param type      the type for which to check an entity
+   * @param otherType the additional type for which to check an entity
+   * @return is the giving type associated with any entity
+   */
+  public boolean hasEntity(Class<?> type, Class<?> otherType) {
+    return get(type, otherType) != null;
   }
 
   /**
@@ -102,7 +153,7 @@ abstract class TypeHolder<T> {
    *
    * @return sequence of field-entity pairs
    */
-  public Stream<Entry<Class<?>, T>> entityByTypes() {
+  public Stream<Entry<DualClass<?, ?>, T>> entityByTypes() {
     return typeHolder.entrySet().stream();
   }
 
@@ -121,14 +172,32 @@ abstract class TypeHolder<T> {
    * @return the most relevant class.
    */
   private Class<?> getRelevantClass(Class<?> cls) {
-    Set<Class<?>> keys = typeHolder.keySet();
-    if (keys.contains(cls)) return cls;
+    Set<DualClass<?, ?>> dualClasses = typeHolder.keySet();
+    if (dualClasses.stream().anyMatch(c -> c.actual() == cls)) return cls;
 
     for (Class<?> superClass : getAllSuperclasses(cls)) {
-      if (keys.contains(superClass)) return superClass;
+      if (dualClasses.stream().anyMatch(c -> c.actual() == superClass)) return superClass;
     }
     for (Class<?> interfaceClass : getAllInterfaces(cls)) {
-      if (keys.contains(interfaceClass)) return interfaceClass;
+      if (dualClasses.stream().anyMatch(c -> c.actual() == interfaceClass)) return interfaceClass;
+    }
+    return null;
+  }
+
+  private Class<?> getRelevantClass(Class<?> cls, Class<?> otherCls) {
+    if (otherCls == null) return null;
+
+    Set<DualClass<?, ?>> registeredDualClasses = typeHolder.keySet();
+    DualClass<?, ?> dualClass = dualClass(cls, otherCls);
+    if (registeredDualClasses.stream().anyMatch(dualClass::equals)) return otherCls;
+
+    for (Class<?> superClass : getAllSuperclasses(otherCls)) {
+      DualClass<?, ?> dualWithSuperClass = dualClass(cls, superClass);
+      if (registeredDualClasses.stream().anyMatch(dualWithSuperClass::equals)) return superClass;
+    }
+    for (Class<?> interfaceClass : getAllInterfaces(otherCls)) {
+      DualClass<?, ?> dualWithInterface = dualClass(cls, interfaceClass);
+      if (registeredDualClasses.stream().anyMatch(dualWithInterface::equals)) return interfaceClass;
     }
     return null;
   }
@@ -154,7 +223,10 @@ abstract class TypeHolder<T> {
     return "{%s}".formatted(join(registeredEntitiesDescription).with(", "));
   }
 
-  private static <T> String formatRegisteredEntity(Entry<Class<?>, T> entry) {
-    return "%s -> %s".formatted(entry.getKey().getSimpleName(), entry.getValue());
+  private static <T> String formatRegisteredEntity(Entry<DualClass<?, ?>, T> entry) {
+    DualClass<?, ?> dualClass = entry.getKey();
+    return dualClass.hasNoExpected()
+        ? format("%s -> %s", dualClass.actualDescription(), entry.getValue())
+        : format("[%s - %s] -> %s", dualClass.actualDescription(), dualClass.expectedDescription(), entry.getValue());
   }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/TypeMessages.java b/assertj-core/src/main/java/org/assertj/core/internal/TypeMessages.java
index 2b509e5d7..b6661e65f 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/TypeMessages.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/TypeMessages.java
@@ -15,6 +15,8 @@ package org.assertj.core.internal;
 import java.util.Map;
 import java.util.stream.Stream;
 
+import org.assertj.core.util.DualClass;
+
 /**
  * An internal holder of the custom message for type. It is used to store messages for registered classes.
  * When looking for a message for a given class the holder returns the most relevant comparator.
@@ -62,7 +64,7 @@ public class TypeMessages extends TypeHolder<String> {
    *
    * @return sequence of field-message pairs
    */
-  public Stream<Map.Entry<Class<?>, String>> messageByTypes() {
+  public Stream<Map.Entry<DualClass<?, ?>, String>> messageByTypes() {
     return super.entityByTypes();
   }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/util/DualClass.java b/assertj-core/src/main/java/org/assertj/core/util/DualClass.java
new file mode 100644
index 000000000..bdf5fad0d
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/util/DualClass.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.util;
+
+import static java.util.Objects.hash;
+
+import java.util.Objects;
+
+/**
+ * Class representing a pair of two generic class reference.
+ *
+ * @param <A> Type of the actual value
+ * @param <E> Type of the expected value
+ * @author Alessandro Modolo
+ */
+public class DualClass<A, E> {
+
+  private final Class<A> actual;
+  private final Class<E> expected;
+
+  DualClass(Class<A> actual, Class<E> expected) {
+    this.actual = actual;
+    this.expected = expected;
+  }
+
+  /**
+   * Create a new instance of {@link DualClass}.
+   *
+   * @param actual  The class of the actual value
+   * @param expected The class of the expected value
+   * @param <A>   Type of the actual value
+   * @param <E>   Type of the expected value
+   * @return A new instance of {@link DualClass} with the specified classes reference
+   */
+  public static <A, E> DualClass<A, E> dualClass(Class<A> actual, Class<E> expected) {
+    return new DualClass<>(actual, expected);
+  }
+
+  /**
+   * Returns the class of the actual value.
+   *
+   * @return The class whose actual value belongs to
+   */
+  public Class<A> actual() {
+    return actual;
+  }
+
+  /**
+   * Returns the class of the expected value.
+   *
+   * @return The class whose expected value belongs to
+   */
+  public Class<E> expected() {
+    return expected;
+  }
+
+  public boolean hasNoExpected() {
+    return expected == null;
+  }
+
+  public String actualDescription() {
+    return actual == null ? "" : actual.getName();
+  }
+
+  public String expectedDescription() {
+    return expected == null ? "" : expected.getName();
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+
+    DualClass<?, ?> dualClass = (DualClass<?, ?>) o;
+
+    return Objects.equals(actual, dualClass.actual) && Objects.equals(expected, dualClass.expected);
+  }
+
+  @Override
+  public int hashCode() {
+    return hash(actual, expected);
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/util/DualClassComparator.java b/assertj-core/src/main/java/org/assertj/core/util/DualClassComparator.java
new file mode 100644
index 000000000..346690a72
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/util/DualClassComparator.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.util;
+
+import java.util.Comparator;
+
+/**
+ * A comparator for {@link DualClass}, allowing comparison based on class of the actual and expected components.
+ *
+ * @author Alessandro Modolo
+ */
+public class DualClassComparator extends NullSafeComparator<DualClass<?, ?>> {
+  private static final int NOT_EQUAL = -1;
+
+  private final Comparator<Class<?>> actualComparator;
+  private final Comparator<Class<?>> expectedComparator;
+
+  /**
+   * Constructs a {@link DualClassComparator} with the specified comparators for actual and expected components class.
+   *
+   * @param actualComparator  Comparator for the actual component
+   * @param expectedComparator Comparator for the expected component
+   */
+  public DualClassComparator(Comparator<Class<?>> actualComparator, Comparator<Class<?>> expectedComparator) {
+    this.actualComparator = actualComparator;
+    this.expectedComparator = expectedComparator;
+  }
+
+  @Override
+  protected int compareNonNull(DualClass<?, ?> o1, DualClass<?, ?> o2) {
+    int result = compare(o1.actual(), o2.actual(), actualComparator);
+    return result == 0 ? compare(o1.expected(), o2.expected(), expectedComparator) : result;
+  }
+
+  private int compare(Class<?> o1, Class<?> o2, Comparator<Class<?>> comparator) {
+    if (o1 == o2) return 0;
+    if (o1 == null) return -1;
+    if (o2 == null) return 1;
+
+    return comparator != null ? comparator.compare(o1, o2) : NOT_EQUAL;
+  }
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
index ea3f294e6..96e065a46 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_builder_Test.java
@@ -336,8 +336,7 @@ class RecursiveComparisonConfiguration_builder_Test {
     RecursiveComparisonConfiguration configuration = configBuilder().withComparatorForType(alwaysEqualComparator, String.class)
                                                                     .build();
     // THEN
-    then(configuration.hasComparatorForType(String.class)).isTrue();
-    then(configuration.getComparatorForType(String.class)).isSameAs(alwaysEqualComparator);
+    then(configuration.getComparatorForDualType(String.class)).isSameAs(alwaysEqualComparator);
   }
 
   @Test
@@ -345,7 +344,7 @@ class RecursiveComparisonConfiguration_builder_Test {
     // WHEN
     RecursiveComparisonConfiguration configuration = configBuilder().withEqualsForType(STRING_EQUALS, String.class).build();
     // THEN
-    then(configuration.hasComparatorForType(String.class)).isTrue();
+    then(configuration.getComparatorForDualType(String.class)).isNotNull();
   }
 
   @Test
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_comparatorByType_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_comparatorByType_Test.java
index a463e6f3c..d10aa1def 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_comparatorByType_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/configuration/RecursiveComparisonConfiguration_comparatorByType_Test.java
@@ -12,16 +12,12 @@
  */
 package org.assertj.tests.core.api.recursive.comparison.configuration;
 
-import static java.util.stream.Collectors.toList;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS;
 
 import java.util.Comparator;
-import java.util.List;
-import java.util.Map.Entry;
 import java.util.function.BiPredicate;
 
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
@@ -45,8 +41,8 @@ class RecursiveComparisonConfiguration_comparatorByType_Test {
     // WHEN
     TypeComparators typeComparators = recursiveComparisonConfiguration.getTypeComparators();
     // THEN
-    List<Entry<Class<?>, Comparator<?>>> defaultComparators = defaultTypeComparators().comparatorByTypes().collect(toList());
-    assertThat(typeComparators.comparatorByTypes()).containsExactlyElementsOf(defaultComparators);
+    var defaultComparators = defaultTypeComparators().comparatorByTypes().toList();
+    then(typeComparators.comparatorByTypes()).containsExactlyElementsOf(defaultComparators);
   }
 
   @Test
@@ -57,9 +53,9 @@ class RecursiveComparisonConfiguration_comparatorByType_Test {
     recursiveComparisonConfiguration.registerEqualsForType((Tuple t1, Tuple t2) -> false, Tuple.class);
     recursiveComparisonConfiguration.registerComparatorForType(ALWAYS_EQUALS, Double.class);
     // THEN
-    assertThat(recursiveComparisonConfiguration.getComparatorForType(Integer.class)).isSameAs(integerComparator);
-    assertThat(recursiveComparisonConfiguration.getComparatorForType(Tuple.class)).isNotNull();
-    assertThat(recursiveComparisonConfiguration.getComparatorForType(Double.class)).isSameAs(ALWAYS_EQUALS);
+    then(recursiveComparisonConfiguration.getComparatorForDualType(Integer.class)).isSameAs(integerComparator);
+    then(recursiveComparisonConfiguration.getComparatorForDualType(Tuple.class)).isNotNull();
+    then(recursiveComparisonConfiguration.getComparatorForDualType(Double.class)).isSameAs(ALWAYS_EQUALS);
   }
 
   @Test
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_fluent_API_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_fluent_API_Test.java
index e2d12a3e2..c75af8d28 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_fluent_API_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_fluent_API_Test.java
@@ -12,11 +12,11 @@
  */
 package org.assertj.tests.core.api.recursive.comparison.fields;
 
-import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
+import static org.assertj.core.util.DualClass.dualClass;
 import static org.assertj.tests.core.testkit.AlwaysDifferentComparator.alwaysDifferent;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_TIMESTAMP;
@@ -25,10 +25,7 @@ import static org.assertj.tests.core.testkit.BiPredicates.DOUBLE_EQUALS;
 import static org.assertj.tests.core.testkit.BiPredicates.STRING_EQUALS;
 
 import java.sql.Timestamp;
-import java.util.Comparator;
 import java.util.Date;
-import java.util.List;
-import java.util.Map.Entry;
 import java.util.UUID;
 import java.util.regex.Pattern;
 
@@ -49,7 +46,7 @@ class RecursiveComparisonAssert_fluent_API_Test extends WithComparingFieldsIntro
                                           .getRecursiveComparisonConfiguration();
     // THEN
     then(configuration.isInStrictTypeCheckingMode()).isFalse();
-    List<Entry<Class<?>, Comparator<?>>> defaultComparators = defaultTypeComparators().comparatorByTypes().collect(toList());
+    var defaultComparators = defaultTypeComparators().comparatorByTypes().toList();
     then(configuration.getTypeComparators().comparatorByTypes()).containsExactlyElementsOf(defaultComparators);
     then(configuration.comparatorByFields()).isEmpty();
     then(configuration.getIgnoreAllActualNullFields()).isFalse();
@@ -294,10 +291,10 @@ class RecursiveComparisonAssert_fluent_API_Test extends WithComparingFieldsIntro
                                                  .withEqualsForType((o1, o2) -> true, type3)
                                                  .getRecursiveComparisonConfiguration();
     // THEN
-    then(currentConfiguration.getTypeComparators().comparatorByTypes()).contains(entry(type1, ALWAYS_EQUALS_STRING),
-                                                                                 entry(type2, ALWAYS_EQUALS_TIMESTAMP));
-    then(currentConfiguration.getTypeComparators().comparatorByTypes()).anyMatch(entry -> entry.getKey().equals(type3)
-                                                                                          && entry.getValue() != null);
+    then(currentConfiguration.comparatorByTypes()).contains(entry(dualClass(type1, null), ALWAYS_EQUALS_STRING),
+                                                            entry(dualClass(type2, null), ALWAYS_EQUALS_TIMESTAMP))
+                                                  .anyMatch(entry -> entry.getKey().actual().equals(type3)
+                                                                     && entry.getValue() != null);
   }
 
   @Test
@@ -334,8 +331,8 @@ class RecursiveComparisonAssert_fluent_API_Test extends WithComparingFieldsIntro
                                                  .withEqualsForType((o1, o2) -> false, type2)
                                                  .getRecursiveComparisonConfiguration();
     // THEN
-    then(currentConfiguration.getComparatorForType(type1)).isSameAs(alwaysDifferentComparator);
-    then(currentConfiguration.getComparatorForType(type2)).isNotSameAs(alwaysEqualComparator);
+    then(currentConfiguration.getComparatorForDualType(type1)).isSameAs(alwaysDifferentComparator);
+    then(currentConfiguration.getComparatorForDualType(type2)).isNotSameAs(alwaysEqualComparator);
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_for_iterables_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_for_iterables_Test.java
index 22ed95f54..c6b1e0727 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_for_iterables_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_for_iterables_Test.java
@@ -16,6 +16,7 @@ import static com.google.common.collect.Sets.newHashSet;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.DualClass.dualClass;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
 
@@ -53,7 +54,7 @@ class RecursiveComparisonAssert_for_iterables_Test extends WithComparingFieldsIn
                                           .usingRecursiveComparison(recursiveComparisonConfiguration)
                                           .getRecursiveComparisonConfiguration();
     // THEN
-    then(configuration.getTypeComparators().comparatorByTypes()).contains(entry(String.class, ALWAYS_EQUALS_STRING));
+    then(configuration.comparatorByTypes()).contains(entry(dualClass(String.class, null), ALWAYS_EQUALS_STRING));
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_for_object_arrays_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_for_object_arrays_Test.java
index 2ea13f675..c1cd69c32 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_for_object_arrays_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_for_object_arrays_Test.java
@@ -15,6 +15,7 @@ package org.assertj.tests.core.api.recursive.comparison.fields;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.DualClass.dualClass;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
 
 import org.assertj.tests.core.api.recursive.data.Person;
@@ -42,7 +43,7 @@ class RecursiveComparisonAssert_for_object_arrays_Test extends WithComparingFiel
                                                  .usingRecursiveComparison(recursiveComparisonConfiguration)
                                                  .getRecursiveComparisonConfiguration();
     // THEN
-    assertThat(currentConfiguration.getTypeComparators().comparatorByTypes()).contains(entry(String.class, ALWAYS_EQUALS_STRING));
+    then(currentConfiguration.comparatorByTypes()).contains(entry(dualClass(String.class, null), ALWAYS_EQUALS_STRING));
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_Test.java
index 604cab521..143fa259b 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -18,6 +18,7 @@ import static org.assertj.core.api.BDDAssertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.DualClass.dualClass;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Maps.newHashMap;
@@ -107,7 +108,8 @@ class RecursiveComparisonAssert_isEqualTo_Test extends WithComparingFieldsIntros
                                           .usingRecursiveComparison(recursiveComparisonConfiguration)
                                           .getRecursiveComparisonConfiguration();
     // THEN
-    then(configuration.getTypeComparators().comparatorByTypes()).contains(entry(String.class, ALWAYS_EQUALS_STRING));
+    then(configuration.comparatorByTypes()).contains(entry(dualClass(String.class, null), ALWAYS_EQUALS_STRING));
+
   }
 
   @Test
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
index 06a60abdc..13061ff4d 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
@@ -24,6 +24,8 @@ import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.sql.Timestamp;
+import java.time.LocalTime;
+import java.time.ZoneOffset;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.Map;
@@ -36,6 +38,8 @@ import org.assertj.tests.core.api.recursive.data.Address;
 import org.assertj.tests.core.api.recursive.data.AlwaysEqualPerson;
 import org.assertj.tests.core.api.recursive.data.Giant;
 import org.assertj.tests.core.api.recursive.data.Person;
+import org.assertj.tests.core.api.recursive.data.TimeOffset;
+import org.assertj.tests.core.api.recursive.data.TimeOffsetDto;
 import org.assertj.tests.core.testkit.AlwaysDifferentComparator;
 import org.assertj.tests.core.testkit.AlwaysEqualComparator;
 import org.assertj.tests.core.testkit.AtPrecisionComparator;
@@ -60,8 +64,8 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
                      .forEach(entry -> recursiveComparisonConfiguration.registerComparatorForType(entry.getValue(),
                                                                                                   entry.getKey()));
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .isEqualTo(expected);
   }
 
   @ParameterizedTest(name = "{3}: actual={0} / expected={1} - comparatorsByType: {2}")
@@ -75,8 +79,8 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
                      .forEach(entry -> recursiveComparisonConfiguration.registerEqualsForType(asBiPredicate(entry.getValue()),
                                                                                               entry.getKey()));
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .isEqualTo(expected);
   }
 
   private static BiPredicate<Object, Object> asBiPredicate(Comparator<Object> comparator) {
@@ -154,12 +158,12 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     goliathTwin.height = 3.1;
 
     // THEN
-    assertThat(goliath).usingRecursiveComparison(recursiveComparisonConfiguration)
-                       .withComparatorForType(new AtPrecisionComparator<>(0.2), Double.class)
-                       .isEqualTo(goliathTwin);
-    assertThat(goliath).usingRecursiveComparison(recursiveComparisonConfiguration)
-                       .withEqualsForType((d1, d2) -> Math.abs(d1 - d2) < 0.2, Double.class)
-                       .isEqualTo(goliathTwin);
+    then(goliath).usingRecursiveComparison(recursiveComparisonConfiguration)
+                 .withComparatorForType(new AtPrecisionComparator<>(0.2), Double.class)
+                 .isEqualTo(goliathTwin);
+    then(goliath).usingRecursiveComparison(recursiveComparisonConfiguration)
+                 .withEqualsForType((d1, d2) -> Math.abs(d1 - d2) < 0.2, Double.class)
+                 .isEqualTo(goliathTwin);
   }
 
   @Test
@@ -168,12 +172,12 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     Patient actual = new Patient(null);
     Patient expected = new Patient(new Timestamp(3L));
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withComparatorForType(ALWAYS_EQUALS_TIMESTAMP, Timestamp.class)
-                      .isEqualTo(expected);
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withEqualsForType((o1, o2) -> true, Timestamp.class)
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withComparatorForType(ALWAYS_EQUALS_TIMESTAMP, Timestamp.class)
+                .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withEqualsForType((o1, o2) -> true, Timestamp.class)
+                .isEqualTo(expected);
   }
 
   @Test
@@ -183,10 +187,9 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     Patient actual = new Patient(dateOfBirth);
     Patient expected = new Patient(dateOfBirth);
     // THEN
-    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                                                                                 .withComparatorForType(NEVER_EQUALS,
-                                                                                                        Timestamp.class)
-                                                                                 .isEqualTo(expected));
+    var assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                                                      .withComparatorForType(NEVER_EQUALS, Timestamp.class)
+                                                                      .isEqualTo(expected));
     // THEN
     then(assertionError).hasMessageContaining("- java.sql.Timestamp -> org.assertj.tests.core.testkit.NeverEqualComparator");
   }
@@ -198,12 +201,11 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     Patient actual = new Patient(dateOfBirth);
     Patient expected = new Patient(dateOfBirth);
     // THEN
-    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                                                                                 .withEqualsForType((o1, o2) -> false,
-                                                                                                    Timestamp.class)
-                                                                                 .isEqualTo(expected));
-    then(assertionError).hasMessageContaining("- java.sql.Timestamp -> ");
+    var assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                                                      .withEqualsForType((o1, o2) -> false, Timestamp.class)
+                                                                      .isEqualTo(expected));
     // THEN
+    then(assertionError).hasMessageContaining("- java.sql.Timestamp -> ");
   }
 
   @Test
@@ -214,12 +216,12 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     Person expected = new Person(actual.name);
     expected.dateOfBirth = new Date(1000L);
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withComparatorForType(SYMMETRIC_DATE_COMPARATOR, Timestamp.class)
-                      .isEqualTo(expected);
-    assertThat(expected).usingRecursiveComparison(recursiveComparisonConfiguration)
-                        .withComparatorForType(SYMMETRIC_DATE_COMPARATOR, Timestamp.class)
-                        .isEqualTo(actual);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withComparatorForType(SYMMETRIC_DATE_COMPARATOR, Timestamp.class)
+                .isEqualTo(expected);
+    then(expected).usingRecursiveComparison(recursiveComparisonConfiguration)
+                  .withComparatorForType(SYMMETRIC_DATE_COMPARATOR, Timestamp.class)
+                  .isEqualTo(actual);
   }
 
   @Test
@@ -232,14 +234,60 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     expected.neighbour = new AlwaysEqualPerson();
     expected.neighbour.name = "Omar2";
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withComparatorForType(ALWAYS_EQUALS, AlwaysEqualPerson.class) // fails if commented
-                      .ignoringOverriddenEqualsForFields("neighbour")
-                      .isEqualTo(expected);
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withEqualsForType((o1, o2) -> true, AlwaysEqualPerson.class) // fails if commented
-                      .ignoringOverriddenEqualsForFields("neighbour")
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withComparatorForType(ALWAYS_EQUALS, AlwaysEqualPerson.class) // fails if commented
+                .ignoringOverriddenEqualsForFields("neighbour")
+                .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withEqualsForType((o1, o2) -> true, AlwaysEqualPerson.class) // fails if commented
+                .ignoringOverriddenEqualsForFields("neighbour")
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_using_a_BiPredicate_to_compare_fields_with_different_types_but_same_values() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.toString();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((t, s) -> LocalTime.parse(s).equals(t), LocalTime.class, String.class)
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_using_two_BiPredicates_that_matches_fields_with_different_types_but_same_values() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    actual.offset = ZoneOffset.UTC;
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.toString();
+    expected.offset = actual.offset.getId();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((z, s) -> ZoneOffset.of(s).equals(z), ZoneOffset.class, String.class)
+                .withEqualsForTypes((t, s) -> LocalTime.parse(s).equals(t), LocalTime.class, String.class)
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_having_two_BiPredicates_with_same_left_type() {
+    // GIVEN
+    LocalTime now = LocalTime.now();
+    TimeOffsetDto actual = new TimeOffsetDto();
+    actual.time = now.toString();
+    actual.offset = "Z";
+    TimeOffset expected = new TimeOffset();
+    expected.time = now;
+    expected.offset = ZoneOffset.UTC;
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((s, z) -> ZoneOffset.of(s).equals(z), String.class, ZoneOffset.class)
+                .withEqualsForTypes((s, t) -> LocalTime.parse(s).equals(t), String.class, LocalTime.class)
+                .isEqualTo(expected);
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isNotEqualTo_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isNotEqualTo_Test.java
index c6cd2bcb6..547d03b3f 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isNotEqualTo_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isNotEqualTo_Test.java
@@ -16,8 +16,13 @@ import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.tests.core.api.recursive.data.Color.GREEN;
 import static org.assertj.tests.core.testkit.NeverEqualComparator.NEVER_EQUALS_STRING;
 
+import java.time.LocalTime;
+import java.time.ZoneOffset;
+
 import org.assertj.tests.core.api.recursive.data.Light;
 import org.assertj.tests.core.api.recursive.data.Person;
+import org.assertj.tests.core.api.recursive.data.TimeOffset;
+import org.assertj.tests.core.api.recursive.data.TimeOffsetDto;
 import org.assertj.tests.core.testkit.CartoonCharacter;
 import org.assertj.tests.core.testkit.Jedi;
 import org.junit.jupiter.api.Test;
@@ -170,4 +175,62 @@ class RecursiveComparisonAssert_isNotEqualTo_Test extends WithComparingFieldsInt
                 .isNotEqualTo(other);
   }
 
+  @Test
+  void should_pass_using_a_BiPredicate_to_compare_fields_with_different_types_and_different_values() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.plusHours(1).toString();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((t, s) -> LocalTime.parse(s).equals(t), LocalTime.class, String.class)
+                .isNotEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_using_a_never_match_BiPredicate_to_compare_fields_with_different_types() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.toString();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((t, s) -> false, LocalTime.class, String.class)
+                .isNotEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_using_at_least_one_BiPredicate_that_not_matching_fields_with_different_types() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    actual.offset = ZoneOffset.UTC;
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.toString();
+    expected.offset = actual.offset.getId();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((z, s) -> ZoneOffset.of(s).equals(z), ZoneOffset.class, String.class)
+                .withEqualsForTypes((t, s) -> false, LocalTime.class, String.class)
+                .isNotEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_having_two_BiPredicates_with_same_left_type_and_one_not_matching_fields_with_different_types() {
+    // GIVEN
+    LocalTime now = LocalTime.now();
+    TimeOffsetDto actual = new TimeOffsetDto();
+    actual.time = now.toString();
+    actual.offset = "Z";
+    TimeOffset expected = new TimeOffset();
+    expected.time = now;
+    expected.offset = ZoneOffset.UTC;
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((s, z) -> ZoneOffset.of(s).equals(z), String.class, ZoneOffset.class)
+                .withEqualsForTypes((s, t) -> false, String.class, LocalTime.class)
+                .isNotEqualTo(expected);
+  }
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_fluent_API_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_fluent_API_Test.java
index 6aa1c8789..f1d322b4b 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_fluent_API_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_fluent_API_Test.java
@@ -12,11 +12,11 @@
  */
 package org.assertj.tests.core.api.recursive.comparison.legacy;
 
-import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
+import static org.assertj.core.util.DualClass.dualClass;
 import static org.assertj.tests.core.testkit.AlwaysDifferentComparator.alwaysDifferent;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_TIMESTAMP;
@@ -25,10 +25,7 @@ import static org.assertj.tests.core.testkit.BiPredicates.DOUBLE_EQUALS;
 import static org.assertj.tests.core.testkit.BiPredicates.STRING_EQUALS;
 
 import java.sql.Timestamp;
-import java.util.Comparator;
 import java.util.Date;
-import java.util.List;
-import java.util.Map.Entry;
 import java.util.UUID;
 import java.util.regex.Pattern;
 
@@ -49,8 +46,8 @@ class RecursiveComparisonAssert_fluent_API_Test extends WithLegacyIntrospectionS
                                           .getRecursiveComparisonConfiguration();
     // THEN
     then(configuration.isInStrictTypeCheckingMode()).isFalse();
-    List<Entry<Class<?>, Comparator<?>>> defaultComparators = defaultTypeComparators().comparatorByTypes().collect(toList());
-    then(configuration.getTypeComparators().comparatorByTypes()).containsExactlyElementsOf(defaultComparators);
+    var defaultComparators = defaultTypeComparators().comparatorByTypes().toList();
+    then(configuration.comparatorByTypes()).containsExactlyElementsOf(defaultComparators);
     then(configuration.comparatorByFields()).isEmpty();
     then(configuration.getIgnoreAllActualNullFields()).isFalse();
     then(configuration.getIgnoredFields()).isEmpty();
@@ -284,10 +281,10 @@ class RecursiveComparisonAssert_fluent_API_Test extends WithLegacyIntrospectionS
                                                  .withEqualsForType((o1, o2) -> true, type3)
                                                  .getRecursiveComparisonConfiguration();
     // THEN
-    then(currentConfiguration.getTypeComparators().comparatorByTypes()).contains(entry(type1, ALWAYS_EQUALS_STRING),
-                                                                                 entry(type2, ALWAYS_EQUALS_TIMESTAMP));
-    then(currentConfiguration.getTypeComparators().comparatorByTypes()).anyMatch(entry -> entry.getKey().equals(type3)
-                                                                                          && entry.getValue() != null);
+    then(currentConfiguration.comparatorByTypes()).contains(entry(dualClass(type1, null), ALWAYS_EQUALS_STRING),
+                                                            entry(dualClass(type2, null), ALWAYS_EQUALS_TIMESTAMP))
+                                                  .anyMatch(entry -> entry.getKey().actual().equals(type3)
+                                                                     && entry.getValue() != null);
   }
 
   @Test
@@ -324,8 +321,8 @@ class RecursiveComparisonAssert_fluent_API_Test extends WithLegacyIntrospectionS
                                                  .withEqualsForType((o1, o2) -> false, type2)
                                                  .getRecursiveComparisonConfiguration();
     // THEN
-    then(currentConfiguration.getComparatorForType(type1)).isSameAs(alwaysDifferentComparator);
-    then(currentConfiguration.getComparatorForType(type2)).isNotSameAs(alwaysEqualComparator);
+    then(currentConfiguration.getComparatorForDualType(type1)).isSameAs(alwaysDifferentComparator);
+    then(currentConfiguration.getComparatorForDualType(type2)).isNotSameAs(alwaysEqualComparator);
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_for_iterables_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_for_iterables_Test.java
index 3b5b27f5f..ef8ae0c09 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_for_iterables_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_for_iterables_Test.java
@@ -16,6 +16,7 @@ import static com.google.common.collect.Sets.newHashSet;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.DualClass.dualClass;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
 
@@ -53,7 +54,7 @@ class RecursiveComparisonAssert_for_iterables_Test extends WithLegacyIntrospecti
                                           .usingRecursiveComparison(recursiveComparisonConfiguration)
                                           .getRecursiveComparisonConfiguration();
     // THEN
-    then(configuration.getTypeComparators().comparatorByTypes()).contains(entry(String.class, ALWAYS_EQUALS_STRING));
+    then(configuration.comparatorByTypes()).contains(entry(dualClass(String.class, null), ALWAYS_EQUALS_STRING));
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_for_object_arrays_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_for_object_arrays_Test.java
index d6e271eb1..f9e8aef7e 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_for_object_arrays_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_for_object_arrays_Test.java
@@ -15,6 +15,7 @@ package org.assertj.tests.core.api.recursive.comparison.legacy;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.DualClass.dualClass;
 import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
 
 import org.assertj.tests.core.api.recursive.data.Person;
@@ -42,7 +43,7 @@ class RecursiveComparisonAssert_for_object_arrays_Test extends WithLegacyIntrosp
                                                  .usingRecursiveComparison(recursiveComparisonConfiguration)
                                                  .getRecursiveComparisonConfiguration();
     // THEN
-    assertThat(currentConfiguration.getTypeComparators().comparatorByTypes()).contains(entry(String.class, ALWAYS_EQUALS_STRING));
+    then(currentConfiguration.comparatorByTypes()).contains(entry(dualClass(String.class, null), ALWAYS_EQUALS_STRING));
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_Test.java
index 7529154cf..a4529ef4d 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -107,7 +107,8 @@ class RecursiveComparisonAssert_isEqualTo_Test extends WithLegacyIntrospectionSt
                                           .usingRecursiveComparison(recursiveComparisonConfiguration)
                                           .getRecursiveComparisonConfiguration();
     // THEN
-    then(configuration.getTypeComparators().comparatorByTypes()).contains(entry(String.class, ALWAYS_EQUALS_STRING));
+    then(configuration.comparatorByTypes()).anyMatch(e -> e.getKey().actual() == String.class && e.getKey().expected() == null
+                                                          && e.getValue() == ALWAYS_EQUALS_STRING);
   }
 
   @Test
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
index 0f15dd197..4f13a6cd3 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
@@ -24,6 +24,8 @@ import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.sql.Timestamp;
+import java.time.LocalTime;
+import java.time.ZoneOffset;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.Map;
@@ -36,6 +38,8 @@ import org.assertj.tests.core.api.recursive.data.Address;
 import org.assertj.tests.core.api.recursive.data.AlwaysEqualPerson;
 import org.assertj.tests.core.api.recursive.data.Giant;
 import org.assertj.tests.core.api.recursive.data.Person;
+import org.assertj.tests.core.api.recursive.data.TimeOffset;
+import org.assertj.tests.core.api.recursive.data.TimeOffsetDto;
 import org.assertj.tests.core.testkit.AlwaysDifferentComparator;
 import org.assertj.tests.core.testkit.AlwaysEqualComparator;
 import org.assertj.tests.core.testkit.AtPrecisionComparator;
@@ -46,6 +50,7 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
+@SuppressWarnings("unused")
 class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithLegacyIntrospectionStrategyBaseTest {
 
   @ParameterizedTest(name = "{3}: actual={0} / expected={1} - comparatorsByType: {2}")
@@ -55,12 +60,11 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithL
                                                                                             Map<Class<?>, Comparator<Object>> comparatorByTypes,
                                                                                             String testDescription) {
     // GIVEN
-    comparatorByTypes.entrySet().stream()
-                     .forEach(entry -> recursiveComparisonConfiguration.registerComparatorForType(entry.getValue(),
-                                                                                                  entry.getKey()));
+    comparatorByTypes.forEach((key, value) -> recursiveComparisonConfiguration.registerComparatorForType(value,
+                                                                                                         key));
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .isEqualTo(expected);
   }
 
   @ParameterizedTest(name = "{3}: actual={0} / expected={1} - comparatorsByType: {2}")
@@ -70,12 +74,11 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithL
                                                                                         Map<Class<?>, Comparator<Object>> comparatorByTypes,
                                                                                         String testDescription) {
     // GIVEN
-    comparatorByTypes.entrySet().stream()
-                     .forEach(entry -> recursiveComparisonConfiguration.registerEqualsForType(asBiPredicate(entry.getValue()),
-                                                                                              entry.getKey()));
+    comparatorByTypes.forEach((key, value) -> recursiveComparisonConfiguration.registerEqualsForType(asBiPredicate(value),
+                                                                                                     key));
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .isEqualTo(expected);
   }
 
   private static BiPredicate<Object, Object> asBiPredicate(Comparator<Object> comparator) {
@@ -153,12 +156,12 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithL
     goliathTwin.height = 3.1;
 
     // THEN
-    assertThat(goliath).usingRecursiveComparison(recursiveComparisonConfiguration)
-                       .withComparatorForType(new AtPrecisionComparator<>(0.2), Double.class)
-                       .isEqualTo(goliathTwin);
-    assertThat(goliath).usingRecursiveComparison(recursiveComparisonConfiguration)
-                       .withEqualsForType((d1, d2) -> Math.abs(d1 - d2) < 0.2, Double.class)
-                       .isEqualTo(goliathTwin);
+    then(goliath).usingRecursiveComparison(recursiveComparisonConfiguration)
+                 .withComparatorForType(new AtPrecisionComparator<>(0.2), Double.class)
+                 .isEqualTo(goliathTwin);
+    then(goliath).usingRecursiveComparison(recursiveComparisonConfiguration)
+                 .withEqualsForType((d1, d2) -> Math.abs(d1 - d2) < 0.2, Double.class)
+                 .isEqualTo(goliathTwin);
   }
 
   @Test
@@ -167,12 +170,12 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithL
     Patient actual = new Patient(null);
     Patient expected = new Patient(new Timestamp(3L));
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withComparatorForType(ALWAYS_EQUALS_TIMESTAMP, Timestamp.class)
-                      .isEqualTo(expected);
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withEqualsForType((o1, o2) -> true, Timestamp.class)
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withComparatorForType(ALWAYS_EQUALS_TIMESTAMP, Timestamp.class)
+                .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withEqualsForType((o1, o2) -> true, Timestamp.class)
+                .isEqualTo(expected);
   }
 
   @Test
@@ -182,10 +185,9 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithL
     Patient actual = new Patient(dateOfBirth);
     Patient expected = new Patient(dateOfBirth);
     // THEN
-    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                                                                                 .withComparatorForType(NEVER_EQUALS,
-                                                                                                        Timestamp.class)
-                                                                                 .isEqualTo(expected));
+    var assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                                                      .withComparatorForType(NEVER_EQUALS, Timestamp.class)
+                                                                      .isEqualTo(expected));
     // THEN
     then(assertionError).hasMessageContaining("- java.sql.Timestamp -> org.assertj.tests.core.testkit.NeverEqualComparator");
   }
@@ -197,12 +199,11 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithL
     Patient actual = new Patient(dateOfBirth);
     Patient expected = new Patient(dateOfBirth);
     // THEN
-    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                                                                                 .withEqualsForType((o1, o2) -> false,
-                                                                                                    Timestamp.class)
-                                                                                 .isEqualTo(expected));
-    then(assertionError).hasMessageContaining("- java.sql.Timestamp -> ");
+    var assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                                                      .withEqualsForType((o1, o2) -> false, Timestamp.class)
+                                                                      .isEqualTo(expected));
     // THEN
+    then(assertionError).hasMessageContaining("- java.sql.Timestamp -> ");
   }
 
   @Test
@@ -213,12 +214,12 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithL
     Person expected = new Person(actual.name);
     expected.dateOfBirth = new Date(1000L);
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withComparatorForType(SYMMETRIC_DATE_COMPARATOR, Timestamp.class)
-                      .isEqualTo(expected);
-    assertThat(expected).usingRecursiveComparison(recursiveComparisonConfiguration)
-                        .withComparatorForType(SYMMETRIC_DATE_COMPARATOR, Timestamp.class)
-                        .isEqualTo(actual);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withComparatorForType(SYMMETRIC_DATE_COMPARATOR, Timestamp.class)
+                .isEqualTo(expected);
+    then(expected).usingRecursiveComparison(recursiveComparisonConfiguration)
+                  .withComparatorForType(SYMMETRIC_DATE_COMPARATOR, Timestamp.class)
+                  .isEqualTo(actual);
   }
 
   @Test
@@ -231,14 +232,60 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test extends WithL
     expected.neighbour = new AlwaysEqualPerson();
     expected.neighbour.name = "Omar2";
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withComparatorForType(ALWAYS_EQUALS, AlwaysEqualPerson.class) // fails if commented
-                      .ignoringOverriddenEqualsForFields("neighbour")
-                      .isEqualTo(expected);
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .withEqualsForType((o1, o2) -> true, AlwaysEqualPerson.class) // fails if commented
-                      .ignoringOverriddenEqualsForFields("neighbour")
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withComparatorForType(ALWAYS_EQUALS, AlwaysEqualPerson.class) // fails if commented
+                .ignoringOverriddenEqualsForFields("neighbour")
+                .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .withEqualsForType((o1, o2) -> true, AlwaysEqualPerson.class) // fails if commented
+                .ignoringOverriddenEqualsForFields("neighbour")
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_using_a_BiPredicate_to_compare_fields_with_different_types_but_same_values() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.toString();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((t, s) -> LocalTime.parse(s).equals(t), LocalTime.class, String.class)
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_using_two_BiPredicates_that_matches_fields_with_different_types_but_same_values() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    actual.offset = ZoneOffset.UTC;
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.toString();
+    expected.offset = actual.offset.getId();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((z, s) -> ZoneOffset.of(s).equals(z), ZoneOffset.class, String.class)
+                .withEqualsForTypes((t, s) -> LocalTime.parse(s).equals(t), LocalTime.class, String.class)
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_having_two_BiPredicates_with_same_left_type() {
+    // GIVEN
+    LocalTime now = LocalTime.now();
+    TimeOffsetDto actual = new TimeOffsetDto();
+    actual.time = now.toString();
+    actual.offset = "Z";
+    TimeOffset expected = new TimeOffset();
+    expected.time = now;
+    expected.offset = ZoneOffset.UTC;
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((s, z) -> ZoneOffset.of(s).equals(z), String.class, ZoneOffset.class)
+                .withEqualsForTypes((s, t) -> LocalTime.parse(s).equals(t), String.class, LocalTime.class)
+                .isEqualTo(expected);
   }
 
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isNotEqualTo_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isNotEqualTo_Test.java
index f06f40bcb..acb5d015e 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isNotEqualTo_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isNotEqualTo_Test.java
@@ -16,8 +16,13 @@ import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.tests.core.api.recursive.data.Color.GREEN;
 import static org.assertj.tests.core.testkit.NeverEqualComparator.NEVER_EQUALS_STRING;
 
+import java.time.LocalTime;
+import java.time.ZoneOffset;
+
 import org.assertj.tests.core.api.recursive.data.Light;
 import org.assertj.tests.core.api.recursive.data.Person;
+import org.assertj.tests.core.api.recursive.data.TimeOffset;
+import org.assertj.tests.core.api.recursive.data.TimeOffsetDto;
 import org.assertj.tests.core.testkit.CartoonCharacter;
 import org.assertj.tests.core.testkit.Jedi;
 import org.junit.jupiter.api.Test;
@@ -170,4 +175,62 @@ class RecursiveComparisonAssert_isNotEqualTo_Test extends WithLegacyIntrospectio
                 .isNotEqualTo(other);
   }
 
+  @Test
+  void should_pass_using_a_BiPredicate_to_compare_fields_with_different_types_and_different_values() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.plusHours(1).toString();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((t, s) -> LocalTime.parse(s).equals(t), LocalTime.class, String.class)
+                .isNotEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_using_a_never_match_BiPredicate_to_compare_fields_with_different_types() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.toString();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((t, s) -> false, LocalTime.class, String.class)
+                .isNotEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_using_at_least_one_BiPredicate_that_not_matching_fields_with_different_types() {
+    // GIVEN
+    TimeOffset actual = new TimeOffset();
+    actual.time = LocalTime.now();
+    actual.offset = ZoneOffset.UTC;
+    TimeOffsetDto expected = new TimeOffsetDto();
+    expected.time = actual.time.toString();
+    expected.offset = actual.offset.getId();
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((z, s) -> ZoneOffset.of(s).equals(z), ZoneOffset.class, String.class)
+                .withEqualsForTypes((t, s) -> false, LocalTime.class, String.class)
+                .isNotEqualTo(expected);
+  }
+
+  @Test
+  void should_pass_having_two_BiPredicates_with_same_left_type_and_one_not_matching_fields_with_different_types() {
+    // GIVEN
+    LocalTime now = LocalTime.now();
+    TimeOffsetDto actual = new TimeOffsetDto();
+    actual.time = now.toString();
+    actual.offset = "Z";
+    TimeOffset expected = new TimeOffset();
+    expected.time = now;
+    expected.offset = ZoneOffset.UTC;
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForTypes((s, z) -> ZoneOffset.of(s).equals(z), String.class, ZoneOffset.class)
+                .withEqualsForTypes((s, t) -> false, String.class, LocalTime.class)
+                .isNotEqualTo(expected);
+  }
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/TimeOffset.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/TimeOffset.java
new file mode 100644
index 000000000..f307050ff
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/TimeOffset.java
@@ -0,0 +1,21 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.data;
+
+import java.time.LocalTime;
+import java.time.ZoneOffset;
+
+public class TimeOffset {
+  public LocalTime time;
+  public ZoneOffset offset;
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/TimeOffsetDto.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/TimeOffsetDto.java
new file mode 100644
index 000000000..019b35e6c
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/data/TimeOffsetDto.java
@@ -0,0 +1,18 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.data;
+
+public class TimeOffsetDto {
+  public String time;
+  public String offset;
+}
