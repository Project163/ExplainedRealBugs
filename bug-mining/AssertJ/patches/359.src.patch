diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index a1497daf3..ee4a7d120 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -65,12 +65,13 @@ public class RecursiveComparisonDifferenceCalculator {
   private static final Map<Class<?>, Boolean> customHash = new ConcurrentHashMap<>();
 
   private static class ComparisonState {
-    Set<DualValue> visitedDualValues;
+    // Not using a Set as we want to precisely track visited values, a set would remove duplicates
+    List<DualValue> visitedDualValues;
     List<ComparisonDifference> differences = new ArrayList<>();
     DualValueDeque dualValuesToCompare;
     RecursiveComparisonConfiguration recursiveComparisonConfiguration;
 
-    public ComparisonState(Set<DualValue> visited, RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
+    public ComparisonState(List<DualValue> visited, RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
       this.visitedDualValues = visited;
       this.dualValuesToCompare = new DualValueDeque(recursiveComparisonConfiguration);
       this.recursiveComparisonConfiguration = recursiveComparisonConfiguration;
@@ -131,10 +132,19 @@ public class RecursiveComparisonDifferenceCalculator {
       } else {
         dualValuesToCompare.addFirst(dualValue);
       }
-      // need to remove already visited fields pair to avoid infinite recursion in case
+      // We need to remove already visited fields pair to avoid infinite recursion in case
       // parent -> set{child} with child having a reference back to parent
       // it occurs to unordered collection where we compare all possible combination of the collection elements recursively
-      dualValuesToCompare.removeAll(visitedDualValues);
+      // --
+      // Don't use removeAll which uses equals to compare values, comparison must be done by reference otherwise we could remove
+      // values too agressively, that occurs when we add a duplicate of a value already visited.
+      // Example:
+      // - a and a are duplicates but are not the same object, i.e. a equals a' but a' != a
+      // - visitedDualValues = {a , b , c}
+      // - dualValuesToCompare = {a'}
+      // dualValuesToCompare.removeAll(visitedDualValues) would remove it which is incorrect
+      // If we compare references then a' won't be removed from dualValuesToCompare
+      visitedDualValues.forEach(visited -> dualValuesToCompare.removeIf(toCompare -> toCompare == visited));
     }
 
     private boolean mustCompareFieldsRecursively(boolean isRootObject, DualValue dualValue) {
@@ -172,14 +182,14 @@ public class RecursiveComparisonDifferenceCalculator {
       return list(expectedAndActualTypeDifference(actual, expected));
     }
     List<String> rootPath = list();
-    final Set<DualValue> visited = new HashSet<>();
+    List<DualValue> visited = list();
     return determineDifferences(actual, expected, rootPath, true, visited, recursiveComparisonConfiguration);
   }
 
   // TODO keep track of ignored fields in an RecursiveComparisonExecution class ?
 
   private static List<ComparisonDifference> determineDifferences(Object actual, Object expected, List<String> parentPath,
-                                                                 boolean isRootObject, Set<DualValue> visited,
+                                                                 boolean isRootObject, List<DualValue> visited,
                                                                  RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     ComparisonState comparisonState = new ComparisonState(visited, recursiveComparisonConfiguration);
     comparisonState.initDualValuesToCompare(actual, expected, parentPath, isRootObject);
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
index e415bd32c..8c833fda7 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
@@ -18,6 +18,7 @@ import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 
+import java.util.List;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
@@ -231,4 +232,67 @@ public class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
     verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, friendsDifference);
   }
 
+  @Test
+  public void should_fix_1854() {
+    // Original Lists
+    List<Integer> listA = list(1, 2);
+    List<Integer> listB = list(1, 2);
+
+    // --------------------------------------------------------------------------------------------------------------
+    // Base test case - compare against exact copies of the original lists
+    List<Integer> listACopy = list(1, 2);
+    List<Integer> listBCopy = list(1, 2);
+    // The lists themselves are equal to each other.
+    assertThat(listA).usingRecursiveComparison()
+                     .ignoringCollectionOrder()
+                     .isEqualTo(listACopy);
+    assertThat(listB).usingRecursiveComparison()
+                     .ignoringCollectionOrder()
+                     .isEqualTo(listBCopy);
+    // Also, nested lists are still considered equal (regardless of the order of the top-level list)
+    assertThat(list(listA, listB)).usingRecursiveComparison()
+                                  .ignoringCollectionOrder()
+                                  .isEqualTo(list(listACopy, listBCopy))
+                                  .isEqualTo(list(listBCopy, listACopy));
+
+    // --------------------------------------------------------------------------------------------------------------
+    // Reversed test case - compare against reversed copies of the original lists
+    List<Integer> listAReverse = list(2, 1);
+    List<Integer> listBReverse = list(2, 1);
+    // The lists themselves are still equal to each other. So far so good.
+    assertThat(listA).usingRecursiveComparison()
+                     .ignoringCollectionOrder()
+                     .isEqualTo(listAReverse);
+    assertThat(listB).usingRecursiveComparison()
+                     .ignoringCollectionOrder()
+                     .isEqualTo(listBReverse);
+    // Also, comparing a list with one reversed and one copy works!
+    assertThat(list(listA, listB)).usingRecursiveComparison()
+                                  .ignoringCollectionOrder()
+                                  .isEqualTo(list(listACopy, listBReverse))
+                                  .isEqualTo(list(listAReverse, listBCopy));
+
+    // <<<<<<<<<<<<<<<<<<<<<<<< HERE IS THE PROBLEM >>>>>>>>>>>>>>>>>>>>>>>>>>>>
+    // Comparing the original lists against two reversed lists fails!
+    assertThat(list(listA, listB)).usingRecursiveComparison()
+                                  .ignoringCollectionOrder()
+                                  .isEqualTo(list(listAReverse, listBReverse))
+                                  .isEqualTo(list(listBReverse, listAReverse));
+
+    // --------------------------------------------------------------------------------------------------------------
+    // Additional test case - compare against reversed copies of lists with different core elements
+    List<Integer> listC = list(3, 4);
+    List<Integer> listCReverse = list(4, 3);
+    // The lists themselves are equal to each other.
+    assertThat(listC).usingRecursiveComparison()
+                     .ignoringCollectionOrder()
+                     .isEqualTo(listCReverse);
+
+    // Interestingly, both of these assertions work fine!
+    assertThat(list(listA, listC)).usingRecursiveComparison()
+                                  .ignoringCollectionOrder()
+                                  .isEqualTo(list(listAReverse, listCReverse))
+                                  .isEqualTo(list(listCReverse, listAReverse));
+  }
+
 }
