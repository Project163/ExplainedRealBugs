diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 1968b5ce3..4176086f2 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -3150,7 +3150,7 @@ public class Assertions implements InstanceOfAssertFactories {
   }
 
   /**
-   * Register a {@link Representation} that will be used in all following assertions.
+   * Use the given {@link Representation} in all remaining tests assertions.
    * <p>
    * {@link Representation} are used to format types in assertions error messages.
    * <p>
@@ -3238,7 +3238,9 @@ public class Assertions implements InstanceOfAssertFactories {
   }
 
   /**
-   * Fallback to use {@link StandardRepresentation} to revert the effect of calling {@link #useRepresentation(Representation)}.
+   * Reset the representaion being used to the one from the {@link Configuration} to revert the effect of calling {@link #useRepresentation(Representation)}.
+   * <p>
+   * Unless a specific {@link Configuration} is in use, this method resets the representation to the {@link StandardRepresentation}. 
    *
    * @since 2.5.0 / 3.5.0
    */
diff --git a/src/main/java/org/assertj/core/configuration/ConfigurationProvider.java b/src/main/java/org/assertj/core/configuration/ConfigurationProvider.java
index 379a406c2..9d569c2fb 100644
--- a/src/main/java/org/assertj/core/configuration/ConfigurationProvider.java
+++ b/src/main/java/org/assertj/core/configuration/ConfigurationProvider.java
@@ -14,8 +14,11 @@ package org.assertj.core.configuration;
 
 import static java.lang.String.format;
 import static org.assertj.core.configuration.Configuration.DEFAULT_CONFIGURATION;
-import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
 
+import java.util.List;
+import java.util.ServiceLoader;
+
+import org.assertj.core.presentation.CompositeRepresentation;
 import org.assertj.core.presentation.Representation;
 import org.assertj.core.presentation.StandardRepresentation;
 
@@ -30,34 +33,45 @@ import org.assertj.core.presentation.StandardRepresentation;
 public final class ConfigurationProvider {
 
   public static final ConfigurationProvider CONFIGURATION_PROVIDER = new ConfigurationProvider();
-  private final Representation representation;
   private final Configuration configuration;
+  private CompositeRepresentation compositeRepresentation;
 
   private ConfigurationProvider() {
-    representation = Services.get(Representation.class, STANDARD_REPRESENTATION);
-    if (representation != STANDARD_REPRESENTATION) {
-      System.err.println(format("Although it still works, registering a Representation through a file named 'org.assertj.core.presentation.Representation' in the META-INF/services directory is deprecated.%n"
-                                + "The proper way of providing a Representation is to register a Configuration as described in the documentation (a Configuration allowing to provide a Representation and other AssertJ configuration elements)"));
-    }
     configuration = Services.get(Configuration.class, DEFAULT_CONFIGURATION);
     if (configuration != DEFAULT_CONFIGURATION) {
       configuration.applyAndDisplay();
     }
+    List<Representation> representations = Services.getAll(Representation.class);
+    compositeRepresentation = new CompositeRepresentation(representations);
+    if (!configuration.hasCustomRepresentation()) {
+      // registered representations are only used if the configuration representation
+      if (representations.size() == 1) {
+        System.out.println(format("AssertJ has found one registered representation: %s, AssertJ will use it first and then fall back to standard representation if it returned a null representation of the value to display.",
+                                  representations.get(0)));
+      } else if (representations.size() > 1) {
+        System.out.println(format("AssertJ has found %s registered representations, AssertJ will use them first and then fall back to standard representation if they returned a null representation of the value to display, the order (by highest priority first) of use will be: %s",
+                                  representations.size(), compositeRepresentation.getAllRepresentationsOrderedByPriority()));
+      }
+    } else if (!representations.isEmpty()) {
+      System.out.println(format("AssertJ has found these representations %s in the classpath but they won't be used as the loaded configuration has specified a custom representation which takes precedence over representations loaded with the java ServiceLoader: %s",
+                                representations, representation()));
+    }
   }
 
   /**
-   * Returns the default {@link Representation} that needs to be used within AssertJ, which is taken first from:
+   * Returns the {@link Representation} that AssertJ will use, which is taken first from:
    * <ul>
-   * <li>a registered {@link Configuration#representation()} if any </li>
-   * <li>a registered {@link Representation}</li>
+   * <li>the representation returned by a custom {@link Configuration} through {@link Configuration#representation()} but only if it is different from the {@link StandardRepresentation}</li>
+   * <li>the {@link Representation} with highest priority loaded from the classpath by the {@link ServiceLoader}</li>
    * </ul>
-   * If no custom representation was registered, the {@link StandardRepresentation} will be used.
-   *
+   * If no custom representation was registered or overridden in a specific {@link Configuration}, the {@link StandardRepresentation} is used.
+   * <p>
    * @return the default {@link Representation} that needs to be used within AssertJ
    * @since 2.9.0 / 3.9.0
+   * @since 3.22.0 support for registered multiple {@link Representation}s with priority. 
    */
   public Representation representation() {
-    return configuration.hasCustomRepresentation() ? configuration.representation() : representation;
+    return configuration.hasCustomRepresentation() ? configuration.representation() : compositeRepresentation;
   }
 
   /**
diff --git a/src/main/java/org/assertj/core/configuration/Services.java b/src/main/java/org/assertj/core/configuration/Services.java
index 7f49dcc5f..4b78b6a8b 100644
--- a/src/main/java/org/assertj/core/configuration/Services.java
+++ b/src/main/java/org/assertj/core/configuration/Services.java
@@ -13,8 +13,10 @@
 package org.assertj.core.configuration;
 
 import static java.lang.String.format;
+import static org.assertj.core.util.Lists.newArrayList;
 
 import java.util.Iterator;
+import java.util.List;
 import java.util.ServiceLoader;
 
 /**
@@ -38,4 +40,9 @@ class Services {
     }
     return result;
   }
+
+  public static <SERVICE> List<SERVICE> getAll(Class<SERVICE> serviceType) {
+    Iterator<SERVICE> services = ServiceLoader.load(serviceType, Services.class.getClassLoader()).iterator();
+    return newArrayList(services);
+  }
 }
diff --git a/src/main/java/org/assertj/core/presentation/CompositeRepresentation.java b/src/main/java/org/assertj/core/presentation/CompositeRepresentation.java
new file mode 100644
index 000000000..a8b1d4bb6
--- /dev/null
+++ b/src/main/java/org/assertj/core/presentation/CompositeRepresentation.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static java.util.Comparator.comparingInt;
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class CompositeRepresentation implements Representation {
+
+  private final List<Representation> representations;
+
+  public CompositeRepresentation(List<Representation> representations) {
+    if (representations == null) throw new IllegalArgumentException("The given representations should not be null");
+    this.representations = representations.stream()
+                                          .sorted(comparingInt(Representation::getPriority).reversed())
+                                          .collect(toList());
+  }
+
+  @Override
+  public String toStringOf(Object object) {
+    // don't create streams for performance reasons and because this code is simple enough (even not as elegant as with stream)
+    for (Representation representation : representations) {
+      String value = representation.toStringOf(object);
+      if (value != null) return value;
+    }
+    return STANDARD_REPRESENTATION.toStringOf(object);
+  }
+
+  @Override
+  public String unambiguousToStringOf(Object object) {
+    // don't create streams for performance reasons and because this code is simple enough (even not as elegant as with stream)
+    for (Representation representation : representations) {
+      String value = representation.unambiguousToStringOf(object);
+      if (value != null) return value;
+    }
+    return STANDARD_REPRESENTATION.unambiguousToStringOf(object);
+  }
+
+  @Override
+  public String toString() {
+    return representations.isEmpty() ? STANDARD_REPRESENTATION.toString() : representations.toString();
+  }
+
+  public List<Representation> getAllRepresentationsOrderedByPriority() {
+    List<Representation> representationsOrderedByPriority = new ArrayList<>(representations);
+    representationsOrderedByPriority.add(STANDARD_REPRESENTATION);
+    return representationsOrderedByPriority;
+  }
+}
diff --git a/src/main/java/org/assertj/core/presentation/Representation.java b/src/main/java/org/assertj/core/presentation/Representation.java
index 067e31077..05907b938 100644
--- a/src/main/java/org/assertj/core/presentation/Representation.java
+++ b/src/main/java/org/assertj/core/presentation/Representation.java
@@ -12,37 +12,49 @@
  */
 package org.assertj.core.presentation;
 
+import java.util.ServiceLoader;
+
 import org.assertj.core.api.Assertions;
+import org.assertj.core.configuration.Configuration;
 
 /**
- * Controls the formatting (String representation) of types in assertion error message.
+ * Controls the formatting (String representation) of types in assertion error messages.
  * <p>
- * There are two ways to replace the default {@link Representation} ({@link StandardRepresentation}):  
+ * There are several ways to replace the {@link StandardRepresentation} as the default {@link Representation}:  
  * <ul>
- * <li>call {@link Assertions#useRepresentation(Representation)}, from this point all the assertions will use the given representation</li>
- * <li>register a representation as a service discovered at program startup</li>
+ * <li>call {@link Assertions#useRepresentation(Representation)}, from this point all assertions will use the given representation.</li>
+ * <li>use a {@link Configuration} overriding the default representation specified with {@link Configuration#representation()} as explained <a href="https://assertj.github.io/doc/#automatic-configuration-discovery">here</a>.</li>
+ * <li>register a representation as a service discovered at program startup.</li>
  * </ul>
  * <p>
- * The advantage of registering a representation is that you don't need to do anything in your tests, the java runtime will discover it 
- * and AssertJ will use it but it requires a bit more work than a simple call to {@link Assertions#useRepresentation(Representation)}.  
+ * The advantage of registering a representation (or a  configuration overriding the default representation) is that you don't need to do anything in your tests, 
+ * the java runtime will discover it and AssertJ will use it but it requires a bit more work than a simple call to {@link Assertions#useRepresentation(Representation)}.  
+ * <p>
+ * Note that a {@link Configuration} overriding the default representation takes precedence over any registered representation. 
  * <p>
  * To register a {@link Representation}, you need to do several things:
  * <ul>
  * <li>create a file named {@code org.assertj.core.presentation.Representation} file in META-INF/services directory</li>
  * <li>put the fully qualified class name of your {@link Representation} in it</li>   
  * <li>make sure {@code META-INF/services/org.assertj.core.presentation.Representation} is in the runtime classpath, usually putting it in {@code src/test/resources} is enough</li>
- * <li>we recommend that you extend from the {@link StandardRepresentation} and override the
- * {@link StandardRepresentation#fallbackToStringOf(Object)}. By doing this all the defaults of AssertJ would be applied and you can apply your own customization</li>
  * </ul>
  * <p>
  * The <a href="https://github.com/assertj/assertj-examples/tree/main/assertions-examples">assertj-examples</a> project provides a working example of registering a custom representation.
  * <p>
  * Registering a representation has been introduced in AssertJ 2.9.0/3.9.0.  
+ * <p>
+ * Since 3.22.0, AssertJ can load multiples representations from the classpath, the idea behind is that different domain-specific libraries would be able to 
+ * independently register representations for their respective domain. AssertJ aggregate them in a {@link CompositeRepresentation} which loops over 
+ * the different representations and use the first non null representation value of the variable to display. If multiples representations overlap the highest priority one wins (see {@link #getPriority()}).   
+ * The {@link StandardRepresentation} is the fallback option when all the registered representations returned a null representation of the value to display (meaning they did not know how to represent the value).
+ * <p>
  * 
  * @author Mariusz Smykula
  */
 public interface Representation {
 
+  int DEFAULT_PRIORITY = 1;
+
   /**
    * Returns the {@code String} representation of the given object. It may or may not be the object's own implementation of
    * {@code toString}.
@@ -61,4 +73,18 @@ public interface Representation {
    */
   String unambiguousToStringOf(Object object);
 
+  /**
+   * In case multiple representations are loaded through {@link ServiceLoader} and they can represent the same types the one with the highest priority is selected.
+   * If representations have the same priority, there is no guarantee which one is selected (but one will).
+   * <p>
+   * The {@link StandardRepresentation} is the fallback option when all the registered representations returned a null representation of the value to display (meaning they did not know how to represent the value).
+   * <p>
+   * The default priority is 1.
+   * 
+   * @return the representation priority.
+   */
+  default int getPriority() {
+    return DEFAULT_PRIORITY;
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/presentation/CompositeRepresentation_Test.java b/src/test/java/org/assertj/core/presentation/CompositeRepresentation_Test.java
new file mode 100644
index 000000000..e723e7e3a
--- /dev/null
+++ b/src/test/java/org/assertj/core/presentation/CompositeRepresentation_Test.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static java.util.Collections.emptyList;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+
+public class CompositeRepresentation_Test extends AbstractBaseRepresentationTest {
+
+  @Test
+  void should_use_representation_with_highest_priority() {
+    // GIVEN
+    Representation representationP1 = representation(1);
+    Representation representationP2 = representation(2);
+    Representation representationP3 = representation(3);
+    List<Representation> representations = list(representationP1, representationP3, representationP2);
+    CompositeRepresentation compositeRepresentation = new CompositeRepresentation(representations);
+    // WHEN
+    String toString = compositeRepresentation.toStringOf("foo");
+    String unambiguousToString = compositeRepresentation.unambiguousToStringOf("foo");
+    // THEN
+    then(toString).isEqualTo("3");
+    then(unambiguousToString).isEqualTo("3");
+  }
+
+  @Test
+  void should_use_standard_representation_if_composite_representation_is_not_given_any_specific_representation() {
+    // GIVEN
+    CompositeRepresentation compositeRepresentation = new CompositeRepresentation(emptyList());
+    // WHEN
+    Object longNumber = 123L;
+    // THEN
+    then(compositeRepresentation.toStringOf(longNumber)).isEqualTo(STANDARD_REPRESENTATION.toStringOf(longNumber));
+    then(compositeRepresentation.unambiguousToStringOf(longNumber)).isEqualTo(STANDARD_REPRESENTATION.unambiguousToStringOf(longNumber));
+  }
+
+  @Test
+  void should_throw_IllegalArgumentException_if_null_list_representations_is_given() {
+    assertThatIllegalArgumentException().isThrownBy(() -> new CompositeRepresentation(null));
+  }
+
+  @Test
+  void should_implement_toString() {
+    // GIVEN
+    Representation representationP1 = representation(1);
+    Representation representationP2 = representation(2);
+    CompositeRepresentation compositeRepresentation = new CompositeRepresentation(list(representationP2, representationP1));
+    // WHEN/THEN
+    then(compositeRepresentation).hasToString("[Representation2, Representation1]");
+  }
+
+  @Test
+  void should_return_all_representations_used_in_order() {
+    // GIVEN
+    Representation representationP1 = representation(1);
+    Representation representationP2 = representation(2);
+    CompositeRepresentation compositeRepresentation = new CompositeRepresentation(list(representationP1, representationP2));
+    // WHEN/THEN
+    then(compositeRepresentation.getAllRepresentationsOrderedByPriority()).containsExactly(representationP2, representationP1,
+                                                                                           STANDARD_REPRESENTATION);
+  }
+
+  private static Representation representation(int priority) {
+    return new Representation() {
+
+      @Override
+      public int getPriority() {
+        return priority;
+      }
+
+      @Override
+      public String unambiguousToStringOf(Object object) {
+        return "" + getPriority();
+      }
+
+      @Override
+      public String toStringOf(Object object) {
+        return "" + getPriority();
+      }
+
+      @Override
+      public String toString() {
+        return "Representation" + getPriority();
+      }
+    };
+  }
+}
