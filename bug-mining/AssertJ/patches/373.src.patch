diff --git a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 39e3bee0b..c5990a118 100644
--- a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -16,7 +16,6 @@ import static org.assertj.core.error.ShouldBeEqualByComparingFieldByFieldRecursi
 import static org.assertj.core.error.ShouldNotBeEqualComparingFieldByFieldRecursively.shouldNotBeEqualComparingFieldByFieldRecursively;
 
 import java.util.Comparator;
-import java.util.Date;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Optional;
@@ -27,7 +26,6 @@ import java.util.OptionalLong;
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCalculator;
-// import org.assertj.core.error.ShouldNotBeEqualComparingFieldByFieldRecursively;
 import org.assertj.core.internal.Failures;
 import org.assertj.core.internal.TypeComparators;
 import org.assertj.core.util.CheckReturnValue;
@@ -506,11 +504,10 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * By default the recursive comparison uses overridden {@code equals} methods to compare fields,
-   * this method allows to  compare recursively all fields <b>except fields with java types</b> (at some point we need to compare something!).
+   * This method instructs the recursive comparison to compare recursively all fields including the one whose type have overridden equals,
+   * <b>except fields with java types</b> (at some point we need to compare something!).
    * <p>
-   * For the recursive comparison to use the overridden {@code equals} of a given type anyway (like {@link Date}) you can register
-   * a type comparator using {@link #withComparatorForType(Comparator, Class)}.
+   * Since 3.17.0 this is the default behavior for recursive comparisons, to revert to the previous behavior call {@link #usingOverriddenEquals()}.
    * <p>
    * Example:
    * <pre><code class='java'> public class Person {
@@ -544,15 +541,18 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * sherlock2.home.address.street = "Butcher Street";
    * sherlock2.home.address.number = 221;
    *
-   * // assertion succeeds but that's not what we expected since the home.address.street fields differ
-   * // but the equals implementation in Address does not compare them.
+   * // Assertion succeeds because:
+   * // - overridden equals are used
+   * // - Address has overridden equals and does not compare street fields.
    * assertThat(sherlock).usingRecursiveComparison()
+   *                     .usingOverriddenEquals()
    *                     .isEqualTo(sherlock2);
    *
-   * // to avoid the previous issue, we force a recursive comparison on the home.address field
-   * // now this assertion fails as we expect since the home.address.street fields differ
+   * // To avoid using Address overridden equals, don't call usingOverriddenEquals() or call ignoringAllOverriddenEquals()
+   * // (calling ignoringAllOverriddenEquals() is actually not required as this is the default behavior).
+   * // This assertion fails as it will compare home.address.street fields which differ
    * assertThat(sherlock).usingRecursiveComparison()
-   *                     .ignoringAllOverriddenEquals()
+   *                      //.ignoringAllOverriddenEquals() // not needed as this is the default
    *                     .isEqualTo(sherlock2);</code></pre>
    *
    * @return this {@link RecursiveComparisonAssert} to chain other methods.
@@ -563,8 +563,67 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * By default the recursive comparison uses overridden {@code equals} methods to compare fields,
-   * this method allows to force a recursive comparison for the given fields (it adds them to the already registered ones).
+   * By default the recursive comparison compare recursively all fields including the ones whose type have overridden equals
+   * <b>except fields with java types</b> (at some point we need to compare something!).
+   * <p>
+   * This method instructs the recursive comparison to use overridden equals.
+   * <p>
+   * Example:
+   * <pre><code class='java'> public class Person {
+   *   String name;
+   *   double height;
+   *   Home home = new Home();
+   * }
+   *
+   * public class Home {
+   *   Address address = new Address();
+   * }
+   *
+   * public static class Address {
+   *   int number;
+   *   String street;
+   *
+   *   // only compares number!
+   *   {@literal @}Override
+   *   public boolean equals(final Object other) {
+   *     if (!(other instanceof Address)) return false;
+   *     Address castOther = (Address) other;
+   *     return Objects.equals(number, castOther.number);
+   *   }
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", 1.80);
+   * sherlock.home.address.street = "Baker Street";
+   * sherlock.home.address.number = 221;
+   *
+   * Person sherlock2 = new Person("Sherlock", 1.80);
+   * sherlock2.home.address.street = "Butcher Street";
+   * sherlock2.home.address.number = 221;
+   *
+   * // assertion succeeds because Address equals does not compare street fields.
+   * assertThat(sherlock).usingRecursiveComparison()
+   *                     .usingOverriddenEquals()
+   *                     .isEqualTo(sherlock2);
+   *
+   * // Assertion fails because:
+   * // - Address equals is not used.
+   * // - street fields are compared and differ.
+   * assertThat(sherlock).usingRecursiveComparison()
+   *                     .isEqualTo(sherlock2);</code></pre>
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   * @since 3.17.0
+   */
+  public SELF usingOverriddenEquals() {
+    recursiveComparisonConfiguration.useOverriddenEquals();
+    return myself;
+  }
+
+  /**
+   * In case you have instructed the recursive to use overridden {@code equals} with {@link #usingOverriddenEquals()},
+   * this method allows to ignore overridden {@code equals} for the given fields (it adds them to the already registered ones).
+   * <p>
+   * Since 3.17.0 all overridden {@code equals} so this method is only relevant if you have called {@link #usingOverriddenEquals()} before.
    * <p>
    * Nested fields can be specified by using dots like this: {@code home.address.street}
    * <p>
@@ -583,7 +642,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    *   int number;
    *   String street;
    *
-   *   // only compares number, ouch!
+   *   // only compares number
    *   {@literal @}Override
    *   public boolean equals(final Object other) {
    *     if (!(other instanceof Address)) return false;
@@ -600,14 +659,19 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * sherlock2.home.address.street = "Butcher Street";
    * sherlock2.home.address.number = 221;
    *
-   * // assertion succeeds but that's not what we expected since the home.address.street fields differ
-   * // but the equals implementation in Address does not compare them.
+   * // Assertion succeeds because:
+   * // - overridden equals are used
+   * // - Address has overridden equals and does not compare street fields.
    * assertThat(sherlock).usingRecursiveComparison()
+   *                     .usingOverriddenEquals()
    *                     .isEqualTo(sherlock2);
    *
-   * // to avoid the previous issue, we force a recursive comparison on the home.address field
-   * // now this assertion fails as we expect since the home.address.street fields differ
+   * // ignoringOverriddenEqualsForFields force a recursive comparison on the given field
+   * // Assertion fails because:
+   * // - Address equals is not used.
+   * // - street fields are compared and differ.
    * assertThat(sherlock).usingRecursiveComparison()
+   *                     .usingOverriddenEquals()
    *                     .ignoringOverriddenEqualsForFields("home.address")
    *                     .isEqualTo(sherlock2);</code></pre>
    *
@@ -624,6 +688,8 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * By default the recursive comparison uses overridden {@code equals} methods to compare fields,
    * this method allows to force a recursive comparison for all fields of the given types (it adds them to the already registered ones).
    * <p>
+   * Since 3.17.0 all overridden {@code equals} so this method is only relevant if you have called {@link #usingOverriddenEquals()} before.
+   * <p>
    * Example:
    * <pre><code class='java'> public class Person {
    *   String name;
@@ -656,14 +722,19 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * sherlock2.home.address.street = "Butcher Street";
    * sherlock2.home.address.number = 221;
    *
-   * // assertion succeeds but that's not what we expected since the home.address.street fields differ
-   * // but the equals implementation in Address does not compare them.
+   * // Assertion succeeds because:
+   * // - overridden equals are used
+   * // - Address has overridden equals and does not compare street fields.
    * assertThat(sherlock).usingRecursiveComparison()
+   *                     .usingOverriddenEquals()
    *                     .isEqualTo(sherlock2);
    *
-   * // to avoid the previous issue, we force a recursive comparison on the Address type
-   * // now this assertion fails as we expect since the home.address.street fields differ
+   * // ignoringOverriddenEqualsForTypes force a recursive comparison on the given types.
+   * // Assertion fails because:
+   * // - Address equals is not used.
+   * // - street fields are compared and differ.
    * assertThat(sherlock).usingRecursiveComparison()
+   *                     .usingOverriddenEquals()
    *                     .ignoringOverriddenEqualsForTypes(Address.class)
    *                     .isEqualTo(sherlock2);</code></pre>
    *
@@ -677,9 +748,11 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * By default the recursive comparison uses overridden {@code equals} methods to compare fields,
+   * In case you have instructed the recursive to use overridden {@code equals} with {@link #usingOverriddenEquals()},
    * this method allows to force a recursive comparison for the fields matching the given regexes (it adds them to the already registered ones).
    * <p>
+   * Since 3.17.0 all overridden {@code equals} so this method is only relevant if you have called {@link #usingOverriddenEquals()} before.
+   * <p>
    * Nested fields can be specified by using dots like: {@code home\.address\.street} ({@code \} is used to escape
    * dots since they have a special meaning in regexes).
    * <p>
@@ -715,14 +788,15 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * sherlock2.home.address.street = "Butcher Street";
    * sherlock2.home.address.number = 221;
    *
-   * // assertion succeeds but that's not what we expected since the home.address.street fields differ
-   * // but the equals implementation in Address does not compare them.
+   * // assertion succeeds because overridden equals are used and thus street fields are mot compared
    * assertThat(sherlock).usingRecursiveComparison()
+   *                     .usingOverriddenEquals()
    *                     .isEqualTo(sherlock2);
    *
-   * // to avoid the previous issue, we force a recursive comparison on home and its fields
+   * // ignoringOverriddenEqualsForFields force a recursive comparison on the field matching the regex
    * // now this assertion fails as we expect since the home.address.street fields differ
    * assertThat(sherlock).usingRecursiveComparison()
+   *                     .usingOverriddenEquals()
    *                     .ignoringOverriddenEqualsForFieldsMatchingRegexes("home.*")
    *                     .isEqualTo(sherlock2);</code></pre>
    *
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 8a2a5e595..4dec7e55c 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -55,7 +55,7 @@ public class RecursiveComparisonConfiguration {
   private List<Class<?>> ignoredOverriddenEqualsForTypes = new ArrayList<>();
   private List<FieldLocation> ignoredOverriddenEqualsForFields = new ArrayList<>();
   private List<Pattern> ignoredOverriddenEqualsForFieldsMatchingRegexes = new ArrayList<>();
-  private boolean ignoreAllOverriddenEquals = false;
+  private boolean ignoreAllOverriddenEquals = true;
 
   // ignore order in collections section
   private boolean ignoreCollectionOrder = false;
@@ -251,6 +251,15 @@ public class RecursiveComparisonConfiguration {
     ignoreAllOverriddenEquals = true;
   }
 
+  /**
+   * Force a recursive comparison on all fields (except java types).
+   * <p>
+   * See {@link RecursiveComparisonAssert#usingOverriddenEquals()} for examples.
+   */
+  public void useOverriddenEquals() {
+    ignoreAllOverriddenEquals = false;
+  }
+
   /**
    * Adds the given fields to the list of fields to force a recursive comparison on.
    * <p>
@@ -598,13 +607,12 @@ public class RecursiveComparisonConfiguration {
   }
 
   private void describeOverriddenEqualsMethodsUsage(StringBuilder description, Representation representation) {
-    boolean isConfiguredToIgnoreSomeOverriddenEqualsMethods = isConfiguredToIgnoreSomeOverriddenEqualsMethods();
     String header = ignoreAllOverriddenEquals
-        ? "- no overridden equals methods were used in the comparison except for java types"
+        ? "- no overridden equals methods were used in the comparison (except for java types)"
         : "- overridden equals methods were used in the comparison";
     description.append(header);
-    if (isConfiguredToIgnoreSomeOverriddenEqualsMethods) {
-      description.append(format(ignoreAllOverriddenEquals ? " and:%n" : ", except for:%n"));
+    if (isConfiguredToIgnoreSomeButNotAllOverriddenEqualsMethods()) {
+      description.append(format(" except for:%n"));
       describeIgnoredOverriddenEqualsMethods(description, representation);
     } else {
       description.append(format("%n"));
@@ -738,10 +746,11 @@ public class RecursiveComparisonConfiguration {
     return join(fieldsDescription).with(", ");
   }
 
-  private boolean isConfiguredToIgnoreSomeOverriddenEqualsMethods() {
-    return !ignoredOverriddenEqualsForFieldsMatchingRegexes.isEmpty()
-           || !ignoredOverriddenEqualsForTypes.isEmpty()
-           || !ignoredOverriddenEqualsForFields.isEmpty();
+  private boolean isConfiguredToIgnoreSomeButNotAllOverriddenEqualsMethods() {
+    boolean ignoreSomeOverriddenEqualsMethods = !ignoredOverriddenEqualsForFieldsMatchingRegexes.isEmpty()
+                                                || !ignoredOverriddenEqualsForTypes.isEmpty()
+                                                || !ignoredOverriddenEqualsForFields.isEmpty();
+    return !ignoreAllOverriddenEquals && ignoreSomeOverriddenEqualsMethods;
   }
 
   private void describeRegisteredComparatorByTypes(StringBuilder description) {
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
index d7c3c780d..99b2d4086 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
@@ -43,6 +43,8 @@ public class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends Rec
   @MethodSource("container_values")
   public void should_fail_as_Person_overridden_equals_should_be_honored(Object actual, Object expected,
                                                                         ComparisonDifference difference) {
+    // GIVEN
+    recursiveComparisonConfiguration.useOverriddenEquals();
     // WHEN
     compareRecursivelyFailsAsExpected(actual, expected);
     // THEN
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index 66653472e..9369ebf2d 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -106,13 +106,13 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
-    assertThat(multiLineDescription).contains("- no overridden equals methods were used in the comparison except for java types");
+    assertThat(multiLineDescription).contains("- no overridden equals methods were used in the comparison (except for java types)");
   }
 
   @Test
   public void should_show_the_ignored_all_overridden_equals_methods_flag_and_additional_ones() {
     // GIVEN
-    recursiveComparisonConfiguration.ignoreAllOverriddenEquals();
+    recursiveComparisonConfiguration.useOverriddenEquals();
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFields("foo", "bar", "foo.bar");
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFieldsMatchingRegexes(".*oo", ".*ar");
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForTypes(String.class, Multimap.class);
@@ -120,7 +120,7 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
     // @format:off
-    assertThat(multiLineDescription).contains(format("- no overridden equals methods were used in the comparison except for java types and:%n" +
+    assertThat(multiLineDescription).contains(format("- overridden equals methods were used in the comparison except for:%n" +
                                                      "  - the following fields: foo, bar, foo.bar%n" +
                                                      "  - the following types: java.lang.String, com.google.common.collect.Multimap%n" +
                                                      "  - the types matching the following regexes: .*oo, .*ar%n"));
@@ -130,12 +130,13 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
   @Test
   public void should_show_the_ignored_overridden_equals_methods_regexes() {
     // GIVEN
+    recursiveComparisonConfiguration.useOverriddenEquals();
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFieldsMatchingRegexes("foo", "bar", "foo.bar");
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
     // @format:off
-    assertThat(multiLineDescription).contains(format("- overridden equals methods were used in the comparison, except for:%n" +
+    assertThat(multiLineDescription).contains(format("- overridden equals methods were used in the comparison except for:%n" +
                                                      "  - the types matching the following regexes: foo, bar, foo.bar%n"));
     // @format:on
   }
@@ -143,30 +144,52 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
   @Test
   public void should_show_the_ignored_overridden_equals_methods_types() {
     // GIVEN
+    recursiveComparisonConfiguration.useOverriddenEquals();
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForTypes(String.class, Multimap.class);
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
     // @format:off
-    assertThat(multiLineDescription).contains(format("- overridden equals methods were used in the comparison, except for:%n" +
+    assertThat(multiLineDescription).contains(format("- overridden equals methods were used in the comparison except for:%n" +
                                                      "  - the following types: java.lang.String, com.google.common.collect.Multimap%n"));
     // @format:on
   }
 
+  @Test
+  public void should_not_show_specific_ignored_overridden_equals_methods_when_all_are_ignored() {
+    // GIVEN
+    recursiveComparisonConfiguration.ignoreAllOverriddenEquals();
+    recursiveComparisonConfiguration.ignoreOverriddenEqualsForTypes(String.class, Multimap.class);
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    assertThat(multiLineDescription).contains("- no overridden equals methods were used in the comparison (except for java types)")
+                                    .doesNotContain("java.lang.String", "com.google.common.collect.Multimap");
+  }
+
   @Test
   public void should_show_the_ignored_overridden_equals_methods_fields() {
     // GIVEN
+    recursiveComparisonConfiguration.useOverriddenEquals();
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFields("foo", "baz", "foo.baz");
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
     // @format:off
     assertThat(multiLineDescription).contains(format(
-               "- overridden equals methods were used in the comparison, except for:%n" +
+               "- overridden equals methods were used in the comparison except for:%n" +
                "  - the following fields: foo, baz, foo.baz%n"));
     // @format:on
   }
 
+  @Test
+  public void should_show_all_overridden_equals_methods_are_ignored_by_default() {
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    assertThat(multiLineDescription).contains("- no overridden equals methods were used in the comparison (except for java types)");
+  }
+
   @Test
   public void should_show_the_ignored_collection_order() {
     // GIVEN
@@ -261,6 +284,7 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
     recursiveComparisonConfiguration.ignoreFields("foo", "bar", "foo.bar");
     recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("f.*", ".ba.", "..b%sr..");
     recursiveComparisonConfiguration.ignoreFieldsOfTypes(UUID.class, ZonedDateTime.class);
+    recursiveComparisonConfiguration.useOverriddenEquals();
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFieldsMatchingRegexes(".*oo", ".ar", "oo.ba");
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForTypes(String.class, Multimap.class);
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFields("foo", "baz", "foo.baz");
@@ -282,7 +306,7 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
                "- the following fields were ignored in the comparison: foo, bar, foo.bar%n" +
                "- the fields matching the following regexes were ignored in the comparison: f.*, .ba., ..b%%sr..%n"+
                "- the following types were ignored in the comparison: java.util.UUID, java.time.ZonedDateTime%n" +
-               "- overridden equals methods were used in the comparison, except for:%n" +
+               "- overridden equals methods were used in the comparison except for:%n" +
                "  - the following fields: foo, baz, foo.baz%n" +
                "  - the following types: java.lang.String, com.google.common.collect.Multimap%n" +
                "  - the types matching the following regexes: .*oo, .ar, oo.ba%n" +
