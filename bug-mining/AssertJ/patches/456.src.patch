diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index c2ba80d2e..f1eab9f5a 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -15,7 +15,6 @@ package org.assertj.core.api.recursive.comparison;
 import static java.lang.String.format;
 import static java.util.Objects.deepEquals;
 import static java.util.stream.Collectors.joining;
-import static java.util.stream.Collectors.toMap;
 import static org.assertj.core.api.recursive.comparison.ComparisonDifference.rootComparisonDifference;
 import static org.assertj.core.api.recursive.comparison.DualValue.DEFAULT_ORDERED_COLLECTION_TYPES;
 import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
@@ -35,6 +34,7 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
@@ -472,9 +472,6 @@ public class RecursiveComparisonDifferenceCalculator {
       comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "sorted maps", actualMap.size(), expectedMap.size()));
       // no need to inspect entries, maps are not equal as they don't have the same size
       return;
-      // TODO instead we could register the diff between expected and actual that is:
-      // - unexpected actual entries (the ones not matching any expected)
-      // - expected entries not found in actual.
     }
     Iterator<Map.Entry<K, V>> expectedMapEntries = expectedMap.entrySet().iterator();
     for (Map.Entry<?, ?> actualEntry : actualMap.entrySet()) {
@@ -503,35 +500,19 @@ public class RecursiveComparisonDifferenceCalculator {
       comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "maps", actualMap.size(), expectedMap.size()));
       // no need to inspect entries, maps are not equal as they don't have the same size
       return;
-      // TODO instead we could register the diff between expected and actual that is:
-      // - unexpected actual entries (the ones not matching any expected)
-      // - expected entries not found in actual.
-    }
-
-    // index expected entries by their key deep hash code
-    Map<Integer, Map.Entry<?, ?>> expectedEntriesByDeepHashCode = expectedMap.entrySet().stream()
-                                                                             .collect(toMap(entry -> deepHashCode(entry.getKey()),
-                                                                                            entry -> entry));
-    // index actual keys by their deep hash code
-    Map<?, Integer> actualDeepHashCodesByKey = actualMap.keySet().stream().collect(toMap(key -> key, key -> deepHashCode(key)));
-    Map<?, ?> unmatchedActualEntries = actualDeepHashCodesByKey.entrySet().stream()
-                                                               .filter(entry -> !expectedEntriesByDeepHashCode.containsKey(entry.getValue()))
-                                                               // back to actual entries
-                                                               .collect(toMap(entry -> entry.getKey(),
-                                                                              entry -> actualMap.get(entry.getKey())));
-    if (!unmatchedActualEntries.isEmpty()) {
-      comparisonState.addDifference(dualValue,
-                                    format("The following actual map entries were not found in the expected map:%n  %s",
-                                           unmatchedActualEntries));
+    }
+    // actual and expected maps same size but do they have the same keys?
+    Set<?> expectedKeysNotFound = new LinkedHashSet<>(expectedMap.keySet());
+    expectedKeysNotFound.removeAll(actualMap.keySet());
+    if (!expectedKeysNotFound.isEmpty()) {
+      comparisonState.addDifference(dualValue, format("The following keys were not found in the actual map value:%n  %s",
+                                                      expectedKeysNotFound));
       return;
     }
-
-    for (Map.Entry<?, ?> actualEntry : actualMap.entrySet()) {
-      int deepHashCode = actualDeepHashCodesByKey.get(actualEntry.getKey());
-      Map.Entry<?, ?> expectedEntry = expectedEntriesByDeepHashCode.get(deepHashCode);
-      // since we have found an entry in expected with the actual entry key, we just need to compare entry values.
-      FieldLocation keyFieldLocation = keyFieldLocation(dualValue.fieldLocation, actualEntry.getKey());
-      comparisonState.registerForComparison(new DualValue(keyFieldLocation, actualEntry.getValue(), expectedEntry.getValue()));
+    // actual and expected maps have the same keys, we need now to compare their values
+    for (Object key : expectedMap.keySet()) {
+      FieldLocation keyFieldLocation = keyFieldLocation(dualValue.fieldLocation, key);
+      comparisonState.registerForComparison(new DualValue(keyFieldLocation, actualMap.get(key), expectedMap.get(key)));
     }
   }
 
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
index 2d00933a2..c36c7e1f9 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -25,6 +25,7 @@ import static org.assertj.core.error.ShouldNotBeNull.shouldNotBeNull;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
 import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Maps.newHashMap;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 import static org.mockito.Mockito.verify;
 
@@ -34,6 +35,7 @@ import java.nio.file.Paths;
 import java.sql.Timestamp;
 import java.util.Date;
 import java.util.List;
+import java.util.Map;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
@@ -455,11 +457,33 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
     ComparisonDifference difference = diff("_children",
                                            mapOf(entry("importantValue", "10"), entry("someNotImportantValue", 1)),
                                            mapOf(entry("bar", "10"), entry("foo", 1)),
-                                           format("The following actual map entries were not found in the expected map:%n"
-                                                  + "  {importantValue=\"10\", someNotImportantValue=1}"));
+                                           format("The following keys were not found in the actual map value:%n  [foo, bar]"));
     verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
   }
 
+  @Test
+  void issue_2475_example_should_succeed() {
+    then(issue2475Map()).usingRecursiveComparison()
+                        .isEqualTo(issue2475Map());
+  }
+
+  private static Map<String, List<String>> issue2475Map() {
+    Map<String, List<String>> map = newHashMap("VMP", list("OztNUFPcnceerHAppabgHT",
+                                                           "IW",
+                                                           "AfBSmPEYfOBwGzWHzQveOi",
+                                                           "dSalYEgeHNTe",
+                                                           "mXjwEZBxeimMiWrmRVePVAwWHtRXfqQyD",
+                                                           "TGgLRwnPQUbZWFr",
+                                                           "pQWceZdDmTXdyQXcJdB",
+                                                           "ProMMnAnRXg"));
+    map.put("Uko", list("pUisdBNIy",
+                        "rfX",
+                        "BagGdILqDLrNRfotwKqjCVNOJxSNoYKtSgBLMEJEJymhZjZvDuwvsqBiJuJpmvWOkiuSobCjRkeWVenaqIdlltsiUMPNtKcDMOAKiRRHHfikxUnOotnJFzNjwyYrcbkNBjxlvici",
+                        "AR",
+                        "dDvIHrhSxskuTvDSdUZwoUDdxFxxaxBWkTiprWPqSPZumdoHkvwPRrecqCLagzeeOjCuSufGwLoKATVaXfIPmjYsVfGuwlyEysXwWbVfPLgbVkaPaQdcVFQfADfDKEJeuQZlKKSsfuXICYWrmOGILeuqXKZyfEXHLnGILUcWmaVRRjrSjXXnHiTXYgdkrDeLEXZnAlbIEUYSblPqOaxuvpmOS"));
+    return map;
+  }
+
   public static class Wrappers {
     private List<Wrapper> values;
 
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
index 5b841b708..4a1f357d8 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
@@ -117,8 +117,7 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
     Map<String, Author> singletonGeorgeMartinMap = singletonMap(georgeMartin.name, georgeMartin);
     return Stream.of(Arguments.of(singletonPratchettMap, singletonGeorgeMartinMap, "group",
                                   singletonPratchettMap, singletonGeorgeMartinMap,
-                                  format("The following actual map entries were not found in the expected map:%n"
-                                         + "  {Terry Pratchett=Author [name=Terry Pratchett]}")),
+                                  format("The following keys were not found in the actual map value:%n  [George Martin]")),
                      Arguments.of(nonSortedPratchettAndMartin, singletonPratchettMap, "group",
                                   nonSortedPratchettAndMartin, singletonPratchettMap,
                                   "actual and expected values are maps of different size, actual size=2 when expected size=1"),
@@ -132,8 +131,7 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
                                   none, pratchett, null),
                      Arguments.of(singletonPratchettMap, singletonMap(georgeMartin.name, pratchett), "group",
                                   singletonPratchettMap, singletonMap(georgeMartin.name, pratchett),
-                                  format("The following actual map entries were not found in the expected map:%n"
-                                         + "  {Terry Pratchett=Author [name=Terry Pratchett]}")),
+                                  format("The following keys were not found in the actual map value:%n  [George Martin]")),
                      Arguments.of(singletonPratchettMap, empty, "group",
                                   singletonPratchettMap, empty,
                                   "actual and expected values are maps of different size, actual size=1 when expected size=0"));
@@ -162,8 +160,7 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
     AssertionError assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison()
                                                                                  .isEqualTo(expected));
     // THEN
-    then(assertionError).hasMessageContaining(format("The following actual map entries were not found in the expected map:%n"
-                                                     + "  {b=b, e=e}"));
+    then(assertionError).hasMessageContaining(format("The following keys were not found in the actual map value:%n  [c, d]"));
   }
 
   static Stream<Arguments> mapWithNonMaps() {
