diff --git a/src/main/java/org/assertj/core/api/AbstractObjectAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
index 896255b73..2b6e234d6 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
@@ -44,10 +44,15 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * Note that comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
    * field using its <code>equals</code> method.
    * <p/>
+   * If an object has a field and a property with the same name, the field value will be used over the property.
+   * <p/>
    * Private fields are used in comparison but this can be disabled using
    * {@link Assertions#setAllowComparingPrivateFields(boolean)}, if disabled only <b>accessible </b>fields values are
    * compared, accessible fields include directly accessible fields (e.g. public) or fields with an accessible getter.
    * <p/>
+   * The objects to compare can be of different types but the fields/properties used in comparison must exist in both, 
+   * for example if actual objct has a name String field, it is expected other object to also have one.
+   * <p/>
    * 
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
@@ -62,7 +67,7 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * @param other the object to compare {@code actual} to.
    * @throws NullPointerException if the actual or other object is {@code null}.
    * @throws AssertionError if the actual and the given object are not lenient equals.
-   * @throws AssertionError if the other object is not an instance of the actual type.
+   * @throws IntrospectionError if one of actual's field to compare can't be found in the other object.
    */
   public S isEqualToIgnoringNullFields(A other) {
     objects.assertIsEqualToIgnoringNullFields(info, actual, other);
@@ -72,16 +77,20 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
   /**
    * Assert that the actual object is equal to given one using a field by field comparison on the given fields only
    * (fields can be inherited fields or nested fields). This can be handy if <code>equals</code> implementation of
-   * objects to compare
-   * does not suit you.
+   * objects to compare does not suit you.
    * <p/>
    * Note that comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
    * field using its <code>equals</code> method.
    * <p/>
+   * If an object has a field and a property with the same name, the field value will be used over the property.
+   * <p/>
    * Private fields are used in comparison but this can be disabled using
    * {@link Assertions#setAllowComparingPrivateFields(boolean)}, if disabled only <b>accessible </b>fields values are
    * compared, accessible fields include directly accessible fields (e.g. public) or fields with an accessible getter.
    * <p/>
+   * The objects to compare can be of different types but the fields/properties used in comparison must exist in both, 
+   * for example if actual objct has a name String field, it is expected other object to also have one.
+   * <p/>
    * 
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT);
@@ -100,7 +109,7 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * @param fieldsUsedInComparison accepted fieldsUsedInComparison for lenient equality.
    * @throws NullPointerException if the actual or other is {@code null}.
    * @throws AssertionError if the actual and the given object are not lenient equals.
-   * @throws AssertionError if the other object is not an instance of the actual type.
+   * @throws IntrospectionError if one of actual's field to compare can't be found in the other object.
    * @throws IntrospectionError if a field does not exist in actual.
    */
   public S isEqualToComparingOnlyGivenFields(A other, String... fieldsUsedInComparison) {
@@ -116,10 +125,15 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * Note that comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
    * field using its <code>equals</code> method.
    * <p/>
+   * If an object has a field and a property with the same name, the field value will be used over the property.
+   * <p/>
    * Private fields are used in comparison but this can be disabled using
    * {@link Assertions#setAllowComparingPrivateFields(boolean)}, if disabled only <b>accessible </b>fields values are
    * compared, accessible fields include directly accessible fields (e.g. public) or fields with an accessible getter.
    * <p/>
+   * The objects to compare can be of different types but the fields/properties used in comparison must exist in both, 
+   * for example if actual objct has a name String field, it is expected other object to also have one.
+   * <p/>
    * 
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
@@ -135,7 +149,7 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * @param fieldsToIgnore ignored fieldsToIgnore for lenient equality.
    * @throws NullPointerException if the actual or given object is {@code null}.
    * @throws AssertionError if the actual and the given object are not lenient equals.
-   * @throws AssertionError if the other object is not an instance of the actual type.
+   * @throws IntrospectionError if one of actual's field to compare can't be found in the other object.
    */
   public S isEqualToIgnoringGivenFields(A other, String... fieldsToIgnore) {
     objects.assertIsEqualToIgnoringGivenFields(info, actual, other, fieldsToIgnore);
@@ -143,16 +157,21 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
   }
 
   /**
-   * Assert that the actual object is equal to the given object based on a field by field comparison (including
+   * Assert that the actual object is equal to the given object based on a field/property by field/property comparison (including
    * inherited fields). This can be handy if <code>equals</code> implementation of objects to compare does not suit you.
    * <p/>
    * Note that comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
    * field using its <code>equals</code> method.
    * <p/>
+   * If an object has a field and a property with the same name, the field value will be used over the property.
+   * <p/>
    * Private fields are used in comparison but this can be disabled using
    * {@link Assertions#setAllowComparingPrivateFields(boolean)}, if disabled only <b>accessible </b>fields values are
    * compared, accessible fields include directly accessible fields (e.g. public) or fields with an accessible getter.
    * <p/>
+   * The objects to compare can be of different types but the fields/properties used in comparison must exist in both, 
+   * for example if actual objct has a name String field, it is expected other object to also have one.
+   * <p/>
    * 
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
@@ -166,8 +185,8 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
    * 
    * @param other the object to compare {@code actual} to.
    * @throws NullPointerException if the actual or given object is {@code null}.
-   * @throws AssertionError if the actual and the given object are not equals field by field.
-   * @throws AssertionError if the other object is not an instance of the actual type.
+   * @throws AssertionError if the actual and the given object are not equals field/property by field/property.
+   * @throws IntrospectionError if one of actual's field to compare can't be found in the other object.
    */
   public S isEqualToComparingFieldByField(A other) {
     objects.assertIsEqualToIgnoringGivenFields(info, actual, other);
diff --git a/src/main/java/org/assertj/core/internal/Objects.java b/src/main/java/org/assertj/core/internal/Objects.java
index 5c3666507..e01707ddd 100644
--- a/src/main/java/org/assertj/core/internal/Objects.java
+++ b/src/main/java/org/assertj/core/internal/Objects.java
@@ -19,7 +19,6 @@ import static org.assertj.core.error.ShouldBeEqualToIgnoringFields.shouldBeEqual
 import static org.assertj.core.error.ShouldBeExactlyInstanceOf.shouldBeExactlyInstance;
 import static org.assertj.core.error.ShouldBeIn.shouldBeIn;
 import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
-import static org.assertj.core.error.ShouldBeInstance.shouldBeInstanceButWasNull;
 import static org.assertj.core.error.ShouldBeInstanceOfAny.shouldBeInstanceOfAny;
 import static org.assertj.core.error.ShouldBeOfClassIn.shouldBeOfClassIn;
 import static org.assertj.core.error.ShouldBeSame.shouldBeSame;
@@ -537,26 +536,24 @@ public class Objects {
    */
   public <A> void assertIsEqualToIgnoringNullFields(AssertionInfo info, A actual, A other) {
     assertNotNull(info, actual);
-    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
     List<String> fieldsNames = new LinkedList<>();
     List<Object> rejectedValues = new LinkedList<>();
     List<Object> expectedValues = new LinkedList<>();
     List<String> nullFields = new LinkedList<>();
     for (Field field : getDeclaredFieldsIncludingInherited(actual.getClass())) {
-      try {
-        Object otherFieldValue = getFieldOrPropertyValue(other, field.getName());
-        if (otherFieldValue == null) {
-          nullFields.add(field.getName());
-        } else {
-          Object actualFieldValue = getFieldOrPropertyValue(actual, field.getName());
-          if (!otherFieldValue.equals(actualFieldValue)) {
-            fieldsNames.add(field.getName());
-            rejectedValues.add(actualFieldValue);
-            expectedValues.add(otherFieldValue);
-          }
+      if (!canReadFieldValue(field, actual)) {
+        continue;
+      }
+      Object otherFieldValue = getFieldOrPropertyValue(other, field.getName());
+      if (otherFieldValue == null) {
+        nullFields.add(field.getName());
+      } else {
+        Object actualFieldValue = getFieldOrPropertyValue(actual, field.getName());
+        if (!otherFieldValue.equals(actualFieldValue)) {
+          fieldsNames.add(field.getName());
+          rejectedValues.add(actualFieldValue);
+          expectedValues.add(otherFieldValue);
         }
-      } catch (IntrospectionError e) {
-        // Not readable field, skip.
       }
     }
     if (!fieldsNames.isEmpty())
@@ -579,7 +576,6 @@ public class Objects {
    */
   public <A> void assertIsEqualToComparingOnlyGivenFields(AssertionInfo info, A actual, A other, String... fields) {
     assertNotNull(info, actual);
-    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
     ByFieldsComparison byFieldsComparison = isEqualToComparingOnlyGivenFields(actual, other, fields);
     if (byFieldsComparison.isFieldsNamesNotEmpty())
       throw failures.failure(info, shouldBeEqualComparingOnlyGivenFields(actual, byFieldsComparison.fieldsNames,
@@ -619,7 +615,6 @@ public class Objects {
    */
   public <A> void assertIsEqualToIgnoringGivenFields(AssertionInfo info, A actual, A other, String... fields) {
     assertNotNull(info, actual);
-    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
     ByFieldsComparison byFieldsComparison = isEqualToIgnoringGivenFields(actual, other, fields);
     if (byFieldsComparison.isFieldsNamesNotEmpty())
       throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, byFieldsComparison.fieldsNames,
@@ -713,25 +708,6 @@ public class Objects {
     return declaredFields;
   }
 
-  /**
-   * Verifies that other object is an instance of the given type.
-   *
-   * @param info contains information about the assertion.
-   * @param other the object to check type against given class.
-   * @param clazz the type to check the given object against.
-   * @throws NullPointerException if the given type is {@code null}.
-   * @throws AssertionError if other is {@code null}.
-   * @throws AssertionError if other is not an instance of the given type.
-   */
-  private void assertOtherTypeIsCompatibleWithActualClass(AssertionInfo info, Object other, Class<?> clazz) {
-    if (other == null) throw failures.failure(info, shouldBeInstanceButWasNull("other", clazz));
-    isInstanceOf(other, clazz, info);
-  }
-
-  private void isInstanceOf(Object object, Class<?> clazz, AssertionInfo info) {
-    if (!clazz.isInstance(object)) throw failures.failure(info, shouldBeInstance(object, clazz));
-  }
-
   public boolean areEqualToIgnoringGivenFields(Object actual, Object other, String... fields) {
     return isEqualToIgnoringGivenFields(actual, other, fields).isFieldsNamesEmpty();
   }
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java
index 7004938e9..b95748774 100644
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingOnlyGivenFields_Test.java
@@ -12,8 +12,9 @@
  */
 package org.assertj.core.internal.objects;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 import static org.assertj.core.error.ShouldBeEqualByComparingOnlyGivenFields.shouldBeEqualComparingOnlyGivenFields;
-import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
@@ -25,9 +26,11 @@ import java.util.List;
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.api.Assertions;
 import org.assertj.core.internal.ObjectsBaseTest;
+import org.assertj.core.test.CartoonCharacter;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Jedi;
 import org.assertj.core.test.Name;
+import org.assertj.core.test.Person;
 import org.assertj.core.test.Player;
 import org.assertj.core.util.introspection.FieldSupport;
 import org.assertj.core.util.introspection.IntrospectionError;
@@ -72,6 +75,13 @@ public class Objects_assertIsEqualToComparingOnlyGivenFields_Test extends Object
 	objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "name", "lightSaberColor");
   }
 
+  @Test
+  public void should_pass_when_fields_are_equal_even_if_objects_types_differ() {
+    CartoonCharacter actual = new CartoonCharacter("Homer Simpson");
+    Person other = new Person("Homer Simpson");
+    objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "name");
+  }
+
   @Test
   public void should_fail_if_actual_is_null() {
 	thrown.expectAssertionError(actualIsNull());
@@ -117,17 +127,16 @@ public class Objects_assertIsEqualToComparingOnlyGivenFields_Test extends Object
   }
 
   @Test
-  public void should_fail_when_objects_to_compare_are_of_different_types() {
-	AssertionInfo info = someInfo();
+  public void should_fail_when_one_of_actual_field_to_compare_can_not_be_found_in_the_other_object() {
 	Jedi actual = new Jedi("Yoda", "Green");
 	Employee other = new Employee();
 	try {
-	  objects.assertIsEqualToComparingOnlyGivenFields(info, actual, other, "name");
-	} catch (AssertionError err) {
-	  verify(failures).failure(info, shouldBeInstance(other, actual.getClass()));
+      objects.assertIsEqualToComparingOnlyGivenFields(someInfo(), actual, other, "lightSaberColor");
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError err) {
+      assertThat(err).hasMessageStartingWith("Unable to obtain the value of <'lightSaberColor'> field/property");
 	  return;
 	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToIgnoringGivenFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToIgnoringGivenFields_Test.java
index 4379c3cfe..0ccf8a60a 100644
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToIgnoringGivenFields_Test.java
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToIgnoringGivenFields_Test.java
@@ -12,8 +12,9 @@
  */
 package org.assertj.core.internal.objects;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 import static org.assertj.core.error.ShouldBeEqualToIgnoringFields.shouldBeEqualToIgnoringGivenFields;
-import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
@@ -26,10 +27,13 @@ import java.util.List;
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.api.Assertions;
 import org.assertj.core.internal.ObjectsBaseTest;
+import org.assertj.core.test.CartoonCharacter;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Jedi;
+import org.assertj.core.test.Person;
 import org.assertj.core.test.TestClassWithRandomId;
 import org.assertj.core.util.introspection.FieldSupport;
+import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.Test;
 
 
@@ -71,6 +75,18 @@ public class Objects_assertIsEqualToIgnoringGivenFields_Test extends ObjectsBase
     objects.assertIsEqualToIgnoringGivenFields(someInfo(), actual, other, "name");
   }
 
+  @Test
+  public void should_pass_when_fields_are_equal_even_if_objects_types_differ() {
+    CartoonCharacter actual = new CartoonCharacter("Homer Simpson");
+    Person other = new Person("Homer Simpson");
+    try {
+      objects.assertIsEqualToIgnoringGivenFields(someInfo(), actual, other, "children");
+    } catch (AssertionError e) {
+      // jacoco instruments code adding properties that will make the test fails => ignore such failure
+      assertThat(e).as("check that failure only comes from jacoco").hasMessageContaining("$jacocoData");
+    }
+  }
+
   @Test
   public void should_fail_if_actual_is_null() {
     thrown.expectAssertionError(actualIsNull());
@@ -130,17 +146,16 @@ public class Objects_assertIsEqualToIgnoringGivenFields_Test extends ObjectsBase
   }
 
   @Test
-  public void should_fail_when_objects_to_compare_are_of_different_types() {
-    AssertionInfo info = someInfo();
+  public void should_fail_when_one_of_actual_field_to_compare_can_not_be_found_in_the_other_object() {
     Jedi actual = new Jedi("Yoda", "Green");
     Employee other = new Employee();
     try {
-      objects.assertIsEqualToIgnoringGivenFields(info, actual, other, "name");
-    } catch (AssertionError err) {
-      verify(failures).failure(info, shouldBeInstance(other, actual.getClass()));
+      objects.assertIsEqualToIgnoringGivenFields(someInfo(), actual, other, "name");
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError err) {
+      assertThat(err).hasMessageStartingWith("Unable to obtain the value of <'lightSaberColor'> field/property");
       return;
     }
-    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToIgnoringNullFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToIgnoringNullFields_Test.java
index 3682f7d54..7cb47d25a 100644
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToIgnoringNullFields_Test.java
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToIgnoringNullFields_Test.java
@@ -12,7 +12,8 @@
  */
 package org.assertj.core.internal.objects;
 
-import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 import static org.assertj.core.error.ShouldBeEqualToIgnoringFields.shouldBeEqualToIgnoringGivenFields;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
@@ -23,10 +24,13 @@ import static org.mockito.Mockito.verify;
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.api.Assertions;
 import org.assertj.core.internal.ObjectsBaseTest;
+import org.assertj.core.test.CartoonCharacter;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Jedi;
+import org.assertj.core.test.Person;
 import org.assertj.core.test.TestClassWithRandomId;
 import org.assertj.core.util.introspection.FieldSupport;
+import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.Test;
 
 /**
@@ -39,85 +43,96 @@ public class Objects_assertIsEqualToIgnoringNullFields_Test extends ObjectsBaseT
 
   @Test
   public void should_pass_when_fields_are_equal() {
-	Jedi actual = new Jedi("Yoda", "Green");
-	Jedi other = new Jedi("Yoda", "Green");
-	objects.assertIsEqualToIgnoringNullFields(someInfo(), actual, other);
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi("Yoda", "Green");
+    objects.assertIsEqualToIgnoringNullFields(someInfo(), actual, other);
   }
 
   @Test
   public void should_pass_when_some_other_field_is_null_but_not_actual() {
-	Jedi actual = new Jedi("Yoda", "Green");
-	Jedi other = new Jedi("Yoda", null);
-	objects.assertIsEqualToIgnoringNullFields(someInfo(), actual, other);
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi("Yoda", null);
+    objects.assertIsEqualToIgnoringNullFields(someInfo(), actual, other);
   }
 
   @Test
-  public void should_fail_if_actual_is_null() {
-	thrown.expectAssertionError(actualIsNull());
-	Jedi other = new Jedi("Yoda", "Green");
-	objects.assertIsEqualToIgnoringNullFields(someInfo(), null, other);
+  public void should_pass_when_fields_are_equal_even_if_objects_types_differ() {
+    Person actual = new Person("Homer Simpson");
+    CartoonCharacter other = new CartoonCharacter("Homer Simpson");
+    try {
+      objects.assertIsEqualToIgnoringNullFields(someInfo(), actual, other);
+    } catch (AssertionError e) {
+      // jacoco instruments code adding properties that will make the test fails => ignore such failure
+      assertThat(e).as("check that failure only comes from jacoco").hasMessageContaining("$jacocoData");
+    }
   }
 
   @Test
-  public void should_fail_when_some_actual_field_is_null_but_not_other() {
-	AssertionInfo info = someInfo();
-	Jedi actual = new Jedi("Yoda", null);
-	Jedi other = new Jedi("Yoda", "Green");
-	try {
-	  objects.assertIsEqualToIgnoringNullFields(info, actual, other);
-	} catch (AssertionError err) {
-	  verify(failures).failure(info,
-		                       shouldBeEqualToIgnoringGivenFields(actual, newArrayList("lightSaberColor"),
-		                                                          newArrayList((Object) null),
-		                                                          newArrayList((Object) "Green"),
-		                                                          newArrayList("strangeNotReadablePrivateField")));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+  public void should_pass_when_private_fields_differ_but_are_not_compared() {
+    boolean allowedToUsePrivateFields = FieldSupport.comparison().isAllowedToUsePrivateFields();
+    Assertions.setAllowComparingPrivateFields(false);
+    TestClassWithRandomId actual = new TestClassWithRandomId("1", 1);
+    TestClassWithRandomId other = new TestClassWithRandomId(null, 1);
+    // s field is ignored because null in other, and id also because it is private without public getter
+    objects.assertIsEqualToIgnoringNullFields(someInfo(), actual, other);
+    // reset
+    Assertions.setAllowComparingPrivateFields(allowedToUsePrivateFields);
   }
 
   @Test
-  public void should_fail_when_a_field_differ() {
-	AssertionInfo info = someInfo();
-	Jedi actual = new Jedi("Yoda", "Green");
-	Jedi other = new Jedi("Soda", "Green");
-	try {
-	  objects.assertIsEqualToIgnoringNullFields(info, actual, other);
-	} catch (AssertionError err) {
-	  verify(failures).failure(info,
-		                       shouldBeEqualToIgnoringGivenFields(actual, newArrayList("name"),
-		                                                          newArrayList((Object) "Yoda"),
-		                                                          newArrayList((Object) "Soda"),
-		                                                          newArrayList("strangeNotReadablePrivateField")));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    Jedi other = new Jedi("Yoda", "Green");
+    objects.assertIsEqualToIgnoringNullFields(someInfo(), null, other);
   }
 
   @Test
-  public void should_fail_when_objects_to_compare_are_of_different_types() {
-	AssertionInfo info = someInfo();
-	Jedi actual = new Jedi("Yoda", "Green");
-	Employee other = new Employee();
-	try {
-	  objects.assertIsEqualToIgnoringNullFields(info, actual, other);
-	} catch (AssertionError err) {
-	  verify(failures).failure(info, shouldBeInstance(other, actual.getClass()));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+  public void should_fail_when_some_actual_field_is_null_but_not_other() {
+    AssertionInfo info = someInfo();
+    Jedi actual = new Jedi("Yoda", null);
+    Jedi other = new Jedi("Yoda", "Green");
+    try {
+      objects.assertIsEqualToIgnoringNullFields(info, actual, other);
+    } catch (AssertionError err) {
+      verify(failures).failure(info,
+                               shouldBeEqualToIgnoringGivenFields(actual, newArrayList("lightSaberColor"),
+                                                                  newArrayList((Object) null),
+                                                                  newArrayList((Object) "Green"),
+                                                                  newArrayList("strangeNotReadablePrivateField")));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
-  public void should_pass_when_private_fields_differ_but_are_not_compared() {
-	boolean allowedToUsePrivateFields = FieldSupport.comparison().isAllowedToUsePrivateFields();
-    Assertions.setAllowComparingPrivateFields(false);
-	TestClassWithRandomId actual = new TestClassWithRandomId("1", 1);
-	TestClassWithRandomId other = new TestClassWithRandomId(null, 1);
-	// s field is ignored because null in other, and id also because it is private without public getter
-	objects.assertIsEqualToIgnoringNullFields(someInfo(), actual, other);
-	// reset
-	Assertions.setAllowComparingPrivateFields(allowedToUsePrivateFields);
+  public void should_fail_when_a_field_differ() {
+    AssertionInfo info = someInfo();
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi("Soda", "Green");
+    try {
+      objects.assertIsEqualToIgnoringNullFields(info, actual, other);
+    } catch (AssertionError err) {
+      verify(failures).failure(info,
+                               shouldBeEqualToIgnoringGivenFields(actual, newArrayList("name"),
+                                                                  newArrayList((Object) "Yoda"),
+                                                                  newArrayList((Object) "Soda"),
+                                                                  newArrayList("strangeNotReadablePrivateField")));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_when_one_of_actual_field_to_compare_can_not_be_found_in_the_other_object() {
+    Jedi actual = new Jedi("Yoda", "Green");
+    Employee other = new Employee();
+    try {
+      objects.assertIsEqualToIgnoringNullFields(someInfo(), actual, other);
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError err) {
+      assertThat(err).hasMessageStartingWith("Unable to obtain the value of <'lightSaberColor'> field/property");
+      return;
+    }
   }
 
 }
