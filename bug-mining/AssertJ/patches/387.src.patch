diff --git a/pom.xml b/pom.xml
index cfa8c2785..0bf99896f 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd ">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd ">
   <modelVersion>4.0.0</modelVersion>
   <artifactId>assertj-core</artifactId>
   <version>3.17.3-SNAPSHOT</version>
@@ -75,10 +76,7 @@
       <scope>provided</scope>
       <optional>true</optional>
       <exclusions>
-        <!--
-        This has to be excluded because it's subjecting the code to the
-        incorrect version of certain hamcrest packages.
-        -->
+        <!-- This has to be excluded because it's subjecting the code to the incorrect version of certain hamcrest packages. -->
         <exclusion>
           <groupId>org.hamcrest</groupId>
           <artifactId>hamcrest-core</artifactId>
@@ -96,17 +94,10 @@
       <artifactId>junit-jupiter</artifactId>
       <scope>test</scope>
     </dependency>
-    <!-- required to resolve
-    These dependencies are required to workaround a bad
-    interaction using includeDependencyManagement=true for
-    the Bnd resolver and testing plugins and the enforcer
-    plugin which causes a false positive from the enforcer
-    plugin. The Bnd 5.2.0 resolver and testing plugins
-    don't have this problem, so these dependencies
-    can be removed when updating bnd.version to 5.2.0 and
-    configuring the Bnd resolver and testing plugins to use
-    includeDependencyManagement=true.
-    -->
+    <!-- required to resolve These dependencies are required to workaround a bad interaction using includeDependencyManagement=true
+      for the Bnd resolver and testing plugins and the enforcer plugin which causes a false positive from the enforcer plugin.
+      The Bnd 5.2.0 resolver and testing plugins don't have this problem, so these dependencies can be removed when updating bnd.version
+      to 5.2.0 and configuring the Bnd resolver and testing plugins to use includeDependencyManagement=true. -->
     <dependency>
       <groupId>org.junit.jupiter</groupId>
       <artifactId>junit-jupiter-engine</artifactId>
@@ -170,6 +161,12 @@
       <artifactId>mockito-junit-jupiter</artifactId>
       <scope>test</scope>
     </dependency>
+    <dependency>
+      <groupId>com.fasterxml.jackson.core</groupId>
+      <artifactId>jackson-databind</artifactId>
+      <version>2.11.2</version>
+      <scope>test</scope>
+    </dependency>
     <!-- NEEDED! Unlike File, a Path is not linked to the JRE's filesystem. In order to accurately test assertions, we need
       a decent JSR 203 implementation which lets us test our assertions. Right now, this is memoryfilesystem (https://github.com/marschall/memoryfilesystem).
       Another choice would be jimfs from Google (https://github.com/google/jimfs), but its support for reading/writing file attributes
@@ -371,7 +368,7 @@
       <plugin>
         <groupId>org.apache.maven.plugins</groupId>
         <artifactId>maven-antrun-plugin</artifactId>
-        <version>3.0.0</version><!--$NO-MVN-MAN-VER$-->
+        <version>3.0.0</version><!--$NO-MVN-MAN-VER$ -->
         <executions>
           <!-- STEP 5: detach the primary artifact so we can re-execute maven-jar-plugin -->
           <execution>
@@ -594,9 +591,9 @@
     <pluginManagement>
       <plugins>
         <plugin>
-            <groupId>net.alchim31.maven</groupId>
-            <artifactId>yuicompressor-maven-plugin</artifactId>
-            <version>1.5.1</version>
+          <groupId>net.alchim31.maven</groupId>
+          <artifactId>yuicompressor-maven-plugin</artifactId>
+          <version>1.5.1</version>
         </plugin>
         <!--This plugin's configuration is used to store Eclipse m2e settings only. It has no influence on the Maven build
           itself. -->
diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index 7b2a6431a..283a1ddb4 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -38,6 +38,7 @@ import java.time.LocalDateTime;
 import java.time.OffsetDateTime;
 import java.time.ZonedDateTime;
 import java.util.Calendar;
+import java.util.Collection;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.HashMap;
@@ -215,7 +216,7 @@ public class StandardRepresentation implements Representation {
     if (object instanceof PredicateDescription) return toStringOf((PredicateDescription) object);
     if (object instanceof Future) return toStringOf((Future<?>) object);
     if (isArray(object)) return formatArray(object);
-    if (object instanceof Iterable<?>) return smartFormat((Iterable<?>) object);
+    if (object instanceof Collection<?>) return smartFormat((Collection<?>) object);
     if (object instanceof Map<?, ?>) return toStringOf((Map<?, ?>) object);
     if (object instanceof Tuple) return toStringOf((Tuple) object);
     if (object instanceof MapEntry) return toStringOf((MapEntry<?, ?>) object);
@@ -223,9 +224,26 @@ public class StandardRepresentation implements Representation {
     if (object instanceof InsertDelta<?>) return toStringOf((InsertDelta<?>) object);
     if (object instanceof ChangeDelta<?>) return toStringOf((ChangeDelta<?>) object);
     if (object instanceof DeleteDelta<?>) return toStringOf((DeleteDelta<?>) object);
+    // Only format Iterables that are not collections and have not overridden toString
+    // ex: JsonNode is an Iterable that is best formatted with its own String
+    // Path is another example but we can deal with it specifically as it is part of the JDK.
+    if (object instanceof Iterable<?> && !hasOverriddenToString((Iterable<?>) object))
+      return smartFormat((Collection<?>) object);
     return fallbackToStringOf(object);
   }
 
+  private static boolean hasOverriddenToString(Iterable<?> iterable) {
+    try {
+      Method method = iterable.getClass().getMethod("toString");
+      Class<?> declaringClass = method.getDeclaringClass();
+      return !Object.class.equals(declaringClass);
+    } catch (NoSuchMethodException | SecurityException e) {
+      // NoSuchMethodException should not occur as toString is always defined.
+      // if SecurityException occurs, returning false will lead to format iterable
+      return false;
+    }
+  }
+
   @Override
   public String unambiguousToStringOf(Object obj) {
     // some types have already an unambiguous toString, no need to double down
@@ -512,8 +530,6 @@ public class StandardRepresentation implements Representation {
     if (isArrayTypePrimitive(element)) return formatPrimitiveArray(element);
     // object array/iterable elements can cycle back to root, we pass the latter to check for it
     if (isArray(element)) return format((Object[]) element, start, end, elementSeparator, indentation, root);
-    if (element instanceof Iterable && !(element instanceof Path))
-      return format((Iterable) element, start, end, elementSeparator, indentation, root);
     // Since potentially self referencing containers have been handled, it is reasonably safe to use toStringOf.
     // What we don't track are cycles like A -> B -> A but that should be rare enough thus this solution is good enough
     // To fully avoid all cycles we would need to track all visited elements but the issue is that:
@@ -521,7 +537,7 @@ public class StandardRepresentation implements Representation {
     // List<Object> outerList = list(innerList, innerList);
     // outerList would be represented as [[1, 2, 3], (already visited)] instead of [[1, 2, 3], [1, 2, 3]]
     // Final word, the approach used here is the same as the toString implementation in AbstractCollection
-    return element == null ? NULL : toStringOf(element);
+    return element == null ? NULL : toStringOf(element); // TODO add indentation?
   }
 
   // private methods
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
index 94c029c1b..ec661ad92 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
@@ -27,6 +27,10 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.node.JsonNodeFactory;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+
 class StandardRepresentation_iterable_format_Test extends AbstractBaseRepresentationTest {
 
   @Test
@@ -210,6 +214,27 @@ class StandardRepresentation_iterable_format_Test extends AbstractBaseRepresenta
     then(formatted).isEqualTo("[[1, 2, 3], [1, 2, 3]]");
   }
 
+  // see https://github.com/joel-costigliola/assertj-core/issues/1990
+  @Test
+  public void should_use_overridden_toString_over_iterable_representation() {
+    // GIVEN
+    JsonNode a = JsonNodeFactory.instance.objectNode().put("a", 1);
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.toStringOf(a);
+    // THEN
+    then(formatted).isEqualTo("{\"a\":1}");
+  }
+
+  @Test
+  public void should_use_overridden_toString_over_iterable_representation_in_collection_elements() {
+    // GIVEN
+    List<ObjectNode> a = list(JsonNodeFactory.instance.objectNode().put("a", 1));
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.toStringOf(a);
+    // THEN
+    then(formatted).isEqualTo("[{\"a\":1}]");
+  }
+
   private static String stringOfLength(int length) {
     return Stream.generate(() -> "a").limit(length).collect(joining());
   }
