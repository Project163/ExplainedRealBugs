diff --git a/src/main/java/org/assertj/core/api/AbstractByteAssert.java b/src/main/java/org/assertj/core/api/AbstractByteAssert.java
index 38052ac84..6897904be 100644
--- a/src/main/java/org/assertj/core/api/AbstractByteAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractByteAssert.java
@@ -14,6 +14,7 @@ package org.assertj.core.api;
 
 import java.util.Comparator;
 
+import org.assertj.core.data.Offset;
 import org.assertj.core.internal.Bytes;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.util.VisibleForTesting;
@@ -317,7 +318,64 @@ public abstract class AbstractByteAssert<S extends AbstractByteAssert<S>> extend
     bytes.assertIsStrictlyBetween(info, actual, start, end);
     return myself;
   }
+  
+  /**
+   * Verifies that the actual byte is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat((byte)5).isCloseTo((byte)7, within((byte)3));
+   *
+   * // if difference is exactly equals to the offset, it's ok
+   * assertThat((byte)5).isCloseTo((byte)7, within((byte)2));
+   *
+   * // assertion will fail
+   * assertThat((byte)5).isCloseTo((byte)7, within((byte)1));
+   * </code></pre>
+   *
+   * @param expected the given byte to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isCloseTo(byte expected, Offset<Byte> offset) {
+    bytes.assertIsCloseTo(info, actual, expected, offset);
+    return myself;
+  }
 
+  /**
+   * Verifies that the actual Byte is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat((byte)5).isCloseTo(new Byte("7"), within((byte)3));
+   *
+   * // if difference is exactly equals to the offset, it's ok
+   * assertThat((byte)5).isCloseTo(new Byte("7"), within((byte)2));
+   *
+   * // assertion will fail
+   * assertThat((byte)5).isCloseTo(new Byte("7"), within((byte)1));
+   * </code></pre>
+   *
+   * @param expected the given Byte to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws NullPointerException if the expected Byte is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isCloseTo(Byte expected, Offset<Byte> offset) {
+    bytes.assertIsCloseTo(info, actual, expected, offset);
+    return myself;
+  }
+  
   @Override
   public S usingComparator(Comparator<? super Byte> customComparator) {
     super.usingComparator(customComparator);
diff --git a/src/main/java/org/assertj/core/api/AbstractFloatAssert.java b/src/main/java/org/assertj/core/api/AbstractFloatAssert.java
index e62d86843..5a4cb5c8b 100644
--- a/src/main/java/org/assertj/core/api/AbstractFloatAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractFloatAssert.java
@@ -112,7 +112,7 @@ public abstract class AbstractFloatAssert<S extends AbstractFloatAssert<S>> exte
    * Verifies that the actual number is close to the given one within the given offset.<br>
    * If difference is equal to offset value, assertion is considered valid.
    * <p>
-   * Example with double:
+   * Example:
    *
    * <pre><code class='java'>
    * // assertion will pass:
@@ -137,7 +137,6 @@ public abstract class AbstractFloatAssert<S extends AbstractFloatAssert<S>> exte
    * @param offset the given positive offset.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given offset is {@code null}.
-   * @throws NullPointerException if the expected number is {@code null}.
    * @throws AssertionError if the actual value is not equal to the given one.
    */
   // duplicate javadoc of isCloseTo(Float other, Offset<Float> offset but can't define it in super class
@@ -175,7 +174,7 @@ public abstract class AbstractFloatAssert<S extends AbstractFloatAssert<S>> exte
    * @param offset the given positive offset.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given offset is {@code null}.
-   * @throws NullPointerException if the expected number is {@code null}.
+   * @throws NullPointerException if the other number is {@code null}.
    * @throws AssertionError if the actual value is not equal to the given one.
    */
   @Override
diff --git a/src/main/java/org/assertj/core/api/AbstractIntegerAssert.java b/src/main/java/org/assertj/core/api/AbstractIntegerAssert.java
index a44998154..c0f65e9e7 100644
--- a/src/main/java/org/assertj/core/api/AbstractIntegerAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIntegerAssert.java
@@ -14,6 +14,7 @@ package org.assertj.core.api;
 
 import java.util.Comparator;
 
+import org.assertj.core.data.Offset;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.Integers;
 import org.assertj.core.util.VisibleForTesting;
@@ -181,6 +182,64 @@ public abstract class AbstractIntegerAssert<S extends AbstractIntegerAssert<S>>
     return myself;
   }
 
+  /**
+   * Verifies that the actual int is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example:
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat(5).isCloseTo(7, within(3));
+   *
+   * // if difference is exactly equals to the offset, it's ok
+   * assertThat(5).isCloseTo(7, within(2));
+   *
+   * // assertion will fail
+   * assertThat(5).isCloseTo(7, within(1));
+   * </code></pre>
+   *
+   * @param expected the given int to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isCloseTo(int expected, Offset<Integer> offset) {
+    integers.assertIsCloseTo(info, actual, expected, offset);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual Integer is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example:
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat(5).isCloseTo(new Integer(7), within(3));
+   *
+   * // if difference is exactly equals to the offset (0.1), it's ok
+   * assertThat(5).isCloseTo(new Integer(7), within(2));
+   *
+   * // assertion will fail
+   * assertThat(5).isCloseTo(new Integer(7), within(1));
+   * </code></pre>
+   *
+   * @param expected the given Integer to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws NullPointerException if the expected Integer is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isCloseTo(Integer expected, Offset<Integer> offset) {
+    integers.assertIsCloseTo(info, actual, expected, offset);
+    return myself;
+  }
+  
+  
   @Override
   public S usingComparator(Comparator<? super Integer> customComparator) {
     super.usingComparator(customComparator);
diff --git a/src/main/java/org/assertj/core/api/AbstractLongAssert.java b/src/main/java/org/assertj/core/api/AbstractLongAssert.java
index c86137156..262e7ce2c 100644
--- a/src/main/java/org/assertj/core/api/AbstractLongAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractLongAssert.java
@@ -14,12 +14,13 @@ package org.assertj.core.api;
 
 import java.util.Comparator;
 
+import org.assertj.core.data.Offset;
 import org.assertj.core.internal.*;
 import org.assertj.core.util.VisibleForTesting;
 
-
 /**
  * Base class for all implementations of assertions for {@link Long}s.
+ * 
  * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/anMa4g"
  *          target="_blank">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;
  *          for more details.
@@ -32,154 +33,219 @@ import org.assertj.core.util.VisibleForTesting;
  * @author Mikhail Mazursky
  * @author Nicolas François
  */
-public abstract class AbstractLongAssert<S extends AbstractLongAssert<S>> extends AbstractComparableAssert<S, Long> implements NumberAssert<S, Long> {
-
-	@VisibleForTesting
-	Longs longs = Longs.instance();
-
-	protected AbstractLongAssert(Long actual, Class<?> selfType) {
-		super(actual, selfType);
-	}
-
-	/**
-	 * Verifies that the actual value is equal to the given one.
-	 * @param expected the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is not equal to the given one.
-	 */
-	public S isEqualTo(long expected) {
-		longs.assertEqual(info, actual, expected);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is not equal to the given one.
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is equal to the given one.
-	 */
-	public S isNotEqualTo(long other) {
-		longs.assertNotEqual(info, actual, other);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isZero() {
-		longs.assertIsZero(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isNotZero() {
-		longs.assertIsNotZero(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isPositive() {
-		longs.assertIsPositive(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isNegative() {
-		longs.assertIsNegative(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isNotNegative() {
-		longs.assertIsNotNegative(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isNotPositive() {
-		longs.assertIsNotPositive(info, actual);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is less than the given one.
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is equal to or greater than the given one.
-	 */
-	public S isLessThan(long other) {
-		longs.assertLessThan(info, actual, other);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is less than or equal to the given one.
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is greater than the given one.
-	 */
-	public S isLessThanOrEqualTo(long other) {
-		longs.assertLessThanOrEqualTo(info, actual, other);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is greater than the given one.
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is equal to or less than the given one.
-	 */
-	public S isGreaterThan(long other) {
-		longs.assertGreaterThan(info, actual, other);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is greater than or equal to the given one.
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is less than the given one.
-	 */
-	public S isGreaterThanOrEqualTo(long other) {
-		longs.assertGreaterThanOrEqualTo(info, actual, other);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isBetween(Long start, Long end) {
-		longs.assertIsBetween(info, actual, start, end);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isStrictlyBetween(Long start, Long end) {
-		longs.assertIsStrictlyBetween(info, actual, start, end);
-		return myself;
-	}
-
-	@Override
-	public S usingComparator(Comparator<? super Long> customComparator) {
-		super.usingComparator(customComparator);
-		longs = new Longs(new ComparatorBasedComparisonStrategy(customComparator));
-		return myself;
-	}
-
-	@Override
-	public S usingDefaultComparator() {
-		super.usingDefaultComparator();
-		longs = Longs.instance();
-		return myself;
-	}
+public abstract class AbstractLongAssert<S extends AbstractLongAssert<S>> extends AbstractComparableAssert<S, Long>
+    implements NumberAssert<S, Long> {
+
+  @VisibleForTesting
+  Longs longs = Longs.instance();
+
+  protected AbstractLongAssert(Long actual, Class<?> selfType) {
+    super(actual, selfType);
+  }
+
+  /**
+   * Verifies that the actual value is equal to the given one.
+   * 
+   * @param expected the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isEqualTo(long expected) {
+    longs.assertEqual(info, actual, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is not equal to the given one.
+   * 
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is equal to the given one.
+   */
+  public S isNotEqualTo(long other) {
+    longs.assertNotEqual(info, actual, other);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isZero() {
+    longs.assertIsZero(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isNotZero() {
+    longs.assertIsNotZero(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isPositive() {
+    longs.assertIsPositive(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isNegative() {
+    longs.assertIsNegative(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isNotNegative() {
+    longs.assertIsNotNegative(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isNotPositive() {
+    longs.assertIsNotPositive(info, actual);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is less than the given one.
+   * 
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is equal to or greater than the given one.
+   */
+  public S isLessThan(long other) {
+    longs.assertLessThan(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is less than or equal to the given one.
+   * 
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is greater than the given one.
+   */
+  public S isLessThanOrEqualTo(long other) {
+    longs.assertLessThanOrEqualTo(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is greater than the given one.
+   * 
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is equal to or less than the given one.
+   */
+  public S isGreaterThan(long other) {
+    longs.assertGreaterThan(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is greater than or equal to the given one.
+   * 
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is less than the given one.
+   */
+  public S isGreaterThanOrEqualTo(long other) {
+    longs.assertGreaterThanOrEqualTo(info, actual, other);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isBetween(Long start, Long end) {
+    longs.assertIsBetween(info, actual, start, end);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isStrictlyBetween(Long start, Long end) {
+    longs.assertIsStrictlyBetween(info, actual, start, end);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual long is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example:
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat(5l).isCloseTo(7l, within(3l));
+   *
+   * // if difference is exactly equals to the offset, it's ok
+   * assertThat(5l).isCloseTo(7l, within(2l));
+   *
+   * // assertion will fail
+   * assertThat(5l).isCloseTo(7l, within(1l));
+   * </code></pre>
+   *
+   * @param expected the given long to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isCloseTo(long expected, Offset<Long> offset) {
+    longs.assertIsCloseTo(info, actual, expected, offset);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual Long is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example with double:
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat(5l).isCloseTo(new Long(7), within(3l));
+   *
+   * // if difference is exactly equals to the offset (0.1), it's ok
+   * assertThat(5l).isCloseTo(new Long(7), within(2l));
+   *
+   * // assertion will fail
+   * assertThat(5l).isCloseTo(new Long(7), within(1l));
+   * </code></pre>
+   *
+   * @param expected the given Long to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws NullPointerException if the expected Long is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  @Override
+  public S isCloseTo(Long expected, Offset<Long> offset) {
+    longs.assertIsCloseTo(info, actual, expected, offset);
+    return myself;
+  }
+
+  @Override
+  public S usingComparator(Comparator<? super Long> customComparator) {
+    super.usingComparator(customComparator);
+    longs = new Longs(new ComparatorBasedComparisonStrategy(customComparator));
+    return myself;
+  }
+
+  @Override
+  public S usingDefaultComparator() {
+    super.usingDefaultComparator();
+    longs = Longs.instance();
+    return myself;
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/AbstractShortAssert.java b/src/main/java/org/assertj/core/api/AbstractShortAssert.java
index 24a65a365..2c45a0293 100644
--- a/src/main/java/org/assertj/core/api/AbstractShortAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractShortAssert.java
@@ -12,13 +12,18 @@
  */
 package org.assertj.core.api;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.within;
+
 import java.util.Comparator;
 
+import org.assertj.core.data.Offset;
 import org.assertj.core.internal.*;
 import org.assertj.core.util.VisibleForTesting;
 
 /**
  * Base class for all implementations of assertions for {@link Short}s.
+ * 
  * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/anMa4g"
  *          target="_blank">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;
  *          for more details.
@@ -31,160 +36,217 @@ import org.assertj.core.util.VisibleForTesting;
  * @author Nicolas François
  */
 public abstract class AbstractShortAssert<S extends AbstractShortAssert<S>> extends AbstractComparableAssert<S, Short>
-		implements NumberAssert<S, Short> {
-
-	@VisibleForTesting
-	Shorts shorts = Shorts.instance();
-
-	protected AbstractShortAssert(Short actual, Class<?> selfType) {
-		super(actual, selfType);
-	}
-
-	/**
-	 * Verifies that the actual value is equal to the given one.
-	 *
-	 * @param expected the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is not equal to the given one.
-	 */
-	public S isEqualTo(short expected) {
-		shorts.assertEqual(info, actual, expected);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is not equal to the given one.
-	 *
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is equal to the given one.
-	 */
-	public S isNotEqualTo(short other) {
-		shorts.assertNotEqual(info, actual, other);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isZero() {
-		shorts.assertIsZero(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isNotZero() {
-		shorts.assertIsNotZero(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isPositive() {
-		shorts.assertIsPositive(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isNegative() {
-		shorts.assertIsNegative(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isNotNegative() {
-		shorts.assertIsNotNegative(info, actual);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isNotPositive() {
-		shorts.assertIsNotPositive(info, actual);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is less than the given one.
-	 *
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is equal to or greater than the given one.
-	 */
-	public S isLessThan(short other) {
-		shorts.assertLessThan(info, actual, other);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is less than or equal to the given one.
-	 *
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is greater than the given one.
-	 */
-	public S isLessThanOrEqualTo(short other) {
-		shorts.assertLessThanOrEqualTo(info, actual, other);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is greater than the given one.
-	 *
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is equal to or less than the given one.
-	 */
-	public S isGreaterThan(short other) {
-		shorts.assertGreaterThan(info, actual, other);
-		return myself;
-	}
-
-	/**
-	 * Verifies that the actual value is greater than or equal to the given one.
-	 *
-	 * @param other the given value to compare the actual value to.
-	 * @return {@code this} assertion object.
-	 * @throws AssertionError if the actual value is {@code null}.
-	 * @throws AssertionError if the actual value is less than the given one.
-	 */
-	public S isGreaterThanOrEqualTo(short other) {
-		shorts.assertGreaterThanOrEqualTo(info, actual, other);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isBetween(Short start, Short end) {
-		shorts.assertIsBetween(info, actual, start, end);
-		return myself;
-	}
-
-	/** {@inheritDoc} */
-	@Override
-	public S isStrictlyBetween(Short start, Short end) {
-		shorts.assertIsStrictlyBetween(info, actual, start, end);
-		return myself;
-	}
-
-	@Override
-	public S usingComparator(Comparator<? super Short> customComparator) {
-		super.usingComparator(customComparator);
-		shorts = new Shorts(new ComparatorBasedComparisonStrategy(customComparator));
-		return myself;
-	}
-
-	@Override
-	public S usingDefaultComparator() {
-		super.usingDefaultComparator();
-		shorts = Shorts.instance();
-		return myself;
-	}
+    implements NumberAssert<S, Short> {
+
+  @VisibleForTesting
+  Shorts shorts = Shorts.instance();
+
+  protected AbstractShortAssert(Short actual, Class<?> selfType) {
+    super(actual, selfType);
+  }
+
+  /**
+   * Verifies that the actual value is equal to the given one.
+   *
+   * @param expected the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isEqualTo(short expected) {
+    shorts.assertEqual(info, actual, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is not equal to the given one.
+   *
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is equal to the given one.
+   */
+  public S isNotEqualTo(short other) {
+    shorts.assertNotEqual(info, actual, other);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isZero() {
+    shorts.assertIsZero(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isNotZero() {
+    shorts.assertIsNotZero(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isPositive() {
+    shorts.assertIsPositive(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isNegative() {
+    shorts.assertIsNegative(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isNotNegative() {
+    shorts.assertIsNotNegative(info, actual);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isNotPositive() {
+    shorts.assertIsNotPositive(info, actual);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is less than the given one.
+   *
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is equal to or greater than the given one.
+   */
+  public S isLessThan(short other) {
+    shorts.assertLessThan(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is less than or equal to the given one.
+   *
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is greater than the given one.
+   */
+  public S isLessThanOrEqualTo(short other) {
+    shorts.assertLessThanOrEqualTo(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is greater than the given one.
+   *
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is equal to or less than the given one.
+   */
+  public S isGreaterThan(short other) {
+    shorts.assertGreaterThan(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual value is greater than or equal to the given one.
+   *
+   * @param other the given value to compare the actual value to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual value is {@code null}.
+   * @throws AssertionError if the actual value is less than the given one.
+   */
+  public S isGreaterThanOrEqualTo(short other) {
+    shorts.assertGreaterThanOrEqualTo(info, actual, other);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isBetween(Short start, Short end) {
+    shorts.assertIsBetween(info, actual, start, end);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S isStrictlyBetween(Short start, Short end) {
+    shorts.assertIsStrictlyBetween(info, actual, start, end);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual short is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example:
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat((short)5).isCloseTo((short)7, within((short)3));
+   *
+   * // if difference is exactly equals to the offset, it's ok
+   * assertThat((short)5).isCloseTo((short)7, within((short)2));
+   *
+   * // assertion will fail
+   * assertThat((short)5).isCloseTo((short)7, within((short)1));
+   * </code></pre>
+   *
+   * @param expected the given short to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isCloseTo(short expected, Offset<Short> offset) {
+    shorts.assertIsCloseTo(info, actual, expected, offset);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual Short is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example:
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat((short)5).isCloseTo(new Short("7"), within((short)3));
+   *
+   * // if difference is exactly equals to the offset, it's ok
+   * assertThat((short)5).isCloseTo(new Short("7"), within((short)2));
+   *
+   * // assertion will fail
+   * assertThat((short)5).isCloseTo(new Short("7"), within((short)1));
+   * </code></pre>
+   *
+   * @param expected the given Short to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws NullPointerException if the expected Short is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  public S isCloseTo(Short expected, Offset<Short> offset) {
+    shorts.assertIsCloseTo(info, actual, expected, offset);
+    return myself;
+  }
+
+  @Override
+  public S usingComparator(Comparator<? super Short> customComparator) {
+    super.usingComparator(customComparator);
+    shorts = new Shorts(new ComparatorBasedComparisonStrategy(customComparator));
+    return myself;
+  }
+
+  @Override
+  public S usingDefaultComparator() {
+    super.usingDefaultComparator();
+    shorts = Shorts.instance();
+    return myself;
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index ebb1a95ff..168bf5bad 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -899,6 +899,62 @@ public class Assertions {
     return Offset.offset(value);
   }
 
+  /**
+   * Assertions entry point for Byte {@link Offset} to use with isCloseTo assertions.
+   * <p/>
+   * Typical usage :
+   * <p/>
+   * 
+   * <pre><code class='java'>
+   * assertThat((byte)10).isCloseTo((byte)11, within((byte)1));
+   * </code></pre>
+   */
+  public static Offset<Byte> within(Byte value) {
+    return Offset.offset(value);
+  }
+  
+  /**
+   * Assertions entry point for Integer {@link Offset} to use with isCloseTo assertions.
+   * <p/>
+   * Typical usage :
+   * <p/>
+   * 
+   * <pre><code class='java'>
+   * assertThat(10).isCloseTo(11, within(1));
+   * </code></pre>
+   */
+  public static Offset<Integer> within(Integer value) {
+    return Offset.offset(value);
+  }
+  
+  /**
+   * Assertions entry point for Short {@link Offset} to use with isCloseTo assertions.
+   * <p/>
+   * Typical usage :
+   * <p/>
+   * 
+   * <pre><code class='java'>
+   * assertThat(10).isCloseTo(11, within(1));
+   * </code></pre>
+   */
+  public static Offset<Short> within(Short value) {
+    return Offset.offset(value);
+  }
+  
+  /**
+   * Assertions entry point for Long {@link Offset} to use with isCloseTo assertions.
+   * <p/>
+   * Typical usage :
+   * <p/>
+   * 
+   * <pre><code class='java'>
+   * assertThat(5l).isCloseTo(7l, within(2l));
+   * </code></pre>
+   */
+  public static Offset<Long> within(Long value) {
+    return Offset.offset(value);
+  }
+  
   // ------------------------------------------------------------------------------------------------------
   // Condition methods : not assertions but here to have a single entry point to all AssertJ features.
   // ------------------------------------------------------------------------------------------------------
diff --git a/src/main/java/org/assertj/core/api/LongAssert.java b/src/main/java/org/assertj/core/api/LongAssert.java
index 1c6624ace..536325665 100644
--- a/src/main/java/org/assertj/core/api/LongAssert.java
+++ b/src/main/java/org/assertj/core/api/LongAssert.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api;
 
 
+
 /**
  * Assertion methods for {@link Long}s.
  * <p>
@@ -33,4 +34,5 @@ public class LongAssert extends AbstractLongAssert<LongAssert> {
   protected LongAssert(Long actual) {
     super(actual, LongAssert.class);
   }
+
 }
diff --git a/src/main/java/org/assertj/core/api/NumberAssert.java b/src/main/java/org/assertj/core/api/NumberAssert.java
index a1f151ca9..4557d5011 100644
--- a/src/main/java/org/assertj/core/api/NumberAssert.java
+++ b/src/main/java/org/assertj/core/api/NumberAssert.java
@@ -12,6 +12,8 @@
  */
 package org.assertj.core.api;
 
+import org.assertj.core.data.Offset;
+
 /**
  * Assertion methods applicable to <code>{@link Number}</code>s.
  * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/anMa4g" target="_blank">Emulating
@@ -115,4 +117,34 @@ public interface NumberAssert<S extends NumberAssert<S, A>, A extends Number> {
    * @throws AssertionError if the actual value is not in ]start, end[ range.
    */
   S isStrictlyBetween(A start, A end);
+  
+  /**
+   * Verifies that the actual number is close to the given one within the given offset.<br>
+   * If difference is equal to offset value, assertion is considered valid.
+   * <p>
+   * Example with double:
+   *
+   * <pre><code class='java'>
+   * // assertions will pass:
+   * assertThat(8.1).isCloseTo(new Double(8.0), within(0.2));
+   *
+   * // you can use offset if you prefer
+   * assertThat(8.1).isCloseTo(new Double(8.0), offset(0.2));
+   *
+   * // if difference is exactly equals to the offset (0.1), it's ok
+   * assertThat(8.1).isCloseTo(new Double(8.0), within(0.1));
+   *
+   * // assertion will fail
+   * assertThat(8.1).isCloseTo(new Double(8.0), within(0.01));
+   * </code></pre>
+   *
+   * @param expected the given number to compare the actual value to.
+   * @param offset the given positive offset.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given offset is {@code null}.
+   * @throws NullPointerException if the expected number is {@code null}.
+   * @throws AssertionError if the actual value is not equal to the given one.
+   */
+  S isCloseTo(A expected, Offset<A> offset);
+
 }
diff --git a/src/main/java/org/assertj/core/data/Offset.java b/src/main/java/org/assertj/core/data/Offset.java
index fb2c6c3e1..d077b0daf 100644
--- a/src/main/java/org/assertj/core/data/Offset.java
+++ b/src/main/java/org/assertj/core/data/Offset.java
@@ -76,6 +76,38 @@ public class Offset<T extends Number> {
     return new Offset<>(value);
   }
 
+  /**
+   * Creates a new {@link Offset}.
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   */
+  public static Offset<Short> offset(Short value) {
+    checkNotNull(value);
+    if (value < 0) {
+      throw valueNotPositive();
+    }
+    return new Offset<>(value);
+  }
+  
+  /**
+   * Creates a new {@link Offset}.
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   */
+  public static Offset<Long> offset(Long value) {
+    checkNotNull(value);
+    if (value < 0) {
+      throw valueNotPositive();
+    }
+    return new Offset<>(value);
+  }
+  
   /**
    * Creates a new {@link Offset}.
    *
@@ -90,6 +122,20 @@ public class Offset<T extends Number> {
     return new Offset<>(value);
   }
 
+  /**
+   * Creates a new {@link Offset}.
+   *
+   * @param value the value of the offset.
+   * @return the created {@code Offset}.
+   * @throws NullPointerException if the given value is {@code null}.
+   * @throws IllegalArgumentException if the given value is negative.
+   */
+  public static Offset<Byte> offset(final Byte value) {
+    checkNotNull(value);
+    if (value.compareTo((byte) 0) < 0) throw valueNotPositive();
+    return new Offset<>(value);
+  }
+  
   private static IllegalArgumentException valueNotPositive() {
     return new IllegalArgumentException("The value of the offset should be greater than zero");
   }
diff --git a/src/main/java/org/assertj/core/internal/Bytes.java b/src/main/java/org/assertj/core/internal/Bytes.java
index 72d5c34e0..1ad73c9c0 100644
--- a/src/main/java/org/assertj/core/internal/Bytes.java
+++ b/src/main/java/org/assertj/core/internal/Bytes.java
@@ -12,6 +12,13 @@
  */
 package org.assertj.core.internal;
 
+import static java.lang.Math.abs;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.internal.CommonValidations.checkNumberIsNotNull;
+import static org.assertj.core.internal.CommonValidations.checkOffsetIsNotNull;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.data.Offset;
 import org.assertj.core.util.*;
 
 /**
@@ -26,6 +33,7 @@ public class Bytes extends Numbers<Byte> {
 
   /**
    * Returns the singleton instance of this class.
+   * 
    * @return the singleton instance of this class.
    */
   public static Bytes instance() {
@@ -46,4 +54,13 @@ public class Bytes extends Numbers<Byte> {
     return 0;
   }
 
+  public void assertIsCloseTo(AssertionInfo info, Byte actual, Byte expected, Offset<Byte> offset) {
+      assertNotNull(info, actual);
+      checkOffsetIsNotNull(offset);
+      checkNumberIsNotNull(expected);
+      byte absDiff = (byte) abs(expected - actual);
+      if (absDiff > offset.value) throw failures.failure(info, shouldBeEqual(actual, expected, offset, absDiff));
+    }
+
+
 }
diff --git a/src/main/java/org/assertj/core/internal/Doubles.java b/src/main/java/org/assertj/core/internal/Doubles.java
index 644c33064..a1c0ef8f1 100644
--- a/src/main/java/org/assertj/core/internal/Doubles.java
+++ b/src/main/java/org/assertj/core/internal/Doubles.java
@@ -23,7 +23,6 @@ import org.assertj.core.data.Offset;
 import org.assertj.core.util.Objects;
 import org.assertj.core.util.VisibleForTesting;
 
-
 /**
  * Reusable assertions for <code>{@link Double}</code>s.
  * 
@@ -36,6 +35,7 @@ public class Doubles extends RealNumbers<Double> {
 
   /**
    * Returns the singleton instance of this class based on {@link StandardComparisonStrategy}.
+   * 
    * @return the singleton instance of this class based on {@link StandardComparisonStrategy}.
    */
   public static Doubles instance() {
@@ -63,8 +63,10 @@ public class Doubles extends RealNumbers<Double> {
 
   /**
    * Verifies that two floats are equal within a positive offset.<br>
-   * It does not rely on the custom comparisonStrategy (if one is set) because using an offset is already a specific comparison
+   * It does not rely on the custom comparisonStrategy (if one is set) because using an offset is already a specific
+   * comparison
    * strategy.
+   * 
    * @param info contains information about the assertion.
    * @param actual the actual value.
    * @param expected the expected value.
@@ -90,7 +92,7 @@ public class Doubles extends RealNumbers<Double> {
     return abs(expected - actual) <= offset.value.doubleValue();
   }
 
-  public void assertIsCloseTo(final WritableAssertionInfo info, final Double actual, final double other,
+  public void assertIsCloseTo(final AssertionInfo info, final Double actual, final Double other,
                               final Offset<Double> offset) {
     assertEqual(info, actual, other, offset);
   }
diff --git a/src/main/java/org/assertj/core/internal/Integers.java b/src/main/java/org/assertj/core/internal/Integers.java
index f614cabf8..f066cd110 100644
--- a/src/main/java/org/assertj/core/internal/Integers.java
+++ b/src/main/java/org/assertj/core/internal/Integers.java
@@ -12,6 +12,13 @@
  */
 package org.assertj.core.internal;
 
+import static java.lang.Math.abs;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.internal.CommonValidations.checkNumberIsNotNull;
+import static org.assertj.core.internal.CommonValidations.checkOffsetIsNotNull;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.data.Offset;
 import org.assertj.core.util.VisibleForTesting;
 
 /**
@@ -45,4 +52,14 @@ public class Integers extends Numbers<Integer> {
   protected Integer zero() {
     return 0;
   }
+  
+  public void assertIsCloseTo(AssertionInfo info, Integer actual, Integer expected, Offset<Integer> offset) {
+    assertNotNull(info, actual);
+    checkOffsetIsNotNull(offset);
+    checkNumberIsNotNull(expected);
+    int absDiff = abs(expected - actual);
+    if (absDiff > offset.value) throw failures.failure(info, shouldBeEqual(actual, expected, offset, absDiff));
+  }
+
+  
 }
diff --git a/src/main/java/org/assertj/core/internal/Longs.java b/src/main/java/org/assertj/core/internal/Longs.java
index fffbdc174..d3d69cf0a 100644
--- a/src/main/java/org/assertj/core/internal/Longs.java
+++ b/src/main/java/org/assertj/core/internal/Longs.java
@@ -12,7 +12,14 @@
  */
 package org.assertj.core.internal;
 
-import org.assertj.core.util.*;
+import static java.lang.Math.abs;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.internal.CommonValidations.checkNumberIsNotNull;
+import static org.assertj.core.internal.CommonValidations.checkOffsetIsNotNull;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.data.Offset;
+import org.assertj.core.util.VisibleForTesting;
 
 /**
  * Reusable assertions for <code>{@link Long}</code>s.
@@ -26,6 +33,7 @@ public class Longs extends Numbers<Long> {
 
   /**
    * Returns the singleton instance of this class.
+   * 
    * @return the singleton instance of this class.
    */
   public static Longs instance() {
@@ -46,4 +54,12 @@ public class Longs extends Numbers<Long> {
     super(comparisonStrategy);
   }
 
+  public void assertIsCloseTo(AssertionInfo info, Long actual, Long expected, Offset<Long> offset) {
+    assertNotNull(info, actual);
+    checkOffsetIsNotNull(offset);
+    checkNumberIsNotNull(expected);
+    long absDiff = abs(expected - actual);
+    if (absDiff > offset.value) throw failures.failure(info, shouldBeEqual(actual, expected, offset, absDiff));
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/internal/Shorts.java b/src/main/java/org/assertj/core/internal/Shorts.java
index afe5b2fd0..31a95eb5b 100644
--- a/src/main/java/org/assertj/core/internal/Shorts.java
+++ b/src/main/java/org/assertj/core/internal/Shorts.java
@@ -12,6 +12,13 @@
  */
 package org.assertj.core.internal;
 
+import static java.lang.Math.abs;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.internal.CommonValidations.checkNumberIsNotNull;
+import static org.assertj.core.internal.CommonValidations.checkOffsetIsNotNull;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.data.Offset;
 import org.assertj.core.util.*;
 
 /**
@@ -46,4 +53,12 @@ public class Shorts extends Numbers<Short> {
     return 0;
   }
 
+  public void assertIsCloseTo(AssertionInfo info, Short actual, Short expected, Offset<Short> offset) {
+    assertNotNull(info, actual);
+    checkOffsetIsNotNull(offset);
+    checkNumberIsNotNull(expected);
+    Short absDiff = (short) abs(expected - actual);
+    if (absDiff > offset.value) throw failures.failure(info, shouldBeEqual(actual, expected, offset, absDiff));
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_BigDecimal_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_BigDecimal_Test.java
index dac61ba4a..c4959f9dd 100644
--- a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_BigDecimal_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_BigDecimal_Test.java
@@ -15,9 +15,6 @@ package org.assertj.core.api;
 import static java.math.BigDecimal.ONE;
 import static java.math.BigDecimal.ZERO;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.within;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
 
 import java.math.BigDecimal;
 
@@ -33,22 +30,13 @@ public class Assertions_assertThat_with_BigDecimal_Test {
   @Test
   public void should_create_Assert() {
     AbstractBigDecimalAssert<?> assertions = Assertions.assertThat(ZERO);
-    assertNotNull(assertions);
+    assertThat(assertions).isNotNull();
   }
 
   @Test
   public void should_pass_actual() {
     AbstractBigDecimalAssert<?> assertions = Assertions.assertThat(ONE);
-    assertSame(ONE, assertions.actual);
-  }
-
-  @Test
-  public void isCloseTo_within_offset_should_pass() {
-    final BigDecimal actual = new BigDecimal("8.1");
-    final BigDecimal other = new BigDecimal("8.0");
-    assertThat(actual).isCloseTo(other, within(new BigDecimal("0.2")));
-    // if difference is exactly equals to offset value, it's ok
-    assertThat(actual).isCloseTo(other, within(new BigDecimal("0.1")));
+    assertThat(assertions.actual).isSameAs(ONE);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Byte_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Byte_Test.java
index a98b67d89..b90cd4fda 100644
--- a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Byte_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Byte_Test.java
@@ -12,8 +12,7 @@
  */
 package org.assertj.core.api;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.Test;
 
@@ -28,13 +27,13 @@ public class Assertions_assertThat_with_Byte_Test {
   public void should_create_Assert() {
     Byte zero = 0;
     AbstractByteAssert<?> assertions = Assertions.assertThat(zero);
-    assertNotNull(assertions);
+    assertThat(assertions).isNotNull();
   }
 
   @Test
   public void should_pass_actual() {
     Byte eight = 8;
     AbstractByteAssert<?> assertions = Assertions.assertThat(eight);
-    assertSame(eight, assertions.actual);
+    assertThat(assertions.actual).isSameAs(eight);
   }
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Double_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Double_Test.java
index 39ea5f8da..a81ecd4a0 100644
--- a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Double_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Double_Test.java
@@ -13,10 +13,6 @@
 package org.assertj.core.api;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.offset;
-import static org.assertj.core.api.Assertions.within;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
 
 import org.junit.Test;
 
@@ -31,33 +27,14 @@ public class Assertions_assertThat_with_Double_Test {
   public void should_create_Assert() {
     Double zero = 0d;
     AbstractDoubleAssert<?> assertions = Assertions.assertThat(zero);
-    assertNotNull(assertions);
+    assertThat(assertions).isNotNull();
   }
 
   @Test
   public void should_pass_actual() {
     Double eight = 8d;
     AbstractDoubleAssert<?> assertions = Assertions.assertThat(eight);
-    assertSame(eight, assertions.actual);
+    assertThat(assertions.actual).isSameAs(eight);
   }
 
-  @Test
-  public void isCloseTo_within_offset_should_pass() {
-    assertThat(8.1).isCloseTo(8.0, within(0.2));
-    assertThat(8.1).isCloseTo(new Double(8.0), within(0.2));
-    // you can use offset if you prefer
-    assertThat(8.1).isCloseTo(8.0, offset(0.2));
-    // if difference is exactly equals to 0.1, it's ok
-    assertThat(8.1).isCloseTo(8.0, within(0.1));
-  }
-
-  @Test
-  public void isEqualTo_with_offset_should_pass() {
-    assertThat(8.1).isEqualTo(8.0, offset(0.2));
-    assertThat(8.1).isEqualTo(new Double(8.0), offset(0.2));
-    // if difference is exactly equals to the offset (0.1), it's ok
-    assertThat(8.1).isEqualTo(8.0, offset(0.1));
-    // within is an alias of offset
-    assertThat(8.1).isEqualTo(8.0, within(0.1));
-  }
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Float_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Float_Test.java
index 5d6cb0354..4b35d5c13 100644
--- a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Float_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Float_Test.java
@@ -13,10 +13,6 @@
 package org.assertj.core.api;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.offset;
-import static org.assertj.core.api.Assertions.within;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
 
 import org.junit.Test;
 
@@ -30,34 +26,14 @@ public class Assertions_assertThat_with_Float_Test {
   @Test
   public void should_create_Assert() {
     Float zero = 0f;
-    AbstractFloatAssert<?> assertions = Assertions.assertThat(zero);
-    assertNotNull(assertions);
+    AbstractFloatAssert<?> assertions = assertThat(zero);
+    assertThat(assertions).isNotNull();
   }
 
   @Test
   public void should_pass_actual() {
     Float eight = 8f;
-    AbstractFloatAssert<?> assertions = Assertions.assertThat(eight);
-    assertSame(eight, assertions.actual);
-  }
-
-  @Test
-  public void isCloseTo_within_offset_should_pass() {
-    assertThat(8.1f).isCloseTo(8.2f, within(0.2f));
-    assertThat(8f).isCloseTo(new Float(8.2f), within(0.5f));
-    // you can use offset if you prefer
-    assertThat(8.1f).isCloseTo(8.2f, offset(0.2f));
-    // if difference is exactly equals to 0.1, it's ok
-    assertThat(8.1f).isCloseTo(8.2f, within(0.1f));
-  }
-
-  @Test
-  public void isEqualTo_with_offset_should_pass() {
-    assertThat(8.1f).isEqualTo(8.2f, offset(0.2f));
-    assertThat(8.1f).isEqualTo(new Float(8.2), offset(0.2f));
-    // within is an alias of offset
-    assertThat(8.1f).isEqualTo(8.2f, within(0.1f));
-    // if difference is exactly equals to the offset (0.1), it's ok
-    assertThat(8.1f).isEqualTo(new Float(8.2), offset(0.1f));
+    AbstractFloatAssert<?> assertions = assertThat(eight);
+    assertThat(assertions.actual).isSameAs(eight);
   }
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Integer_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Integer_Test.java
index 3d3dc1244..1bd802746 100644
--- a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Integer_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Integer_Test.java
@@ -12,8 +12,7 @@
  */
 package org.assertj.core.api;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.Test;
 
@@ -28,13 +27,13 @@ public class Assertions_assertThat_with_Integer_Test {
   public void should_create_Assert() {
     Integer zero = 0;
     AbstractIntegerAssert<?> assertions = Assertions.assertThat(zero);
-    assertNotNull(assertions);
+    assertThat(assertions).isNotNull();
   }
 
   @Test
   public void should_pass_actual() {
     Integer eight = 8;
     AbstractIntegerAssert<?> assertions = Assertions.assertThat(eight);
-    assertSame(eight, assertions.actual);
+    assertThat(assertions.actual).isSameAs(eight);
   }
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Long_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Long_Test.java
index 25bde807f..4fa7635f1 100644
--- a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Long_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Long_Test.java
@@ -12,8 +12,7 @@
  */
 package org.assertj.core.api;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.Test;
 
@@ -28,13 +27,13 @@ public class Assertions_assertThat_with_Long_Test {
   public void should_create_Assert() {
     Long zero = 0L;
     AbstractLongAssert<?> assertions = Assertions.assertThat(zero);
-    assertNotNull(assertions);
+    assertThat(assertions).isNotNull();
   }
 
   @Test
   public void should_pass_actual() {
     Long eight = 8L;
     AbstractLongAssert<?> assertions = Assertions.assertThat(eight);
-    assertSame(eight, assertions.actual);
+    assertThat(assertions.actual).isSameAs(eight);
   }
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Short_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Short_Test.java
index 190cff9ec..605d2531b 100644
--- a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Short_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_Short_Test.java
@@ -12,8 +12,7 @@
  */
 package org.assertj.core.api;
 
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertSame;
+import static org.assertj.core.api.Assertions.assertThat;
 
 import org.junit.Test;
 
@@ -28,13 +27,13 @@ public class Assertions_assertThat_with_Short_Test {
   public void should_create_Assert() {
     Short zero = (short) 0;
     AbstractShortAssert<?> assertions = Assertions.assertThat(zero);
-    assertNotNull(assertions);
+    assertThat(assertions).isNotNull();
   }
 
   @Test
   public void should_pass_actual() {
     Short eight = (short) 8;
     AbstractShortAssert<?> assertions = Assertions.assertThat(eight);
-    assertSame(eight, assertions.actual);
+    assertThat(assertions.actual).isSameAs(eight);
   }
 }
diff --git a/src/test/java/org/assertj/core/api/byte_/ByteAssert_isCloseTo_byte_Test.java b/src/test/java/org/assertj/core/api/byte_/ByteAssert_isCloseTo_byte_Test.java
new file mode 100644
index 000000000..38ac75f98
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/byte_/ByteAssert_isCloseTo_byte_Test.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.byte_;
+
+import static org.assertj.core.data.Offset.offset;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ByteAssert;
+import org.assertj.core.api.ByteAssertBaseTest;
+import org.assertj.core.data.Offset;
+
+
+/**
+ * Tests for <code>{@link org.assertj.core.api.ByteAssert#isCloseTo(byte, org.assertj.core.data.Offset)}</code>.
+ *
+ * @author Joel Costigliola
+ */
+public class ByteAssert_isCloseTo_byte_Test extends ByteAssertBaseTest {
+
+  private final Offset<Byte> offset = offset((byte)5);
+  private final Byte value = (byte)8;
+
+  @Override
+  protected ByteAssert invoke_api_method() {
+    return assertions.isCloseTo(value, offset);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(bytes).assertIsCloseTo(getInfo(assertions), getActual(assertions), value, offset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/double_/DoubleAssert_isCloseTo_double_Test.java b/src/test/java/org/assertj/core/api/double_/DoubleAssert_isCloseTo_double_Test.java
new file mode 100644
index 000000000..8174848a4
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/double_/DoubleAssert_isCloseTo_double_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.double_;
+
+import static org.assertj.core.data.Offset.offset;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.DoubleAssert;
+import org.assertj.core.api.DoubleAssertBaseTest;
+import org.assertj.core.data.Offset;
+
+public class DoubleAssert_isCloseTo_double_Test extends DoubleAssertBaseTest {
+
+  private final Offset<Double> offset = offset(5.0);
+  private final Double value = 8.0;
+
+  @Override
+  protected DoubleAssert invoke_api_method() {
+    return assertions.isCloseTo(value, offset);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(doubles).assertIsCloseTo(getInfo(assertions), getActual(assertions), value, offset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/integer_/IntegerAssert_isCloseTo_integer_Test.java b/src/test/java/org/assertj/core/api/integer_/IntegerAssert_isCloseTo_integer_Test.java
new file mode 100644
index 000000000..b5d37eee6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/integer_/IntegerAssert_isCloseTo_integer_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.integer_;
+
+import static org.assertj.core.data.Offset.offset;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.IntegerAssert;
+import org.assertj.core.api.IntegerAssertBaseTest;
+import org.assertj.core.data.Offset;
+
+public class IntegerAssert_isCloseTo_integer_Test extends IntegerAssertBaseTest {
+
+  private final Offset<Integer> offset = offset(5);
+  private final Integer value = 8;
+
+  @Override
+  protected IntegerAssert invoke_api_method() {
+    return assertions.isCloseTo(value, offset);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(integers).assertIsCloseTo(getInfo(assertions), getActual(assertions), value, offset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/long_/LongAssert_isCloseTo_long_Test.java b/src/test/java/org/assertj/core/api/long_/LongAssert_isCloseTo_long_Test.java
new file mode 100644
index 000000000..229374a20
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/long_/LongAssert_isCloseTo_long_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.long_;
+
+import static org.assertj.core.data.Offset.offset;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.LongAssert;
+import org.assertj.core.api.LongAssertBaseTest;
+import org.assertj.core.data.Offset;
+
+public class LongAssert_isCloseTo_long_Test extends LongAssertBaseTest {
+
+  private final Offset<Long> offset = offset(5l);
+  private final Long value = 8l;
+
+  @Override
+  protected LongAssert invoke_api_method() {
+    return assertions.isCloseTo(value, offset);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(longs).assertIsCloseTo(getInfo(assertions), getActual(assertions), value, offset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/short_/ShortAssert_isCloseTo_short_Test.java b/src/test/java/org/assertj/core/api/short_/ShortAssert_isCloseTo_short_Test.java
new file mode 100644
index 000000000..3554be17d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/short_/ShortAssert_isCloseTo_short_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.short_;
+
+import static org.assertj.core.data.Offset.offset;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ShortAssert;
+import org.assertj.core.api.ShortAssertBaseTest;
+import org.assertj.core.data.Offset;
+
+public class ShortAssert_isCloseTo_short_Test extends ShortAssertBaseTest {
+
+  private final Offset<Short> offset = offset((short)5);
+  private final Short value = 8;
+
+  @Override
+  protected ShortAssert invoke_api_method() {
+    return assertions.isCloseTo(value, offset);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(shorts).assertIsCloseTo(getInfo(assertions), getActual(assertions), value, offset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsCloseTo_Test.java
index 4ce4576a0..92159e661 100644
--- a/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsCloseTo_Test.java
+++ b/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsCloseTo_Test.java
@@ -12,8 +12,10 @@
  */
 package org.assertj.core.internal.bigdecimals;
 
+import static java.math.BigDecimal.ZERO;
 import static java.math.BigDecimal.ONE;
 import static java.math.BigDecimal.TEN;
+import static org.assertj.core.api.Assertions.within;
 import static org.assertj.core.data.Offset.offset;
 import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
 import static org.assertj.core.test.TestData.someInfo;
@@ -24,7 +26,6 @@ import static org.mockito.Mockito.verify;
 import java.math.BigDecimal;
 
 import org.junit.Test;
-
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.BigDecimalsBaseTest;
 
@@ -42,6 +43,16 @@ public class BigDecimals_assertIsCloseTo_Test extends BigDecimalsBaseTest {
     bigDecimals.assertIsCloseTo(someInfo(), null, ONE, offset(ONE));
   }
 
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if__expected_value_is_null() {
+    bigDecimals.assertIsCloseTo(someInfo(), ONE, null, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_offset_is_null() {
+    bigDecimals.assertIsCloseTo(someInfo(), ONE, ZERO, null);
+  }
+  
   @Test
   public void should_pass_if_big_decimals_difference_is_less_than_given_offset() {
     bigDecimals.assertIsCloseTo(someInfo(), new BigDecimal("5.0"), new BigDecimal("5.1"), offset(ONE));
diff --git a/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsCloseTo_Test.java
new file mode 100644
index 000000000..cee97bca9
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsCloseTo_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.bytes;
+
+import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.BytesBaseTest;
+import org.junit.Test;
+
+public class Bytes_assertIsCloseTo_Test extends BytesBaseTest {
+
+  private static final Byte ZERO = 0;
+  private static final Byte ONE = 1;
+  private static final Byte TWO = 2;
+  private static final Byte TEN = 10;
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    bytes.assertIsCloseTo(someInfo(), null, ONE, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if__expected_value_is_null() {
+    bytes.assertIsCloseTo(someInfo(), ONE, null, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_offset_is_null() {
+    bytes.assertIsCloseTo(someInfo(), ONE, ZERO, null);
+  }
+
+  @Test
+  public void should_pass_if_difference_is_less_than_given_offset() {
+    bytes.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
+    bytes.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
+  }
+
+  @Test
+  public void should_pass_if_difference_is_equal_to_given_offset() {
+    bytes.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
+    bytes.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
+    bytes.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+  }
+  
+  @Test
+  public void should_fail_if_actual_is_not_close_enough_to_expected_value() {
+    AssertionInfo info = someInfo();
+    try {
+      bytes.assertIsCloseTo(info, ONE, TEN, within(ONE));
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeEqual(ONE, TEN, within(ONE), (byte)(TEN - ONE)));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsCloseTo_Test.java
new file mode 100644
index 000000000..dade68101
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsCloseTo_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.doubles;
+
+import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DoublesBaseTest;
+import org.junit.Test;
+
+public class Doubles_assertIsCloseTo_Test extends DoublesBaseTest {
+
+  private static final Double ZERO = 0d;
+  private static final Double ONE = 1d;
+  private static final Double TWO = 2d;
+  private static final Double TEN = 10d;
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    doubles.assertIsCloseTo(someInfo(), null, ONE, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_expected_value_is_null() {
+    doubles.assertIsCloseTo(someInfo(), ONE, null, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_offset_is_null() {
+    doubles.assertIsCloseTo(someInfo(), ONE, ZERO, null);
+  }
+
+  @Test
+  public void should_pass_if_difference_is_less_than_given_offset() {
+    doubles.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
+    doubles.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
+  }
+
+  @Test
+  public void should_pass_if_difference_is_equal_to_given_offset() {
+    doubles.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
+    doubles.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
+    doubles.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+  }
+  
+  @Test
+  public void should_fail_if_actual_is_not_close_enough_to_expected_value() {
+    AssertionInfo info = someInfo();
+    try {
+      doubles.assertIsCloseTo(info, ONE, TEN, within(ONE));
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeEqual(ONE, TEN, within(ONE), TEN - ONE));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/floats/Floats_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/floats/Floats_assertIsCloseTo_Test.java
new file mode 100644
index 000000000..cdb186a53
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/floats/Floats_assertIsCloseTo_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.floats;
+
+import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.FloatsBaseTest;
+import org.junit.Test;
+
+public class Floats_assertIsCloseTo_Test extends FloatsBaseTest {
+
+  private static final Float ZERO = 0f;
+  private static final Float ONE = 1f;
+  private static final Float TWO = 2f;
+  private static final Float TEN = 10f;
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    floats.assertIsCloseTo(someInfo(), null, ONE, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if__expected_value_is_null() {
+    floats.assertIsCloseTo(someInfo(), ONE, null, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_offset_is_null() {
+    floats.assertIsCloseTo(someInfo(), ONE, ZERO, null);
+  }
+
+  @Test
+  public void should_pass_if_difference_is_less_than_given_offset() {
+    floats.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
+    floats.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
+  }
+
+  @Test
+  public void should_pass_if_difference_is_equal_to_given_offset() {
+    floats.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
+    floats.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
+    floats.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+  }
+  
+  @Test
+  public void should_fail_if_actual_is_not_close_enough_to_expected_value() {
+    AssertionInfo info = someInfo();
+    try {
+      floats.assertIsCloseTo(info, ONE, TEN, within(ONE));
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeEqual(ONE, TEN, within(ONE), TEN - ONE));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/integers/Integers_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/integers/Integers_assertIsCloseTo_Test.java
new file mode 100644
index 000000000..702262cee
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/integers/Integers_assertIsCloseTo_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.integers;
+
+import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.IntegersBaseTest;
+import org.junit.Test;
+
+public class Integers_assertIsCloseTo_Test extends IntegersBaseTest {
+
+  private static final Integer ZERO = 0;
+  private static final Integer ONE = 1;
+  private static final Integer TWO = 2;
+  private static final Integer TEN = 10;
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    integers.assertIsCloseTo(someInfo(), null, ONE, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_expected_value_is_null() {
+    integers.assertIsCloseTo(someInfo(), ONE, null, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_offset_is_null() {
+    integers.assertIsCloseTo(someInfo(), ONE, ZERO, null);
+  }
+
+  @Test
+  public void should_pass_if_difference_is_less_than_given_offset() {
+    integers.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
+    integers.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
+  }
+
+  @Test
+  public void should_pass_if_difference_is_equal_to_given_offset() {
+    integers.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
+    integers.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
+    integers.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+  }
+  
+  @Test
+  public void should_fail_if_actual_is_not_close_enough_to_expected_value() {
+    AssertionInfo info = someInfo();
+    try {
+      integers.assertIsCloseTo(info, ONE, TEN, within(ONE));
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeEqual(ONE, TEN, within(ONE), TEN - ONE));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/longs/Longs_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/longs/Longs_assertIsCloseTo_Test.java
new file mode 100644
index 000000000..f429fb9f7
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/longs/Longs_assertIsCloseTo_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.longs;
+
+import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.LongsBaseTest;
+import org.junit.Test;
+
+public class Longs_assertIsCloseTo_Test extends LongsBaseTest {
+
+  private static final Long ZERO = 0l;
+  private static final Long ONE = 1l;
+  private static final Long TWO = 2l;
+  private static final Long TEN = 10l;
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    longs.assertIsCloseTo(someInfo(), null, ONE, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_expected_value_is_null() {
+    longs.assertIsCloseTo(someInfo(), ONE, null, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_offset_is_null() {
+    longs.assertIsCloseTo(someInfo(), ONE, ZERO, null);
+  }
+
+  @Test
+  public void should_pass_if_difference_is_less_than_given_offset() {
+    longs.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
+    longs.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
+  }
+
+  @Test
+  public void should_pass_if_difference_is_equal_to_given_offset() {
+    longs.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
+    longs.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
+    longs.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+  }
+  
+  @Test
+  public void should_fail_if_actual_is_not_close_enough_to_expected_value() {
+    AssertionInfo info = someInfo();
+    try {
+      longs.assertIsCloseTo(info, ONE, TEN, within(ONE));
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeEqual(ONE, TEN, within(ONE), TEN - ONE));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsCloseTo_Test.java
new file mode 100644
index 000000000..1812cfb4d
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsCloseTo_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.shorts;
+
+import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.ShortsBaseTest;
+import org.junit.Test;
+
+public class Shorts_assertIsCloseTo_Test extends ShortsBaseTest {
+
+  private static final Short ZERO = 0;
+  private static final Short ONE = 1;
+  private static final Short TWO = 2;
+  private static final Short TEN = 10;
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    shorts.assertIsCloseTo(someInfo(), null, ONE, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_expected_value_is_null() {
+    shorts.assertIsCloseTo(someInfo(), ONE, null, within(ONE));
+  }
+
+  @Test(expected = NullPointerException.class)
+  public void should_fail_if_offset_is_null() {
+    shorts.assertIsCloseTo(someInfo(), ONE, ZERO, null);
+  }
+
+  @Test
+  public void should_pass_if_difference_is_less_than_given_offset() {
+    shorts.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
+    shorts.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
+  }
+
+  @Test
+  public void should_pass_if_difference_is_equal_to_given_offset() {
+    shorts.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
+    shorts.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
+    shorts.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+  }
+  
+  @Test
+  public void should_fail_if_actual_is_not_close_enough_to_expected_value() {
+    AssertionInfo info = someInfo();
+    try {
+      shorts.assertIsCloseTo(info, ONE, TEN, within(ONE));
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeEqual(ONE, TEN, within(ONE), (short)(TEN - ONE)));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
