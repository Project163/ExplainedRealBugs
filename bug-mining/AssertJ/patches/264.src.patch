diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index e947cedf3..28a434455 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -835,7 +835,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     List<Object> values = FieldsOrPropertiesExtractor.extract(actual, byName(propertyOrField));
     String extractedDescription = extractedDescriptionOf(propertyOrField);
     String description = mostRelevantDescription(info.description(), extractedDescription);
-    return newListAssertInstance(values).as(description);
+    return newListAssertInstance(values).withAssertionState(myself).as(description);
   }
 
   /**
@@ -1025,7 +1025,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     List<P> values = (List<P>) FieldsOrPropertiesExtractor.extract(actual, byName(propertyOrField));
     String extractedDescription = extractedDescriptionOf(propertyOrField);
     String description = mostRelevantDescription(info.description(), extractedDescription);
-    return newListAssertInstance(values).as(description);
+    return newListAssertInstance(values).withAssertionState(myself).as(description);
   }
 
   /**
@@ -1117,7 +1117,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     List<Tuple> values = FieldsOrPropertiesExtractor.extract(actual, byName(propertiesOrFields));
     String extractedDescription = extractedDescriptionOf(propertiesOrFields);
     String description = mostRelevantDescription(info.description(), extractedDescription);
-    return newListAssertInstance(values).as(description);
+    return newListAssertInstance(values).withAssertionState(myself).as(description);
   }
 
   /**
@@ -1163,7 +1163,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   @CheckReturnValue
   public <V> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> extracting(Extractor<? super ELEMENT, V> extractor) {
     List<V> values = FieldsOrPropertiesExtractor.extract(actual, extractor);
-    return newListAssertInstance(values).as(info.description());
+    return newListAssertInstance(values).withAssertionState(myself);
   }
 
   /**
@@ -1209,7 +1209,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   @CheckReturnValue
   public <V, EXCEPTION extends Exception> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> extracting(ThrowingExtractor<? super ELEMENT, V, EXCEPTION> extractor) {
     List<V> values = FieldsOrPropertiesExtractor.extract(actual, extractor);
-    return newListAssertInstance(values).as(info.description());
+    return newListAssertInstance(values).withAssertionState(myself);
   }
 
   /**
@@ -1494,7 +1494,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
                                                                                           .toArray());
     List<Tuple> tuples = stream(actual.spliterator(), false).map(tupleExtractor)
                                                             .collect(toList());
-    return newListAssertInstance(tuples).as(info.description());
+    return newListAssertInstance(tuples).withAssertionState(myself);
   }
 
   /**
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index c7819c318..759d9f72f 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -1467,6 +1467,7 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
   @CheckReturnValue
   public SELF usingElementComparator(Comparator<? super ELEMENT> elementComparator) {
     this.arrays = new ObjectArrays(new ComparatorBasedComparisonStrategy(elementComparator));
+    this.iterables = new Iterables(new ComparatorBasedComparisonStrategy(elementComparator));
     // to have the same semantics on base assertions like isEqualTo, we need to use an iterable comparator comparing
     // elements with elementComparator parameter
     objects = new Objects(new ObjectArrayElementComparisonStrategy<>(elementComparator));
@@ -1869,7 +1870,7 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
     Object[] values = FieldsOrPropertiesExtractor.extract(actual, byName(fieldOrProperty));
     String extractedDescription = extractedDescriptionOf(fieldOrProperty);
     String description = mostRelevantDescription(info.description(), extractedDescription);
-    return newListAssertInstance(newArrayList(values)).as(description);
+    return newListAssertInstance(newArrayList(values)).withAssertionState(myself).as(description);
   }
 
   /**
@@ -1923,7 +1924,7 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
     List<P> values = (List<P>) FieldsOrPropertiesExtractor.extract(Arrays.asList(actual), byName(fieldOrProperty));
     String extractedDescription = extractedDescriptionOf(fieldOrProperty);
     String description = mostRelevantDescription(info.description(), extractedDescription);
-    return newListAssertInstance(values).as(description);
+    return newListAssertInstance(values).withAssertionState(myself).as(description);
   }
 
   /**
@@ -1981,7 +1982,7 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
     List<Tuple> values = FieldsOrPropertiesExtractor.extract(Arrays.asList(actual), byName(propertiesOrFields));
     String extractedDescription = extractedDescriptionOf(propertiesOrFields);
     String description = mostRelevantDescription(info.description(), extractedDescription);
-    return newListAssertInstance(values).as(description);
+    return newListAssertInstance(values).withAssertionState(myself).as(description);
   }
 
   /**
@@ -2018,7 +2019,7 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
   @CheckReturnValue
   public <U> AbstractListAssert<?, List<? extends U>, U, ObjectAssert<U>> extracting(Extractor<? super ELEMENT, U> extractor) {
     List<U> values = FieldsOrPropertiesExtractor.extract(Arrays.asList(actual), extractor);
-    return newListAssertInstance(values).as(info.description());
+    return newListAssertInstance(values).withAssertionState(myself);
   }
 
   /**
@@ -2062,7 +2063,7 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
   @CheckReturnValue
   public <V, EXCEPTION extends Exception> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> extracting(ThrowingExtractor<? super ELEMENT, V, EXCEPTION> extractor) {
     List<V> values = FieldsOrPropertiesExtractor.extract(newArrayList(actual), extractor);
-    return newListAssertInstance(values).as(info.description());
+    return newListAssertInstance(values).withAssertionState(myself);
   }
 
   /**
@@ -2120,7 +2121,7 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
                                                                                           .map(extractor -> extractor.apply(objectToExtractValueFrom))
                                                                                           .toArray());
     List<Tuple> tuples = stream(actual).map(tupleExtractor).collect(toList());
-    return newListAssertInstance(tuples).as(info.description());
+    return newListAssertInstance(tuples).withAssertionState(myself);
   }
 
   /**
diff --git a/src/main/java/org/assertj/core/groups/Tuple.java b/src/main/java/org/assertj/core/groups/Tuple.java
index 876e3d0a6..c732eb385 100644
--- a/src/main/java/org/assertj/core/groups/Tuple.java
+++ b/src/main/java/org/assertj/core/groups/Tuple.java
@@ -24,11 +24,11 @@ public class Tuple {
   private final List<Object> datas = newArrayList();
 
   public Tuple(Object... values) {
-	addAll(datas, values);
+    addAll(datas, values);
   }
 
   public Object[] toArray() {
-	return datas.toArray();
+    return datas.toArray();
   }
 
   public List<Object> toList() {
@@ -37,19 +37,19 @@ public class Tuple {
 
   @Override
   public int hashCode() {
-	final int prime = 31;
-	int result = 1;
-	result = prime * result + datas.hashCode();
-	return result;
+    final int prime = 31;
+    int result = 1;
+    result = prime * result + datas.hashCode();
+    return result;
   }
 
   @Override
   public boolean equals(Object obj) {
-	if (this == obj) return true;
-	if (obj == null) return false;
+    if (this == obj) return true;
+    if (obj == null) return false;
     if (!(obj instanceof Tuple)) return false;
-	Tuple other = (Tuple) obj;
-	// datas can't be null
+    Tuple other = (Tuple) obj;
+    // datas can't be null
     return areEqual(datas.toArray(), other.datas.toArray());
   }
 
@@ -59,7 +59,7 @@ public class Tuple {
   }
 
   public static Tuple tuple(Object... values) {
-	return new Tuple(values);
+    return new Tuple(values);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/GroupAssertTestHelper.java b/src/test/java/org/assertj/core/api/GroupAssertTestHelper.java
new file mode 100644
index 000000000..3a533a4d6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/GroupAssertTestHelper.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import java.util.Map;
+import java.util.function.Function;
+
+import org.assertj.core.api.iterable.ThrowingExtractor;
+import org.assertj.core.internal.TypeComparators;
+import org.assertj.core.test.Employee;
+import org.assertj.core.util.introspection.PropertyOrFieldSupport;
+
+public class GroupAssertTestHelper {
+
+  public static TypeComparators comparatorsByTypeOf(AbstractListAssert<?, ?, ?, ?> assertion) {
+    return (TypeComparators) PropertyOrFieldSupport.EXTRACTION.getValueOf("comparatorsByType", assertion);
+  }
+
+  public static TypeComparators comparatorForElementFieldsWithTypeOf(AbstractListAssert<?, ?, ?, ?> assertion) {
+    return (TypeComparators) PropertyOrFieldSupport.EXTRACTION.getValueOf("comparatorsForElementPropertyOrFieldTypes", assertion);
+  }
+
+  public static Map<?, ?> comparatorForElementFieldsWithNamesOf(AbstractListAssert<?, ?, ?, ?> assertion) {
+    return (Map<?, ?>) PropertyOrFieldSupport.EXTRACTION.getValueOf("comparatorsForElementPropertyOrFieldNames", assertion);
+  }
+
+  public static final Function<Employee, String> lastNameFunction = employee -> employee.name.getLast();
+  public static final Function<Employee, String> firstNameFunction = employee -> employee.name.first;
+  public static final ThrowingExtractor<Employee, String, Exception> throwingFirstNameExtractor = employee -> employee.name.first;
+
+}
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index 4d98f5f7e..375574337 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -105,14 +105,14 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
 
   private Map<String, Object> iterableMap;
 
-  private ThrowingExtractor<Name, String, Exception> throwingFirstNameExtractor;
-  private ThrowingExtractor<Name, String, Exception> throwingLastNameExtractor;
-  private Extractor<Name, String> firstNameExtractor;
-  private Extractor<Name, String> lastNameExtractor;
-  private Function<Name, String> firstNameFunction;
-  private Function<Name, String> lastNameFunction;
+  private static final ThrowingExtractor<Name, String, Exception> throwingFirstNameExtractor = Name::getFirst;
+  private static final ThrowingExtractor<Name, String, Exception> throwingLastNameExtractor = Name::getLast;
+  private static final Extractor<Name, String> firstNameExtractor = Name::getFirst;
+  private static final Extractor<Name, String> lastNameExtractor = Name::getLast;
+  private static final Function<Name, String> firstNameFunction = Name::getFirst;
+  private static final Function<Name, String> lastNameFunction = Name::getLast;
 
-  private Extractor<? super CartoonCharacter, ? extends Collection<CartoonCharacter>> childrenExtractor;
+  private static final Extractor<? super CartoonCharacter, ? extends Collection<CartoonCharacter>> childrenExtractor = CartoonCharacter::getChildren;
 
   @Before
   public void setup() {
@@ -141,15 +141,6 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
     iterableMap.put("job", jobs);
     iterableMap.put("city", cities);
     iterableMap.put("rank", ranks);
-
-    throwingFirstNameExtractor = Name::getFirst;
-    throwingLastNameExtractor = Name::getLast;
-    firstNameFunction = Name::getFirst;
-    lastNameFunction = Name::getLast;
-    firstNameExtractor = Name::getFirst;
-    lastNameExtractor = Name::getLast;
-
-    childrenExtractor = CartoonCharacter::getChildren;
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
index 197de6f3c..97804cc2f 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
@@ -15,18 +15,31 @@ package org.assertj.core.api.iterable;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithNamesOf;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithTypeOf;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorsByTypeOf;
+import static org.assertj.core.api.GroupAssertTestHelper.firstNameFunction;
+import static org.assertj.core.api.GroupAssertTestHelper.lastNameFunction;
+import static org.assertj.core.api.GroupAssertTestHelper.throwingFirstNameExtractor;
 import static org.assertj.core.data.TolkienCharacter.Race.DWARF;
 import static org.assertj.core.data.TolkienCharacter.Race.ELF;
 import static org.assertj.core.data.TolkienCharacter.Race.HOBBIT;
 import static org.assertj.core.data.TolkienCharacter.Race.MAIA;
 import static org.assertj.core.data.TolkienCharacter.Race.MAN;
+import static org.assertj.core.extractor.Extractors.byName;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TIMESTAMP;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
 import static org.assertj.core.test.ExpectedException.none;
 import static org.assertj.core.util.Lists.newArrayList;
 
+import java.sql.Timestamp;
 import java.util.ArrayList;
 import java.util.List;
 
 import org.assertj.core.api.AbstractIterableAssert;
+import org.assertj.core.api.AbstractListAssert;
 import org.assertj.core.data.TolkienCharacter;
 import org.assertj.core.extractor.Extractors;
 import org.assertj.core.groups.Tuple;
@@ -48,7 +61,7 @@ public class IterableAssert_extracting_Test {
 
   private Employee yoda;
   private Employee luke;
-  private Iterable<Employee> employees;
+  private Iterable<Employee> jedis;
   private final List<TolkienCharacter> fellowshipOfTheRing = new ArrayList<>();
 
   private static final Extractor<Employee, String> firstName = new Extractor<Employee, String>() {
@@ -71,13 +84,13 @@ public class IterableAssert_extracting_Test {
       if (employee.getAge() < 20) throw new Exception("age < 20");
       return employee.getName().getFirst();
     }
-  }; 
+  };
 
   @Before
   public void setUp() {
     yoda = new Employee(1L, new Name("Yoda"), 800);
     luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
-    employees = newArrayList(yoda, luke);
+    jedis = newArrayList(yoda, luke);
     fellowshipOfTheRing.add(TolkienCharacter.of("Frodo", 33, HOBBIT));
     fellowshipOfTheRing.add(TolkienCharacter.of("Sam", 38, HOBBIT));
     fellowshipOfTheRing.add(TolkienCharacter.of("Gandalf", 2020, MAIA));
@@ -93,99 +106,99 @@ public class IterableAssert_extracting_Test {
 
   @Test
   public void should_allow_assertions_on_property_values_extracted_from_given_iterable() {
-    assertThat(employees).extracting("age")
-                         .as("extract property backed by a private field")
-                         .containsOnly(800, 26);
-    assertThat(employees).extracting("adult")
-                         .as("extract pure property")
-                         .containsOnly(true, true);
-    assertThat(employees).extracting("name.first")
-                         .as("nested property")
-                         .containsOnly("Yoda", "Luke");
-    assertThat(employees).extracting("name")
-                         .as("extract field that is also a property")
-                         .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
-    assertThat(employees).extracting("name", Name.class)
-                         .as("extract field that is also a property but specifying the extracted type")
-                         .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+    assertThat(jedis).extracting("age")
+                     .as("extract property backed by a private field")
+                     .containsOnly(800, 26);
+    assertThat(jedis).extracting("adult")
+                     .as("extract pure property")
+                     .containsOnly(true, true);
+    assertThat(jedis).extracting("name.first")
+                     .as("nested property")
+                     .containsOnly("Yoda", "Luke");
+    assertThat(jedis).extracting("name")
+                     .as("extract field that is also a property")
+                     .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+    assertThat(jedis).extracting("name", Name.class)
+                     .as("extract field that is also a property but specifying the extracted type")
+                     .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
   }
 
   @Test
   public void should_allow_assertions_on_null_property_values_extracted_from_given_iterable() {
     yoda.name.setFirst(null);
-    assertThat(employees).extracting("name.first")
-                         .as("not null property but null nested property")
-                         .containsOnly(null, "Luke");
+    assertThat(jedis).extracting("name.first")
+                     .as("not null property but null nested property")
+                     .containsOnly(null, "Luke");
     yoda.setName(null);
-    assertThat(employees).extracting("name.first")
-                         .as("extract nested property when top property is null")
-                         .containsOnly(null, "Luke");
-    assertThat(employees).extracting("name")
-                         .as("null property")
-                         .containsOnly(null, new Name("Luke", "Skywalker"));
+    assertThat(jedis).extracting("name.first")
+                     .as("extract nested property when top property is null")
+                     .containsOnly(null, "Luke");
+    assertThat(jedis).extracting("name")
+                     .as("null property")
+                     .containsOnly(null, new Name("Luke", "Skywalker"));
   }
 
   @Test
   public void should_allow_assertions_on_field_values_extracted_from_given_iterable() {
-    assertThat(employees).extracting("id")
-                         .as("extract field")
-                         .containsOnly(1L, 2L);
-    assertThat(employees).extracting("surname")
-                         .as("null field")
-                         .containsNull();
-    assertThat(employees).extracting("surname.first")
-                         .as("null nested field")
-                         .containsNull();
+    assertThat(jedis).extracting("id")
+                     .as("extract field")
+                     .containsOnly(1L, 2L);
+    assertThat(jedis).extracting("surname")
+                     .as("null field")
+                     .containsNull();
+    assertThat(jedis).extracting("surname.first")
+                     .as("null nested field")
+                     .containsNull();
     yoda.surname = new Name();
-    assertThat(employees).extracting("surname.first")
-                         .as("not null field but null nested field")
-                         .containsNull();
+    assertThat(jedis).extracting("surname.first")
+                     .as("not null field but null nested field")
+                     .containsNull();
     yoda.surname = new Name("Master");
-    assertThat(employees).extracting("surname.first")
-                         .as("nested field")
-                         .containsOnly("Master", null);
-    assertThat(employees).extracting("surname", Name.class)
-                         .as("extract field specifying the extracted type")
-                         .containsOnly(new Name("Master"), null);
+    assertThat(jedis).extracting("surname.first")
+                     .as("nested field")
+                     .containsOnly("Master", null);
+    assertThat(jedis).extracting("surname", Name.class)
+                     .as("extract field specifying the extracted type")
+                     .containsOnly(new Name("Master"), null);
   }
 
   @Test
   public void should_allow_assertions_on_property_values_extracted_from_given_iterable_with_extracted_type_defined() {
     // extract field that is also a property and check generic for comparator.
-    assertThat(employees).extracting("name", Name.class)
-                         .usingElementComparator((o1, o2) -> o1.getFirst().compareTo(o2.getFirst()))
-                         .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+    assertThat(jedis).extracting("name", Name.class)
+                     .usingElementComparator((o1, o2) -> o1.getFirst().compareTo(o2.getFirst()))
+                     .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
   }
 
   @Test
   public void should_throw_error_if_no_property_nor_field_with_given_name_can_be_extracted() {
     thrown.expectIntrospectionError();
-    assertThat(employees).extracting("unknown");
+    assertThat(jedis).extracting("unknown");
   }
 
   @Test
   public void should_allow_assertions_on_multiple_extracted_values_from_given_iterable() {
-    assertThat(employees).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
-                                                                             tuple("Luke", 26, 2L));
+    assertThat(jedis).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
+                                                                         tuple("Luke", 26, 2L));
   }
 
   @Test
   public void should_throw_error_if_one_property_or_field_can_not_be_extracted() {
     thrown.expectIntrospectionError();
-    assertThat(employees).extracting("unknown", "age", "id")
-                         .containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+    assertThat(jedis).extracting("unknown", "age", "id")
+                     .containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
   }
 
   @Test
   public void should_allow_extracting_single_values_using_extractor() {
-    assertThat(employees).extracting(firstName).containsOnly("Yoda", "Luke");
-    assertThat(employees).extracting(age).containsOnly(26, 800);
+    assertThat(jedis).extracting(firstName).containsOnly("Yoda", "Luke");
+    assertThat(jedis).extracting(age).containsOnly(26, 800);
   }
 
   @Test
   public void should_allow_assertions_on_extractor_assertions_extracted_from_given_array_compatibility_runtimeexception() {
     thrown.expect(RuntimeException.class);
-    assertThat(employees).extracting(new Extractor<Employee, String>() {
+    assertThat(jedis).extracting(new Extractor<Employee, String>() {
       @Override
       public String extract(Employee input) {
         if (input.getAge() > 100) {
@@ -198,13 +211,13 @@ public class IterableAssert_extracting_Test {
 
   @Test
   public void should_allow_assertions_on_extractor_assertions_extracted_from_given_array() {
-    assertThat(employees).extracting(input -> input.getName().getFirst()).containsOnly("Yoda", "Luke");
+    assertThat(jedis).extracting(input -> input.getName().getFirst()).containsOnly("Yoda", "Luke");
   }
 
   @Test
   public void should_rethrow_throwing_extractor_checked_exception_as_a_runtime_exception() {
     thrown.expect(RuntimeException.class, "java.lang.Exception: age > 100");
-    assertThat(employees).extracting(employee -> {
+    assertThat(jedis).extracting(employee -> {
       if (employee.getAge() > 100) throw new Exception("age > 100");
       return employee.getName().getFirst();
     });
@@ -213,7 +226,7 @@ public class IterableAssert_extracting_Test {
   @Test
   public void should_let_throwing_extractor_runtime_exception_bubble_up() {
     thrown.expect(RuntimeException.class, "age > 100");
-    assertThat(employees).extracting(employee -> {
+    assertThat(jedis).extracting(employee -> {
       if (employee.getAge() > 100) throw new RuntimeException("age > 100");
       return employee.getName().getFirst();
     });
@@ -221,7 +234,7 @@ public class IterableAssert_extracting_Test {
 
   @Test
   public void should_allow_extracting_with_throwing_extractor() {
-    assertThat(employees).extracting(employee -> {
+    assertThat(jedis).extracting(employee -> {
       if (employee.getAge() < 20) throw new Exception("age < 20");
       return employee.getName().getFirst();
     }).containsOnly("Yoda", "Luke");
@@ -229,7 +242,7 @@ public class IterableAssert_extracting_Test {
 
   @Test
   public void should_allow_extracting_with_anonymous_class_throwing_extractor() {
-    assertThat(employees).extracting(new ThrowingExtractor<Employee, Object, Exception>() {
+    assertThat(jedis).extracting(new ThrowingExtractor<Employee, Object, Exception>() {
       @Override
       public Object extractThrows(Employee employee) throws Exception {
         if (employee.getAge() < 20) throw new Exception("age < 20");
@@ -240,7 +253,7 @@ public class IterableAssert_extracting_Test {
 
   @Test
   public void should_allow_extracting_multiple_values_using_extractor() {
-    assertThat(employees).extracting(new Extractor<Employee, Tuple>() {
+    assertThat(jedis).extracting(new Extractor<Employee, Tuple>() {
       @Override
       public Tuple extract(Employee input) {
         return new Tuple(input.getName().getFirst(), input.getAge(), input.id);
@@ -250,9 +263,9 @@ public class IterableAssert_extracting_Test {
 
   @Test
   public void should_allow_extracting_by_toString_method() {
-    assertThat(employees).extracting(Extractors.toStringMethod())
-                         .containsOnly("Employee[id=1, name=Name[first='Yoda', last='null'], age=800]",
-                                       "Employee[id=2, name=Name[first='Luke', last='Skywalker'], age=26]");
+    assertThat(jedis).extracting(Extractors.toStringMethod())
+                     .containsOnly("Employee[id=1, name=Name[first='Yoda', last='null'], age=800]",
+                                   "Employee[id=2, name=Name[first='Luke', last='Skywalker'], age=26]");
   }
 
   @Test
@@ -359,49 +372,55 @@ public class IterableAssert_extracting_Test {
   public void should_use_property_field_names_as_description_when_extracting_simple_value_list() {
     thrown.expectAssertionErrorWithMessageContaining("[Extracted: name.first]");
 
-    assertThat(employees).extracting("name.first").isEmpty();
+    assertThat(jedis).extracting("name.first").isEmpty();
   }
 
   @Test
   public void should_use_property_field_names_as_description_when_extracting_typed_simple_value_list() {
     thrown.expectAssertionErrorWithMessageContaining("[Extracted: name.first]");
 
-    assertThat(employees).extracting("name.first", String.class).isEmpty();
+    assertThat(jedis).extracting("name.first", String.class).isEmpty();
   }
 
   @Test
   public void should_use_property_field_names_as_description_when_extracting_tuples_list() {
     thrown.expectAssertionErrorWithMessageContaining("[Extracted: name.first, name.last]");
 
-    assertThat(employees).extracting("name.first", "name.last").isEmpty();
+    assertThat(jedis).extracting("name.first", "name.last").isEmpty();
   }
 
   @Test
   public void should_keep_existing_description_if_set_when_extracting_typed_simple_value_list() {
     thrown.expectAssertionErrorWithMessageContaining("[check employees first name]");
 
-    assertThat(employees).as("check employees first name").extracting("name.first", String.class).isEmpty();
+    assertThat(jedis).as("check employees first name")
+                     .extracting("name.first", String.class)
+                     .isEmpty();
   }
 
   @Test
   public void should_keep_existing_description_if_set_when_extracting_tuples_list() {
     thrown.expectAssertionErrorWithMessageContaining("[check employees name]");
 
-    assertThat(employees).as("check employees name").extracting("name.first", "name.last").isEmpty();
+    assertThat(jedis).as("check employees name")
+                     .extracting("name.first", "name.last")
+                     .isEmpty();
   }
 
   @Test
   public void should_keep_existing_description_if_set_when_extracting_simple_value_list() {
     thrown.expectAssertionErrorWithMessageContaining("[check employees first name]");
 
-    assertThat(employees).as("check employees first name").extracting("name.first").isEmpty();
+    assertThat(jedis).as("check employees first name")
+                     .extracting("name.first")
+                     .isEmpty();
   }
 
   @Test
   public void should_keep_existing_description_if_set_when_extracting_using_extractor() {
     thrown.expectAssertionErrorWithMessageContaining("[check employees first name]");
 
-    assertThat(employees).as("check employees first name").extracting(new Extractor<Employee, String>() {
+    assertThat(jedis).as("check employees first name").extracting(new Extractor<Employee, String>() {
       @Override
       public String extract(Employee input) {
         return input.getName().getFirst();
@@ -413,7 +432,153 @@ public class IterableAssert_extracting_Test {
   public void should_keep_existing_description_if_set_when_extracting_using_throwing_extractor() {
     thrown.expectAssertionErrorWithMessageContaining("[expected exception]");
 
-    assertThat(employees).as("expected exception").extracting(throwingExtractor).containsOnly("Luke");
+    assertThat(jedis).as("expected exception")
+                     .extracting(throwingExtractor)
+                     .containsOnly("Luke");
+  }
+
+  @Test
+  public void should_extract_tuples_according_to_given_functions() {
+    assertThat(jedis).extracting(firstNameFunction, lastNameFunction)
+                     .contains(tuple("Yoda", null), tuple("Luke", "Skywalker"));
+  }
+
+  @Test
+  public void extracting_by_several_functions_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_TUPLE, Tuple.class)
+                                                                .extracting(firstNameFunction, lastNameFunction)
+                                                                .contains(tuple("YODA", null), tuple("Luke", "Skywalker"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(Tuple.class)).isSameAs(ALWAY_EQUALS_TUPLE);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_name_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting("name.first")
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_strongly_typed_name_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting("name.first", String.class)
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_multiple_names_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_TUPLE, Tuple.class)
+                                                                .extracting("name.first", "name.last")
+                                                                .contains(tuple("YODA", null), tuple("Luke", "Skywalker"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(Tuple.class)).isSameAs(ALWAY_EQUALS_TUPLE);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_single_extractor_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting(byName("name.first"))
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_throwing_extractor_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting(throwingFirstNameExtractor)
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/list/ListAssert_assertionState_propagation_with_extracting_Test.java b/src/test/java/org/assertj/core/api/list/ListAssert_assertionState_propagation_with_extracting_Test.java
new file mode 100644
index 000000000..2423500a8
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/list/ListAssert_assertionState_propagation_with_extracting_Test.java
@@ -0,0 +1,191 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.list;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithNamesOf;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithTypeOf;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorsByTypeOf;
+import static org.assertj.core.api.GroupAssertTestHelper.firstNameFunction;
+import static org.assertj.core.api.GroupAssertTestHelper.lastNameFunction;
+import static org.assertj.core.api.GroupAssertTestHelper.throwingFirstNameExtractor;
+import static org.assertj.core.extractor.Extractors.byName;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TIMESTAMP;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.sql.Timestamp;
+import java.util.List;
+
+import org.assertj.core.api.AbstractListAssert;
+import org.assertj.core.groups.Tuple;
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.Name;
+import org.junit.Before;
+import org.junit.Test;
+
+public class ListAssert_assertionState_propagation_with_extracting_Test {
+
+  private Employee yoda;
+  private Employee luke;
+  private List<Employee> jedis;
+
+  @Before
+  public void setUp() {
+    yoda = new Employee(1L, new Name("Yoda"), 800);
+    luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+    jedis = newArrayList(yoda, luke);
+  }
+
+  @Test
+  public void extracting_by_several_functions_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_TUPLE, Tuple.class)
+                                                                .extracting(firstNameFunction, lastNameFunction)
+                                                                .contains(tuple("YODA", null), tuple("Luke", "Skywalker"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(Tuple.class)).isSameAs(ALWAY_EQUALS_TUPLE);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_name_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting("name.first")
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_strongly_typed_name_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting("name.first", String.class)
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_multiple_names_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_TUPLE, Tuple.class)
+                                                                .extracting("name.first", "name.last")
+                                                                .contains(tuple("YODA", null), tuple("Luke", "Skywalker"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(Tuple.class)).isSameAs(ALWAY_EQUALS_TUPLE);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_single_extractor_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting(byName("name.first"))
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_throwing_extractor_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting(throwingFirstNameExtractor)
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java
index a74a29ddd..5dad65906 100644
--- a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java
@@ -15,19 +15,33 @@ package org.assertj.core.api.objectarray;
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithNamesOf;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithTypeOf;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorsByTypeOf;
+import static org.assertj.core.api.GroupAssertTestHelper.firstNameFunction;
+import static org.assertj.core.api.GroupAssertTestHelper.lastNameFunction;
+import static org.assertj.core.api.GroupAssertTestHelper.throwingFirstNameExtractor;
 import static org.assertj.core.data.TolkienCharacter.Race.DWARF;
 import static org.assertj.core.data.TolkienCharacter.Race.ELF;
 import static org.assertj.core.data.TolkienCharacter.Race.HOBBIT;
 import static org.assertj.core.data.TolkienCharacter.Race.MAIA;
 import static org.assertj.core.data.TolkienCharacter.Race.MAN;
+import static org.assertj.core.extractor.Extractors.byName;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TIMESTAMP;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
 import static org.assertj.core.test.ExpectedException.none;
 import static org.assertj.core.util.Arrays.array;
 
+import java.sql.Timestamp;
 import java.util.List;
 
 import org.assertj.core.api.AbstractIterableAssert;
+import org.assertj.core.api.AbstractListAssert;
 import org.assertj.core.api.iterable.ThrowingExtractor;
 import org.assertj.core.data.TolkienCharacter;
+import org.assertj.core.groups.Tuple;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
@@ -45,7 +59,7 @@ public class ObjectArrayAssert_extracting_Test {
 
   private Employee yoda;
   private Employee luke;
-  private Employee[] employees;
+  private Employee[] jedis;
   private TolkienCharacter[] fellowshipOfTheRing;
 
   @Rule
@@ -55,7 +69,7 @@ public class ObjectArrayAssert_extracting_Test {
   public void setUpOnce() {
     yoda = new Employee(1L, new Name("Yoda"), 800);
     luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
-    employees = array(yoda, luke);
+    jedis = array(yoda, luke);
     fellowshipOfTheRing = new TolkienCharacter[8];
     fellowshipOfTheRing[0] = TolkienCharacter.of("Frodo", 33, HOBBIT);
     fellowshipOfTheRing[1] = TolkienCharacter.of("Sam", 38, HOBBIT);
@@ -74,52 +88,52 @@ public class ObjectArrayAssert_extracting_Test {
 
   @Test
   public void should_allow_assertions_on_property_values_extracted_from_given_iterable() {
-    assertThat(employees).extracting("age").containsOnly(800, 26);
+    assertThat(jedis).extracting("age").containsOnly(800, 26);
   }
 
   @Test
   public void should_allow_assertions_on_property_values_extracted_from_given_iterable_with_extracted_type_defined() {
-    assertThat(employees).extracting("name", Name.class).containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+    assertThat(jedis).extracting("name", Name.class).containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
   }
 
   @Test
   public void should_allow_assertions_on_field_values_extracted_from_given_iterable() {
     // basic types
-    assertThat(employees).extracting("id").containsOnly(1L, 2L);
+    assertThat(jedis).extracting("id").containsOnly(1L, 2L);
     // object
-    assertThat(employees).extracting("name").containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+    assertThat(jedis).extracting("name").containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
     // nested property
-    assertThat(employees).extracting("name.first").containsOnly("Yoda", "Luke");
+    assertThat(jedis).extracting("name.first").containsOnly("Yoda", "Luke");
   }
 
   @Test
   public void should_throw_error_if_no_property_nor_field_with_given_name_can_be_extracted() {
     thrown.expectIntrospectionError();
-    assertThat(employees).extracting("unknown");
+    assertThat(jedis).extracting("unknown");
   }
 
   @Test
   public void should_allow_assertions_on_multiple_extracted_values_from_given_iterable() {
-    assertThat(employees).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
-                                                                             tuple("Luke", 26, 2L));
+    assertThat(jedis).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
+                                                                         tuple("Luke", 26, 2L));
   }
 
   @Test
   public void should_throw_error_if_one_property_or_field_can_not_be_extracted() {
     thrown.expectIntrospectionError();
-    assertThat(employees).extracting("unknown", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
-                                                                          tuple("Luke", 26, 2L));
+    assertThat(jedis).extracting("unknown", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
+                                                                      tuple("Luke", 26, 2L));
   }
 
   @Test
   public void should_allow_assertions_on_extractor_assertions_extracted_from_given_array_compatibility() {
-    assertThat(employees).extracting(input -> input.getName().getFirst()).containsOnly("Yoda", "Luke");
+    assertThat(jedis).extracting(input -> input.getName().getFirst()).containsOnly("Yoda", "Luke");
   }
 
   @Test
   public void should_allow_assertions_on_extractor_assertions_extracted_from_given_array_compatibility_RuntimeException() {
     thrown.expect(RuntimeException.class);
-    assertThat(employees).extracting(input -> {
+    assertThat(jedis).extracting(input -> {
       if (input.getAge() > 100) throw new RuntimeException("age > 100");
       return input.getName().getFirst();
     });
@@ -127,13 +141,13 @@ public class ObjectArrayAssert_extracting_Test {
 
   @Test
   public void should_allow_assertions_on_extractor_assertions_extracted_from_given_array() {
-    assertThat(employees).extracting(input -> input.getName().getFirst()).containsOnly("Yoda", "Luke");
+    assertThat(jedis).extracting(input -> input.getName().getFirst()).containsOnly("Yoda", "Luke");
   }
 
   @Test
   public void should_rethrow_throwing_extractor_checked_exception_as_a_runtime_exception() {
     thrown.expect(RuntimeException.class, "java.lang.Exception: age > 100");
-    assertThat(employees).extracting(employee -> {
+    assertThat(jedis).extracting(employee -> {
       if (employee.getAge() > 100) throw new Exception("age > 100");
       return employee.getName().getFirst();
     });
@@ -142,7 +156,7 @@ public class ObjectArrayAssert_extracting_Test {
   @Test
   public void should_let_throwing_extractor_runtime_exception_bubble_up() {
     thrown.expect(RuntimeException.class, "age > 100");
-    assertThat(employees).extracting(employee -> {
+    assertThat(jedis).extracting(employee -> {
       if (employee.getAge() > 100) throw new RuntimeException("age > 100");
       return employee.getName().getFirst();
     });
@@ -150,12 +164,12 @@ public class ObjectArrayAssert_extracting_Test {
 
   @Test
   public void should_allow_extracting_with_throwing_extractor() {
-    assertThat(employees).extracting(THROWING_EXTRACTOR).containsOnly("Yoda", "Luke");
+    assertThat(jedis).extracting(THROWING_EXTRACTOR).containsOnly("Yoda", "Luke");
   }
 
   @Test
   public void should_allow_extracting_with_anonymous_class_throwing_extractor() {
-    assertThat(employees).extracting(new ThrowingExtractor<Employee, Object, Exception>() {
+    assertThat(jedis).extracting(new ThrowingExtractor<Employee, Object, Exception>() {
       @Override
       public Object extractThrows(Employee employee) throws Exception {
         if (employee.getAge() < 20) throw new Exception("age < 20");
@@ -270,55 +284,193 @@ public class ObjectArrayAssert_extracting_Test {
   public void should_use_property_field_names_as_description_when_extracting_simple_value_list() {
     thrown.expectAssertionErrorWithMessageContaining("[Extracted: name.first]");
 
-    assertThat(employees).extracting("name.first").isEmpty();
+    assertThat(jedis).extracting("name.first").isEmpty();
   }
 
   @Test
   public void should_use_property_field_names_as_description_when_extracting_typed_simple_value_list() {
     thrown.expectAssertionErrorWithMessageContaining("[Extracted: name.first]");
 
-    assertThat(employees).extracting("name.first", String.class).isEmpty();
+    assertThat(jedis).extracting("name.first", String.class).isEmpty();
   }
 
   @Test
   public void should_use_property_field_names_as_description_when_extracting_tuples_list() {
     thrown.expectAssertionErrorWithMessageContaining("[Extracted: name.first, name.last]");
 
-    assertThat(employees).extracting("name.first", "name.last").isEmpty();
+    assertThat(jedis).extracting("name.first", "name.last").isEmpty();
   }
 
   @Test
   public void should_keep_existing_description_if_set_when_extracting_typed_simple_value_list() {
     thrown.expectAssertionErrorWithMessageContaining("[check employees first name]");
 
-    assertThat(employees).as("check employees first name").extracting("name.first", String.class).isEmpty();
+    assertThat(jedis).as("check employees first name").extracting("name.first", String.class).isEmpty();
   }
 
   @Test
   public void should_keep_existing_description_if_set_when_extracting_tuples_list() {
     thrown.expectAssertionErrorWithMessageContaining("[check employees name]");
 
-    assertThat(employees).as("check employees name").extracting("name.first", "name.last").isEmpty();
+    assertThat(jedis).as("check employees name").extracting("name.first", "name.last").isEmpty();
   }
 
   @Test
   public void should_keep_existing_description_if_set_when_extracting_simple_value_list() {
     thrown.expectAssertionErrorWithMessageContaining("[check employees first name]");
 
-    assertThat(employees).as("check employees first name").extracting("name.first").isEmpty();
+    assertThat(jedis).as("check employees first name").extracting("name.first").isEmpty();
   }
 
   @Test
   public void should_keep_existing_description_if_set_when_extracting_using_extractor() {
     thrown.expectAssertionErrorWithMessageContaining("[check employees first name]");
 
-    assertThat(employees).as("check employees first name").extracting(input -> input.getName().getFirst()).isEmpty();
+    assertThat(jedis).as("check employees first name").extracting(input -> input.getName().getFirst()).isEmpty();
   }
 
   public void should_keep_existing_description_if_set_when_extracting_using_throwing_extractor() {
     thrown.expectAssertionErrorWithMessageContaining("[expected exception]");
 
-    assertThat(employees).as("expected exception").extracting(THROWING_EXTRACTOR).isEmpty();
+    assertThat(jedis).as("expected exception").extracting(THROWING_EXTRACTOR).isEmpty();
+  }
+
+  @Test
+  public void extracting_by_several_functions_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_TUPLE, Tuple.class)
+                                                                .extracting(firstNameFunction, lastNameFunction)
+                                                                .contains(tuple("YODA", null), tuple("Luke", "Skywalker"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(Tuple.class)).isSameAs(ALWAY_EQUALS_TUPLE);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_name_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting("name.first")
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_strongly_typed_name_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting("name.first", String.class)
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_multiple_names_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_TUPLE, Tuple.class)
+                                                                .extracting("name.first", "name.last")
+                                                                .contains(tuple("YODA", null), tuple("Luke", "Skywalker"));
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(Tuple.class)).isSameAs(ALWAY_EQUALS_TUPLE);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_single_extractor_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting(byName("name.first"))
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+  @Test
+  public void extracting_by_throwing_extractor_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
+                                                                                                          "foo")
+                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
+                                                                                                         Timestamp.class)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting(throwingFirstNameExtractor)
+                                                                .contains("YODA", "Luke");
+    // THEN
+    assertThat(assertion.descriptionText()).isEqualTo("test description");
+    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/test/AlwaysEqualComparator.java b/src/test/java/org/assertj/core/test/AlwaysEqualComparator.java
index aa8cf3f50..1a8501f74 100644
--- a/src/test/java/org/assertj/core/test/AlwaysEqualComparator.java
+++ b/src/test/java/org/assertj/core/test/AlwaysEqualComparator.java
@@ -15,11 +15,14 @@ package org.assertj.core.test;
 import java.sql.Timestamp;
 import java.util.Comparator;
 
+import org.assertj.core.groups.Tuple;
+
 public class AlwaysEqualComparator<T> implements Comparator<T> {
 
-  public static final AlwaysEqualComparator<Object> ALWAY_EQUALS = new AlwaysEqualComparator<>();
-  public static final AlwaysEqualComparator<String> ALWAY_EQUALS_STRING = new AlwaysEqualComparator<>();
-  public static final AlwaysEqualComparator<Timestamp> ALWAY_EQUALS_TIMESTAMP = new AlwaysEqualComparator<>();
+  public static final AlwaysEqualComparator<Object> ALWAY_EQUALS = alwaysEqual();
+  public static final AlwaysEqualComparator<String> ALWAY_EQUALS_STRING = alwaysEqual();
+  public static final AlwaysEqualComparator<Timestamp> ALWAY_EQUALS_TIMESTAMP = alwaysEqual();
+  public static final AlwaysEqualComparator<Tuple> ALWAY_EQUALS_TUPLE = alwaysEqual();
 
   @Override
   public int compare(T o1, T o2) {
