diff --git a/src/main/java/org/assertj/core/api/AbstractLocalTimeAssert.java b/src/main/java/org/assertj/core/api/AbstractLocalTimeAssert.java
new file mode 100644
index 000000000..6f1c34004
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/AbstractLocalTimeAssert.java
@@ -0,0 +1,535 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.error.ShouldBeAfter.shouldBeAfter;
+import static org.assertj.core.error.ShouldBeAfterOrEqualsTo.shouldBeAfterOrEqualsTo;
+import static org.assertj.core.error.ShouldBeBefore.shouldBeBefore;
+import static org.assertj.core.error.ShouldBeBeforeOrEqualsTo.shouldBeBeforeOrEqualsTo;
+import static org.assertj.core.error.ShouldBeEqualIgnoringNanos.shouldBeEqualIgnoringNanos;
+import static org.assertj.core.error.ShouldBeEqualIgnoringSeconds.shouldBeEqualIgnoringSeconds;
+import static org.assertj.core.error.ShouldHaveSameHourAs.shouldHaveSameHourAs;
+
+import java.time.LocalTime;
+
+import org.assertj.core.internal.Failures;
+import org.assertj.core.internal.Objects;
+
+/**
+ * Assertions for {@link LocalTime} type from new Date &amp; Time API introduced in Java 8.
+ */
+public abstract class AbstractLocalTimeAssert<S extends AbstractLocalTimeAssert<S>>
+    extends AbstractAssert<S, LocalTime> {
+
+  public static final String NULL_LOCAL_TIME_PARAMETER_MESSAGE = "The LocalTime to compare actual with should not be null";
+
+  /**
+   * Creates a new <code>{@link org.assertj.core.api.AbstractLocalTimeAssert}</code>.
+   * 
+   * @param selfType the "self type"
+   * @param actual the actual value to verify
+   */
+  protected AbstractLocalTimeAssert(LocalTime actual, Class<?> selfType) {
+	super(actual, selfType);
+  }
+
+  // visible for test
+  protected LocalTime getActual() {
+	return actual;
+  }
+
+  /**
+   * Verifies that the actual {@code LocalTime} is <b>strictly</b> before the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalTime.parse("12:00:00")).isBefore(LocalTime.parse("13:00:00"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalTime} is not strictly before the given one.
+   */
+  public S isBefore(LocalTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalTimeParameterIsNotNull(other);
+	if (!actual.isBefore(other)) {
+	  throw Failures.instance().failure(info, shouldBeBefore(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isBefore(LocalTime)} but the {@link LocalTime} is built from given String, which
+   * must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"
+   * >ISO LocalTime format</a> to allow calling {@link LocalTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // you can express expected LocalTime as String (AssertJ taking care of the conversion)
+   * assertThat(LocalTime.parse("12:59")).isBefore("13:00");
+   * </code></pre>
+   * 
+   * @param localTimeAsString String representing a {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalTime}.
+   * @throws AssertionError if the actual {@code LocalTime} is not strictly before the {@link LocalTime} built
+   *           from given String.
+   */
+  public S isBefore(String localTimeAsString) {
+	assertLocalTimeAsStringParameterIsNotNull(localTimeAsString);
+	return isBefore(LocalTime.parse(localTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalTime} is before or equals to the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalTime.parse("12:00:00")).isBeforeOrEqualTo(LocalTime.parse("12:00:00"))
+   *                                        .isBeforeOrEqualTo(LocalTime.parse("12:00:01"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalTime} is not before or equals to the given one.
+   */
+  public S isBeforeOrEqualTo(LocalTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalTimeParameterIsNotNull(other);
+	if (actual.isAfter(other)) {
+	  throw Failures.instance().failure(info, shouldBeBeforeOrEqualsTo(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isBeforeOrEqualTo(LocalTime)} but the {@link LocalTime} is built from given
+   * String, which must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"
+   * >ISO LocalTime format</a> to allow calling {@link LocalTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // you can express expected LocalTime as String (AssertJ taking care of the conversion)
+   * assertThat(LocalTime.parse("12:00:00")).isBeforeOrEqualTo("12:00:00")
+   *                                        .isBeforeOrEqualTo("13:00:00");
+   * </code></pre>
+   * 
+   * @param localTimeAsString String representing a {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalTime}.
+   * @throws AssertionError if the actual {@code LocalTime} is not before or equals to the {@link LocalTime} built from
+   *           given String.
+   */
+  public S isBeforeOrEqualTo(String localTimeAsString) {
+	assertLocalTimeAsStringParameterIsNotNull(localTimeAsString);
+	return isBeforeOrEqualTo(LocalTime.parse(localTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalTime} is after or equals to the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalTime.parse("13:00:00")).isAfterOrEqualTo(LocalTime.parse("13:00:00"))
+   *                                        .isAfterOrEqualTo(LocalTime.parse("12:00:00"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalTime} is not after or equals to the given one.
+   */
+  public S isAfterOrEqualTo(LocalTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalTimeParameterIsNotNull(other);
+	if (actual.isBefore(other)) {
+	  throw Failures.instance().failure(info, shouldBeAfterOrEqualsTo(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isAfterOrEqualTo(LocalTime)} but the {@link LocalTime} is built from given
+   * String, which must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"
+   * >ISO LocalTime format</a> to allow calling {@link LocalTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // you can express expected LocalTime as String (AssertJ taking care of the conversion)
+   * assertThat(LocalTime.parse("13:00:00")).isAfterOrEqualTo("13:00:00")
+   *                                        .isAfterOrEqualTo("12:00:00");
+   * </code></pre>
+   * 
+   * @param localTimeAsString String representing a {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalTime}.
+   * @throws AssertionError if the actual {@code LocalTime} is not after or equals to the {@link LocalTime} built from
+   *           given String.
+   */
+  public S isAfterOrEqualTo(String localTimeAsString) {
+	assertLocalTimeAsStringParameterIsNotNull(localTimeAsString);
+	return isAfterOrEqualTo(LocalTime.parse(localTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalTime} is <b>strictly</b> after the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalTime.parse("13:00:00")).isAfter(LocalTime.parse("12:00:00"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalTime} is not strictly after the given one.
+   */
+  public S isAfter(LocalTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalTimeParameterIsNotNull(other);
+	if (!actual.isAfter(other)) {
+	  throw Failures.instance().failure(info, shouldBeAfter(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isAfter(LocalTime)} but the {@link LocalTime} is built from given a String that
+   * must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"
+   * >ISO LocalTime format</a> to allow calling {@link LocalTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // you can express expected LocalTime as String (AssertJ taking care of the conversion)
+   * assertThat(LocalTime.parse("13:00:00")).isAfter("12:00:00");
+   * </code></pre>
+   * 
+   * @param localTimeAsString String representing a {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalTime}.
+   * @throws AssertionError if the actual {@code LocalTime} is not strictly after the {@link LocalTime} built
+   *           from given String.
+   */
+  public S isAfter(String localTimeAsString) {
+	assertLocalTimeAsStringParameterIsNotNull(localTimeAsString);
+	return isAfter(LocalTime.parse(localTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isEqualTo(Object)} (where Object is expected to be {@link LocalTime}) but here you
+   * pass {@link LocalTime} String representation that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"
+   * >ISO LocalTime format</a> to allow calling {@link LocalTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // you can express expected LocalTime as String (AssertJ taking care of the conversion)
+   * assertThat(LocalTime.parse("13:00:00")).isEqualTo("13:00:00");
+   * </code></pre>
+   * 
+   * @param localTimeAsString String representing a {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalTime}.
+   * @throws AssertionError if the actual {@code LocalTime} is not equal to the {@link LocalTime} built from
+   *           given String.
+   */
+  public S isEqualTo(String localTimeAsString) {
+	assertLocalTimeAsStringParameterIsNotNull(localTimeAsString);
+	return isEqualTo(LocalTime.parse(localTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isNotEqualTo(Object)} (where Object is expected to be {@link LocalTime}) but here you
+   * pass {@link LocalTime} String representation that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"
+   * >ISO LocalTime format</a> to allow calling {@link LocalTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // you can express expected LocalTime as String (AssertJ taking care of the conversion)
+   * assertThat(LocalTime.parse("13:00:00")).isNotEqualTo("12:00:00");
+   * </code></pre>
+   * 
+   * @param localTimeAsString String representing a {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalTime}.
+   * @throws AssertionError if the actual {@code LocalTime} is equal to the {@link LocalTime} built from given
+   *           String.
+   */
+  public S isNotEqualTo(String localTimeAsString) {
+	assertLocalTimeAsStringParameterIsNotNull(localTimeAsString);
+	return isNotEqualTo(LocalTime.parse(localTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isIn(Object...)} (where Objects are expected to be {@link LocalTime}) but here you
+   * pass {@link LocalTime} String representations that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"
+   * >ISO LocalTime format</a> to allow calling {@link LocalTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // you can express expected LocalTimes as String (AssertJ taking care of the conversion)
+   * assertThat(LocalTime.parse("13:00:00")).isIn("12:00:00", "13:00:00");
+   * </code></pre>
+   * 
+   * @param localTimesAsString String array representing {@link LocalTime}s.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalTime}.
+   * @throws AssertionError if the actual {@code LocalTime} is not in the {@link LocalTime}s built from given
+   *           Strings.
+   */
+  public S isIn(String... localTimesAsString) {
+	checkIsNotNullAndNotEmpty(localTimesAsString);
+	return isIn(convertToLocalTimeArray(localTimesAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isNotIn(Object...)} (where Objects are expected to be {@link LocalTime}) but here you
+   * pass {@link LocalTime} String representations that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_TIME"
+   * >ISO LocalTime format</a> to allow calling {@link LocalTime#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // you can express expected LocalTimes as String (AssertJ taking care of the conversion)
+   * assertThat(LocalTime.parse("13:00:00")).isNotIn("12:00:00", "14:00:00");
+   * </code></pre>
+   * 
+   * @param localTimesAsString Array of String representing a {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalTime}.
+   * @throws AssertionError if the actual {@code LocalTime} is in the {@link LocalTime}s built from given
+   *           Strings.
+   */
+  public S isNotIn(String... localTimesAsString) {
+	checkIsNotNullAndNotEmpty(localTimesAsString);
+	return isNotIn(convertToLocalTimeArray(localTimesAsString));
+  }
+
+  private static Object[] convertToLocalTimeArray(String... localTimesAsString) {
+	LocalTime[] dates = new LocalTime[localTimesAsString.length];
+	for (int i = 0; i < localTimesAsString.length; i++) {
+	  dates[i] = LocalTime.parse(localTimesAsString[i]);
+	}
+	return dates;
+  }
+
+  private void checkIsNotNullAndNotEmpty(Object[] values) {
+	if (values == null) throw new IllegalArgumentException("The given LocalTime array should not be null");
+	if (values.length == 0) throw new IllegalArgumentException("The given LocalTime array should not be empty");
+  }
+
+  /**
+   * Check that the {@link LocalTime} string representation to compare actual {@link LocalTime} to is not null,
+   * otherwise throws a {@link IllegalArgumentException} with an explicit message
+   * 
+   * @param localTimeAsString String representing the {@link LocalTime} to compare actual with
+   * @throws IllegalArgumentException with an explicit message if the given {@link String} is null
+   */
+  private static void assertLocalTimeAsStringParameterIsNotNull(String localTimeAsString) {
+	// @format:off
+	if (localTimeAsString == null) throw new IllegalArgumentException("The String representing the LocalTime to compare actual with should not be null");
+	// @format:on
+  }
+
+  /**
+   * Check that the {@link LocalTime} to compare actual {@link LocalTime} to is not null, in that case throws a
+   * {@link IllegalArgumentException} with an explicit message
+   * 
+   * @param other the {@link LocalTime} to check
+   * @throws IllegalArgumentException with an explicit message if the given {@link LocalTime} is null
+   */
+  private static void assertLocalTimeParameterIsNotNull(LocalTime other) {
+	if (other == null) throw new IllegalArgumentException("The LocalTime to compare actual with should not be null");
+  }
+
+  /**
+   * Verifies that actual and given {@code LocalTime} have same hour, minute and second fields (nanosecond fields are
+   * ignored in comparison).
+   * <p>
+   * Assertion can fail with localTimes in same chronological nanosecond time window, e.g :
+   * <p>
+   * 23:00:<b>01.000000000</b> and 23:00:<b>00.999999999</b>.
+   * <p>
+   * Assertion fails as second fields differ even if time difference is only 1ns.
+   * <p>
+   * Code example :
+   * 
+   * <pre><code class='java'>
+   * // successfull assertions
+   * LocalTime localTime1 = LocalTime.of(12, 0, 1, 0);
+   * LocalTime localTime2 = LocalTime.of(12, 0, 1, 456);
+   * assertThat(localTime1).isEqualToIgnoringNanos(localTime2);
+   * 
+   * // failing assertions (even if time difference is only 1ns)
+   * LocalTime localTimeA = LocalTime.of(12, 0, 1, 0);
+   * LocalTime localTimeB = LocalTime.of(12, 0, 0, 999999999);
+   * assertThat(localTimeA).isEqualToIgnoringNanos(localTimeB);
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalTime} is are not equal with nanoseconds ignored.
+   */
+  public S isEqualToIgnoringNanos(LocalTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalTimeParameterIsNotNull(other);
+	if (!areEqualIgnoringNanos(actual, other)) {
+	  throw Failures.instance().failure(info, shouldBeEqualIgnoringNanos(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Verifies that actual and given {@link LocalTime} have same hour and minute fields (second and nanosecond fields are
+   * ignored in comparison).
+   * <p>
+   * Assertion can fail with LocalTimes in same chronological second time window, e.g :
+   * <p>
+   * 23:<b>01:00</b>.000 and 23:<b>00:59</b>.000.
+   * <p>
+   * Assertion fails as minute fields differ even if time difference is only 1s.
+   * <p>
+   * Code example :
+   * 
+   * <pre><code class='java'>
+   * // successful assertions
+   * LocalTime localTime1 = LocalTime.of(23, 50, 0, 0);
+   * LocalTime localTime2 = LocalTime.of(23, 50, 10, 456);
+   * assertThat(localTime1).isEqualToIgnoringSeconds(localTime2);
+   * 
+   * // failing assertions (even if time difference is only 1ms)
+   * LocalTime localTimeA = LocalTime.of(23, 50, 00, 000);
+   * LocalTime localTimeB = LocalTime.of(23, 49, 59, 999);
+   * assertThat(localTimeA).isEqualToIgnoringSeconds(localTimeB);
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalTime} is are not equal with second and nanosecond fields
+   *           ignored.
+   */
+  public S isEqualToIgnoringSeconds(LocalTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalTimeParameterIsNotNull(other);
+	if (!areEqualIgnoringSeconds(actual, other)) {
+	  throw Failures.instance().failure(info, shouldBeEqualIgnoringSeconds(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Verifies that actual and given {@code LocalTime} have same hour fields (minute, second and nanosecond fields are
+   * ignored in comparison).
+   * <p>
+   * Assertion can fail with localTimes in same chronological second time window, e.g :
+   * <p>
+   * <b>01:00</b>:00.000 and <b>00:59:59</b>.000.
+   * <p>
+   * Time difference is only 1s but hour fields differ.
+   * <p>
+   * Code example :
+   * 
+   * <pre><code class='java'>
+   * // successful assertions
+   * LocalTime localTime1 = LocalTime.of(23, 50, 0, 0);
+   * LocalTime localTime2 = LocalTime.of(23, 00, 2, 7);
+   * assertThat(localTime1).hasSameHourAs(localTime2);
+   * 
+   * // failing assertions (even if time difference is only 1ms)
+   * LocalTime localTimeA = LocalTime.of(01, 00, 00, 000);
+   * LocalTime localTimeB = LocalTime.of(00, 59, 59, 999);
+   * assertThat(localTimeA).hasSameHourAs(localTimeB);
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalTime}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalTime} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalTime} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalTime} is are not equal ignoring minute, second and nanosecond
+   *           fields.
+   */
+  public S hasSameHourAs(LocalTime other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalTimeParameterIsNotNull(other);
+	if (!haveSameHourField(actual, other)) {
+	  throw Failures.instance().failure(info, shouldHaveSameHourAs(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Returns true if both localtime are in the same year, month and day of month, hour, minute and second, false
+   * otherwise.
+   * 
+   * @param actual the actual localtime. expected not be null
+   * @param other the other localtime. expected not be null
+   * @return true if both localtime are in the same year, month and day of month, hour, minute and second, false
+   *         otherwise.
+   */
+  private static boolean areEqualIgnoringNanos(LocalTime actual, LocalTime other) {
+	return areEqualIgnoringSeconds(actual, other) && actual.getSecond() == other.getSecond();
+  }
+
+  /**
+   * Returns true if both localtime are in the same year, month, day of month, hour and minute, false otherwise.
+   * 
+   * @param actual the actual localtime. expected not be null
+   * @param other the other localtime. expected not be null
+   * @return true if both localtime are in the same year, month, day of month, hour and minute, false otherwise.
+   */
+  private static boolean areEqualIgnoringSeconds(LocalTime actual, LocalTime other) {
+	return haveSameHourField(actual, other) && actual.getMinute() == other.getMinute();
+  }
+
+  private static boolean haveSameHourField(LocalTime actual, LocalTime other) {
+	return actual.getHour() == other.getHour();
+  }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java b/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
index 7646be303..b967350f7 100644
--- a/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
+++ b/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
@@ -19,6 +19,7 @@ import java.io.InputStream;
 import java.math.BigDecimal;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.ZonedDateTime;
 import java.util.Date;
 import java.util.Iterator;
@@ -504,4 +505,14 @@ public abstract class AbstractSoftAssertions {
 	return proxy(ZonedDateTimeAssert.class, ZonedDateTime.class, actual);
   }
   
+  /**
+   * Creates a new instance of <code>{@link LocalTimeAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public LocalTimeAssert assertThat(LocalTime actual) {
+	return proxy(LocalTimeAssert.class, LocalTime.class, actual);
+  }
+  
 }
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 526e8ad2d..51b7caebb 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -19,6 +19,7 @@ import java.nio.charset.Charset;
 import java.text.DateFormat;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.ZonedDateTime;
 import java.util.Date;
 import java.util.Iterator;
@@ -563,6 +564,16 @@ public class Assertions {
     return new LocalDateTimeAssert(localDateTime);
   }
   
+  /**
+   * Creates a new instance of <code>{@link LocalTimeAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static AbstractLocalTimeAssert<?> assertThat(LocalTime actual) {
+	return new LocalTimeAssert(actual);
+  }
+  
   /**
    * Creates a new instance of <code>{@link LocalDateAssert}</code>.
    *
diff --git a/src/main/java/org/assertj/core/api/BDDAssertions.java b/src/main/java/org/assertj/core/api/BDDAssertions.java
index 9b30a778c..0e25af96e 100644
--- a/src/main/java/org/assertj/core/api/BDDAssertions.java
+++ b/src/main/java/org/assertj/core/api/BDDAssertions.java
@@ -17,6 +17,7 @@ import java.io.InputStream;
 import java.math.BigDecimal;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.ZonedDateTime;
 import java.util.Date;
 import java.util.Iterator;
@@ -522,6 +523,17 @@ public class BDDAssertions extends Assertions {
 	return assertThat(actual);
   }
 
+  /**
+   * Creates a new instance of <code>{@link LocalTimeAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static AbstractLocalTimeAssert<?> then(LocalTime actual) {
+	return assertThat(actual);
+  }
+  
+
   /**
    * Creates a new </code>{@link org.assertj.core.api.BDDAssertions}</code>.
    */
diff --git a/src/main/java/org/assertj/core/api/LocalTimeAssert.java b/src/main/java/org/assertj/core/api/LocalTimeAssert.java
new file mode 100644
index 000000000..a2917e8bb
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/LocalTimeAssert.java
@@ -0,0 +1,28 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import java.time.LocalTime;
+
+public class LocalTimeAssert extends AbstractLocalTimeAssert<LocalTimeAssert> {
+
+  /**
+   * Creates a new <code>{@link LocalTimeAssert}</code>.
+   *
+   * @param selfType the "self type"
+   * @param actual the actual value to verify
+   */
+  protected LocalTimeAssert(LocalTime actual) {
+    super(actual, LocalTimeAssert.class);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringNanos.java b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringNanos.java
index 568c2d3f2..dfbd871f8 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringNanos.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringNanos.java
@@ -15,11 +15,16 @@ package org.assertj.core.error;
 import org.assertj.core.error.BasicErrorMessageFactory;
 import org.assertj.core.error.ErrorMessageFactory;
 
+import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.ZonedDateTime;
 
 /**
- * Creates an error message indicating that an assertion that verifies that two {@link ZonedDateTime} have same year,
- * month, day, hour, minute and second failed.
+ * Creates an error message indicating that an assertion that verifies that :
+ * <ul>
+ * <li>two {@link ZonedDateTime}, {@link LocalDateTime} have same year, month, day, hour, minute and second failed.</li>
+ * <li>two {@link LocalTime} have hour, minute and second failed.</li>
+ * </ul>
  * 
  * @author Joel Costigliola
  */
@@ -33,11 +38,26 @@ public class ShouldBeEqualIgnoringNanos extends BasicErrorMessageFactory {
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ErrorMessageFactory shouldBeEqualIgnoringNanos(Object actual, Object other) {
-    return new ShouldBeEqualIgnoringNanos(actual, other);
+	return new ShouldBeEqualIgnoringNanos(actual, other);
+  }
+
+  /**
+   * Creates a new <code>{@link ShouldBeEqualIgnoringNanos}</code>.
+   * 
+   * @param actual the actual LocalTime in the failed assertion.
+   * @param other the LocalTime used in the failed assertion to compare the actual LocalTime to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeEqualIgnoringNanos(LocalTime actual, LocalTime other) {
+	return new ShouldBeEqualIgnoringNanos(actual, other);
   }
 
   private ShouldBeEqualIgnoringNanos(Object actual, Object other) {
-    super("\nExpecting:\n  <%s>\nto have same year, month, day, hour, minute and second as:\n  <%s>\nbut had not.",
-        actual, other);
+	super("\nExpecting:\n  <%s>\nto have same year, month, day, hour, minute and second as:\n  <%s>\nbut had not.",
+	      actual, other);
+  }
+
+  private ShouldBeEqualIgnoringNanos(LocalTime actual, LocalTime other) {
+	super("\nExpecting:\n  <%s>\nto have same hour, minute and second as:\n  <%s>\nbut had not.", actual, other);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringSeconds.java b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringSeconds.java
index 707d8a52f..9c89fb280 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringSeconds.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqualIgnoringSeconds.java
@@ -12,9 +12,7 @@
  */
 package org.assertj.core.error;
 
-import org.assertj.core.error.BasicErrorMessageFactory;
-import org.assertj.core.error.ErrorMessageFactory;
-
+import java.time.LocalTime;
 import java.time.ZonedDateTime;
 
 /**
@@ -33,11 +31,26 @@ public class ShouldBeEqualIgnoringSeconds extends BasicErrorMessageFactory {
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ErrorMessageFactory shouldBeEqualIgnoringSeconds(Object actual, Object other) {
-    return new ShouldBeEqualIgnoringSeconds(actual, other);
+	return new ShouldBeEqualIgnoringSeconds(actual, other);
   }
 
   private ShouldBeEqualIgnoringSeconds(Object actual, Object other) {
-    super("\nExpecting:\n  <%s>\nto have same year, month, day, hour and minute as:\n  <%s>\nbut had not.", actual,
-        other);
+	super("\nExpecting:\n  <%s>\nto have same year, month, day, hour and minute as:\n  <%s>\nbut had not.", actual,
+	      other);
+  }
+
+  /**
+   * Creates a new <code>{@link ShouldBeEqualIgnoringSeconds}</code>.
+   * 
+   * @param actual the actual LocalTime in the failed assertion.
+   * @param other the LocalTime used in the failed assertion to compare the actual LocalTime to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeEqualIgnoringSeconds(LocalTime actual, LocalTime other) {
+	return new ShouldBeEqualIgnoringSeconds(actual, other);
+  }
+
+  private ShouldBeEqualIgnoringSeconds(LocalTime actual, LocalTime other) {
+	super("\nExpecting:\n  <%s>\nto have same hour and minute as:\n  <%s>\nbut had not.", actual, other);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveSameHourAs.java b/src/main/java/org/assertj/core/error/ShouldHaveSameHourAs.java
new file mode 100644
index 000000000..e6b648e4b
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldHaveSameHourAs.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.error.BasicErrorMessageFactory;
+import org.assertj.core.error.ErrorMessageFactory;
+
+import java.time.LocalTime;
+import java.time.ZonedDateTime;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that two {@link ZonedDateTime} have same year,
+ * month, day and hour fields failed.
+ * 
+ * @author Joel Costigliola
+ */
+public class ShouldHaveSameHourAs extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link ShouldHaveSameHourAs}</code>.
+   * 
+   * @param actual the actual value in the failed assertion.
+   * @param other the value used in the failed assertion to compare the actual value to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldHaveSameHourAs(LocalTime actual, LocalTime other) {
+    return new ShouldHaveSameHourAs(actual, other);
+  }
+
+  private ShouldHaveSameHourAs(LocalTime actual, LocalTime other) {
+	super("\nExpecting:\n  <%s>\nto have same hour as:\n  <%s>\nbut had not.", actual, other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/BDDAssertions_then_Test.java b/src/test/java/org/assertj/core/api/BDDAssertions_then_Test.java
index b899498a1..22994e708 100644
--- a/src/test/java/org/assertj/core/api/BDDAssertions_then_Test.java
+++ b/src/test/java/org/assertj/core/api/BDDAssertions_then_Test.java
@@ -23,6 +23,7 @@ import static org.powermock.api.mockito.PowerMockito.verifyStatic;
 import java.math.BigDecimal;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.ZonedDateTime;
 import java.util.Arrays;
 import java.util.Date;
@@ -504,4 +505,15 @@ public class BDDAssertions_then_Test {
 	assertThat(actual);
   }
 
+  @Test
+  public void then_of_LocalTime_should_delegate_to_assertThat() {
+	// GIVEN
+	LocalTime actual = LocalTime.of(23, 59, 59);
+	// WHEN
+	then(actual);
+	// THEN
+	verifyStatic();
+	assertThat(actual);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index b4b57d1ee..98cef1ac1 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -22,6 +22,7 @@ import java.io.File;
 import java.math.BigDecimal;
 import java.time.LocalDate;
 import java.time.LocalDateTime;
+import java.time.LocalTime;
 import java.time.ZonedDateTime;
 import java.util.List;
 import java.util.Optional;
@@ -146,11 +147,12 @@ public class SoftAssertionsTest {
 	  softly.assertThat(LocalDateTime.of(2015, 1, 1, 23, 59, 59)).isEqualTo(LocalDateTime.of(2015, 1, 1, 23, 59, 0));
 	  softly.assertThat(ZonedDateTime.of(2015, 1, 1, 23, 59, 59, 0, UTC)).isEqualTo(ZonedDateTime.of(2015, 1, 1, 23,
 		                                                                                             59, 0, 0, UTC));
+	  softly.assertThat(LocalTime.of(23, 59, 59)).isEqualTo(LocalTime.of(23, 59, 0));
 	  softly.assertAll();
 	  fail("Should not reach here");
 	} catch (SoftAssertionError e) {
 	  List<String> errors = e.getErrors();
-	  assertThat(errors).hasSize(43);
+	  assertThat(errors).hasSize(44);
 	  assertThat(errors.get(0)).isEqualTo("expected:<[1]> but was:<[0]>");
 
 	  assertThat(errors.get(1)).isEqualTo("expected:<[tru]e> but was:<[fals]e>");
@@ -224,6 +226,7 @@ public class SoftAssertionsTest {
 	  assertThat(errors.get(40)).isEqualTo("expected:<2015-01-0[2]> but was:<2015-01-0[1]>");
 	  assertThat(errors.get(41)).isEqualTo("expected:<2015-01-01T23:59[]> but was:<2015-01-01T23:59[:59]>");
 	  assertThat(errors.get(42)).isEqualTo("expected:<2015-01-01T23:59[]Z> but was:<2015-01-01T23:59[:59]Z>");
+	  assertThat(errors.get(43)).isEqualTo("expected:<23:59[]> but was:<23:59[:59]>");
 	}
   }
 
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssertBaseTest.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssertBaseTest.java
new file mode 100644
index 000000000..a9ec00141
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssertBaseTest.java
@@ -0,0 +1,46 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.junit.Assume.assumeTrue;
+
+import java.time.LocalTime;
+
+import org.assertj.core.api.AbstractLocalTimeAssert;
+import org.assertj.core.api.BaseTest;
+import org.junit.experimental.theories.DataPoint;
+
+/**
+ * Base test class for {@link AbstractLocalTimeAssert} tests.
+ */
+public class LocalTimeAssertBaseTest extends BaseTest {
+
+  @DataPoint
+  public static LocalTime localTime1 = LocalTime.of(0, 0);
+  @DataPoint
+  public static LocalTime localTime2 = LocalTime.of(23, 59, 59, 999);
+  @DataPoint
+  public static LocalTime localTime3 = LocalTime.of(0, 0, 0, 1);
+  @DataPoint
+  public static LocalTime localTime4 = LocalTime.of(22, 15, 15, 875);
+  @DataPoint
+  public static LocalTime localTime5 = LocalTime.of(22, 15, 15, 874);
+  @DataPoint
+  public static LocalTime localTime6 = LocalTime.of(22, 15, 15, 876);
+
+  protected static void testAssumptions(LocalTime reference, LocalTime timeBefore, LocalTime timeAfter) {
+    assumeTrue(timeBefore.isBefore(reference));
+    assumeTrue(timeAfter.isAfter(reference));
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_hasSameHourAs_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_hasSameHourAs_Test.java
new file mode 100644
index 000000000..74e83507c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_hasSameHourAs_Test.java
@@ -0,0 +1,78 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.AbstractLocalTimeAssert.NULL_LOCAL_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalTime;
+
+import org.assertj.core.api.BaseTest;
+import org.junit.Test;
+
+public class LocalTimeAssert_hasSameHourAs_Test extends BaseTest {
+
+  private final LocalTime refLocalTime = LocalTime.of(23, 0, 0, 0);
+
+  @Test
+  public void should_pass_if_actual_andexpected_have_same_hour() {
+	assertThat(refLocalTime).hasSameHourAs(refLocalTime.plusMinutes(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_localtimetime_with_minute_ignored() {
+	try {
+	  assertThat(refLocalTime).hasSameHourAs(refLocalTime.minusMinutes(1));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <23:00>\n" +
+		                       "to have same hour as:\n" +
+		                       "  <22:59>\n" +
+		                       "but had not.");
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_minutes_fields_are_different_even_if_time_difference_is_less_than_a_minute() {
+	try {
+	  assertThat(refLocalTime).hasSameHourAs(refLocalTime.minusNanos(1));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <23:00>\n" +
+		                       "to have same hour as:\n" +
+		                       "  <22:59:59.999999999>\n" +
+		                       "but had not.");
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalTime actual = null;
+	assertThat(actual).hasSameHourAs(LocalTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_localtimetime_is_null() {
+	expectIllegalArgumentException(NULL_LOCAL_TIME_PARAMETER_MESSAGE);
+	assertThat(refLocalTime).hasSameHourAs(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isAfterOrEqualTo_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isAfterOrEqualTo_Test.java
new file mode 100644
index 000000000..3506e3a6a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isAfterOrEqualTo_Test.java
@@ -0,0 +1,97 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalTimeAssert_isAfterOrEqualTo_Test extends LocalTimeAssertBaseTest {
+
+  @Theory
+  public void test_isAfterOrEqual_assertion(LocalTime referenceTime, LocalTime timeBefore,
+	                                        LocalTime timeAfter) {
+	// GIVEN
+	testAssumptions(referenceTime, timeBefore, timeAfter);
+	// WHEN
+	assertThat(timeAfter).isAfterOrEqualTo(referenceTime);
+	assertThat(referenceTime).isAfterOrEqualTo(referenceTime);
+	// THEN
+	verify_that_isAfterOrEqual_assertion_fails_and_throws_AssertionError(timeBefore, referenceTime);
+  }
+
+  @Test
+  public void test_isAfterOrEqual_assertion_error_message() {
+	try {
+	  assertThat(LocalTime.of(3, 0, 5)).isAfterOrEqualTo(LocalTime.of(3, 3, 3));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <03:00:05>\n" +
+		                       "to be after or equals to:\n" +
+		                       "  <03:03:03>");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalTime actual = null;
+	assertThat(actual).isAfterOrEqualTo(LocalTime.now());
+  }
+
+  @Test
+  public void should_fail_if_timeTime_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isAfterOrEqualTo((LocalTime) null);
+  }
+
+  @Test
+  public void should_fail_if_timeTime_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isAfterOrEqualTo((String) null);
+  }
+
+  private static void verify_that_isAfterOrEqual_assertion_fails_and_throws_AssertionError(LocalTime timeToCheck,
+	                                                                                       LocalTime reference) {
+	try {
+	  assertThat(timeToCheck).isAfterOrEqualTo(reference);
+	} catch (AssertionError e) {
+	  // AssertionError was expected, test same assertion with String based parameter
+	  try {
+		assertThat(timeToCheck).isAfterOrEqualTo(reference.toString());
+	  } catch (AssertionError e2) {
+		// AssertionError was expected (again)
+		return;
+	  }
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isAfter_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isAfter_Test.java
new file mode 100644
index 000000000..641132e68
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isAfter_Test.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static java.time.LocalTime.parse;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+@RunWith(Theories.class)
+public class LocalTimeAssert_isAfter_Test extends LocalTimeAssertBaseTest {
+
+  @Theory
+  public void test_isAfter_assertion(LocalTime referenceTime, LocalTime timeBefore, LocalTime timeAfter) {
+	// GIVEN
+	testAssumptions(referenceTime, timeBefore, timeAfter);
+	// WHEN
+	assertThat(timeAfter).isAfter(referenceTime);
+	assertThat(timeAfter).isAfter(referenceTime.toString());
+	// THEN
+	verify_that_isAfter_assertion_fails_and_throws_AssertionError(referenceTime, referenceTime);
+	verify_that_isAfter_assertion_fails_and_throws_AssertionError(timeBefore, referenceTime);
+  }
+
+  @Test
+  public void test_isAfter_assertion_error_message() {
+	try {
+	  assertThat(parse("03:00:05.123")).isAfter(parse("03:00:05.123456789"));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <03:00:05.123>\n" +
+		                       "to be strictly after:\n" +
+		                       "  <03:00:05.123456789>");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalTime actual = null;
+	assertThat(actual).isAfter(LocalTime.now());
+  }
+
+  @Test
+  public void should_fail_if_timeTime_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isAfter((LocalTime) null);
+  }
+
+  @Test
+  public void should_fail_if_timeTime_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isAfter((String) null);
+  }
+
+  private static void verify_that_isAfter_assertion_fails_and_throws_AssertionError(LocalTime timeToCheck,
+	                                                                                LocalTime reference) {
+	try {
+	  assertThat(timeToCheck).isAfter(reference);
+	} catch (AssertionError e) {
+	  // AssertionError was expected, test same assertion with String based parameter
+	  try {
+		assertThat(timeToCheck).isAfter(reference.toString());
+	  } catch (AssertionError e2) {
+		// AssertionError was expected (again)
+		return;
+	  }
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isBeforeOrEqualTo_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isBeforeOrEqualTo_Test.java
new file mode 100644
index 000000000..4384fa1d4
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isBeforeOrEqualTo_Test.java
@@ -0,0 +1,97 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalTimeAssert_isBeforeOrEqualTo_Test extends LocalTimeAssertBaseTest {
+
+  @Theory
+  public void test_isBeforeOrEqual_assertion(LocalTime referenceTime, LocalTime timeBefore,
+	                                         LocalTime timeAfter) {
+	// GIVEN
+	testAssumptions(referenceTime, timeBefore, timeAfter);
+	// WHEN
+	assertThat(timeBefore).isBeforeOrEqualTo(referenceTime);
+	assertThat(referenceTime).isBeforeOrEqualTo(referenceTime);
+	// THEN
+	verify_that_isBeforeOrEqual_assertion_fails_and_throws_AssertionError(timeAfter, referenceTime);
+  }
+
+  @Test
+  public void test_isBeforeOrEqual_assertion_error_message() {
+	try {
+	  assertThat(LocalTime.of(3, 0, 5)).isBeforeOrEqualTo(LocalTime.of(3, 0, 4));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <03:00:05>\n" +
+		                       "to be before or equals to:\n" +
+		                       "  <03:00:04>");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalTime actual = null;
+	assertThat(actual).isBeforeOrEqualTo(LocalTime.now());
+  }
+
+  @Test
+  public void should_fail_if_timeTime_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isBeforeOrEqualTo((LocalTime) null);
+  }
+
+  @Test
+  public void should_fail_if_timeTime_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isBeforeOrEqualTo((String) null);
+  }
+
+  private static void verify_that_isBeforeOrEqual_assertion_fails_and_throws_AssertionError(LocalTime timeToCheck,
+	                                                                                        LocalTime reference) {
+	try {
+	  assertThat(timeToCheck).isBeforeOrEqualTo(reference);
+	} catch (AssertionError e) {
+	  // AssertionError was expected, test same assertion with String based parameter
+	  try {
+		assertThat(timeToCheck).isBeforeOrEqualTo(reference.toString());
+	  } catch (AssertionError e2) {
+		// AssertionError was expected (again)
+		return;
+	  }
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isBefore_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isBefore_Test.java
new file mode 100644
index 000000000..f8726ffd0
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isBefore_Test.java
@@ -0,0 +1,96 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalTimeAssert_isBefore_Test extends LocalTimeAssertBaseTest {
+
+  @Theory
+  public void test_isBefore_assertion(LocalTime referenceTime, LocalTime timeBefore, LocalTime timeAfter) {
+	// GIVEN
+	testAssumptions(referenceTime, timeBefore, timeAfter);
+	// WHEN
+	assertThat(timeBefore).isBefore(referenceTime);
+	// THEN
+	verify_that_isBefore_assertion_fails_and_throws_AssertionError(referenceTime, referenceTime);
+	verify_that_isBefore_assertion_fails_and_throws_AssertionError(timeAfter, referenceTime);
+  }
+
+  @Test
+  public void test_isBefore_assertion_error_message() {
+	try {
+	  assertThat(LocalTime.of(3, 0, 5)).isBefore(LocalTime.of(3, 0, 4));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <03:00:05>\n" +
+		                       "to be strictly before:\n" +
+		                       "  <03:00:04>");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalTime actual = null;
+	assertThat(actual).isBefore(LocalTime.now());
+  }
+
+  @Test
+  public void should_fail_if_timeTime_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isBefore((LocalTime) null);
+  }
+
+  @Test
+  public void should_fail_if_timeTime_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isBefore((String) null);
+  }
+
+  private static void verify_that_isBefore_assertion_fails_and_throws_AssertionError(LocalTime timeToTest,
+	                                                                                 LocalTime reference) {
+	try {
+	  assertThat(timeToTest).isBefore(reference);
+	} catch (AssertionError e) {
+	  // AssertionError was expected, test same assertion with String based parameter
+	  try {
+		assertThat(timeToTest).isBefore(reference.toString());
+	  } catch (AssertionError e2) {
+		// AssertionError was expected (again)
+		return;
+	  }
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualToIgnoringNanoseconds_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualToIgnoringNanoseconds_Test.java
new file mode 100644
index 000000000..ecb09517c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualToIgnoringNanoseconds_Test.java
@@ -0,0 +1,77 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.AbstractLocalTimeAssert.NULL_LOCAL_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalTime;
+
+import org.assertj.core.api.BaseTest;
+import org.junit.Test;
+
+public class LocalTimeAssert_isEqualToIgnoringNanoseconds_Test extends BaseTest {
+
+  private final LocalTime refLocalTime = LocalTime.of(0, 0, 1, 0);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_nanosecond_fields() {
+	assertThat(refLocalTime).isEqualToIgnoringNanos(refLocalTime.withNano(55));
+	assertThat(refLocalTime).isEqualToIgnoringNanos(refLocalTime.plusNanos(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_localtimetime_with_nanoseconds_ignored() {
+	try {
+	  assertThat(refLocalTime).isEqualToIgnoringNanos(refLocalTime.plusSeconds(1));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\nExpecting:\n  " +
+		                       "<00:00:01>\n" +
+		                       "to have same hour, minute and second as:\n" +
+		                       "  <00:00:02>\n" +
+		                       "but had not.");
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
+	try {
+	  assertThat(refLocalTime).isEqualToIgnoringNanos(refLocalTime.minusNanos(1));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\nExpecting:\n" +
+		                       "  <00:00:01>\n" +
+		                       "to have same hour, minute and second as:\n" +
+		                       "  <00:00:00.999999999>\n" +
+		                       "but had not.");
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalTime actual = null;
+	assertThat(actual).isEqualToIgnoringNanos(LocalTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_localtimetime_is_null() {
+	expectIllegalArgumentException(NULL_LOCAL_TIME_PARAMETER_MESSAGE);
+	assertThat(refLocalTime).isEqualToIgnoringNanos(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualToIgnoringSeconds_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualToIgnoringSeconds_Test.java
new file mode 100644
index 000000000..29b9ffe16
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualToIgnoringSeconds_Test.java
@@ -0,0 +1,76 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.AbstractLocalTimeAssert.NULL_LOCAL_TIME_PARAMETER_MESSAGE;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalTime;
+
+import org.assertj.core.api.BaseTest;
+import org.junit.Test;
+
+public class LocalTimeAssert_isEqualToIgnoringSeconds_Test extends BaseTest {
+
+  private final LocalTime refLocalTime = LocalTime.of(23, 51, 0, 0);
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_other_ignoring_second_fields() {
+	assertThat(refLocalTime).isEqualToIgnoringSeconds(refLocalTime.plusSeconds(1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_equal_to_given_localtimetime_with_second_ignored() {
+	try {
+	  assertThat(refLocalTime).isEqualToIgnoringSeconds(refLocalTime.plusMinutes(1));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\nExpecting:\n" +
+		                       "  <23:51>\n" +
+		                       "to have same hour and minute as:\n" +
+		                       "  <23:52>\n" +
+		                       "but had not.");
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
+	try {
+	  assertThat(refLocalTime).isEqualToIgnoringSeconds(refLocalTime.minusNanos(1));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\nExpecting:\n" +
+		                       "  <23:51>\n" +
+		                       "to have same hour and minute as:\n" +
+		                       "  <23:50:59.999999999>\n" +
+		                       "but had not.");
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalTime actual = null;
+	assertThat(actual).isEqualToIgnoringSeconds(LocalTime.now());
+  }
+
+  @Test
+  public void should_throw_error_if_given_localtimetime_is_null() {
+	expectIllegalArgumentException(NULL_LOCAL_TIME_PARAMETER_MESSAGE);
+	assertThat(refLocalTime).isEqualToIgnoringSeconds(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualTo_Test.java
new file mode 100644
index 000000000..193786e89
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isEqualTo_Test.java
@@ -0,0 +1,64 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+@RunWith(Theories.class)
+public class LocalTimeAssert_isEqualTo_Test extends LocalTimeAssertBaseTest {
+
+  @Theory
+  public void test_isEqualTo_assertion(LocalTime referenceTime) {
+    // WHEN
+    assertThat(referenceTime).isEqualTo(referenceTime.toString());
+    // THEN
+    verify_that_isEqualTo_assertion_fails_and_throws_AssertionError(referenceTime);
+  }
+
+  @Test
+  public void test_isEqualTo_assertion_error_message() {
+    try {
+      assertThat(LocalTime.of(3, 0, 5)).isEqualTo("03:03:03");
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("expected:<03:0[3:03]> but was:<03:0[0:05]>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_timeTime_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the LocalTime to compare actual with should not be null");
+    assertThat(LocalTime.now()).isEqualTo((String) null);
+  }
+
+  private static void verify_that_isEqualTo_assertion_fails_and_throws_AssertionError(LocalTime reference) {
+    try {
+      assertThat(reference).isEqualTo(reference.plusHours(1).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isIn_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isIn_Test.java
new file mode 100644
index 000000000..4d635f6ec
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isIn_Test.java
@@ -0,0 +1,79 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalTime} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalTimeAssert_isIn_Test extends LocalTimeAssertBaseTest {
+
+  @Theory
+  public void test_isIn_assertion(LocalTime referenceTime) {
+	// WHEN
+	assertThat(referenceTime).isIn(referenceTime.toString(), referenceTime.plusHours(1).toString());
+	// THEN
+	verify_that_isIn_assertion_fails_and_throws_AssertionError(referenceTime);
+  }
+
+  @Test
+  public void test_isIn_assertion_error_message() {
+	try {
+	  assertThat(LocalTime.of(3, 0, 5)).isIn("03:03:03");
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       " <03:00:05>\n" +
+		                       "to be in:\n" +
+		                       " <[03:03:03]>\n");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_timeTimes_as_string_array_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The given LocalTime array should not be null");
+	assertThat(LocalTime.now()).isIn((String[]) null);
+  }
+
+  @Test
+  public void should_fail_if_timeTimes_as_string_array_parameter_is_empty() {
+	expectException(IllegalArgumentException.class, "The given LocalTime array should not be empty");
+	assertThat(LocalTime.now()).isIn(new String[0]);
+  }
+
+  private static void verify_that_isIn_assertion_fails_and_throws_AssertionError(LocalTime reference) {
+	try {
+	  assertThat(reference).isIn(reference.plusHours(1).toString(), reference.plusHours(2).toString());
+	} catch (AssertionError e) {
+	  // AssertionError was expected
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isNotEqualTo_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isNotEqualTo_Test.java
new file mode 100644
index 000000000..d177ef934
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isNotEqualTo_Test.java
@@ -0,0 +1,74 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalTime} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalTimeAssert_isNotEqualTo_Test extends LocalTimeAssertBaseTest {
+
+  @Theory
+  public void test_isNotEqualTo_assertion(LocalTime referenceTime) {
+	// WHEN
+	assertThat(referenceTime).isNotEqualTo(referenceTime.plusHours(1).toString());
+	// THEN
+	verify_that_isNotEqualTo_assertion_fails_and_throws_AssertionError(referenceTime);
+  }
+
+  @Test
+  public void test_isNotEqualTo_assertion_error_message() {
+	try {
+	  assertThat(LocalTime.of(3, 0, 5)).isNotEqualTo("03:00:05");
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       " <03:00:05>\n" +
+		                       "not to be equal to:\n" +
+		                       " <03:00:05>\n");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_timeTime_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the LocalTime to compare actual with should not be null");
+	assertThat(LocalTime.now()).isNotEqualTo((String) null);
+  }
+
+  private static void verify_that_isNotEqualTo_assertion_fails_and_throws_AssertionError(LocalTime reference) {
+	try {
+	  assertThat(reference).isNotEqualTo(reference.toString());
+	} catch (AssertionError e) {
+	  // AssertionError was expected
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isNotIn_Test.java b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isNotIn_Test.java
new file mode 100644
index 000000000..4dcc094ef
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localtime/LocalTimeAssert_isNotIn_Test.java
@@ -0,0 +1,79 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localtime;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalTime;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalTime} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalTimeAssert_isNotIn_Test extends LocalTimeAssertBaseTest {
+
+  @Theory
+  public void test_isNotIn_assertion(LocalTime referenceTime) {
+	// WHEN
+	assertThat(referenceTime).isNotIn(referenceTime.plusHours(1).toString(), referenceTime.plusHours(2).toString());
+	// THEN
+	verify_that_isNotIn_assertion_fails_and_throws_AssertionError(referenceTime);
+  }
+
+  @Test
+  public void test_isNotIn_assertion_error_message() {
+	try {
+	  assertThat(LocalTime.of(3, 0, 5)).isNotIn("03:00:05", "03:03:03");
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       " <03:00:05>\n" +
+		                       "not to be in:\n" +
+		                       " <[03:00:05, 03:03:03]>\n");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_timeTimes_as_string_array_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The given LocalTime array should not be null");
+	assertThat(LocalTime.now()).isNotIn((String[]) null);
+  }
+
+  @Test
+  public void should_fail_if_timeTimes_as_string_array_parameter_is_empty() {
+	expectException(IllegalArgumentException.class, "The given LocalTime array should not be empty");
+	assertThat(LocalTime.now()).isNotIn(new String[0]);
+  }
+
+  private static void verify_that_isNotIn_assertion_fails_and_throws_AssertionError(LocalTime reference) {
+	try {
+	  assertThat(reference).isNotIn(reference.toString(), reference.plusHours(1).toString());
+	} catch (AssertionError e) {
+	  // AssertionError was expected
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
