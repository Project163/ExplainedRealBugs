diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index ac997cce1..a1227851b 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -14,9 +14,10 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.extractor.Extractors.*;
-import static org.assertj.core.util.Iterables.*;
-import static org.assertj.core.util.Lists.*;
+import static org.assertj.core.extractor.Extractors.byName;
+import static org.assertj.core.extractor.Extractors.resultOf;
+import static org.assertj.core.util.Iterables.toArray;
+import static org.assertj.core.util.Lists.newArrayList;
 
 import java.util.Collection;
 import java.util.Comparator;
@@ -31,6 +32,7 @@ import org.assertj.core.internal.ComparisonStrategy;
 import org.assertj.core.internal.FieldByFieldComparisonStrategy;
 import org.assertj.core.internal.IgnoringFieldsComparisonStrategy;
 import org.assertj.core.internal.Iterables;
+import org.assertj.core.internal.ObjectArrays;
 import org.assertj.core.internal.OnFieldsComparisonStrategy;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.introspection.IntrospectionError;
@@ -60,7 +62,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
   Iterables iterables = Iterables.instance();
 
   protected AbstractIterableAssert(A actual, Class<?> selfType) {
-    super(actual, selfType);
+	super(actual, selfType);
   }
 
   /**
@@ -68,7 +70,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public void isNullOrEmpty() {
-    iterables.assertNullOrEmpty(info, actual);
+	iterables.assertNullOrEmpty(info, actual);
   }
 
   /**
@@ -76,7 +78,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public void isEmpty() {
-    iterables.assertEmpty(info, actual);
+	iterables.assertEmpty(info, actual);
   }
 
   /**
@@ -84,8 +86,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S isNotEmpty() {
-    iterables.assertNotEmpty(info, actual);
-    return myself;
+	iterables.assertNotEmpty(info, actual);
+	return myself;
   }
 
   /**
@@ -93,16 +95,16 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S hasSize(int expected) {
-    iterables.assertHasSize(info, actual, expected);
-    return myself;
+	iterables.assertHasSize(info, actual, expected);
+	return myself;
   }
 
   /**
    * {@inheritDoc}
    */
   public S hasSameSizeAs(Object other) {
-    iterables.assertHasSameSizeAs(info, actual, other);
-    return myself;
+	iterables.assertHasSameSizeAs(info, actual, other);
+	return myself;
   }
 
   /**
@@ -110,8 +112,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S hasSameSizeAs(Iterable<?> other) {
-    iterables.assertHasSameSizeAs(info, actual, other);
-    return myself;
+	iterables.assertHasSameSizeAs(info, actual, other);
+	return myself;
   }
 
   /**
@@ -119,8 +121,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S contains(T... values) {
-    iterables.assertContains(info, actual, values);
-    return myself;
+	iterables.assertContains(info, actual, values);
+	return myself;
   }
 
   /**
@@ -128,8 +130,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S containsOnly(T... values) {
-    iterables.assertContainsOnly(info, actual, values);
-    return myself;
+	iterables.assertContainsOnly(info, actual, values);
+	return myself;
   }
 
   /**
@@ -137,8 +139,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S containsOnlyOnce(T... values) {
-    iterables.assertContainsOnlyOnce(info, actual, values);
-    return myself;
+	iterables.assertContainsOnlyOnce(info, actual, values);
+	return myself;
   }
 
   /**
@@ -146,8 +148,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S containsExactly(T... values) {
-    iterables.assertContainsExactly(info, actual, values);
-    return myself;
+	iterables.assertContainsExactly(info, actual, values);
+	return myself;
   }
 
   /**
@@ -160,8 +162,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @throws AssertionError if the actual {@code Iterable} is not subset of set {@code Iterable}.
    */
   public S isSubsetOf(Iterable<? extends T> values) {
-    iterables.assertIsSubsetOf(info, actual, values);
-    return myself;
+	iterables.assertIsSubsetOf(info, actual, values);
+	return myself;
   }
 
   /**
@@ -169,8 +171,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S containsSequence(T... sequence) {
-    iterables.assertContainsSequence(info, actual, sequence);
-    return myself;
+	iterables.assertContainsSequence(info, actual, sequence);
+	return myself;
   }
 
   /**
@@ -178,14 +180,14 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S containsSubsequence(T... sequence) {
-    iterables.assertContainsSubsequence(info, actual, sequence);
-    return myself;
+	iterables.assertContainsSubsequence(info, actual, sequence);
+	return myself;
   }
 
   @Override
   public S doesNotContain(T... values) {
-    iterables.assertDoesNotContain(info, actual, values);
-    return myself;
+	iterables.assertDoesNotContain(info, actual, values);
+	return myself;
   }
 
   /**
@@ -212,8 +214,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @throws AssertionError if the actual group contains some elements of the given {@link Iterable}.
    */
   public S doesNotContainAnyElementsOf(Iterable<? extends T> iterable) {
-    iterables.assertDoesNotContainAnyElementsOf(info, actual, iterable);
-    return myself;
+	iterables.assertDoesNotContainAnyElementsOf(info, actual, iterable);
+	return myself;
   }
 
   /**
@@ -221,8 +223,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S doesNotHaveDuplicates() {
-    iterables.assertDoesNotHaveDuplicates(info, actual);
-    return myself;
+	iterables.assertDoesNotHaveDuplicates(info, actual);
+	return myself;
   }
 
   /**
@@ -230,8 +232,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S startsWith(T... sequence) {
-    iterables.assertStartsWith(info, actual, sequence);
-    return myself;
+	iterables.assertStartsWith(info, actual, sequence);
+	return myself;
   }
 
   /**
@@ -239,8 +241,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S endsWith(T... sequence) {
-    iterables.assertEndsWith(info, actual, sequence);
-    return myself;
+	iterables.assertEndsWith(info, actual, sequence);
+	return myself;
   }
 
   /**
@@ -248,8 +250,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S containsNull() {
-    iterables.assertContainsNull(info, actual);
-    return myself;
+	iterables.assertContainsNull(info, actual);
+	return myself;
   }
 
   /**
@@ -257,8 +259,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S doesNotContainNull() {
-    iterables.assertDoesNotContainNull(info, actual);
-    return myself;
+	iterables.assertDoesNotContainNull(info, actual);
+	return myself;
   }
 
   /**
@@ -266,8 +268,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S are(Condition<? super T> condition) {
-    iterables.assertAre(info, actual, condition);
-    return myself;
+	iterables.assertAre(info, actual, condition);
+	return myself;
   }
 
   /**
@@ -275,8 +277,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S areNot(Condition<? super T> condition) {
-    iterables.assertAreNot(info, actual, condition);
-    return myself;
+	iterables.assertAreNot(info, actual, condition);
+	return myself;
   }
 
   /**
@@ -284,8 +286,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S have(Condition<? super T> condition) {
-    iterables.assertHave(info, actual, condition);
-    return myself;
+	iterables.assertHave(info, actual, condition);
+	return myself;
   }
 
   /**
@@ -293,8 +295,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S doNotHave(Condition<? super T> condition) {
-    iterables.assertDoNotHave(info, actual, condition);
-    return myself;
+	iterables.assertDoNotHave(info, actual, condition);
+	return myself;
   }
 
   /**
@@ -302,8 +304,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S areAtLeast(int times, Condition<? super T> condition) {
-    iterables.assertAreAtLeast(info, actual, times, condition);
-    return myself;
+	iterables.assertAreAtLeast(info, actual, times, condition);
+	return myself;
   }
 
   /**
@@ -311,8 +313,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S areAtMost(int times, Condition<? super T> condition) {
-    iterables.assertAreAtMost(info, actual, times, condition);
-    return myself;
+	iterables.assertAreAtMost(info, actual, times, condition);
+	return myself;
   }
 
   /**
@@ -320,14 +322,14 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S areExactly(int times, Condition<? super T> condition) {
-    iterables.assertAreExactly(info, actual, times, condition);
-    return myself;
+	iterables.assertAreExactly(info, actual, times, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S haveAtLeastOne(Condition<? super T> condition) {
-    return haveAtLeast(1, condition);
+	return haveAtLeast(1, condition);
   }
 
   /**
@@ -335,8 +337,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S haveAtLeast(int times, Condition<? super T> condition) {
-    iterables.assertHaveAtLeast(info, actual, times, condition);
-    return myself;
+	iterables.assertHaveAtLeast(info, actual, times, condition);
+	return myself;
   }
 
   /**
@@ -344,8 +346,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S haveAtMost(int times, Condition<? super T> condition) {
-    iterables.assertHaveAtMost(info, actual, times, condition);
-    return myself;
+	iterables.assertHaveAtMost(info, actual, times, condition);
+	return myself;
   }
 
   /**
@@ -353,8 +355,72 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S haveExactly(int times, Condition<? super T> condition) {
-    iterables.assertHaveExactly(info, actual, times, condition);
-    return myself;
+	iterables.assertHaveExactly(info, actual, times, condition);
+	return myself;
+  }
+
+  /**
+   * Verifies that at least one element in the actual {@code Iterable} belong to the specified type (matching includes
+   * subclasses of the given type).
+   * <p/>
+   * Example:
+   * 
+   * <pre>
+   * List&lt;Number&gt; numbers = new ArrayList&lt;Number&gt;();
+   * numbers.add(1);
+   * numbers.add(2L);
+   * 
+   * // successful assertion:
+   * assertThat(numbers).hasAtLeastOneElementOfType(Long.class);
+   * 
+   * // assertion failure:
+   * assertThat(numbers).hasAtLeastOneElementOfType(Float.class);
+   * </pre>
+   *
+   * @param expectedType the expected type.
+   * @return this assertion object.
+   * @throws NullPointerException if the given type is {@code null}.
+   * @throws AssertionError if the actual {@code Object} group does not have any elements of the given type.
+   */
+  @Override
+  public S hasAtLeastOneElementOfType(Class<?> type) {
+	// reuse code from object arrays as the logic is the same
+	// (ok since this assertion don't rely on comparison strategy)
+	ObjectArrays.instance().assertHasAtLeastOneElementOfType(info, toArray(actual), type);
+	return myself;
+  }
+
+  /**
+   * Verifies that all the elements in the actual {@code Iterable} belong to the specified type (matching includes
+   * subclasses of the given type).
+   * <p/>
+   * Example:
+   * 
+   * <pre>
+   * List&lt;Number&gt; numbers = new ArrayList&lt;Number&gt;();
+   * numbers.add(1);
+   * numbers.add(2);
+   * numbers.add(3);
+   * 
+   * // successful assertion:
+   * assertThat(numbers).hasOnlyElementsOfType(Number.class);
+   * assertThat(numbers).hasOnlyElementsOfType(Integer.class);
+   * 
+   * // assertion failure:
+   * assertThat(numbers).hasOnlyElementsOfType(Long.class);
+   * </pre>
+   *
+   * @param expectedType the expected type.
+   * @return this assertion object.
+   * @throws NullPointerException if the given type is {@code null}.
+   * @throws AssertionError if one element is not of the expected type.
+   */
+  @Override
+  public S hasOnlyElementsOfType(Class<?> type) {
+	// reuse code from object arrays as the logic is the same
+	// (ok since this assertion don't rely on comparison strategy)
+	ObjectArrays.instance().assertHasOnlyElementsOfType(info, toArray(actual), type);
+	return myself;
   }
 
   /**
@@ -362,8 +428,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S containsAll(Iterable<? extends T> iterable) {
-    iterables.assertContainsAll(info, actual, iterable);
-    return myself;
+	iterables.assertContainsAll(info, actual, iterable);
+	return myself;
   }
 
   /**
@@ -371,8 +437,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S usingElementComparator(Comparator<? super T> customComparator) {
-    this.iterables = new Iterables(new ComparatorBasedComparisonStrategy(customComparator));
-    return myself;
+	this.iterables = new Iterables(new ComparatorBasedComparisonStrategy(customComparator));
+	return myself;
   }
 
   /**
@@ -380,8 +446,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S usingDefaultElementComparator() {
-    this.iterables = Iterables.instance();
-    return myself;
+	this.iterables = Iterables.instance();
+	return myself;
   }
 
   /**
@@ -437,8 +503,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *           in one of the initial Iterable's element.
    */
   public ListAssert<Object> extracting(String propertyOrField) {
-    List<Object> values = FieldsOrPropertiesExtractor.extract(actual, byName(propertyOrField));
-    return new ListAssert<Object>(values);
+	List<Object> values = FieldsOrPropertiesExtractor.extract(actual, byName(propertyOrField));
+	return new ListAssert<Object>(values);
   }
 
   /**
@@ -465,7 +531,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * // let's verify the words of great houses in Westeros:
    * 
    * assertThat(greatHouses).extractingResultOf(&quot;sayTheWords&quot;)
-   *     .contains(&quot;Winter is Comming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;).doesNotContain(&quot;Lannisters always pay their debts&quot;);
+   *                        .contains(&quot;Winter is Comming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;)
+   *                        .doesNotContain(&quot;Lannisters always pay their debts&quot;);
    * </pre>
    * 
    * Following requirements have to be met to extract method results:
@@ -484,8 +551,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *           return void, or method accepts arguments.
    */
   public ListAssert<Object> extractingResultOf(String method) {
-    List<Object> values = FieldsOrPropertiesExtractor.extract(actual, resultOf(method));
-    return new ListAssert<Object>(values);
+	List<Object> values = FieldsOrPropertiesExtractor.extract(actual, resultOf(method));
+	return new ListAssert<Object>(values);
   }
 
   /**
@@ -511,7 +578,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * // let's verify the words of great houses in Westeros:
    * 
    * assertThat(greatHouses).extractingResultOf(&quot;sayTheWords&quot;, String.class)
-   *     .contains(&quot;Winter is Comming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;).doesNotContain(&quot;Lannisters always pay their debts&quot;);
+   *                        .contains(&quot;Winter is Comming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;)
+   *                        .doesNotContain(&quot;Lannisters always pay their debts&quot;);
    * </pre>
    * 
    * Following requirements have to be met to extract method results:
@@ -532,9 +600,9 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *           return void or method accepts arguments.
    */
   public <P> ListAssert<P> extractingResultOf(String method, Class<P> extractedType) {
-    @SuppressWarnings("unchecked")
-    List<P> values = (List<P>) FieldsOrPropertiesExtractor.extract(actual, resultOf(method));
-    return new ListAssert<P>(values);
+	@SuppressWarnings("unchecked")
+	List<P> values = (List<P>) FieldsOrPropertiesExtractor.extract(actual, resultOf(method));
+	return new ListAssert<P>(values);
   }
 
   /**
@@ -590,9 +658,9 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *           in one of the initial Iterable's element.
    */
   public <P> ListAssert<P> extracting(String propertyOrField, Class<P> extractingType) {
-    @SuppressWarnings("unchecked")
-    List<P> values = (List<P>) FieldsOrPropertiesExtractor.extract(actual, byName(propertyOrField));
-    return new ListAssert<P>(values);
+	@SuppressWarnings("unchecked")
+	List<P> values = (List<P>) FieldsOrPropertiesExtractor.extract(actual, byName(propertyOrField));
+	return new ListAssert<P>(values);
   }
 
   /**
@@ -655,7 +723,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *           public) in one of the initial Iterable's element.
    */
   public ListAssert<Tuple> extracting(String... propertiesOrFields) {
-    return extracting(byName(propertiesOrFields));
+	return extracting(byName(propertiesOrFields));
   }
 
   /**
@@ -703,8 +771,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return a new assertion object whose object under test is the list of values extracted
    */
   public <V> ListAssert<V> extracting(Extractor<? super T, V> extractor) {
-    List<V> values = FieldsOrPropertiesExtractor.extract(actual, extractor);
-    return new ListAssert<V>(values);
+	List<V> values = FieldsOrPropertiesExtractor.extract(actual, extractor);
+	return new ListAssert<V>(values);
   }
 
   /**
@@ -748,20 +816,20 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return a new assertion object whose object under test is the list of values extracted
    */
   public <V> ListAssert<V> flatExtracting(Extractor<? super T, ? extends Collection<V>> extractor) {
-    List<V> result = newArrayList();
-    final List<? extends Collection<V>> extractedValues = FieldsOrPropertiesExtractor.extract(actual, extractor);
+	List<V> result = newArrayList();
+	final List<? extends Collection<V>> extractedValues = FieldsOrPropertiesExtractor.extract(actual, extractor);
 
-    for (Collection<? extends V> iterable : extractedValues) {
-      result.addAll(iterable);
-    }
+	for (Collection<? extends V> iterable : extractedValues) {
+	  result.addAll(iterable);
+	}
 
-    return new ListAssert<V>(result);
+	return new ListAssert<V>(result);
   }
 
   /**
-   * Same as {@link #containsExactly(Object[])} but handle the {@link Iterable} to array conversion.
-   * Same semantic as {@link #containsExactly(Object...)} : verifies that actual contains all the elements of the given
-   * iterable and nothing else <b>in the same order</b>.
+   * Same as {@link #containsExactly(Object[])} but handle the {@link Iterable} to array conversion. Same semantic as
+   * {@link #containsExactly(Object...)} : verifies that actual contains all the elements of the given iterable and
+   * nothing else <b>in the same order</b>.
    * <p/>
    * Example :
    * 
@@ -778,7 +846,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @param iterable the given {@code Iterable} we will get elements from.
    */
   public S containsExactlyElementsOf(Iterable<? extends T> iterable) {
-    return containsExactly(toArray(iterable));
+	return containsExactly(toArray(iterable));
   }
 
   /**
@@ -801,7 +869,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @param iterable the given {@code Iterable} we will get elements from.
    */
   public S containsOnlyElementsOf(Iterable<? extends T> iterable) {
-      return containsOnly(toArray(iterable));
+	return containsOnly(toArray(iterable));
   }
 
   /**
@@ -831,16 +899,14 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *           {@code Iterable}
    */
   public S hasSameElementsAs(Iterable<? extends T> iterable) {
-    return containsOnly(toArray(iterable));
+	return containsOnly(toArray(iterable));
   }
 
   /**
-   * Use field by field comparison (including inherited fields) instead of relying
-   * on actual type A <code>equals</code> method to compare group elements
-   * for incoming assertion checks.
+   * Use field by field comparison (including inherited fields) instead of relying on actual type A <code>equals</code>
+   * method to compare group elements for incoming assertion checks.
    *
-   * This can be handy if <code>equals</code> implementation of objects to compare does not suit you.
-   * </p>
+   * This can be handy if <code>equals</code> implementation of objects to compare does not suit you. </p>
    * <p>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
    * (e.g. public) or fields with an accessible getter.
@@ -848,13 +914,13 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *
    * <pre>
    * Example:
-   *
+   * 
    * TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
    * TolkienCharacter frodoClone = new TolkienCharacter("Frodo", 33, HOBBIT);
-   *
+   * 
    * // Fail if equals has not been overriden in TolkienCharacter as equals default implementation only compares references
    * assertThat(newArrayList(frodo)).contains(frodoClone);
-   *
+   * 
    * // frodo and frodoClone are equals when doing a field by field comparison.
    * assertThat(newArrayList(frodo)).usingFieldByFieldElementComparator().contains(frodoClone);
    *
@@ -863,7 +929,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return {@code this} assertion object.
    */
   public S usingFieldByFieldElementComparator() {
-    return usingComparisonStrategy(new FieldByFieldComparisonStrategy());
+	return usingComparisonStrategy(new FieldByFieldComparisonStrategy());
   }
 
   /**
@@ -893,12 +959,12 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return {@code this} assertion object.
    */
   public S usingElementComparatorOnFields(String... fields) {
-    return usingComparisonStrategy(new OnFieldsComparisonStrategy(fields));
+	return usingComparisonStrategy(new OnFieldsComparisonStrategy(fields));
   }
 
   protected S usingComparisonStrategy(ComparisonStrategy comparisonStrategy) {
-    iterables = new Iterables(comparisonStrategy);
-    return myself;
+	iterables = new Iterables(comparisonStrategy);
+	return myself;
   }
 
   /**
@@ -929,7 +995,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return {@code this} assertion object.
    */
   public S usingElementComparatorIgnoringFields(String... fields) {
-    return usingComparisonStrategy(new IgnoringFieldsComparisonStrategy(fields));
+	return usingComparisonStrategy(new IgnoringFieldsComparisonStrategy(fields));
   }
 
   /**
@@ -973,7 +1039,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S inHexadecimal() {
-    return super.inHexadecimal();
+	return super.inHexadecimal();
   }
 
   /**
@@ -1015,6 +1081,6 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S inBinary() {
-    return super.inBinary();
+	return super.inBinary();
   }
 }
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 348189e0f..dd56dd4ea 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -56,7 +56,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
   ObjectArrays arrays = ObjectArrays.instance();
 
   protected AbstractObjectArrayAssert(T[] actual, Class<?> selfType) {
-    super(actual, selfType);
+	super(actual, selfType);
   }
 
   /**
@@ -66,7 +66,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    */
   @Override
   public void isNullOrEmpty() {
-    arrays.assertNullOrEmpty(info, actual);
+	arrays.assertNullOrEmpty(info, actual);
   }
 
   /**
@@ -76,7 +76,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    */
   @Override
   public void isEmpty() {
-    arrays.assertEmpty(info, actual);
+	arrays.assertEmpty(info, actual);
   }
 
   /**
@@ -86,8 +86,8 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    */
   @Override
   public S isNotEmpty() {
-    arrays.assertNotEmpty(info, actual);
-    return myself;
+	arrays.assertNotEmpty(info, actual);
+	return myself;
   }
 
   /**
@@ -97,8 +97,8 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    */
   @Override
   public S hasSize(int expected) {
-    arrays.assertHasSize(info, actual, expected);
-    return myself;
+	arrays.assertHasSize(info, actual, expected);
+	return myself;
   }
 
   /**
@@ -106,223 +106,237 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    */
   @Override
   public S hasSameSizeAs(Object other) {
-    // TODO same implementation as in AbstractArrayAssert, but can't inherit from it due to generics problem ...
-    arrays.assertHasSameSizeAs(info, actual, other);
-    return myself;
+	// TODO same implementation as in AbstractArrayAssert, but can't inherit from it due to generics problem ...
+	arrays.assertHasSameSizeAs(info, actual, other);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S hasSameSizeAs(Iterable<?> other) {
-    arrays.assertHasSameSizeAs(info, actual, other);
-    return myself;
+	arrays.assertHasSameSizeAs(info, actual, other);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S contains(T... values) {
-    arrays.assertContains(info, actual, values);
-    return myself;
+	arrays.assertContains(info, actual, values);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S containsOnly(T... values) {
-    arrays.assertContainsOnly(info, actual, values);
-    return myself;
+	arrays.assertContainsOnly(info, actual, values);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S containsOnlyOnce(T... values) {
-    arrays.assertContainsOnlyOnce(info, actual, values);
-    return myself;
+	arrays.assertContainsOnlyOnce(info, actual, values);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S containsExactly(T... values) {
-    objects.assertEqual(info, actual, values);
-    return myself;
+	objects.assertEqual(info, actual, values);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S containsSequence(T... sequence) {
-    arrays.assertContainsSequence(info, actual, sequence);
-    return myself;
+	arrays.assertContainsSequence(info, actual, sequence);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S containsSubsequence(T... subsequence) {
-    arrays.assertContainsSubsequence(info, actual, subsequence);
-    return myself;
+	arrays.assertContainsSubsequence(info, actual, subsequence);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S contains(T value, Index index) {
-    arrays.assertContains(info, actual, value, index);
-    return myself;
+	arrays.assertContains(info, actual, value, index);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S doesNotContain(T value, Index index) {
-    arrays.assertDoesNotContain(info, actual, value, index);
-    return myself;
+	arrays.assertDoesNotContain(info, actual, value, index);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S doesNotContain(T... values) {
-    arrays.assertDoesNotContain(info, actual, values);
-    return myself;
+	arrays.assertDoesNotContain(info, actual, values);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S doesNotHaveDuplicates() {
-    arrays.assertDoesNotHaveDuplicates(info, actual);
-    return myself;
+	arrays.assertDoesNotHaveDuplicates(info, actual);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S startsWith(T... sequence) {
-    arrays.assertStartsWith(info, actual, sequence);
-    return myself;
+	arrays.assertStartsWith(info, actual, sequence);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S endsWith(T... sequence) {
-    arrays.assertEndsWith(info, actual, sequence);
-    return myself;
+	arrays.assertEndsWith(info, actual, sequence);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S containsNull() {
-    arrays.assertContainsNull(info, actual);
-    return myself;
+	arrays.assertContainsNull(info, actual);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S doesNotContainNull() {
-    arrays.assertDoesNotContainNull(info, actual);
-    return myself;
+	arrays.assertDoesNotContainNull(info, actual);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S are(Condition<? super T> condition) {
-    arrays.assertAre(info, actual, condition);
-    return myself;
+	arrays.assertAre(info, actual, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S areNot(Condition<? super T> condition) {
-    arrays.assertAreNot(info, actual, condition);
-    return myself;
+	arrays.assertAreNot(info, actual, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S have(Condition<? super T> condition) {
-    arrays.assertHave(info, actual, condition);
-    return myself;
+	arrays.assertHave(info, actual, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S doNotHave(Condition<? super T> condition) {
-    arrays.assertDoNotHave(info, actual, condition);
-    return myself;
+	arrays.assertDoNotHave(info, actual, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S areAtLeast(int times, Condition<? super T> condition) {
-    arrays.assertAreAtLeast(info, actual, times, condition);
-    return myself;
+	arrays.assertAreAtLeast(info, actual, times, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S areAtMost(int times, Condition<? super T> condition) {
-    arrays.assertAreAtMost(info, actual, times, condition);
-    return myself;
+	arrays.assertAreAtMost(info, actual, times, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S areExactly(int times, Condition<? super T> condition) {
-    arrays.assertAreExactly(info, actual, times, condition);
-    return myself;
+	arrays.assertAreExactly(info, actual, times, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S haveAtLeastOne(Condition<? super T> condition) {
-    return haveAtLeast(1, condition);
+	return haveAtLeast(1, condition);
   }
 
   /** {@inheritDoc} */
   @Override
   public S haveAtLeast(int times, Condition<? super T> condition) {
-    arrays.assertHaveAtLeast(info, actual, times, condition);
-    return myself;
+	arrays.assertHaveAtLeast(info, actual, times, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S haveAtMost(int times, Condition<? super T> condition) {
-    arrays.assertHaveAtMost(info, actual, times, condition);
-    return myself;
+	arrays.assertHaveAtMost(info, actual, times, condition);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S haveExactly(int times, Condition<? super T> condition) {
-    arrays.assertHaveExactly(info, actual, times, condition);
-    return myself;
+	arrays.assertHaveExactly(info, actual, times, condition);
+	return myself;
   }
 
+  /** {@inheritDoc} */
+  @Override
+  public S hasAtLeastOneElementOfType(Class<?> type) {
+	arrays.assertHasAtLeastOneElementOfType(info, actual, type);
+	return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S hasOnlyElementsOfType(Class<?> type) {
+	arrays.assertHasOnlyElementsOfType(info, actual, type);
+	return myself;
+  }
+  
   /** {@inheritDoc} */
   @Override
   public S isSorted() {
-    arrays.assertIsSorted(info, actual);
-    return myself;
+	arrays.assertIsSorted(info, actual);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isSortedAccordingTo(Comparator<? super T> comparator) {
-    arrays.assertIsSortedAccordingToComparator(info, actual, comparator);
-    return myself;
+	arrays.assertIsSortedAccordingToComparator(info, actual, comparator);
+	return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S containsAll(Iterable<? extends T> iterable) {
-    arrays.assertContainsAll(info, actual, iterable);
-    return myself;
+	arrays.assertContainsAll(info, actual, iterable);
+	return myself;
   }
 
   @Override
   public S usingElementComparator(Comparator<? super T> customComparator) {
-    this.arrays = new ObjectArrays(new ComparatorBasedComparisonStrategy(customComparator));
-    return myself;
+	this.arrays = new ObjectArrays(new ComparatorBasedComparisonStrategy(customComparator));
+	return myself;
   }
 
   @Override
   public S usingDefaultElementComparator() {
-    this.arrays = ObjectArrays.instance();
-    return myself;
+	this.arrays = ObjectArrays.instance();
+	return myself;
   }
 
   /**
@@ -374,8 +388,8 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * @throws IntrospectionError if no field or property exists with the given name (or field exists but is not public)
    */
   public ObjectArrayAssert<Object> extracting(String fieldOrProperty) {
-    Object[] values = FieldsOrPropertiesExtractor.extract(actual, byName(fieldOrProperty));
-    return new ObjectArrayAssert<Object>(values);
+	Object[] values = FieldsOrPropertiesExtractor.extract(actual, byName(fieldOrProperty));
+	return new ObjectArrayAssert<Object>(values);
   }
 
   /**
@@ -428,9 +442,9 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * @throws IntrospectionError if no field or property exists with the given name (or field exists but is not public)
    */
   public <P> ObjectArrayAssert<P> extracting(String fieldOrProperty, Class<P> extractingType) {
-    @SuppressWarnings("unchecked")
-    P[] values = (P[]) FieldsOrPropertiesExtractor.extract(actual, byName(fieldOrProperty));
-    return new ObjectArrayAssert<P>(values);
+	@SuppressWarnings("unchecked")
+	P[] values = (P[]) FieldsOrPropertiesExtractor.extract(actual, byName(fieldOrProperty));
+	return new ObjectArrayAssert<P>(values);
   }
 
   /**
@@ -492,10 +506,10 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *           public) in one of the initial Iterable's element.
    */
   public ObjectArrayAssert<Tuple> extracting(String... propertiesOrFields) {
-    Object[] values = FieldsOrPropertiesExtractor.extract(actual, byName(propertiesOrFields));
-    Tuple[] result = Arrays.copyOf(values, values.length, Tuple[].class);
+	Object[] values = FieldsOrPropertiesExtractor.extract(actual, byName(propertiesOrFields));
+	Tuple[] result = Arrays.copyOf(values, values.length, Tuple[].class);
 
-    return new ObjectArrayAssert<Tuple>(result);
+	return new ObjectArrayAssert<Tuple>(result);
   }
 
   /**
@@ -541,20 +555,20 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * @return a new assertion object whose object under test is the list of values extracted
    */
   public <U> ObjectArrayAssert<U> extracting(Extractor<? super T, U> extractor) {
-    U[] extracted = FieldsOrPropertiesExtractor.extract(actual, extractor);
+	U[] extracted = FieldsOrPropertiesExtractor.extract(actual, extractor);
 
-    return new ObjectArrayAssert<U>(extracted);
+	return new ObjectArrayAssert<U>(extracted);
   }
 
   public <U, C extends Collection<U>> ObjectArrayAssert<U> flatExtracting(Extractor<? super T, C> extractor) {
-    final List<C> extractedValues = FieldsOrPropertiesExtractor.extract(Arrays.asList(actual), extractor);
+	final List<C> extractedValues = FieldsOrPropertiesExtractor.extract(Arrays.asList(actual), extractor);
 
-    final List<U> result = newArrayList();
-    for (C e : extractedValues) {
-      result.addAll(e);
-    }
+	final List<U> result = newArrayList();
+	for (C e : extractedValues) {
+	  result.addAll(e);
+	}
 
-    return new ObjectArrayAssert<U>(Iterables.toArray(result));
+	return new ObjectArrayAssert<U>(Iterables.toArray(result));
   }
 
   /**
@@ -579,7 +593,8 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * // let's verify the words of great houses in Westeros:
    * 
    * assertThat(greatHousesOfWesteros).extractingResultOf(&quot;sayTheWords&quot;)
-   *     .contains(&quot;Winter is Comming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;).doesNotContain(&quot;Lannisters always pay their debts&quot;);
+   *                                  .contains(&quot;Winter is Comming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;)
+   *                                  .doesNotContain(&quot;Lannisters always pay their debts&quot;);
    * </pre>
    * 
    * <p>
@@ -598,8 +613,8 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *           return void, or method accepts arguments.
    */
   public ObjectArrayAssert<Object> extractingResultOf(String method) {
-    Object[] values = FieldsOrPropertiesExtractor.extract(actual, resultOf(method));
-    return new ObjectArrayAssert<Object>(values);
+	Object[] values = FieldsOrPropertiesExtractor.extract(actual, resultOf(method));
+	return new ObjectArrayAssert<Object>(values);
   }
 
   /**
@@ -624,7 +639,8 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * // let's verify the words of great houses in Westeros:
    * 
    * assertThat(greatHousesOfWesteros).extractingResultOf(&quot;sayTheWords&quot;, String.class)
-   *     .contains(&quot;Winter is Comming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;).doesNotContain(&quot;Lannisters always pay their debts&quot;);
+   *                                  .contains(&quot;Winter is Comming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;)
+   *                                  .doesNotContain(&quot;Lannisters always pay their debts&quot;);
    * </pre>
    * 
    * <p>
@@ -644,9 +660,9 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *           return void, or method accepts arguments.
    */
   public <P> ObjectArrayAssert<P> extractingResultOf(String method, Class<P> extractingType) {
-    @SuppressWarnings("unchecked")
-    P[] values = (P[]) FieldsOrPropertiesExtractor.extract(actual, resultOf(method));
-    return new ObjectArrayAssert<P>(values);
+	@SuppressWarnings("unchecked")
+	P[] values = (P[]) FieldsOrPropertiesExtractor.extract(actual, resultOf(method));
+	return new ObjectArrayAssert<P>(values);
   }
 
   /**
@@ -687,12 +703,12 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    */
   @Override
   public S inHexadecimal() {
-    return super.inHexadecimal();
+	return super.inHexadecimal();
   }
 
   @Override
   public S inBinary() {
-    return super.inBinary();
+	return super.inBinary();
   }
 
 }
diff --git a/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java b/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
index 63da5e8ee..c99eff497 100644
--- a/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
+++ b/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
@@ -71,7 +71,8 @@ public interface ObjectEnumerableAssert<S extends ObjectEnumerableAssert<S, T>,
    * // assertions will fail
    * assertThat(newArrayList(&quot;Aria&quot;, &quot;Stark&quot;, &quot;daughter&quot;, &quot;of&quot;, &quot;Ned&quot;, &quot;Stark&quot;)).containsOnlyOnce(&quot;Stark&quot;);
    * assertThat(newArrayList(&quot;winter&quot;, &quot;is&quot;, &quot;coming&quot;)).containsOnlyOnce(&quot;Lannister&quot;);
-   * assertThat(newArrayList(&quot;Aria&quot;, &quot;Stark&quot;, &quot;daughter&quot;, &quot;of&quot;, &quot;Ned&quot;, &quot;Stark&quot;)).containsOnlyOnce(&quot;Stark&quot;, &quot;Lannister&quot;, &quot;Aria&quot;);
+   * assertThat(newArrayList(&quot;Aria&quot;, &quot;Stark&quot;, &quot;daughter&quot;, &quot;of&quot;, &quot;Ned&quot;, &quot;Stark&quot;)).containsOnlyOnce(&quot;Stark&quot;, &quot;Lannister&quot;,
+   *                                                                                              &quot;Aria&quot;);
    * </pre>
    * 
    * @param values the given values.
@@ -114,6 +115,7 @@ public interface ObjectEnumerableAssert<S extends ObjectEnumerableAssert<S, T>,
   /**
    * Verifies that the actual group contains the given sequence, without any other values between them.
    * <p>
+   * 
    * <pre>
    * Example:
    * Iterable&lt;Ring&gt; elvesRings = newArrayList(vilya, nenya, narya);
@@ -125,6 +127,7 @@ public interface ObjectEnumerableAssert<S extends ObjectEnumerableAssert<S, T>,
    * assertThat(elvesRings).containsSequence(vilya, narya);
    * assertThat(elvesRings).containsSequence(nenya, vilya);
    * </pre>
+   * 
    * </p>
    * 
    * @param sequence the sequence of objects to look for.
@@ -344,4 +347,50 @@ public interface ObjectEnumerableAssert<S extends ObjectEnumerableAssert<S, T>,
    * @throws AssertionError if the actual group does not contain all the elements of given {@code Iterable}.
    */
   S containsAll(Iterable<? extends T> iterable);
+
+  /**
+   * Verifies that at least one element in the actual {@code Object} group belong to the specified type (matching
+   * includes subclasses of the given type).
+   * <p/>
+   * Example:
+   * 
+   * <pre>
+   * Number[] numbers = { 2, 6L, 8.0 };
+   * 
+   * // successful assertion:
+   * assertThat(numbers).hasAtLeastOneElementOfType(Long.class);
+   * 
+   * // assertion failure:
+   * assertThat(numbers).hasAtLeastOneElementOfType(Float.class);
+   * </pre>
+   *
+   * @param expectedType the expected type.
+   * @return this assertion object.
+   * @throws NullPointerException if the given type is {@code null}.
+   * @throws AssertionError if the actual {@code Object} group does not have any elements of the given type.
+   */
+  S hasAtLeastOneElementOfType(Class<?> expectedType);
+
+  /**
+   * Verifies that all the elements in the actual {@code Object} group belong to the specified type (matching includes
+   * subclasses of the given type).
+   * <p/>
+   * Example:
+   * 
+   * <pre>
+   * Number[] numbers = { 2, 6, 8 };
+   * 
+   * // successful assertion:
+   * assertThat(numbers).hasOnlyElementsOfType(Integer.class);
+   * 
+   * // assertion failure:
+   * assertThat(numbers).hasOnlyElementsOfType(Long.class);
+   * </pre>
+   *
+   * @param expectedType the expected type.
+   * @return this assertion object.
+   * @throws NullPointerException if the given type is {@code null}.
+   * @throws AssertionError if one element is not of the expected type.
+   */
+  public S hasOnlyElementsOfType(Class<?> expectedType);
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveAtLeastOneElementOfType.java b/src/main/java/org/assertj/core/error/ShouldHaveAtLeastOneElementOfType.java
new file mode 100644
index 000000000..29ec5bd9d
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldHaveAtLeastOneElementOfType.java
@@ -0,0 +1,22 @@
+package org.assertj.core.error;
+
+
+/**
+ * Creates an error message indicating that a group does not have an element of the given type.
+ */
+public class ShouldHaveAtLeastOneElementOfType extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link ShouldHaveAtLeastOneElementOfType}</code>.
+   * @param actual array or Iterable
+   * @param expectedType the expected type of one element at least
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ShouldHaveAtLeastOneElementOfType shouldHaveAtLeastOneElementOfType(Object actual, Class<?> expectedType) {
+    return new ShouldHaveAtLeastOneElementOfType(actual, expectedType);
+  }
+
+  private ShouldHaveAtLeastOneElementOfType(Object actual, Class<?> expectedType) {
+    super("%nExpecting:%n  <%s>%nto have at least one element of type:%n  <%s>%nbut had none.", actual, expectedType);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveOnlyElementsOfType.java b/src/main/java/org/assertj/core/error/ShouldHaveOnlyElementsOfType.java
new file mode 100644
index 000000000..d6fd786d9
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldHaveOnlyElementsOfType.java
@@ -0,0 +1,23 @@
+package org.assertj.core.error;
+
+
+/**
+ * Creates an error message indicating that a group does not have an element of the given type.
+ */
+public class ShouldHaveOnlyElementsOfType extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link ShouldHaveOnlyElementsOfType}</code>.
+   * @param actual array or Iterable
+   * @param expectedType the expected type of all elements
+   * @param unexpectedType the type of one element that is not expectedType or it subclasses.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ShouldHaveOnlyElementsOfType shouldHaveOnlyElementsOfType(Object actual, Class<?> expectedType, Class<?> unexpectedType) {
+    return new ShouldHaveOnlyElementsOfType(actual, expectedType, unexpectedType);
+  }
+
+  private ShouldHaveOnlyElementsOfType(Object actual, Class<?> expectedType, Class<?> unexpectedType) {
+    super("%nExpecting:%n  <%s>%nto only have elements of type:%n  <%s>%nbut found:%n  <%s>", actual, expectedType, unexpectedType);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/ObjectArrays.java b/src/main/java/org/assertj/core/internal/ObjectArrays.java
index 7c9d3ac74..062b7f92a 100644
--- a/src/main/java/org/assertj/core/internal/ObjectArrays.java
+++ b/src/main/java/org/assertj/core/internal/ObjectArrays.java
@@ -14,6 +14,9 @@
  */
 package org.assertj.core.internal;
 
+import static org.assertj.core.error.ShouldHaveAtLeastOneElementOfType.shouldHaveAtLeastOneElementOfType;
+import static org.assertj.core.error.ShouldHaveOnlyElementsOfType.shouldHaveOnlyElementsOfType;
+
 import java.util.Comparator;
 
 import org.assertj.core.api.ArraySortedAssert;
@@ -455,6 +458,24 @@ public class ObjectArrays {
     arrays.assertHaveExactly(info, failures, conditions, actual, times, condition);
   }
 
+  public <E> void assertHasAtLeastOneElementOfType(AssertionInfo info, E[] actual, Class<?> type) {
+	Objects.instance().assertNotNull(info, actual);
+	boolean found = false;
+	for (Object o : actual) {
+	  if (!type.isInstance(o)) continue;
+	  found = true;
+	  break;
+	}
+	if (!found) throw failures.failure(info, shouldHaveAtLeastOneElementOfType(actual, type)); 
+  }
+  
+  public <E> void assertHasOnlyElementsOfType(AssertionInfo info, E[] actual, Class<?> type) {
+	Objects.instance().assertNotNull(info, actual);
+	for (Object o : actual) {
+	  if (!type.isInstance(o)) throw failures.failure(info, shouldHaveOnlyElementsOfType(actual, type, o.getClass()));
+	}
+  }
+  
   /**
    * Concrete implementation of {@link ArraySortedAssert#isSorted()}.
    * 
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasAtLeastOneElementOfType_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasAtLeastOneElementOfType_Test.java
new file mode 100644
index 000000000..45081dcfb
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasAtLeastOneElementOfType_Test.java
@@ -0,0 +1,26 @@
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.List;
+
+import org.assertj.core.internal.ObjectArrays;
+import org.junit.Test;
+
+/**
+ * Only make one test since assertion is delegated to {@link ObjectArrays} which has its own tests.
+ */
+public class IterableAssert_hasAtLeastOneElementOfType_Test {
+
+  @Test
+  public void should_pass_if_actual_has_one_element_of_the_expected_type() {
+	List<Object> list = newArrayList();
+	list.add("string");
+	list.add(1);
+	assertThat(list).hasAtLeastOneElementOfType(Integer.class)
+	                .hasAtLeastOneElementOfType(String.class)
+	                .hasAtLeastOneElementOfType(Object.class);
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasOnlyElementsOfType_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasOnlyElementsOfType_Test.java
new file mode 100644
index 000000000..b23653cf3
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasOnlyElementsOfType_Test.java
@@ -0,0 +1,22 @@
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.List;
+
+import org.assertj.core.internal.ObjectArrays;
+import org.junit.Test;
+
+/**
+ * Only make one test since assertion is delegated to {@link ObjectArrays} which has its own tests.
+ */
+public class IterableAssert_hasOnlyElementsOfType_Test {
+
+  @Test
+  public void should_pass_if_actual_has_one_element_of_the_expected_type() {
+	List<Integer> list = newArrayList(1, 2);
+	assertThat(list).hasOnlyElementsOfType(Number.class).hasOnlyElementsOfType(Integer.class);
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasAtLeastOneElementOfType_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasAtLeastOneElementOfType_Test.java
new file mode 100644
index 000000000..63c786cd0
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasAtLeastOneElementOfType_Test.java
@@ -0,0 +1,22 @@
+package org.assertj.core.api.objectarray;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ObjectArrayAssert;
+import org.assertj.core.api.ObjectArrayAssertBaseTest;
+
+/**
+ * Tests for {@link ObjectArrayAssert#hasAtLeastOneElementOfType(Class)}.
+ */
+public class ObjectArrayAssert_hasAtLeastOneElementOfType_Test extends ObjectArrayAssertBaseTest {
+
+  @Override
+  protected ObjectArrayAssert<Object> invoke_api_method() {
+    return assertions.hasAtLeastOneElementOfType(String.class);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(arrays).assertHasAtLeastOneElementOfType(getInfo(assertions), getActual(assertions), String.class);
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasOnlyElementsOfType_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasOnlyElementsOfType_Test.java
new file mode 100644
index 000000000..acbe31136
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasOnlyElementsOfType_Test.java
@@ -0,0 +1,22 @@
+package org.assertj.core.api.objectarray;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ObjectArrayAssert;
+import org.assertj.core.api.ObjectArrayAssertBaseTest;
+
+/**
+ * Tests for {@link ObjectArrayAssert#hasOnlyElementsOfType(Class)}.
+ */
+public class ObjectArrayAssert_hasOnlyElementsOfType_Test extends ObjectArrayAssertBaseTest {
+
+  @Override
+  protected ObjectArrayAssert<Object> invoke_api_method() {
+    return assertions.hasOnlyElementsOfType(String.class);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(arrays).assertHasOnlyElementsOfType(getInfo(assertions), getActual(assertions), String.class);
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveAtLeastOneElementOfType_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveAtLeastOneElementOfType_create_Test.java
new file mode 100644
index 000000000..cd3cbc224
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldHaveAtLeastOneElementOfType_create_Test.java
@@ -0,0 +1,55 @@
+/*
+ * Created on Jan 28, 2011
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveAtLeastOneElementOfType.shouldHaveAtLeastOneElementOfType;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link ShouldHaveAtLeastOneElementOfType#shouldHaveAtLeastOneElementOfType(Object, Class)}</code>.
+ */
+public class ShouldHaveAtLeastOneElementOfType_create_Test {
+
+  @Test
+  public void should_create_error_message_for_iterable() {
+	ErrorMessageFactory factory = shouldHaveAtLeastOneElementOfType(newArrayList("Yoda", "Luke"), Long.class);
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n"
+	                              + "Expecting:\n"
+	                              + "  <[\"Yoda\", \"Luke\"]>\n"
+	                              + "to have at least one element of type:\n"
+	                              + "  <java.lang.Long>\n"
+	                              + "but had none.");
+  }
+
+  @Test
+  public void should_create_error_message_for_array() {
+	ErrorMessageFactory factory = shouldHaveAtLeastOneElementOfType(array("Yoda", "Luke"), Long.class);
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n"
+	                              + "Expecting:\n"
+	                              + "  <[\"Yoda\", \"Luke\"]>\n"
+	                              + "to have at least one element of type:\n"
+	                              + "  <java.lang.Long>\n"
+	                              + "but had none.");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveOnlyElementsOfType_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveOnlyElementsOfType_create_Test.java
new file mode 100644
index 000000000..2f9fd10d5
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldHaveOnlyElementsOfType_create_Test.java
@@ -0,0 +1,62 @@
+/*
+ * Created on Jan 28, 2011
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveOnlyElementsOfType.shouldHaveOnlyElementsOfType;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link ShouldHaveAtLeastOneElementOfType#shouldHaveAtLeastOneElementOfType(Object, Class)}</code>.
+ */
+public class ShouldHaveOnlyElementsOfType_create_Test {
+
+  @Test
+  public void should_create_error_message_for_iterable() {
+	List<Object> list = new ArrayList<Object>();
+	list.add("Yoda");
+	list.add(5L);
+	ErrorMessageFactory factory = shouldHaveOnlyElementsOfType(list, String.class, Long.class);
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n"
+	                              + "Expecting:\n"
+	                              + "  <[\"Yoda\", 5L]>\n"
+	                              + "to only have elements of type:\n"
+	                              + "  <java.lang.String>\n"
+	                              + "but found:\n"
+	                              + "  <java.lang.Long>");
+  }
+
+  @Test
+  public void should_create_error_message_for_array() {
+	Object[] array = new Object[] { "Yoda", 5L };
+	ErrorMessageFactory factory = shouldHaveOnlyElementsOfType(array, String.class, Long.class);
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n"
+	                              + "Expecting:\n"
+	                              + "  <[\"Yoda\", 5L]>\n"
+	                              + "to only have elements of type:\n"
+	                              + "  <java.lang.String>\n"
+	                              + "but found:\n"
+	                              + "  <java.lang.Long>");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasAtLeastOneElementOfType_Test.java b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasAtLeastOneElementOfType_Test.java
new file mode 100644
index 000000000..50f433a15
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasAtLeastOneElementOfType_Test.java
@@ -0,0 +1,46 @@
+package org.assertj.core.internal.objectarrays;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveAtLeastOneElementOfType.shouldHaveAtLeastOneElementOfType;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import org.assertj.core.internal.ObjectArraysBaseTest;
+import org.junit.Test;
+
+public class ObjectArrays_assertHasAtLeastOneElementOfType_Test extends ObjectArraysBaseTest {
+
+  private static final Object[] array = { 6, "Hello" };
+ 
+  @Test
+  public void should_pass_if_actual_has_one_element_of_the_expected_type() {
+	arrays.assertHasAtLeastOneElementOfType(someInfo(), array, Integer.class);
+	arrays.assertHasAtLeastOneElementOfType(someInfo(), array, String.class);
+	arrays.assertHasAtLeastOneElementOfType(someInfo(), array, Object.class);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	arrays.assertHasAtLeastOneElementOfType(someInfo(), null, Integer.class);
+  }
+
+  @Test
+  public void should_throw_exception_if_expected_type_is_null() {
+	thrown.expect(NullPointerException.class);
+	arrays.assertHasAtLeastOneElementOfType(someInfo(), array, null);
+  }
+
+  @Test
+  public void should_fail_if_no_elements_in_actual_belongs_to_the_expected_type() {
+	try {
+	  arrays.assertHasAtLeastOneElementOfType(someInfo(), array, Float.class);
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage(shouldHaveAtLeastOneElementOfType(array, Float.class).create());
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasOnlyElementsOfType_Test.java b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasOnlyElementsOfType_Test.java
new file mode 100644
index 000000000..17aba0cdb
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasOnlyElementsOfType_Test.java
@@ -0,0 +1,48 @@
+package org.assertj.core.internal.objectarrays;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveOnlyElementsOfType.shouldHaveOnlyElementsOfType;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import org.assertj.core.api.ObjectArrayAssert;
+import org.assertj.core.internal.ObjectArraysBaseTest;
+import org.junit.Test;
+
+/**
+ * Tests for {@link ObjectArrayAssert#hasOnlyElementsOfType(Class)}.
+ */
+public class ObjectArrays_assertHasOnlyElementsOfType_Test extends ObjectArraysBaseTest {
+
+  private static final Object[] array = { 6, 7.0, 8L };
+ 
+  @Test
+  public void should_pass_if_actual_has_only_elements_of_the_expected_type() {
+	arrays.assertHasOnlyElementsOfType(someInfo(), array, Number.class);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	arrays.assertHasOnlyElementsOfType(someInfo(), null, Integer.class);
+  }
+
+  @Test
+  public void should_throw_exception_if_expected_type_is_null() {
+	thrown.expect(NullPointerException.class);
+	arrays.assertHasOnlyElementsOfType(someInfo(), array, null);
+  }
+
+  @Test
+  public void should_fail_if_one_element_in_actual_does_not_belong_to_the_expected_type() {
+	try {
+	  arrays.assertHasOnlyElementsOfType(someInfo(), array, Long.class);
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage(shouldHaveOnlyElementsOfType(array, Long.class, Integer.class).create());
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+}
\ No newline at end of file
