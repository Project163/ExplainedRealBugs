diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index c05862cd8..9001aeecc 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -645,6 +645,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
 
   /**
    * Same as {@link #containsExactly(Object[])} but handle the {@link Iterable} to array conversion.
+   * Same semantic as {@link #containsExactly(Object...)} : verifies that actual contains all the elements of the given
+   * iterable and nothing else <b>in the same order</b>.
    * <p/>
    * Example :
    * <pre>
@@ -664,16 +666,19 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
   }
   
   /**
-   * Same as {@link #containsOnly(Object[])} but handle the {@link Iterable} to array conversion.
+   * Same semantic as {@link #containsOnly(Object[])} : verifies that actual contains all the elements of the given
+   * iterable and nothing else, <b>in any order</b>.
    * <p/>
    * Example :
+   * 
    * <pre>
    * Iterable&lt;Ring&gt; rings = newArrayList(vilya, nenya);
-   *
+   * 
    * // assertion will pass
    * assertThat(rings).containsOnlyElementsOf(newLinkedList(nenya, vilya));
-   *
-   * // assertion will fail as actual has fewer elements than expected.
+   * assertThat(rings).containsOnlyElementsOf(newLinkedList(nenya, nenya, vilya, vilya));
+   * 
+   * // assertion will fail as actual does not contqin narya.
    * assertThat(rings).containsOnlyElementsOf(newLinkedList(nenya, vilya, narya));
    * </pre>
    * 
@@ -683,34 +688,64 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
       return containsOnly(toArray(iterable));
   }
 
-    /**
-     * Use field by field comparison (including inherited fields) instead of relying
-     * on actual type A <code>equals</code> method to compare group elements
-     * for incoming assertion checks.
-     *
-     * This can be handy if <code>equals</code> implementation of objects to compare does not suit you.
-     * </p>
-     * <p>
-     * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
-     * (e.g. public) or fields with an accessible getter.
-     * </p>
-     *
-     * <pre>
-     * Example:
-     *
-     * TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
-     * TolkienCharacter frodoClone = new TolkienCharacter("Frodo", 33, HOBBIT);
-     *
-     * // Fail if equals has not been overriden in TolkienCharacter as equals default implementation only compares references
-     * assertThat(newArrayList(frodo)).contains(frodoClone);
-     *
-     * // frodo and frodoClone are equals when doing a field by field comparison.
-     * assertThat(newArrayList(frodo)).usingFieldByFieldElementComparator().contains(frodoClone);
-     *
-     * </pre>
-     *
-     * @return {@code this} assertion object.
-     */
+  /**
+   * Same semantic as {@link #containsOnlyElementsOf(Iterable)} : verifies that actual contains all the elements of the
+   * given iterable and nothing else, <b>in any order</b>.
+   * 
+   * <pre>
+   * Example:
+   * Iterable&lt;Ring&gt; elvesRings = newArrayList(vilya, nenya, narya);
+   * 
+   * // assertions will pass
+   * assertThat(elvesRings).hasSameElementsAs(newArrayList(nenya, narya, vilya));
+   * assertThat(elvesRings).hasSameElementsAs(newArrayList(nenya, narya, vilya, nenya));
+   * 
+   * // assertions will fail
+   * assertThat(elvesRings).hasSameElementsAs(newArrayList(nenya, narya));
+   * assertThat(elvesRings).hasSameElementsAs(newArrayList(nenya, narya, vilya, oneRing));
+   * </pre>
+   * 
+   * </p>
+   * 
+   * @param values the values to verify against
+   * @return this assertion object
+   * @throws AssertionError if the actual group is {@code null}
+   * @throws NullPointerException if the given {@code Iterable} is {@code null}
+   * @throws AssertionError if the actual {@code Iterable} does not have the same elements, in any order, as the given
+   *           {@code Iterable}
+   */
+  public S hasSameElementsAs(Iterable<? extends T> iterable) {
+    return containsOnly(toArray(iterable));
+  }
+
+  /**
+   * Use field by field comparison (including inherited fields) instead of relying
+   * on actual type A <code>equals</code> method to compare group elements
+   * for incoming assertion checks.
+   *
+   * This can be handy if <code>equals</code> implementation of objects to compare does not suit you.
+   * </p>
+   * <p>
+   * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
+   * (e.g. public) or fields with an accessible getter.
+   * </p>
+   *
+   * <pre>
+   * Example:
+   *
+   * TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
+   * TolkienCharacter frodoClone = new TolkienCharacter("Frodo", 33, HOBBIT);
+   *
+   * // Fail if equals has not been overriden in TolkienCharacter as equals default implementation only compares references
+   * assertThat(newArrayList(frodo)).contains(frodoClone);
+   *
+   * // frodo and frodoClone are equals when doing a field by field comparison.
+   * assertThat(newArrayList(frodo)).usingFieldByFieldElementComparator().contains(frodoClone);
+   *
+   * </pre>
+   *
+   * @return {@code this} assertion object.
+   */
   public S usingFieldByFieldElementComparator() {
     return usingComparisonStrategy(new FieldByFieldComparisonStrategy());
   }
@@ -821,7 +856,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return {@code this} assertion object.
    */
   @Override
-  public S inHexadecimal() { // TODO rename to asHexadecimalElements() ?
+  public S inHexadecimal() {
     return super.inHexadecimal();
   }
 
