diff --git a/src/main/java/org/assertj/core/internal/Maps.java b/src/main/java/org/assertj/core/internal/Maps.java
index 7fbab56ef..864546435 100644
--- a/src/main/java/org/assertj/core/internal/Maps.java
+++ b/src/main/java/org/assertj/core/internal/Maps.java
@@ -48,6 +48,7 @@ import static org.assertj.core.internal.CommonValidations.checkSizes;
 import static org.assertj.core.internal.CommonValidations.hasSameSizeAsCheck;
 import static org.assertj.core.internal.ErrorMessages.keysToLookForIsEmpty;
 import static org.assertj.core.internal.ErrorMessages.keysToLookForIsNull;
+import static org.assertj.core.internal.ErrorMessages.valuesToLookForIsEmpty;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Arrays.asList;
 import static org.assertj.core.util.IterableUtil.toArray;
@@ -319,21 +320,17 @@ public class Maps {
         found.add(entry);
       }
     }
-    if (found.isEmpty()) return;
-    throw failures.failure(info, shouldNotContain(actual, entries, found));
+    if (!found.isEmpty()) throw failures.failure(info, shouldNotContain(actual, entries, found));
   }
 
   public <K, V> void assertContainsKeys(AssertionInfo info, Map<K, V> actual, K[] keys) {
     assertNotNull(info, actual);
     requireNonNull(keys, keysToLookForIsNull("array of keys"));
-    if (actual.isEmpty() && keys.length == 0) {
-      return;
-    }
+    if (actual.isEmpty() && keys.length == 0) return;
     failIfEmpty(keys, keysToLookForIsEmpty("array of keys"));
 
     Set<K> notFound = getNotFoundKeys(actual, keys);
-    if (notFound.isEmpty()) return;
-    throw failures.failure(info, shouldContainKeys(actual, notFound));
+    if (!notFound.isEmpty()) throw failures.failure(info, shouldContainKeys(actual, notFound));
   }
 
   public <K, V> void assertContainsKey(AssertionInfo info, Map<K, V> actual, K key) {
@@ -443,24 +440,40 @@ public class Maps {
 
   public <K, V> void assertContainsValue(AssertionInfo info, Map<K, V> actual, V value) {
     assertNotNull(info, actual);
-    if (!actual.containsValue(value)) throw failures.failure(info, shouldContainValue(actual, value));
+    if (!containsValue(actual, value)) throw failures.failure(info, shouldContainValue(actual, value));
   }
 
   public <K, V> void assertContainsValues(AssertionInfo info, Map<K, V> actual, V[] values) {
     assertNotNull(info, actual);
     requireNonNull(values, "The array of values to look for should not be null");
     if (actual.isEmpty() && values.length == 0) return;
-    //
-    Set<V> valuesNotFound = new LinkedHashSet<>();
-    for (V valueToLookFor : values) {
-      if (!actual.containsValue(valueToLookFor)) valuesNotFound.add(valueToLookFor);
-    }
-    if (!valuesNotFound.isEmpty()) throw failures.failure(info, shouldContainValues(actual, valuesNotFound));
+    failIfEmpty(values, valuesToLookForIsEmpty());
+
+    Set<V> notFound = getNotFoundValues(actual, values);
+    if (!notFound.isEmpty()) throw failures.failure(info, shouldContainValues(actual, notFound));
   }
 
   public <K, V> void assertDoesNotContainValue(AssertionInfo info, Map<K, V> actual, V value) {
     assertNotNull(info, actual);
-    if (actual.containsValue(value)) throw failures.failure(info, shouldNotContainValue(actual, value));
+    if (containsValue(actual, value)) throw failures.failure(info, shouldNotContainValue(actual, value));
+  }
+
+  private static <V> Set<V> getNotFoundValues(Map<?, V> actual, V[] expectedValues) {
+    // Stream API avoided for performance reasons
+    Set<V> notFound = new LinkedHashSet<>();
+    for (V expectedValue : expectedValues) {
+      if (!containsValue(actual, expectedValue)) notFound.add(expectedValue);
+    }
+    return notFound;
+  }
+
+  private static <V> boolean containsValue(Map<?, V> actual, V value) {
+    try {
+      return actual.containsValue(value);
+    } catch (NullPointerException e) {
+      if (value == null) return false; // null values not permitted
+      throw e;
+    }
   }
 
   public <K, V> void assertContainsOnly(AssertionInfo info, Map<K, V> actual, Entry<? extends K, ? extends V>[] entries) {
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsKey_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsKey_Test.java
index b5daeca65..ccf60aa80 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsKey_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsKey_Test.java
@@ -51,9 +51,9 @@ class Maps_assertContainsKey_Test extends MapsBaseTest {
   @Test
   void should_fail_if_actual_is_null() {
     // GIVEN
-    String keys = "name";
+    String key = "name";
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsKey(someInfo(), null, keys));
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsKey(someInfo(), null, key));
     // THEN
     then(assertionError).hasMessage(actualIsNull());
   }
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsValue_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsValue_Test.java
index 952220359..2bc68e409 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsValue_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsValue_Test.java
@@ -12,64 +12,104 @@
  */
 package org.assertj.core.internal.maps;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.unmodifiableMap;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.assertThatNoException;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.MapEntry.entry;
 import static org.assertj.core.error.ShouldContainValue.shouldContainValue;
 import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.mockito.Mockito.verify;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.util.Map;
+import java.util.stream.Stream;
 
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.Maps;
+import org.apache.commons.collections4.map.SingletonMap;
 import org.assertj.core.internal.MapsBaseTest;
-import org.junit.jupiter.api.BeforeEach;
+import org.assertj.core.test.jdk11.Jdk11;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
+import com.google.common.collect.ImmutableMap;
 
 /**
- * Tests for <code>{@link Maps#assertContainsValue(AssertionInfo, Map, Object)}</code>.
- * 
  * @author Nicolas François
  * @author Joel Costigliola
  */
 class Maps_assertContainsValue_Test extends MapsBaseTest {
 
-  @Override
-  @BeforeEach
-  public void setUp() {
-    super.setUp();
-    actual = mapOf(entry("name", "Yoda"), entry("color", "green"), entry(null, null));
+  @Test
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    String value = "Yoda";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsValue(someInfo(), null, value));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
-  @Test
-  void should_pass_if_actual_contains_given_value() {
-    maps.assertContainsValue(someInfo(), actual, "Yoda");
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsSuccessfulTestCases",
+      "modifiableMapsSuccessfulTestCases",
+  })
+  void should_pass(Map<String, String> actual, String expected) {
+    // WHEN/THEN
+    assertThatNoException().as(actual.getClass().getName())
+                           .isThrownBy(() -> maps.assertContainsValue(info, actual, expected));
   }
 
-  @Test
-  void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> maps.assertContainsValue(someInfo(), null, "Yoda"))
-                                                   .withMessage(actualIsNull());
+  private static Stream<Arguments> unmodifiableMapsSuccessfulTestCases() {
+    return Stream.of(arguments(singletonMap("name", "Yoda"), "Yoda"),
+                     arguments(new SingletonMap<>("name", "Yoda"), "Yoda"),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))), "Yoda"),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), "Yoda"),
+                     arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"), "Yoda"));
   }
 
-  @Test
-  void should_success_if_value_is_null() {
-    maps.assertContainsValue(someInfo(), actual, null);
+  private static Stream<Arguments> modifiableMapsSuccessfulTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")), "Yoda"),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")), "Jedi")));
   }
 
-  @Test
-  void should_fail_if_actual_does_not_contain_value() {
-    AssertionInfo info = someInfo();
-    String value = "veryOld";
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsFailureTestCases",
+      "modifiableMapsFailureTestCases",
+  })
+  void should_fail(Map<String, String> actual, String expected) {
+    // WHEN
+    assertThatExceptionOfType(AssertionError.class).as(actual.getClass().getName())
+                                                   .isThrownBy(() -> maps.assertContainsValue(info, actual, expected))
+                                                   // THEN
+                                                   .withMessage(shouldContainValue(actual, expected).create());
+  }
 
-    Throwable error = catchThrowable(() -> maps.assertContainsValue(info, actual, value));
+  private static Stream<Arguments> unmodifiableMapsFailureTestCases() {
+    return Stream.of(arguments(emptyMap(), "Yoda"),
+                     arguments(singletonMap("name", "Yoda"), "green"),
+                     arguments(new SingletonMap<>("name", "Yoda"), "green"),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))), "green"),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), "green"),
+                     arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"), "green"),
+                     // implementation not permitting null keys
+                     arguments(Jdk11.Map.of("name", "Yoda"), null));
+  }
 
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldContainValue(actual, value));
+  private static Stream<Arguments> modifiableMapsFailureTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda")),
+                                                          "green"),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          "green")));
   }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsValues_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsValues_Test.java
index b5ea37185..aeefd6ee9 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsValues_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsValues_Test.java
@@ -12,79 +12,152 @@
  */
 package org.assertj.core.internal.maps;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.unmodifiableMap;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.api.Assertions.assertThatNoException;
 import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.MapEntry.entry;
 import static org.assertj.core.error.ShouldContainValues.shouldContainValues;
 import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.assertj.core.util.Sets.newLinkedHashSet;
-import static org.mockito.Mockito.verify;
+import static org.assertj.core.util.Sets.set;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
 
-import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.stream.Stream;
 
-import org.assertj.core.api.AssertionInfo;
+import org.apache.commons.collections4.map.SingletonMap;
 import org.assertj.core.internal.MapsBaseTest;
-import org.junit.jupiter.api.BeforeEach;
+import org.assertj.core.test.jdk11.Jdk11;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import com.google.common.collect.ImmutableMap;
 
 /**
- * Tests for <code>{@link org.assertj.core.internal.Maps#assertContainsValues(org.assertj.core.api.AssertionInfo, java.util.Map, Object[])}</code>.
- *
  * @author Nicolas François
  * @author Joel Costigliola
  * @author Alexander Bischof
  */
 class Maps_assertContainsValues_Test extends MapsBaseTest {
 
-  @Override
-  @BeforeEach
-  public void setUp() {
-    super.setUp();
-    actual = mapOf(entry("name", "Yoda"), entry("type", "Jedi"), entry("color", "green"), entry(null, null));
+  @Test
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    String[] values = { "Yoda" };
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsValues(someInfo(), null, values));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
-  void should_pass_if_actual_contains_given_values() {
-    maps.assertContainsValues(someInfo(), actual, new String[] { "Yoda", "Jedi" });
+  void should_fail_if_given_values_array_is_null() {
+    // GIVEN
+    String[] values = null;
+    // WHEN
+    Throwable thrown = catchThrowable(() -> maps.assertContainsValues(someInfo(), actual, values));
+    // THEN
+    then(thrown).isInstanceOf(NullPointerException.class).hasMessage("The array of values to look for should not be null");
   }
 
   @Test
-  void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> maps.assertContainsValues(someInfo(), null, array("Yoda")))
-                                                   .withMessage(actualIsNull());
+  void should_fail_if_given_values_array_is_empty() {
+    // GIVEN
+    String[] values = array();
+    // WHEN
+    Throwable thrown = catchThrowable(() -> maps.assertContainsValues(someInfo(), actual, values));
+    // THEN
+    then(thrown).isInstanceOf(IllegalArgumentException.class).hasMessage("The array of values to look for should not be empty");
   }
 
-  @Test
-  void should_fail_if_value_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> maps.assertContainsValues(someInfo(), actual, (String[]) null))
-                                    .withMessage("The array of values to look for should not be null");
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsSuccessfulTestCases",
+      "modifiableMapsSuccessfulTestCases",
+  })
+  void should_pass(Map<String, String> actual, String[] expected) {
+    // WHEN/THEN
+    assertThatNoException().as(actual.getClass().getName())
+                           .isThrownBy(() -> maps.assertContainsValues(info, actual, expected));
   }
 
-  @Test
-  void should_pass_if_actual_and_given_values_are_empty() {
-    actual = new HashMap<>();
-    maps.assertContainsValues(someInfo(), actual, array());
+  private static Stream<Arguments> unmodifiableMapsSuccessfulTestCases() {
+    return Stream.of(arguments(emptyMap(), emptyKeys()),
+                     arguments(singletonMap("name", "Yoda"), array("Yoda")),
+                     arguments(new SingletonMap<>("name", "Yoda"), array("Yoda")),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))), array("Yoda", "Jedi")),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))), array("Jedi", "Yoda")),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), array("Yoda", "Jedi")),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), array("Jedi", "Yoda")),
+                     arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"), array("Yoda", "Jedi")),
+                     arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"), array("Jedi", "Yoda")));
   }
 
-  @Test
-  void should_success_if_values_contains_null() {
-    maps.assertContainsValues(someInfo(), actual, array("Yoda", null));
+  private static Stream<Arguments> modifiableMapsSuccessfulTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array("Yoda")),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array("Yoda", "Jedi")),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array("Jedi", "Yoda"))));
   }
 
-  @Test
-  void should_fail_if_actual_does_not_contain_value() {
-    AssertionInfo info = someInfo();
-    String value = "veryOld";
-    String value2 = "veryOld2";
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsFailureTestCases",
+      "modifiableMapsFailureTestCases",
+  })
+  void should_fail(Map<String, String> actual, String[] expected, Set<String> notFound) {
+    // WHEN
+    assertThatExceptionOfType(AssertionError.class).as(actual.getClass().getName())
+                                                   .isThrownBy(() -> maps.assertContainsValues(info, actual, expected))
+                                                   // THEN
+                                                   .withMessage(shouldContainValues(actual, notFound).create());
+  }
 
-    Throwable error = catchThrowable(() -> maps.assertContainsValues(info, actual, array(value, value2)));
+  private static Stream<Arguments> unmodifiableMapsFailureTestCases() {
+    return Stream.of(arguments(emptyMap(),
+                               array("Yoda"),
+                               set("Yoda")),
+                     arguments(singletonMap("name", "Yoda"),
+                               array("green"),
+                               set("green")),
+                     arguments(new SingletonMap<>("name", "Yoda"),
+                               array("green"),
+                               set("green")),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))),
+                               array("Yoda", "green"),
+                               set("green")),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"),
+                               array("Yoda", "green"),
+                               set("green")),
+                     arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"),
+                               array("Yoda", "green"),
+                               set("green")),
+                     arguments(Jdk11.Map.of("name", "Yoda"),
+                               array((String) null), // implementation not permitting null keys
+                               set((String) null)));
+  }
 
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldContainValues(actual, newLinkedHashSet(value, value2)));
+  private static Stream<Arguments> modifiableMapsFailureTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda")),
+                                                          array("Yoda", "green"),
+                                                          set("green")),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          array("Yoda", "green"),
+                                                          set("green"))));
   }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainKey_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainKey_Test.java
index a415fec60..547dc4e4f 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainKey_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainKey_Test.java
@@ -77,7 +77,7 @@ class Maps_assertDoesNotContainKey_Test extends MapsBaseTest {
                      arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), "color"),
                      arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"), "color"),
                      // implementation not permitting null keys
-                     arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"), null));
+                     arguments(Jdk11.Map.of("name", "Yoda"), null));
   }
 
   private static Stream<Arguments> modifiableMapsSuccessfulTestCases() {
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainValue_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainValue_Test.java
index 71ff3128d..e8de67eeb 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainValue_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertDoesNotContainValue_Test.java
@@ -12,64 +12,104 @@
  */
 package org.assertj.core.internal.maps;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.singletonMap;
+import static java.util.Collections.unmodifiableMap;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.assertThatNoException;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.MapEntry.entry;
 import static org.assertj.core.error.ShouldNotContainValue.shouldNotContainValue;
 import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.mockito.Mockito.verify;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.util.Map;
+import java.util.stream.Stream;
 
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.Maps;
+import org.apache.commons.collections4.map.SingletonMap;
 import org.assertj.core.internal.MapsBaseTest;
-import org.junit.jupiter.api.BeforeEach;
+import org.assertj.core.test.jdk11.Jdk11;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
+import com.google.common.collect.ImmutableMap;
 
 /**
- * Tests for <code>{@link Maps#assertDoesNotContainValue(AssertionInfo, Map, Object)}</code>.
- * 
  * @author Nicolas François
  * @author Joel Costigliola
  */
 class Maps_assertDoesNotContainValue_Test extends MapsBaseTest {
 
-  @Override
-  @BeforeEach
-  public void setUp() {
-    super.setUp();
-    actual = mapOf(entry("name", "Yoda"), entry("color", "green"));
+  @Test
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    String value = "Yoda";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> maps.assertDoesNotContainValue(someInfo(), null, value));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
-  @Test
-  void should_pass_if_actual_contains_given_value() {
-    maps.assertDoesNotContainValue(someInfo(), actual, "veryOld");
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsSuccessfulTestCases",
+      "modifiableMapsSuccessfulTestCases",
+  })
+  void should_pass(Map<String, String> actual, String expected) {
+    // WHEN/THEN
+    assertThatNoException().as(actual.getClass().getName())
+                           .isThrownBy(() -> maps.assertDoesNotContainValue(info, actual, expected));
   }
 
-  @Test
-  void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> maps.assertDoesNotContainValue(someInfo(), null, "veryOld"))
-                                                   .withMessage(actualIsNull());
+  private static Stream<Arguments> unmodifiableMapsSuccessfulTestCases() {
+    return Stream.of(arguments(emptyMap(), "Yoda"),
+                     arguments(singletonMap("name", "Yoda"), "green"),
+                     arguments(new SingletonMap<>("name", "Yoda"), "green"),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))), "green"),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), "green"),
+                     arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"), "green"),
+                     // implementation not permitting null keys
+                     arguments(Jdk11.Map.of("name", "Yoda"), null));
   }
 
-  @Test
-  void should_success_if_value_is_null() {
-    maps.assertDoesNotContainValue(someInfo(), actual, null);
+  private static Stream<Arguments> modifiableMapsSuccessfulTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda")),
+                                                          "green"),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")),
+                                                          "green")));
   }
 
-  @Test
-  void should_fail_if_actual_does_not_contain_value() {
-    AssertionInfo info = someInfo();
-    String value = "Yoda";
+  @ParameterizedTest
+  @MethodSource({
+      "unmodifiableMapsFailureTestCases",
+      "modifiableMapsFailureTestCases",
+  })
+  void should_fail(Map<String, String> actual, String expected) {
+    // WHEN
+    assertThatExceptionOfType(AssertionError.class).as(actual.getClass().getName())
+                                                   .isThrownBy(() -> maps.assertDoesNotContainValue(info, actual, expected))
+                                                   // THEN
+                                                   .withMessage(shouldNotContainValue(actual, expected).create());
+  }
 
-    Throwable error = catchThrowable(() -> maps.assertDoesNotContainValue(info, actual, value));
+  private static Stream<Arguments> unmodifiableMapsFailureTestCases() {
+    return Stream.of(arguments(singletonMap("name", "Yoda"), "Yoda"),
+                     arguments(new SingletonMap<>("name", "Yoda"), "Yoda"),
+                     arguments(unmodifiableMap(mapOf(entry("name", "Yoda"), entry("job", "Jedi"))), "Yoda"),
+                     arguments(ImmutableMap.of("name", "Yoda", "job", "Jedi"), "Yoda"),
+                     arguments(Jdk11.Map.of("name", "Yoda", "job", "Jedi"), "Yoda"));
+  }
 
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldNotContainValue(actual, value));
+  private static Stream<Arguments> modifiableMapsFailureTestCases() {
+    return Stream.of(MODIFIABLE_MAPS)
+                 .flatMap(supplier -> Stream.of(arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")), "Yoda"),
+                                                arguments(mapOf(supplier, entry("name", "Yoda"), entry("job", "Jedi")), "Jedi")));
   }
+
 }
