diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index a2f68a311..f819e60a3 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -25,8 +25,10 @@ import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPR
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
 
+import java.lang.reflect.Array;
 import java.util.ArrayList;
 import java.util.Comparator;
+import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
@@ -34,6 +36,7 @@ import java.util.Map.Entry;
 import java.util.Optional;
 import java.util.Set;
 import java.util.TreeMap;
+import java.util.concurrent.atomic.AtomicReference;
 import java.util.function.BiPredicate;
 import java.util.function.Predicate;
 import java.util.regex.Pattern;
@@ -1223,8 +1226,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
         return Optional.empty();
       }
       if (isContainer(node)) {
-        // TODO: supported with https://github.com/assertj/assertj/issues/3354
-        return Optional.empty();
+        node = unwrapContainer(node);
+        continue;
       }
       String comparedFieldNodeNameElement = comparedFieldLocation.getDecomposedPath().get(nestingLevel);
       Set<String> nodeNames = introspectionStrategy.getChildrenNodeNamesOf(node);
@@ -1237,6 +1240,24 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return Optional.empty();
   }
 
+  private Object unwrapContainer(Object container) {
+    if (container instanceof Optional) {
+      return ((Optional<?>) container).orElse(null);
+    }
+    if (container instanceof AtomicReference) {
+      return ((AtomicReference<?>) container).get();
+    }
+    if (container instanceof Iterable) {
+      Iterator<?> iterator = ((Iterable<?>) container).iterator();
+      return iterator.hasNext() ? iterator.next() : null;
+    }
+    if (container.getClass().isArray()) {
+      return Array.getLength(container) > 0 ? Array.get(container, 0) : null;
+    }
+    // To handle other types that might be identified as true by isContainer in the future.
+    return null;
+  }
+
   private static String formatUnknownComparedField(FieldLocation fieldLocation, String unknownNodeNameElement) {
     return fieldLocation.isTopLevelField()
         ? "{%s}".formatted(unknownNodeNameElement)
diff --git a/assertj-core/src/test/java/org/assertj/core/internal/RecursiveComparison_NonExistentFieldInContainers_Test.java b/assertj-core/src/test/java/org/assertj/core/internal/RecursiveComparison_NonExistentFieldInContainers_Test.java
new file mode 100644
index 000000000..bcfaae13b
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/internal/RecursiveComparison_NonExistentFieldInContainers_Test.java
@@ -0,0 +1,165 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.thenIllegalArgumentException;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.concurrent.atomic.AtomicReference;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for AssertJ issue #3354.
+ * <p>
+ * Verifies that comparing a non-existent field within a container (Iterable, Array, Optional, AtomicReference)
+ * correctly throws an {@link IllegalArgumentException}.
+ *
+ * @author Dongmin Cha
+ */
+@SuppressWarnings("OptionalUsedAsFieldOrParameterType")
+class RecursiveComparison_NonExistentFieldInContainers_Test {
+
+  static class Player {
+    String name;
+
+    Player(String name) {
+      this.name = name;
+    }
+  }
+
+  static class TeamWithList {
+    List<Player> players;
+
+    TeamWithList(List<Player> players) {
+      this.players = players;
+    }
+  }
+
+  static class TeamWithSet {
+    Set<Player> players;
+
+    TeamWithSet(Set<Player> players) {
+      this.players = players;
+    }
+  }
+
+  static class TeamWithArray {
+    Player[] players;
+
+    TeamWithArray(Player[] players) {
+      this.players = players;
+    }
+  }
+
+  static class TeamWithOptionalPlayer {
+    Optional<Player> player;
+
+    TeamWithOptionalPlayer(Optional<Player> player) {
+      this.player = player;
+    }
+  }
+
+  static class TeamWithAtomicReferencePlayer {
+    AtomicReference<Player> player;
+
+    TeamWithAtomicReferencePlayer(AtomicReference<Player> player) {
+      this.player = player;
+    }
+  }
+
+  @Nested
+  @DisplayName("for Iterable containers (List/Set)")
+  class ForIterable {
+
+    @Test
+    void should_throw_exception_when_comparing_non_existent_field_in_list() {
+      // GIVEN
+      var actual = new TeamWithList(List.of(new Player("Son")));
+      var expected = new TeamWithList(List.of(new Player("Maddison")));
+      // WHEN & THEN
+      thenIllegalArgumentException().isThrownBy(() -> assertThat(actual).usingRecursiveComparison()
+                                                                        .comparingOnlyFields("players.salary")
+                                                                        .isEqualTo(expected))
+                                    .withMessageContaining("players.salary");
+    }
+
+    @Test
+    void should_throw_exception_when_comparing_non_existent_field_in_set() {
+      // GIVEN
+      var actual = new TeamWithSet(Set.of(new Player("Son")));
+      var expected = new TeamWithSet(Set.of(new Player("Maddison")));
+      // WHEN & THEN
+      thenIllegalArgumentException().isThrownBy(() -> assertThat(actual).usingRecursiveComparison()
+                                                                        .comparingOnlyFields("players.salary")
+                                                                        .isEqualTo(expected))
+                                    .withMessageContaining("players.salary");
+    }
+  }
+
+  @Nested
+  @DisplayName("for Array containers")
+  class ForArray {
+
+    @Test
+    void should_throw_exception_when_comparing_non_existent_field_in_array() {
+      // GIVEN
+      var actual = new TeamWithArray(new Player[] { new Player("Son") });
+      var expected = new TeamWithArray(new Player[] { new Player("Maddison") });
+      // WHEN & THEN
+      thenIllegalArgumentException().isThrownBy(() -> assertThat(actual).usingRecursiveComparison()
+                                                                        .comparingOnlyFields("players.salary")
+                                                                        .isEqualTo(expected))
+                                    .withMessageContaining("players.salary");
+    }
+  }
+
+  @Nested
+  @DisplayName("for Optional wrappers")
+  class ForOptional {
+
+    @Test
+    void should_throw_exception_when_comparing_non_existent_field_in_optional() {
+      // GIVEN
+      var actual = new TeamWithOptionalPlayer(Optional.of(new Player("Son")));
+      var expected = new TeamWithOptionalPlayer(Optional.of(new Player("Kane")));
+      // WHEN & THEN
+      thenIllegalArgumentException().isThrownBy(() -> assertThat(actual).usingRecursiveComparison()
+                                                                        .comparingOnlyFields("player.salary")
+                                                                        .isEqualTo(expected))
+                                    .withMessageContaining("player.salary");
+    }
+  }
+
+  @Nested
+  @DisplayName("for AtomicReference wrappers")
+  class ForAtomicReference {
+
+    @Test
+    void should_throw_exception_when_comparing_non_existent_field_in_atomic_reference() {
+      // GIVEN
+      var actual = new TeamWithAtomicReferencePlayer(new AtomicReference<>(new Player("Son")));
+      var expected = new TeamWithAtomicReferencePlayer(new AtomicReference<>(new Player("Kane")));
+      // WHEN & THEN
+      thenIllegalArgumentException().isThrownBy(() -> assertThat(actual).usingRecursiveComparison()
+                                                                        .comparingOnlyFields("player.salary")
+                                                                        .isEqualTo(expected))
+                                    .withMessageContaining("player.salary");
+    }
+  }
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
index 92011a009..6f6ddc6f3 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
@@ -43,10 +43,9 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends WithC
   @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
   @MethodSource
   void should_only_compare_given_fields(Object actual, Object expected, String[] fieldNamesToCompare) {
-
-    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                .comparingOnlyFields(fieldNamesToCompare)
-                .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .comparingOnlyFields(fieldNamesToCompare)
+                      .isEqualTo(expected);
   }
 
   private static Stream<Arguments> should_only_compare_given_fields() {
@@ -153,7 +152,7 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends WithC
                 .isEqualTo(expected);
   }
 
-  @SuppressWarnings("unused")
+  @SuppressWarnings({ "unused", "FieldCanBeLocal" })
   static class Staff {
 
     private Boolean deleted;
@@ -280,9 +279,9 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends WithC
     // GIVEN
     recursiveComparisonConfiguration.compareOnlyFields(fieldNamesToCompare);
     // WHEN
-    IllegalArgumentException iae = catchIllegalArgumentException(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                                                                                         .comparingOnlyFields(fieldNamesToCompare)
-                                                                                         .isEqualTo(expected));
+    var iae = catchIllegalArgumentException(() -> assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                                                    .comparingOnlyFields(fieldNamesToCompare)
+                                                                    .isEqualTo(expected));
     // THEN
     then(iae).hasMessage("The following fields don't exist: " + unknownFields);
   }
@@ -309,8 +308,8 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends WithC
                      arguments(john, alice, array("name", "neighbour", "number"), "{number}"),
                      arguments(john, alice, array("neighbor"), "{neighbor}"),
                      arguments(john, alice, array("neighbour.neighbor.name"), "{neighbor in <neighbour.neighbor.name>}"),
-                     // TODO for https://github.com/assertj/assertj/issues/3354
-                     // arguments(sherlockHolmes, drWatson, array("friends.other"), "{other in <friends.other>}"),
+                     arguments(sherlockHolmes, drWatson, array("friends.other"), "{other in <friends.other>}"),
+                     arguments(sherlockHolmes, drWatson, array("friends.friends.other"), "{other in <friends.friends.other>}"),
                      arguments(john, alice, array("neighbour.neighbour.name", "neighbour.neighbour.number"),
                                "{number in <neighbour.neighbour.number>}"));
   }
@@ -477,11 +476,10 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends WithC
     BaseClass actual = new SubType1();
     BaseClass expected = new SubType2();
     // WHEN
-    var exception = catchIllegalArgumentException(() -> assertThat(actual).usingRecursiveComparison()
-                                                                          .comparingOnlyFields("common", "inSubType1",
-                                                                                               "inSubType2")
-                                                                          .isEqualTo(expected));
+    var iae = catchIllegalArgumentException(() -> assertThat(actual).usingRecursiveComparison()
+                                                                    .comparingOnlyFields("common", "inSubType1", "inSubType2")
+                                                                    .isEqualTo(expected));
     // THEN
-    then(exception).hasMessage("The following fields don't exist: {inSubType2}");
+    then(iae).hasMessage("The following fields don't exist: {inSubType2}");
   }
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
index 6fca17a91..75b3cdb6f 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/legacy/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
@@ -308,8 +308,7 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends WithL
                      arguments(john, alice, array("name", "neighbour", "number"), "{number}"),
                      arguments(john, alice, array("neighbor"), "{neighbor}"),
                      arguments(john, alice, array("neighbour.neighbor.name"), "{neighbor in <neighbour.neighbor.name>}"),
-                     // TODO for https://github.com/assertj/assertj/issues/3354
-                     // arguments(sherlockHolmes, drWatson, array("friends.other"), "{other in <friends.other>}"),
+                     arguments(sherlockHolmes, drWatson, array("friends.other"), "{other in <friends.other>}"),
                      arguments(john, alice, array("neighbour.neighbour.name", "neighbour.neighbour.number"),
                                "{number in <neighbour.neighbour.number>}"));
   }
