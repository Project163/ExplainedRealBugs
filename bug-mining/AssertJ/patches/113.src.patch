diff --git a/src/main/java/org/assertj/core/api/AbstractAssert.java b/src/main/java/org/assertj/core/api/AbstractAssert.java
index 884de911d..f6db0f933 100644
--- a/src/main/java/org/assertj/core/api/AbstractAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractAssert.java
@@ -59,9 +59,9 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
   // let's keep compiler warning internal (when we can) and not expose them to our end users.
   @SuppressWarnings("unchecked")
   protected AbstractAssert(A actual, Class<?> selfType) {
-	myself = (S) selfType.cast(this);
-	this.actual = actual;
-	info = new WritableAssertionInfo();
+    myself = (S) selfType.cast(this);
+    this.actual = actual;
+    info = new WritableAssertionInfo();
   }
 
   /**
@@ -72,7 +72,7 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
    * @return the {@link WritableAssertionInfo} used in the current assertion
    */
   protected WritableAssertionInfo getWritableAssertionInfo() {
-	return info;
+    return info;
   }
 
   /**
@@ -103,22 +103,22 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
    * @param arguments the arguments referenced by the format specifiers in the errorMessage string.
    */
   protected void failWithMessage(String errorMessage, Object... arguments) {
-	AssertionError failureWithOverridenErrorMessage = Failures.instance().failureIfErrorMessageIsOverriden(info);
-	if (failureWithOverridenErrorMessage != null) throw failureWithOverridenErrorMessage;
-	String description = MessageFormatter.instance().format(info.description(), info.representation(), "");
-	throw new AssertionError(description + String.format(errorMessage, arguments));
+    AssertionError failureWithOverridenErrorMessage = Failures.instance().failureIfErrorMessageIsOverriden(info);
+    if (failureWithOverridenErrorMessage != null) throw failureWithOverridenErrorMessage;
+    String description = MessageFormatter.instance().format(info.description(), info.representation(), "");
+    throw new AssertionError(description + String.format(errorMessage, arguments));
   }
 
   /** {@inheritDoc} */
   @Override
   public S as(String description, Object... args) {
-	return describedAs(description, args);
+    return describedAs(description, args);
   }
 
   /** {@inheritDoc} */
   @Override
   public S as(Description description) {
-	return describedAs(description);
+    return describedAs(description);
   }
 
   /**
@@ -154,8 +154,8 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
    * @return {@code this} assertion object.
    */
   protected S inHexadecimal() {
-	info.useHexadecimalRepresentation();
-	return myself;
+    info.useHexadecimalRepresentation();
+    return myself;
   }
 
   /**
@@ -174,204 +174,211 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
    * @return {@code this} assertion object.
    */
   protected S inBinary() {
-	info.useBinaryRepresentation();
-	return myself;
+    info.useBinaryRepresentation();
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S describedAs(String description, Object... args) {
-	info.description(description, args);
-	return myself;
+    info.description(description, args);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S describedAs(Description description) {
-	info.description(description);
-	return myself;
+    info.description(description);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isEqualTo(Object expected) {
-	objects.assertEqual(info, actual, expected);
-	return myself;
+    objects.assertEqual(info, actual, expected);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotEqualTo(Object other) {
-	objects.assertNotEqual(info, actual, other);
-	return myself;
+    objects.assertNotEqual(info, actual, other);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public void isNull() {
-	objects.assertNull(info, actual);
+    objects.assertNull(info, actual);
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotNull() {
-	objects.assertNotNull(info, actual);
-	return myself;
+    objects.assertNotNull(info, actual);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isSameAs(Object expected) {
-	objects.assertSame(info, actual, expected);
-	return myself;
+    objects.assertSame(info, actual, expected);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotSameAs(Object other) {
-	objects.assertNotSame(info, actual, other);
-	return myself;
+    objects.assertNotSame(info, actual, other);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isIn(Object... values) {
-	objects.assertIsIn(info, actual, values);
-	return myself;
+    objects.assertIsIn(info, actual, values);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotIn(Object... values) {
-	objects.assertIsNotIn(info, actual, values);
-	return myself;
+    objects.assertIsNotIn(info, actual, values);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isIn(Iterable<?> values) {
-	objects.assertIsIn(info, actual, values);
-	return myself;
+    objects.assertIsIn(info, actual, values);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotIn(Iterable<?> values) {
-	objects.assertIsNotIn(info, actual, values);
-	return myself;
+    objects.assertIsNotIn(info, actual, values);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S is(Condition<? super A> condition) {
-	conditions.assertIs(info, actual, condition);
-	return myself;
+    conditions.assertIs(info, actual, condition);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNot(Condition<? super A> condition) {
-	conditions.assertIsNot(info, actual, condition);
-	return myself;
+    conditions.assertIsNot(info, actual, condition);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S has(Condition<? super A> condition) {
-	conditions.assertHas(info, actual, condition);
-	return myself;
+    conditions.assertHas(info, actual, condition);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S doesNotHave(Condition<? super A> condition) {
-	conditions.assertDoesNotHave(info, actual, condition);
-	return myself;
+    conditions.assertDoesNotHave(info, actual, condition);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isInstanceOf(Class<?> type) {
-	objects.assertIsInstanceOf(info, actual, type);
-	return myself;
+    objects.assertIsInstanceOf(info, actual, type);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isInstanceOfAny(Class<?>... types) {
-	objects.assertIsInstanceOfAny(info, actual, types);
-	return myself;
+    objects.assertIsInstanceOfAny(info, actual, types);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotInstanceOf(Class<?> type) {
-	objects.assertIsNotInstanceOf(info, actual, type);
-	return myself;
+    objects.assertIsNotInstanceOf(info, actual, type);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotInstanceOfAny(Class<?>... types) {
-	objects.assertIsNotInstanceOfAny(info, actual, types);
-	return myself;
+    objects.assertIsNotInstanceOfAny(info, actual, types);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S hasSameClassAs(Object other) {
-	objects.assertHasSameClassAs(info, actual, other);
-	return myself;
+    objects.assertHasSameClassAs(info, actual, other);
+    return myself;
+  }
+
+  /** {@inheritDoc} */
+  @Override
+  public S hasToString(String expectedToString) {
+    objects.assertHasToString(info, actual, expectedToString);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S doesNotHaveSameClassAs(Object other) {
-	objects.assertDoesNotHaveSameClassAs(info, actual, other);
-	return myself;
+    objects.assertDoesNotHaveSameClassAs(info, actual, other);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isExactlyInstanceOf(Class<?> type) {
-	objects.assertIsExactlyInstanceOf(info, actual, type);
-	return myself;
+    objects.assertIsExactlyInstanceOf(info, actual, type);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotExactlyInstanceOf(Class<?> type) {
-	objects.assertIsNotExactlyInstanceOf(info, actual, type);
-	return myself;
+    objects.assertIsNotExactlyInstanceOf(info, actual, type);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isOfAnyClassIn(Class<?>... types) {
-	objects.assertIsOfAnyClassIn(info, actual, types);
-	return myself;
+    objects.assertIsOfAnyClassIn(info, actual, types);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S isNotOfAnyClassIn(Class<?>... types) {
-	objects.assertIsNotOfAnyClassIn(info, actual, types);
-	return myself;
+    objects.assertIsNotOfAnyClassIn(info, actual, types);
+    return myself;
   }
 
   /** {@inheritDoc} */
   @SuppressWarnings("unchecked")
   @Override
   public AbstractListAssert<?, ?, Object> asList() {
-	objects.assertIsInstanceOf(info, actual, List.class);
-	return Assertions.assertThat((List<Object>) actual);
+    objects.assertIsInstanceOf(info, actual, List.class);
+    return Assertions.assertThat((List<Object>) actual);
   }
 
   /** {@inheritDoc} */
   @Override
   public AbstractCharSequenceAssert<?, String> asString() {
-	objects.assertIsInstanceOf(info, actual, String.class);
-	return Assertions.assertThat((String) actual);
+    objects.assertIsInstanceOf(info, actual, String.class);
+    return Assertions.assertThat((String) actual);
   }
 
   /**
@@ -381,7 +388,7 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
    * @return the description String representation of this assertion.
    */
   public String descriptionText() {
-	return info.descriptionText();
+    return info.descriptionText();
   }
 
   /**
@@ -403,30 +410,30 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
    * @throws Exception see {@link String#format(String, Object...)} exception clause.
    */
   public S overridingErrorMessage(String newErrorMessage, Object... args) {
-	info.overridingErrorMessage(formatIfArgs(newErrorMessage, args));
-	return myself;
+    info.overridingErrorMessage(formatIfArgs(newErrorMessage, args));
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S usingComparator(Comparator<? super A> customComparator) {
-	// using a specific strategy to compare actual with other objects.
-	this.objects = new Objects(new ComparatorBasedComparisonStrategy(customComparator));
-	return myself;
+    // using a specific strategy to compare actual with other objects.
+    this.objects = new Objects(new ComparatorBasedComparisonStrategy(customComparator));
+    return myself;
   }
 
   /** {@inheritDoc} */
   @Override
   public S usingDefaultComparator() {
-	// fall back to default strategy to compare actual with other objects.
-	this.objects = Objects.instance();
-	return myself;
+    // fall back to default strategy to compare actual with other objects.
+    this.objects = Objects.instance();
+    return myself;
   }
-  
+
   @Override
   public S withThreadDumpOnError() {
-	Failures.instance().enablePrintThreadDump();
-	return myself;
+    Failures.instance().enablePrintThreadDump();
+    return myself;
   }
 
   /**
@@ -437,7 +444,7 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
   @Override
   @Deprecated
   public boolean equals(Object obj) {
-	throw new UnsupportedOperationException("'equals' is not supported...maybe you intended to call 'isEqualTo'");
+    throw new UnsupportedOperationException("'equals' is not supported...maybe you intended to call 'isEqualTo'");
   }
 
   /**
@@ -447,6 +454,6 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
    */
   @Override
   public int hashCode() {
-	return 1;
+    return 1;
   }
 }
diff --git a/src/main/java/org/assertj/core/api/Assert.java b/src/main/java/org/assertj/core/api/Assert.java
index 0a7ed9519..f15af29ae 100644
--- a/src/main/java/org/assertj/core/api/Assert.java
+++ b/src/main/java/org/assertj/core/api/Assert.java
@@ -16,7 +16,9 @@ import java.util.Comparator;
 
 /**
  * Base contract of all assertion objects: the minimum functionality that any assertion object should provide.
- * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/anMa4g" target="_blank">Emulating
+ * 
+ * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/anMa4g"
+ *          target="_blank">Emulating
  *          'self types' using Java Generics to simplify fluent API implementation</a>&quot; for more details.
  * @param <A> the type of the "actual" value.
  * 
@@ -29,6 +31,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is equal to the given one.
+   * 
    * @param expected the given value to compare the actual value to.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual value is not equal to the given one.
@@ -37,6 +40,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is not equal to the given one.
+   * 
    * @param other the given value to compare the actual value to.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual value is equal to the given one.
@@ -45,12 +49,14 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is {@code null}.
+   * 
    * @throws AssertionError if the actual value is not {@code null}.
    */
   void isNull();
 
   /**
    * Verifies that the actual value is not {@code null}.
+   * 
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual value is {@code null}.
    */
@@ -58,6 +64,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is the same as the given one.
+   * 
    * @param expected the given value to compare the actual value to.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual value is not the same as the given one.
@@ -66,6 +73,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is not the same as the given one.
+   * 
    * @param other the given value to compare the actual value to.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual value is the same as the given one.
@@ -74,6 +82,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is present in the given array of values.
+   * 
    * @param values the given array to search the actual value in.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given array is {@code null}.
@@ -84,6 +93,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is not present in the given array of values.
+   * 
    * @param values the given array to search the actual value in.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given array is {@code null}.
@@ -94,6 +104,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is present in the given values.
+   * 
    * @param values the given iterable to search the actual value in.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given collection is {@code null}.
@@ -104,6 +115,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is not present in the given values.
+   * 
    * @param values the given iterable to search the actual value in.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given collection is {@code null}.
@@ -115,8 +127,8 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
   /**
    * Use given custom comparator instead of relying on actual type A equals method for incoming assertion checks.
    * <p>
-   * Custom comparator is bound to assertion instance, meaning that if a new assertion is created, it will use default comparison
-   * strategy.
+   * Custom comparator is bound to assertion instance, meaning that if a new assertion is created, it will use default
+   * comparison strategy.
    * <p>
    * Examples :
    * 
@@ -135,13 +147,16 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
   /**
    * Revert to standard comparison for incoming assertion checks.
    * <p>
-   * This method should be used to disable a custom comparison strategy set by calling {@link #usingComparator(Comparator)}.
+   * This method should be used to disable a custom comparison strategy set by calling
+   * {@link #usingComparator(Comparator)}.
+   * 
    * @return {@code this} assertion object.
    */
   S usingDefaultComparator();
 
   /**
    * Verifies that the actual value is an instance of the given type.
+   * 
    * @param type the type to check the actual value against.
    * @return this assertion object.
    * @throws NullPointerException if the given type is {@code null}.
@@ -152,6 +167,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is an instance of any of the given types.
+   * 
    * @param types the types to check the actual value against.
    * @return this assertion object.
    * @throws AssertionError if the actual value is {@code null}.
@@ -163,6 +179,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is not an instance of the given type.
+   * 
    * @param type the type to check the actual value against.
    * @return this assertion object.
    * @throws NullPointerException if the given type is {@code null}.
@@ -173,6 +190,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is not an instance of any of the given types.
+   * 
    * @param types the types to check the actual value against.
    * @return this assertion object.
    * @throws AssertionError if the actual value is {@code null}.
@@ -184,6 +202,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value has the same class as the given object.
+   * 
    * @param other the object to check type against.
    * @return this assertion object.
    * @throws AssertionError if the actual has not the same type has the given object.
@@ -192,8 +211,30 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
    */
   S hasSameClassAs(Object other);
 
+  /**
+   * Verifies that actual<code>actual.toString()</code> is equal to the given <code>String</code>.
+   * <p>
+   * Example :
+   *
+   * <pre><code class='java'>
+   * CartoonCaracter homer = new CartoonCaracter("Homer");
+   *
+   * // Instead of writing ...  
+   * assertThat(homer.toString()).isEqualTo("Homer");
+   * // ... you can simply use: 
+   * assertThat(homer).hasToString("Homer");
+   * </code></pre>
+   * 
+   * @param expectedToString the expected String description of actual.
+   * @return this assertion object.
+   * @throws AssertionError if <code>actual.toString()</code> result is not to the given <code>String</code>.
+   * @throws AssertionError if actual is {@code null}.
+   */
+  S hasToString(String expectedToString);
+
   /**
    * Verifies that the actual value does not have the same class as the given object.
+   * 
    * @param other the object to check type against.
    * @return this assertion object.
    * @throws AssertionError if the actual has the same type has the given object.
@@ -204,6 +245,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is <b>exactly</b> an instance of the given type.
+   * 
    * @param type the type to check the actual value against.
    * @return this assertion object.
    * @throws AssertionError if the actual is not <b>exactly</b> an instance of given type.
@@ -214,6 +256,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value is not <b>exactly</b> an instance of given type.
+   * 
    * @param type the type to check the actual value against.
    * @return this assertion object.
    * @throws AssertionError if the actual is exactly a instance of given type.
@@ -224,6 +267,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value type is in given types.
+   * 
    * @param types the types to check the actual value against.
    * @return this assertion object.
    * @throws AssertionError if the actual value type is not in given type.
@@ -234,6 +278,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * Verifies that the actual value type is not in given types.
+   * 
    * @param types the types to check the actual value against.
    * @return this assertion object.
    * @throws AssertionError if the actual value type is in given types.
@@ -278,8 +323,8 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
 
   /**
    * @deprecated
-   * Throws <code>{@link UnsupportedOperationException}</code> if called. It is easy to accidentally call
-   * <code>{@link #equals(Object)}</code> instead of <code>{@link #isEqualTo(Object)}</code>.
+   *             Throws <code>{@link UnsupportedOperationException}</code> if called. It is easy to accidentally call
+   *             <code>{@link #equals(Object)}</code> instead of <code>{@link #isEqualTo(Object)}</code>.
    * @throws UnsupportedOperationException if this method is called.
    */
   @Override
@@ -295,6 +340,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
    * assertThat("Messi").withThreadDumpOnError().isEqualTo("Ronaldo");
    * </code></pre>
    * will print the thread dump, something looking like:
+   * 
    * <pre><code>
    * "JDWP Command Reader"
    * 	java.lang.Thread.State: RUNNABLE
@@ -332,6 +378,7 @@ public interface Assert<S extends Assert<S, A>, A> extends Descriptable<S>, Exte
    * 		at org.assertj.core.api.AbstractAssert.isEqualTo(AbstractAssert.java:198)
    * 		at org.assertj.examples.ThreadDumpOnErrorExample.main(ThreadDumpOnErrorExample.java:28)
    * </code></pre>
+   * 
    * @return this assertion object.
    */
   S withThreadDumpOnError();
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveToString.java b/src/main/java/org/assertj/core/error/ShouldHaveToString.java
new file mode 100644
index 000000000..eaba1e126
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldHaveToString.java
@@ -0,0 +1,24 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+public class ShouldHaveToString extends BasicErrorMessageFactory {
+
+  public static ErrorMessageFactory shouldHaveToString(Object actual, String expectedToString) {
+    return new ShouldHaveToString(actual, expectedToString);
+  }
+
+  private ShouldHaveToString(Object actual, String expectedToString) {
+    super("%nExpecting actual's toString() to return:%n  <%s>%nbut was:%n  <%s>", expectedToString, actual);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Objects.java b/src/main/java/org/assertj/core/internal/Objects.java
index ce17bac2c..ecd6b1bf3 100644
--- a/src/main/java/org/assertj/core/internal/Objects.java
+++ b/src/main/java/org/assertj/core/internal/Objects.java
@@ -24,6 +24,7 @@ import static org.assertj.core.error.ShouldBeInstanceOfAny.shouldBeInstanceOfAny
 import static org.assertj.core.error.ShouldBeOfClassIn.shouldBeOfClassIn;
 import static org.assertj.core.error.ShouldBeSame.shouldBeSame;
 import static org.assertj.core.error.ShouldHaveSameClass.shouldHaveSameClass;
+import static org.assertj.core.error.ShouldHaveToString.shouldHaveToString;
 import static org.assertj.core.error.ShouldNotBeEqual.shouldNotBeEqual;
 import static org.assertj.core.error.ShouldNotBeExactlyInstanceOf.shouldNotBeExactlyInstance;
 import static org.assertj.core.error.ShouldNotBeIn.shouldNotBeIn;
@@ -73,27 +74,27 @@ public class Objects {
    * @return the singleton instance of this class based on {@link StandardComparisonStrategy}.
    */
   public static Objects instance() {
-	return INSTANCE;
+    return INSTANCE;
   }
 
   @VisibleForTesting
   Objects() {
-	this(StandardComparisonStrategy.instance());
+    this(StandardComparisonStrategy.instance());
   }
 
   public Objects(ComparisonStrategy comparisonStrategy) {
-	this.comparisonStrategy = comparisonStrategy;
+    this.comparisonStrategy = comparisonStrategy;
   }
 
   @VisibleForTesting
   public Comparator<?> getComparator() {
-	return comparisonStrategy instanceof ComparatorBasedComparisonStrategy ?
-	    ((ComparatorBasedComparisonStrategy) comparisonStrategy).getComparator() : null;
+    return comparisonStrategy instanceof ComparatorBasedComparisonStrategy ?
+        ((ComparatorBasedComparisonStrategy) comparisonStrategy).getComparator() : null;
   }
 
   @VisibleForTesting
   public ComparisonStrategy getComparisonStrategy() {
-	return comparisonStrategy;
+    return comparisonStrategy;
   }
 
   /**
@@ -107,7 +108,7 @@ public class Objects {
    * @throws AssertionError if the given object is not an instance of the given type.
    */
   public void assertIsInstanceOf(AssertionInfo info, Object actual, Class<?> type) {
-	if (!isInstanceOfClass(actual, type, info)) throw failures.failure(info, shouldBeInstance(actual, type));
+    if (!isInstanceOfClass(actual, type, info)) throw failures.failure(info, shouldBeInstance(actual, type));
   }
 
   /**
@@ -123,23 +124,23 @@ public class Objects {
    * @throws AssertionError if the given object is not an instance of any of the given types.
    */
   public void assertIsInstanceOfAny(AssertionInfo info, Object actual, Class<?>[] types) {
-	if (objectIsInstanceOfOneOfGivenClasses(actual, types, info)) return;
-	throw failures.failure(info, shouldBeInstanceOfAny(actual, types));
+    if (objectIsInstanceOfOneOfGivenClasses(actual, types, info)) return;
+    throw failures.failure(info, shouldBeInstanceOfAny(actual, types));
   }
 
   private boolean objectIsInstanceOfOneOfGivenClasses(Object actual, Class<?>[] types, AssertionInfo info) {
-	checkIsNotNullAndIsNotEmpty(types);
-	assertNotNull(info, actual);
-	for (Class<?> type : types) {
-	  if (type == null) {
-		String format = "The given array of types:<%s> should not have null elements";
-		throw new NullPointerException(format(format, info.representation().toStringOf(types)));
-	  }
-	  if (type.isInstance(actual)) {
-		return true;
-	  }
-	}
-	return false;
+    checkIsNotNullAndIsNotEmpty(types);
+    assertNotNull(info, actual);
+    for (Class<?> type : types) {
+      if (type == null) {
+        String format = "The given array of types:<%s> should not have null elements";
+        throw new NullPointerException(format(format, info.representation().toStringOf(types)));
+      }
+      if (type.isInstance(actual)) {
+        return true;
+      }
+    }
+    return false;
   }
 
   /**
@@ -153,13 +154,13 @@ public class Objects {
    * @throws AssertionError if the given object is an instance of the given type.
    */
   public void assertIsNotInstanceOf(AssertionInfo info, Object actual, Class<?> type) {
-	if (isInstanceOfClass(actual, type, info)) throw failures.failure(info, shouldNotBeInstance(actual, type));
+    if (isInstanceOfClass(actual, type, info)) throw failures.failure(info, shouldNotBeInstance(actual, type));
   }
 
   private boolean isInstanceOfClass(Object actual, Class<?> clazz, AssertionInfo info) {
-	assertNotNull(info, actual);
-	checkTypeIsNotNull(clazz);
-	return clazz.isInstance(actual);
+    assertNotNull(info, actual);
+    checkTypeIsNotNull(clazz);
+    return clazz.isInstance(actual);
   }
 
   /**
@@ -175,8 +176,8 @@ public class Objects {
    * @throws AssertionError if the given object is an instance of any of the given types.
    */
   public void assertIsNotInstanceOfAny(AssertionInfo info, Object actual, Class<?>[] types) {
-	if (!objectIsInstanceOfOneOfGivenClasses(actual, types, info)) return;
-	throw failures.failure(info, shouldNotBeInstanceOfAny(actual, types));
+    if (!objectIsInstanceOfOneOfGivenClasses(actual, types, info)) return;
+    throw failures.failure(info, shouldNotBeInstanceOfAny(actual, types));
   }
 
   /**
@@ -189,17 +190,17 @@ public class Objects {
    * @throws NullPointerException if the given object is null.
    */
   public void assertHasSameClassAs(AssertionInfo info, Object actual, Object other) {
-	if (!haveSameClass(actual, other, info)) throw failures.failure(info, shouldHaveSameClass(actual, other));
+    if (!haveSameClass(actual, other, info)) throw failures.failure(info, shouldHaveSameClass(actual, other));
   }
 
   private boolean haveSameClass(Object actual, Object other, AssertionInfo info) {
-	assertNotNull(info, actual);
-	if (other == null) {
-	  throw new NullPointerException("The given object should not be null");
-	}
-	Class<?> actualClass = actual.getClass();
-	Class<?> otherClass = other.getClass();
-	return actualClass.equals(otherClass);
+    assertNotNull(info, actual);
+    if (other == null) {
+      throw new NullPointerException("The given object should not be null");
+    }
+    Class<?> actualClass = actual.getClass();
+    Class<?> otherClass = other.getClass();
+    return actualClass.equals(otherClass);
   }
 
   /**
@@ -213,7 +214,7 @@ public class Objects {
    * @throws NullPointerException if the given object is null.
    */
   public void assertDoesNotHaveSameClassAs(AssertionInfo info, Object actual, Object other) {
-	if (haveSameClass(actual, other, info)) throw failures.failure(info, shouldNotHaveSameClass(actual, other));
+    if (haveSameClass(actual, other, info)) throw failures.failure(info, shouldNotHaveSameClass(actual, other));
   }
 
   /**
@@ -227,14 +228,14 @@ public class Objects {
    * @throws NullPointerException if the given object is null.
    */
   public void assertIsExactlyInstanceOf(AssertionInfo info, Object actual, Class<?> type) {
-	if (!actualIsExactlyInstanceOfType(actual, type, info))
-	  throw failures.failure(info, shouldBeExactlyInstance(actual, type));
+    if (!actualIsExactlyInstanceOfType(actual, type, info))
+      throw failures.failure(info, shouldBeExactlyInstance(actual, type));
   }
 
   private boolean actualIsExactlyInstanceOfType(Object actual, Class<?> expectedType, AssertionInfo info) {
-	assertNotNull(info, actual);
-	checkTypeIsNotNull(expectedType);
-	return expectedType.equals(actual.getClass());
+    assertNotNull(info, actual);
+    checkTypeIsNotNull(expectedType);
+    return expectedType.equals(actual.getClass());
   }
 
   /**
@@ -248,8 +249,8 @@ public class Objects {
    * @throws NullPointerException if the given object is null.
    */
   public void assertIsNotExactlyInstanceOf(AssertionInfo info, Object actual, Class<?> type) {
-	if (actualIsExactlyInstanceOfType(actual, type, info))
-	  throw failures.failure(info, shouldNotBeExactlyInstance(actual, type));
+    if (actualIsExactlyInstanceOfType(actual, type, info))
+      throw failures.failure(info, shouldNotBeExactlyInstance(actual, type));
   }
 
   /**
@@ -263,14 +264,14 @@ public class Objects {
    * @throws NullPointerException if the given types is null.
    */
   public void assertIsOfAnyClassIn(AssertionInfo info, Object actual, Class<?>[] types) {
-	boolean itemInArray = isOfOneOfGivenTypes(actual, types, info);
-	if (!itemInArray) throw failures.failure(info, shouldBeOfClassIn(actual, types));
+    boolean itemInArray = isOfOneOfGivenTypes(actual, types, info);
+    if (!itemInArray) throw failures.failure(info, shouldBeOfClassIn(actual, types));
   }
 
   private boolean isOfOneOfGivenTypes(Object actual, Class<?>[] types, AssertionInfo info) {
-	assertNotNull(info, actual);
-	if (types == null) throw new NullPointerException("The given types should not be null");
-	return isItemInArray(actual.getClass(), types);
+    assertNotNull(info, actual);
+    if (types == null) throw new NullPointerException("The given types should not be null");
+    return isItemInArray(actual.getClass(), types);
   }
 
   /**
@@ -284,17 +285,17 @@ public class Objects {
    * @throws NullPointerException if the given types is null.
    */
   public void assertIsNotOfAnyClassIn(AssertionInfo info, Object actual, Class<?>[] types) {
-	boolean itemInArray = isOfOneOfGivenTypes(actual, types, info);
-	if (itemInArray) throw failures.failure(info, shouldNotBeOfClassIn(actual, types));
+    boolean itemInArray = isOfOneOfGivenTypes(actual, types, info);
+    if (itemInArray) throw failures.failure(info, shouldNotBeOfClassIn(actual, types));
   }
 
   private void checkIsNotNullAndIsNotEmpty(Class<?>[] types) {
-	if (types == null) {
-	  throw new NullPointerException("The given array of types should not be null");
-	}
-	if (types.length == 0) {
-	  throw new IllegalArgumentException("The given array of types should not be empty");
-	}
+    if (types == null) {
+      throw new NullPointerException("The given array of types should not be null");
+    }
+    if (types.length == 0) {
+      throw new IllegalArgumentException("The given array of types should not be empty");
+    }
   }
 
   /**
@@ -308,10 +309,10 @@ public class Objects {
    *           equal.
    */
   public void assertEqual(AssertionInfo info, Object actual, Object expected) {
-	if (areEqual(actual, expected)) {
-	  return;
-	}
-	throw failures.failure(info, shouldBeEqual(actual, expected, comparisonStrategy, info.representation()));
+    if (areEqual(actual, expected)) {
+      return;
+    }
+    throw failures.failure(info, shouldBeEqual(actual, expected, comparisonStrategy, info.representation()));
   }
 
   /**
@@ -323,10 +324,10 @@ public class Objects {
    * @throws AssertionError if {@code actual} is equal to {@code other}.
    */
   public void assertNotEqual(AssertionInfo info, Object actual, Object other) {
-	if (!areEqual(actual, other)) {
-	  return;
-	}
-	throw failures.failure(info, shouldNotBeEqual(actual, other, comparisonStrategy));
+    if (!areEqual(actual, other)) {
+      return;
+    }
+    throw failures.failure(info, shouldNotBeEqual(actual, other, comparisonStrategy));
   }
 
   /**
@@ -337,7 +338,7 @@ public class Objects {
    * @return true if actual and other are equal (null safe equals check), false otherwise.
    */
   private boolean areEqual(Object actual, Object other) {
-	return comparisonStrategy.areEqual(actual, other);
+    return comparisonStrategy.areEqual(actual, other);
   }
 
   /**
@@ -348,10 +349,10 @@ public class Objects {
    * @throws AssertionError if the given object is not {@code null}.
    */
   public void assertNull(AssertionInfo info, Object actual) {
-	if (actual == null) {
-	  return;
-	}
-	throw failures.failure(info, shouldBeEqual(actual, null, comparisonStrategy, info.representation()));
+    if (actual == null) {
+      return;
+    }
+    throw failures.failure(info, shouldBeEqual(actual, null, comparisonStrategy, info.representation()));
   }
 
   /**
@@ -362,10 +363,10 @@ public class Objects {
    * @throws AssertionError if the given object is {@code null}.
    */
   public void assertNotNull(AssertionInfo info, Object actual) {
-	if (actual != null) {
-	  return;
-	}
-	throw failures.failure(info, shouldNotBeNull());
+    if (actual != null) {
+      return;
+    }
+    throw failures.failure(info, shouldNotBeNull());
   }
 
   /**
@@ -377,10 +378,10 @@ public class Objects {
    * @throws AssertionError if the given objects do not refer to the same object.
    */
   public void assertSame(AssertionInfo info, Object actual, Object expected) {
-	if (actual == expected) {
-	  return;
-	}
-	throw failures.failure(info, shouldBeSame(actual, expected));
+    if (actual == expected) {
+      return;
+    }
+    throw failures.failure(info, shouldBeSame(actual, expected));
   }
 
   /**
@@ -392,10 +393,16 @@ public class Objects {
    * @throws AssertionError if the given objects refer to the same object.
    */
   public void assertNotSame(AssertionInfo info, Object actual, Object other) {
-	if (actual != other) {
-	  return;
-	}
-	throw failures.failure(info, shouldNotBeSame(actual));
+    if (actual != other) {
+      return;
+    }
+    throw failures.failure(info, shouldNotBeSame(actual));
+  }
+
+  public void assertHasToString(AssertionInfo info, Object actual, String expectedToString) {
+    assertNotNull(info, actual);
+    if (!actual.toString().equals(expectedToString))
+      throw failures.failure(info, shouldHaveToString(actual, expectedToString));
   }
 
   /**
@@ -409,12 +416,12 @@ public class Objects {
    * @throws AssertionError if the given object is not present in the given array.
    */
   public void assertIsIn(AssertionInfo info, Object actual, Object[] values) {
-	checkIsNotNullAndNotEmpty(values);
-	assertNotNull(info, actual);
-	if (isItemInArray(actual, values)) {
-	  return;
-	}
-	throw failures.failure(info, shouldBeIn(actual, values, comparisonStrategy));
+    checkIsNotNullAndNotEmpty(values);
+    assertNotNull(info, actual);
+    if (isItemInArray(actual, values)) {
+      return;
+    }
+    throw failures.failure(info, shouldBeIn(actual, values, comparisonStrategy));
   }
 
   /**
@@ -428,21 +435,21 @@ public class Objects {
    * @throws AssertionError if the given object is present in the given array.
    */
   public void assertIsNotIn(AssertionInfo info, Object actual, Object[] values) {
-	checkIsNotNullAndNotEmpty(values);
-	assertNotNull(info, actual);
-	if (!isItemInArray(actual, values)) {
-	  return;
-	}
-	throw failures.failure(info, shouldNotBeIn(actual, values, comparisonStrategy));
+    checkIsNotNullAndNotEmpty(values);
+    assertNotNull(info, actual);
+    if (!isItemInArray(actual, values)) {
+      return;
+    }
+    throw failures.failure(info, shouldNotBeIn(actual, values, comparisonStrategy));
   }
 
   private void checkIsNotNullAndNotEmpty(Object[] values) {
-	if (values == null) {
-	  throw new NullPointerException("The given array should not be null");
-	}
-	if (values.length == 0) {
-	  throw new IllegalArgumentException("The given array should not be empty");
-	}
+    if (values == null) {
+      throw new NullPointerException("The given array should not be null");
+    }
+    if (values.length == 0) {
+      throw new IllegalArgumentException("The given array should not be empty");
+    }
   }
 
   /**
@@ -453,10 +460,10 @@ public class Objects {
    * @return <code>true</code> if given item is in given array, <code>false</code> otherwise.
    */
   private boolean isItemInArray(Object item, Object[] arrayOfValues) {
-	for (Object value : arrayOfValues) {
-	  if (areEqual(value, item)) return true;
-	}
-	return false;
+    for (Object value : arrayOfValues) {
+      if (areEqual(value, item)) return true;
+    }
+    return false;
   }
 
   /**
@@ -470,12 +477,12 @@ public class Objects {
    * @throws AssertionError if the given object is not present in the given collection.
    */
   public void assertIsIn(AssertionInfo info, Object actual, Iterable<?> values) {
-	checkIsNotNullAndNotEmpty(values);
-	assertNotNull(info, actual);
-	if (isActualIn(actual, values)) {
-	  return;
-	}
-	throw failures.failure(info, shouldBeIn(actual, values, comparisonStrategy));
+    checkIsNotNullAndNotEmpty(values);
+    assertNotNull(info, actual);
+    if (isActualIn(actual, values)) {
+      return;
+    }
+    throw failures.failure(info, shouldBeIn(actual, values, comparisonStrategy));
   }
 
   /**
@@ -489,30 +496,30 @@ public class Objects {
    * @throws AssertionError if the given object is present in the given collection.
    */
   public void assertIsNotIn(AssertionInfo info, Object actual, Iterable<?> values) {
-	checkIsNotNullAndNotEmpty(values);
-	assertNotNull(info, actual);
-	if (!isActualIn(actual, values)) {
-	  return;
-	}
-	throw failures.failure(info, shouldNotBeIn(actual, values, comparisonStrategy));
+    checkIsNotNullAndNotEmpty(values);
+    assertNotNull(info, actual);
+    if (!isActualIn(actual, values)) {
+      return;
+    }
+    throw failures.failure(info, shouldNotBeIn(actual, values, comparisonStrategy));
   }
 
   private void checkIsNotNullAndNotEmpty(Iterable<?> values) {
-	if (values == null) {
-	  throw new NullPointerException("The given iterable should not be null");
-	}
-	if (!values.iterator().hasNext()) {
-	  throw new IllegalArgumentException("The given iterable should not be empty");
-	}
+    if (values == null) {
+      throw new NullPointerException("The given iterable should not be null");
+    }
+    if (!values.iterator().hasNext()) {
+      throw new IllegalArgumentException("The given iterable should not be empty");
+    }
   }
 
   private boolean isActualIn(Object actual, Iterable<?> values) {
-	for (Object value : values) {
-	  if (areEqual(value, actual)) {
-		return true;
-	  }
-	}
-	return false;
+    for (Object value : values) {
+      if (areEqual(value, actual)) {
+        return true;
+      }
+    }
+    return false;
   }
 
   /**
@@ -528,32 +535,32 @@ public class Objects {
    * @throws AssertionError if the other object is not an instance of the actual type.
    */
   public <A> void assertIsLenientEqualsToIgnoringNullFields(AssertionInfo info, A actual, A other) {
-	assertNotNull(info, actual);
-	assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
-	List<String> fieldsNames = new LinkedList<>();
-	List<Object> rejectedValues = new LinkedList<>();
-	List<Object> expectedValues = new LinkedList<>();
-	List<String> nullFields = new LinkedList<>();
-	for (Field field : getDeclaredFieldsIncludingInherited(actual.getClass())) {
-	  try {
-		Object otherFieldValue = getFieldOrPropertyValue(other, field.getName());
-		if (otherFieldValue == null) {
-		  nullFields.add(field.getName());
-		} else {
-		  Object actualFieldValue = getFieldOrPropertyValue(actual, field.getName());
-		  if (!otherFieldValue.equals(actualFieldValue)) {
-			fieldsNames.add(field.getName());
-			rejectedValues.add(actualFieldValue);
-			expectedValues.add(otherFieldValue);
-		  }
-		}
-	  } catch (IntrospectionError e) {
-		// Not readable field, skip.
-	  }
-	}
-	if (!fieldsNames.isEmpty())
-	  throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, fieldsNames,
-	                                                                  rejectedValues, expectedValues, nullFields));
+    assertNotNull(info, actual);
+    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
+    List<String> fieldsNames = new LinkedList<>();
+    List<Object> rejectedValues = new LinkedList<>();
+    List<Object> expectedValues = new LinkedList<>();
+    List<String> nullFields = new LinkedList<>();
+    for (Field field : getDeclaredFieldsIncludingInherited(actual.getClass())) {
+      try {
+        Object otherFieldValue = getFieldOrPropertyValue(other, field.getName());
+        if (otherFieldValue == null) {
+          nullFields.add(field.getName());
+        } else {
+          Object actualFieldValue = getFieldOrPropertyValue(actual, field.getName());
+          if (!otherFieldValue.equals(actualFieldValue)) {
+            fieldsNames.add(field.getName());
+            rejectedValues.add(actualFieldValue);
+            expectedValues.add(otherFieldValue);
+          }
+        }
+      } catch (IntrospectionError e) {
+        // Not readable field, skip.
+      }
+    }
+    if (!fieldsNames.isEmpty())
+      throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, fieldsNames,
+                                                                      rejectedValues, expectedValues, nullFields));
   }
 
   /**
@@ -570,30 +577,30 @@ public class Objects {
    * @throws IntrospectionError if a field does not exist in actual.
    */
   public <A> void assertIsEqualToComparingOnlyGivenFields(AssertionInfo info, A actual, A other, String... fields) {
-	assertNotNull(info, actual);
-	assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
-	ByFieldsComparison byFieldsComparison = isEqualToComparingOnlyGivenFields(actual, other, fields);
-	if (byFieldsComparison.isFieldsNamesNotEmpty())
-	  throw failures.failure(info, shouldBeEqualComparingOnlyGivenFields(actual, byFieldsComparison.fieldsNames,
-	                                                                     byFieldsComparison.rejectedValues,
-	                                                                     byFieldsComparison.expectedValues,
-	                                                                     newArrayList(fields)));
+    assertNotNull(info, actual);
+    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
+    ByFieldsComparison byFieldsComparison = isEqualToComparingOnlyGivenFields(actual, other, fields);
+    if (byFieldsComparison.isFieldsNamesNotEmpty())
+      throw failures.failure(info, shouldBeEqualComparingOnlyGivenFields(actual, byFieldsComparison.fieldsNames,
+                                                                         byFieldsComparison.rejectedValues,
+                                                                         byFieldsComparison.expectedValues,
+                                                                         newArrayList(fields)));
   }
 
   private <A> ByFieldsComparison isEqualToComparingOnlyGivenFields(A actual, A other, String[] fields) {
-	List<String> rejectedFieldsNames = new LinkedList<>();
-	List<Object> expectedValues = new LinkedList<>();
-	List<Object> rejectedValues = new LinkedList<>();
-	for (String fieldName : fields) {
-	  Object actualFieldValue = getFieldOrPropertyValue(actual, fieldName);
-	  Object otherFieldValue = getFieldOrPropertyValue(other, fieldName);
-	  if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
-		rejectedFieldsNames.add(fieldName);
-		expectedValues.add(otherFieldValue);
-		rejectedValues.add(actualFieldValue);
-	  }
-	}
-	return new ByFieldsComparison(rejectedFieldsNames, expectedValues, rejectedValues);
+    List<String> rejectedFieldsNames = new LinkedList<>();
+    List<Object> expectedValues = new LinkedList<>();
+    List<Object> rejectedValues = new LinkedList<>();
+    for (String fieldName : fields) {
+      Object actualFieldValue = getFieldOrPropertyValue(actual, fieldName);
+      Object otherFieldValue = getFieldOrPropertyValue(other, fieldName);
+      if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
+        rejectedFieldsNames.add(fieldName);
+        expectedValues.add(otherFieldValue);
+        rejectedValues.add(actualFieldValue);
+      }
+    }
+    return new ByFieldsComparison(rejectedFieldsNames, expectedValues, rejectedValues);
   }
 
   /**
@@ -610,52 +617,52 @@ public class Objects {
    * @throws AssertionError if the other object is not an instance of the actual type.
    */
   public <A> void assertIsEqualToIgnoringGivenFields(AssertionInfo info, A actual, A other, String... fields) {
-	assertNotNull(info, actual);
-	assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
-	ByFieldsComparison byFieldsComparison = isEqualToIgnoringGivenFields(actual, other, fields);
-	if (byFieldsComparison.isFieldsNamesNotEmpty())
-	  throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, byFieldsComparison.fieldsNames,
-	                                                                  byFieldsComparison.rejectedValues,
-	                                                                  byFieldsComparison.expectedValues,
-	                                                                  newArrayList(fields)));
+    assertNotNull(info, actual);
+    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
+    ByFieldsComparison byFieldsComparison = isEqualToIgnoringGivenFields(actual, other, fields);
+    if (byFieldsComparison.isFieldsNamesNotEmpty())
+      throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, byFieldsComparison.fieldsNames,
+                                                                      byFieldsComparison.rejectedValues,
+                                                                      byFieldsComparison.expectedValues,
+                                                                      newArrayList(fields)));
   }
 
   private <A> ByFieldsComparison isEqualToIgnoringGivenFields(A actual, A other, String[] givenIgnoredFields) {
-	Set<Field> declaredFieldsIncludingInherited = getDeclaredFieldsIncludingInherited(actual.getClass());
-	verifyIgnoredFieldsExist(actual, declaredFieldsIncludingInherited, givenIgnoredFields);
-	List<String> fieldsNames = new LinkedList<>();
-	List<Object> expectedValues = new LinkedList<>();
-	List<Object> rejectedValues = new LinkedList<>();
-	Set<String> ignoredFields = newLinkedHashSet(givenIgnoredFields);
-	for (Field field : declaredFieldsIncludingInherited) {
-	  // ignore private field if user has decided not to use them in comparison
-	  if (ignoredFields.contains(field.getName()) || !canReadFieldValue(field, actual)) {
-		continue;
-	  }
-	  Object actualFieldValue = getFieldOrPropertyValue(actual, field.getName());
-	  Object otherFieldValue = getFieldOrPropertyValue(other, field.getName());
-	  if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
-		fieldsNames.add(field.getName());
-		rejectedValues.add(actualFieldValue);
-		expectedValues.add(otherFieldValue);
-	  }
-	}
-	return new ByFieldsComparison(fieldsNames, expectedValues, rejectedValues);
+    Set<Field> declaredFieldsIncludingInherited = getDeclaredFieldsIncludingInherited(actual.getClass());
+    verifyIgnoredFieldsExist(actual, declaredFieldsIncludingInherited, givenIgnoredFields);
+    List<String> fieldsNames = new LinkedList<>();
+    List<Object> expectedValues = new LinkedList<>();
+    List<Object> rejectedValues = new LinkedList<>();
+    Set<String> ignoredFields = newLinkedHashSet(givenIgnoredFields);
+    for (Field field : declaredFieldsIncludingInherited) {
+      // ignore private field if user has decided not to use them in comparison
+      if (ignoredFields.contains(field.getName()) || !canReadFieldValue(field, actual)) {
+        continue;
+      }
+      Object actualFieldValue = getFieldOrPropertyValue(actual, field.getName());
+      Object otherFieldValue = getFieldOrPropertyValue(other, field.getName());
+      if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
+        fieldsNames.add(field.getName());
+        rejectedValues.add(actualFieldValue);
+        expectedValues.add(otherFieldValue);
+      }
+    }
+    return new ByFieldsComparison(fieldsNames, expectedValues, rejectedValues);
   }
 
   private <A> boolean canReadFieldValue(Field field, A actual) {
-	return fieldSupport.isAllowedToRead(field) || propertySupport.publicGetterExistsFor(field.getName(), actual);
+    return fieldSupport.isAllowedToRead(field) || propertySupport.publicGetterExistsFor(field.getName(), actual);
   }
 
   private <A> void verifyIgnoredFieldsExist(A actual, Set<Field> declaredFields, String[] ignoredFields) {
-	Set<String> ignoredFieldsNotDefined = newLinkedHashSet(ignoredFields);
-	for (Field f : declaredFields) {
-	  ignoredFieldsNotDefined.remove(f.getName());
-	}
-	if (!ignoredFieldsNotDefined.isEmpty()) {
-	  throw new IllegalArgumentException(format("Fields to ignore <%s> not defined for type <%s>",
-		                                        ignoredFieldsNotDefined, actual.getClass().getCanonicalName()));
-	}
+    Set<String> ignoredFieldsNotDefined = newLinkedHashSet(ignoredFields);
+    for (Field f : declaredFields) {
+      ignoredFieldsNotDefined.remove(f.getName());
+    }
+    if (!ignoredFieldsNotDefined.isEmpty()) {
+      throw new IllegalArgumentException(format("Fields to ignore <%s> not defined for type <%s>",
+                                                ignoredFieldsNotDefined, actual.getClass().getCanonicalName()));
+    }
   }
 
   /**
@@ -670,19 +677,19 @@ public class Objects {
    * @throws IntrospectionError is field value can't get retrieved.
    */
   private <A> Object getFieldOrPropertyValue(A a, String fieldName) {
-	try {
-	  return fieldSupport.fieldValue(fieldName, Object.class, a);
-	} catch (IntrospectionError e) {
-	  try {
-		// field is not accessible, let's try to get its value from its getter if any.
-		return propertySupport.propertyValueOf(fieldName, Object.class, a);
-	  } catch (IntrospectionError e2) {
-		// this time, we really fail
-		String msg = format("Unable to obtain the value of <'%s'> field/property from <%s>, expecting a public field or getter",
-		                    fieldName, a);
-		throw new IntrospectionError(msg);
-	  }
-	}
+    try {
+      return fieldSupport.fieldValue(fieldName, Object.class, a);
+    } catch (IntrospectionError e) {
+      try {
+        // field is not accessible, let's try to get its value from its getter if any.
+        return propertySupport.propertyValueOf(fieldName, Object.class, a);
+      } catch (IntrospectionError e2) {
+        // this time, we really fail
+        String msg = format("Unable to obtain the value of <'%s'> field/property from <%s>, expecting a public field or getter",
+                            fieldName, a);
+        throw new IntrospectionError(msg);
+      }
+    }
   }
 
   /**
@@ -693,15 +700,15 @@ public class Objects {
    * @return the declared fields of given class and its superclasses.
    */
   private static Set<Field> getDeclaredFieldsIncludingInherited(Class<?> clazz) {
-	if (clazz == null) throw new NullPointerException("expecting Class parameter not to be null");
-	Set<Field> declaredFields = newLinkedHashSet(clazz.getDeclaredFields());
-	// get fields declared in superclass
-	Class<?> superclazz = clazz.getSuperclass();
-	while (superclazz != null && !superclazz.getName().startsWith("java.lang")) {
-	  declaredFields.addAll(newLinkedHashSet(superclazz.getDeclaredFields()));
-	  superclazz = superclazz.getSuperclass();
-	}
-	return declaredFields;
+    if (clazz == null) throw new NullPointerException("expecting Class parameter not to be null");
+    Set<Field> declaredFields = newLinkedHashSet(clazz.getDeclaredFields());
+    // get fields declared in superclass
+    Class<?> superclazz = clazz.getSuperclass();
+    while (superclazz != null && !superclazz.getName().startsWith("java.lang")) {
+      declaredFields.addAll(newLinkedHashSet(superclazz.getDeclaredFields()));
+      superclazz = superclazz.getSuperclass();
+    }
+    return declaredFields;
   }
 
   /**
@@ -715,45 +722,46 @@ public class Objects {
    * @throws AssertionError if other is not an instance of the given type.
    */
   private void assertOtherTypeIsCompatibleWithActualClass(AssertionInfo info, Object other, Class<?> clazz) {
-	if (other == null) throw failures.failure(info, shouldBeInstanceButWasNull("other", clazz));
-	isInstanceOf(other, clazz, info);
+    if (other == null) throw failures.failure(info, shouldBeInstanceButWasNull("other", clazz));
+    isInstanceOf(other, clazz, info);
   }
 
   private void isInstanceOf(Object object, Class<?> clazz, AssertionInfo info) {
-	if (!clazz.isInstance(object)) throw failures.failure(info, shouldBeInstance(object, clazz));
+    if (!clazz.isInstance(object)) throw failures.failure(info, shouldBeInstance(object, clazz));
   }
 
   public boolean areEqualToIgnoringGivenFields(Object actual, Object other, String... fields) {
-	return isEqualToIgnoringGivenFields(actual, other, fields).isFieldsNamesEmpty();
+    return isEqualToIgnoringGivenFields(actual, other, fields).isFieldsNamesEmpty();
   }
 
   public boolean areEqualToComparingOnlyGivenFields(Object actual, Object other, String... fields) {
-	return isEqualToComparingOnlyGivenFields(actual, other, fields).isFieldsNamesEmpty();
+    return isEqualToComparingOnlyGivenFields(actual, other, fields).isFieldsNamesEmpty();
   }
 
   public static class ByFieldsComparison {
 
-	private final List<String> fieldsNames;
-	private final List<Object> expectedValues;
-	private final List<Object> rejectedValues;
-
-	public ByFieldsComparison(final List<String> fieldsNames, final List<Object> expectedValues,
-	                          final List<Object> rejectedValues) {
-	  this.fieldsNames = fieldsNames;
-	  this.expectedValues = expectedValues;
-	  this.rejectedValues = rejectedValues;
-	}
-
-	public ByFieldsComparison() {
-	  this(new ArrayList<String>(), new ArrayList<>(), new ArrayList<>());
-	}
-
-	public boolean isFieldsNamesEmpty() {
-	  return fieldsNames.isEmpty();
-	}
-
-	public boolean isFieldsNamesNotEmpty() {
-	  return !isFieldsNamesEmpty();
-	}
+    private final List<String> fieldsNames;
+    private final List<Object> expectedValues;
+    private final List<Object> rejectedValues;
+
+    public ByFieldsComparison(final List<String> fieldsNames,
+                              final List<Object> expectedValues,
+                              final List<Object> rejectedValues) {
+      this.fieldsNames = fieldsNames;
+      this.expectedValues = expectedValues;
+      this.rejectedValues = rejectedValues;
+    }
+
+    public ByFieldsComparison() {
+      this(new ArrayList<String>(), new ArrayList<>(), new ArrayList<>());
+    }
+
+    public boolean isFieldsNamesEmpty() {
+      return fieldsNames.isEmpty();
+    }
+
+    public boolean isFieldsNamesNotEmpty() {
+      return !isFieldsNamesEmpty();
+    }
   }
 }
diff --git a/src/test/java/org/assertj/core/api/abstract_/AbstractAssert_hasToString_Test.java b/src/test/java/org/assertj/core/api/abstract_/AbstractAssert_hasToString_Test.java
new file mode 100644
index 000000000..3901cf364
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/abstract_/AbstractAssert_hasToString_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.abstract_;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AbstractAssertBaseTest;
+import org.assertj.core.api.ConcreteAssert;
+
+public class AbstractAssert_hasToString_Test extends AbstractAssertBaseTest {
+
+  @Override
+  protected ConcreteAssert invoke_api_method() {
+    return assertions.hasToString("some description");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(objects).assertHasToString(getInfo(assertions), getActual(assertions), "some description");
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveToString_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveToString_create_Test.java
new file mode 100644
index 000000000..1af100e7a
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldHaveToString_create_Test.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveToString.shouldHaveToString;
+
+import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+public class ShouldHaveToString_create_Test {
+
+  @Test
+  public void should_create_error_message() throws Exception {
+    String actual = "c++";
+    String expectedToString = "java";
+    String errorMessage = shouldHaveToString(actual, expectedToString).create(new TestDescription("TEST"),
+                                                                              new StandardRepresentation());
+    assertThat(errorMessage).isEqualTo(format("[TEST] %n" +
+                                              "Expecting actual's toString() to return:%n" +
+                                              "  <\"java\">%n" +
+                                              "but was:%n" +
+                                              "  <\"c++\">"));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertHasToString_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertHasToString_Test.java
new file mode 100644
index 000000000..87fb9126b
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertHasToString_Test.java
@@ -0,0 +1,60 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.objects;
+
+import static org.assertj.core.error.ShouldHaveToString.shouldHaveToString;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.ObjectsBaseTest;
+import org.assertj.core.test.Person;
+import org.junit.Before;
+import org.junit.Test;
+
+public class Objects_assertHasToString_Test extends ObjectsBaseTest {
+
+  private Person actual;
+
+  @Before
+  public void setup() {
+    actual = mock(Person.class);
+    when(actual.toString()).thenReturn("foo");
+  }
+
+  @Test
+  public void should_pass_if_actual_toString_is_the_expected_String() {
+    objects.assertHasToString(someInfo(), actual, "foo");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    objects.assertHasToString(someInfo(), null, "foo");
+  }
+
+  @Test
+  public void should_fail_if_actual_toString_is_not_the_expected_String() {
+    AssertionInfo info = someInfo();
+    try {
+      objects.assertHasToString(info, actual, "bar");
+      failBecauseExpectedAssertionErrorWasNotThrown();
+    } catch (AssertionError err) {
+      verify(failures).failure(info, shouldHaveToString(actual, "bar"));
+    }
+  }
+}
