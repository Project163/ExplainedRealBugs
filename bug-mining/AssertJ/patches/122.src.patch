diff --git a/src/main/java/org/assertj/core/api/AbstractClassAssert.java b/src/main/java/org/assertj/core/api/AbstractClassAssert.java
index 8d3f3008d..c496ffba3 100644
--- a/src/main/java/org/assertj/core/api/AbstractClassAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractClassAssert.java
@@ -151,6 +151,48 @@ public abstract class AbstractClassAssert<S extends AbstractClassAssert<S>> exte
     return myself;
   }
 
+  /**
+   * Verifies that the actual {@code Class} is final (has {@code final} modifier).
+   *
+   * <pre><code class='java'>
+   * // These assertions succeed:
+   * assertThat(String.class).isFinal();
+   * assertThat(Math.class).isFinal();
+   *
+   * // These assertions fail:
+   * assertThat(Object.class).isFinal();
+   * assertThat(Throwable.class).isFinal();
+   * </code></pre>
+   *
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if the actual {@code Class} is not final.
+   */
+  public S isFinal() {
+    classes.assertIsFinal(info, actual);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual {@code Class} is not final (does not have {@code final} modifier).
+   *
+   * <pre><code class='java'>
+   * // These assertions succeed:
+   * assertThat(Object.class).isNotFinal();
+   * assertThat(Throwable.class).isNotFinal();
+   *
+   * // These assertions fail:
+   * assertThat(String.class).isNotFinal();
+   * assertThat(Math.class).isNotFinal();
+   * </code></pre>
+   *
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if the actual {@code Class} is final.
+   */
+  public S isNotFinal() {
+    classes.assertIsNotFinal(info, actual);
+    return myself;
+  }
+
   /**
    * Verifies that the actual {@code Class} has the given {@code Annotation}s.
    * 
diff --git a/src/main/java/org/assertj/core/error/ShouldBeFinal.java b/src/main/java/org/assertj/core/error/ShouldBeFinal.java
new file mode 100644
index 000000000..020f9dc12
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeFinal.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a class is (or is not) final.
+ *
+ * @author Michal Kordas
+ */
+public class ShouldBeFinal extends BasicErrorMessageFactory {
+
+  private ShouldBeFinal(Class<?> actual, boolean positive) {
+    super("%nExpecting:%n  <%s>%n" + (positive ? "to" : "not to") + " be a final class.", actual);
+  }
+
+  /**
+   * Creates a new {@link ShouldBeFinal}.
+   *
+   * @param actual the actual value in the failed assertion.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeFinal(Class<?> actual) {
+    return new ShouldBeFinal(actual, true);
+  }
+
+  /**
+   * Creates a new {@link ShouldBeFinal}.
+   *
+   * @param actual the actual value in the failed assertion.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldNotBeFinal(Class<?> actual) {
+    return new ShouldBeFinal(actual, false);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Classes.java b/src/main/java/org/assertj/core/internal/Classes.java
index abc8f969f..1b18f5cc3 100644
--- a/src/main/java/org/assertj/core/internal/Classes.java
+++ b/src/main/java/org/assertj/core/internal/Classes.java
@@ -15,6 +15,8 @@ package org.assertj.core.internal;
 import static org.assertj.core.error.ShouldBeAnnotation.shouldBeAnnotation;
 import static org.assertj.core.error.ShouldBeAnnotation.shouldNotBeAnnotation;
 import static org.assertj.core.error.ShouldBeAssignableFrom.shouldBeAssignableFrom;
+import static org.assertj.core.error.ShouldBeFinal.shouldBeFinal;
+import static org.assertj.core.error.ShouldBeFinal.shouldNotBeFinal;
 import static org.assertj.core.error.ShouldBeInterface.shouldBeInterface;
 import static org.assertj.core.error.ShouldBeInterface.shouldNotBeInterface;
 import static org.assertj.core.error.ShouldHaveAnnotations.shouldHaveAnnotations;
@@ -24,6 +26,7 @@ import static org.assertj.core.util.Sets.newLinkedHashSet;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
 import java.util.LinkedHashSet;
 import java.util.Set;
 
@@ -45,7 +48,7 @@ public class Classes {
    * @return the singleton instance of this class.
    */
   public static Classes instance() {
-	return INSTANCE;
+    return INSTANCE;
   }
 
   @VisibleForTesting
@@ -62,21 +65,21 @@ public class Classes {
    * @throws AssertionError if the actual {@code Class} is not assignable from all of the {@code others} classes.
    */
   public void assertIsAssignableFrom(AssertionInfo info, Class<?> actual, Class<?>... others) {
-	assertNotNull(info, actual);
-
-	Set<Class<?>> expected = newLinkedHashSet(others);
-	Set<Class<?>> missing = new LinkedHashSet<>();
-	for (Class<?> other : expected) {
-	  classParameterIsNotNull(other);
-	  if (!actual.isAssignableFrom(other)) {
-		missing.add(other);
-	  }
-	}
-
-	if (missing.isEmpty()) {
-	  return;
-	}
-	throw failures.failure(info, shouldBeAssignableFrom(actual, expected, missing));
+    assertNotNull(info, actual);
+
+    Set<Class<?>> expected = newLinkedHashSet(others);
+    Set<Class<?>> missing = new LinkedHashSet<>();
+    for (Class<?> other : expected) {
+      classParameterIsNotNull(other);
+      if (!actual.isAssignableFrom(other)) {
+        missing.add(other);
+      }
+    }
+
+    if (missing.isEmpty()) {
+      return;
+    }
+    throw failures.failure(info, shouldBeAssignableFrom(actual, expected, missing));
   }
 
   /**
@@ -88,12 +91,12 @@ public class Classes {
    * @throws AssertionError if the actual {@code Class} is an interface.
    */
   public void assertIsNotInterface(AssertionInfo info, Class<?> actual) {
-	assertNotNull(info, actual);
+    assertNotNull(info, actual);
 
-	if (!actual.isInterface()) {
-	  return;
-	}
-	throw failures.failure(info, shouldNotBeInterface(actual));
+    if (!actual.isInterface()) {
+      return;
+    }
+    throw failures.failure(info, shouldNotBeInterface(actual));
   }
 
   /**
@@ -105,12 +108,12 @@ public class Classes {
    * @throws AssertionError if the actual {@code Class} is not an interface.
    */
   public void assertIsInterface(AssertionInfo info, Class<?> actual) {
-	assertNotNull(info, actual);
+    assertNotNull(info, actual);
 
-	if (actual.isInterface()) {
-	  return;
-	}
-	throw failures.failure(info, shouldBeInterface(actual));
+    if (actual.isInterface()) {
+      return;
+    }
+    throw failures.failure(info, shouldBeInterface(actual));
   }
 
   /**
@@ -122,12 +125,12 @@ public class Classes {
    * @throws AssertionError if the actual {@code Class} is an annotation.
    */
   public void assertIsNotAnnotation(AssertionInfo info, Class<?> actual) {
-	assertNotNull(info, actual);
+    assertNotNull(info, actual);
 
-	if (!actual.isAnnotation()) {
-	  return;
-	}
-	throw failures.failure(info, shouldNotBeAnnotation(actual));
+    if (!actual.isAnnotation()) {
+      return;
+    }
+    throw failures.failure(info, shouldNotBeAnnotation(actual));
   }
 
   /**
@@ -139,12 +142,38 @@ public class Classes {
    * @throws AssertionError if the actual {@code Class} is not an annotation.
    */
   public void assertIsAnnotation(AssertionInfo info, Class<?> actual) {
-	assertNotNull(info, actual);
+    assertNotNull(info, actual);
 
-	if (actual.isAnnotation()) {
-	  return;
-	}
-	throw failures.failure(info, shouldBeAnnotation(actual));
+    if (actual.isAnnotation()) {
+      return;
+    }
+    throw failures.failure(info, shouldBeAnnotation(actual));
+  }
+
+  /**
+   * Verifies that the actual {@code Class} is final.
+   *
+   * @param info contains information about the assertion.
+   * @param actual the "actual" {@code Class}.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if the actual {@code Class} is not final.
+   */
+  public void assertIsFinal(AssertionInfo info, Class<?> actual) {
+    assertNotNull(info, actual);
+    if (!Modifier.isFinal(actual.getModifiers())) throw failures.failure(info, shouldBeFinal(actual));
+  }
+
+  /**
+   * Verifies that the actual {@code Class} is not final.
+   *
+   * @param info contains information about the assertion.
+   * @param actual the "actual" {@code Class}.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if the actual {@code Class} is final.
+   */
+  public void assertIsNotFinal(AssertionInfo info, Class<?> actual) {
+    assertNotNull(info, actual);
+    if (Modifier.isFinal(actual.getModifiers())) throw failures.failure(info, shouldNotBeFinal(actual));
   }
 
   /**
@@ -157,21 +186,21 @@ public class Classes {
    * @throws AssertionError if the actual {@code Class} doesn't contains all of these annotations.
    */
   public void assertContainsAnnotations(AssertionInfo info, Class<?> actual,
-	                                    @SuppressWarnings("unchecked") Class<? extends Annotation>... annotations) {
-	assertNotNull(info, actual);
-	Set<Class<? extends Annotation>> expected = newLinkedHashSet(annotations);
-	Set<Class<? extends Annotation>> missing = new LinkedHashSet<>();
-	for (Class<? extends Annotation> other : expected) {
-	  classParameterIsNotNull(other);
-	  if (actual.getAnnotation(other) == null) {
-		missing.add(other);
-	  }
-	}
-
-	if (missing.isEmpty()) {
-	  return;
-	}
-	throw failures.failure(info, shouldHaveAnnotations(actual, expected, missing));
+                                        @SuppressWarnings("unchecked") Class<? extends Annotation>... annotations) {
+    assertNotNull(info, actual);
+    Set<Class<? extends Annotation>> expected = newLinkedHashSet(annotations);
+    Set<Class<? extends Annotation>> missing = new LinkedHashSet<>();
+    for (Class<? extends Annotation> other : expected) {
+      classParameterIsNotNull(other);
+      if (actual.getAnnotation(other) == null) {
+        missing.add(other);
+      }
+    }
+
+    if (missing.isEmpty()) {
+      return;
+    }
+    throw failures.failure(info, shouldHaveAnnotations(actual, expected, missing));
   }
 
   /**
@@ -184,22 +213,22 @@ public class Classes {
    * @throws AssertionError if the actual {@code Class} doesn't contains all of the field.
    */
   public void assertHasFields(AssertionInfo info, Class<?> actual, String... fields) {
-	assertNotNull(info, actual);
-	Set<String> expectedFieldNames = newLinkedHashSet(fields);
-	Set<String> missingFieldNames = newLinkedHashSet();
-	Set<String> actualFieldNames = fieldsToName(actual.getFields());
-	if (noMissingFields(actualFieldNames, expectedFieldNames, missingFieldNames)) return;
-	throw failures.failure(info, shouldHaveFields(actual, expectedFieldNames, missingFieldNames));
+    assertNotNull(info, actual);
+    Set<String> expectedFieldNames = newLinkedHashSet(fields);
+    Set<String> missingFieldNames = newLinkedHashSet();
+    Set<String> actualFieldNames = fieldsToName(actual.getFields());
+    if (noMissingFields(actualFieldNames, expectedFieldNames, missingFieldNames)) return;
+    throw failures.failure(info, shouldHaveFields(actual, expectedFieldNames, missingFieldNames));
   }
 
   private static boolean noMissingFields(Set<String> actualFieldNames, Set<String> expectedFieldNames,
-	                                     Set<String> missingFieldNames) {
-	for (String field : expectedFieldNames) {
-	  if (!actualFieldNames.contains(field)) {
-		missingFieldNames.add(field);
-	  }
-	}
-	return missingFieldNames.isEmpty();
+                                         Set<String> missingFieldNames) {
+    for (String field : expectedFieldNames) {
+      if (!actualFieldNames.contains(field)) {
+        missingFieldNames.add(field);
+      }
+    }
+    return missingFieldNames.isEmpty();
   }
 
   /**
@@ -212,24 +241,24 @@ public class Classes {
    * @throws AssertionError if the actual {@code Class} doesn't contains all of the field.
    */
   public void assertHasDeclaredFields(AssertionInfo info, Class<?> actual, String... fields) {
-	assertNotNull(info, actual);
-	Set<String> expectedFieldNames = newLinkedHashSet(fields);
-	Set<String> missingFieldNames = newLinkedHashSet();
-	Set<String> actualFieldNames = fieldsToName(actual.getDeclaredFields());
-	if (noMissingFields(actualFieldNames, expectedFieldNames, missingFieldNames)) return;
-	throw failures.failure(info, shouldHaveDeclaredFields(actual, expectedFieldNames, missingFieldNames));
+    assertNotNull(info, actual);
+    Set<String> expectedFieldNames = newLinkedHashSet(fields);
+    Set<String> missingFieldNames = newLinkedHashSet();
+    Set<String> actualFieldNames = fieldsToName(actual.getDeclaredFields());
+    if (noMissingFields(actualFieldNames, expectedFieldNames, missingFieldNames)) return;
+    throw failures.failure(info, shouldHaveDeclaredFields(actual, expectedFieldNames, missingFieldNames));
   }
 
   private static Set<String> fieldsToName(Field[] fields) {
-	Set<String> fieldsName = new LinkedHashSet<>();
-	for (Field field : fields) {
-	  fieldsName.add(field.getName());
-	}
-	return fieldsName;
+    Set<String> fieldsName = new LinkedHashSet<>();
+    for (Field field : fields) {
+      fieldsName.add(field.getName());
+    }
+    return fieldsName;
   }
 
   private static void assertNotNull(AssertionInfo info, Class<?> actual) {
-	Objects.instance().assertNotNull(info, actual);
+    Objects.instance().assertNotNull(info, actual);
   }
 
   /**
@@ -240,8 +269,8 @@ public class Classes {
    * @throws NullPointerException with an explicit message if the given class is null
    */
   private static void classParameterIsNotNull(Class<?> clazz) {
-	if (clazz == null)
-	  throw new NullPointerException("The class to compare actual with should not be null");
+    if (clazz == null)
+      throw new NullPointerException("The class to compare actual with should not be null");
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/classes/ClassAssert_isFinal_Test.java b/src/test/java/org/assertj/core/api/classes/ClassAssert_isFinal_Test.java
new file mode 100644
index 000000000..639dfdcfc
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/classes/ClassAssert_isFinal_Test.java
@@ -0,0 +1,37 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.classes;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ClassAssert;
+import org.assertj.core.api.ClassAssertBaseTest;
+
+/**
+ * Tests for <code>{@link ClassAssert#isFinal()}</code>.
+ *
+ * @author Michal Kordas
+ */
+public class ClassAssert_isFinal_Test extends ClassAssertBaseTest {
+
+  @Override
+  protected ClassAssert invoke_api_method() {
+    return assertions.isFinal();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(classes).assertIsFinal(getInfo(assertions), getActual(assertions));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/classes/ClassAssert_isNotFinal_Test.java b/src/test/java/org/assertj/core/api/classes/ClassAssert_isNotFinal_Test.java
new file mode 100644
index 000000000..0847b3e3b
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/classes/ClassAssert_isNotFinal_Test.java
@@ -0,0 +1,37 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.classes;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ClassAssert;
+import org.assertj.core.api.ClassAssertBaseTest;
+
+/**
+ * Tests for <code>{@link ClassAssert#isNotFinal()}</code>.
+ *
+ * @author Michal Kordas
+ */
+public class ClassAssert_isNotFinal_Test extends ClassAssertBaseTest {
+
+  @Override
+  protected ClassAssert invoke_api_method() {
+    return assertions.isNotFinal();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(classes).assertIsNotFinal(getInfo(assertions), getActual(assertions));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeFinal_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeFinal_create_Test.java
new file mode 100644
index 000000000..afa060b76
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeFinal_create_Test.java
@@ -0,0 +1,44 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeFinal.shouldBeFinal;
+import static org.assertj.core.error.ShouldBeFinal.shouldNotBeFinal;
+
+import org.assertj.core.internal.TestDescription;
+import org.junit.Test;
+
+public class ShouldBeFinal_create_Test {
+
+  @Test
+  public void should_create_error_message_for_is_final() throws Exception {
+    String error = shouldBeFinal(Object.class).create(new TestDescription("TEST"));
+
+    assertThat(error).isEqualTo(format("[TEST] %n" +
+                                       "Expecting:%n" +
+                                       "  <java.lang.Object>%n" +
+                                       "to be a final class."));
+  }
+
+  @Test
+  public void should_create_error_message_for_is_not_final() throws Exception {
+    String error = shouldNotBeFinal(String.class).create(new TestDescription("TEST"));
+
+    assertThat(error).isEqualTo(format("[TEST] %n" +
+                                       "Expecting:%n" +
+                                       "  <java.lang.String>%n" +
+                                       "not to be a final class."));
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/classes/Classes_assertIsFinal_Test.java b/src/test/java/org/assertj/core/internal/classes/Classes_assertIsFinal_Test.java
new file mode 100644
index 000000000..30926a416
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/classes/Classes_assertIsFinal_Test.java
@@ -0,0 +1,54 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.classes;
+
+import static org.assertj.core.error.ShouldBeFinal.shouldBeFinal;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.ClassesBaseTest;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link org.assertj.core.internal.Classes#assertIsFinal(AssertionInfo, Class)}</code>.
+ *
+ * @author Michal Kordas
+ */
+public class Classes_assertIsFinal_Test extends ClassesBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    classes.assertIsAnnotation(someInfo(), null);
+  }
+
+  @Test
+  public void should_pass_if_actual_is_a_final_class() {
+    classes.assertIsFinal(someInfo(), Math.class);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_a_final_class() {
+    AssertionInfo info = someInfo();
+    try {
+      classes.assertIsFinal(someInfo(), Object.class);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeFinal(Object.class));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/classes/Classes_assertIsNotFinal_Test.java b/src/test/java/org/assertj/core/internal/classes/Classes_assertIsNotFinal_Test.java
new file mode 100644
index 000000000..aafdbc1fc
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/classes/Classes_assertIsNotFinal_Test.java
@@ -0,0 +1,54 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.classes;
+
+import static org.assertj.core.error.ShouldBeFinal.shouldNotBeFinal;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.ClassesBaseTest;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link org.assertj.core.internal.Classes#assertIsFinal(AssertionInfo, Class)}</code>.
+ *
+ * @author Michal Kordas
+ */
+public class Classes_assertIsNotFinal_Test extends ClassesBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    classes.assertIsAnnotation(someInfo(), null);
+  }
+
+  @Test
+  public void should_pass_if_actual_is_not_a_final_class() {
+    classes.assertIsNotFinal(someInfo(), Throwable.class);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_a_final_class() {
+    AssertionInfo info = someInfo();
+    try {
+      classes.assertIsNotFinal(someInfo(), String.class);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldNotBeFinal(String.class));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
