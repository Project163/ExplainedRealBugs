diff --git a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 98610694a..81a559eb6 100644
--- a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api;
 
 import static org.assertj.core.error.ShouldBeEqualByComparingFieldByFieldRecursively.shouldBeEqualByComparingFieldByFieldRecursively;
+import static org.assertj.core.error.ShouldNotBeEqualComparingFieldByFieldRecursively.shouldNotBeEqualComparingFieldByFieldRecursively;
 
 import java.util.Comparator;
 import java.util.Date;
@@ -28,6 +29,7 @@ import org.assertj.core.api.recursive.comparison.ComparisonDifference;
 import org.assertj.core.api.recursive.comparison.FieldLocation;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCalculator;
+// import org.assertj.core.error.ShouldNotBeEqualComparingFieldByFieldRecursively;
 import org.assertj.core.internal.Failures;
 import org.assertj.core.internal.TypeComparators;
 import org.assertj.core.util.CheckReturnValue;
@@ -57,7 +59,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * This is typically useful when actual's {@code equals} was not overridden.
    * <p>
    * The comparison is <b>not symmetrical</b> since it is <b>limited to actual's fields</b>, the algorithm gather all actual's fields
-   * and then compare them to the corresponding expected's fields.
+   * and then compare them to the corresponding expected's fields.<br>
    * It is then possible for the expected object to have more fields than actual which is handy when comparing a base type to a subtype.
    * <p>
    * <strong>Strict/lenient recursive comparison</strong>
@@ -165,6 +167,61 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Asserts that actual object is not equal to the given object based on a recursive property/field by property/field comparison
+   * (including inherited ones).
+   * <p>
+   * This is typically useful when actual's {@code equals} was not overridden.
+   * <p>
+   * The comparison is <b>not symmetrical</b> since it is <b>limited to actual's fields</b>, the algorithm gather all
+   * actual's fields and then compare them to the corresponding expected's fields.<br>
+   * It is then possible for the expected object to have more fields than actual which is handy when comparing
+   * a base type to a subtype.
+   * <p>
+   * This method is based on {@link #isEqualTo(Object)}, you can check out more usages in that method.
+   * <p>
+   * Example
+   * <pre><code class='java'> // equals not overridden in TolkienCharacter
+   * TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
+   * TolkienCharacter frodoClone = new TolkienCharacter("Frodo", 33, HOBBIT);
+   * TolkienCharacter youngFrodo = new TolkienCharacter("Frodo", 22, HOBBIT);
+   *
+   * // Pass as equals compares object references
+   * assertThat(frodo).isNotEqualTo(frodoClone);
+   *
+   * // Fail as frodo and frodoClone are equals when doing a field by field comparison.
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .isNotEqualTo(frodoClone);
+   *
+   * // Pass as one the age fields differ between frodo and youngFrodo.
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .isNotEqualTo(youngFrodo);</code></pre>
+   *
+   * @param other the object to compare {@code actual} to.
+   * @return {@code this} assertions object
+   * @throws AssertionError if the actual object and the given objects are both {@code null}.
+   * @throws AssertionError if the actual and the given objects are equals property/field by property/field recursively.
+   * @see #isEqualTo(Object)
+   * @since 3.17.0
+   */
+  @Override
+  public SELF isNotEqualTo(Object other) {
+    if (actual == other) throw objects.getFailures().failure(info,
+                                                             shouldNotBeEqualComparingFieldByFieldRecursively(actual, other,
+                                                                                                              recursiveComparisonConfiguration,
+                                                                                                              info.representation()));
+    if (other != null && actual != null) {
+      List<ComparisonDifference> differences = determineDifferencesWith(other);
+      if (differences.isEmpty())
+        throw objects.getFailures().failure(info,
+                                            shouldNotBeEqualComparingFieldByFieldRecursively(actual, other,
+                                                                                             recursiveComparisonConfiguration,
+                                                                                             info.representation()));
+    }
+    // either one of actual or other was null (but not both) or there were no differences
+    return myself;
+  }
+
   /**
    * Makes the recursive comparison to ignore all <b>actual null fields</b> (but note that the expected object null fields are used in the comparison).
    * <p>
diff --git a/src/main/java/org/assertj/core/error/ShouldNotBeEqualComparingFieldByFieldRecursively.java b/src/main/java/org/assertj/core/error/ShouldNotBeEqualComparingFieldByFieldRecursively.java
new file mode 100644
index 000000000..7129bf8dd
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldNotBeEqualComparingFieldByFieldRecursively.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
+import org.assertj.core.presentation.Representation;
+
+public class ShouldNotBeEqualComparingFieldByFieldRecursively extends BasicErrorMessageFactory {
+
+  public static ErrorMessageFactory shouldNotBeEqualComparingFieldByFieldRecursively(Object actual, Object other,
+                                                                                     RecursiveComparisonConfiguration recursiveComparisonConfiguration,
+                                                                                     Representation representation) {
+    String recursiveComparisonConfigurationDescription = recursiveComparisonConfiguration.multiLineDescription(representation);
+    return new ShouldNotBeEqualComparingFieldByFieldRecursively("%n" +
+                                                                "Expecting:%n" +
+                                                                "  <%s>%n" +
+                                                                "not to be equal to:%n" +
+                                                                "  <%s>%n" +
+                                                                "when recursively comparing field by field" +
+                                                                "%n" +
+                                                                "The recursive comparison was performed with this configuration:%n"
+                                                                +
+                                                                recursiveComparisonConfigurationDescription, // don't use %s
+                                                                                                             // to avoid AssertJ
+                                                                                                             // formatting String
+                                                                                                             // with ""
+                                                                actual, other);
+  }
+
+  public static ErrorMessageFactory shouldNotBeEqualComparingFieldByFieldRecursively(Object actual) {
+    if (actual == null)
+      return new ShouldNotBeEqualComparingFieldByFieldRecursively("%n" +
+                                                                  "Expecting actual not to be equal to other but both are null.");
+    return new ShouldNotBeEqualComparingFieldByFieldRecursively("%n" +
+                                                                "Expecting actual not to be equal to other but both refer to the same object (actual == other):%n"
+                                                                + "  <%s>%n", actual);
+  }
+
+  private ShouldNotBeEqualComparingFieldByFieldRecursively(String message, Object... arguments) {
+    super(message, arguments);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/RecursiveComparisonAssert_isNotEqualTo_BaseTest.java b/src/test/java/org/assertj/core/api/RecursiveComparisonAssert_isNotEqualTo_BaseTest.java
new file mode 100644
index 000000000..8368edfd7
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/RecursiveComparisonAssert_isNotEqualTo_BaseTest.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
+import org.assertj.core.internal.ObjectsBaseTest;
+import org.junit.jupiter.api.BeforeEach;
+
+import static org.assertj.core.error.ShouldNotBeEqualComparingFieldByFieldRecursively.shouldNotBeEqualComparingFieldByFieldRecursively;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.verify;
+
+public class RecursiveComparisonAssert_isNotEqualTo_BaseTest extends ObjectsBaseTest {
+  public static WritableAssertionInfo info;
+  public RecursiveComparisonConfiguration recursiveComparisonConfiguration;
+
+  @BeforeEach
+  public void setup() {
+    recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+  }
+
+  public void verifyShouldNotBeEqualComparingFieldByFieldRecursivelyCall(Object actual, Object other) {
+    verify(failures).failure(info, shouldNotBeEqualComparingFieldByFieldRecursively(actual,
+                                                                                    other,
+                                                                                    recursiveComparisonConfiguration,
+                                                                                    info.representation()));
+  }
+
+  public AssertionError areNotEqualRecursiveComparisonFailsAsExpected(Object actual, Object other) {
+    RecursiveComparisonAssert<?> recursiveComparisonAssert = new RecursiveComparisonAssert<>(actual,
+                                                                                             recursiveComparisonConfiguration);
+    info = recursiveComparisonAssert.info;
+    recursiveComparisonAssert.objects = objects;
+    return expectAssertionError(() -> recursiveComparisonAssert.isNotEqualTo(other));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isNotEqualTo_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isNotEqualTo_Test.java
new file mode 100644
index 000000000..f6d214347
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isNotEqualTo_Test.java
@@ -0,0 +1,153 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.recursive.comparison.Color.GREEN;
+import static org.assertj.core.test.NeverEqualComparator.NEVER_EQUALS_STRING;
+
+import org.assertj.core.api.RecursiveComparisonAssert_isNotEqualTo_BaseTest;
+import org.assertj.core.internal.objects.data.Person;
+import org.assertj.core.test.CartoonCharacter;
+import org.assertj.core.test.Jedi;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("RecursiveComparisonAssert isNotEqualTo")
+public class RecursiveComparisonAssert_isNotEqualTo_Test extends RecursiveComparisonAssert_isNotEqualTo_BaseTest {
+
+  @Test
+  public void should_pass_when_either_actual_or_expected_is_null() {
+    // GIVEN
+    Person actual = null;
+    Person other = new Person();
+    // THEN
+    assertThat(actual).usingRecursiveComparison()
+                      .isNotEqualTo(other);
+    assertThat(other).usingRecursiveComparison()
+                     .isNotEqualTo(actual);
+  }
+
+  @Test
+  public void should_fail_when_actual_and_expected_are_null() {
+    // GIVEN
+    Person actual = null;
+    Person other = null;
+    // WHEN
+    areNotEqualRecursiveComparisonFailsAsExpected(actual, other);
+    // THEN
+    verifyShouldNotBeEqualComparingFieldByFieldRecursivelyCall(actual, other);
+  }
+
+  @Test
+  public void should_pass_when_expected_is_an_enum_and_actual_is_not() {
+    // GIVEN
+    RecursiveComparisonAssert_isEqualTo_Test.LightString actual = new RecursiveComparisonAssert_isEqualTo_Test.LightString("GREEN");
+    Light other = new Light(GREEN);
+    // THEN
+    assertThat(actual).usingRecursiveComparison()
+                      .isNotEqualTo(other);
+  }
+
+  @Test
+  public void should_fail_when_field_values_are_null() {
+    // GIVEN
+    Jedi actual = new Jedi("Yoda", null);
+    Jedi other = new Jedi("Yoda", null);
+    recursiveComparisonConfiguration.ignoreFields("name");
+    // WHEN
+    areNotEqualRecursiveComparisonFailsAsExpected(actual, other);
+    // THEN
+    verifyShouldNotBeEqualComparingFieldByFieldRecursivelyCall(actual, other);
+  }
+
+  @Test
+  public void should_fail_when_fields_are_equal_even_if_objects_types_differ() {
+    // GIVEN
+    CartoonCharacter actual = new CartoonCharacter("Homer Simpson");
+    Person other = new Person("Homer Simpson");
+    recursiveComparisonConfiguration.ignoreFields("children");
+    // WHEN
+    areNotEqualRecursiveComparisonFailsAsExpected(actual, other);
+    // THEN
+    verifyShouldNotBeEqualComparingFieldByFieldRecursivelyCall(actual, other);
+  }
+
+  @Test
+  public void should_fail_when_all_field_values_equal() {
+    // GIVEN
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi("Luke", "Green");
+    recursiveComparisonConfiguration.ignoreFields("name");
+    //
+    areNotEqualRecursiveComparisonFailsAsExpected(actual, other);
+    // THEN
+    verifyShouldNotBeEqualComparingFieldByFieldRecursivelyCall(actual, other);
+  }
+
+  @Test
+  public void should_fail_when_all_field_values_equal_and_no_fields_are_ignored() {
+    // GIVEN
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi("Yoda", "Green");
+    // WHEN
+    areNotEqualRecursiveComparisonFailsAsExpected(actual, other);
+    // THEN
+    verifyShouldNotBeEqualComparingFieldByFieldRecursivelyCall(actual, other);
+
+  }
+
+  @Test
+  public void should_be_able_to_compare_objects_of_different_types() {
+    // GIVEN
+    CartoonCharacter other = new CartoonCharacter("Homer Simpson");
+    Person actual = new Person("Homer Simpson");
+    // THEN not equal because of children field in CartoonCharacter
+    assertThat(actual).usingRecursiveComparison()
+                      .isNotEqualTo(other);
+  }
+
+  @Test
+  public void should_be_able_to_use_a_comparator_for_specified_type() {
+    // GIVEN
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi(new String("Yoda"), "Green");
+    // THEN
+    assertThat(actual).usingRecursiveComparison()
+                      .withComparatorForType(NEVER_EQUALS_STRING, String.class)
+                      .isNotEqualTo(other);
+  }
+
+  @Test
+  public void should_pass_when_one_property_or_field_to_compare_can_not_be_found() {
+    // GIVEN
+    Jedi actual = new Jedi("Yoda", "Green");
+    Person other = new Person("Yoda");
+    other.neighbour = other;
+    // THEN
+    assertThat(actual).usingRecursiveComparison()
+                      .isNotEqualTo(other);
+  }
+
+  @Test
+  public void should_be_able_to_use_a_comparator_for_specified_fields() {
+    // GIVEN
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi("Yoda", new String("Green"));
+    // THEN
+    assertThat(actual).usingRecursiveComparison()
+                      .withComparatorForFields(NEVER_EQUALS_STRING, "lightSaberColor")
+                      .isNotEqualTo(other);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldNotBeEqualComparingFieldByFieldRecursively_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotBeEqualComparingFieldByFieldRecursively_create_Test.java
new file mode 100644
index 000000000..df25fa752
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldNotBeEqualComparingFieldByFieldRecursively_create_Test.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
+import static org.assertj.core.error.ShouldNotBeEqualComparingFieldByFieldRecursively.shouldNotBeEqualComparingFieldByFieldRecursively;
+
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.presentation.Representation;
+import org.junit.jupiter.api.Test;
+
+public class ShouldNotBeEqualComparingFieldByFieldRecursively_create_Test {
+  private static final TextDescription TEST_DESCRIPTION = new TextDescription("Test");
+  private static final Representation REPRESENTATION = CONFIGURATION_PROVIDER.representation();
+
+  @Test
+  public void should_show_error_message() {
+    // GIVEN
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+    String message = shouldNotBeEqualComparingFieldByFieldRecursively("Yoda", "Luke",
+                                                                      recursiveComparisonConfiguration,
+                                                                      REPRESENTATION).create(TEST_DESCRIPTION, REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting:%n" +
+                                   "  <\"Yoda\">%n" +
+                                   "not to be equal to:%n" +
+                                   "  <\"Luke\">%n" +
+                                   "when recursively comparing field by field" +
+                                   "%n" +
+                                   "The recursive comparison was performed with this configuration:%n%s",
+                                   CONFIGURATION_PROVIDER.representation().toStringOf(recursiveComparisonConfiguration)));
+
+  }
+
+  @Test
+  public void should_show_error_message_with_custom_comparison_configuration() {
+    // GIVEN
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(String.class);
+    recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
+    recursiveComparisonConfiguration.ignoreCollectionOrder(true);
+    String message = shouldNotBeEqualComparingFieldByFieldRecursively("Yoda", "Luke",
+                                                                      recursiveComparisonConfiguration,
+                                                                      REPRESENTATION).create(TEST_DESCRIPTION, REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting:%n" +
+                                   "  <\"Yoda\">%n" +
+                                   "not to be equal to:%n" +
+                                   "  <\"Luke\">%n" +
+                                   "when recursively comparing field by field" +
+                                   "%n" +
+                                   "The recursive comparison was performed with this configuration:%n%s",
+                                   CONFIGURATION_PROVIDER.representation().toStringOf(recursiveComparisonConfiguration)));
+  }
+
+  @Test
+  public void should_show_two_null_object_error_message() {
+    // GIVEN
+    String message = shouldNotBeEqualComparingFieldByFieldRecursively(null).create(TEST_DESCRIPTION, REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting actual not to be equal to other but both are null."));
+  }
+
+  @Test
+  public void should_show_same_object_error_message() {
+    // GIVEN
+    String message = shouldNotBeEqualComparingFieldByFieldRecursively("Luke").create(TEST_DESCRIPTION, REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting actual not to be equal to other but both refer to the same object (actual == other):%n"
+                                   +
+                                   "  <\"Luke\">%n"));
+  }
+}
