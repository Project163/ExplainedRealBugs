diff --git a/src/main/java/org/assertj/core/internal/Strings.java b/src/main/java/org/assertj/core/internal/Strings.java
index 06e213f3b..36d34b271 100644
--- a/src/main/java/org/assertj/core/internal/Strings.java
+++ b/src/main/java/org/assertj/core/internal/Strings.java
@@ -99,6 +99,7 @@ import org.assertj.core.util.VisibleForTesting;
  */
 public class Strings {
 
+  private static final String EMPTY_STRING = "";
   private static final Strings INSTANCE = new Strings();
   private static final String PUNCTUATION_REGEX = "\\p{Punct}";
   private final ComparisonStrategy comparisonStrategy;
@@ -741,7 +742,7 @@ public class Strings {
     if (toNormalize == null) {
       return null;
     }
-    return normalizeWhitespace(toNormalize.toString().replaceAll(PUNCTUATION_REGEX, ""));
+    return normalizeWhitespace(toNormalize.toString().replaceAll(PUNCTUATION_REGEX, EMPTY_STRING));
   }
 
   /**
@@ -766,7 +767,8 @@ public class Strings {
     String normalizedActual = Normalizer.normalize(actual, Normalizer.Form.NFC);
     String normalizedExpected = Normalizer.normalize(expected, Normalizer.Form.NFC);
     if (!java.util.Objects.equals(normalizedActual, normalizedExpected))
-      throw failures.failure(info, shouldBeEqualNormalizingUnicode(actual, expected, normalizedActual, normalizedExpected), normalizedActual, normalizedExpected);
+      throw failures.failure(info, shouldBeEqualNormalizingUnicode(actual, expected, normalizedActual, normalizedExpected),
+                             normalizedActual, normalizedExpected);
   }
 
   /**
@@ -994,7 +996,7 @@ public class Strings {
 
     // convert all values to one char sequence to compare with the actual char sequence
     String strActual = actual.toString();
-    String strSequence = String.join("", sequence);
+    String strSequence = String.join(EMPTY_STRING, sequence);
     if (!stringContains(strActual, strSequence)) {
       throw failures.failure(info, shouldContainSequence(actual, sequence, comparisonStrategy));
     }
@@ -1044,16 +1046,21 @@ public class Strings {
   }
 
   private String removeUpTo(String string, CharSequence toRemove) {
+    // we have already checked that toRemove was not null in doCommonCheckForCharSequence and this point string is not neither
     int index = indexOf(string, toRemove);
     // remove the start of string up to toRemove included
     return string.substring(index + toRemove.length());
   }
 
   private int indexOf(String string, CharSequence toFind) {
+    if (EMPTY_STRING.equals(string) && EMPTY_STRING.equals(toFind.toString())) return 0;
     for (int i = 0; i < string.length(); i++) {
       if (comparisonStrategy.stringStartsWith(string.substring(i), toFind.toString())) return i;
     }
-    return -1;
+    // should not arrive here since we this method is used from assertContainsSubsequence at a step where we know that toFind
+    // was found and we are checking whether it was at the right place/order.
+    throw new IllegalStateException(format("%s should have been found in %s, please raise an assertj-core issue", toFind,
+                                           string));
   }
 
   public void assertXmlEqualsTo(AssertionInfo info, CharSequence actualXml, CharSequence expectedXml) {
@@ -1200,7 +1207,7 @@ public class Strings {
 
   private static String removeNewLines(CharSequence text) {
     String normalizedText = normalizeNewlines(text);
-    return normalizedText.replace("\n", "");
+    return normalizedText.replace("\n", EMPTY_STRING);
   }
 
   private void doCommonCheckForCharSequence(AssertionInfo info, CharSequence actual, CharSequence[] sequence) {
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSubsequence_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSubsequence_Test.java
index 03694e503..e1ccf106e 100644
--- a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSubsequence_Test.java
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSubsequence_Test.java
@@ -12,109 +12,140 @@
  */
 package org.assertj.core.internal.strings;
 
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
 import static org.assertj.core.error.ShouldContainSubsequenceOfCharSequence.shouldContainSubsequence;
 import static org.assertj.core.internal.ErrorMessages.arrayOfValuesToLookForIsEmpty;
 import static org.assertj.core.internal.ErrorMessages.arrayOfValuesToLookForIsNull;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.verify;
 
+import org.assertj.core.api.WritableAssertionInfo;
 import org.assertj.core.internal.StringsBaseTest;
 import org.junit.jupiter.api.Test;
 
 class Strings_assertContainsSubsequence_Test extends StringsBaseTest {
 
+  private static final WritableAssertionInfo INFO = someInfo();
+
   @Test
   void should_pass_if_actual_contains_subsequence() {
-    strings.assertContainsSubsequence(someInfo(), "Yoda", array("Yo", "da"));
+    strings.assertContainsSubsequence(INFO, "Yoda", array("Yo", "da"));
   }
 
   @Test
   void should_pass_if_actual_contains_subsequence_with_values_between() {
     String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
-    String[] sequenceValues = { "{", "title", "A Game of Thrones", "}" };
-    strings.assertContainsSubsequence(someInfo(), actual, sequenceValues);
+    String[] subsequence = { "{", "title", "A Game of Thrones", "}" };
+    strings.assertContainsSubsequence(INFO, actual, subsequence);
   }
 
   @Test
   void should_fail_if_actual_does_not_contain_all_given_strings() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> strings.assertContainsSubsequence(someInfo(), "Yoda", array("Yo", "da", "Han")))
-                                                   .withMessage(shouldContain("Yoda", array("Yo", "da", "Han"), newLinkedHashSet("Han")).create());
+    // GIVEN
+    String actual = "Yoda";
+    String[] subsequence = { "Yo", "da", "Han" };
+    // WHEN
+    expectAssertionError(() -> strings.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContain(actual, subsequence, newLinkedHashSet("Han")));
   }
 
   @Test
   void should_fail_if_actual_contains_values_but_not_in_given_order() {
+    // GIVEN
     String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
-    String[] sequenceValues = { "{", "author", "A Game of Thrones", "}" };
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> strings.assertContainsSubsequence(someInfo(), actual, sequenceValues))
-                                                   .withMessage(shouldContainSubsequence(actual, sequenceValues, 1).create());
+    String[] subsequence = { "{", "author", "A Game of Thrones", "}" };
+    // WHEN
+    expectAssertionError(() -> strings.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, 1));
   }
 
   @Test
   void should_throw_error_if_subsequence_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> strings.assertContainsSubsequence(someInfo(), "Yoda", null))
+    assertThatNullPointerException().isThrownBy(() -> strings.assertContainsSubsequence(INFO, "Yoda", null))
                                     .withMessage(arrayOfValuesToLookForIsNull());
   }
 
   @Test
   void should_throw_error_if_any_value_of_subsequence_is_null() {
-    String[] sequenceValues = { "author", null };
-    assertThatNullPointerException().isThrownBy(() -> strings.assertContainsSubsequence(someInfo(),
-                                                                                        "'author':'George Martin'",
-                                                                                        sequenceValues))
+    // GIVEN
+    String actual = "'author':'George Martin'";
+    String[] subsequence = { "author", null };
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(() -> strings.assertContainsSubsequence(INFO, actual, subsequence))
                                     .withMessage("Expecting CharSequence elements not to be null but found one at index 1");
   }
 
   @Test
   void should_throw_error_if_subsequence_values_is_empty() {
-    assertThatIllegalArgumentException().isThrownBy(() -> strings.assertContainsSubsequence(someInfo(), "Yoda",
-                                                                                            new String[0]))
+    // GIVEN
+    String actual = "Yoda";
+    String[] emptySubsequence = {};
+    // WHEN/THEN
+    assertThatIllegalArgumentException().isThrownBy(() -> strings.assertContainsSubsequence(INFO, actual, emptySubsequence))
                                         .withMessage(arrayOfValuesToLookForIsEmpty());
   }
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> strings.assertContainsSubsequence(someInfo(), null, array("Yo", "da")))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    String actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> strings.assertContainsSubsequence(INFO, actual, array("a", "b")));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_pass_if_actual_contains_subsequence_that_specifies_multiple_times_the_same_value_bug_544() {
-    strings.assertContainsSubsequence(someInfo(), "a-b-c-", array("a", "-", "b", "-", "c"));
-    strings.assertContainsSubsequence(someInfo(), "{ 'title':'A Game of Thrones', 'author':'George Martin'}",
+    strings.assertContainsSubsequence(INFO, "a-b-c-", array("a", "-", "b", "-", "c"));
+    strings.assertContainsSubsequence(INFO, "{ 'title':'A Game of Thrones', 'author':'George Martin'}",
                                       array("George", " ", "Martin"));
   }
 
   @Test
   void should_pass_if_actual_contains_subsequence_according_to_custom_comparison_strategy() {
-    stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(), "Yoda", array("Yo", "da"));
-    stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(), "Yoda", array("Yo", "DA"));
-    stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(), "Yoda", array("YO", "dA"));
+    stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, "Yoda", array("Yo", "da"));
+    stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, "Yoda", array("Yo", "DA"));
+    stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, "Yoda", array("YO", "dA"));
   }
 
   @Test
   void should_fail_if_actual_does_not_contain_subsequence_according_to_custom_comparison_strategy() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(),
-                                                                                                                                            "Yoda",
-                                                                                                                                            array("Yo",
-                                                                                                                                                  "da",
-                                                                                                                                                  "Han")))
-                                                   .withMessage(shouldContain("Yoda", array("Yo", "da", "Han"),
-                                                                              newLinkedHashSet("Han"),
-                                                                              comparisonStrategy).create());
+    // GIVEN
+    String actual = "Yoda";
+    String[] subsequence = { "Yo", "da", "Han" };
+    // WHEN
+    expectAssertionError(() -> stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContain(actual, subsequence, newLinkedHashSet("Han"), comparisonStrategy));
   }
 
   @Test
   void should_fail_if_actual_contains_values_but_not_in_given_order_according_to_custom_comparison_strategy() {
+    // GIVEN
     String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
-    String[] sequenceValues = { "{", "author", "A Game of Thrones", "}" };
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(), actual, sequenceValues))
-                                                   .withMessage(shouldContainSubsequence(actual, sequenceValues, 1, comparisonStrategy).create());
+    String[] subsequence = { "{", "author", "A Game of Thrones", "}" };
+    // WHEN
+    expectAssertionError(() -> stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, 1, comparisonStrategy));
+  }
+
+  @Test
+  void should_pass_if_empty_string_contains_multiple_empty_subsequence_bug_2158() {
+    strings.assertContainsSubsequence(INFO, "", array(""));
+    strings.assertContainsSubsequence(INFO, "", array("", ""));
+    strings.assertContainsSubsequence(INFO, "", array("", "", ""));
+    strings.assertContainsSubsequence(INFO, "", array("", "", "", ""));
   }
 
 }
