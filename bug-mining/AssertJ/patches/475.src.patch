diff --git a/.gitignore b/.gitignore
index bc6eab1bf..3eb148619 100644
--- a/.gitignore
+++ b/.gitignore
@@ -8,6 +8,7 @@ out
 /.settings
 /.classpath
 /.project
+.externalToolBuilders/
 #Other
 /clover.license
 /actual.txt
diff --git a/src/main/java/org/assertj/core/api/AbstractAssert.java b/src/main/java/org/assertj/core/api/AbstractAssert.java
index cc9b331e8..3e5a7e8db 100644
--- a/src/main/java/org/assertj/core/api/AbstractAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractAssert.java
@@ -34,6 +34,7 @@ import java.util.function.Function;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.configuration.ConfigurationProvider;
 import org.assertj.core.description.Description;
@@ -1059,6 +1060,18 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
     return usingRecursiveComparison(new RecursiveComparisonConfiguration());
   }
 
+  // this method is meant to be overridden and made public in subclasses that want to expose it
+  // this would avoid duplicating this code in all subclasses
+  protected RecursiveAssertionAssert usingRecursiveAssertion(RecursiveAssertionConfiguration recursiveAssertionConfiguration) {
+    return new RecursiveAssertionAssert(actual, recursiveAssertionConfiguration);
+  }
+
+  // this method is meant to be overridden and made public in subclasses that want to expose it
+  // this would avoid duplicating this code in all subclasses
+  protected RecursiveAssertionAssert usingRecursiveAssertion() {
+    return new RecursiveAssertionAssert(actual, RecursiveAssertionConfiguration.builder().build());
+  }
+
   /**
    * Extracts the value of given field/property from the object under test and creates a new assertion object using the
    * given assert factory.
diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index fddc02742..62343bd0d 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -53,6 +53,7 @@ import org.assertj.core.annotations.Beta;
 import org.assertj.core.api.filter.FilterOperator;
 import org.assertj.core.api.filter.Filters;
 import org.assertj.core.api.iterable.ThrowingExtractor;
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.condition.Not;
 import org.assertj.core.description.Description;
@@ -2611,6 +2612,101 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return super.usingRecursiveComparison(recursiveComparisonConfiguration).withTypeComparators(comparatorsByType);
   }
 
+  /**
+   * <p>Asserts that the given predicate is met for all fields of the object under test <b>recursively</b> (but not the object itself).</p>
+   *
+   * <p>For example if the object under test is an instance of class A, A has a B field and B a C field then the assertion checks A's B field and B's C field and all C's fields.</p>
+   *
+   * <p>The recursive algorithm employs cycle detection, so object graphs with cyclic references can safely be asserted over without causing looping.</p>
+   *
+   * <p>This method enables recursive asserting using default configuration, which means all fields of all objects have the   
+   * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
+   * <ul>
+   *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
+   * </ul>
+   *
+   * <p>It is possible to assert several predicates over the object graph in a row.</p>
+   *
+   * <p>The classes used in recursive asserting are <em>not</em> thread safe. Care must be taken when running tests in parallel
+   * not to run assertions over object graphs that are being shared between tests.</p>
+   *
+   * <p><strong>Example</strong></p>
+   * <pre><code style='java'> class Author {
+   *   String name;
+   *   String email;
+   *   List&lt;Book&gt; books = new ArrayList&lt;&gt;();
+   *
+   *   Author(String name, String email) {
+   *     this.name = name;
+   *     this.email = email;
+   *   }
+   * }
+   *
+   * class Book {
+   *   String title;
+   *   Author[] authors;
+   *
+   *   Book(String title, Author[] authors) {
+   *     this.title = title;
+   *     this.authors = authors;
+   *   }
+   * }
+   *
+   * Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+   * Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+   * Author kentBeck = new Author("Kent Beck", "k.beck@recursive.test");
+   *
+   * Book noSqlDistilled = new Book("NoSql Distilled", new Author[] {pramodSadalage, martinFowler});
+   * pramodSadalage.books.add(noSqlDistilled);
+   * martinFowler.books.add(noSqlDistilled);
+   *
+   * Book refactoring = new Book("Refactoring", new Author[] {martinFowler, kentBeck});
+   * martinFowler.books.add(refactoring);
+   * kentBeck.books.add(refactoring);
+   *
+   * // assertion succeeds
+   * List&lt;Author&gt; authors = Arrays.asList(pramodSadalage, kentBeck);
+   * assertThat(authors).usingRecursiveAssertion()
+   *                    .allFieldsSatisfy(field -> field != null); </code></pre>
+   *
+   * <p>In case one or more fields in the object graph fails the predicate test, the entire assertion will fail. Failing fields
+   * will be listed in the failure report using a JSON path-ish notation.</p>
+   *
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion() {
+    return super.usingRecursiveAssertion();
+  }
+
+  /**
+   * <p>The same as {@link #usingRecursiveAssertion()}, but this method allows the developer to pass in an explicit recursion
+   * configuration. This configuration gives fine-grained control over what to include in the recursion, such as:</p>
+   *
+   * <ul>
+   *   <li>Exclusion of fields that are null</li>
+   *   <li>Exclusion of fields by path</li>
+   *   <li>Exclusion of fields by type</li>
+   *   <li>Exclusion of primitive fields</li>
+   *   <li>Inclusion of Java Class Library types in the recursive execution</li>
+   *   <li>Treatment of {@link java.util.Collection} and array objects</li>
+   *   <li>Treatment of {@link java.util.Map} objects</li>
+   *   <li>Treatment of Optional and primitive Optional objects</li>
+   * </ul>
+   *
+   * <p>Please refer to the documentation of {@link RecursiveAssertionConfiguration.Builder} for more details.</p>
+   *
+   * @param recursiveAssertionConfiguration The recursion configuration described above.
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion(RecursiveAssertionConfiguration recursiveAssertionConfiguration) {
+    return super.usingRecursiveAssertion(recursiveAssertionConfiguration);
+  }
+
   /**
    * <b><u>Deprecated javadoc</u></b>
    * <p>
diff --git a/src/main/java/org/assertj/core/api/AbstractMapAssert.java b/src/main/java/org/assertj/core/api/AbstractMapAssert.java
index bc5de94e5..0fec11eb0 100644
--- a/src/main/java/org/assertj/core/api/AbstractMapAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractMapAssert.java
@@ -35,6 +35,7 @@ import java.util.function.Function;
 import java.util.stream.Stream;
 
 import org.assertj.core.annotations.Beta;
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.description.Description;
 import org.assertj.core.groups.Tuple;
@@ -2033,6 +2034,104 @@ public abstract class AbstractMapAssert<SELF extends AbstractMapAssert<SELF, ACT
     return super.usingRecursiveComparison(recursiveComparisonConfiguration);
   }
 
+  /**
+   * <p>Asserts that the given predicate is met for all fields of the object under test <b>recursively</b> (but not the object itself).</p>
+   *
+   * <p>For example if the object under test is an instance of class A, A has a B field and B a C field then the assertion checks A's B field and B's C field and all C's fields.</p>
+   *
+   * <p>The recursive algorithm employs cycle detection, so object graphs with cyclic references can safely be asserted over without causing looping.</p>
+   *
+   * <p>This method enables recursive asserting using default configuration, which means all fields of all objects have the   
+   * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
+   * <ul>
+   *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
+   * </ul>
+   *
+   * <p>It is possible to assert several predicates over the object graph in a row.</p>
+   *
+   * <p>The classes used in recursive asserting are <em>not</em> thread safe. Care must be taken when running tests in parallel
+   * not to run assertions over object graphs that are being shared between tests.</p>
+   *
+   * <p><strong>Example</strong></p>
+   * <pre><code style='java'> class Author {
+   *   String name;
+   *   String email;
+   *   List&lt;Book&gt; books = new ArrayList&lt;&gt;();
+   *
+   *   Author(String name, String email) {
+   *     this.name = name;
+   *     this.email = email;
+   *   }
+   * }
+   *
+   * class Book {
+   *   String title;
+   *   Author[] authors;
+   *
+   *   Book(String title, Author[] authors) {
+   *     this.title = title;
+   *     this.authors = authors;
+   *   }
+   * }
+   *  ...
+   *
+   * Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+   * Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+   * Author kentBeck = new Author("Kent Beck", "k.beck@recursive.test");
+   *
+   * Book noSqlDistilled = new Book("NoSql Distilled", new Author[] {pramodSadalage, martinFowler});
+   * pramodSadalage.books.add(noSqlDistilled);
+   * martinFowler.books.add(noSqlDistilled);
+   *
+   * Book refactoring = new Book("Refactoring", new Author[] {martinFowler, kentBeck});
+   * martinFowler.books.add(refactoring);
+   * kentBeck.books.add(refactoring);
+   *
+   * // assertion succeeds
+   * Map&lt;String, Author&gt; authors = new HashMap&lt;&gt;();
+   * authors.put("MF", martinFowler);
+   * authors.put("KB", kentBeck);
+   * assertThat(authors).usingRecursiveAssertion()
+   *                    .allFieldsSatisfy(field -> field != null); </code></pre>
+   *
+   * <p>In case one or more fields in the object graph fails the predicate test, the entire assertion will fail. Failing fields
+   * will be listed in the failure report using a JSON path-ish notation.</p>
+   *
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion() {
+    return super.usingRecursiveAssertion();
+  }
+
+  /**
+   * <p>The same as {@link #usingRecursiveAssertion()}, but this method allows the developer to pass in an explicit recursion
+   * configuration. This configuration gives fine-grained control over what to include in the recursion, such as:</p>
+   *
+   * <ul>
+   *   <li>Exclusion of fields that are null</li>
+   *   <li>Exclusion of fields by path</li>
+   *   <li>Exclusion of fields by type</li>
+   *   <li>Exclusion of primitive fields</li>
+   *   <li>Inclusion of Java Class Library types in the recursive execution</li>
+   *   <li>Treatment of {@link java.util.Collection} and array objects</li>
+   *   <li>Treatment of {@link java.util.Map} objects</li>
+   *   <li>Treatment of Optional and primitive Optional objects</li>
+   * </ul>
+   *
+   * <p>Please refer to the documentation of {@link RecursiveAssertionConfiguration.Builder} for more details.</p>
+   *
+   * @param recursiveAssertionConfiguration The recursion configuration described above.
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion(RecursiveAssertionConfiguration recursiveAssertionConfiguration) {
+    return super.usingRecursiveAssertion(recursiveAssertionConfiguration);
+  }
+
   private static List<Object> flatten(Iterable<Object> collectionToFlatten) {
     List<Object> result = new ArrayList<>();
     for (Object item : collectionToFlatten) {
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 8babce75b..1528e1e9b 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -49,6 +49,7 @@ import org.assertj.core.annotations.Beta;
 import org.assertj.core.api.filter.FilterOperator;
 import org.assertj.core.api.filter.Filters;
 import org.assertj.core.api.iterable.ThrowingExtractor;
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.condition.Not;
 import org.assertj.core.data.Index;
@@ -4003,6 +4004,101 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
     return super.usingRecursiveComparison(recursiveComparisonConfiguration).withTypeComparators(comparatorsByType);
   }
 
+  /**
+   * <p>Asserts that the given predicate is met for all fields of the object under test <b>recursively</b> (but not the object itself).</p>
+   *
+   * <p>For example if the object under test is an instance of class A, A has a B field and B a C field then the assertion checks A's B field and B's C field and all C's fields.</p>
+   *
+   * <p>The recursive algorithm employs cycle detection, so object graphs with cyclic references can safely be asserted over without causing looping.</p>
+   *
+   * <p>This method enables recursive asserting using default configuration, which means all fields of all objects have the  
+   * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
+   * <ul>
+   *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
+   * </ul>
+   *
+   * <p>It is possible to assert several predicates over the object graph in a row.</p>
+   *
+   * <p>The classes used in recursive asserting are <em>not</em> thread safe. Care must be taken when running tests in parallel
+   * not to run assertions over object graphs that are being shared between tests.</p>
+   *
+   * <p><strong>Example</strong></p>
+   * <pre><code style='java'> class Author {
+   *   String name;
+   *   String email;
+   *   List&lt;Book&gt; books = new ArrayList&lt;&gt;();
+   *
+   *   Author(String name, String email) {
+   *     this.name = name;
+   *     this.email = email;
+   *   }
+   * }
+   *
+   * class Book {
+   *   String title;
+   *   Author[] authors;
+   *
+   *   Book(String title, Author[] authors) {
+   *     this.title = title;
+   *     this.authors = authors;
+   *   }
+   * }
+   *
+   * Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+   * Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+   * Author kentBeck = new Author("Kent Beck", "k.beck@recursive.test");
+   *
+   * Book noSqlDistilled = new Book("NoSql Distilled", new Author[] {pramodSadalage, martinFowler});
+   * pramodSadalage.books.add(noSqlDistilled);
+   * martinFowler.books.add(noSqlDistilled);
+   *
+   * Book refactoring = new Book("Refactoring", new Author[] {martinFowler, kentBeck});
+   * martinFowler.books.add(refactoring);
+   * kentBeck.books.add(refactoring);
+   *
+   * // assertion succeeds
+   * Author[] authors = { pramodSadalage, kentBeck };
+   * assertThat(authors).usingRecursiveAssertion()
+   *                    .allFieldsSatisfy(field -> field != null); </code></pre>
+   *
+   * <p>In case one or more fields in the object graph fails the predicate test, the entire assertion will fail. Failing fields
+   * will be listed in the failure report using a JSON path-ish notation.</p>
+   *
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion() {
+    return super.usingRecursiveAssertion();
+  }
+
+  /**
+   * <p>The same as {@link #usingRecursiveAssertion()}, but this method allows the developer to pass in an explicit recursion
+   * configuration. This configuration gives fine-grained control over what to include in the recursion, such as:</p>
+   *
+   * <ul>
+   *   <li>Exclusion of fields that are null</li>
+   *   <li>Exclusion of fields by path</li>
+   *   <li>Exclusion of fields by type</li>
+   *   <li>Exclusion of primitive fields</li>
+   *   <li>Inclusion of Java Class Library types in the recursive execution</li>
+   *   <li>Treatment of {@link java.util.Collection} and array objects</li>
+   *   <li>Treatment of {@link java.util.Map} objects</li>
+   *   <li>Treatment of Optional and primitive Optional objects</li>
+   * </ul>
+   *
+   * <p>Please refer to the documentation of {@link RecursiveAssertionConfiguration.Builder} for more details.</p>
+   *
+   * @param recursiveAssertionConfiguration The recursion configuration described above.
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion(RecursiveAssertionConfiguration recursiveAssertionConfiguration) {
+    return super.usingRecursiveAssertion(recursiveAssertionConfiguration);
+  }
+  
   /**
    * Verifies that the array under test contains a single element and allows to perform assertions on that element.
    * <p>
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
index c621a63bc..a9ea6a48f 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
@@ -27,6 +27,7 @@ import java.util.TreeMap;
 import java.util.function.Function;
 import java.util.stream.Stream;
 
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.description.Description;
 import org.assertj.core.groups.Tuple;
@@ -1201,6 +1202,99 @@ public abstract class AbstractObjectAssert<SELF extends AbstractObjectAssert<SEL
     return super.usingRecursiveComparison(recursiveComparisonConfiguration).withTypeComparators(comparatorByType);
   }
 
+  /**
+   * <p>Asserts that the given predicate is met for all fields of the object under test <b>recursively</b> (but not the object itself).</p>
+   *
+   * <p>For example if the object under test is an instance of class A, A has a B field and B a C field then the assertion checks A's B field and B's C field and all C's fields.</p>
+   *
+   * <p>The recursive algorithm employs cycle detection, so object graphs with cyclic references can safely be asserted over without causing looping.</p>
+   *
+   * <p>This method enables recursive asserting using default configuration, which means all fields of all objects have the  
+   * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
+   * <ul>
+   *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
+   * </ul>
+   *
+   * <p>It is possible to assert several predicates over the object graph in a row.</p>
+   *
+   * <p>The classes used in recursive asserting are <em>not</em> thread safe. Care must be taken when running tests in parallel
+   * not to run assertions over object graphs that are being shared between tests.</p>
+   *
+   * <p>Example:</p>
+   * <pre><code style='java'> class Author {
+   *   String name;
+   *   String email;
+   *   List&lt;Book&gt; books = new ArrayList();
+   *
+   *   Author(String name, String email) {
+   *     this.name = name;
+   *     this.email = email;
+   *   }
+   * }
+   *
+   * class Book {
+   *   String title;
+   *   Author[] authors;
+   *
+   *   Book(String title, Author[] authors) {
+   *     this.title = title;
+   *     this.authors = authors;
+   *   }
+   * }
+   *
+   * Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+   * Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+   * Author kentBeck = new Author("Kent Beck", "k.beck@recursive.test");
+   *
+   * Book noSqlDistilled = new Book("NoSql Distilled", new Author[] {pramodSadalage, martinFowler});
+   * pramodSadalage.books.add(noSqlDistilled);
+   * martinFowler.books.add(noSqlDistilled);
+   *
+   * Book refactoring = new Book("Refactoring", new Author[] {martinFowler, kentBeck});
+   * martinFowler.books.add(refactoring);
+   * kentBeck.books.add(refactoring);
+   *
+   * // assertion succeeds
+   * assertThat(pramodSadalage).usingRecursiveAssertion()
+   *                           .allFieldsSatisfy(field -> field != null); </code></pre>
+   *
+   * <p>In case one or more fields in the object graph fails the predicate test, the entire assertion will fail. Failing fields
+   * will be listed in the failure report using a JSON path-ish notation.</p>
+   *
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion() {
+    return super.usingRecursiveAssertion();
+  }
+
+  /**
+   * <p>The same as {@link #usingRecursiveAssertion()}, but this method allows the developer to pass in an explicit recursion
+   * configuration. This configuration gives fine-grained control over what to include in the recursion, such as:</p>
+   * <ul>
+   *   <li>Exclusion of fields that are null</li>
+   *   <li>Exclusion of fields by path</li>
+   *   <li>Exclusion of fields by type</li>
+   *   <li>Exclusion of primitive fields</li>
+   *   <li>Inclusion of Java Class Library types in the recursive execution</li>
+   *   <li>Treatment of {@link java.util.Collection} and array objects</li>
+   *   <li>Treatment of {@link java.util.Map} objects</li>
+   *   <li>Treatment of Optional and primitive Optional objects</li>
+   * </ul>
+   *
+   * <p>Please refer to the documentation of {@link RecursiveAssertionConfiguration.Builder} for more details.</p>
+   *
+   * @param recursiveAssertionConfiguration The recursion configuration described above.
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion(RecursiveAssertionConfiguration recursiveAssertionConfiguration) {
+    return super.usingRecursiveAssertion(recursiveAssertionConfiguration);
+  }
+
   // override for proxyable friendly AbstractObjectAssert
   protected <T> AbstractObjectAssert<?, T> newObjectAssert(T objectUnderTest) {
     return new ObjectAssert<>(objectUnderTest);
diff --git a/src/main/java/org/assertj/core/api/AbstractOptionalAssert.java b/src/main/java/org/assertj/core/api/AbstractOptionalAssert.java
index ba37ba126..55c4c39b6 100644
--- a/src/main/java/org/assertj/core/api/AbstractOptionalAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractOptionalAssert.java
@@ -26,6 +26,7 @@ import java.util.function.Consumer;
 import java.util.function.Function;
 
 import org.assertj.core.annotations.Beta;
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.ComparisonStrategy;
@@ -545,6 +546,100 @@ public abstract class AbstractOptionalAssert<SELF extends AbstractOptionalAssert
     return super.usingRecursiveComparison(recursiveComparisonConfiguration);
   }
 
+  /**
+   * <p>Asserts that the given predicate is met for all fields of the object under test <b>recursively</b> (but not the object itself).</p>
+   *
+   * <p>For example if the object under test is an instance of class A, A has a B field and B a C field then the assertion checks A's B field and B's C field and all C's fields.</p>
+   *
+   * <p>The recursive algorithm employs cycle detection, so object graphs with cyclic references can safely be asserted over without causing looping.</p>
+   *
+   * <p>This method enables recursive asserting using default configuration, which means all fields of all objects have the   
+   * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
+   * <ul>
+   *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
+   * </ul>
+   *
+   * <p>It is possible to assert several predicates over the object graph in a row.</p>
+   *
+   * <p>The classes used in recursive asserting are <em>not</em> thread safe. Care must be taken when running tests in parallel
+   * not to run assertions over object graphs that are being shared between tests.</p>
+   *
+   * <p><strong>Example</strong></p>
+   * <pre><code style='java'> class Author {
+   *   String name;
+   *   String email;
+   *   List&lt;Book&gt; books = new ArrayList&lt;&gt;();
+   *
+   *   Author(String name, String email) {
+   *     this.name = name;
+   *     this.email = email;
+   *   }
+   * }
+   *
+   * class Book {
+   *   String title;
+   *   Author[] authors;
+   *
+   *   Book(String title, Author[] authors) {
+   *     this.title = title;
+   *     this.authors = authors;
+   *   }
+   * }
+   *
+   * Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+   * Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+   * Author kentBeck = new Author("Kent Beck", "k.beck@recursive.test");
+   *
+   * Book noSqlDistilled = new Book("NoSql Distilled", new Author[] {pramodSadalage, martinFowler});
+   * pramodSadalage.books.add(noSqlDistilled);
+   * martinFowler.books.add(noSqlDistilled);
+   *
+   * Book refactoring = new Book("Refactoring", new Author[] {martinFowler, kentBeck});
+   * martinFowler.books.add(refactoring);
+   * kentBeck.books.add(refactoring);
+   *
+   * // assertion succeeds
+   * assertThat(Optional.of(pramodSadalage)).usingRecursiveAssertion()
+   *                                        .allFieldsSatisfy(field -> field != null); </code></pre>
+   *
+   * <p>In case one or more fields in the object graph fails the predicate test, the entire assertion will fail. Failing fields
+   * will be listed in the failure report using a JSON path-ish notation.</p>
+   *
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion() {
+    return super.usingRecursiveAssertion();
+  }
+
+  /**
+   * <p>The same as {@link #usingRecursiveAssertion()}, but this method allows the developer to pass in an explicit recursion
+   * configuration. This configuration gives fine-grained control over what to include in the recursion, such as:</p>
+   *
+   * <ul>
+   *   <li>Exclusion of fields that are null</li>
+   *   <li>Exclusion of fields by path</li>
+   *   <li>Exclusion of fields by type</li>
+   *   <li>Exclusion of primitive fields</li>
+   *   <li>Inclusion of Java Class Library types in the recursive execution</li>
+   *   <li>Treatment of {@link java.util.Collection} and array objects</li>
+   *   <li>Treatment of {@link java.util.Map} objects</li>
+   *   <li>Treatment of Optional and primitive Optional objects</li>
+   * </ul>
+   *
+   * <p>Please refer to the documentation of {@link RecursiveAssertionConfiguration.Builder} for more details.</p>
+   *
+   * @param recursiveAssertionConfiguration The recursion configuration described above.
+   * @return A new instance of {@link RecursiveAssertionAssert} built with a default {@link RecursiveAssertionConfiguration}.
+   */
+  @Override
+  public RecursiveAssertionAssert usingRecursiveAssertion(RecursiveAssertionConfiguration recursiveAssertionConfiguration) {
+    return super.usingRecursiveAssertion(recursiveAssertionConfiguration);
+  }
+
   private AbstractObjectAssert<?, VALUE> internalGet() {
     isPresent();
     return assertThat(actual.get()).withAssertionState(myself);
diff --git a/src/main/java/org/assertj/core/api/RecursiveAssertionAssert.java b/src/main/java/org/assertj/core/api/RecursiveAssertionAssert.java
new file mode 100644
index 000000000..e10c121ad
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/RecursiveAssertionAssert.java
@@ -0,0 +1,387 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.error.ShouldNotSatisfyPredicateRecursively.shouldNotSatisfyRecursively;
+
+import java.util.List;
+import java.util.Objects;
+import java.util.function.Predicate;
+
+import org.assertj.core.annotations.Beta;
+import org.assertj.core.api.recursive.FieldLocation;
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionDriver;
+
+/**
+ * <p>An assertion that supports asserting a {@link Predicate} over all the fields of an object graph. Cycle avoidance is used,
+ * so a graph that has cyclic references is essentially reduced to a tree by this class (the actual object graph is not changed
+ * of course, it is treated as an immutable value).</p>
+ *
+ * @since 3.24.0
+ */
+@Beta
+public class RecursiveAssertionAssert extends AbstractAssert<RecursiveAssertionAssert, Object> {
+
+  private final RecursiveAssertionConfiguration recursiveAssertionConfiguration;
+  private final RecursiveAssertionDriver recursiveAssertionDriver;
+
+  public RecursiveAssertionAssert(Object o, RecursiveAssertionConfiguration recursiveAssertionConfiguration) {
+    super(o, RecursiveAssertionAssert.class);
+    this.recursiveAssertionConfiguration = recursiveAssertionConfiguration;
+    this.recursiveAssertionDriver = new RecursiveAssertionDriver(recursiveAssertionConfiguration);
+  }
+
+  /**
+   * <p>Asserts that the given predicate is met for all fields of the object under test <b>recursively</b> (but not the object itself).</p>
+   *
+   * <p>For example if the object under test is an instance of class A, A has a B field and B a C field then the assertion checks A's B field and B's C field and all C's fields.</p>
+   *
+   * <p>The recursive algorithm employs cycle detection, so object graphs with cyclic references can safely be asserted over without causing looping.</p>
+   *
+   * <p>This method enables recursive asserting using default configuration, which means all fields of all objects have the  
+   * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
+   * <ul>
+   *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
+   * </ul>
+   *
+   * <p>It is possible to assert several predicates over the object graph in a row.</p>
+   *
+   * <p>The classes used in recursive asserting are <em>not</em> thread safe. Care must be taken when running tests in parallel
+   * not to run assertions over object graphs that are being shared between tests.</p>
+   * 
+   * <p>Example:</p>
+   * <pre><code style='java'> class Author {
+   *   String name;
+   *   String email;
+   *   List&lt;Book&gt; books = new ArrayList&lt;&gt;();
+   *
+   *   Author(String name, String email) {
+   *     this.name = name;
+   *     this.email = email;
+   *   }
+   * }
+   *
+   * class Book {
+   *   String title;
+   *   Author[] authors;
+   *
+   *   Book(String title, Author[] authors) {
+   *     this.title = title;
+   *     this.authors = authors;
+   *   }
+   * }
+   *
+   * Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+   * Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+   * Author kentBeck = new Author("Kent Beck", "k.beck@recursive.test");
+   *
+   * Book noSqlDistilled = new Book("NoSql Distilled", new Author[] {pramodSadalage, martinFowler});
+   * pramodSadalage.books.add(noSqlDistilled);
+   * martinFowler.books.add(noSqlDistilled);
+   * 
+   * Book refactoring = new Book("Refactoring", new Author[] {martinFowler, kentBeck});
+   * martinFowler.books.add(refactoring);
+   * kentBeck.books.add(refactoring);
+   *
+   * // assertion succeeds
+   * assertThat(pramodSadalage).usingRecursiveAssertion()
+   *                           .allFieldsSatisfy(field -> field != null); </code></pre>
+   *
+   * @param predicate The predicate that is recursively applied to all the fields in the object tree of which actual is the root.
+   * @return {@code this} assertions object
+   * @throws AssertionError if one or more fields as described above fail the predicate test.
+   */
+  public RecursiveAssertionAssert allFieldsSatisfy(Predicate<Object> predicate) {
+    // Reset the driver in case this is not the first predicate being run over actual.
+    recursiveAssertionDriver.reset();
+
+    List<FieldLocation> failedFields = recursiveAssertionDriver.assertOverObjectGraph(predicate, actual);
+    if (!failedFields.isEmpty()) {
+      throw objects.getFailures().failure(info, shouldNotSatisfyRecursively(recursiveAssertionConfiguration, failedFields));
+    }
+    return this;
+  }
+
+  /**
+   * Asserts that none of the fields of the object under test graph (i.e. recursively getting the fields) are null (but not the object itself).
+   * <p>
+   * This is a convenience method for a common test, and it is equivalent to {@code allFieldsSatisfy(field -> field != null)}.
+   * <p>
+   * Example:
+   * <pre><code style='java'> class Author {
+   *   String name;
+   *   String email;
+   *   List&lt;Book&gt; books = new ArrayList&lt;&gt;();
+   *
+   *   Author(String name, String email) {
+   *     this.name = name;
+   *     this.email = email;
+   *   }
+   * }
+   *
+   * class Book {
+   *   String title;
+   *   Author[] authors;
+   *
+   *   Book(String title, Author[] authors) {
+   *     this.title = title;
+   *     this.authors = authors;
+   *   }
+   * }
+   *
+   * Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+   * Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+   * Author kentBeck = new Author("Kent Beck", "k.beck@recursive.test");
+   *
+   * Book noSqlDistilled = new Book("NoSql Distilled", new Author[]{pramodSadalage, martinFowler});
+   * pramodSadalage.books.add(noSqlDistilled);
+   * martinFowler.books.add(noSqlDistilled);
+   * 
+   * Book refactoring = new Book("Refactoring", new Author[] {martinFowler, kentBeck});
+   * martinFowler.books.add(refactoring);
+   * kentBeck.books.add(refactoring);
+   *
+   * // assertion succeeds
+   * assertThat(pramodSadalage).usingRecursiveAssertion()
+   *                           .hasNoNullFields(); </code></pre>
+   *
+   * @return {@code this} assertions object
+   * @throws AssertionError if one or more fields as described above are null.
+   */
+  public RecursiveAssertionAssert hasNoNullFields() {
+    return allFieldsSatisfy(Objects::nonNull);
+  }
+
+  /**
+   * Makes the recursive assertion to ignore the specified fields in the object under test.
+   * <p>
+   * When a field is ignored, all its fields are ignored too.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class Person {
+   *   String name;
+   *   String occupation;
+   *   int age;
+   *   Address address = new Address();
+   * }
+   *
+   * class Address {
+   *   int number;
+   *   String street;
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", "Detective", 60);
+   * sherlock.address.street = "Baker Street";
+   * sherlock.address.number = 221;
+   *
+   * // assertion succeeds because Person has only String fields except for address and age (address fields are ignored)
+   * assertThat(sherlock).usingRecursiveAssertion()
+   *                     .ignoringFields("address", "age")
+   *                     .allFieldsSatisfy(field -> field instanceof String);
+   *
+   * // assertion fails because of age, address and address.number fields
+   * assertThat(sherlock).usingRecursiveAssertion()
+   *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+   *
+   * @param fieldsToIgnore the fields to ignore in the object under test.
+   * @return this {@link RecursiveAssertionAssert} to chain other methods.
+   */
+  public RecursiveAssertionAssert ignoringFields(String... fieldsToIgnore) {
+    recursiveAssertionConfiguration.ignoreFields(fieldsToIgnore);
+    return this;
+  }
+
+  /**
+   * Makes the recursive assertion to ignore the fields matching the specified regexes in the object under test.
+   * <p>
+   * When a field is ignored, all its fields are ignored too.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class Person {
+   *   String name;
+   *   String occupation;
+   *   int age;
+   *   Address address = new Address();
+   * }
+   *
+   * class Address {
+   *   int number;
+   *   String street;
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", "Detective", 60);
+   * sherlock.address.street = "Baker Street";
+   * sherlock.address.number = 221;
+   *
+   * // assertion succeeds because Person has only String fields except for address and age (address fields are ignored)
+   * assertThat(sherlock).usingRecursiveAssertion()
+   *                     .ignoringFieldsMatchingRegexes("ad.*", "ag.")
+   *                     .allFieldsSatisfy(field -> field instanceof String);
+   *
+   * // assertion fails because of age and address fields (address.number is ignored)
+   * assertThat(sherlock).usingRecursiveAssertion()
+   *                     .ignoringFieldsMatchingRegexes(".*ber")
+   *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+   *
+   * @param regexes regexes used to ignore fields in the assertion.
+   * @return this {@link RecursiveAssertionAssert} to chain other methods.
+   */
+  public RecursiveAssertionAssert ignoringFieldsMatchingRegexes(String... regexes) {
+    recursiveAssertionConfiguration.ignoreFieldsMatchingRegexes(regexes);
+    return this;
+  }
+
+  /**
+   * Makes the recursive assertion to ignore the object under test fields of the given types.
+   * The fields are ignored if their types <b>exactly match one of the ignored types</b>, for example if a field is a subtype of an ignored type it is not ignored.
+   * <p>
+   * If some object under test fields are null it is not possible to evaluate their types and thus these fields are not ignored.
+   * <p>
+   * When a field is ignored, all its fields are ignored too.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class Person {
+   *   String name;
+   *   String occupation;
+   *   Address address = new Address();
+   * }
+   *
+   * class Address {
+   *   int number;
+   *   String street;
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", "Detective");
+   * sherlock.address.street = "Baker Street";
+   * sherlock.address.number = 221;
+   *
+   * // assertion succeeds because Person has only String fields except for address  (address fields are ignored)
+   * assertThat(sherlock).usingRecursiveAssertion()
+   *                     .ignoringFieldsOfTypes(Address.class)
+   *                     .allFieldsSatisfy(field -> field instanceof String);
+   *
+   * // assertion fails because of address and address.number fields
+   * assertThat(sherlock).usingRecursiveAssertion()
+   *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+   *
+   * @param typesToIgnore the types we want to ignore in the object under test fields.
+   * @return this {@link RecursiveAssertionAssert} to chain other methods.
+   */
+  public RecursiveAssertionAssert ignoringFieldsOfTypes(Class<?>... typesToIgnore) {
+    recursiveAssertionConfiguration.ignoreFieldsOfTypes(typesToIgnore);
+    return this;
+  }
+
+  /**
+   * Choose between running the {@link Predicate} in use over the primitive fields of an object in an object tree or not,
+   * by default asserting over primitives is <em>enabled</em>.
+   * <p>
+   * For example, consider the following class:
+   * <pre><code class='java'> class Example {
+   *    public int primitiveField;
+   *    public String objectField;
+   *  } </code></pre>
+   * <p>
+   * By default, the assertion being applied recursively will be applied to <code>primitiveField</code> and to
+   * <code>objectField</code>. If ignoring primitives it set to true, the assertion will only be applied to <code>objectField</code>.
+   * <p>
+   * If you elect to assert over primitives then it is your own responsibility as a developer to ensure that your
+   * {@link Predicate} can handle (boxed) primitive arguments.</p>
+   *
+   * @return this {@link RecursiveAssertionAssert} to chain other methods.
+   */
+  public RecursiveAssertionAssert ignoringPrimitiveFields() {
+    recursiveAssertionConfiguration.ignorePrimitiveFields(true);
+    return this;
+  }
+
+  /**
+   * Makes the recursive assertion to ignore all null fields.
+   * <p>
+   * <pre><code class='java'> class Person {
+   *   String name;
+   *   String occupation;
+   *   Address address;
+   * }
+   *
+   * class Address {
+   *   int number;
+   *   String street;
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", "Detective");
+   * sherlock.address = null;
+   *
+   * // assertion succeeds as address field is ignored
+   * assertThat(noName).usingRecursiveAssertion()
+   *                   .ignoringAllNullFields()
+   *                   .allFieldsSatisfy(field -> field instanceof String);
+   *
+   * // assertion fails as address, address.number and address.street fields are not evaluated as String, street because it's null.
+   * assertThat(sherlock).usingRecursiveAssertion()
+   *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+   *
+   * @return this {@link RecursiveAssertionAssert} to chain other methods.
+   */
+  public RecursiveAssertionAssert ignoringAllNullFields() {
+    recursiveAssertionConfiguration.ignoreAllNullFields(true);
+    return this;
+  }
+
+  /**
+   * Makes the recursive assertion to use the specified {@link RecursiveAssertionConfiguration.OptionalAssertionPolicy}.
+   * <p>
+   * See {@link RecursiveAssertionConfiguration.OptionalAssertionPolicy} for the different possible policies, by default
+   * {@link RecursiveAssertionConfiguration.OptionalAssertionPolicy#OPTIONAL_VALUE_ONLY} is used.
+   *
+   * @param optionalAssertionPolicy the {@link RecursiveAssertionConfiguration.OptionalAssertionPolicy} to use.
+   * @return this {@link RecursiveAssertionAssert} to chain other methods.
+   */
+  public RecursiveAssertionAssert withOptionalAssertionPolicy(RecursiveAssertionConfiguration.OptionalAssertionPolicy optionalAssertionPolicy) {
+    recursiveAssertionConfiguration.setOptionalAssertionPolicy(optionalAssertionPolicy);
+    return this;
+  }
+
+  /**
+   * Makes the recursive assertion to use the specified {@link RecursiveAssertionConfiguration.CollectionAssertionPolicy}.
+   * <p>
+   * See {@link RecursiveAssertionConfiguration.CollectionAssertionPolicy} for the different possible policies, by default
+   * {@link RecursiveAssertionConfiguration.CollectionAssertionPolicy#ELEMENTS_ONLY} is used.
+   *
+   * @param collectionAssertionPolicy the {@link RecursiveAssertionConfiguration.CollectionAssertionPolicy} to use.
+   * @return this {@link RecursiveAssertionAssert} to chain other methods.
+   */
+  public RecursiveAssertionAssert withCollectionAssertionPolicy(RecursiveAssertionConfiguration.CollectionAssertionPolicy collectionAssertionPolicy) {
+    recursiveAssertionConfiguration.setCollectionAssertionPolicy(collectionAssertionPolicy);
+    return this;
+  }
+
+  /**
+   * Makes the recursive assertion to use the specified {@link RecursiveAssertionConfiguration.MapAssertionPolicy}.
+   * <p>
+   * See {@link RecursiveAssertionConfiguration.MapAssertionPolicy} for the different possible policies, by default
+   * {@link RecursiveAssertionConfiguration.MapAssertionPolicy#MAP_VALUES_ONLY} is used.
+   *
+   * @param mapAssertionPolicy the {@link RecursiveAssertionConfiguration.MapAssertionPolicy} to use.
+   * @return this {@link RecursiveAssertionAssert} to chain other methods.
+   */
+  public RecursiveAssertionAssert withMapAssertionPolicy(RecursiveAssertionConfiguration.MapAssertionPolicy mapAssertionPolicy) {
+    recursiveAssertionConfiguration.setMapAssertionPolicy(mapAssertionPolicy);
+    return this;
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java b/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java
new file mode 100644
index 000000000..468ef5e86
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java
@@ -0,0 +1,245 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive;
+
+import static java.lang.String.format;
+import static java.util.Arrays.stream;
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.regex.Pattern;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.RecursiveComparisonAssert;
+import org.assertj.core.util.Strings;
+
+public abstract class AbstractRecursiveOperationConfiguration {
+
+  protected static final String DEFAULT_DELIMITER = ", ";
+
+  private final Set<String> ignoredFields = new LinkedHashSet<>();
+  private final List<Pattern> ignoredFieldsRegexes = new ArrayList<>();
+  private final Set<Class<?>> ignoredTypes = new LinkedHashSet<>();
+
+  protected AbstractRecursiveOperationConfiguration(AbstractBuilder<?> builder) {
+    ignoreFields(builder.ignoredFields);
+    ignoreFieldsMatchingRegexes(builder.ignoredFieldsMatchingRegexes);
+    ignoreFieldsOfTypes(builder.ignoredTypes);
+  }
+
+  protected AbstractRecursiveOperationConfiguration() {
+  }
+
+  /**
+   * Adds the given fields to the set of fields from the object under test to ignore in the recursive comparison.
+   * <p>
+   * The fields are ignored by name, not by value.
+   * <p>
+   * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFields(String...)} for examples.
+   *
+   * @param fieldsToIgnore the fields of the object under test to ignore in the comparison.
+   */
+  public void ignoreFields(String... fieldsToIgnore) {
+    List<String> fieldLocations = list(fieldsToIgnore);
+    ignoredFields.addAll(fieldLocations);
+  }
+
+  /**
+   * Returns the set of fields from the object under test to ignore in the recursive comparison.
+   *
+   * @return the set of fields from the object under test to ignore in the recursive comparison.
+   */
+  public Set<String> getIgnoredFields() {
+    return ignoredFields;
+  }
+
+  /**
+   * Allows to ignore in the recursive comparison the object under test fields matching the given regexes. The given regexes are added to the already registered ones.
+   * <p>
+   * See {@link RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...)} for examples.
+   *
+   * @param regexes regexes used to ignore fields in the comparison.
+   */
+  public void ignoreFieldsMatchingRegexes(String... regexes) {
+    List<Pattern> patterns = Stream.of(regexes)
+                                   .map(Pattern::compile)
+                                   .collect(toList());
+    ignoredFieldsRegexes.addAll(patterns);
+  }
+
+  public List<Pattern> getIgnoredFieldsRegexes() {
+    return ignoredFieldsRegexes;
+  }
+
+  /**
+   * Makes the recursive assertion to ignore the object under test fields of the given types.
+   * The fields are ignored if their types <b>exactly match one of the ignored types</b>, for example if a field is a subtype of an ignored type it is not ignored.
+   * <p>
+   * If some object under test fields are null it is not possible to evaluate their types and thus these fields are not ignored.
+   * <p>
+   * Example:
+   * <pre><code class='java'> public class Person {
+   *   String name;
+   *   String occupation;
+   *   Address address = new Address();
+   * }
+   *
+   * public static class Address {
+   *   int number;
+   *   String street;
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", "Detective");
+   * sherlock.address.street = "Baker Street";
+   * sherlock.address.number = 221;
+   *
+   * // assertion succeeds Person has only String fields except for address
+   * assertThat(sherlock).usingRecursiveAssertion()
+   *                     .ignoringFieldsOfTypes(Address.class)
+   *                     .allFieldsSatisfy(field -> field instanceof String);
+   *
+   * // assertion fails because of address and address.number
+   * assertThat(sherlock).usingRecursiveComparison()
+   *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+   *
+   * @param types the types of the object under test to ignore in the comparison.
+   */
+  public void ignoreFieldsOfTypes(Class<?>... types) {
+    stream(types).map(AbstractRecursiveOperationConfiguration::asWrapperIfPrimitiveType).forEach(ignoredTypes::add);
+  }
+
+  private static Class<?> asWrapperIfPrimitiveType(Class<?> type) {
+    if (!type.isPrimitive()) return type;
+    if (type.equals(boolean.class)) return Boolean.class;
+    if (type.equals(byte.class)) return Byte.class;
+    if (type.equals(int.class)) return Integer.class;
+    if (type.equals(short.class)) return Short.class;
+    if (type.equals(char.class)) return Character.class;
+    if (type.equals(float.class)) return Float.class;
+    if (type.equals(double.class)) return Double.class;
+    // should not arrive here since we have tested primitive types first
+    return type;
+  }
+
+  /**
+   * Returns the set of fields from the object under test types to ignore in the recursive comparison.
+   *
+   * @return the set of fields from the object under test types to ignore in the recursive comparison.
+   */
+  public Set<Class<?>> getIgnoredTypes() {
+    return ignoredTypes;
+  }
+
+
+  protected void describeIgnoredFields(StringBuilder description) {
+    if (!getIgnoredFields().isEmpty())
+      description.append(format("- the following fields were ignored in the comparison: %s%n", describeIgnoredFields()));
+  }
+
+  protected void describeIgnoredFieldsRegexes(StringBuilder description) {
+    if (!getIgnoredFieldsRegexes().isEmpty())
+      description.append(format("- the fields matching the following regexes were ignored in the comparison: %s%n",
+                                describeRegexes(getIgnoredFieldsRegexes())));
+  }
+
+  protected String describeIgnoredTypes() {
+    List<String> typesDescription = getIgnoredTypes().stream()
+                                                     .map(Class::getName)
+                                                     .collect(toList());
+    return join(typesDescription);
+  }
+
+  protected String describeRegexes(List<Pattern> regexes) {
+    List<String> fieldsDescription = regexes.stream()
+                                            .map(Pattern::pattern)
+                                            .collect(toList());
+    return join(fieldsDescription);
+  }
+
+  protected static String join(Collection<String> typesDescription) {
+    return Strings.join(typesDescription).with(DEFAULT_DELIMITER);
+  }
+
+  public boolean matchesAnIgnoredFieldRegex(FieldLocation fieldLocation) {
+    return getIgnoredFieldsRegexes().stream()
+                                    .anyMatch(regex -> regex.matcher(fieldLocation.getPathToUseInRules()).matches());
+  }
+
+  public boolean matchesAnIgnoredField(FieldLocation fieldLocation) {
+    return getIgnoredFields().stream().anyMatch(fieldLocation::matches);
+  }
+
+  private String describeIgnoredFields() {
+    return join(getIgnoredFields());
+  }
+
+  protected static class AbstractBuilder<BUILDER_TYPE extends AbstractBuilder<BUILDER_TYPE>> {
+    private final BUILDER_TYPE thisBuilder;
+
+    private String[] ignoredFields = {};
+    private String[] ignoredFieldsMatchingRegexes = {};
+    private Class<?>[] ignoredTypes = {};
+
+    @SuppressWarnings("unchecked")
+    protected AbstractBuilder(Class<? extends AbstractBuilder<BUILDER_TYPE>> selfType) {
+      thisBuilder = (BUILDER_TYPE) selfType.cast(this);
+    }
+
+    /**
+     * Adds the given fields to the set of fields from the object under test to ignore in the recursive comparison. Nested fields can be specified like this: home.address.street.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFields(String...)} for examples.
+     *
+     * @param fieldsToIgnore the fields of the object under test to ignore in the comparison.
+     * @return this builder.
+     */
+    public BUILDER_TYPE withIgnoredFields(String... fieldsToIgnore) {
+      this.ignoredFields = fieldsToIgnore;
+      return thisBuilder;
+    }
+
+    /**
+     * Allows to ignore in the recursive comparison the object under test fields matching the given regexes. The given regexes are added to the already registered ones.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...)} for examples.
+     *
+     * @param regexes regexes used to ignore fields in the comparison.
+     * @return this builder.
+     */
+    public BUILDER_TYPE withIgnoredFieldsMatchingRegexes(String... regexes) {
+      this.ignoredFieldsMatchingRegexes = regexes;
+      return thisBuilder;
+    }
+
+    /**
+     * Adds the given types to the list fields from the object under test types to ignore in the recursive comparison.
+     * The fields are ignored if their types exactly match one of the ignored types, if a field is a subtype of an ignored type it won't be ignored.
+     * <p>
+     * Note that if some object under test fields are null, they are not ignored by this method as their type can't be evaluated.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFieldsOfTypes(Class...)} for examples.
+     *
+     * @param types the types of the object under test to ignore in the comparison.
+     * @return this builder.
+     */
+    public BUILDER_TYPE withIgnoredFieldsOfTypes(Class<?>... types) {
+      this.ignoredTypes = types;
+      return thisBuilder;
+    }
+  }
+}
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java b/src/main/java/org/assertj/core/api/recursive/FieldLocation.java
similarity index 94%
rename from src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
rename to src/main/java/org/assertj/core/api/recursive/FieldLocation.java
index c97446056..d0433b3b2 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
+++ b/src/main/java/org/assertj/core/api/recursive/FieldLocation.java
@@ -10,7 +10,7 @@
  *
  * Copyright 2012-2022 the original author or authors.
  */
-package org.assertj.core.api.recursive.comparison;
+package org.assertj.core.api.recursive;
 
 import static java.util.Collections.emptyList;
 import static java.util.Collections.unmodifiableList;
@@ -41,11 +41,11 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     this(list(s.split("\\.")));
   }
 
-  boolean matches(FieldLocation field) {
+  public boolean matches(FieldLocation field) {
     return pathToUseInRules.equals(field.pathToUseInRules);
   }
 
-  boolean matches(String fieldPath) {
+  public boolean matches(String fieldPath) {
     return pathToUseInRules.equals(fieldPath);
   }
 
@@ -57,7 +57,7 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     return pathToUseInRules;
   }
 
-  FieldLocation field(String field) {
+  public FieldLocation field(String field) {
     List<String> decomposedPathWithField = new ArrayList<>(decomposedPath);
     decomposedPathWithField.add(field);
     return new FieldLocation(decomposedPathWithField);
@@ -99,12 +99,16 @@ public final class FieldLocation implements Comparable<FieldLocation> {
                .collect(joining("."));
   }
 
+  public String getPathToUseInErrorReport() {
+    return String.join(".", decomposedPath);
+  }
+
   public String getFieldName() {
     if (decomposedPath.isEmpty()) return "";
     return decomposedPath.get(decomposedPath.size() - 1);
   }
 
-  static FieldLocation rootFieldLocation() {
+  public static FieldLocation rootFieldLocation() {
     return new FieldLocation(emptyList());
   }
 
diff --git a/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionConfiguration.java b/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionConfiguration.java
new file mode 100644
index 000000000..1fb8ae9b5
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionConfiguration.java
@@ -0,0 +1,732 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.ELEMENTS_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_VALUES_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_VALUE_ONLY;
+import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
+
+import java.util.Collection;
+import java.util.Objects;
+import java.util.function.Predicate;
+
+import org.assertj.core.api.RecursiveAssertionAssert;
+import org.assertj.core.api.recursive.AbstractRecursiveOperationConfiguration;
+
+// Add support for comparedFields
+
+/**
+ * Configuration for recursive assertions.
+ *
+ * @since 3.24.0
+ */
+public class RecursiveAssertionConfiguration extends AbstractRecursiveOperationConfiguration {
+
+  private boolean ignorePrimitiveFields;
+  private final boolean skipJavaLibraryTypeObjects;
+  private CollectionAssertionPolicy collectionAssertionPolicy;
+  private MapAssertionPolicy mapAssertionPolicy;
+  private OptionalAssertionPolicy optionalAssertionPolicy;
+  private boolean ignoreAllNullFields;
+
+  private RecursiveAssertionConfiguration(Builder builder) {
+    super(builder);
+    this.ignorePrimitiveFields = builder.ignorePrimitiveFields;
+    this.skipJavaLibraryTypeObjects = builder.skipJavaLibraryTypeObjects;
+    this.collectionAssertionPolicy = builder.collectionAssertionPolicy;
+    this.mapAssertionPolicy = builder.mapAssertionPolicy;
+    this.optionalAssertionPolicy = builder.optionalAssertionPolicy;
+    this.ignoreAllNullFields = builder.ignoreAllNullFields;
+  }
+
+  /**
+   * Choose between running the {@link Predicate} in use over the primitive fields of an object in an object tree or not,
+   * by default asserting over primitives is <em>enabled</em>.
+   * <p>
+   * For example, consider the following class:
+   * <pre><code class='java'> class Example {
+   *    public int primitiveField;
+   *    public String objectField;
+   *  } </code></pre>
+   * <p>
+   * By default, the assertion being applied recursively is applied to <code>primitiveField</code> and to
+   * <code>objectField</code>. If ignoring primitives it set to true, the assertion will only be applied to <code>objectField</code>.
+   * <p>
+   * If you elect to assert over primitives then it is your own responsibility as a developer to ensure that your
+   * {@link Predicate} can handle (boxed) primitive arguments.</p>
+   */
+  public void ignorePrimitiveFields(boolean ignorePrimitiveFields) {
+    this.ignorePrimitiveFields = ignorePrimitiveFields;
+  }
+
+  /**
+   * Makes the recursive assertion to ignore all null fields.
+   * <p>
+   * Example: see {@link RecursiveAssertionAssert#ignoringAllNullFields()}
+   *
+   * @param ignoreAllNullFields whether to ignore empty optional fields in the recursive comparison
+   */
+  public void ignoreAllNullFields(boolean ignoreAllNullFields) {
+    this.ignoreAllNullFields = ignoreAllNullFields;
+  }
+
+  /**
+   * Makes the recursive assertion to ignore the specified fields in the object under test.
+   * <p>
+   * When a field is ignored, all its fields are ignored too.
+   * <p>
+   * Example: see {@link RecursiveAssertionAssert#ignoringFields(String...)}
+   *
+   * @param fieldsToIgnore the fields to ignore in the object under test.
+   */
+  @Override
+  public void ignoreFields(String... fieldsToIgnore) {
+    super.ignoreFields(fieldsToIgnore);
+  }
+
+  /**
+   * Makes the recursive assertion to ignore the fields matching the specified regexes in the object under test.
+   * <p>
+   * When a field is ignored, all its fields are ignored too.
+   * <p>
+   * Example: see {@link RecursiveAssertionAssert#ignoringFieldsMatchingRegexes(String...)}
+   *
+   * @param regexes regexes used to ignore fields in the assertion.
+   */
+  @Override
+  public void ignoreFieldsMatchingRegexes(String... regexes) {
+    super.ignoreFieldsMatchingRegexes(regexes);
+  }
+
+  /**
+   * Makes the recursive assertion to ignore the object under test fields of the given types.
+   * The fields are ignored if their types <b>exactly match one of the ignored types</b>, for example if a field is a subtype of an ignored type it is not ignored.
+   * <p>
+   * If some object under test fields are null it is not possible to evaluate their types and thus these fields are not ignored.
+   * <p>
+   * When a field is ignored, all its fields are ignored too.
+   * <p>
+   * Example: see {@link RecursiveAssertionAssert#ignoringFieldsOfTypes(Class[])}
+   *
+   * @param types the types we want to ignore in the object under test fields.
+   */
+  @Override
+  public void ignoreFieldsOfTypes(Class<?>... types) {
+    super.ignoreFieldsOfTypes(types);
+  }
+
+  /**
+   * Makes the recursive assertion to use the specified {@link OptionalAssertionPolicy}.
+   *
+   * @param optionalAssertionPolicy the {@link OptionalAssertionPolicy} to use.
+   */
+  public void setOptionalAssertionPolicy(OptionalAssertionPolicy optionalAssertionPolicy) {
+    this.optionalAssertionPolicy = optionalAssertionPolicy;
+  }
+
+  /**
+   * Makes the recursive assertion to use the specified {@link MapAssertionPolicy}.
+   *
+   * @param mapAssertionPolicy the {@link MapAssertionPolicy} to use.
+   */
+  public void setMapAssertionPolicy(MapAssertionPolicy mapAssertionPolicy) {
+    this.mapAssertionPolicy = mapAssertionPolicy;
+  }
+
+  /**
+   * Makes the recursive assertion to use the specified {@link CollectionAssertionPolicy}.
+   *
+   * @param collectionAssertionPolicy the {@link CollectionAssertionPolicy} to use.
+   */
+  public void setCollectionAssertionPolicy(CollectionAssertionPolicy collectionAssertionPolicy) {
+    this.collectionAssertionPolicy = collectionAssertionPolicy;
+  }
+
+  @Override
+  public String toString() {
+    CONFIGURATION_PROVIDER.representation();
+    StringBuilder description = new StringBuilder();
+    describeIgnoreAllNullFields(description);
+    describeIgnoredFields(description);
+    describeIgnoredFieldsRegexes(description);
+    describeIgnoredFieldsOfTypes(description);
+    describeIgnorePrimitiveFields(description);
+    describeSkipJCLTypeObjects(description);
+    describeCollectionAssertionPolicy(description);
+    describeMapAssertionPolicy(description);
+    describeOptionalAssertionPolicy(description);
+    return description.toString();
+  }
+
+  boolean shouldIgnorePrimitiveFields() {
+    return ignorePrimitiveFields;
+  }
+
+  boolean shouldSkipJavaLibraryTypeObjects() {
+    return skipJavaLibraryTypeObjects;
+  }
+
+  CollectionAssertionPolicy getCollectionAssertionPolicy() {
+    return collectionAssertionPolicy;
+  }
+
+  MapAssertionPolicy getMapAssertionPolicy() {
+    return mapAssertionPolicy;
+  }
+
+  OptionalAssertionPolicy getOptionalAssertionPolicy() {
+    return optionalAssertionPolicy;
+  }
+
+  // TODO test
+  boolean shouldIgnoreMap() {
+    return mapAssertionPolicy == MAP_VALUES_ONLY;
+  }
+
+  boolean shouldIgnoreOptional() {
+    return optionalAssertionPolicy == OPTIONAL_VALUE_ONLY;
+  }
+
+  // TODO test
+  boolean shouldIgnoreContainer() {
+    return collectionAssertionPolicy == ELEMENTS_ONLY;
+  }
+
+  boolean shouldIgnoreAllNullFields() {
+    return this.ignoreAllNullFields;
+  }
+
+  private void describeIgnoreAllNullFields(StringBuilder description) {
+    if (shouldIgnoreAllNullFields()) description.append(format("- all null fields were ignored in the assertion%n"));
+  }
+
+  private void describeIgnorePrimitiveFields(StringBuilder description) {
+    if (shouldIgnorePrimitiveFields())
+      description.append(format("- primitive fields were ignored in the recursive assertion%n"));
+  }
+
+  private void describeSkipJCLTypeObjects(StringBuilder description) {
+    if (!shouldSkipJavaLibraryTypeObjects())
+      description.append(format("- fields from Java Class Library types (java.* or javax.*) were included in the recursive assertion%n"));
+    else
+      description.append(format("- fields from Java Class Library types (java.* or javax.*) were excluded in the recursive assertion%n"));
+  }
+
+  private void describeCollectionAssertionPolicy(StringBuilder description) {
+    description.append(format("- the collection assertion policy was %s%n", getCollectionAssertionPolicy().name()));
+  }
+
+  private void describeMapAssertionPolicy(StringBuilder description) {
+    description.append(format("- the map assertion policy was %s%n", getMapAssertionPolicy().name()));
+  }
+
+  private void describeOptionalAssertionPolicy(StringBuilder description) {
+    description.append(format("- the optional assertion policy was %s%n", getOptionalAssertionPolicy().name()));
+  }
+
+  private void describeIgnoredFieldsOfTypes(StringBuilder description) {
+    if (!getIgnoredTypes().isEmpty())
+      description.append(format("- the following types were ignored in the assertion: %s%n", describeIgnoredTypes()));
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (o == null || getClass() != o.getClass()) return false;
+    RecursiveAssertionConfiguration that = (RecursiveAssertionConfiguration) o;
+    return shouldIgnoreAllNullFields() == that.shouldIgnoreAllNullFields()
+           && java.util.Objects.equals(getIgnoredFields(), that.getIgnoredFields())
+           && java.util.Objects.equals(getIgnoredFieldsRegexes(), that.getIgnoredFieldsRegexes())
+           && shouldIgnorePrimitiveFields() == that.shouldIgnorePrimitiveFields()
+           && shouldSkipJavaLibraryTypeObjects() == that.shouldSkipJavaLibraryTypeObjects()
+           && getCollectionAssertionPolicy() == that.getCollectionAssertionPolicy()
+           && getOptionalAssertionPolicy() == that.getOptionalAssertionPolicy()
+           && getMapAssertionPolicy() == that.getMapAssertionPolicy();
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(shouldIgnoreAllNullFields(), getIgnoredFields(), getIgnoredFieldsRegexes(), getIgnoredTypes(),
+                        shouldIgnorePrimitiveFields(), shouldSkipJavaLibraryTypeObjects(), getCollectionAssertionPolicy(),
+                        getOptionalAssertionPolicy(), getMapAssertionPolicy());
+  }
+
+  /**
+   * @return A {@link Builder} that will assist the developer in creating a valid instance of {@link RecursiveAssertionConfiguration}.
+   */
+  public static Builder builder() {
+    return new Builder();
+  }
+
+  /**
+   * Builder for {@link RecursiveAssertionConfiguration}
+   *
+   * @since 3.24.0
+   */
+  public static class Builder extends AbstractBuilder<Builder> {
+    private boolean ignorePrimitiveFields = false;
+    private boolean skipJavaLibraryTypeObjects = true;
+    private CollectionAssertionPolicy collectionAssertionPolicy = ELEMENTS_ONLY;
+    private MapAssertionPolicy mapAssertionPolicy = MAP_VALUES_ONLY;
+    private OptionalAssertionPolicy optionalAssertionPolicy = OPTIONAL_VALUE_ONLY;
+    private boolean ignoreAllNullFields;
+
+    private Builder() {
+      super(Builder.class);
+    }
+
+    /**
+     * Makes the recursive assertion to ignore the specified fields in the object under test.
+     * <p>
+     * Example:
+     * <pre><code class='java'> class Person {
+     *   String name;
+     *   String occupation;
+     *   int age;
+     *   Address address = new Address();
+     * }
+     *
+     * class Address {
+     *   int number;
+     *   String street;
+     * }
+     *
+     * Person sherlock = new Person("Sherlock", "Detective", 60);
+     * sherlock.address.street = "Baker Street";
+     * sherlock.address.number = 221;
+     *
+     * RecursiveAssertionConfiguration config = RecursiveAssertionConfiguration.builder()
+     *                                                                         .withIgnoredFields("address", "age")
+     *                                                                         .build();
+     *
+     * // assertion succeeds Person has only String fields except for address and age
+     * assertThat(sherlock).usingRecursiveAssertion(config)
+     *                     .allFieldsSatisfy(field -> field instanceof String);
+     *
+     * // assertion fails because of age, address and address.number fields
+     * assertThat(sherlock).usingRecursiveComparison()
+     *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+     *
+     * @param fieldsToIgnore the fields to ignore in the object under test.
+     * @return this builder.
+     */
+    @Override
+    public Builder withIgnoredFields(String... fieldsToIgnore) {
+      return super.withIgnoredFields(fieldsToIgnore);
+    }
+
+    /**
+     * Makes the recursive assertion to ignore the fields matching the specified regexes in the object under test.
+     * <p>
+     * Example:
+     * <pre><code class='java'> class Person {
+     *   String name;
+     *   String occupation;
+     *   int age;
+     *   Address address = new Address();
+     * }
+     *
+     * class Address {
+     *   int number;
+     *   String street;
+     * }
+     *
+     * Person sherlock = new Person("Sherlock", "Detective", 60);
+     * sherlock.address.street = "Baker Street";
+     * sherlock.address.number = 221;
+     *
+     * RecursiveAssertionConfiguration config = RecursiveAssertionConfiguration.builder()
+     *                                                                         .withIgnoredFieldsMatchingRegexes("ad.*", "ag.")
+     *                                                                         .build();
+     *
+     * // assertion succeeds Person has only String fields except for address and age
+     * assertThat(sherlock).usingRecursiveAssertion(config)
+     *                     .allFieldsSatisfy(field -> field instanceof String);
+     *
+     * // assertion fails because of age, address and address.number fields as by default no fields are ignored
+     * assertThat(sherlock).usingRecursiveComparison()
+     *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+     *
+     * @param regexes regexes used to ignore fields in the assertion.
+     * @return this builder.
+     */
+    @Override
+    public Builder withIgnoredFieldsMatchingRegexes(String... regexes) {
+      return super.withIgnoredFieldsMatchingRegexes(regexes);
+    }
+
+    /**
+     * Makes the recursive assertion to ignore all null fields.
+     * <p>
+     * Example:
+     * <pre><code class='java'> class Person {
+     *   String name;
+     *   String occupation;
+     *   Address address;
+     * }
+     *
+     * class Address {
+     *   int number;
+     *   String street;
+     * }
+     *
+     * Person sherlock = new Person("Sherlock", "Detective");
+     * sherlock.address = null;
+     *
+     * RecursiveAssertionConfiguration config = RecursiveAssertionConfiguration.builder()
+     *                                                                         .withIgnoreAllNullFields(true)
+     *                                                                         .build();
+     *
+     * // assertion succeeds as name and home.address.street fields are ignored in the comparison
+     * assertThat(noName).usingRecursiveAssertion(config)
+     *                  .allFieldsSatisfy(field -> field instanceof String);
+     *
+     * // assertion fails as name and home.address.street fields are populated for sherlock but not for noName.
+     * assertThat(sherlock).usingRecursiveComparison()
+     *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+     *
+     * @param ignoreAllNullFields whether to ignore empty optional fields in the recursive comparison
+     * @return This builder.
+     */
+    public Builder withIgnoreAllNullFields(boolean ignoreAllNullFields) {
+      this.ignoreAllNullFields = ignoreAllNullFields;
+      return this;
+    }
+
+    /**
+     * Choose between running the {@link Predicate} in use over the primitive fields of an object in an object tree or not,
+     * by default asserting over primitives is <em>enabled</em>.
+     * <p>
+     * For example, consider the following class:
+     * <pre><code class='java'> class Example {
+     *    public int primitiveField;
+     *    public String objectField;
+     *  } </code></pre>
+     * <p>
+     * By default, the assertion being applied recursively is applied to <code>primitiveField</code> and to
+     * <code>objectField</code>. If ignoring primitives it set to true, the assertion will only be applied to <code>objectField</code>.
+     * <p>
+     * If you elect to assert over primitives then it is your own responsibility as a developer to ensure that your
+     * {@link Predicate} can handle (boxed) primitive arguments.</p>
+     *
+     * @param ignorePrimitiveFields <code>true</code> to avoid asserting over primitives, <code>false</code> to enable.
+     * @return This builder.
+     */
+    public Builder withIgnorePrimitiveFields(final boolean ignorePrimitiveFields) {
+      this.ignorePrimitiveFields = ignorePrimitiveFields;
+      return this;
+    }
+
+    /**
+     * <p>Choose whether or not, while recursively applying a {@link Predicate} to an object tree, the recursion will dive into 
+     * types defined in the Java Class Library. That is to say, whether or not to recurse into objects whose classes are 
+     * declared in a package starting with java.* or javax.* .</p>
+     * <p>Consider the following example:</p>
+     * <pre><code style='java'> class Example {
+     *   String s = "Don't look at me!";
+     * }
+     *
+     * assertThat(new Example()).usingRecursiveAssertion(...).allFieldsSatisfy(o -> myPredicate(o)); </code></pre>
+     *
+     * <p>With no recursion into Java Class Library types, <code>myPredicate()</code> is applied to the field <code>s</code>
+     * but not to the internal fields of {@link String}. With recursion into Java standard types active, the internal 
+     * fields of String will be examined as well.</p>
+     * <p>By default, recursion into Java Class Library types is <em>disabled</em>. 
+     *
+     * @param recursionIntoJavaClassLibraryTypes <code>true</code> to enable recursion into Java Class Library types, <code>false</code> to disable it. Defaults to <code>false</code>.  
+     * @return This builder.
+     */
+    public Builder withRecursionIntoJavaClassLibraryTypes(final boolean recursionIntoJavaClassLibraryTypes) {
+      this.skipJavaLibraryTypeObjects = !recursionIntoJavaClassLibraryTypes;
+      return this;
+    }
+
+    /**
+     * Makes the recursive assertion to ignore the object under test fields of the given types.
+     * The fields are ignored if their types <b>exactly match one of the ignored types</b>, for example if a field is a subtype of an ignored type it is not ignored.
+     * <p>
+     * If some object under test fields are null it is not possible to evaluate their types and thus these fields are not ignored.
+     * <p>
+     * Example:
+     * <pre><code class='java'> class Person {
+     *   String name;
+     *   String occupation;
+     *   Address address = new Address();
+     * }
+     *
+     * class Address {
+     *   int number;
+     *   String street;
+     * }
+     *
+     * Person sherlock = new Person("Sherlock", "Detective");
+     * sherlock.address.street = "Baker Street";
+     * sherlock.address.number = 221;
+     *
+     * RecursiveAssertionConfiguration config = RecursiveAssertionConfiguration.builder()
+     *                                                                         .withIgnoredFieldsOfTypes(Address.class)
+     *                                                                         .build();
+     *
+     * // assertion succeeds Person has only String fields except for address
+     * assertThat(sherlock).usingRecursiveAssertion(config)
+     *                     .allFieldsSatisfy(field -> field instanceof String);
+     *
+     * // assertion fails because of address and address.number fields as the default config does not ignore any types.
+     * assertThat(sherlock).usingRecursiveComparison()
+     *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+     *
+     * @param types the types we want to ignore in the object under test fields.
+     * @return This builder.
+     */
+    @Override
+    public Builder withIgnoredFieldsOfTypes(Class<?>... types) {
+      return super.withIgnoredFieldsOfTypes(types);
+    }
+
+    /**
+     * <p>Selects the {@link CollectionAssertionPolicy} to use for recursive application of a {@link Predicate} to an object tree. 
+     * If not set, defaults to {@link CollectionAssertionPolicy#COLLECTION_OBJECT_AND_ELEMENTS}.</p>
+     * <p>Note that for the purposes of recursive asserting, an array counts as a collection, so this policy is applied to
+     * arrays as well as children of {@link Collection}.
+     *
+     * @param policy The policy to use for collections and arrays in recursive asserting.
+     * @return This builder.
+     */
+    public Builder withCollectionAssertionPolicy(CollectionAssertionPolicy policy) {
+      collectionAssertionPolicy = policy;
+      return this;
+    }
+
+    /**
+     * <p>Selects the {@link MapAssertionPolicy} to use for recursive application of a {@link Predicate} to an object tree. 
+     * If not set, defaults to {@link MapAssertionPolicy#MAP_OBJECT_AND_ENTRIES}.</p>
+     *
+     * @param policy The policy to use for maps in recursive asserting.
+     * @return This builder.
+     */
+    public Builder withMapAssertionPolicy(MapAssertionPolicy policy) {
+      mapAssertionPolicy = policy;
+      return this;
+    }
+
+    /**
+     * Makes the recursive assertion to use the specified {@link RecursiveAssertionConfiguration.OptionalAssertionPolicy}.
+     * <p>
+     * See {@link RecursiveAssertionConfiguration.OptionalAssertionPolicy} for the different possible policies, by default
+     * {@link RecursiveAssertionConfiguration.OptionalAssertionPolicy#OPTIONAL_VALUE_ONLY} is used.
+     *
+     * @param policy the {@link RecursiveAssertionConfiguration.OptionalAssertionPolicy} to use.
+     * @return this {@link RecursiveAssertionAssert} to chain other methods.
+     */
+    public Builder withOptionalAssertionPolicy(RecursiveAssertionConfiguration.OptionalAssertionPolicy policy) {
+      optionalAssertionPolicy = policy;
+      return this;
+    }
+
+    public RecursiveAssertionConfiguration build() {
+      return new RecursiveAssertionConfiguration(this);
+    }
+  }
+
+  /**
+   * Possible policies to use regarding collections (including arrays) when recursively asserting over the fields of an object tree.
+   * @author bzt
+   */
+  public enum CollectionAssertionPolicy {
+    /**
+     * Apply the {@link Predicate} (recursively) to the elements of the collection/array but not the collection/array itself.
+     * <p>
+     * Consider the following example:
+     * <pre><code style='java'> class Parent {
+     *   List&lt;String&gt; greetings = new ArrayList&lt;&gt;();
+     * }
+     *
+     * Parent parent = new Parent();
+     * parent.greetings.add("Hello");
+     * parent.greetings.add("Salut");
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field));</code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the two strings {@code "Hello"} and {@code "Salut"} but
+     * not to the {@code greetings} field.
+     */
+    ELEMENTS_ONLY,
+
+    /**
+     * Apply the {@link Predicate} to the collection/array only but not to its elements.
+     * <p>
+     * Consider the following example:
+     * <pre><code style='java'> class Parent {
+     *   List&lt;String&gt; greetings = new ArrayList&lt;&gt;();
+     * }
+     *
+     * Parent parent = new Parent();
+     * parent.greetings.add("Hello");
+     * parent.greetings.add("Salut");
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field));</code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the {@code greetings} ArrayList field
+     * but not to the two strings {@code "Hello"} and {@code "Salut"}.
+     */
+    COLLECTION_OBJECT_ONLY,
+
+    /**
+     * Apply the {@link Predicate} to the collection/array as well as to (recursively) its elements.
+     * <p>
+     * Consider the following example:
+     * <pre><code style='java'> class Parent {
+     *   List&lt;String&gt; greetings = new ArrayList&lt;&gt;();
+     * }
+     *
+     * Parent parent = new Parent();
+     * parent.greetings.add("Hello");
+     * parent.greetings.add("Salut");
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field));</code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the {@code greetings} ArrayList field and
+     * to the two strings {@code "Hello"} and {@code "Salut"}.
+     */
+    COLLECTION_OBJECT_AND_ELEMENTS
+  }
+
+  /**
+   * Possible policies to use regarding maps when recursively asserting over the fields of an object tree.
+   * @author bzt
+   */
+  public enum MapAssertionPolicy {
+    /**
+     * Apply the {@link Predicate} to the map but not to its entries.
+     * <p>
+     * Consider the following example:<p>
+     * <pre><code style='java'> class Parent {
+     *   Map&lt;String, String&gt; greetings = new HashMap&lt;&gt;();
+     * }
+     *
+     * Parent parent = new Parent();
+     * parent.greetings.put("english", "Hi");
+     * parent.greetings.put("french", "Salut");
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field)); </code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the {@code greetings} field
+     * but not to the objects contained in the {@code greetings} map entries.
+     */
+    MAP_OBJECT_ONLY,
+
+    /**
+     * Apply the {@link Predicate} (recursively) to the map values but not to the map itself or its keys.
+     * <p>
+     * <pre><code style='java'> class Parent {
+     *   Map&lt;String, String&gt; greetings = new HashMap&lt;&gt;();
+     * }
+     *
+     * Parent parent = new Parent();
+     * parent.greetings.put("english", "Hi");
+     * parent.greetings.put("french", "Salut");
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field)); </code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the {@code greetings} map values {@code "Hi"}
+     * and {@code "Salut"} but not to the {@code greetings} field itself or its keys.
+     */
+    MAP_VALUES_ONLY,
+
+    /**
+     * Apply the {@link Predicate} to the map as well as (recursively) to its keys and values.
+     * <p>
+     * Consider the following example:<p>
+     * <pre><code style='java'> class Parent {
+     *   Map&lt;String, String&gt; greetings = new HashMap&lt;&gt;();
+     * }
+     *
+     * Parent parent = new Parent();
+     * parent.greetings.put("english", "Hi");
+     * parent.greetings.put("french", "Salut");
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field)); </code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the {@code greetings} field and also to
+     * the keys and values of the {@code greetings} map: {@code "english", "Hi", "french"} and {@code "Salut"}.
+     */
+    MAP_OBJECT_AND_ENTRIES
+  }
+
+  /**
+   * Possible policies to use regarding optionals when recursively asserting over the fields of an object tree.
+   */
+  public enum OptionalAssertionPolicy
+  {
+    /**
+     * Apply the {@link Predicate} (recursively) to the value of the optional field but not the optional field.
+     * <p>
+     * Consider the following example:
+     * <pre><code style='java'> class Parent {
+     *   Optional&lt;String&gt; greeting = Optional.of("Hi");
+     * }
+     *
+     * Parent parent = new Parent();
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field));</code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the optional value "Hi" but not to the {@code greeting} Optional field.
+     */
+    OPTIONAL_VALUE_ONLY,
+
+    /**
+     * Apply the {@link Predicate} to the optional field but not to its value.
+     * <p>
+     * Consider the following example:
+     * <pre><code style='java'> class Parent {
+     *   Optional&lt;String&gt; greeting = Optional.of("Hi");
+     * }
+     *
+     * Parent parent = new Parent();
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field));</code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the {@code greeting} Optional field but not to the optional value "Hi".
+     */
+    OPTIONAL_OBJECT_ONLY,
+
+    /**
+     * Apply the {@link Predicate} to the optional field as well as to (recursively) its value.
+     * <p>
+     * Consider the following example:
+     * <pre><code style='java'> class Parent {
+     *   List&lt;String&gt; greetings = new Optional&lt;&gt;();
+     * }
+     *
+     * Parent parent = new Parent();
+     * parent.greetings.add("Hello");
+     * parent.greetings.add("Salut");
+     *
+     * assertThat(parent).usingRecursiveAssertion()
+     *                   .allFieldsSatisfy(field -> myPredicate(field));</code></pre>
+     *
+     * With this policy, <code>myPredicate(field)</code> is applied to the {@code greeting} Optional field and its value "Hi".
+     */
+    OPTIONAL_OBJECT_AND_VALUE
+  }
+}
diff --git a/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver.java b/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver.java
new file mode 100644
index 000000000..898aece30
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver.java
@@ -0,0 +1,301 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static java.lang.String.format;
+import static java.util.Arrays.stream;
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.COLLECTION_OBJECT_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_OBJECT_AND_ENTRIES;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_OBJECT_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_OBJECT_ONLY;
+import static org.assertj.core.internal.Objects.getFieldsNames;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Sets.newHashSet;
+import static org.assertj.core.util.introspection.ClassUtils.isOptionalOrPrimitiveOptional;
+import static org.assertj.core.util.introspection.ClassUtils.isPrimitiveOrWrapper;
+import static org.assertj.core.util.introspection.PropertyOrFieldSupport.EXTRACTION;
+
+import java.lang.reflect.Field;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
+import java.util.Set;
+import java.util.function.Predicate;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.assertj.core.util.Arrays;
+
+public class RecursiveAssertionDriver {
+
+  private static final String NULL = "null";
+  private static final String INDEX_FORMAT = "[%d]";
+  private static final String KEY_FORMAT = "KEY[%s]";
+  private static final String VALUE_FORMAT = "VAL[%s]";
+
+  private final Set<String> visitedNodeIds = newHashSet();
+  private final List<FieldLocation> fieldsFailingTheAssertion = list();
+  private final RecursiveAssertionConfiguration configuration;
+
+  public RecursiveAssertionDriver(RecursiveAssertionConfiguration configuration) {
+    this.configuration = configuration;
+  }
+
+  public List<FieldLocation> assertOverObjectGraph(Predicate<Object> predicate, Object graphNode) {
+    assertRecursively(predicate, graphNode, graphNode.getClass(), rootFieldLocation());
+    return fieldsFailingTheAssertion.stream().sorted().collect(toList());
+  }
+
+  public void reset() {
+    visitedNodeIds.clear();
+    fieldsFailingTheAssertion.clear();
+  }
+
+  private void assertRecursively(Predicate<Object> predicate, Object node, Class<?> nodeType, FieldLocation fieldLocation) {
+    if (nodeMustBeIgnored(node, nodeType, fieldLocation)) return;
+
+    boolean nodeAlreadyVisited = markNodeAsVisited(node);
+    if (nodeAlreadyVisited) return;
+
+    if (!isRootObject(fieldLocation) && shouldEvaluateAssertion(nodeType)) {
+      evaluateAssertion(predicate, node, fieldLocation);
+    }
+    recurseIntoFieldsOfCurrentNode(predicate, node, nodeType, fieldLocation);
+  }
+
+  private boolean nodeMustBeIgnored(Object node, Class<?> nodeType, FieldLocation fieldLocation) {
+    return isNullWhichAreIgnored(node)
+           || isPrimitiveWhichAreIgnored(nodeType)
+           || configuration.matchesAnIgnoredField(fieldLocation)
+           || configuration.matchesAnIgnoredFieldRegex(fieldLocation)
+           || configuration.getIgnoredTypes().contains(nodeType);
+  }
+
+  private boolean isRootObject(FieldLocation fieldLocation) {
+    return fieldLocation.equals(rootFieldLocation());
+  }
+
+  private boolean isNullWhichAreIgnored(Object node) {
+    return node == null && configuration.shouldIgnoreAllNullFields();
+  }
+
+  private boolean isPrimitiveWhichAreIgnored(Class<?> nodeType) {
+    return configuration.shouldIgnorePrimitiveFields() && isPrimitiveOrWrapper(nodeType);
+  }
+
+  private void evaluateAssertion(Predicate<Object> predicate, Object node, FieldLocation fieldLocation) {
+    if (assertionFails(predicate, node)) {
+      fieldsFailingTheAssertion.add(fieldLocation);
+    }
+  }
+
+  private boolean assertionFails(Predicate<Object> predicate, Object node) {
+    return !predicate.test(node);
+  }
+
+  private boolean shouldEvaluateAssertion(Class<?> nodeType) {
+    boolean ignoreContainerAssertion = configuration.shouldIgnoreContainer() && isContainer(nodeType);
+    boolean ignoreMapAssertion = configuration.shouldIgnoreMap() && isMap(nodeType);
+    boolean ignoreOptionalAssertion = configuration.shouldIgnoreOptional() && isOptionalOrPrimitiveOptional(nodeType);
+    return !(ignoreContainerAssertion || ignoreMapAssertion || ignoreOptionalAssertion);
+  }
+
+  private boolean isContainer(Class<?> nodeType) {
+    return isCollection(nodeType) || isArray(nodeType);
+  }
+
+  private void recurseIntoFieldsOfCurrentNode(Predicate<Object> predicate, Object node, Class<?> nodeType,
+                                              FieldLocation fieldLocation) {
+    if (isTypeRequiringSpecificHandling(nodeType)) {
+      if (shouldRecurseOverSpecialTypes(nodeType)) {
+        doRecursionForSpecialTypes(predicate, node, nodeType, fieldLocation);
+      }
+    } else if (shouldRecurseIntoNode(node)) {
+      evaluateFieldsOfCurrentNodeRecursively(predicate, node, fieldLocation);
+    }
+  }
+
+  private boolean isTypeRequiringSpecificHandling(Class<?> nodeType) {
+    return isCollection(nodeType) || isMap(nodeType) || isArray(nodeType) || isOptionalOrPrimitiveOptional(nodeType);
+  }
+
+  private boolean shouldRecurseOverSpecialTypes(Class<?> nodeType) {
+    boolean recurseOverContainer = isContainer(nodeType)
+                                   && configuration.getCollectionAssertionPolicy() != COLLECTION_OBJECT_ONLY;
+    boolean recurseOverMap = isMap(nodeType) && configuration.getMapAssertionPolicy() != MAP_OBJECT_ONLY;
+    boolean recurseOverOptional = isOptionalOrPrimitiveOptional(nodeType)
+                                  && configuration.getOptionalAssertionPolicy() != OPTIONAL_OBJECT_ONLY;
+    return recurseOverContainer || recurseOverMap || recurseOverOptional;
+  }
+
+  private void doRecursionForSpecialTypes(Predicate<Object> predicate, Object node, Class<?> nodeType,
+                                          FieldLocation fieldLocation) {
+    if (isCollection(nodeType)) {
+      recurseIntoCollection(predicate, (Collection<?>) node, fieldLocation);
+    } else if (isArray(nodeType)) {
+      recurseIntoArray(predicate, node, nodeType, fieldLocation);
+    } else if (isMap(nodeType)) {
+      recurseIntoMap(predicate, (Map<?, ?>) node, fieldLocation);
+    } else if (isOptionalOrPrimitiveOptional(nodeType)) {
+      recurseIntoOptional(predicate, node, fieldLocation);
+    }
+  }
+
+  // TODO extend support from collection to iterable
+  private void recurseIntoCollection(Predicate<Object> predicate, Collection<?> collection, FieldLocation fieldLocation) {
+    // TODO handle collection if needed by policy
+    int index = 0;
+    for (Object element : collection) {
+      assertRecursively(predicate, element, safeGetClass(element), fieldLocation.field(format(INDEX_FORMAT, index)));
+      index++;
+    }
+  }
+
+  private void recurseIntoArray(Predicate<Object> predicate, Object node, Class<?> nodeType, FieldLocation fieldLocation) {
+    Class<?> arrayType = nodeType.getComponentType();
+    Object[] array = Arrays.asObjectArray(node);
+    for (int i = 0; i < array.length; i++) {
+      assertRecursively(predicate, array[i], arrayType, fieldLocation.field(format(INDEX_FORMAT, i)));
+    }
+  }
+
+  private void recurseIntoOptional(Predicate<Object> predicate, Object node, FieldLocation fieldLocation) {
+    // If we are here, we know the node is an optional or a primitive optional
+    if (node instanceof Optional) {
+      Optional optionalNode = (Optional) node;
+      if (optionalNode.isPresent()) {
+        Class<?> nextNodeType = safeGetClass(optionalNode.get());
+        assertRecursively(predicate, optionalNode.get(), nextNodeType, fieldLocation.field("value"));
+      }
+    } else if (node instanceof OptionalInt) {
+      OptionalInt optionalIntNode = (OptionalInt) node;
+      if (optionalIntNode.isPresent()) {
+        evaluateAssertion(predicate, optionalIntNode.getAsInt(), fieldLocation.field("value"));
+      }
+    } else if (node instanceof OptionalLong) {
+      OptionalLong optionalLongNode = (OptionalLong) node;
+      if (optionalLongNode.isPresent()) {
+        evaluateAssertion(predicate, optionalLongNode.getAsLong(), fieldLocation.field("value"));
+      }
+    } else if (node instanceof OptionalDouble) {
+      OptionalDouble optionalDoubleNode = (OptionalDouble) node;
+      if (optionalDoubleNode.isPresent()) {
+        evaluateAssertion(predicate, optionalDoubleNode.getAsDouble(), fieldLocation.field("value"));
+      }
+    }
+  }
+
+  private void recurseIntoMap(Predicate<Object> predicate, Map<?, ?> node, FieldLocation fieldLocation) {
+    // If we are here, we can assume the policy is not MAP_OBJECT_ONLY
+    // For both policies VALUES_ONLY and MAP_OBJECT_AND_ENTRIES we have to recurse over the values.
+    recurseIntoMapValues(predicate, node, fieldLocation);
+    if (configuration.getMapAssertionPolicy() == MAP_OBJECT_AND_ENTRIES) {
+      recurseIntoMapKeys(predicate, node, fieldLocation);
+    }
+  }
+
+  private void recurseIntoMapValues(Predicate<Object> predicate, Map<?, ?> currentNode, FieldLocation fieldLocation) {
+    currentNode.values().forEach(nextNode -> recurseIntoMapElement(predicate, fieldLocation, nextNode, VALUE_FORMAT));
+  }
+
+  private void recurseIntoMapKeys(Predicate<Object> predicate, Map<?, ?> currentNode, FieldLocation fieldLocation) {
+    currentNode.keySet().forEach(nextNode -> recurseIntoMapElement(predicate, fieldLocation, nextNode, KEY_FORMAT));
+  }
+
+  private void recurseIntoMapElement(Predicate<Object> predicate, FieldLocation fieldLocation, Object nextNode,
+                                     String msgFormat) {
+    Class<?> nextNodeType = safeGetClass(nextNode);
+    String nextNodeFieldName = nextNode != null ? nextNode.toString() : NULL;
+    assertRecursively(predicate, nextNode, nextNodeType, fieldLocation.field(format(msgFormat, nextNodeFieldName)));
+  }
+
+  private static Class<?> safeGetClass(Object object) {
+    return object != null ? object.getClass() : Object.class;
+  }
+
+  private boolean shouldRecurseIntoNode(Object node) {
+    return node != null && !nodeIsJavaTypeToIgnore(node);
+  }
+
+  private boolean nodeIsJavaTypeToIgnore(Object node) {
+    String canonicalName = node.getClass().getCanonicalName();
+    boolean isJCLType = canonicalName.startsWith("java.") || canonicalName.startsWith("javax.");
+    return isJCLType && configuration.shouldSkipJavaLibraryTypeObjects();
+  }
+
+  private void evaluateFieldsOfCurrentNodeRecursively(Predicate<Object> predicate, Object node, FieldLocation fieldLocation) {
+    Set<String> namesOfFieldsInNode = getFieldsNames(node.getClass());
+    namesOfFieldsInNode.forEach(fieldName -> {
+      Object fieldValue = EXTRACTION.getSimpleValue(fieldName, node);
+      Class<?> fieldType = getFieldType(fieldValue, fieldName, node);
+      assertRecursively(predicate, fieldValue, fieldType, fieldLocation.field(fieldName));
+    });
+  }
+
+  private boolean markNodeAsVisited(Object node) {
+    // Cannot mark null nodes, so just lie and say marking succeeded...
+    if (node == null) return false;
+
+    String objectId = identityToString(node);
+    return !visitedNodeIds.add(objectId);
+  }
+
+  /*
+   * This is taken verbatim from org.apache.commons.lang3.ObjectUtils .
+   */
+  private static String identityToString(final Object object) {
+    if (object == null) {
+      return null;
+    }
+    final String name = object.getClass().getName();
+    final String hexString = Integer.toHexString(System.identityHashCode(object));
+    return name + '@' + hexString;
+  }
+
+  private boolean isCollection(Class<?> nodeType) {
+    return Collection.class.isAssignableFrom(nodeType);
+  }
+
+  private boolean isArray(Class<?> nodeType) {
+    return nodeType.isArray();
+  }
+
+  private boolean isMap(Class<?> nodeType) {
+    return Map.class.isAssignableFrom(nodeType);
+  }
+
+  private static Class<?> getFieldType(Object fieldValue, String fieldName, Object targetObject) {
+    return fieldValue != null ? fieldValue.getClass() : getFieldType(fieldName, targetObject.getClass());
+  }
+
+  private static Class<?> getFieldType(String fieldName, Class<?> objectClass) {
+    try {
+      Optional<Field> potentialField = stream(objectClass.getDeclaredFields()).filter(field -> fieldName.equals(field.getName()))
+                                                                              .findAny();
+      if (potentialField.isPresent()) return potentialField.get().getType();
+      Class<?> superclass = objectClass.getSuperclass();
+      if (superclass != null) return getFieldType(fieldName, superclass);
+      throw new NoSuchFieldException();
+    } catch (NoSuchFieldException | SecurityException e) {
+      throw new IllegalStateException(format("Could not find field %s on class %s, even though its name was retrieved from the class earlier",
+                                             fieldName, objectClass.getCanonicalName()),
+                                      e);
+    }
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index e8c2e6bc0..11e939b24 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -15,7 +15,7 @@ package org.assertj.core.api.recursive.comparison;
 import static java.lang.String.format;
 import static java.util.Collections.unmodifiableList;
 import static java.util.Objects.requireNonNull;
-import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Arrays.isArray;
 
@@ -39,6 +39,8 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.stream.Stream;
 
+import org.assertj.core.api.recursive.FieldLocation;
+
 // logically immutable
 public final class DualValue {
 
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 41221c5cc..f2c4e9abf 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -13,7 +13,6 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static java.lang.String.format;
-import static java.util.Arrays.stream;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
@@ -25,7 +24,6 @@ import static org.assertj.core.util.Sets.newLinkedHashSet;
 import static org.assertj.core.util.introspection.PropertyOrFieldSupport.COMPARISON;
 
 import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Comparator;
 import java.util.LinkedHashSet;
 import java.util.List;
@@ -37,16 +35,16 @@ import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert;
+import org.assertj.core.api.recursive.AbstractRecursiveOperationConfiguration;
+import org.assertj.core.api.recursive.FieldLocation;
 import org.assertj.core.internal.Objects;
 import org.assertj.core.internal.TypeComparators;
 import org.assertj.core.internal.TypeMessages;
 import org.assertj.core.presentation.Representation;
-import org.assertj.core.util.Strings;
 import org.assertj.core.util.VisibleForTesting;
 
-public class RecursiveComparisonConfiguration {
+public class RecursiveComparisonConfiguration extends AbstractRecursiveOperationConfiguration {
 
-  private static final String DEFAULT_DELIMITER = ", ";
   private static final boolean DEFAULT_IGNORE_ALL_OVERRIDDEN_EQUALS = true;
   public static final String INDENT_LEVEL_2 = "  -";
   private boolean strictTypeChecking = false;
@@ -55,9 +53,6 @@ public class RecursiveComparisonConfiguration {
   private boolean ignoreAllActualNullFields = false;
   private boolean ignoreAllActualEmptyOptionalFields = false;
   private boolean ignoreAllExpectedNullFields = false;
-  private Set<String> ignoredFields = new LinkedHashSet<>();
-  private List<Pattern> ignoredFieldsRegexes = new ArrayList<>();
-  private Set<Class<?>> ignoredTypes = new LinkedHashSet<>();
 
   // fields to compare (no other field will be)
   private Set<FieldLocation> comparedFields = new LinkedHashSet<>();
@@ -82,14 +77,12 @@ public class RecursiveComparisonConfiguration {
   private FieldMessages fieldMessages = new FieldMessages();
 
   private RecursiveComparisonConfiguration(Builder builder) {
-    this.strictTypeChecking = builder.strictTypeChecking;
+    super(builder);
     this.ignoreAllActualNullFields = builder.ignoreAllActualNullFields;
     this.ignoreAllActualEmptyOptionalFields = builder.ignoreAllActualEmptyOptionalFields;
+    this.strictTypeChecking = builder.strictTypeChecking;
     this.ignoreAllExpectedNullFields = builder.ignoreAllExpectedNullFields;
-    this.ignoredFields = newLinkedHashSet(builder.ignoredFields);
     this.comparedFields = newLinkedHashSet(builder.comparedFields);
-    ignoreFieldsMatchingRegexes(builder.ignoredFieldsMatchingRegexes);
-    ignoreFieldsOfTypes(builder.ignoredTypes);
     ignoreOverriddenEqualsForTypes(builder.ignoredOverriddenEqualsForTypes);
     this.ignoredOverriddenEqualsForFields = list(builder.ignoredOverriddenEqualsForFields);
     ignoreOverriddenEqualsForFieldsMatchingRegexes(builder.ignoredOverriddenEqualsForFieldsMatchingRegexes);
@@ -103,7 +96,9 @@ public class RecursiveComparisonConfiguration {
     this.typeMessages = builder.typeMessages;
   }
 
-  public RecursiveComparisonConfiguration() {}
+  public RecursiveComparisonConfiguration() {
+    super();
+  }
 
   public boolean hasComparatorForField(String fieldName) {
     return fieldComparators.hasComparatorForField(fieldName);
@@ -206,20 +201,6 @@ public class RecursiveComparisonConfiguration {
     this.ignoreAllExpectedNullFields = ignoreAllExpectedNullFields;
   }
 
-  /**
-   * Adds the given fields to the set of fields from the object under test to ignore in the recursive comparison.
-   * <p>
-   * The fields are ignored by name, not by value.
-   * <p>
-   * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFields(String...)} for examples.
-   *
-   * @param fieldsToIgnore the fields of the object under test to ignore in the comparison.
-   */
-  public void ignoreFields(String... fieldsToIgnore) {
-    List<String> fieldLocations = list(fieldsToIgnore);
-    ignoredFields.addAll(fieldLocations);
-  }
-
   /**
    * Adds the given fields and their subfields to the set of fields from the object under test to compare (no other fields will be compared).
    * <p>
@@ -236,56 +217,6 @@ public class RecursiveComparisonConfiguration {
     Stream.of(fieldNamesToCompare).map(FieldLocation::new).forEach(comparedFields::add);
   }
 
-  /**
-   * Allows to ignore in the recursive comparison the object under test fields matching the given regexes. The given regexes are added to the already registered ones.
-   * <p>
-   * See {@link RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...)} for examples.
-   *
-   * @param regexes regexes used to ignore fields in the comparison.
-   */
-  public void ignoreFieldsMatchingRegexes(String... regexes) {
-    List<Pattern> patterns = Stream.of(regexes)
-                                   .map(Pattern::compile)
-                                   .collect(toList());
-    ignoredFieldsRegexes.addAll(patterns);
-  }
-
-  /**
-   * Adds the given types to the list fields from the object under test types to ignore in the recursive comparison.
-   * The fields are ignored if their types exactly match one of the ignored types, if a field is a subtype of an ignored type it won't be ignored.
-   * <p>
-   * Note that if some object under test fields are null, they are not ignored by this method as their type can't be evaluated.
-   * <p>
-   * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFieldsOfTypes(Class...)} for examples.
-   *
-   * @param types the types of the object under test to ignore in the comparison.
-   */
-  public void ignoreFieldsOfTypes(Class<?>... types) {
-    stream(types).map(RecursiveComparisonConfiguration::asWrapperIfPrimitiveType).forEach(ignoredTypes::add);
-  }
-
-  private static Class<?> asWrapperIfPrimitiveType(Class<?> type) {
-    if (!type.isPrimitive()) return type;
-    if (type.equals(boolean.class)) return Boolean.class;
-    if (type.equals(byte.class)) return Byte.class;
-    if (type.equals(int.class)) return Integer.class;
-    if (type.equals(short.class)) return Short.class;
-    if (type.equals(char.class)) return Character.class;
-    if (type.equals(float.class)) return Float.class;
-    if (type.equals(double.class)) return Double.class;
-    // should not arrive here since we have tested primitive types first
-    return type;
-  }
-
-  /**
-   * Returns the set of fields from the object under test to ignore in the recursive comparison.
-   *
-   * @return the set of fields from the object under test to ignore in the recursive comparison.
-   */
-  public Set<String> getIgnoredFields() {
-    return ignoredFields;
-  }
-
   /**
    * Returns the set of fields to compare from the object under test (no other fields will be compared).
    *
@@ -295,15 +226,6 @@ public class RecursiveComparisonConfiguration {
     return comparedFields;
   }
 
-  /**
-   * Returns the set of fields from the object under test types to ignore in the recursive comparison.
-   *
-   * @return the set of fields from the object under test types to ignore in the recursive comparison.
-   */
-  public Set<Class<?>> getIgnoredTypes() {
-    return ignoredTypes;
-  }
-
   /**
    * Force a recursive comparison on all fields (except java types).
    * <p>
@@ -400,7 +322,7 @@ public class RecursiveComparisonConfiguration {
    * <p>
    * See {@link RecursiveComparisonAssert#ignoringCollectionOrderInFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringCollectionOrderInFieldsMatchingRegexes(String...)} for examples.
    *
-   * @param regexes regexes used to find the object under test fields to ignore collection order in in the comparison.
+   * @param regexes regexes used to find the object under test fields to ignore collection order in the comparison.
    */
   public void ignoreCollectionOrderInFieldsMatchingRegexes(String... regexes) {
     ignoredCollectionOrderInFieldsMatchingRegexes.addAll(Stream.of(regexes)
@@ -553,10 +475,6 @@ public class RecursiveComparisonConfiguration {
     return strictTypeChecking;
   }
 
-  public List<Pattern> getIgnoredFieldsRegexes() {
-    return ignoredFieldsRegexes;
-  }
-
   public List<Class<?>> getIgnoredOverriddenEqualsForTypes() {
     return ignoredOverriddenEqualsForTypes;
   }
@@ -583,10 +501,10 @@ public class RecursiveComparisonConfiguration {
     return java.util.Objects.hash(fieldComparators, ignoreAllActualEmptyOptionalFields, ignoreAllActualNullFields,
                                   ignoreAllExpectedNullFields, ignoreAllOverriddenEquals, ignoreCollectionOrder,
                                   ignoredCollectionOrderInFields, ignoredCollectionOrderInFieldsMatchingRegexes,
-                                  ignoredFields,
-                                  ignoredFieldsRegexes, ignoredOverriddenEqualsForFields,
+                                  getIgnoredFields(),
+                                  getIgnoredFieldsRegexes(), ignoredOverriddenEqualsForFields,
                                   ignoredOverriddenEqualsForTypes,
-                                  ignoredOverriddenEqualsForFieldsMatchingRegexes, ignoredTypes, strictTypeChecking,
+                                  ignoredOverriddenEqualsForFieldsMatchingRegexes, getIgnoredTypes(), strictTypeChecking,
                                   typeComparators, comparedFields, fieldMessages, typeMessages);
   }
 
@@ -603,14 +521,14 @@ public class RecursiveComparisonConfiguration {
            && ignoreAllOverriddenEquals == other.ignoreAllOverriddenEquals
            && ignoreCollectionOrder == other.ignoreCollectionOrder
            && java.util.Objects.equals(ignoredCollectionOrderInFields, other.ignoredCollectionOrderInFields)
-           && java.util.Objects.equals(ignoredFields, other.ignoredFields)
+           && java.util.Objects.equals(getIgnoredFields(), other.getIgnoredFields())
            && java.util.Objects.equals(comparedFields, other.comparedFields)
-           && java.util.Objects.equals(ignoredFieldsRegexes, other.ignoredFieldsRegexes)
+           && java.util.Objects.equals(getIgnoredFieldsRegexes(), other.getIgnoredFieldsRegexes())
            && java.util.Objects.equals(ignoredOverriddenEqualsForFields, other.ignoredOverriddenEqualsForFields)
            && java.util.Objects.equals(ignoredOverriddenEqualsForTypes, other.ignoredOverriddenEqualsForTypes)
            && java.util.Objects.equals(ignoredOverriddenEqualsForFieldsMatchingRegexes,
                                        other.ignoredOverriddenEqualsForFieldsMatchingRegexes)
-           && java.util.Objects.equals(ignoredTypes, other.ignoredTypes)
+           && java.util.Objects.equals(getIgnoredTypes(), other.getIgnoredTypes())
            && strictTypeChecking == other.strictTypeChecking
            && java.util.Objects.equals(typeComparators, other.typeComparators)
            && java.util.Objects.equals(ignoredCollectionOrderInFieldsMatchingRegexes,
@@ -734,34 +652,24 @@ public class RecursiveComparisonConfiguration {
            || matchesAnIgnoredCollectionOrderInFieldRegex(fieldLocation);
   }
 
-  private void describeIgnoredFieldsRegexes(StringBuilder description) {
-    if (!ignoredFieldsRegexes.isEmpty())
-      description.append(format("- the fields matching the following regexes were ignored in the comparison: %s%n",
-                                describeRegexes(ignoredFieldsRegexes)));
-  }
-
-  private void describeIgnoredFields(StringBuilder description) {
-    if (!ignoredFields.isEmpty())
-      description.append(format("- the following fields were ignored in the comparison: %s%n", describeIgnoredFields()));
-  }
-
   private void describeComparedFields(StringBuilder description) {
     if (!comparedFields.isEmpty())
       description.append(format("- the comparison was performed on the following fields: %s%n", describeComparedFields()));
   }
 
   private void describeIgnoredFieldsForTypes(StringBuilder description) {
-    if (!ignoredTypes.isEmpty())
+    if (!getIgnoredTypes().isEmpty())
       description.append(format("- the following types were ignored in the comparison: %s%n", describeIgnoredTypes()));
   }
 
-  private void describeIgnoreAllActualNullFields(StringBuilder description) {
+  protected void describeIgnoreAllActualNullFields(StringBuilder description) {
     if (ignoreAllActualNullFields) description.append(format("- all actual null fields were ignored in the comparison%n"));
   }
 
-  private void describeIgnoreAllActualEmptyOptionalFields(StringBuilder description) {
-    if (getIgnoreAllActualEmptyOptionalFields())
-      description.append(format("- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n"));
+  protected void describeIgnoreAllActualEmptyOptionalFields(StringBuilder description) {
+    if (ignoreAllActualEmptyOptionalFields)
+      description.append(format(
+        "- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n"));
   }
 
   private void describeIgnoreAllExpectedNullFields(StringBuilder description) {
@@ -770,8 +678,8 @@ public class RecursiveComparisonConfiguration {
 
   private void describeOverriddenEqualsMethodsUsage(StringBuilder description, Representation representation) {
     String header = ignoreAllOverriddenEquals
-        ? "- no overridden equals methods were used in the comparison (except for java types)"
-        : "- overridden equals methods were used in the comparison";
+      ? "- no overridden equals methods were used in the comparison (except for java types)"
+      : "- overridden equals methods were used in the comparison";
     description.append(header);
     if (isConfiguredToIgnoreSomeButNotAllOverriddenEqualsMethods()) {
       description.append(format(" except for:%n"));
@@ -816,8 +724,9 @@ public class RecursiveComparisonConfiguration {
 
   private void describeIgnoredCollectionOrderInFieldsMatchingRegexes(StringBuilder description) {
     if (!ignoredCollectionOrderInFieldsMatchingRegexes.isEmpty())
-      description.append(format("- collection order was ignored in the fields matching the following regexes in the comparison: %s%n",
-                                describeRegexes(ignoredCollectionOrderInFieldsMatchingRegexes)));
+      description.append(
+        format("- collection order was ignored in the fields matching the following regexes in the comparison: %s%n",
+               describeRegexes(ignoredCollectionOrderInFieldsMatchingRegexes)));
   }
 
   private boolean matchesAnIgnoredOverriddenEqualsRegex(Class<?> clazz) {
@@ -844,26 +753,17 @@ public class RecursiveComparisonConfiguration {
            && dualValue.isActualFieldAnEmptyOptionalOfAnyType();
   }
 
-  private boolean matchesAnIgnoredFieldRegex(FieldLocation fieldLocation) {
-    return ignoredFieldsRegexes.stream()
-                               .anyMatch(regex -> regex.matcher(fieldLocation.getPathToUseInRules()).matches());
-  }
-
   private boolean matchesAnIgnoredFieldType(DualValue dualValue) {
     Object actual = dualValue.actual;
-    if (actual != null) return ignoredTypes.contains(actual.getClass());
+    if (actual != null) return getIgnoredTypes().contains(actual.getClass());
     Object expected = dualValue.expected;
     // actual is null => we can't evaluate its type, we can only reliably check dualValue.expected's type if
     // strictTypeChecking is enabled which guarantees expected is of the same type.
-    if (strictTypeChecking && expected != null) return ignoredTypes.contains(expected.getClass());
+    if (strictTypeChecking && expected != null) return getIgnoredTypes().contains(expected.getClass());
     // if strictTypeChecking is disabled, we can't safely ignore the field (if we did, we would ignore all null fields!).
     return false;
   }
 
-  private boolean matchesAnIgnoredField(FieldLocation fieldLocation) {
-    return ignoredFields.stream().anyMatch(fieldLocation::matches);
-  }
-
   private boolean matchesAnIgnoredCollectionOrderInField(FieldLocation fieldLocation) {
     return ignoredCollectionOrderInFields.stream().anyMatch(fieldLocation::matches);
   }
@@ -873,36 +773,14 @@ public class RecursiveComparisonConfiguration {
     return ignoredCollectionOrderInFieldsMatchingRegexes.stream().anyMatch(regex -> regex.matcher(pathToUseInRules).matches());
   }
 
-  private String describeIgnoredFields() {
-    return join(ignoredFields);
-  }
-
   private String describeComparedFields() {
     return join(comparedFields.stream().map(FieldLocation::shortDescription).collect(toList()));
   }
 
-  private String describeIgnoredTypes() {
-    List<String> typesDescription = ignoredTypes.stream()
-                                                .map(Class::getName)
-                                                .collect(toList());
-    return join(typesDescription);
-  }
-
-  private static String join(Collection<String> typesDescription) {
-    return Strings.join(typesDescription).with(DEFAULT_DELIMITER);
-  }
-
   private String describeIgnoredCollectionOrderInFields() {
     return join(ignoredCollectionOrderInFields);
   }
 
-  private String describeRegexes(List<Pattern> regexes) {
-    List<String> fieldsDescription = regexes.stream()
-                                            .map(Pattern::pattern)
-                                            .collect(toList());
-    return join(fieldsDescription);
-  }
-
   private boolean isConfiguredToIgnoreSomeButNotAllOverriddenEqualsMethods() {
     boolean ignoreSomeOverriddenEqualsMethods = !ignoredOverriddenEqualsForFieldsMatchingRegexes.isEmpty()
                                                 || !ignoredOverriddenEqualsForTypes.isEmpty()
@@ -949,8 +827,8 @@ public class RecursiveComparisonConfiguration {
 
   private void describeTypeCheckingStrictness(StringBuilder description) {
     String str = strictTypeChecking
-        ? "- actual and expected objects and their fields were considered different when of incompatible types (i.e. expected type does not extend actual's type) even if all their fields match, for example a Person instance will never match a PersonDto (call strictTypeChecking(false) to change that behavior).%n"
-        : "- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).%n";
+      ? "- actual and expected objects and their fields were considered different when of incompatible types (i.e. expected type does not extend actual's type) even if all their fields match, for example a Person instance will never match a PersonDto (call strictTypeChecking(false) to change that behavior).%n"
+      : "- actual and expected objects and their fields were compared field by field recursively even if they were not of the same type, this allows for example to compare a Person to a PersonDto (call strictTypeChecking(true) to change that behavior).%n";
     description.append(format(str));
   }
 
@@ -996,15 +874,12 @@ public class RecursiveComparisonConfiguration {
   /**
    * Builder to build {@link RecursiveComparisonConfiguration}.
    */
-  public static final class Builder {
+  public static final class Builder extends AbstractBuilder<Builder> {
     private boolean strictTypeChecking;
     private boolean ignoreAllActualNullFields;
     private boolean ignoreAllActualEmptyOptionalFields;
     private boolean ignoreAllExpectedNullFields;
-    private String[] ignoredFields = {};
     private FieldLocation[] comparedFields = {};
-    private String[] ignoredFieldsMatchingRegexes = {};
-    private Class<?>[] ignoredTypes = {};
     private Class<?>[] ignoredOverriddenEqualsForTypes = {};
     private String[] ignoredOverriddenEqualsForFields = {};
     private String[] ignoredOverriddenEqualsForFieldsMatchingRegexes = {};
@@ -1017,7 +892,9 @@ public class RecursiveComparisonConfiguration {
     private FieldMessages fieldMessages = new FieldMessages();
     private TypeMessages typeMessages = new TypeMessages();
 
-    private Builder() {}
+    private Builder() {
+      super(Builder.class);
+    }
 
     /**
      * Sets whether the recursive comparison will check that actual's type is compatible with expected's type (the same applies for each field).
@@ -1072,19 +949,6 @@ public class RecursiveComparisonConfiguration {
       return this;
     }
 
-    /**
-     * Adds the given fields to the set of fields from the object under test to ignore in the recursive comparison. Nested fields can be specified like this: home.address.street.
-     * <p>
-     * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFields(String...)} for examples.
-     *
-     * @param fieldsToIgnore the fields of the object under test to ignore in the comparison.
-     * @return this builder.
-     */
-    public Builder withIgnoredFields(String... fieldsToIgnore) {
-      this.ignoredFields = fieldsToIgnore;
-      return this;
-    }
-
     /**
      * Adds the given fields to the set of fields from the object under test to compare in the recursive comparison.
      * <p>
@@ -1100,35 +964,6 @@ public class RecursiveComparisonConfiguration {
       return this;
     }
 
-    /**
-     * Allows to ignore in the recursive comparison the object under test fields matching the given regexes. The given regexes are added to the already registered ones.
-     * <p>
-     * See {@link RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...)} for examples.
-     *
-     * @param regexes regexes used to ignore fields in the comparison.
-     * @return this builder.
-     */
-    public Builder withIgnoredFieldsMatchingRegexes(String... regexes) {
-      this.ignoredFieldsMatchingRegexes = regexes;
-      return this;
-    }
-
-    /**
-     * Adds the given types to the list fields from the object under test types to ignore in the recursive comparison.
-     * The fields are ignored if their types exactly match one of the ignored types, if a field is a subtype of an ignored type it won't be ignored.
-     * <p>
-     * Note that if some object under test fields are null, they are not ignored by this method as their type can't be evaluated.
-     * <p>
-     * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFieldsOfTypes(Class...)} for examples.
-     *
-     * @param types the types of the object under test to ignore in the comparison.
-     * @return this builder.
-     */
-    public Builder withIgnoredFieldsOfTypes(Class<?>... types) {
-      this.ignoredTypes = types;
-      return this;
-    }
-
     /**
      * Adds the given types to the list of types to force a recursive comparison on.
      * <p>
@@ -1212,7 +1047,7 @@ public class RecursiveComparisonConfiguration {
      * <p>
      * See {@link RecursiveComparisonAssert#ignoringCollectionOrderInFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringCollectionOrderInFieldsMatchingRegexes(String...)} for examples.
      *
-     * @param regexes regexes used to find the object under test fields to ignore collection order in in the comparison.
+     * @param regexes regexes used to find the object under test fields to ignore collection order in the comparison.
      * @return this builder.
      */
     public Builder withIgnoredCollectionOrderInFieldsMatchingRegexes(String... regexes) {
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 343918ff7..dec33b2a7 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -15,9 +15,9 @@ package org.assertj.core.api.recursive.comparison;
 import static java.lang.String.format;
 import static java.util.Objects.deepEquals;
 import static java.util.stream.Collectors.joining;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
 import static org.assertj.core.api.recursive.comparison.ComparisonDifference.rootComparisonDifference;
 import static org.assertj.core.api.recursive.comparison.DualValue.DEFAULT_ORDERED_COLLECTION_TYPES;
-import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
 import static org.assertj.core.internal.Objects.getFieldsNames;
 import static org.assertj.core.util.IterableUtil.sizeOf;
 import static org.assertj.core.util.IterableUtil.toCollection;
@@ -47,6 +47,7 @@ import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.stream.Stream;
 
+import org.assertj.core.api.recursive.FieldLocation;
 import org.assertj.core.internal.DeepDifference;
 
 /**
@@ -166,7 +167,7 @@ public class RecursiveComparisonDifferenceCalculator {
 
     private String getCustomErrorMessage(DualValue dualValue) {
       String fieldName = dualValue.getConcatenatedPath();
-      // field custome messages take precedence over type messages
+      // field custom messages take precedence over type messages
       if (recursiveComparisonConfiguration.hasCustomMessageForField(fieldName)) {
         return recursiveComparisonConfiguration.getMessageForField(fieldName);
       }
diff --git a/src/main/java/org/assertj/core/error/ShouldNotSatisfyPredicateRecursively.java b/src/main/java/org/assertj/core/error/ShouldNotSatisfyPredicateRecursively.java
new file mode 100644
index 000000000..896b75e8c
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldNotSatisfyPredicateRecursively.java
@@ -0,0 +1,43 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static java.util.stream.Collectors.toList;
+
+import java.util.List;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
+
+public class ShouldNotSatisfyPredicateRecursively extends BasicErrorMessageFactory {
+
+  private static final String INDENT = "  ";
+  private static final String NEW_LINE = format("%n");
+
+  public static ErrorMessageFactory shouldNotSatisfyRecursively(RecursiveAssertionConfiguration recursiveAssertionConfiguration,
+                                                                List<FieldLocation> failedFields) {
+    List<String> fieldsDescription = failedFields.stream().map(FieldLocation::getPathToUseInErrorReport).collect(toList());
+    StringBuilder builder = new StringBuilder(NEW_LINE);
+    builder.append("The following fields did not satisfy the predicate:").append(NEW_LINE);
+    builder.append(INDENT + fieldsDescription.toString() + NEW_LINE);
+    builder.append("The recursive assertion was performed with this configuration:").append(NEW_LINE);
+    builder.append(recursiveAssertionConfiguration);
+    return new ShouldNotSatisfyPredicateRecursively(builder.toString());
+  }
+
+  private ShouldNotSatisfyPredicateRecursively(String message) {
+    super(message);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/groups/Tuple.java b/src/main/java/org/assertj/core/groups/Tuple.java
index f175b0574..1bb7ed994 100644
--- a/src/main/java/org/assertj/core/groups/Tuple.java
+++ b/src/main/java/org/assertj/core/groups/Tuple.java
@@ -33,7 +33,7 @@ public final class Tuple {
   public List<Object> toList() {
     return values;
   }
-
+  
   @Override
   public boolean equals(Object obj) {
     if (this == obj) return true;
diff --git a/src/main/java/org/assertj/core/util/introspection/ClassUtils.java b/src/main/java/org/assertj/core/util/introspection/ClassUtils.java
index a361e9a8e..db33166bc 100644
--- a/src/main/java/org/assertj/core/util/introspection/ClassUtils.java
+++ b/src/main/java/org/assertj/core/util/introspection/ClassUtils.java
@@ -12,13 +12,28 @@
  */
 package org.assertj.core.util.introspection;
 
+import static org.assertj.core.util.Lists.list;
+
 import java.util.ArrayList;
 import java.util.HashSet;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 
 public class ClassUtils {
 
+  /**
+   * Lists primitive wrapper {@link Class}es.
+   */
+  private static final List<Class<?>> PRIMITIVE_WRAPPER_TYPES = list(Boolean.class, Byte.class, Character.class, Short.class,
+                                                                     Integer.class, Long.class, Double.class, Float.class,
+                                                                     Void.class);
+  private static final List<Class<?>> OPTIONAL_TYPES = list(Optional.class, OptionalLong.class, OptionalDouble.class,
+                                                            OptionalInt.class);
+
   /**
    * <p>Gets a {@code List} of superclasses for the given class.</p>
    *
@@ -81,4 +96,42 @@ public class ClassUtils {
       cls = cls.getSuperclass();
     }
   }
-}
\ No newline at end of file
+
+  /**
+   * Returns whether the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},
+   * {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}, {@link Void}).
+   * <p>
+   * Returns false if passed null since the method can't evaluate the class.
+   * <p>
+   * Inspired from apache commons-lang ClassUtils
+   *
+   * @param type The class to query or null.
+   * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Boolean}, {@link Byte},
+   *         {@link Character}, {@link Short}, {@link Integer}, {@link Long}, {@link Double}, {@link Float}, {@link Void}).
+   * @since 3.24.0
+   */
+  public static boolean isPrimitiveOrWrapper(final Class<?> type) {
+    if (type == null) {
+      return false;
+    }
+    return type.isPrimitive() || PRIMITIVE_WRAPPER_TYPES.contains(type);
+  }
+
+  /**
+   * Returns whether the given {@code type} is a primitive or primitive wrapper ({@link Optional}, {@link OptionalInt},
+   * {@link OptionalLong}, {@link OptionalDouble}).
+   * <p>
+   * Returns false if passed null since the method can't evaluate the class.
+   *
+   * @param type The class to query or null.
+   * @return true if the given {@code type} is a primitive or primitive wrapper ({@link Optional}, {@link OptionalInt},
+   *              {@link OptionalLong}, {@link OptionalDouble}).
+   * @since 3.24.0
+   */
+  public static boolean isOptionalOrPrimitiveOptional(final Class<?> type) {
+    if (type == null) {
+      return false;
+    }
+    return OPTIONAL_TYPES.contains(type);
+  }
+}
diff --git a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
index 1ec5cdb70..22133343f 100644
--- a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
@@ -254,5 +254,6 @@ public enum FieldSupport {
     // only read public field
     return isPublic(field.getModifiers());
   }
+  
 
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_Test.java b/src/test/java/org/assertj/core/api/recursive/FieldLocation_Test.java
similarity index 97%
rename from src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_Test.java
rename to src/test/java/org/assertj/core/api/recursive/FieldLocation_Test.java
index c1c8a2336..6fd98be5c 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/FieldLocation_Test.java
@@ -10,7 +10,7 @@
  *
  * Copyright 2012-2022 the original author or authors.
  */
-package org.assertj.core.api.recursive.comparison;
+package org.assertj.core.api.recursive;
 
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_field_Test.java b/src/test/java/org/assertj/core/api/recursive/FieldLocation_field_Test.java
similarity index 97%
rename from src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_field_Test.java
rename to src/test/java/org/assertj/core/api/recursive/FieldLocation_field_Test.java
index 428bf9e49..073dd57d7 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_field_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/FieldLocation_field_Test.java
@@ -10,7 +10,7 @@
  *
  * Copyright 2012-2022 the original author or authors.
  */
-package org.assertj.core.api.recursive.comparison;
+package org.assertj.core.api.recursive;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.util.Lists.list;
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasChild_Test.java b/src/test/java/org/assertj/core/api/recursive/FieldLocation_hasChild_Test.java
similarity index 98%
rename from src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasChild_Test.java
rename to src/test/java/org/assertj/core/api/recursive/FieldLocation_hasChild_Test.java
index b52a20228..29c9ba3b1 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasChild_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/FieldLocation_hasChild_Test.java
@@ -10,7 +10,7 @@
  *
  * Copyright 2012-2022 the original author or authors.
  */
-package org.assertj.core.api.recursive.comparison;
+package org.assertj.core.api.recursive;
 
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasParent_Test.java b/src/test/java/org/assertj/core/api/recursive/FieldLocation_hasParent_Test.java
similarity index 98%
rename from src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasParent_Test.java
rename to src/test/java/org/assertj/core/api/recursive/FieldLocation_hasParent_Test.java
index 744f065fd..ab8ea7047 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasParent_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/FieldLocation_hasParent_Test.java
@@ -10,7 +10,7 @@
  *
  * Copyright 2012-2022 the original author or authors.
  */
-package org.assertj.core.api.recursive.comparison;
+package org.assertj.core.api.recursive;
 
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_matches_Test.java b/src/test/java/org/assertj/core/api/recursive/FieldLocation_matches_Test.java
similarity index 98%
rename from src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_matches_Test.java
rename to src/test/java/org/assertj/core/api/recursive/FieldLocation_matches_Test.java
index f711e8994..d633588bf 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_matches_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/FieldLocation_matches_Test.java
@@ -10,7 +10,7 @@
  *
  * Copyright 2012-2022 the original author or authors.
  */
-package org.assertj.core.api.recursive.comparison;
+package org.assertj.core.api.recursive;
 
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/AbstractRecursiveAssertionDriverTestBase.java b/src/test/java/org/assertj/core/api/recursive/assertion/AbstractRecursiveAssertionDriverTestBase.java
new file mode 100644
index 000000000..24f1d1e4a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/AbstractRecursiveAssertionDriverTestBase.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.util.function.Predicate;
+
+import org.junit.jupiter.api.BeforeEach;
+
+abstract class AbstractRecursiveAssertionDriverTestBase {
+
+  protected Predicate<Object> succeedingMockPredicate;
+  protected Predicate<Object> failingMockPredicate;
+
+  Object emptyTestObject() {
+    return new Object();
+  }
+
+  @SuppressWarnings("unchecked")
+  @BeforeEach
+  public void prepareMockPredicates() {
+    succeedingMockPredicate = mock(Predicate.class, "call-verification-predicate-succeeding");
+    when(succeedingMockPredicate.test(any())).thenReturn(true);
+    failingMockPredicate = mock(Predicate.class, "call-verification-predicate-failing");
+    when(failingMockPredicate.test(any())).thenReturn(false);
+  }
+
+  protected RecursiveAssertionDriver testSubjectWithDefaultConfiguration() {
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder().build();
+    return new RecursiveAssertionDriver(configuration);
+  }
+
+  protected Object objectWithNullField() {
+    return new ClassWithNullField();
+  }
+
+  Top simpleCycleStructure() {
+    Top top = new Top();
+    Middle middle = new Middle();
+    Bottom bottom = new Bottom();
+
+    top.linkToMiddle = middle;
+    middle.linkToBottom = bottom;
+    bottom.loopBackToTop = top;
+
+    return top;
+  }
+
+  class ClassWithNullField {
+    @SuppressWarnings("unused")
+    private Object nullField = null;
+  }
+
+  class Top {
+    Middle linkToMiddle;
+  }
+
+  class Middle {
+    Bottom linkToBottom;
+  }
+
+  class Bottom {
+    Top loopBackToTop;
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_Test.java
new file mode 100644
index 000000000..a7291e07b
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_Test.java
@@ -0,0 +1,144 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.function.Predicate;
+
+import org.assertj.core.test.jdk11.Jdk11;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_allFieldsSatisfy_Test {
+
+  @Test
+  void object_recursive_assertion_should_pass_when_asserting_not_null_over_graph_without_null_values() {
+    // GIVEN
+    Object testObject = objectGraphNoNulls();
+    // WHEN/THEN
+    then(testObject).usingRecursiveAssertion().allFieldsSatisfy(Objects::nonNull);
+  }
+
+  @Test
+  void iterable_recursive_assertion_should_pass_when_asserting_not_null_over_graph_without_null_values() {
+    // GIVEN
+    List<Object> testObject = Jdk11.List.of(objectGraphNoNulls(), objectGraphNoNulls());
+    // WHEN/THEN
+    then(testObject).usingRecursiveAssertion().allFieldsSatisfy(Objects::nonNull);
+  }
+
+  @Test
+  void array_recursive_assertion_should_pass_when_asserting_not_null_over_graph_without_null_values() {
+    // GIVEN
+    Object[] testObject = array(objectGraphNoNulls(), objectGraphNoNulls());
+    // WHEN/THEN
+    then(testObject).usingRecursiveAssertion().allFieldsSatisfy(Objects::nonNull);
+  }
+
+  @Test
+  void map_recursive_assertion_should_pass_when_asserting_not_null_over_graph_without_null_values() {
+    // GIVEN
+    Map<String, Object> testObject = Jdk11.Map.of("k1", objectGraphNoNulls(), "k2", objectGraphNoNulls());
+    // WHEN/THEN
+    then(testObject).usingRecursiveAssertion().allFieldsSatisfy(Objects::nonNull);
+  }
+
+  @Test
+  void optional_recursive_assertion_should_pass_when_asserting_not_null_over_graph_without_null_values() {
+    // GIVEN
+    Optional<Object> testObject = Optional.of(objectGraphNoNulls());
+    // WHEN/THEN
+    then(testObject).usingRecursiveAssertion().allFieldsSatisfy(Objects::nonNull);
+  }
+
+  @Test
+  void should_not_evaluate_root_object_but_only_its_fields() {
+    // GIVEN
+    Object address = new Address("Paris", "Tolbiac");
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN/THEN
+    then(address).usingRecursiveAssertion().allFieldsSatisfy(isString);
+  }
+
+  @Test
+  void should_fail_when_asserting_not_null_over_graph_with_null_values() {
+    // GIVEN
+    Object testObject = objectGraphWithNullValue();
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(testObject).usingRecursiveAssertion()
+                                                                            .allFieldsSatisfy(Objects::nonNull));
+    // THEN
+    then(error).hasMessageContaining("books.[0].authors.[1].books.[1].authors.[1].email");
+  }
+
+  Object objectGraphNoNulls() {
+    Author root = (Author) objectGraphWithNullValue();
+    root.books.get(0).authors[1].books.get(1).authors[1].email = "k.beck@recursive.test";
+    return root;
+  }
+
+  Object objectGraphWithNullValue() {
+    Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+    Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+    Author kentBeck = new Author("Kent Beck", null);
+
+    Book noSqlDistilled = new Book("NoSql Distilled", array(pramodSadalage, martinFowler));
+    pramodSadalage.books.add(noSqlDistilled);
+    martinFowler.books.add(noSqlDistilled);
+
+    Book refactoring = new Book("Refactoring", array(martinFowler, kentBeck));
+    martinFowler.books.add(refactoring);
+    kentBeck.books.add(refactoring);
+
+    return pramodSadalage;
+  }
+
+  static class Author {
+    String name;
+    String email;
+    List<Book> books = new ArrayList<>();
+
+    Author(String name, String email) {
+      this.name = name;
+      this.email = email;
+    }
+  }
+
+  static class Book {
+    String title;
+    Author[] authors;
+
+    Book(String title, Author[] authors) {
+      this.title = title;
+      this.authors = authors;
+    }
+  }
+
+  static class Address {
+    String town;
+    String street;
+
+    Address(String town, String street) {
+      this.town = town;
+      this.street = street;
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringAllNullFields_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringAllNullFields_Test.java
new file mode 100644
index 000000000..3e995c1bb
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringAllNullFields_Test.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.function.Predicate;
+
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringAllNullFields_Test {
+
+  @Test
+  void should_pass_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", "Detective");
+    sherlock.address = null;
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN/THEN
+    then(sherlock).usingRecursiveAssertion()
+                  .ignoringAllNullFields()
+                  .allFieldsSatisfy(isString);
+  }
+
+  @Test
+  void should_fail_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", "Detective");
+    sherlock.address = new Address(221, null);
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(sherlock).usingRecursiveAssertion()
+                                                                          .allFieldsSatisfy(isString));
+    // THEN
+    then(error).hasMessageContaining("[address, address.number, address.street]");
+  }
+
+  static class Person {
+    String name;
+    String occupation;
+    Address address;
+
+    public Person(String name, String occupation) {
+      this.name = name;
+      this.occupation = occupation;
+    }
+  }
+
+  static class Address {
+    int number;
+    String street;
+
+    public Address(int number, String street) {
+      this.number = number;
+      this.street = street;
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFieldsMatchingRegexes_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFieldsMatchingRegexes_Test.java
new file mode 100644
index 000000000..b4f5b1475
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFieldsMatchingRegexes_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.function.Predicate;
+
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFieldsMatchingRegexes_Test {
+
+  @Test
+  void should_pass_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", "Detective", 60);
+    sherlock.address.street = "Baker Street";
+    sherlock.address.number = 221;
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN/THEN
+    then(sherlock).usingRecursiveAssertion()
+                  .ignoringFieldsMatchingRegexes("ad.*", "ag.")
+                  .allFieldsSatisfy(isString);
+  }
+
+  @Test
+  void should_fail_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", "Detective", 60);
+    sherlock.address.street = "Baker Street";
+    sherlock.address.number = 221;
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(sherlock).usingRecursiveAssertion()
+                                                                          .ignoringFieldsMatchingRegexes(".*ber")
+                                                                          .allFieldsSatisfy(isString));
+    // THEN
+    then(error).hasMessageContaining("[address, age]");
+  }
+
+  static class Person {
+    String name;
+    String occupation;
+    int age;
+    Address address = new Address();
+
+    Person(String name, String occupation, int age) {
+      this.name = name;
+      this.occupation = occupation;
+    }
+  }
+
+  static class Address {
+    int number;
+    String street;
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFieldsOfTypes_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFieldsOfTypes_Test.java
new file mode 100644
index 000000000..5aab3def8
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFieldsOfTypes_Test.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.function.Predicate;
+
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFieldsOfTypes_Test {
+
+  @Test
+  void should_pass_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", "Detective");
+    sherlock.address.street = "Baker Street";
+    sherlock.address.number = 221;
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN/THEN
+    then(sherlock).usingRecursiveAssertion()
+                  .ignoringFieldsOfTypes(Address.class)
+                  .allFieldsSatisfy(isString);
+  }
+
+  @Test
+  void should_fail_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", null);
+    sherlock.address.street = "Baker Street";
+    sherlock.address.number = 221;
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(sherlock).usingRecursiveAssertion().allFieldsSatisfy(isString));
+    // THEN
+    then(error).hasMessageContaining("[address, address.number, occupation]");
+  }
+
+  static class Person {
+    String name;
+    String occupation;
+    Address address = new Address();
+
+    Person(String name, String occupation) {
+      this.name = name;
+      this.occupation = occupation;
+    }
+  }
+
+  static class Address {
+    int number;
+    String street;
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFields_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFields_Test.java
new file mode 100644
index 000000000..d3e713c9d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFields_Test.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.function.Predicate;
+
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringFields_Test {
+
+  @Test
+  void should_pass_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", "Detective", 60);
+    sherlock.address.street = "Baker Street";
+    sherlock.address.number = 221;
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN/THEN
+    then(sherlock).usingRecursiveAssertion()
+                  .ignoringFields("address", "age")
+                  .allFieldsSatisfy(isString);
+  }
+
+  @Test
+  void should_fail_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", "Detective", 60);
+    sherlock.address.street = "Baker Street";
+    sherlock.address.number = 221;
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(sherlock).usingRecursiveAssertion().ignoringFields("age")
+                                                                          .allFieldsSatisfy(isString));
+    // THEN
+    then(error).hasMessageContaining("[address, address.number]");
+  }
+
+  static class Person {
+    String name;
+    String occupation;
+    int age;
+    Address address = new Address();
+
+    Person(String name, String occupation, int age) {
+      this.name = name;
+      this.occupation = occupation;
+    }
+  }
+
+  static class Address {
+    int number;
+    String street;
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringPrimitiveFields_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringPrimitiveFields_Test.java
new file mode 100644
index 000000000..7188c11c3
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringPrimitiveFields_Test.java
@@ -0,0 +1,60 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.function.Predicate;
+
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_allFieldsSatisfy_with_ignoringPrimitiveFields_Test {
+
+  @Test
+  void should_pass_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", 60, 1.80);
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN/THEN
+    then(sherlock).usingRecursiveAssertion()
+                  .ignoringPrimitiveFields()
+                  .allFieldsSatisfy(isString);
+  }
+
+  @Test
+  void should_fail_when_asserting_only_string() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock", 60, 1.80);
+    Predicate<Object> isString = field -> field instanceof String;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(sherlock).usingRecursiveAssertion()
+                                                                          .allFieldsSatisfy(isString));
+    // THEN
+    then(error).hasMessageContaining("[age, height]");
+  }
+
+  static class Person {
+    int age;
+    Double height;
+    String name;
+
+    public Person(String name, int age, Double height) {
+      this.age = age;
+      this.height = height;
+      this.name = name;
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_hasNoNullFields_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_hasNoNullFields_Test.java
new file mode 100644
index 000000000..8854a99e5
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_hasNoNullFields_Test.java
@@ -0,0 +1,89 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.BDDAssertions.thenNoException;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_hasNoNullFields_Test {
+
+  @Test
+  void should_pass_when_asserting_not_null_over_graph_without_null_values() {
+    // GIVEN
+    Object testObject = objectGraphNoNulls();
+    // WHEN/THEN
+    thenNoException().isThrownBy(() -> assertThat(testObject).usingRecursiveAssertion().hasNoNullFields());
+  }
+
+  @Test
+  void should_fail_when_asserting_not_null_over_graph_with_null_values() {
+    // GIVEN
+    Object testObject = objectGraphWithNullValue();
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(testObject).usingRecursiveAssertion().hasNoNullFields());
+    // THEN
+    then(error).hasMessageContaining("books.[0].authors.[1].books.[1].authors.[1].email");
+  }
+
+  Object objectGraphNoNulls() {
+    Author root = (Author) objectGraphWithNullValue();
+    root.books.get(0).authors[1].books.get(1).authors[1].email = "k.beck@recursive.test";
+    return root;
+  }
+
+  Object objectGraphWithNullValue() {
+    Author pramodSadalage = new Author("Pramod Sadalage", "p.sadalage@recursive.test");
+    Author martinFowler = new Author("Martin Fowler", "m.fowler@recursive.test");
+    Author kentBeck = new Author("Kent Beck", null);
+
+    Book noSqlDistilled = new Book("NoSql Distilled", array(pramodSadalage, martinFowler));
+    pramodSadalage.books.add(noSqlDistilled);
+    martinFowler.books.add(noSqlDistilled);
+
+    Book refactoring = new Book("Refactoring", array(martinFowler, kentBeck));
+    martinFowler.books.add(refactoring);
+    kentBeck.books.add(refactoring);
+
+    return pramodSadalage;
+  }
+
+  class Author {
+    String name;
+    String email;
+    List<Book> books = new ArrayList<>();
+
+    Author(String name, String email) {
+      this.name = name;
+      this.email = email;
+    }
+  }
+
+  class Book {
+    String title;
+    Author[] authors;
+
+    Book(String title, Author[] authors) {
+      this.title = title;
+      this.authors = authors;
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withCollectionPolicy_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withCollectionPolicy_Test.java
new file mode 100644
index 000000000..d54cfa675
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withCollectionPolicy_Test.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.COLLECTION_OBJECT_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.ELEMENTS_ONLY;
+
+import org.assertj.core.api.RecursiveAssertionAssert;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_withCollectionPolicy_Test {
+
+  @Test
+  void should_use_given_CollectionAssertionPolicy() {
+    // GIVEN
+    Object object = "foo";
+    RecursiveAssertionConfiguration.CollectionAssertionPolicy collectionAssertionPolicy = COLLECTION_OBJECT_ONLY;
+    // WHEN
+    RecursiveAssertionAssert recursiveAssertionAssert = assertThat(object).usingRecursiveAssertion()
+                                                                          .withCollectionAssertionPolicy(collectionAssertionPolicy);
+    // THEN
+    RecursiveAssertionConfiguration expectedConfig = RecursiveAssertionConfiguration.builder()
+                                                                                    .withCollectionAssertionPolicy(collectionAssertionPolicy)
+                                                                                    .build();
+    then(recursiveAssertionAssert).hasFieldOrPropertyWithValue("recursiveAssertionConfiguration", expectedConfig);
+  }
+
+  @Test
+  void should_use_given_ELEMENTS_ONLY_CollectionAssertionPolicy_by_default() {
+    // GIVEN
+    Object object = "foo";
+    // WHEN
+    RecursiveAssertionAssert recursiveAssertionAssert = assertThat(object).usingRecursiveAssertion();
+    // THEN
+    RecursiveAssertionConfiguration expectedConfig = RecursiveAssertionConfiguration.builder()
+                                                                                    .withCollectionAssertionPolicy(ELEMENTS_ONLY)
+                                                                                    .build();
+    then(recursiveAssertionAssert).hasFieldOrPropertyWithValue("recursiveAssertionConfiguration", expectedConfig);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withMapPolicy_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withMapPolicy_Test.java
new file mode 100644
index 000000000..ac95e17a8
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withMapPolicy_Test.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_OBJECT_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_VALUES_ONLY;
+
+import org.assertj.core.api.RecursiveAssertionAssert;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_withMapPolicy_Test {
+
+  @Test
+  void should_use_given_MapAssertionPolicy() {
+    // GIVEN
+    Object object = "foo";
+    RecursiveAssertionConfiguration.MapAssertionPolicy mapAssertionPolicy = MAP_OBJECT_ONLY;
+    // WHEN
+    RecursiveAssertionAssert recursiveAssertionAssert = assertThat(object).usingRecursiveAssertion()
+                                                                          .withMapAssertionPolicy(mapAssertionPolicy);
+    // THEN
+    RecursiveAssertionConfiguration expectedConfig = RecursiveAssertionConfiguration.builder()
+                                                                                    .withMapAssertionPolicy(mapAssertionPolicy)
+                                                                                    .build();
+    then(recursiveAssertionAssert).hasFieldOrPropertyWithValue("recursiveAssertionConfiguration", expectedConfig);
+  }
+
+  @Test
+  void should_use_given_MAP_VALUES_ONLY_MapAssertionPolicy_by_default() {
+    // GIVEN
+    Object object = "foo";
+    // WHEN
+    RecursiveAssertionAssert recursiveAssertionAssert = assertThat(object).usingRecursiveAssertion();
+    // THEN
+    RecursiveAssertionConfiguration expectedConfig = RecursiveAssertionConfiguration.builder()
+                                                                                    .withMapAssertionPolicy(MAP_VALUES_ONLY)
+                                                                                    .build();
+    then(recursiveAssertionAssert).hasFieldOrPropertyWithValue("recursiveAssertionConfiguration", expectedConfig);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withOptionalPolicy_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withOptionalPolicy_Test.java
new file mode 100644
index 000000000..4c8d90399
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_withOptionalPolicy_Test.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_OBJECT_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_VALUE_ONLY;
+
+import org.assertj.core.api.RecursiveAssertionAssert;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionAssert_withOptionalPolicy_Test {
+
+  @Test
+  void should_use_given_OptionalAssertionPolicy() {
+    // GIVEN
+    Object object = "foo";
+    RecursiveAssertionConfiguration.OptionalAssertionPolicy optionalAssertionPolicy = OPTIONAL_OBJECT_ONLY;
+    // WHEN
+    RecursiveAssertionAssert recursiveAssertionAssert = assertThat(object).usingRecursiveAssertion()
+                                                                          .withOptionalAssertionPolicy(optionalAssertionPolicy);
+    // THEN
+    RecursiveAssertionConfiguration expectedConfig = RecursiveAssertionConfiguration.builder()
+                                                                                    .withOptionalAssertionPolicy(optionalAssertionPolicy)
+                                                                                    .build();
+    then(recursiveAssertionAssert).hasFieldOrPropertyWithValue("recursiveAssertionConfiguration", expectedConfig);
+  }
+
+  @Test
+  void should_use_given_OPTIONAL_VALUE_ONLY_OptionalAssertionPolicy_by_default() {
+    // GIVEN
+    Object object = "foo";
+    // WHEN
+    RecursiveAssertionAssert recursiveAssertionAssert = assertThat(object).usingRecursiveAssertion();
+    // THEN
+    RecursiveAssertionConfiguration expectedConfig = RecursiveAssertionConfiguration.builder()
+                                                                                    .withOptionalAssertionPolicy(OPTIONAL_VALUE_ONLY)
+                                                                                    .build();
+    then(recursiveAssertionAssert).hasFieldOrPropertyWithValue("recursiveAssertionConfiguration", expectedConfig);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_AssertionApplicationTest.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_AssertionApplicationTest.java
new file mode 100644
index 000000000..99c460637
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_AssertionApplicationTest.java
@@ -0,0 +1,116 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
+import static org.mockito.Mockito.verifyNoInteractions;
+
+import java.util.List;
+import java.util.Optional;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionDriver_AssertionApplicationTest extends AbstractRecursiveAssertionDriverTestBase {
+
+  @Test
+  void should_not_call_predicate_for_the_root_object() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Object emptyTestObject = emptyTestObject();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(succeedingMockPredicate, emptyTestObject);
+    // THEN
+    then(failedFields).isEmpty();
+    verifyNoInteractions(succeedingMockPredicate);
+  }
+
+  @Test
+  void should_assert_over_null_when_configured_to_do_so() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Object emptyTestObject = objectWithNullField();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, emptyTestObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("nullField"));
+  }
+
+  @Test
+  void should_not_assert_over_null_when_configured_not_to_do_so() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder().withIgnoreAllNullFields(true)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object emptyTestObject = objectWithNullField();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, emptyTestObject);
+    // THEN
+    then(failedFields).isEmpty();
+  }
+
+  @Test
+  void should_not_assert_over_fields_that_are_being_ignored_by_name() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withIgnoredFields("linkToMiddle.linkToBottom")
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = simpleCycleStructure();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("linkToMiddle"));
+  }
+
+  @Test
+  void should_not_assert_over_fields_that_are_being_ignored_by_regex() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withIgnoredFieldsMatchingRegexes("linkToMiddle\\.link.*")
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = simpleCycleStructure();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("linkToMiddle"));
+  }
+
+  @Test
+  void should_not_assert_over_fields_that_are_being_ignored_by_type() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withIgnoredFieldsOfTypes(Bottom.class)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = simpleCycleStructure();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("linkToMiddle"));
+  }
+
+  @Test
+  void should_assert_over_empty_optionals() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Object testObject = Optional.empty();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).isEmpty();
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_CollectionPolicyTest.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_CollectionPolicyTest.java
new file mode 100644
index 000000000..38a029f8a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_CollectionPolicyTest.java
@@ -0,0 +1,141 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.COLLECTION_OBJECT_AND_ELEMENTS;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.COLLECTION_OBJECT_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.ELEMENTS_ONLY;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionDriver_CollectionPolicyTest extends AbstractRecursiveAssertionDriverTestBase {
+
+  @Test
+  void should_assert_over_collection_object_but_not_elements_when_policy_is_collection_only() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withCollectionAssertionPolicy(COLLECTION_OBJECT_ONLY)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = testObjectWithACollection();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("collection"));
+  }
+
+  @Test
+  void should_assert_over_array_object_but_not_elements_when_policy_is_collection_only() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withCollectionAssertionPolicy(COLLECTION_OBJECT_ONLY)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = testObjectWithAnArray();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("array"));
+  }
+
+  @Test
+  void should_assert_over_collection_elements_but_not_collection_when_policy_is_elements_only() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withCollectionAssertionPolicy(ELEMENTS_ONLY)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = testObjectWithACollection();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("collection").field("[0]"),
+                                    rootFieldLocation().field("collection").field("[1]"));
+  }
+
+  @Test
+  void should_assert_over_array_elements_but_not_object_when_policy_is_collection_only() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withCollectionAssertionPolicy(ELEMENTS_ONLY)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = testObjectWithAnArray();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("array").field("[0]"),
+                                    rootFieldLocation().field("array").field("[1]"));
+  }
+
+  @Test
+  void should_assert_over_collection_object_and_elements_when_policy_is_object_and_elements() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withCollectionAssertionPolicy(COLLECTION_OBJECT_AND_ELEMENTS)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = testObjectWithACollection();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("collection"),
+                                    rootFieldLocation().field("collection").field("[0]"),
+                                    rootFieldLocation().field("collection").field("[1]"));
+  }
+
+  @Test
+  void should_assert_over_array_object_and_elements_when_policy_is_object_and_elements() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withCollectionAssertionPolicy(COLLECTION_OBJECT_AND_ELEMENTS)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = testObjectWithAnArray();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("array"),
+                                    rootFieldLocation().field("array").field("[0]"),
+                                    rootFieldLocation().field("array").field("[1]"));
+  }
+
+  private Object testObjectWithACollection() {
+    ClassWithCollectionChild child = new ClassWithCollectionChild();
+    child.collection.add("Hello World!");
+    child.collection.add("Goodbye World!");
+    return child;
+  }
+
+  private Object testObjectWithAnArray() {
+    ClassWithArrayChild child = new ClassWithArrayChild();
+    child.array[0] = "Hello World!";
+    child.array[1] = "Goodbye World!";
+    return child;
+  }
+
+  class ClassWithCollectionChild {
+    Collection<Object> collection = list();
+  }
+
+  class ClassWithArrayChild {
+    Object[] array = new Object[2];
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_JavaClassLibraryRecursionTest.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_JavaClassLibraryRecursionTest.java
new file mode 100644
index 000000000..56ed07037
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_JavaClassLibraryRecursionTest.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
+
+import java.util.List;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionDriver_JavaClassLibraryRecursionTest extends AbstractRecursiveAssertionDriverTestBase {
+
+  @Test
+  void should_assert_over_but_not_recurse_into_jcl_classes_when_configured_not_to_recurse_into_JCL() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Object testObject = jclReferencingObject();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("jclField"));
+  }
+
+  @Test
+  void should_assert_over_and_recurse_into_jcl_classes_when_configured_to_recurse_into_JCL() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withRecursionIntoJavaClassLibraryTypes(true)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = jclReferencingObject();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).hasSizeGreaterThanOrEqualTo(3)
+                      .contains(rootFieldLocation().field("jclField"),
+                                // OOOOH, knowledge of String internals! this is why recursion into JCL types is off by default
+                                rootFieldLocation().field("jclField").field("coder"));
+  }
+
+  private Object jclReferencingObject() {
+    return new ClassWithAFieldWithATypeFromTheJCL();
+  }
+
+  class ClassWithAFieldWithATypeFromTheJCL {
+    @SuppressWarnings("unused")
+    private String jclField = "Hello World";
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_MapPolicyTest.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_MapPolicyTest.java
new file mode 100644
index 000000000..fd38ce400
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_MapPolicyTest.java
@@ -0,0 +1,85 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_OBJECT_AND_ENTRIES;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_OBJECT_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_VALUES_ONLY;
+
+import java.util.List;
+import java.util.Map;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.assertj.core.test.jdk11.Jdk11;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionDriver_MapPolicyTest extends AbstractRecursiveAssertionDriverTestBase {
+
+  @Test
+  public void should_assert_over_map_but_not_keys_or_values_when_policy_is_map_object_only() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withMapAssertionPolicy(MAP_OBJECT_ONLY)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = classWithMap();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("map"));
+  }
+
+  @Test
+  public void should_assert_over_values_but_not_keys_or_map_object_when_policy_is_values_only() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withMapAssertionPolicy(MAP_VALUES_ONLY)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = classWithMap();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("map").field("VAL[value0]"),
+                                    rootFieldLocation().field("map").field("VAL[value1]"));
+  }
+
+  @Test
+  public void should_assert_over_map_object_and_keys_and_values_when_policy_is_map_object_and_entries() {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withMapAssertionPolicy(MAP_OBJECT_AND_ENTRIES)
+                                                                                   .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(configuration);
+    Object testObject = classWithMap();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("map"),
+                                    rootFieldLocation().field("map").field("KEY[key0]"),
+                                    rootFieldLocation().field("map").field("VAL[value0]"),
+                                    rootFieldLocation().field("map").field("KEY[key1]"),
+                                    rootFieldLocation().field("map").field("VAL[value1]"));
+  }
+
+  private Object classWithMap() {
+    return new ClassWithMap();
+  }
+
+  class ClassWithMap {
+    @SuppressWarnings("unused")
+    private Map<String, String> map = Jdk11.Map.of("key0", "value0", "key1", "value1");
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_OptionalPolicy_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_OptionalPolicy_Test.java
new file mode 100644
index 000000000..ca2646abd
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_OptionalPolicy_Test.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_OBJECT_AND_VALUE;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_OBJECT_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_VALUE_ONLY;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class RecursiveAssertionDriver_OptionalPolicy_Test extends AbstractRecursiveAssertionDriverTestBase {
+
+  @ParameterizedTest
+  @MethodSource(value = "wrapper_object_with_Optional_and_primitive_Optional_types")
+  void should_assert_over_optional_value_but_not_the_optional_object_when_policy_is_OPTIONAL_VALUE_ONLY(Wrapper<?> testObject) {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withOptionalAssertionPolicy(OPTIONAL_VALUE_ONLY)
+                                                                                   .build();
+    RecursiveAssertionDriver driver = new RecursiveAssertionDriver(configuration);
+    // WHEN
+    List<FieldLocation> failedFields = driver.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(new FieldLocation("optional.value"));
+  }
+
+  @ParameterizedTest
+  @MethodSource(value = "wrapper_object_with_Optional_and_primitive_Optional_types")
+  void should_assert_over_optional_object_but_not_its_value_when_policy_is_OPTIONAL_OBJECT_ONLY(Wrapper<?> testObject) {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withOptionalAssertionPolicy(OPTIONAL_OBJECT_ONLY)
+                                                                                   .build();
+    RecursiveAssertionDriver driver = new RecursiveAssertionDriver(configuration);
+    // WHEN
+    List<FieldLocation> failedFields = driver.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(new FieldLocation("optional"));
+  }
+
+  @ParameterizedTest
+  @MethodSource(value = "wrapper_object_with_Optional_and_primitive_Optional_types")
+  void should_assert_over_optional_object_and_its_value_when_policy_is_OPTIONAL_OBJECT_AND_VALUE(Wrapper<?> testObject) {
+    // GIVEN
+    RecursiveAssertionConfiguration configuration = RecursiveAssertionConfiguration.builder()
+                                                                                   .withOptionalAssertionPolicy(OPTIONAL_OBJECT_AND_VALUE)
+                                                                                   .build();
+    RecursiveAssertionDriver driver = new RecursiveAssertionDriver(configuration);
+    // WHEN
+    List<FieldLocation> failedFields = driver.assertOverObjectGraph(failingMockPredicate, testObject);
+    // THEN
+    then(failedFields).containsOnly(new FieldLocation("optional"), new FieldLocation("optional.value"));
+  }
+
+  private static Stream<Wrapper> wrapper_object_with_Optional_and_primitive_Optional_types() {
+    return Stream.of(new Wrapper(Optional.of("foo")), new Wrapper(OptionalLong.of(1l)),
+                     new Wrapper(OptionalDouble.of(1.0)), new Wrapper(OptionalInt.of(1)));
+  }
+
+  static class Wrapper<T> {
+    T optional;
+
+    Wrapper(T optional) {
+      this.optional = optional;
+    }
+
+    @Override
+    public String toString() {
+      return optional.getClass().getSimpleName();
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_PrimitiveFieldHandlingTest.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_PrimitiveFieldHandlingTest.java
new file mode 100644
index 000000000..95704a348
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_PrimitiveFieldHandlingTest.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
+
+import java.util.List;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionDriver_PrimitiveFieldHandlingTest extends AbstractRecursiveAssertionDriverTestBase {
+
+  @Test
+  void should_assert_over_primitive_field_when_configured_to_do_so() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Object objectToAssertOver = objectToAssertOver();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, objectToAssertOver);
+    // THEN
+    then(failedFields).hasSize(2).contains(rootFieldLocation().field("primitiveField"));
+  }
+
+  @Test
+  void should_not_assert_over_primitive_field_when_configured_to_ignore_them() {
+    // GIVEN
+    RecursiveAssertionConfiguration recursiveAssertionConfiguration = RecursiveAssertionConfiguration.builder()
+                                                                                                     .withIgnorePrimitiveFields(true)
+                                                                                                     .build();
+    RecursiveAssertionDriver objectUnderTest = new RecursiveAssertionDriver(recursiveAssertionConfiguration);
+    Object objectToAssertOver = objectToAssertOver();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, objectToAssertOver);
+    // THEN
+    then(failedFields).doesNotContain(rootFieldLocation().field("primitiveField"));
+  }
+
+  @Test
+  void should_assert_over_inherited_primitive_field_when_configured_to_do_so() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Object objectToAssertOver = objectHierarchyToAssertOver();
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(failingMockPredicate, objectToAssertOver);
+    // THEN
+    then(failedFields).contains(rootFieldLocation().field("primitiveField"),
+                                rootFieldLocation().field("objectField"),
+                                rootFieldLocation().field("anotherObjectField"));
+  }
+
+  private Object objectToAssertOver() {
+    return new ClassWithPrimitiveAndObjectField();
+  }
+
+  private Object objectHierarchyToAssertOver() {
+    return new SubClassWithAdditionalField();
+  }
+
+  @SuppressWarnings("unused")
+  private class ClassWithPrimitiveAndObjectField {
+    private int primitiveField = 0;
+    private Object objectField = new Object();
+  }
+
+  @SuppressWarnings("unused")
+  private class SubClassWithAdditionalField extends ClassWithPrimitiveAndObjectField {
+    private Object anotherObjectField = new Object();
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_RecursionTest.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_RecursionTest.java
new file mode 100644
index 000000000..d4d1d51f8
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver_RecursionTest.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.BDDAssertions.thenNoException;
+import static org.assertj.core.api.recursive.FieldLocation.rootFieldLocation;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.function.Predicate;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.junit.jupiter.api.Test;
+
+class RecursiveAssertionDriver_RecursionTest extends AbstractRecursiveAssertionDriverTestBase {
+
+  @Test
+  void should_recurse_through_object_tree() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Object objectTree = simpleCycleStructure();
+    Predicate<Object> boomOnOveruse = predicateThatThrowsWhenCalledTooOften(25);
+    // WHEN
+    List<FieldLocation> failedFields = objectUnderTest.assertOverObjectGraph(boomOnOveruse, objectTree);
+    // THEN
+    then(failedFields).containsOnly(rootFieldLocation().field("linkToMiddle"),
+                                    rootFieldLocation().field("linkToMiddle").field("linkToBottom"));
+  }
+
+  @Test
+  void should_detect_cycle_and_break_looping() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Object objectTree = simpleCycleStructure();
+    Predicate<Object> boomOnOveruse = predicateThatThrowsWhenCalledTooOften(100);
+    // WHEN / THEN
+    thenNoException().isThrownBy(() -> objectUnderTest.assertOverObjectGraph(boomOnOveruse, objectTree));
+  }
+
+  @Test
+  void should_not_attempt_to_recurse_into_null_fields() {
+    // GIVEN
+    RecursiveAssertionDriver objectUnderTest = testSubjectWithDefaultConfiguration();
+    Top objectTree = simpleCycleStructure();
+    objectTree.linkToMiddle.linkToBottom.loopBackToTop = null;
+    Predicate<Object> boomOnOveruse = predicateThatThrowsWhenCalledTooOften(100);
+    // WHEN / THEN
+    thenNoException().isThrownBy(() -> objectUnderTest.assertOverObjectGraph(boomOnOveruse, objectTree));
+  }
+
+  private Predicate<Object> predicateThatThrowsWhenCalledTooOften(int maxCalls) {
+    AtomicInteger callLimit = new AtomicInteger(maxCalls - 1);
+    return o -> {
+      int call = callLimit.getAndDecrement();
+      if (call < 0) throw new RuntimeException("Called too often -- assuming cycling -- BOOM!");
+      return false;
+    };
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveComparisonConfiguration_toString_Test.java b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveComparisonConfiguration_toString_Test.java
new file mode 100644
index 000000000..0d32fbf9a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveComparisonConfiguration_toString_Test.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.assertion;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.ELEMENTS_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_VALUES_ONLY;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_VALUE_ONLY;
+
+import java.time.ZonedDateTime;
+import java.util.UUID;
+
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.Builder;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+class RecursiveComparisonConfiguration_toString_Test {
+
+  private Builder recursiveComparisonConfigurationBuilder;
+
+  @BeforeEach
+  void setup() {
+    recursiveComparisonConfigurationBuilder = RecursiveAssertionConfiguration.builder();
+  }
+
+  @Test
+  void should_show_a_complete_description() {
+    // GIVEN
+    recursiveComparisonConfigurationBuilder.withIgnorePrimitiveFields(true)
+                                           .withIgnoreAllNullFields(true)
+                                           .withIgnoredFields("foo", "bar", "foo.bar")
+                                           .withIgnoredFieldsMatchingRegexes("f.*", ".ba.", "..b%sr..")
+                                           .withIgnoredFieldsOfTypes(UUID.class, ZonedDateTime.class)
+                                           .withRecursionIntoJavaClassLibraryTypes(true)
+                                           .withCollectionAssertionPolicy(ELEMENTS_ONLY)
+                                           .withMapAssertionPolicy(MAP_VALUES_ONLY)
+                                           .withOptionalAssertionPolicy(OPTIONAL_VALUE_ONLY);
+    // WHEN
+    RecursiveAssertionConfiguration recursiveAssertionConfiguration = recursiveComparisonConfigurationBuilder.build();
+    // THEN
+    //@format:off
+    then(recursiveAssertionConfiguration).hasToString(format("- all null fields were ignored in the assertion%n" +
+                                                             "- the following fields were ignored in the comparison: foo, bar, foo.bar%n" +
+                                                             "- the fields matching the following regexes were ignored in the comparison: f.*, .ba., ..b%%sr..%n" +
+                                                             "- the following types were ignored in the assertion: java.util.UUID, java.time.ZonedDateTime%n" +
+                                                             "- primitive fields were ignored in the recursive assertion%n" +
+                                                             "- fields from Java Class Library types (java.* or javax.*) were included in the recursive assertion%n" +
+                                                             "- the collection assertion policy was ELEMENTS_ONLY%n" +
+                                                             "- the map assertion policy was MAP_VALUES_ONLY%n" +
+                                                             "- the optional assertion policy was OPTIONAL_VALUE_ONLY%n"));
+    //@format:on
+  }
+
+  @Test
+  void should_show_a_complete_description_with_default_values() {
+    // WHEN
+    RecursiveAssertionConfiguration recursiveAssertionConfiguration = recursiveComparisonConfigurationBuilder.build();
+    // THEN
+    // @format:off
+    then(recursiveAssertionConfiguration).hasToString(format("- fields from Java Class Library types (java.* or javax.*) were excluded in the recursive assertion%n" +
+                                                             "- the collection assertion policy was ELEMENTS_ONLY%n" +
+                                                             "- the map assertion policy was MAP_VALUES_ONLY%n"+
+                                                             "- the optional assertion policy was OPTIONAL_VALUE_ONLY%n"));
+    // @format:on
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
index ffed100a3..bf6a73500 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
@@ -21,6 +21,7 @@ import java.util.function.BiPredicate;
 import java.util.regex.Pattern;
 
 import org.apache.commons.lang3.RandomUtils;
+import org.assertj.core.api.recursive.FieldLocation;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration.Builder;
 import org.assertj.core.test.AlwaysEqualComparator;
 import org.junit.jupiter.api.Test;
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreCollectionOrder_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreCollectionOrder_Test.java
index cbf72585d..92b2a251f 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreCollectionOrder_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreCollectionOrder_Test.java
@@ -22,6 +22,7 @@ import java.util.Set;
 import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
+import org.assertj.core.api.recursive.FieldLocation;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
diff --git a/src/test/java/org/assertj/core/error/ShouldNotSatisfyPredicateRecursively_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotSatisfyPredicateRecursively_create_Test.java
new file mode 100644
index 000000000..b68718ebb
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldNotSatisfyPredicateRecursively_create_Test.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldNotSatisfyPredicateRecursively.shouldNotSatisfyRecursively;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+
+import org.assertj.core.api.recursive.FieldLocation;
+import org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration;
+import org.assertj.core.description.TextDescription;
+import org.junit.jupiter.api.Test;
+
+class ShouldNotSatisfyPredicateRecursively_create_Test {
+
+  private static final TextDescription DESCRIPTION = new TextDescription("Test");
+
+  @Test
+  void should_create_error_message() {
+    // GIVEN
+    RecursiveAssertionConfiguration recursiveAssertionConfiguration = RecursiveAssertionConfiguration.builder().build();
+    List<FieldLocation> failedFields = list(new FieldLocation("name"), new FieldLocation("address"));
+    ErrorMessageFactory factory = shouldNotSatisfyRecursively(recursiveAssertionConfiguration, failedFields);
+    // WHEN
+    String message = factory.create(DESCRIPTION, STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "The following fields did not satisfy the predicate:%n" +
+                                   "  [name, address]%n" +
+                                   "The recursive assertion was performed with this configuration:%n%s",
+                                   recursiveAssertionConfiguration));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/util/introspection/ClassUtils_isOptionalOrPrimitiveOptional_Test.java b/src/test/java/org/assertj/core/util/introspection/ClassUtils_isOptionalOrPrimitiveOptional_Test.java
new file mode 100644
index 000000000..1e77db403
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/introspection/ClassUtils_isOptionalOrPrimitiveOptional_Test.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.introspection.ClassUtils.isOptionalOrPrimitiveOptional;
+
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class ClassUtils_isOptionalOrPrimitiveOptional_Test {
+
+  @ParameterizedTest
+  @MethodSource
+  void should_detect_Optional_and_primitive_Optional_types(Class<?> clazz) {
+    // WHEN
+    boolean isPrimitive = isOptionalOrPrimitiveOptional(clazz);
+    // THEN
+    then(isPrimitive).isTrue();
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_detect_as_not_from_the_Optional_family(Class<?> clazz) {
+    // WHEN
+    boolean isPrimitive = isOptionalOrPrimitiveOptional(clazz);
+    // THEN
+    then(isPrimitive).isFalse();
+  }
+
+  private static Stream<Class<?>> should_detect_Optional_and_primitive_Optional_types() {
+    return Stream.of(Optional.class, OptionalLong.class, OptionalDouble.class, OptionalInt.class);
+  }
+
+  private static Stream<Class<?>> should_detect_as_not_from_the_Optional_family() {
+    return Stream.of(String.class, com.google.common.base.Optional.class);
+  }
+}
diff --git a/src/test/java/org/assertj/core/util/introspection/ClassUtils_isPrimitiveOrWrapper_Test.java b/src/test/java/org/assertj/core/util/introspection/ClassUtils_isPrimitiveOrWrapper_Test.java
new file mode 100644
index 000000000..a11f7889b
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/introspection/ClassUtils_isPrimitiveOrWrapper_Test.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.introspection.ClassUtils.isPrimitiveOrWrapper;
+
+import java.util.List;
+import java.util.Optional;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class ClassUtils_isPrimitiveOrWrapper_Test {
+
+  @ParameterizedTest
+  @MethodSource
+  void isPrimitiveOrWrapper_should_detect_primitive_types_and_their_corresponding_wrapper(Class<?> clazz) {
+    // WHEN
+    boolean isPrimitive = isPrimitiveOrWrapper(clazz);
+    // THEN
+    then(isPrimitive).isTrue();
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_detect_as_not_primitive_types_or_their_corresponding_wrapper(Class<?> clazz) {
+    // WHEN
+    boolean isPrimitive = isPrimitiveOrWrapper(clazz);
+    // THEN
+    then(isPrimitive).isFalse();
+  }
+
+  private static Stream<Class<?>> isPrimitiveOrWrapper_should_detect_primitive_types_and_their_corresponding_wrapper() {
+    return Stream.of(Boolean.class, Byte.class, Character.class, Short.class, Integer.class, Long.class, Double.class,
+                     Float.class, Void.class, Boolean.TYPE, Byte.TYPE, Character.TYPE, Short.TYPE, Integer.TYPE, Long.TYPE,
+                     Double.TYPE, Float.TYPE, Void.TYPE);
+  }
+
+  private static Stream<Class<?>> should_detect_as_not_primitive_types_or_their_corresponding_wrapper() {
+    return Stream.of(Optional.class, String.class, List.class, AtomicInteger.class);
+  }
+
+}
