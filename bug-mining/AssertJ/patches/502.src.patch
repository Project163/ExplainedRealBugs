diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/BoundedQueue.java b/assertj-core/src/main/java/org/assertj/core/presentation/BoundedQueue.java
new file mode 100644
index 000000000..80cab1b5b
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/BoundedQueue.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static org.assertj.core.util.Preconditions.checkArgument;
+
+import java.util.AbstractQueue;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Queue;
+
+/** A queue with a fixed maximum size. Once the queue is full, no more elements can be added until an element is removed. */
+final class BoundedQueue<T> extends AbstractQueue<T> {
+  /** Queue that never holds more than {@code capacity} elements. */
+  private final Queue<T> data;
+
+  /** The maximum number of elements that can be present. */
+  private final int capacity;
+
+  /**
+   * Creates a new {@link BoundedQueue}.
+   *
+   * @param capacity the maximum number of elements the queue can hold
+   * @throws IllegalArgumentException if the capacity is negative
+   */
+  BoundedQueue(int capacity) {
+    checkArgument(capacity >= 0, "capacity must be non-negative but was %d", capacity);
+    this.capacity = capacity;
+    this.data = new LinkedList<>();
+  }
+
+  @Override
+  public Iterator<T> iterator() {
+    return data.iterator();
+  }
+
+  @Override
+  public int size() {
+    return data.size();
+  }
+
+  @Override
+  public boolean offer(T element) {
+    return data.size() < capacity && data.offer(element);
+  }
+
+  @Override
+  public T poll() {
+    return data.poll();
+  }
+
+  @Override
+  public T peek() {
+    return data.peek();
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/HeadTailAccumulator.java b/assertj-core/src/main/java/org/assertj/core/presentation/HeadTailAccumulator.java
new file mode 100644
index 000000000..a3b002b80
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/HeadTailAccumulator.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static org.assertj.core.util.Preconditions.checkArgument;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Queue;
+import java.util.stream.Stream;
+
+/**
+ * Accumulates the values in a stream or iterable, keeping the first and last elements and discarding everything in between.
+ */
+final class HeadTailAccumulator<T> {
+  /** The first elements seen. */
+  private final Queue<T> head;
+
+  /** The elements seen most recently, excluding anything already on {@code head}. */
+  private final Queue<T> tail;
+
+  /**
+   * Creates a new {@link HeadTailAccumulator}.
+   *
+   * @param headCapacity the maximum number of elements to retain from the start of the stream
+   * @param tailCapacity the maximum number of elements to retain from the end of the stream.
+   * @throws IllegalArgumentException if either argument is negative
+   */
+  HeadTailAccumulator(int headCapacity, int tailCapacity) {
+    checkArgument(headCapacity >= 0, "head capacity must be non-negative but was %d", headCapacity);
+    checkArgument(tailCapacity >= 0, "tail capacity must be non-negative but was %d", tailCapacity);
+    this.head = new BoundedQueue<>(headCapacity);
+    this.tail = new RotatingQueue<>(tailCapacity);
+  }
+
+  /**
+   * Adds an element to the accumulator, possibly displacing an older element.
+   *
+   * @param element the element to add (may be {@code null})
+   */
+  void add(final T element) {
+    if (!head.offer(element)) tail.offer(element);
+  }
+
+  /**
+   * Converts the accumulated elements into a stream.
+   *
+   * @return the head and tail concatenated
+   */
+  Stream<T> stream() {
+    List<T> result = new ArrayList<>(head);
+    result.addAll(tail);
+    return result.stream();
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/RotatingQueue.java b/assertj-core/src/main/java/org/assertj/core/presentation/RotatingQueue.java
new file mode 100644
index 000000000..a5a375e17
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/RotatingQueue.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static org.assertj.core.util.Preconditions.checkArgument;
+
+import java.util.AbstractQueue;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Queue;
+
+/**
+ * Queue with a fixed maximum size. When an element is added to a full queue, the oldest element
+ * is removed before the new element is added.
+ */
+final class RotatingQueue<T> extends AbstractQueue<T> {
+  /** The array to provide a view of. */
+  private final Queue<T> data;
+
+  /** The maximum number of elements that can be present. */
+  private final int capacity;
+
+  /**
+   * Creates a new {@link RotatingQueue}.
+   *
+   * @param capacity the maximum number of elements the queue can hold
+   * @throws IllegalArgumentException if the capacity is negative
+   */
+  RotatingQueue(int capacity) {
+    checkArgument(capacity >= 0, "capacity must be non-negative but was %d", capacity);
+    this.capacity = capacity;
+    this.data = new LinkedList<>();
+  }
+
+  @Override
+  public Iterator<T> iterator() {
+    return data.iterator();
+  }
+
+  @Override
+  public int size() {
+    return data.size();
+  }
+
+  @Override
+  public boolean offer(T element) {
+    if (capacity == 0) return false;
+    if (data.size() == capacity) data.remove();
+    return data.add(element);
+  }
+
+  @Override
+  public T poll() {
+    return data.poll();
+  }
+
+  @Override
+  public T peek() {
+    return data.peek();
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index c444c050f..57de0b412 100644
--- a/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -21,7 +21,6 @@ import static org.assertj.core.util.Arrays.notAnArrayOfPrimitives;
 import static org.assertj.core.util.DateUtil.formatAsDatetime;
 import static org.assertj.core.util.DateUtil.formatAsDatetimeWithMs;
 import static org.assertj.core.util.Preconditions.checkArgument;
-import static org.assertj.core.util.Streams.stream;
 import static org.assertj.core.util.Strings.concat;
 import static org.assertj.core.util.Strings.quote;
 import static org.assertj.core.util.Throwables.getStackTrace;
@@ -62,7 +61,6 @@ import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.concurrent.atomic.AtomicStampedReference;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Function;
-import java.util.stream.Stream;
 
 import org.assertj.core.configuration.Configuration;
 import org.assertj.core.configuration.ConfigurationProvider;
@@ -633,7 +631,7 @@ public class StandardRepresentation implements Representation {
     if (iterable == null) return null;
     Iterator<?> iterator = iterable.iterator();
     if (!iterator.hasNext()) return start + end;
-    List<String> representedElements = representElements(stream(iterable), start, end, elementSeparator, indentation, root);
+    List<String> representedElements = representElements(iterable, start, end, elementSeparator, indentation, root);
     return representGroup(representedElements, start, end, elementSeparator, indentation);
   }
 
@@ -652,10 +650,14 @@ public class StandardRepresentation implements Representation {
 
   // private methods
 
-  private List<String> representElements(Stream<?> elements, String start, String end, String elementSeparator,
+  private List<String> representElements(Iterable<?> elements, String start, String end, String elementSeparator,
                                          String indentation, Object root) {
-    return elements.map(element -> safeStringOf(element, start, end, elementSeparator, indentation, root))
-                   .collect(toList());
+    int capacity = maxElementsForPrinting / 2 + 1;
+    HeadTailAccumulator<Object> accumulator = new HeadTailAccumulator<>(capacity, capacity);
+    elements.forEach(accumulator::add);
+
+    return accumulator.stream().map(element -> safeStringOf(element, start, end, elementSeparator, indentation, root))
+                      .collect(toList());
   }
 
   // this method only deals with max number of elements to display, the elements representation is already computed
diff --git a/assertj-core/src/test/java/org/assertj/core/presentation/BoundedQueue_Test.java b/assertj-core/src/test/java/org/assertj/core/presentation/BoundedQueue_Test.java
new file mode 100644
index 000000000..7b72522fa
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/presentation/BoundedQueue_Test.java
@@ -0,0 +1,150 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static org.assertj.core.api.Assertions.catchIllegalArgumentException;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.List;
+import java.util.Queue;
+import java.util.Random;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import com.google.common.collect.ImmutableList;
+
+final class BoundedQueue_Test {
+
+  private final Random random = new Random();
+
+  @ParameterizedTest
+  @MethodSource
+  void should_only_be_able_to_offer_up_to_capacity(int capacity, List<Integer> toAdd, List<Integer> expected) {
+    // GIVEN
+    Queue<Integer> bounded = new BoundedQueue<>(capacity);
+    // WHEN
+    for (int i : toAdd)
+      bounded.offer(i);
+    // THEN
+    then(bounded).containsExactlyElementsOf(expected);
+  }
+
+  static Stream<Arguments> should_only_be_able_to_offer_up_to_capacity() {
+    return Stream.of(Arguments.of(0, ImmutableList.of(1), ImmutableList.of()),
+                     Arguments.of(1, ImmutableList.of(1), ImmutableList.of(1)),
+                     Arguments.of(2, ImmutableList.of(1), ImmutableList.of(1)),
+                     Arguments.of(2, ImmutableList.of(1, 2), ImmutableList.of(1, 2)),
+                     Arguments.of(2, ImmutableList.of(1, 2, 3), ImmutableList.of(1, 2)),
+                     Arguments.of(3, ImmutableList.of(1, 2, 3, 4, 5), ImmutableList.of(1, 2, 3)));
+  }
+
+  @ParameterizedTest
+  @MethodSource("should_only_be_able_to_offer_up_to_capacity")
+  void should_only_be_able_to_add_up_to_capacity(int capacity, List<Integer> toAdd, List<Integer> expected) {
+    // GIVEN
+    Queue<Integer> bounded = new BoundedQueue<>(capacity);
+    // WHEN
+    for (int i : toAdd) {
+      try {
+        bounded.add(i);
+      } catch (IllegalStateException e) {
+        // expected if the queue is full
+      }
+    }
+    // THEN
+    then(bounded).containsExactlyElementsOf(expected);
+  }
+
+  @Test
+  void should_allow_null() {
+    // GIVEN
+    Queue<Integer> bounded = new BoundedQueue<>(3);
+    // WHEN
+    bounded.offer(null);
+    // THEN
+    then(bounded).containsExactly((Integer) null);
+  }
+
+  @Test
+  void should_not_be_able_to_add_over_capacity() {
+    // GIVEN
+    Queue<Integer> bounded = new BoundedQueue<>(1);
+    bounded.add(random.nextInt());
+    // WHEN
+    IllegalStateException exception = catchThrowableOfType(() -> bounded.add(random.nextInt()), IllegalStateException.class);
+    // THEN
+    then(exception).hasMessageContaining("full");
+    then(bounded).hasSize(1);
+  }
+
+  @Test
+  void should_be_able_to_peek_at_empty_queue() {
+    // GIVEN
+    Queue<Integer> bounded = new BoundedQueue<>(1);
+    // WHEN
+    Integer actual = bounded.peek();
+    // THEN
+    then(actual).isNull();
+  }
+
+  @Test
+  void should_be_able_to_peek_at_non_empty_queue() {
+    // GIVEN
+    Queue<Integer> bounded = new BoundedQueue<>(3);
+    Integer first = random.nextInt();
+    bounded.add(first);
+    bounded.add(random.nextInt());
+    // WHEN
+    Integer actual = bounded.peek();
+    // THEN
+    then(actual).isEqualTo(first);
+  }
+
+  @Test
+  void should_be_able_to_poll_empty_queue() {
+    // GIVEN
+    Queue<Integer> bounded = new BoundedQueue<>(1);
+    // WHEN
+    Integer actual = bounded.poll();
+    // THEN
+    then(actual).isNull();
+  }
+
+  @Test
+  void should_be_able_to_poll_non_empty_queue() {
+    // GIVEN
+    Queue<Integer> bounded = new BoundedQueue<>(3);
+    Integer first = random.nextInt();
+    bounded.add(first);
+    Integer second = random.nextInt();
+    bounded.add(second);
+    // WHEN
+    Integer actual = bounded.poll();
+    // THEN
+    then(actual).isEqualTo(first);
+    then(bounded).containsExactly(second);
+  }
+
+  @Test
+  void should_not_be_able_to_be_created_with_a_negative_capacity() {
+    // WHEN
+    IllegalArgumentException exception = catchIllegalArgumentException(() -> new BoundedQueue<>(-1));
+    // THEN
+    then(exception).hasMessageContainingAll("negative", "-1");
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/presentation/HeadTailAccumulator_Test.java b/assertj-core/src/test/java/org/assertj/core/presentation/HeadTailAccumulator_Test.java
new file mode 100644
index 000000000..7a670b9b6
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/presentation/HeadTailAccumulator_Test.java
@@ -0,0 +1,86 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static java.util.Collections.emptyList;
+import static org.assertj.core.api.Assertions.catchIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import com.google.common.collect.ImmutableList;
+
+final class HeadTailAccumulator_Test {
+  @ParameterizedTest
+  @MethodSource
+  void should_retain_the_expected_elements(int headCapacity, int tailCapacity, List<Integer> toAdd, List<Integer> expected) {
+    // GIVEN
+    HeadTailAccumulator<Integer> accumulator = new HeadTailAccumulator<>(headCapacity, tailCapacity);
+    // WHEN
+    for (int i : toAdd)
+      accumulator.add(i);
+    // THEN
+    then(accumulator.stream().collect(Collectors.toList())).containsExactlyElementsOf(expected);
+  }
+
+  static Stream<Arguments> should_retain_the_expected_elements() {
+    return Stream.of(// don't keep anything
+                     Arguments.of(0, 0, list(1, 2), emptyList()),
+                     // head only
+                     Arguments.of(2, 0, list(1, 2, 3, 4), list(1, 2)),
+                     // tail only
+                     Arguments.of(0, 2, list(1, 2, 3, 4), list(3, 4)),
+                     // both head and tail
+                     Arguments.of(1, 1, list(1, 2, 3), list(1, 3)),
+                     Arguments.of(2, 2, list(1, 2, 3, 4, 5, 6), list(1, 2, 5, 6)),
+                     Arguments.of(1, 3, list(1, 2, 3, 4, 5, 6), list(1, 4, 5, 6)),
+                     // keep everything if the sum of the capacities is at least the number of elements
+                     Arguments.of(3, 3, list(1, 2, 3, 4, 5, 6), list(1, 2, 3, 4, 5, 6)),
+                     Arguments.of(2, 6, list(1, 2, 3, 4, 5, 6), ImmutableList.of(1, 2, 3, 4, 5, 6)));
+  }
+
+  @Test
+  void should_allow_null() {
+    // GIVEN
+    HeadTailAccumulator<Integer> accumulator = new HeadTailAccumulator<>(1, 1);
+    // WHEN
+    accumulator.add(null);
+    accumulator.add(null);
+    // THEN
+    then(accumulator.stream()).containsExactly(null, null);
+  }
+
+  @Test
+  void should_not_be_able_to_be_created_with_a_negative_head_capacity() {
+    // WHEN
+    IllegalArgumentException exception = catchIllegalArgumentException(() -> new HeadTailAccumulator<>(-1, 1));
+    // THEN
+    then(exception).hasMessageContainingAll("negative", "head", "-1");
+  }
+
+  @Test
+  void should_not_be_able_to_be_created_with_a_negative_tail_capacity() {
+    // WHEN
+    IllegalArgumentException exception = catchIllegalArgumentException(() -> new HeadTailAccumulator<>(1, -1));
+    // THEN
+    then(exception).hasMessageContainingAll("negative", "tail", "-1");
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/presentation/RotatingQueue_Test.java b/assertj-core/src/test/java/org/assertj/core/presentation/RotatingQueue_Test.java
new file mode 100644
index 000000000..f17b647fd
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/presentation/RotatingQueue_Test.java
@@ -0,0 +1,157 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static org.assertj.core.api.Assertions.catchIllegalArgumentException;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.List;
+import java.util.Queue;
+import java.util.Random;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+import com.google.common.collect.ImmutableList;
+
+final class RotatingQueue_Test {
+
+  private final Random random = new Random();
+
+  @Test
+  void should_not_be_able_to_offer_zero_capacity_queue() {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(0);
+    // WHEN
+    boolean actual = rotating.offer(random.nextInt());
+    // THEN
+    then(actual).isFalse();
+    then(rotating.isEmpty()).isTrue();
+  }
+
+  @Test
+  void should_not_be_able_to_add_to_zero_capacity_queue() {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(0);
+    // WHEN
+    IllegalStateException exception = catchThrowableOfType(() -> rotating.add(random.nextInt()),
+                                                           IllegalStateException.class);
+    // THEN
+    then(exception).hasMessageContaining("full");
+  }
+
+  @ParameterizedTest
+  @MethodSource("should_rotate_old_elements_source")
+  void should_rotate_old_elements_with_offer(
+                                             int capacity, List<Integer> toAdd, List<Integer> expected) {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(capacity);
+    // WHEN
+    for (int i : toAdd)
+      rotating.offer(i);
+    // THEN
+    then(rotating).containsExactlyElementsOf(expected);
+  }
+
+  @ParameterizedTest
+  @MethodSource("should_rotate_old_elements_source")
+  void should_rotate_old_elements_with_add(
+                                           int capacity, List<Integer> toAdd, List<Integer> expected) {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(capacity);
+    // WHEN
+    for (int i : toAdd) {
+      rotating.add(i);
+    }
+    // THEN
+    then(rotating).containsExactlyElementsOf(expected);
+  }
+
+  static Stream<Arguments> should_rotate_old_elements_source() {
+    return Stream.of(Arguments.of(1, ImmutableList.of(1), ImmutableList.of(1)),
+                     Arguments.of(2, ImmutableList.of(1), ImmutableList.of(1)),
+                     Arguments.of(2, ImmutableList.of(1, 2), ImmutableList.of(1, 2)),
+                     Arguments.of(2, ImmutableList.of(1, 2, 3), ImmutableList.of(2, 3)),
+                     Arguments.of(3, ImmutableList.of(1, 2, 3, 4, 5), ImmutableList.of(3, 4, 5)));
+  }
+
+  @Test
+  void should_allow_null() {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(3);
+    // WHEN
+    rotating.offer(null);
+    // THEN
+    then(rotating).containsExactly((Integer) null);
+  }
+
+  @Test
+  void should_be_able_to_peek_at_empty_queue() {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(1);
+    // WHEN
+    Integer actual = rotating.peek();
+    // THEN
+    then(actual).isNull();
+  }
+
+  @Test
+  void should_be_able_to_peek_at_non_empty_queue() {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(3);
+    Integer first = random.nextInt();
+    rotating.add(first);
+    rotating.add(random.nextInt());
+    // WHEN
+    Integer actual = rotating.peek();
+    // THEN
+    then(actual).isEqualTo(first);
+  }
+
+  @Test
+  void should_be_able_to_poll_empty_queue() {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(1);
+    // WHEN
+    Integer actual = rotating.poll();
+    // THEN
+    then(actual).isNull();
+  }
+
+  @Test
+  void should_be_able_to_poll_non_empty_queue() {
+    // GIVEN
+    Queue<Integer> rotating = new RotatingQueue<>(3);
+    Integer first = random.nextInt();
+    rotating.add(first);
+    Integer second = random.nextInt();
+    rotating.add(second);
+    // WHEN
+    Integer actual = rotating.poll();
+    // THEN
+    then(actual).isEqualTo(first);
+    then(rotating).containsExactly(second);
+  }
+
+  @Test
+  void should_not_be_able_to_be_created_with_a_negative_capacity() {
+    // WHEN
+    IllegalArgumentException exception = catchIllegalArgumentException(() -> new RotatingQueue<>(-1));
+    // THEN
+    then(exception).hasMessageContainingAll("non-negative", "-1");
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java b/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
index 03fa271da..6af241f16 100644
--- a/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
@@ -25,11 +25,17 @@ import static org.mockito.Mockito.withSettings;
 
 import java.nio.file.DirectoryStream;
 import java.nio.file.SecureDirectoryStream;
+import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.List;
 import java.util.UUID;
+import java.util.concurrent.TimeUnit;
 import java.util.stream.Stream;
 
+import org.apache.commons.lang3.StringUtils;
+import org.assertj.core.configuration.Configuration;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
@@ -260,6 +266,23 @@ class StandardRepresentation_iterable_format_Test extends AbstractBaseRepresenta
     then(formatted).isEqualTo("[{\"a\":1}]");
   }
 
+  @Test
+  @Timeout(value = 1, unit = TimeUnit.SECONDS)
+  void should_format_big_list() {
+    // GIVEN
+    int elementsPerArray = 200;
+    List<int[]> numbers = new ArrayList<>();
+    for (int i = 0; i < 1 << 18; i++) {
+      numbers.add(new int[elementsPerArray]);
+    }
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.toStringOf(numbers);
+    // THEN
+    then(formatted).contains("...");
+    then(StringUtils.countMatches(formatted, "0")).isEqualTo(
+                                                             Configuration.MAX_ELEMENTS_FOR_PRINTING * elementsPerArray);
+  }
+
   private static String stringOfLength(int length) {
     return Stream.generate(() -> "a").limit(length).collect(joining());
   }
