diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/ComparisonDifference.java b/src/main/java/org/assertj/core/api/recursive/comparison/ComparisonDifference.java
index 4d54dcc69..1bfb4eb97 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/ComparisonDifference.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/ComparisonDifference.java
@@ -38,9 +38,9 @@ public class ComparisonDifference implements Comparable<ComparisonDifference> {
   private static final String FIELD = "field/property '%s'";
   private static final String TOP_LEVEL_OBJECTS = "Top level actual and expected objects";
   private static final String TOP_LEVEL_ELEMENTS = "Top level actual and expected objects element at index %s";
-  private static final String TEMPLATE = "%s differ:%n" +
-                                         "- actual value   : %s%n" +
-                                         "- expected value : %s%s";
+  static final String TEMPLATE = "%s differ:%n" +
+                                 "- actual value  : %s%n" +
+                                 "- expected value: %s%s";
 
   final List<String> decomposedPath;
   final String concatenatedPath;
@@ -105,8 +105,8 @@ public class ComparisonDifference implements Comparable<ComparisonDifference> {
                   additionalInfo);
   }
 
-  // retuns a user friendly path that can differ from DualValue field location
-  private String fieldPathDescription() {
+  // returns a user friendly path description
+  protected String fieldPathDescription() {
     if (concatenatedPath.isEmpty()) return TOP_LEVEL_OBJECTS;
     if (concatenatedPath.matches(TOP_LEVEL_ELEMENT_PATTERN)) return format(TOP_LEVEL_ELEMENTS, extractIndex(concatenatedPath));
     return format(FIELD, concatenatedPath);
@@ -150,7 +150,11 @@ public class ComparisonDifference implements Comparable<ComparisonDifference> {
   @Override
   public int compareTo(final ComparisonDifference other) {
     // we don't use '.' to join path before comparing them as it would make a.b < aa
-    return join("", decomposedPath).compareTo(join("", other.decomposedPath));
+    return concat(decomposedPath).compareTo(concat(other.decomposedPath));
+  }
+
+  private static String concat(List<String> decomposedPath) {
+    return join("", decomposedPath);
   }
 
 }
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/ComparisonKeyDifference.java b/src/main/java/org/assertj/core/api/recursive/comparison/ComparisonKeyDifference.java
new file mode 100644
index 000000000..0e7b54457
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/ComparisonKeyDifference.java
@@ -0,0 +1,53 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static java.lang.String.format;
+
+import org.assertj.core.internal.UnambiguousRepresentation;
+import org.assertj.core.presentation.Representation;
+
+public class ComparisonKeyDifference extends ComparisonDifference {
+
+  static final String TEMPLATE_FOR_KEY_DIFFERENCE = "map key difference:%n" +
+                                                    "- actual key  : %s%n" +
+                                                    "- expected key: %s";
+
+  final Object actualKey;
+  final Object expectedKey;
+
+  public ComparisonKeyDifference(DualValue dualValue, Object actualKey, Object expectedKey) {
+    super(dualValue);
+    this.actualKey = actualKey;
+    this.expectedKey = expectedKey;
+  }
+
+  @Override
+  public String toString() {
+    return format("ComparisonDifference [path=%s, actualKey=%s, expectedKey=%s]", concatenatedPath, actualKey, expectedKey);
+  }
+
+  @Override
+  public String multiLineDescription(Representation representation) {
+    UnambiguousRepresentation unambiguousRepresentation = new UnambiguousRepresentation(representation, actual, expected);
+    UnambiguousRepresentation unambiguousKeyRepresentation = new UnambiguousRepresentation(representation, actualKey,
+                                                                                           expectedKey);
+    return format(TEMPLATE + "%n" + TEMPLATE_FOR_KEY_DIFFERENCE,
+                  fieldPathDescription(),
+                  unambiguousRepresentation.getActual(),
+                  unambiguousRepresentation.getExpected(),
+                  "",
+                  unambiguousKeyRepresentation.getActual(),
+                  unambiguousKeyRepresentation.getExpected());
+  }
+}
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index f48291906..a90dcd794 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -86,6 +86,10 @@ public class RecursiveComparisonDifferenceCalculator {
       differences.add(new ComparisonDifference(dualValue, format(description, args)));
     }
 
+    void addKeyDifference(DualValue parentDualValue, Object actualKey, Object expectedKey) {
+      differences.add(new ComparisonKeyDifference(parentDualValue, actualKey, expectedKey));
+    }
+
     public List<ComparisonDifference> getDifferences() {
       Collections.sort(differences);
       return differences;
@@ -460,12 +464,17 @@ public class RecursiveComparisonDifferenceCalculator {
       // - expected entries not found in actual.
     }
     Iterator<Map.Entry<K, V>> expectedMapEntries = expectedMap.entrySet().iterator();
-    FieldLocation fieldLocation = dualValue.fieldLocation;
     for (Map.Entry<?, ?> actualEntry : actualMap.entrySet()) {
       Map.Entry<?, ?> expectedEntry = expectedMapEntries.next();
-      // Must split the Key and Value so that Map.Entry's equals() method is not used.
-      comparisonState.registerForComparison(new DualValue(fieldLocation, actualEntry.getKey(), expectedEntry.getKey()));
-      comparisonState.registerForComparison(new DualValue(fieldLocation, actualEntry.getValue(), expectedEntry.getValue()));
+      // check keys are matched before comparing values as keys represents a field
+      if (!java.util.Objects.equals(actualEntry.getKey(), expectedEntry.getKey())) {
+        // report a missing key/field.
+        comparisonState.addKeyDifference(dualValue, actualEntry.getKey(), expectedEntry.getKey());
+      } else {
+        // as the key/field match we can simply compare field/key values
+        FieldLocation keyFieldLocation = keyFieldLocation(dualValue.fieldLocation, actualEntry.getKey());
+        comparisonState.registerForComparison(new DualValue(keyFieldLocation, actualEntry.getValue(), expectedEntry.getValue()));
+      }
     }
   }
 
@@ -506,13 +515,16 @@ public class RecursiveComparisonDifferenceCalculator {
     for (Map.Entry<?, ?> actualEntry : actualMap.entrySet()) {
       int deepHashCode = actualDeepHashCodesByKey.get(actualEntry.getKey());
       Map.Entry<?, ?> expectedEntry = expectedEntriesByDeepHashCode.get(deepHashCode);
-      // Must split the Key and Value so that Map.Entry's equals() method is not used.
-      FieldLocation fieldLocation = dualValue.fieldLocation;
-      comparisonState.registerForComparison(new DualValue(fieldLocation, actualEntry.getKey(), expectedEntry.getKey()));
-      comparisonState.registerForComparison(new DualValue(fieldLocation, actualEntry.getValue(), expectedEntry.getValue()));
+      // since we have found an entry in expected with the actual entry key, we just need to compare entry values.
+      FieldLocation keyFieldLocation = keyFieldLocation(dualValue.fieldLocation, actualEntry.getKey());
+      comparisonState.registerForComparison(new DualValue(keyFieldLocation, actualEntry.getValue(), expectedEntry.getValue()));
     }
   }
 
+  private static FieldLocation keyFieldLocation(FieldLocation parentFieldLocation, Object key) {
+    return key == null ? parentFieldLocation : parentFieldLocation.field(key.toString());
+  }
+
   private static void compareOptional(DualValue dualValue, ComparisonState comparisonState) {
     if (!dualValue.isActualFieldAnOptional()) {
       comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an Optional"));
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_compareTo_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_compareTo_Test.java
index e6561652e..073a07fbe 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_compareTo_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_compareTo_Test.java
@@ -35,7 +35,7 @@ class ComparisonDifference_compareTo_Test {
     // WHEN
     Set<ComparisonDifference> differences = newTreeSet(diff1, diff2, diff3, diff4, diff5, diff6);
     // THEN
-    assertThat(differences).extracting(input -> input.concatenatedPath)
+    assertThat(differences).extracting(diff -> diff.concatenatedPath)
                            .containsExactly("aa", "aaa", "a.b", "a.b.c", "a.c", "b");
   }
 
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_multiLineDescription_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_multiLineDescription_Test.java
index 2ef880ca6..8e9a61c64 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_multiLineDescription_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_multiLineDescription_Test.java
@@ -43,8 +43,8 @@ class ComparisonDifference_multiLineDescription_Test {
     String multiLineDescription = comparisonDifference.multiLineDescription();
     // THEN
     assertThat(multiLineDescription).isEqualTo(format("field/property 'a.b' differ:%n" +
-                                                      "- actual value   : \"foo\"%n" +
-                                                      "- expected value : \"bar\""));
+                                                      "- actual value  : \"foo\"%n" +
+                                                      "- expected value: \"bar\""));
   }
 
   @Test
@@ -55,8 +55,8 @@ class ComparisonDifference_multiLineDescription_Test {
     String multiLineDescription = comparisonDifference.multiLineDescription();
     // THEN
     assertThat(multiLineDescription).isEqualTo(format("Top level actual and expected objects differ:%n" +
-                                                      "- actual value   : \"foo\"%n" +
-                                                      "- expected value : \"bar\""));
+                                                      "- actual value  : \"foo\"%n" +
+                                                      "- expected value: \"bar\""));
   }
 
   @ParameterizedTest(name = "path {0}, index {1}")
@@ -68,8 +68,8 @@ class ComparisonDifference_multiLineDescription_Test {
     String multiLineDescription = comparisonDifference.multiLineDescription();
     // THEN
     assertThat(multiLineDescription).isEqualTo(format("Top level actual and expected objects element at index %s differ:%n" +
-                                                      "- actual value   : \"foo\"%n" +
-                                                      "- expected value : \"bar\"", index));
+                                                      "- actual value  : \"foo\"%n" +
+                                                      "- expected value: \"bar\"", index));
   }
 
   @ParameterizedTest(name = "path {0}, index {1}")
@@ -81,8 +81,8 @@ class ComparisonDifference_multiLineDescription_Test {
     String multiLineDescription = comparisonDifference.multiLineDescription();
     // THEN
     assertThat(multiLineDescription).isEqualTo(format("field/property %s differ:%n" +
-                                                      "- actual value   : \"foo\"%n" +
-                                                      "- expected value : \"bar\"", index));
+                                                      "- actual value  : \"foo\"%n" +
+                                                      "- expected value: \"bar\"", index));
   }
 
   private static Stream<Arguments> multiline_description_should_indicate_element_difference() {
@@ -101,8 +101,8 @@ class ComparisonDifference_multiLineDescription_Test {
     String multiLineDescription = comparisonDifference.multiLineDescription();
     // THEN
     assertThat(multiLineDescription).contains("field/property 'a.b' differ:")
-                                    .contains("- actual value   : [\"bar\", \"foo\"] (LinkedHashSet@")
-                                    .contains("- expected value : [\"bar\", \"foo\"] (TreeSet@");
+                                    .contains("- actual value  : [\"bar\", \"foo\"] (LinkedHashSet@")
+                                    .contains("- expected value: [\"bar\", \"foo\"] (TreeSet@");
   }
 
   @Test
@@ -115,8 +115,8 @@ class ComparisonDifference_multiLineDescription_Test {
     String multiLineDescription = comparisonDifference.multiLineDescription();
     // THEN
     assertThat(multiLineDescription).contains("field/property 'a.b' differ:")
-                                    .contains("- actual value   : {1L=true, 2L=false} (LinkedHashMap@")
-                                    .contains("- expected value : {1L=true, 2L=false} (TreeMap@");
+                                    .contains("- actual value  : {1L=true, 2L=false} (LinkedHashMap@")
+                                    .contains("- expected value: {1L=true, 2L=false} (TreeMap@");
   }
 
   @Test
@@ -126,8 +126,8 @@ class ComparisonDifference_multiLineDescription_Test {
     ComparisonDifference com = new ComparisonDifference(dualValue, "additional information");
     // THEN
     assertThat(com.multiLineDescription()).isEqualTo(format("field/property 'a.b' differ:%n" +
-                                                            "- actual value   : \"foo\"%n" +
-                                                            "- expected value : \"bar\"%n" +
+                                                            "- actual value  : \"foo\"%n" +
+                                                            "- expected value: \"bar\"%n" +
                                                             "additional information"));
   }
 
@@ -138,8 +138,8 @@ class ComparisonDifference_multiLineDescription_Test {
     ComparisonDifference com = new ComparisonDifference(dualValue, "%additional %information%");
     // THEN
     assertThat(com.multiLineDescription()).isEqualTo(format("field/property 'a.b' differ:%n" +
-                                                            "- actual value   : \"foo%%\"%n" +
-                                                            "- expected value : \"%%bar%%%%\"%n" +
+                                                            "- actual value  : \"foo%%\"%n" +
+                                                            "- expected value: \"%%bar%%%%\"%n" +
                                                             "%%additional %%information%%"));
   }
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_rootComparisonDifference_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_rootComparisonDifference_Test.java
index 704cc6f0a..01b37e7bc 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_rootComparisonDifference_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonDifference_rootComparisonDifference_Test.java
@@ -28,8 +28,8 @@ class ComparisonDifference_rootComparisonDifference_Test {
     String multiLineDescription = comparisonDifference.multiLineDescription();
     // THEN
     assertThat(multiLineDescription).isEqualTo(format("Top level actual and expected objects differ:%n" +
-                                                      "- actual value   : \"foo\"%n" +
-                                                      "- expected value : \"bar\"%n" +
+                                                      "- actual value  : \"foo\"%n" +
+                                                      "- expected value: \"bar\"%n" +
                                                       "info"));
   }
 
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonKeyDifference_multiLineDescription_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonKeyDifference_multiLineDescription_Test.java
new file mode 100644
index 000000000..a39d323fc
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/ComparisonKeyDifference_multiLineDescription_Test.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.Lists.list;
+
+import org.junit.jupiter.api.Test;
+
+class ComparisonKeyDifference_multiLineDescription_Test {
+
+  @Test
+  void should_build_a_multiline_description() {
+    // GIVEN
+    DualValue dualValue = new DualValue(list("a", "b"), "foo", "bar");
+    ComparisonDifference comparisonDifference = new ComparisonKeyDifference(dualValue, "k1", "k2");
+    // WHEN
+    String multiLineDescription = comparisonDifference.multiLineDescription();
+    // THEN
+    assertThat(multiLineDescription).isEqualTo(format("field/property 'a.b' differ:%n" +
+                                                      "- actual value  : \"foo\"%n" +
+                                                      "- expected value: \"bar\"%n" +
+                                                      "map key difference:%n" +
+                                                      "- actual key  : \"k1\"%n" +
+                                                      "- expected key: \"k2\""));
+  }
+
+  @Test
+  void multiline_description_should_indicate_top_level_objects_difference() {
+    // GIVEN
+    ComparisonDifference comparisonDifference = new ComparisonKeyDifference(new DualValue(list(), "foo", "bar"), "k1", "k2");
+    // WHEN
+    String multiLineDescription = comparisonDifference.multiLineDescription();
+    // THEN
+    assertThat(multiLineDescription).isEqualTo(format("Top level actual and expected objects differ:%n" +
+                                                      "- actual value  : \"foo\"%n" +
+                                                      "- expected value: \"bar\"%n" +
+                                                      "map key difference:%n" +
+                                                      "- actual key  : \"k1\"%n" +
+                                                      "- expected key: \"k2\""));
+  }
+
+  @Test
+  void should_build_multiline_description_containing_percent() {
+    // GIVEN
+    DualValue dualValue = new DualValue(list("a", "b"), "foo%", "%bar%%");
+    ComparisonDifference com = new ComparisonKeyDifference(dualValue, "%k1", "%k2%%");
+    // THEN
+    assertThat(com.multiLineDescription()).isEqualTo(format("field/property 'a.b' differ:%n" +
+                                                            "- actual value  : \"foo%%\"%n" +
+                                                            "- expected value: \"%%bar%%%%\"%n" +
+                                                            "map key difference:%n" +
+                                                            "- actual key  : \"%%k1\"%n" +
+                                                            "- expected key: \"%%k2%%%%\""));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_bddSoftAssertions_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_bddSoftAssertions_Test.java
index 8b88b65ee..0f125dab8 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_bddSoftAssertions_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_bddSoftAssertions_Test.java
@@ -61,11 +61,11 @@ class RecursiveComparisonAssert_bddSoftAssertions_Test extends RecursiveComparis
     List<Throwable> errorsCollected = softly.errorsCollected();
     assertThat(errorsCollected).hasSize(2);
     assertThat(errorsCollected.get(0)).hasMessageContaining("field/property 'home.address.number' differ:")
-                                      .hasMessageContaining("- actual value   : 1")
-                                      .hasMessageContaining("- expected value : 2");
+                                      .hasMessageContaining("- actual value  : 1")
+                                      .hasMessageContaining("- expected value: 2");
     assertThat(errorsCollected.get(1)).hasMessageContaining("field/property 'home.address.number' differ:")
-                                      .hasMessageContaining("- actual value   : 2")
-                                      .hasMessageContaining("- expected value : 1");
+                                      .hasMessageContaining("- actual value  : 2")
+                                      .hasMessageContaining("- expected value: 1");
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_for_maps_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_for_maps_Test.java
index a9af0938b..a23081897 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_for_maps_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_for_maps_Test.java
@@ -12,9 +12,12 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.test.Maps.mapOf;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 
 import java.util.Map;
 
@@ -22,6 +25,9 @@ import org.assertj.core.internal.objects.data.PersonDto;
 import org.assertj.core.test.Person;
 import org.junit.jupiter.api.Test;
 
+import com.google.common.collect.ImmutableMap;
+import com.google.common.collect.ImmutableSortedMap;
+
 class RecursiveComparisonAssert_for_maps_Test {
 
   @Test
@@ -48,4 +54,63 @@ class RecursiveComparisonAssert_for_maps_Test {
                 .isEqualTo(expected);
   }
 
+  @Test
+  public void should_honor_ignored_fields() {
+    // GIVEN
+    Map<String, Object> mapA = ImmutableMap.of("foo", "bar", "description", "foobar", "submap",
+                                               ImmutableMap.of("subFoo", "subBar", "description", "subFooBar"));
+    Map<String, Object> mapB = ImmutableMap.of("foo", "bar", "description", "barfoo", "submap",
+                                               ImmutableMap.of("subFoo", "subBar", "description", "subBarFoo"));
+    // THEN
+    assertThat(mapA).usingRecursiveComparison()
+                    .ignoringFields("description", "submap.description")
+                    .isEqualTo(mapB);
+    assertThat(mapA).usingRecursiveComparison()
+                    .ignoringFieldsMatchingRegexes(".*description")
+                    .isEqualTo(mapB);
+  }
+
+  @Test
+  public void should_honor_ignored_fields_with_sorted_maps() {
+    // GIVEN
+    Map<String, Object> mapA = ImmutableSortedMap.of("foo", "bar", "description", "foobar", "submap",
+                                                     ImmutableSortedMap.of("subFoo", "subBar", "description", "subFooBar"));
+    Map<String, Object> mapB = ImmutableSortedMap.of("foo", "bar", "description", "barfoo", "submap",
+                                                     ImmutableSortedMap.of("subFoo", "subBar", "description", "subBarFoo"));
+    // THEN
+    assertThat(mapA).usingRecursiveComparison()
+                    .ignoringFields("description", "submap.description")
+                    .isEqualTo(mapB);
+    assertThat(mapA).usingRecursiveComparison()
+                    .ignoringFieldsMatchingRegexes(".*description")
+                    .isEqualTo(mapB);
+  }
+
+  @Test
+  public void should_repor_missing_keys_as_missing_fields() {
+    // GIVEN
+    Map<String, Object> mapA = ImmutableSortedMap.of("foo", "bar", "desc", "foobar", "submap",
+                                                     ImmutableSortedMap.of("subFoo", "subBar", "description", "subFooBar"));
+    Map<String, Object> mapB = ImmutableSortedMap.of("fu", "bar", "description", "foobar", "submap",
+                                                     ImmutableSortedMap.of("subFu", "subBar", "description", "subFuBar"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(mapA).usingRecursiveComparison()
+                                                                               .isEqualTo(mapB));
+    // THEN
+    then(assertionError).hasMessageContainingAll(format("map key difference:%n"
+                                                        + "- actual key  : \"foo\"%n"
+                                                        + "- expected key: \"fu\""),
+                                                 format("map key difference:%n"
+                                                        + "- actual key  : \"desc\"%n"
+                                                        + "- expected key: \"description\""),
+                                                 format("map key difference:%n"
+                                                        + "- actual key  : \"subFoo\"%n"
+                                                        + "- expected key: \"subFu\""),
+                                                 format("field/property 'submap.description' differ:%n"
+                                                        + "- actual value  : \"subFooBar\"%n"
+                                                        + "- expected value: \"subFuBar\"")
+
+    );
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
index 1472ad20d..d62a72203 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
@@ -70,7 +70,7 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends RecursiveC
                                               + "  [Person[name='Sheldon']]"))),
                      Arguments.of(actualAsArray, expectedAsArray, diff("[0]", sheldon, sheldonDto)),
                      Arguments.of(actualAsOptional, expectedAsOptional, diff("value", sheldon, sheldonDto)),
-                     Arguments.of(actualAsMap, expectedAsMap, diff("", sheldon, sheldonDto)));
+                     Arguments.of(actualAsMap, expectedAsMap, diff("sheldon", sheldon, sheldonDto)));
   }
 
   @ParameterizedTest(name = "author 1 {0} / author 2 {1}")
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
index b53c79684..c9e15b741 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
@@ -128,7 +128,7 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
                      Arguments.of(nonSortedPratchettAndMartin, sortedMartinAndPratchett, "group",
                                   nonSortedPratchettAndMartin, sortedMartinAndPratchett,
                                   "expected field is a sorted map but actual field is not (java.util.LinkedHashMap)"),
-                     Arguments.of(singletonMap(pratchett.name, none), singletonPratchettMap, "group",
+                     Arguments.of(singletonMap(pratchett.name, none), singletonPratchettMap, "group.Terry Pratchett",
                                   none, pratchett, null),
                      Arguments.of(singletonPratchettMap, singletonMap(georgeMartin.name, pratchett), "group",
                                   singletonPratchettMap, singletonMap(georgeMartin.name, pratchett),
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_softAssertions_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_softAssertions_Test.java
index 494eb409a..6bcc6e9fe 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_softAssertions_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_softAssertions_Test.java
@@ -61,11 +61,11 @@ class RecursiveComparisonAssert_softAssertions_Test extends RecursiveComparisonA
     List<Throwable> errorsCollected = softly.errorsCollected();
     assertThat(errorsCollected).hasSize(2);
     assertThat(errorsCollected.get(0)).hasMessageContaining("field/property 'home.address.number' differ:")
-                                      .hasMessageContaining("- actual value   : 1")
-                                      .hasMessageContaining("- expected value : 2");
+                                      .hasMessageContaining("- actual value  : 1")
+                                      .hasMessageContaining("- expected value: 2");
     assertThat(errorsCollected.get(1)).hasMessageContaining("field/property 'home.address.number' differ:")
-                                      .hasMessageContaining("- actual value   : 2")
-                                      .hasMessageContaining("- expected value : 1");
+                                      .hasMessageContaining("- actual value  : 2")
+                                      .hasMessageContaining("- expected value: 1");
   }
 
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively_create_Test.java
index 616072ee6..ad3f91b78 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively_create_Test.java
@@ -219,12 +219,12 @@ class ShouldBeEqualByComparingFieldByFieldRecursively_create_Test {
                                    "when recursively comparing field by field, but found the following 2 differences:%n" +
                                    "%n" +
                                    "field/property 'first' differ:%n" +
-                                   "- actual value   : \"Magic\"%n" +
-                                   "- expected value : null%n" +
+                                   "- actual value  : \"Magic\"%n" +
+                                   "- expected value: null%n" +
                                    "%n" +
                                    "field/property 'last' differ:%n" +
-                                   "- actual value   : \"Johnson\"%n" +
-                                   "- expected value : \"Ginobili\"%n" +
+                                   "- actual value  : \"Johnson\"%n" +
+                                   "- expected value: \"Ginobili\"%n" +
                                    "%n" +
                                    "The recursive comparison was performed with this configuration:%n%s",
                                    CONFIGURATION_PROVIDER.representation().toStringOf(recursiveComparisonConfiguration)));
@@ -255,8 +255,8 @@ class ShouldBeEqualByComparingFieldByFieldRecursively_create_Test {
                                    "when recursively comparing field by field, but found the following difference:%n" +
                                    "%n" +
                                    "field/property 'first' differ:%n" +
-                                   "- actual value   : \"Magic\"%n" +
-                                   "- expected value : null%n" +
+                                   "- actual value  : \"Magic\"%n" +
+                                   "- expected value: null%n" +
                                    "%n" +
                                    "The recursive comparison was performed with this configuration:%n%s",
                                    CONFIGURATION_PROVIDER.representation().toStringOf(recursiveComparisonConfiguration)));
@@ -287,8 +287,8 @@ class ShouldBeEqualByComparingFieldByFieldRecursively_create_Test {
                                    "when recursively comparing field by field, but found the following difference:%n" +
                                    "%n" +
                                    "field/property 'first' differ:%n" +
-                                   "- actual value   : \"%%%%Ma%%gi%%\"%n" +
-                                   "- expected value : null%n" +
+                                   "- actual value  : \"%%%%Ma%%gi%%\"%n" +
+                                   "- expected value: null%n" +
                                    "%n" +
                                    "The recursive comparison was performed with this configuration:%n%s",
                                    CONFIGURATION_PROVIDER.representation().toStringOf(recursiveComparisonConfiguration)));
