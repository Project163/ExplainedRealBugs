diff --git a/src/main/java/org/assertj/core/api/ComparatorFactory.java b/src/main/java/org/assertj/core/api/ComparatorFactory.java
index a301ace33..9107cafa4 100644
--- a/src/main/java/org/assertj/core/api/ComparatorFactory.java
+++ b/src/main/java/org/assertj/core/api/ComparatorFactory.java
@@ -12,10 +12,12 @@
  */
 package org.assertj.core.api;
 
-import static java.lang.Math.abs;
-
+import java.math.BigDecimal;
 import java.util.Comparator;
 
+import org.assertj.core.internal.Doubles;
+import org.assertj.core.internal.Floats;
+
 public class ComparatorFactory {
 
   public static final ComparatorFactory INSTANCE = new ComparatorFactory();
@@ -23,15 +25,23 @@ public class ComparatorFactory {
   public Comparator<Double> doubleComparatorWithPrecision(double precision) {
     // can't use <> with anonymous class in java 8
     return new Comparator<Double>() {
+
       @Override
-      public int compare(Double o1, Double o2) {
-        if (abs(o1 - o2) < precision) return 0;
-        return o1 - o2 > 0 ? 1 : -1;
+      public int compare(Double double1, Double double2) {
+        if (Doubles.instance().isNanOrInfinite(precision)) {
+          throw new IllegalArgumentException("Precision should not be Nan or Infinity!");
+        }
+        // handle NAN or Infinity cases with Java Float behavior (and not BigDecimal that are used afterwards)
+        if (Doubles.instance().isNanOrInfinite(double1) || Doubles.instance().isNanOrInfinite(double2)) {
+          return Double.compare(double1, double2);
+        }
+        // if floats are close enough they are considered equal, otherwise we compare as BigDecimal which does exact computation.
+        return isWithinPrecision(double1, double2, precision) ? 0 : asBigDecimal(double1).compareTo(asBigDecimal(double2));
       }
 
       @Override
       public String toString() {
-        return "double comparator at precision " + precision;
+        return "double comparator at precision " + precision + " (values are considered equal if diff == precision)";
       }
     };
   }
@@ -39,17 +49,54 @@ public class ComparatorFactory {
   public Comparator<Float> floatComparatorWithPrecision(float precision) {
     // can't use <> with anonymous class in java 8
     return new Comparator<Float>() {
+
       @Override
-      public int compare(Float o1, Float o2) {
-        if (abs(o1 - o2) < precision) return 0;
-        return o1 - o2 > 0 ? 1 : -1;
+      public int compare(Float float1, Float float2) {
+        Floats floats = Floats.instance();
+        if (floats.isNanOrInfinite(precision)) {
+          throw new IllegalArgumentException("Precision should not be Nan or Infinity!");
+        }
+        // handle NAN or Infinity cases with Java Float behavior (and not BigDecimal that are used afterwards)
+        if (floats.isNanOrInfinite(float1) || floats.isNanOrInfinite(float2)) {
+          return Float.compare(float1, float2);
+        }
+        // if floats are close enough they are considered equal, otherwise we compare as BigDecimal which does exact computation.
+        return isWithinPrecision(float1, float2, precision) ? 0 : asBigDecimal(float1).compareTo(asBigDecimal(float2));
       }
 
       @Override
       public String toString() {
-        return "float comparator at precision " + precision;
+        return "float comparator at precision " + precision + " (values are considered equal if diff == precision)";
       }
     };
   }
 
+  /**
+   * Convert to a precise BigDecimal object using an intermediate String.
+   *
+   * @param <T> type of expected and precision, which should be the subclass of java.lang.Number and java.lang.Comparable
+   * @param number the Number to convert
+   * @return the built BigDecimal
+   */
+  private static <T extends Number> BigDecimal asBigDecimal(T number) {
+    return new BigDecimal(String.valueOf(number));
+  }
+
+  /**
+   * Returns true if the abs(expected - precision) is &lt;= precision, false otherwise.
+   * @param actual    the actual value
+   * @param expected  the expected value
+   * @param precision the acceptable precision
+   *
+   * @param <T> type of number to compare including the precision
+   * @return whether true if the abs(expected - precision) is <= precision, false otherwise.
+   */
+  private static <T extends Number> boolean isWithinPrecision(T actual, T expected, T precision) {
+    BigDecimal expectedBigDecimal = asBigDecimal(expected);
+    BigDecimal actualBigDecimal = asBigDecimal(actual);
+    BigDecimal absDifference = expectedBigDecimal.subtract(actualBigDecimal).abs();
+    BigDecimal precisionAsBigDecimal = asBigDecimal(precision);
+    return absDifference.compareTo(precisionAsBigDecimal) <= 0;
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/internal/Doubles.java b/src/main/java/org/assertj/core/internal/Doubles.java
index 12c6eef12..0931c1c65 100644
--- a/src/main/java/org/assertj/core/internal/Doubles.java
+++ b/src/main/java/org/assertj/core/internal/Doubles.java
@@ -62,7 +62,9 @@ public class Doubles extends RealNumbers<Double> {
 
   @Override
   protected Double absDiff(Double actual, Double other) {
-    return abs(other - actual);
+    return isNanOrInfinite(actual) || isNanOrInfinite(other)
+        ? abs(actual - other)
+        : abs(absBigDecimalDiff(actual, other).doubleValue());
   }
 
   @Override
@@ -84,4 +86,9 @@ public class Doubles extends RealNumbers<Double> {
   protected boolean isNotInfinite(Double value) {
     return !Double.isInfinite(value);
   }
+
+  @Override
+  protected boolean isNaN(Double value) {
+    return Double.isNaN(value);
+  }
 }
diff --git a/src/main/java/org/assertj/core/internal/Floats.java b/src/main/java/org/assertj/core/internal/Floats.java
index 85d49b3a9..ff55a8f29 100644
--- a/src/main/java/org/assertj/core/internal/Floats.java
+++ b/src/main/java/org/assertj/core/internal/Floats.java
@@ -63,7 +63,9 @@ public class Floats extends RealNumbers<Float> {
 
   @Override
   protected Float absDiff(Float actual, Float other) {
-    return abs(other - actual);
+    return isNanOrInfinite(actual) || isNanOrInfinite(other)
+        ? abs(actual - other)
+        : abs(absBigDecimalDiff(actual, other).floatValue());
   }
 
   @Override
@@ -85,4 +87,9 @@ public class Floats extends RealNumbers<Float> {
   protected boolean isNotInfinite(Float value) {
     return !Float.isInfinite(value);
   }
+
+  @Override
+  protected boolean isNaN(Float value) {
+    return Float.isNaN(value);
+  }
 }
diff --git a/src/main/java/org/assertj/core/internal/RealNumbers.java b/src/main/java/org/assertj/core/internal/RealNumbers.java
index d1a1acd2e..2432cd990 100644
--- a/src/main/java/org/assertj/core/internal/RealNumbers.java
+++ b/src/main/java/org/assertj/core/internal/RealNumbers.java
@@ -17,6 +17,8 @@ import static org.assertj.core.error.ShouldBeInfinite.shouldBeInfinite;
 import static org.assertj.core.error.ShouldNotBeFinite.shouldNotBeFinite;
 import static org.assertj.core.error.ShouldNotBeInfinite.shouldNotBeInfinite;
 
+import java.math.BigDecimal;
+
 import org.assertj.core.api.AssertionInfo;
 
 /**
@@ -46,6 +48,12 @@ public abstract class RealNumbers<NUMBER extends Number & Comparable<NUMBER>> ex
     assertEqualByComparison(info, actual, NaN());
   }
 
+  protected BigDecimal absBigDecimalDiff(NUMBER number1, NUMBER number2) {
+    BigDecimal number1AsbigDecimal = new BigDecimal(String.valueOf(number1));
+    BigDecimal number2AsbigDecimal = new BigDecimal(String.valueOf(number2));
+    return number1AsbigDecimal.subtract(number2AsbigDecimal).abs();
+  }
+
   protected abstract NUMBER NaN();
 
   /**
@@ -93,5 +101,17 @@ public abstract class RealNumbers<NUMBER extends Number & Comparable<NUMBER>> ex
     throw failures.failure(info, shouldNotBeInfinite(actual));
   }
 
+  /**
+   * Returns true is if the given value is Nan or Infinite, false otherwise.
+   * 
+   * @param value the value to check
+   * @return true is if the given value is Nan or Infinite, false otherwise.
+   */
+  public boolean isNanOrInfinite(NUMBER value) {
+    return isNaN(value) || isInfinite(value);
+  }
+
+  protected abstract boolean isNaN(NUMBER value);
+
   protected abstract boolean isNotInfinite(NUMBER value);
 }
diff --git a/src/test/java/org/assertj/core/api/ComparatorFactory_doubleComparatorWithPrecision_Test.java b/src/test/java/org/assertj/core/api/ComparatorFactory_doubleComparatorWithPrecision_Test.java
new file mode 100644
index 000000000..0e692cb1a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/ComparatorFactory_doubleComparatorWithPrecision_Test.java
@@ -0,0 +1,106 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.lang.Double.NEGATIVE_INFINITY;
+import static java.lang.Double.NaN;
+import static java.lang.Double.POSITIVE_INFINITY;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.Comparator;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.CsvSource;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class ComparatorFactory_doubleComparatorWithPrecision_Test {
+
+  private final ComparatorFactory INSTANCE = ComparatorFactory.INSTANCE;
+
+  @ParameterizedTest
+  @CsvSource({
+      "1.0, 1.1, 0.1",
+      "0.111, 0.110, 0.001",
+      "0.12345, 0.12346, 0.00001",
+      "0.7654321, 0.7654320, 0.0000001",
+      "1.2464, 1.2463, 0.0001" })
+  void should_evaluate_to_be_equal(Double double1, Double double2, Double precision) {
+    // GIVEN
+    Comparator<Double> comparator = INSTANCE.doubleComparatorWithPrecision(precision);
+    // WHEN
+    int comparisonValue = comparator.compare(double1, double2);
+    int inverseComparisonValue = comparator.compare(double2, double1);
+    // THEN
+    then(comparisonValue).isZero();
+    then(inverseComparisonValue).isZero();
+  }
+
+  @ParameterizedTest
+  @CsvSource({
+      "1.1, 1.0, 0.05",
+      "0.111, 0.110, 0.00099",
+      "0.12346, 0.12345, 0.0000099",
+      "0.7654321, 0.7654320, 0.000000099",
+      "0.7654321, 0.7654320, 9e-8",
+      "1.2464, 1.2463, 0.000099" })
+  void should_evaluate_given_value_to_different(Double value, Double other, Double precision) {
+    // GIVEN
+    Comparator<Double> comparator = INSTANCE.doubleComparatorWithPrecision(precision);
+    // WHEN
+    int comparisonValue = comparator.compare(value, other);
+    int inverseComparisonValue = comparator.compare(other, value);
+    // THEN
+    then(comparisonValue).isOne();
+    then(inverseComparisonValue).isEqualTo(-1);
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_follow_java_behavior_when_dealing_with_infinity_and_NaN(Double value1, Double value2) {
+    // GIVEN
+    Comparator<Double> comparator = INSTANCE.doubleComparatorWithPrecision(1d);
+    // WHEN
+    int comparisonValue = comparator.compare(value1, value2);
+    int javaComparisonValue = value1.compareTo(value2);
+    // THEN
+    then(comparisonValue).isEqualTo(javaComparisonValue);
+  }
+
+  static Stream<Arguments> should_follow_java_behavior_when_dealing_with_infinity_and_NaN() {
+    return Stream.of(arguments(POSITIVE_INFINITY, NEGATIVE_INFINITY),
+                     arguments(NEGATIVE_INFINITY, POSITIVE_INFINITY),
+                     arguments(POSITIVE_INFINITY, POSITIVE_INFINITY),
+                     arguments(NEGATIVE_INFINITY, NEGATIVE_INFINITY),
+                     arguments(NaN, POSITIVE_INFINITY),
+                     arguments(NaN, NEGATIVE_INFINITY),
+                     arguments(NaN, NaN));
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_fail_for_invalid_precision(Double precision) {
+    // GIVEN
+    Comparator<Double> comparator = INSTANCE.doubleComparatorWithPrecision(precision);
+    // WHEN/THEN
+    assertThatIllegalArgumentException().isThrownBy(() -> comparator.compare(1d, 2d));
+  }
+
+  static Stream<Double> should_fail_for_invalid_precision() {
+    return Stream.of(NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/ComparatorFactory_floatComparatorWithPrecision_Test.java b/src/test/java/org/assertj/core/api/ComparatorFactory_floatComparatorWithPrecision_Test.java
new file mode 100644
index 000000000..74615dea2
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/ComparatorFactory_floatComparatorWithPrecision_Test.java
@@ -0,0 +1,105 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.lang.Float.NEGATIVE_INFINITY;
+import static java.lang.Float.NaN;
+import static java.lang.Float.POSITIVE_INFINITY;
+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.Comparator;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.CsvSource;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class ComparatorFactory_floatComparatorWithPrecision_Test {
+
+  private final ComparatorFactory INSTANCE = ComparatorFactory.INSTANCE;
+
+  @ParameterizedTest
+  @CsvSource({
+      "1.0, 1.1, 0.1",
+      "0.111, 0.110, 0.001",
+      "0.12345, 0.12346, 0.00001",
+      "0.7654321, 0.7654320, 0.0000001",
+      "1.2464, 1.2463, 0.0001" })
+  void should_evaluate_to_be_equal(Float float1, Float float2, Float precision) {
+    // GIVEN
+    Comparator<Float> comparator = INSTANCE.floatComparatorWithPrecision(precision);
+    // WHEN
+    int comparisonValue = comparator.compare(float1, float2);
+    int inverseComparisonValue = comparator.compare(float2, float1);
+    // THEN
+    then(comparisonValue).isZero();
+    then(inverseComparisonValue).isZero();
+  }
+
+  @ParameterizedTest
+  @CsvSource({
+      "1.1, 1.0, 0.05",
+      "0.111, 0.110, 0.00099",
+      "0.12346, 0.12345, 0.0000099",
+      "0.7654321, 0.7654320, 0.000000099",
+      "0.7654321, 0.7654320, 9e-8",
+      "1.2464, 1.2463, 0.000099" })
+  void should_evaluate_given_value_to_different(Float value, Float other, Float precision) {
+    // GIVEN
+    Comparator<Float> comparator = INSTANCE.floatComparatorWithPrecision(precision);
+    // WHEN
+    int comparisonValue = comparator.compare(value, other);
+    int inverseComparisonValue = comparator.compare(other, value);
+    // THEN
+    then(comparisonValue).isOne();
+    then(inverseComparisonValue).isEqualTo(-1);
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_follow_java_behavior_when_dealing_with_infinity_and_NaN(Float value1, Float value2) {
+    // GIVEN
+    Comparator<Float> comparator = INSTANCE.floatComparatorWithPrecision(1f);
+    // WHEN
+    int comparisonValue = comparator.compare(value1, value2);
+    int javaComparisonValue = value1.compareTo(value2);
+    // THEN
+    then(comparisonValue).isEqualTo(javaComparisonValue);
+  }
+
+  static Stream<Arguments> should_follow_java_behavior_when_dealing_with_infinity_and_NaN() {
+    return Stream.of(arguments(POSITIVE_INFINITY, NEGATIVE_INFINITY),
+                     arguments(NEGATIVE_INFINITY, POSITIVE_INFINITY),
+                     arguments(POSITIVE_INFINITY, POSITIVE_INFINITY),
+                     arguments(NEGATIVE_INFINITY, NEGATIVE_INFINITY),
+                     arguments(NaN, POSITIVE_INFINITY),
+                     arguments(NaN, NEGATIVE_INFINITY),
+                     arguments(NaN, NaN));
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_fail_for_invalid_precision(Float precision) {
+    // GIVEN
+    Comparator<Float> comparator = INSTANCE.floatComparatorWithPrecision(precision);
+    // WHEN/THEN
+    assertThatIllegalArgumentException().isThrownBy(() -> comparator.compare(1f, 2f));
+  }
+
+  static Stream<Float> should_fail_for_invalid_precision() {
+    return Stream.of(NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/DoublesBaseTest.java b/src/test/java/org/assertj/core/internal/DoublesBaseTest.java
index 9fe1e114b..82473119d 100644
--- a/src/test/java/org/assertj/core/internal/DoublesBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/DoublesBaseTest.java
@@ -12,8 +12,10 @@
  */
 package org.assertj.core.internal;
 
+import static org.assertj.core.test.TestData.someInfo;
 import static org.mockito.Mockito.spy;
 
+import org.assertj.core.api.WritableAssertionInfo;
 import org.assertj.core.util.AbsValueComparator;
 import org.junit.jupiter.api.BeforeEach;
 
@@ -26,6 +28,8 @@ import org.junit.jupiter.api.BeforeEach;
  */
 public class DoublesBaseTest {
 
+  protected static final WritableAssertionInfo INFO = someInfo();
+
   protected Failures failures;
   protected Doubles doubles;
 
@@ -46,4 +50,7 @@ public class DoublesBaseTest {
     return doubles.NaN();
   }
 
+  protected Double absDiff(Double actual, Double other) {
+    return Doubles.instance().absDiff(actual, other);
+  }
 }
diff --git a/src/test/java/org/assertj/core/internal/FloatsBaseTest.java b/src/test/java/org/assertj/core/internal/FloatsBaseTest.java
index ddd529cc7..d9994f677 100644
--- a/src/test/java/org/assertj/core/internal/FloatsBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/FloatsBaseTest.java
@@ -12,8 +12,10 @@
  */
 package org.assertj.core.internal;
 
+import static org.assertj.core.test.TestData.someInfo;
 import static org.mockito.Mockito.spy;
 
+import org.assertj.core.api.WritableAssertionInfo;
 import org.assertj.core.util.AbsValueComparator;
 import org.junit.jupiter.api.BeforeEach;
 
@@ -28,6 +30,8 @@ import org.junit.jupiter.api.BeforeEach;
  */
 public class FloatsBaseTest {
 
+  protected static final WritableAssertionInfo INFO = someInfo();
+
   protected Failures failures;
   protected Floats floats;
 
@@ -48,4 +52,7 @@ public class FloatsBaseTest {
     return floats.NaN();
   }
 
+  protected Float absDiff(Float actual, Float other) {
+    return Floats.instance().absDiff(actual, other);
+  }
 }
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsCloseTo_Test.java
index 4763d1514..6957e04b3 100644
--- a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsCloseTo_Test.java
+++ b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsCloseTo_Test.java
@@ -15,22 +15,22 @@ package org.assertj.core.internal.doubles;
 import static java.lang.Double.NEGATIVE_INFINITY;
 import static java.lang.Double.NaN;
 import static java.lang.Double.POSITIVE_INFINITY;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.Assertions.byLessThan;
-import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.Offset.offset;
 import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
 import static org.assertj.core.internal.ErrorMessages.offsetIsNull;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.mockito.Mockito.verify;
 
-import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.internal.DoublesBaseTest;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.CsvSource;
 
 class Doubles_assertIsCloseTo_Test extends DoublesBaseTest {
 
@@ -41,162 +41,202 @@ class Doubles_assertIsCloseTo_Test extends DoublesBaseTest {
 
   // success
 
-  @Test
-  void should_pass_if_difference_is_less_than_given_offset() {
-    doubles.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
-    doubles.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
-    doubles.assertIsCloseTo(someInfo(), ONE, TWO, byLessThan(TEN));
+  @ParameterizedTest
+  @CsvSource({
+      "1.0, 1.0, 0.0",
+      "1.0, 2.0, 1.0",
+      "1.0, 0.0, 1.0",
+      "1.0, 1.0, 10",
+      "0.375, 0.125, 0.25",
+      "1.0, 1.1, 0.1",
+      "NaN, NaN, 1.0" })
+  void should_pass_if_difference_is_less_than_or_equal_to_given_precision(double actual, double expected, double precision) {
+    doubles.assertIsCloseTo(INFO, actual, expected, within(precision));
+    doubles.assertIsCloseTo(INFO, expected, actual, within(precision));
   }
 
-  @Test
-  void should_pass_if_difference_is_equal_to_given_offset() {
-    doubles.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
-    doubles.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
-    doubles.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+  @ParameterizedTest
+  @CsvSource({
+      "1.0, 2.0, 10",
+      "0.375, 0.125, 0.2500001",
+      "1.1, 1.0, 0.1000001",
+      "NaN, NaN, 1.0" })
+  void should_pass_if_difference_is_less_than_given_offset(Double actual, Double expected, Double precision) {
+    doubles.assertIsCloseTo(INFO, actual, expected, byLessThan(precision));
   }
 
   @Test
   void should_pass_if_actual_and_expected_are_POSITIVE_INFINITY() {
-    doubles.assertIsCloseTo(someInfo(), POSITIVE_INFINITY, POSITIVE_INFINITY, within(ONE));
-    doubles.assertIsCloseTo(someInfo(), POSITIVE_INFINITY, POSITIVE_INFINITY, byLessThan(ONE));
+    doubles.assertIsCloseTo(INFO, POSITIVE_INFINITY, POSITIVE_INFINITY, within(ONE));
+    doubles.assertIsCloseTo(INFO, POSITIVE_INFINITY, POSITIVE_INFINITY, byLessThan(ONE));
   }
 
   @Test
   void should_pass_if_actual_and_expected_are_NEGATIVE_INFINITY() {
-    doubles.assertIsCloseTo(someInfo(), NEGATIVE_INFINITY, NEGATIVE_INFINITY, within(ONE));
-    doubles.assertIsCloseTo(someInfo(), NEGATIVE_INFINITY, NEGATIVE_INFINITY, byLessThan(ONE));
+    doubles.assertIsCloseTo(INFO, NEGATIVE_INFINITY, NEGATIVE_INFINITY, within(ONE));
+    doubles.assertIsCloseTo(INFO, NEGATIVE_INFINITY, NEGATIVE_INFINITY, byLessThan(ONE));
   }
 
-  @Test
-  void should_pass_if_actual_and_expected_are_NaN() {
-    doubles.assertIsCloseTo(someInfo(), NaN, NaN, within(ONE));
-    doubles.assertIsCloseTo(someInfo(), NaN, NaN, byLessThan(ONE));
+  // error or failure
+
+  @ParameterizedTest
+  @CsvSource({
+      "1.0, 1.1, 0.1",
+      "1.0, 2.0, 1.0",
+      "0.375, 0.125, 0.25" })
+  void should_fail_if_difference_is_greater_than_or_equal_to_given_precision(Double expected, Double actual, Double precision) {
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, actual, expected, byLessThan(precision)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(actual, expected, byLessThan(precision), absDiff(expected, actual)));
   }
 
-  // error or failure
+  @ParameterizedTest
+  @CsvSource({
+      "1.0, 1.1, 0.0999999",
+      "0.375, 0.125, 0.2499999" })
+  void should_fail_if_difference_is_greater_than_given_precision(Double expected, Double actual, Double precision) {
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, actual, expected, within(precision)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(actual, expected, within(precision), absDiff(expected, actual)));
+  }
 
   @Test
-  void should_throw_error_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsCloseTo(someInfo(), null, ONE, within(ONE)))
-                                                   .withMessage(actualIsNull());
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    Double actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> doubles.assertIsCloseTo(INFO, actual, ONE, within(ONE)));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_throw_error_if_expected_value_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> doubles.assertIsCloseTo(someInfo(), 6d, null, offset(1d)))
+    assertThatNullPointerException().isThrownBy(() -> doubles.assertIsCloseTo(INFO, 6.0, null, offset(1.0)))
                                     .withMessage("The given number should not be null");
   }
 
   @Test
   void should_throw_error_if_offset_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> doubles.assertIsCloseTo(someInfo(), ONE, ZERO, null));
+    assertThatNullPointerException().isThrownBy(() -> doubles.assertIsCloseTo(INFO, ONE, ZERO, null))
+                                    .withMessage("The given offset should not be null");
   }
 
   @Test
   void should_fail_if_actual_is_not_close_enough_to_expected_value() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> doubles.assertIsCloseTo(info, ONE, TEN, within(ONE)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(ONE, TEN, within(ONE), TEN - ONE));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, ONE, TEN, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(ONE, TEN, within(ONE), TEN - ONE));
   }
 
   @Test
   void should_fail_if_actual_is_not_close_enough_to_expected_value_with_a_strict_offset() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> doubles.assertIsCloseTo(info, ONE, TEN, byLessThan(ONE)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(ONE, TEN, byLessThan(ONE), TEN - ONE));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, ONE, TEN, byLessThan(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(ONE, TEN, byLessThan(ONE), TEN - ONE));
   }
 
   @Test
   void should_fail_if_difference_is_equal_to_the_given_strict_offset() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> doubles.assertIsCloseTo(info, TWO, ONE, byLessThan(ONE)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(TWO, ONE, byLessThan(ONE), TWO - ONE));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, TWO, ONE, byLessThan(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(TWO, ONE, byLessThan(ONE), TWO - ONE));
   }
 
   @Test
   void should_fail_if_actual_is_NaN_and_expected_is_not() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsCloseTo(someInfo(), NaN, ONE, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, NaN, ONE, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(NaN, ONE, within(ONE), absDiff(NaN, ONE)));
   }
 
   @Test
   void should_fail_if_actual_is_POSITIVE_INFINITY_and_expected_is_not() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsCloseTo(someInfo(), POSITIVE_INFINITY, ONE, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, POSITIVE_INFINITY, ONE, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(POSITIVE_INFINITY, ONE, within(ONE), absDiff(POSITIVE_INFINITY, ONE)));
   }
 
   @Test
   void should_fail_if_actual_is_NEGATIVE_INFINITY_and_expected_is_not() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsCloseTo(someInfo(), NEGATIVE_INFINITY, ONE, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, NEGATIVE_INFINITY, ONE, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(NEGATIVE_INFINITY, ONE, within(ONE), absDiff(NEGATIVE_INFINITY, ONE)));
   }
 
   @Test
   void should_fail_if_actual_is_POSITIVE_INFINITY_and_expected_is_NEGATIVE_INFINITY() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsCloseTo(someInfo(), POSITIVE_INFINITY, NEGATIVE_INFINITY, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, POSITIVE_INFINITY, NEGATIVE_INFINITY, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(POSITIVE_INFINITY, NEGATIVE_INFINITY, within(ONE),
+                                                 absDiff(POSITIVE_INFINITY, NEGATIVE_INFINITY)));
   }
 
   @Test
   void should_fail_if_actual_is_NEGATIVE_INFINITY_and_expected_is_POSITIVE_INFINITY() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsCloseTo(someInfo(), NEGATIVE_INFINITY, POSITIVE_INFINITY, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsCloseTo(INFO, NEGATIVE_INFINITY, POSITIVE_INFINITY, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(NEGATIVE_INFINITY, POSITIVE_INFINITY, within(ONE),
+                                                 absDiff(NEGATIVE_INFINITY, POSITIVE_INFINITY)));
   }
 
   // with comparison strategy
 
   @Test
   void should_pass_if_difference_is_less_than_given_offset_whatever_custom_comparison_strategy_is() {
-    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
-    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
-    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, TWO, byLessThan(TEN));
+    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, ONE, within(ONE));
+    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, TWO, within(TEN));
+    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, TWO, byLessThan(TEN));
   }
 
   @Test
   void should_pass_if_difference_is_equal_to_given_offset_whatever_custom_comparison_strategy_is() {
-    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
-    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
-    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, ONE, within(ZERO));
+    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, ZERO, within(ONE));
+    doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, TWO, within(ONE));
   }
 
   @Test
   void should_throw_error_if_offset_is_null_whatever_custom_comparison_strategy_is() {
-    assertThatNullPointerException().isThrownBy(() -> doublesWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(),
-                                                                                                            new Double(8d),
-                                                                                                            new Double(8d),
-                                                                                                            null))
+    // GIVEN
+    ThrowingCallable code = () -> doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, 8d, 8d, null);
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(code)
                                     .withMessage(offsetIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_close_enough_to_expected_value_whatever_custom_comparison_strategy_is() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> doublesWithAbsValueComparisonStrategy.assertIsCloseTo(info, new Double(6d), new Double(8d), offset(1d)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(6d, 8d, offset(1d), 2d));
+    // WHEN
+    expectAssertionError(() -> doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, 6d, 8d, offset(1d)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(6d, 8d, offset(1d), 2d));
   }
 
   @Test
   void should_fail_if_actual_is_not_strictly_close_enough_to_expected_value_whatever_custom_comparison_strategy_is() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> doublesWithAbsValueComparisonStrategy.assertIsCloseTo(info, new Double(6d), new Double(8d), byLessThan(1d)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(6d, 8d, byLessThan(1d), 2d));
+    // WHEN
+    expectAssertionError(() -> doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, 6d, 8d, byLessThan(1d)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(6d, 8d, byLessThan(1d), 2d));
   }
 
   @Test
   void should_throw_error_if_expected_value_is_null_whatever_custom_comparison_strategy_is() {
-    assertThatNullPointerException().isThrownBy(() -> doublesWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(),
-                                                                                                            6d, null,
-                                                                                                            offset(1d)))
+    // GIVEN
+    ThrowingCallable code = () -> doublesWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, 6d, null, offset(1d));
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(code)
                                     .withMessage("The given number should not be null");
   }
 
diff --git a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNotCloseTo_Test.java b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNotCloseTo_Test.java
index 5d7016375..1cbc2eaf9 100644
--- a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNotCloseTo_Test.java
+++ b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNotCloseTo_Test.java
@@ -15,19 +15,16 @@ package org.assertj.core.internal.doubles;
 import static java.lang.Double.NEGATIVE_INFINITY;
 import static java.lang.Double.NaN;
 import static java.lang.Double.POSITIVE_INFINITY;
-import static java.lang.Math.abs;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.Assertions.byLessThan;
-import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.Offset.offset;
 import static org.assertj.core.error.ShouldNotBeEqualWithinOffset.shouldNotBeEqual;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.mockito.Mockito.verify;
 
-import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.DoublesBaseTest;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
@@ -35,114 +32,121 @@ import org.junit.jupiter.params.provider.CsvSource;
 
 class Doubles_assertIsNotCloseTo_Test extends DoublesBaseTest {
 
-  private static final Double ZERO = 0d;
-  private static final Double ONE = 1d;
-  private static final Double TWO = 2d;
-  private static final Double THREE = 3d;
-  private static final Double TEN = 10d;
+  private static final Double ZERO = 0.0;
+  private static final Double ONE = 1.0;
+  private static final Double TWO = 2.0;
+  private static final Double TEN = 10.0;
 
-  @Test
-  void should_pass_if_difference_is_more_than_given_offset() {
-    doubles.assertIsNotCloseTo(someInfo(), ONE, THREE, byLessThan(ONE));
-    doubles.assertIsNotCloseTo(someInfo(), ONE, THREE, within(ONE));
-    doubles.assertIsNotCloseTo(someInfo(), ONE, TEN, byLessThan(TWO));
-    doubles.assertIsNotCloseTo(someInfo(), ONE, TEN, within(TWO));
+  @ParameterizedTest
+  @CsvSource({
+      "1.0, 3.0, 1.0",
+      "1.0, 10.0, 2.0",
+      "1.0, 1.1, 0.0999999999" })
+  void should_pass_if_difference_is_more_than_given_offset(double actual, double expected, double precision) {
+    doubles.assertIsNotCloseTo(INFO, actual, expected, within(precision));
+    doubles.assertIsNotCloseTo(INFO, expected, actual, within(precision));
+    doubles.assertIsNotCloseTo(INFO, actual, expected, byLessThan(precision));
+    doubles.assertIsNotCloseTo(INFO, expected, actual, byLessThan(precision));
   }
 
-  @Test
-  void should_pass_if_difference_is_equal_to_the_given_strict_offset() {
-    doubles.assertIsNotCloseTo(someInfo(), ONE, TWO, byLessThan(ONE));
-    doubles.assertIsNotCloseTo(someInfo(), TWO, ONE, byLessThan(ONE));
+  @ParameterizedTest
+  @CsvSource({
+      "1.0, 2.0, 1.0",
+      "1.0, 1.1, 0.1" })
+  void should_pass_if_difference_is_equal_to_the_given_strict_offset(double actual, double expected, double precision) {
+    doubles.assertIsNotCloseTo(INFO, actual, expected, byLessThan(precision));
+    doubles.assertIsNotCloseTo(INFO, expected, actual, byLessThan(precision));
   }
 
   @Test
   void should_pass_if_actual_is_POSITIVE_INFINITY_and_expected_is_not() {
-    doubles.assertIsNotCloseTo(someInfo(), POSITIVE_INFINITY, ONE, byLessThan(ONE));
-    doubles.assertIsNotCloseTo(someInfo(), POSITIVE_INFINITY, ONE, within(ONE));
+    doubles.assertIsNotCloseTo(INFO, POSITIVE_INFINITY, ONE, byLessThan(ONE));
+    doubles.assertIsNotCloseTo(INFO, POSITIVE_INFINITY, ONE, within(ONE));
   }
 
   @Test
   void should_pass_if_actual_is_POSITIVE_INFINITY_and_expected_is_NEGATIVE_INFINITY() {
-    doubles.assertIsNotCloseTo(someInfo(), POSITIVE_INFINITY, NEGATIVE_INFINITY, byLessThan(ONE));
-    doubles.assertIsNotCloseTo(someInfo(), POSITIVE_INFINITY, NEGATIVE_INFINITY, within(ONE));
+    doubles.assertIsNotCloseTo(INFO, POSITIVE_INFINITY, NEGATIVE_INFINITY, byLessThan(ONE));
+    doubles.assertIsNotCloseTo(INFO, POSITIVE_INFINITY, NEGATIVE_INFINITY, within(ONE));
   }
 
   @Test
   void should_pass_if_actual_is_NEGATIVE_INFINITY_and_expected_is_not() {
-    doubles.assertIsNotCloseTo(someInfo(), NEGATIVE_INFINITY, ONE, byLessThan(ONE));
-    doubles.assertIsNotCloseTo(someInfo(), NEGATIVE_INFINITY, ONE, within(ONE));
+    doubles.assertIsNotCloseTo(INFO, NEGATIVE_INFINITY, ONE, byLessThan(ONE));
+    doubles.assertIsNotCloseTo(INFO, NEGATIVE_INFINITY, ONE, within(ONE));
   }
 
   @Test
   void should_pass_if_actual_is_NEGATIVE_INFINITY_and_expected_is_POSITIVE_INFINITY() {
-    doubles.assertIsNotCloseTo(someInfo(), NEGATIVE_INFINITY, POSITIVE_INFINITY, byLessThan(ONE));
-    doubles.assertIsNotCloseTo(someInfo(), NEGATIVE_INFINITY, POSITIVE_INFINITY, within(ONE));
+    doubles.assertIsNotCloseTo(INFO, NEGATIVE_INFINITY, POSITIVE_INFINITY, byLessThan(ONE));
+    doubles.assertIsNotCloseTo(INFO, NEGATIVE_INFINITY, POSITIVE_INFINITY, within(ONE));
   }
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsNotCloseTo(someInfo(), null, ONE, byLessThan(ONE)))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    Double actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> doubles.assertIsNotCloseTo(INFO, actual, ONE, within(ONE)));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_expected_value_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> doubles.assertIsNotCloseTo(someInfo(), ONE, null, byLessThan(ONE)));
+    assertThatNullPointerException().isThrownBy(() -> doubles.assertIsNotCloseTo(INFO, ONE, null, offset(ONE)))
+                                    .withMessage("The given number should not be null");
   }
 
   @Test
   void should_fail_if_offset_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> doubles.assertIsNotCloseTo(someInfo(), ONE, ZERO, null));
+    assertThatNullPointerException().isThrownBy(() -> doubles.assertIsNotCloseTo(INFO, ONE, ZERO, null))
+                                    .withMessage("The given offset should not be null");
   }
 
   @ParameterizedTest
   @CsvSource({
       "1.0, 1.0, 0.0",
       "1.0, 0.0, 1.0",
-      "1.0, 2.0, 1.0"
+      "1.0, 2.0, 1.0",
+      "1.0, 1.1, 0.1"
   })
   void should_fail_if_difference_is_equal_to_given_offset(Double actual, Double other, Double offset) {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> doubles.assertIsNotCloseTo(someInfo(), actual, other, within(offset)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldNotBeEqual(actual, other, within(offset), abs(actual - other)));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsNotCloseTo(INFO, actual, other, within(offset)));
+    // THEN
+    verify(failures).failure(INFO, shouldNotBeEqual(actual, other, within(offset), absDiff(actual, other)));
   }
   
   @Test
   void should_fail_if_actual_is_too_close_to_expected_value() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> doubles.assertIsNotCloseTo(info, ONE, TWO, within(TEN)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldNotBeEqual(ONE, TWO, within(TEN), TWO - ONE));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsNotCloseTo(INFO, ONE, TWO, within(TEN)));
+    // THEN
+    verify(failures).failure(INFO, shouldNotBeEqual(ONE, TWO, within(TEN), ONE));
   }
 
   @Test
   void should_fail_if_actual_is_too_close_to_expected_value_with_strict_offset() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> doubles.assertIsNotCloseTo(info, ONE, TWO, byLessThan(TEN)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldNotBeEqual(ONE, TWO, byLessThan(TEN), TWO - ONE));
+    // WHEN
+    expectAssertionError(() -> doubles.assertIsNotCloseTo(INFO, ONE, TWO, byLessThan(TEN)));
+    // THEN
+    verify(failures).failure(INFO, shouldNotBeEqual(ONE, TWO, byLessThan(TEN), ONE));
   }
 
   @Test
   void should_fail_if_actual_and_expected_are_NaN() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsNotCloseTo(someInfo(), NaN, NaN, within(ONE)));
+    expectAssertionError(() -> doubles.assertIsNotCloseTo(INFO, NaN, NaN, within(ONE)));
   }
 
   @Test
   void should_fail_if_actual_and_expected_are_POSITIVE_INFINITY() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsNotCloseTo(someInfo(), POSITIVE_INFINITY, POSITIVE_INFINITY, within(ONE)));
+    expectAssertionError(() -> doubles.assertIsNotCloseTo(INFO, POSITIVE_INFINITY, POSITIVE_INFINITY, within(ONE)));
   }
 
   @Test
   void should_fail_if_actual_and_expected_are_NEGATIVE_INFINITY() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> doubles.assertIsNotCloseTo(someInfo(), NEGATIVE_INFINITY, NEGATIVE_INFINITY, within(ONE)));
+    expectAssertionError(() -> doubles.assertIsNotCloseTo(INFO, NEGATIVE_INFINITY, NEGATIVE_INFINITY, within(ONE)));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/doubles/Doubles_isNanOrInfinite_Test.java b/src/test/java/org/assertj/core/internal/doubles/Doubles_isNanOrInfinite_Test.java
new file mode 100644
index 000000000..7ad9987e8
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/doubles/Doubles_isNanOrInfinite_Test.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+
+package org.assertj.core.internal.doubles;
+
+import static java.lang.Double.NEGATIVE_INFINITY;
+import static java.lang.Double.NaN;
+import static java.lang.Double.POSITIVE_INFINITY;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.stream.Stream;
+
+import org.assertj.core.internal.DoublesBaseTest;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.CsvSource;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class Doubles_isNanOrInfinite_Test extends DoublesBaseTest {
+
+  @ParameterizedTest
+  @MethodSource
+  void should_evaluate_as_NaN_or_infinity(double value)
+  {
+    // WHEN
+    boolean isNanOrInfinite = doubles.isNanOrInfinite(value);
+    // THEN
+    then(isNanOrInfinite).isTrue();
+  }
+
+  @ParameterizedTest
+  @CsvSource({ "-1.0", "0.0", "1.0" })
+  void should_not_evaluate_as_NaN_or_infinity(double actual) {
+    // THEN
+    boolean isNanOrInfinite = doubles.isNanOrInfinite(actual);
+    // THEN
+    then(isNanOrInfinite).isFalse();
+  }
+
+  static Stream<Double> should_evaluate_as_NaN_or_infinity() {
+    return Stream.of(NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/floats/Floats_assertIsCloseTo_Test.java b/src/test/java/org/assertj/core/internal/floats/Floats_assertIsCloseTo_Test.java
index 3b54153b7..d6d801d78 100644
--- a/src/test/java/org/assertj/core/internal/floats/Floats_assertIsCloseTo_Test.java
+++ b/src/test/java/org/assertj/core/internal/floats/Floats_assertIsCloseTo_Test.java
@@ -15,22 +15,22 @@ package org.assertj.core.internal.floats;
 import static java.lang.Float.NEGATIVE_INFINITY;
 import static java.lang.Float.NaN;
 import static java.lang.Float.POSITIVE_INFINITY;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.Assertions.byLessThan;
-import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.Offset.offset;
 import static org.assertj.core.error.ShouldBeEqualWithinOffset.shouldBeEqual;
 import static org.assertj.core.internal.ErrorMessages.offsetIsNull;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.mockito.Mockito.verify;
 
-import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.internal.FloatsBaseTest;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.CsvSource;
 
 class Floats_assertIsCloseTo_Test extends FloatsBaseTest {
 
@@ -41,163 +41,204 @@ class Floats_assertIsCloseTo_Test extends FloatsBaseTest {
 
   // success
 
-  @Test
-  void should_pass_if_difference_is_less_than_given_offset() {
-    floats.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
-    floats.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
-    floats.assertIsCloseTo(someInfo(), ONE, TWO, byLessThan(TEN));
+  @ParameterizedTest
+  @CsvSource({
+      "1.0f, 1.0f, 0.0f",
+      "1.0f, 2.0f, 1.0f",
+      "1.0f, 0.0f, 1.0f",
+      "1.0f, 1.0f, 10",
+      "0.375f, 0.125f, 0.25f",
+      "1.0f, 1.1, 0.1",
+      "NaN, NaN, 1.0f" })
+  void should_pass_if_difference_is_less_than_or_equal_to_given_precision(float actual, float expected, float precision) {
+    floats.assertIsCloseTo(INFO, actual, expected, within(precision));
+    floats.assertIsCloseTo(INFO, expected, actual, within(precision));
   }
 
-  @Test
-  void should_pass_if_difference_is_equal_to_given_offset() {
-    floats.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
-    floats.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
-    floats.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+  @ParameterizedTest
+  @CsvSource({
+      "1.0f, 2.0f, 10",
+      "0.375, 0.125, 0.2500001",
+      "1.1, 1.0f, 0.1000001",
+      "NaN, NaN, 1.0f" })
+  void should_pass_if_difference_is_less_than_given_offset(float actual, float expected, float precision) {
+    floats.assertIsCloseTo(INFO, actual, expected, byLessThan(precision));
   }
 
   @Test
   void should_pass_if_actual_and_expected_are_POSITIVE_INFINITY() {
-    floats.assertIsCloseTo(someInfo(), POSITIVE_INFINITY, POSITIVE_INFINITY, within(ONE));
-    floats.assertIsCloseTo(someInfo(), POSITIVE_INFINITY, POSITIVE_INFINITY, byLessThan(ONE));
+    floats.assertIsCloseTo(INFO, POSITIVE_INFINITY, POSITIVE_INFINITY, within(ONE));
+    floats.assertIsCloseTo(INFO, POSITIVE_INFINITY, POSITIVE_INFINITY, byLessThan(ONE));
   }
 
   @Test
   void should_pass_if_actual_and_expected_are_NEGATIVE_INFINITY() {
-    floats.assertIsCloseTo(someInfo(), NEGATIVE_INFINITY, NEGATIVE_INFINITY, within(ONE));
-    floats.assertIsCloseTo(someInfo(), NEGATIVE_INFINITY, NEGATIVE_INFINITY, byLessThan(ONE));
+    floats.assertIsCloseTo(INFO, NEGATIVE_INFINITY, NEGATIVE_INFINITY, within(ONE));
+    floats.assertIsCloseTo(INFO, NEGATIVE_INFINITY, NEGATIVE_INFINITY, byLessThan(ONE));
   }
 
-  @Test
-  void should_pass_if_actual_and_expected_are_NaN() {
-    floats.assertIsCloseTo(someInfo(), NaN, NaN, within(ONE));
-    floats.assertIsCloseTo(someInfo(), NaN, NaN, byLessThan(ONE));
+  // error or failure
+
+  @ParameterizedTest
+  @CsvSource({
+      "1.0f, 1.1f, 0.1f",
+      "1.0f, 2.0f, 1.0f",
+      "0.375f, 0.125f, 0.25f" })
+  void should_fail_if_difference_is_greater_than_or_equal_to_given_precision(float expected, float actual, float precision) {
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, actual, expected, byLessThan(precision)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(actual, expected, byLessThan(precision), absDiff(expected, actual)));
   }
 
-  // error or failure
+  @ParameterizedTest
+  @CsvSource({
+      "1.0f, 1.1f, 0.0999999f",
+      "0.375f, 0.125f, 0.2499999f" })
+  void should_fail_if_difference_is_greater_than_given_precision(float expected, float actual, float precision) {
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, actual, expected, within(precision)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(actual, expected, within(precision), absDiff(expected, actual)));
+  }
 
   @Test
-  void should_throw_error_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> floats.assertIsCloseTo(someInfo(), null, ONE, within(ONE)))
-                                                   .withMessage(actualIsNull());
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    Float actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> floats.assertIsCloseTo(INFO, actual, ONE, within(ONE)));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_throw_error_if_expected_value_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> floats.assertIsCloseTo(someInfo(), 6f, null, offset(1f)))
+    assertThatNullPointerException().isThrownBy(() -> floats.assertIsCloseTo(INFO, 6.0f, null, offset(1.0f)))
                                     .withMessage("The given number should not be null");
   }
 
   @Test
   void should_throw_error_if_offset_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> floats.assertIsCloseTo(someInfo(), ONE, ZERO, null));
+    assertThatNullPointerException().isThrownBy(() -> floats.assertIsCloseTo(INFO, ONE, ZERO, null))
+                                    .withMessage("The given offset should not be null");
   }
 
   @Test
   void should_fail_if_actual_is_not_close_enough_to_expected_value() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> floats.assertIsCloseTo(info, ONE, TEN, within(ONE)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(ONE, TEN, within(ONE), TEN - ONE));
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, ONE, TEN, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(ONE, TEN, within(ONE), TEN - ONE));
   }
 
   @Test
   void should_fail_if_actual_is_not_close_enough_to_expected_value_with_a_strict_offset() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> floats.assertIsCloseTo(info, ONE, TEN, byLessThan(ONE)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(ONE, TEN, byLessThan(ONE), TEN - ONE));
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, ONE, TEN, byLessThan(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(ONE, TEN, byLessThan(ONE), TEN - ONE));
   }
 
   @Test
   void should_fail_if_difference_is_equal_to_the_given_strict_offset() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> floats.assertIsCloseTo(info, TWO, ONE, byLessThan(ONE)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(TWO, ONE, byLessThan(ONE), TWO - ONE));
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, TWO, ONE, byLessThan(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(TWO, ONE, byLessThan(ONE), TWO - ONE));
   }
 
   @Test
   void should_fail_if_actual_is_NaN_and_expected_is_not() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> floats.assertIsCloseTo(someInfo(), NaN, ONE, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, NaN, ONE, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(NaN, ONE, within(ONE), absDiff(NaN, ONE)));
   }
 
   @Test
   void should_fail_if_actual_is_POSITIVE_INFINITY_and_expected_is_not() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> floats.assertIsCloseTo(someInfo(), POSITIVE_INFINITY, ONE, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, POSITIVE_INFINITY, ONE, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(POSITIVE_INFINITY, ONE, within(ONE), absDiff(POSITIVE_INFINITY, ONE)));
   }
 
   @Test
   void should_fail_if_actual_is_NEGATIVE_INFINITY_and_expected_is_not() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> floats.assertIsCloseTo(someInfo(), NEGATIVE_INFINITY, ONE, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, NEGATIVE_INFINITY, ONE, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(NEGATIVE_INFINITY, ONE, within(ONE), absDiff(NEGATIVE_INFINITY, ONE)));
   }
 
   @Test
   void should_fail_if_actual_is_POSITIVE_INFINITY_and_expected_is_NEGATIVE_INFINITY() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> floats.assertIsCloseTo(someInfo(), POSITIVE_INFINITY, NEGATIVE_INFINITY, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, POSITIVE_INFINITY, NEGATIVE_INFINITY, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(POSITIVE_INFINITY, NEGATIVE_INFINITY, within(ONE),
+                                                 absDiff(POSITIVE_INFINITY, NEGATIVE_INFINITY)));
   }
 
   @Test
   void should_fail_if_actual_is_NEGATIVE_INFINITY_and_expected_is_POSITIVE_INFINITY() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> floats.assertIsCloseTo(someInfo(), NEGATIVE_INFINITY, POSITIVE_INFINITY, within(ONE)));
+    // WHEN
+    expectAssertionError(() -> floats.assertIsCloseTo(INFO, NEGATIVE_INFINITY, POSITIVE_INFINITY, within(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(NEGATIVE_INFINITY, POSITIVE_INFINITY, within(ONE),
+                                                 absDiff(NEGATIVE_INFINITY, POSITIVE_INFINITY)));
   }
 
   // with comparison strategy
 
   @Test
   void should_pass_if_difference_is_less_than_given_offset_whatever_custom_comparison_strategy_is() {
-    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, ONE, within(ONE));
-    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, TWO, within(TEN));
-    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, TWO, byLessThan(TEN));
+    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, ONE, within(ONE));
+    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, TWO, within(TEN));
+    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, TWO, byLessThan(TEN));
   }
 
   @Test
   void should_pass_if_difference_is_equal_to_given_offset_whatever_custom_comparison_strategy_is() {
-    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, ONE, within(ZERO));
-    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, ZERO, within(ONE));
-    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(), ONE, TWO, within(ONE));
+    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, ONE, within(ZERO));
+    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, ZERO, within(ONE));
+    floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, ONE, TWO, within(ONE));
   }
 
   @Test
   void should_throw_error_if_offset_is_null_whatever_custom_comparison_strategy_is() {
-    assertThatNullPointerException().isThrownBy(() -> floatsWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(),
-                                                                                                           new Float(8f),
-                                                                                                           new Float(8f),
-                                                                                                           null))
+    // GIVEN
+    ThrowingCallable code = () -> floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, 8f, 8f, null);
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(code)
                                     .withMessage(offsetIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_close_enough_to_expected_value_whatever_custom_comparison_strategy_is() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> floatsWithAbsValueComparisonStrategy.assertIsCloseTo(info, new Float(6f), new Float(8f), offset(1f)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(6f, 8f, offset(1f), 2f));
+    // WHEN
+    expectAssertionError(() -> floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, 6f, 8f, offset(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(6f, 8f, offset(ONE), TWO));
   }
 
   @Test
   void should_fail_if_actual_is_not_strictly_close_enough_to_expected_value_whatever_custom_comparison_strategy_is() {
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> floatsWithAbsValueComparisonStrategy.assertIsCloseTo(info, new Float(6f), new Float(8f), byLessThan(1f)));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeEqual(6f, 8f, byLessThan(1f), 2f));
+    // WHEN
+    expectAssertionError(() -> floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, 6f, 8f, byLessThan(ONE)));
+    // THEN
+    verify(failures).failure(INFO, shouldBeEqual(6f, 8f, byLessThan(ONE), TWO));
   }
 
   @Test
   void should_throw_error_if_expected_value_is_null_whatever_custom_comparison_strategy_is() {
-    assertThatNullPointerException().isThrownBy(() -> floatsWithAbsValueComparisonStrategy.assertIsCloseTo(someInfo(),
-                                                                                                           6f, null,
-                                                                                                           offset(1f)))
+    // GIVEN
+    ThrowingCallable code = () -> floatsWithAbsValueComparisonStrategy.assertIsCloseTo(INFO, 6f, null, offset(ONE));
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(code)
                                     .withMessage("The given number should not be null");
   }
 
+
 }
diff --git a/src/test/java/org/assertj/core/internal/floats/Floats_isNanOrInfinite_Test.java b/src/test/java/org/assertj/core/internal/floats/Floats_isNanOrInfinite_Test.java
new file mode 100644
index 000000000..e10950177
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/floats/Floats_isNanOrInfinite_Test.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+
+package org.assertj.core.internal.floats;
+
+import static java.lang.Float.NEGATIVE_INFINITY;
+import static java.lang.Float.NaN;
+import static java.lang.Float.POSITIVE_INFINITY;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.stream.Stream;
+
+import org.assertj.core.internal.FloatsBaseTest;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.CsvSource;
+import org.junit.jupiter.params.provider.MethodSource;
+
+public class Floats_isNanOrInfinite_Test extends FloatsBaseTest {
+
+  @ParameterizedTest
+  @MethodSource
+  void should_evaluate_as_NaN_or_infinity(float value) {
+    // WHEN
+    boolean isNanOrInfinite = floats.isNanOrInfinite(value);
+    // THEN
+    then(isNanOrInfinite).isTrue();
+  }
+
+  @ParameterizedTest
+  @CsvSource({ "-1.0f", "0.0f", "1.0f" })
+  void should_not_evaluate_as_NaN_or_infinity(float actual) {
+    // THEN
+    boolean isNanOrInfinite = floats.isNanOrInfinite(actual);
+    // THEN
+    then(isNanOrInfinite).isFalse();
+  }
+
+  static Stream<Float> should_evaluate_as_NaN_or_infinity() {
+    return Stream.of(NaN, POSITIVE_INFINITY, NEGATIVE_INFINITY);
+  }
+}
