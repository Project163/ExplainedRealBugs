diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
index 80b83cea2..ef3da7ae7 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
@@ -108,6 +108,12 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     return decomposedPath.get(decomposedPath.size() - 1);
   }
 
+  public boolean isRoot() {
+    // root is the top level object compared or in case of the top level is a iterable/array the elements are considered as roots.
+    // we don't do it for optional it has a 'value' field so for the moment
+    return pathToUseInRules.isEmpty();
+  }
+
   public static FieldLocation rootFieldLocation() {
     return new FieldLocation(emptyList());
   }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 890724b71..c2c2f6bbb 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -227,7 +227,6 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     Stream.of(fieldNamesToCompare).map(FieldLocation::new).forEach(comparedFields::add);
   }
 
-
   /**
    * Adds the given fields of types and their subfields to the set of fields from the object under test to compare (fields of other types will not be compared).
    * <p>
@@ -647,7 +646,9 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   }
 
   boolean shouldIgnore(DualValue dualValue) {
-    return !shouldBeCompared(dualValue) || shouldIgnoreFieldBasedOnFieldLocation(dualValue.fieldLocation) || shouldIgnoreFieldBasedOnFieldValue(dualValue);
+    return !shouldBeCompared(dualValue)
+           || shouldIgnoreFieldBasedOnFieldLocation(dualValue.fieldLocation)
+           || shouldIgnoreFieldBasedOnFieldValue(dualValue);
   }
 
   private boolean shouldBeCompared(DualValue dualValue) {
@@ -664,7 +665,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     // a field f must be compared if any compared fields is f itself (obviously), a parent of f or a child of f.
     // - "name.first" must be compared if "name" is a compared field so will other "name" subfields like "name.last"
     // - "name" must be compared if "name.first" is a compared field otherwise "name" is ignored and "name.first" too
-    return comparedField -> field.matches(comparedField) // exact match
+    return comparedField -> field.isRoot() // always compare root!
+                            || field.matches(comparedField) // exact match
                             || field.hasParent(comparedField) // ex: field "name.first" and "name" compared field
                             || field.hasChild(comparedField); // ex: field "name" and "name.first" compared field
   }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_field_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_field_Test.java
index 3cfe2b3ad..79a026aad 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_field_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_field_Test.java
@@ -12,7 +12,7 @@
  */
 package org.assertj.core.api.recursive;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
 
 import org.assertj.core.api.recursive.comparison.FieldLocation;
@@ -27,9 +27,9 @@ class FieldLocation_field_Test {
     // WHEN
     FieldLocation childFieldLocation = parentFieldLocation.field("bar");
     // THEN
-    assertThat(childFieldLocation.getDecomposedPath()).isEqualTo(list("foo", "bar"));
-    assertThat(childFieldLocation.getPathToUseInRules()).isEqualTo("foo.bar");
-    assertThat(childFieldLocation.getFieldName()).isEqualTo("bar");
+    then(childFieldLocation.getDecomposedPath()).isEqualTo(list("foo", "bar"));
+    then(childFieldLocation.getPathToUseInRules()).isEqualTo("foo.bar");
+    then(childFieldLocation.getFieldName()).isEqualTo("bar");
   }
 
   @Test
@@ -39,8 +39,8 @@ class FieldLocation_field_Test {
     // WHEN
     FieldLocation childFieldLocation = parentFieldLocation.field("name");
     // THEN
-    assertThat(childFieldLocation.getDecomposedPath()).isEqualTo(list("person", "[0]", "children", "[2]", "name"));
-    assertThat(childFieldLocation.getPathToUseInRules()).isEqualTo("person.children.name");
-    assertThat(childFieldLocation.getFieldName()).isEqualTo("name");
+    then(childFieldLocation.getDecomposedPath()).isEqualTo(list("person", "[0]", "children", "[2]", "name"));
+    then(childFieldLocation.getPathToUseInRules()).isEqualTo("person.children.name");
+    then(childFieldLocation.getFieldName()).isEqualTo("name");
   }
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isRoot_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isRoot_Test.java
new file mode 100644
index 000000000..2d9f3dd77
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isRoot_Test.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.FieldLocation;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class FieldLocation_isRoot_Test {
+
+  @ParameterizedTest(name = "{0}")
+  @MethodSource
+  void should_evaluate_object_as_root(FieldLocation fieldLocation) {
+    // GIVEN
+    FieldLocation rootFieldLocation = rootFieldLocation();
+    // WHEN/THEN
+    then(rootFieldLocation.isRoot()).isTrue();
+  }
+
+  private static Stream<FieldLocation> should_evaluate_object_as_root() {
+    return Stream.of(rootFieldLocation(),
+                     new FieldLocation(list("[0]")),
+                     new FieldLocation(list("[1]")));
+
+  }
+
+  @ParameterizedTest(name = "{0}")
+  @MethodSource
+  void should_not_evaluate_object_as_root(FieldLocation fieldLocation) {
+    // GIVEN
+    FieldLocation rootFieldLocation = rootFieldLocation();
+    // WHEN/THEN
+    then(rootFieldLocation.isRoot()).isTrue();
+  }
+
+  private static Stream<FieldLocation> should_not_evaluate_object_as_root() {
+    return Stream.of(new FieldLocation(list("[0]", "name")),
+                     new FieldLocation(list("name")));
+
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
index d93d8d8fd..564a36204 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
@@ -13,7 +13,9 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Sets.set;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.time.ZonedDateTime;
@@ -250,4 +252,46 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends Recur
     ComparisonDifference difference = diff("a", actual.a, expected.a);
     verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
   }
+
+  @ParameterizedTest(name = "actual={0} / expected={1}")
+  @MethodSource
+  void should_fail_when_actual_is_a_container_whose_elements_differs_from_expected_on_compared_fields(Object actual,
+                                                                                                      Object expected,
+                                                                                                      ComparisonDifference difference) {
+    // GIVEN
+    recursiveComparisonConfiguration.compareOnlyFields("name", "subject");
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
+  private static Stream<Arguments> should_fail_when_actual_is_a_container_whose_elements_differs_from_expected_on_compared_fields() {
+    Student john1 = new Student("John", "math", 1);
+    Student john2 = new Student("John", "math", 1);
+    Student rohit = new Student("Rohit", "english", 2);
+    Student rohyt = new Student("Rohyt", "english", 2);
+    ComparisonDifference difference = diff("[1].name", "Rohit", "Rohyt");
+    return Stream.of(arguments(list(john1, rohit), list(john2, rohyt), difference),
+                     arguments(array(john1, rohit), array(john2, rohyt), difference),
+                     arguments(set(john1, rohit), set(john2, rohyt), difference));
+
+  }
+
+  static class Student {
+    String name;
+    String subject;
+    int rollNo;
+
+    Student(String name, String subject, int rollNo) {
+      this.name = name;
+      this.subject = subject;
+      this.rollNo = rollNo;
+    }
+
+    @Override
+    public String toString() {
+      return String.format("Student[name=%s, subject=%s, rollNo=%s]", this.name, this.subject, this.rollNo);
+    }
+  }
 }
