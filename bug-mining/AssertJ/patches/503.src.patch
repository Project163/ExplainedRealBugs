diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 62a0d91e0..8e38e003e 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -539,6 +539,9 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * assertThat(sherlock).usingRecursiveComparison()
    *                     .", "(Home.class)
    *                     .isEqualTo(moriarty);</code></pre>
+   * <p>
+   * Note that the recursive comparison checks whether the fields actually exist and throws an {@link IllegalArgumentException} if some of them don't,
+   * this is done to catch typos.
    *
    * @param typesToCompare the types to compare in the recursive comparison.
    * @return this {@link RecursiveComparisonAssert} to chain other methods.
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
index ef3da7ae7..3167a2992 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
@@ -30,7 +30,7 @@ import java.util.Objects;
 public final class FieldLocation implements Comparable<FieldLocation> {
 
   private final String pathToUseInRules;
-  private final List<String> decomposedPath; // TODO is it useful?
+  private final List<String> decomposedPath;
 
   public FieldLocation(List<String> path) {
     decomposedPath = unmodifiableList(requireNonNull(path, "path cannot be null"));
@@ -114,6 +114,10 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     return pathToUseInRules.isEmpty();
   }
 
+  public boolean isTopLevelField() {
+    return !isRoot() && !pathToUseInRules.contains(".");
+  }
+
   public static FieldLocation rootFieldLocation() {
     return new FieldLocation(emptyList());
   }
@@ -146,7 +150,8 @@ public final class FieldLocation implements Comparable<FieldLocation> {
    * Returns true if this field has the given child (direct or indirect), false otherwise.
    * <p>
    * Examples:
-   * <pre><code class='java'> | field                 | child           | hasChild? 
+   * <pre><code class='java'>
+   * | field                 | child           | hasChild?
    * -----------------------------------------------  
    * | "name"                | "name.first"    | true       
    * | "name"                | "name.last"     | true       
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 7b0eb6d47..cdbb79c5b 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -19,6 +19,7 @@ import static java.util.stream.Collectors.joining;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
+import static org.assertj.core.data.MapEntry.entry;
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
@@ -27,8 +28,11 @@ import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.LinkedHashSet;
 import java.util.List;
+import java.util.Map;
 import java.util.Map.Entry;
+import java.util.Optional;
 import java.util.Set;
+import java.util.TreeMap;
 import java.util.function.BiPredicate;
 import java.util.function.Predicate;
 import java.util.regex.Pattern;
@@ -222,6 +226,9 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * on the other hand if you specify {@code person.name}, {@code person} won't be compared but {@code person.name} will be.
    * <p>
    * See {@link RecursiveComparisonAssert#comparingOnlyFields(String...) RecursiveComparisonAssert#comparingOnlyFields(String...)} for examples.
+   * <p>
+   * Note that the recursive comparison checks whether the fields actually exist and throws an {@link IllegalArgumentException} if some of them don't,
+   * this is done to catch typos.
    *
    * @param fieldNamesToCompare the fields of the object under test to compare in the comparison.
    */
@@ -252,6 +259,16 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return comparedFields;
   }
 
+  boolean someComparedFieldsHaveBeenSpecified() {
+    return !comparedFields.isEmpty();
+  }
+
+  boolean isOrIsChildOfAnyComparedFields(FieldLocation currentFieldLocation) {
+    return comparedFields.stream()
+                         .anyMatch(comparedField -> comparedField.equals(currentFieldLocation)
+                                                    || comparedField.hasChild(currentFieldLocation));
+  }
+
   /**
    * Returns the set of type to compare from the object under test (fields of other types will not be compared).
    *
@@ -1044,6 +1061,44 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return new Builder();
   }
 
+  void checkComparedFieldsExist(Object actual) {
+    Map<FieldLocation, String> unknownComparedFields = new TreeMap<>();
+    for (FieldLocation comparedField : comparedFields) {
+      checkComparedFieldExists(actual,
+                               comparedField).ifPresent(entry -> unknownComparedFields.put(entry.getKey(), entry.getValue()));
+    }
+    if (!unknownComparedFields.isEmpty()) {
+      StringBuilder errorMessageBuilder = new StringBuilder("The following fields don't exist: ");
+      unknownComparedFields.forEach((fieldLocation,
+                                     nodeName) -> errorMessageBuilder.append(formatUnknownComparedField(fieldLocation,
+                                                                                                        nodeName)));
+      throw new IllegalArgumentException(errorMessageBuilder.toString());
+    }
+  }
+
+  private Optional<Entry<FieldLocation, String>> checkComparedFieldExists(Object actual, FieldLocation comparedFieldLocation) {
+    Object node = actual;
+    for (int nestingLevel = 0; nestingLevel < comparedFieldLocation.getDecomposedPath().size(); nestingLevel++) {
+      if (node == null) {
+        // won't be able to get children nodes, assume the field is known as we can't check it
+        return Optional.empty();
+      }
+      String comparedFieldNodeNameElement = comparedFieldLocation.getDecomposedPath().get(nestingLevel);
+      Set<String> nodeNames = introspectionStrategy.getChildrenNodeNamesOf(node);
+      if (!nodeNames.contains(comparedFieldNodeNameElement)) {
+        return Optional.of(entry(comparedFieldLocation, comparedFieldNodeNameElement));
+      }
+      node = introspectionStrategy.getChildNodeValue(comparedFieldNodeNameElement, node);
+    }
+    return Optional.empty();
+  }
+
+  private static String formatUnknownComparedField(FieldLocation fieldLocation, String unknownNodeNameElement) {
+    return fieldLocation.isTopLevelField()
+        ? format("{%s}", unknownNodeNameElement)
+        : format("{%s in %s}", unknownNodeNameElement, fieldLocation);
+  }
+
   /**
    * Builder to build {@link RecursiveComparisonConfiguration}.
    */
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index c048a8011..023f112e6 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -45,7 +45,6 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicLongArray;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceArray;
-import java.util.stream.Collectors;
 import java.util.stream.Stream;
 
 import org.assertj.core.internal.DeepDifference;
@@ -123,16 +122,16 @@ public class RecursiveComparisonDifferenceCalculator {
       boolean mustCompareNodesRecursively = mustCompareNodesRecursively(dualValue);
       if (dualValue.hasNoNullValues() && mustCompareNodesRecursively) {
         // disregard the equals method and start comparing fields
+        if (recursiveComparisonConfiguration.someComparedFieldsHaveBeenSpecified()) {
+          recursiveComparisonConfiguration.checkComparedFieldsExist(actual);
+        }
         // TODO should fail if actual and expected don't have the same fields (taking into account ignored/compared fields)
         Set<String> actualChildrenNodeNamesToCompare = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
         if (!actualChildrenNodeNamesToCompare.isEmpty()) {
           // fields to ignore are evaluated when adding their corresponding dualValues to dualValuesToCompare which filters
           // ignored fields according to recursiveComparisonConfiguration
           Set<String> expectedChildrenNodesNames = recursiveComparisonConfiguration.getChildrenNodeNamesOf(expected);
-          Set<String> specifiedFieldsToCompare = getAllChildFieldsSpecifiedForCompare(recursiveComparisonConfiguration,
-                                                                                      dualValue);
-          if (expectedChildrenNodesNames.containsAll(actualChildrenNodeNamesToCompare)
-              && actualChildrenNodeNamesToCompare.containsAll(specifiedFieldsToCompare)) {
+          if (expectedChildrenNodesNames.containsAll(actualChildrenNodeNamesToCompare)) {
             // we compare actual fields vs expected, ignoring expected additional fields
             for (String actualChildNodeName : actualChildrenNodeNamesToCompare) {
               Object actualChildNodeValue = recursiveComparisonConfiguration.getValue(actualChildNodeName, actual);
@@ -231,9 +230,17 @@ public class RecursiveComparisonDifferenceCalculator {
 
       // first time we evaluate this dual value, perform the usual recursive comparison from there
 
-      if (dualValue.hasPotentialCyclingValues()) {
-        // visited dual values are tracked to avoid cycle, java types don't have cycle => no need to keep track of them.
-        // moreover this would make should_fix_1854_minimal_test to fail (see the test for a detailed explanation)
+      // visited dual values are tracked to avoid cycle
+      if (recursiveComparisonConfiguration.someComparedFieldsHaveBeenSpecified()) {
+        // only track dual values if their field location is a compared field or a child of one that could have cycles,
+        // before we get to a compared field, tracking dual values is wrong, ex: given a person root object with a
+        // neighbour.neighbour field that cycles back to itself, and we compare neighbour.neighbour.name, if we track
+        // visited all dual values, we would not introspect neighbour.neighbour as it was already visited as root.
+        if (recursiveComparisonConfiguration.isOrIsChildOfAnyComparedFields(dualValue.fieldLocation)
+            && dualValue.hasPotentialCyclingValues()) {
+          comparisonState.visitedDualValues.registerVisitedDualValue(dualValue);
+        }
+      } else if (dualValue.hasPotentialCyclingValues()) {
         comparisonState.visitedDualValues.registerVisitedDualValue(dualValue);
       }
 
@@ -347,14 +354,11 @@ public class RecursiveComparisonDifferenceCalculator {
       Set<String> actualChildrenNodeNamesToCompare = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
       Set<String> expectedChildrenNodesNames = recursiveComparisonConfiguration.getChildrenNodeNamesOf(expectedFieldValue);
       // Check if expected has more children nodes than actual, in that case the additional nodes are reported as difference
-      Set<String> specifiedFieldsToCompare = getAllChildFieldsSpecifiedForCompare(recursiveComparisonConfiguration, dualValue);
 
       // Check if expected has more children nodes than actual, in that case the additional nodes are reported as difference
-      if (!expectedChildrenNodesNames.containsAll(actualChildrenNodeNamesToCompare) ||
-          !actualChildrenNodeNamesToCompare.containsAll(specifiedFieldsToCompare)) {
+      if (!expectedChildrenNodesNames.containsAll(actualChildrenNodeNamesToCompare)) {
         // report missing nodes in actual
         Set<String> actualNodesNamesNotInExpected = newHashSet(actualChildrenNodeNamesToCompare);
-        actualNodesNamesNotInExpected.addAll(specifiedFieldsToCompare);
         actualNodesNamesNotInExpected.removeAll(expectedChildrenNodesNames);
         String missingNodes = actualNodesNamesNotInExpected.toString();
         String expectedClassName = expectedFieldClass.getName();
@@ -380,16 +384,6 @@ public class RecursiveComparisonDifferenceCalculator {
     return comparisonState.getDifferences();
   }
 
-  private static Set<String> getAllChildFieldsSpecifiedForCompare(RecursiveComparisonConfiguration recursiveComparisonConfiguration,
-                                                                  DualValue dualValue) {
-    return recursiveComparisonConfiguration.getComparedFields().stream()
-                                           // Remove all specified fields that are not children of this DualValue
-                                           .filter(field -> isChildOfSpecifiedComparatorField(dualValue, field))
-                                           // Map the next FieldLocation to the fieldName
-                                           .map(field -> getChildFieldForValidation(field, dualValue.fieldLocation))
-                                           .collect(Collectors.toSet());
-  }
-
   private static boolean isChildOfSpecifiedComparatorField(DualValue dualValue, FieldLocation field) {
 
     return field.getPathToUseInRules()
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isRoot_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isRoot_Test.java
index 2d9f3dd77..53c332ee1 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isRoot_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isRoot_Test.java
@@ -12,7 +12,7 @@
  */
 package org.assertj.core.api.recursive;
 
-import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
 import static org.assertj.core.util.Lists.list;
 
@@ -27,26 +27,19 @@ class FieldLocation_isRoot_Test {
   @ParameterizedTest(name = "{0}")
   @MethodSource
   void should_evaluate_object_as_root(FieldLocation fieldLocation) {
-    // GIVEN
-    FieldLocation rootFieldLocation = rootFieldLocation();
-    // WHEN/THEN
-    then(rootFieldLocation.isRoot()).isTrue();
+    assertThat(fieldLocation.isRoot()).isTrue();
   }
 
   private static Stream<FieldLocation> should_evaluate_object_as_root() {
     return Stream.of(rootFieldLocation(),
                      new FieldLocation(list("[0]")),
                      new FieldLocation(list("[1]")));
-
   }
 
   @ParameterizedTest(name = "{0}")
   @MethodSource
   void should_not_evaluate_object_as_root(FieldLocation fieldLocation) {
-    // GIVEN
-    FieldLocation rootFieldLocation = rootFieldLocation();
-    // WHEN/THEN
-    then(rootFieldLocation.isRoot()).isTrue();
+    assertThat(fieldLocation.isRoot()).isFalse();
   }
 
   private static Stream<FieldLocation> should_not_evaluate_object_as_root() {
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isTopLevelField_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isTopLevelField_Test.java
new file mode 100644
index 000000000..e6de3253e
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_isTopLevelField_Test.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.FieldLocation;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class FieldLocation_isTopLevelField_Test {
+
+  @ParameterizedTest
+  @MethodSource
+  void should_return_false_for_root_location_or_nested_field_location(FieldLocation fieldLocation) {
+    assertThat(fieldLocation.isTopLevelField()).isFalse();
+  }
+
+  private static Stream<FieldLocation> should_return_false_for_root_location_or_nested_field_location() {
+    return Stream.of(rootFieldLocation(),
+                     new FieldLocation(list("[0]")),
+                     new FieldLocation(list("[1]")),
+                     new FieldLocation(list("friend", "name")));
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_return_true_for_top_level_field(FieldLocation fieldLocation) {
+    assertThat(fieldLocation.isTopLevelField()).isTrue();
+  }
+
+  private static Stream<FieldLocation> should_return_true_for_top_level_field() {
+    return Stream.of(new FieldLocation(list("name")),
+                     new FieldLocation(list("[0]", "name")),
+                     new FieldLocation(list("[1]", "name")));
+  }
+
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_getFieldName_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_getFieldName_Test.java
index 0648aada6..a7d72dd67 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_getFieldName_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_getFieldName_Test.java
@@ -13,7 +13,7 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static java.util.Collections.emptyList;
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
 
 import org.junit.jupiter.api.Test;
@@ -27,7 +27,7 @@ class DualValue_getFieldName_Test {
     // WHEN
     String expectedFieldName = dualValue.getFieldName();
     // THEN
-    assertThat(expectedFieldName).isEqualTo("foo");
+    then(expectedFieldName).isEqualTo("foo");
   }
 
   @Test
@@ -37,7 +37,7 @@ class DualValue_getFieldName_Test {
     // WHEN
     String expectedFieldName = dualValue.getFieldName();
     // THEN
-    assertThat(expectedFieldName).isEqualTo("bar");
+    then(expectedFieldName).isEqualTo("bar");
   }
 
   @Test
@@ -47,7 +47,7 @@ class DualValue_getFieldName_Test {
     // WHEN
     String expectedFieldName = dualValue.getFieldName();
     // THEN
-    assertThat(expectedFieldName).isEqualTo("");
+    then(expectedFieldName).isEqualTo("");
   }
 
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
index 4bba8350e..0d30bf9e8 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
@@ -12,7 +12,10 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchIllegalArgumentException;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.internal.objects.data.FriendlyPerson.friend;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.set;
@@ -24,6 +27,7 @@ import java.util.List;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
+import org.assertj.core.internal.objects.data.FriendlyPerson;
 import org.assertj.core.internal.objects.data.Human;
 import org.assertj.core.internal.objects.data.Person;
 import org.junit.jupiter.api.Test;
@@ -35,10 +39,10 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends Recur
 
   @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
   @MethodSource
-  void should_only_compare_given_fields(Object actual, Object expected, List<String> fieldNamesToCompare) {
+  void should_only_compare_given_fields(Object actual, Object expected, String[] fieldNamesToCompare) {
 
     then(actual).usingRecursiveComparison()
-                .comparingOnlyFields(arrayOf(fieldNamesToCompare))
+                .comparingOnlyFields(fieldNamesToCompare)
                 .isEqualTo(expected);
   }
 
@@ -72,16 +76,16 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends Recur
     Human person5 = new Human();
     person5.home.address.number = 1;
 
-    return Stream.of(arguments(person1, person2, list("name")),
-                     arguments(person1, person4, list("name")),
-                     arguments(person1, person5, list("home")),
-                     arguments(person1, person5, list("home.address")),
-                     arguments(person1, person5, list("home.address.number")),
-                     arguments(john, jack, list("home", "neighbour.neighbour")),
-                     arguments(john, jack, list("home.address", "neighbour.neighbour")),
-                     arguments(john, jack, list("home.address.number", "neighbour.neighbour")),
-                     arguments(john, jack, list("home", "neighbour.neighbour.home")),
-                     arguments(john, jack, list("home.address", "neighbour.neighbour")));
+    return Stream.of(arguments(person1, person2, array("name")),
+                     arguments(person1, person4, array("name")),
+                     arguments(person1, person5, array("home")),
+                     arguments(person1, person5, array("home.address")),
+                     arguments(person1, person5, array("home.address.number")),
+                     arguments(john, jack, array("home", "neighbour.neighbour")),
+                     arguments(john, jack, array("home.address", "neighbour.neighbour")),
+                     arguments(john, jack, array("home.address.number", "neighbour.neighbour")),
+                     arguments(john, jack, array("home", "neighbour.neighbour.home")),
+                     arguments(john, jack, array("home.address", "neighbour.neighbour")));
   }
 
   @Test
@@ -150,10 +154,6 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends Recur
                 .isEqualTo(expected);
   }
 
-  private static String[] arrayOf(List<String> list) {
-    return list.toArray(new String[0]);
-  }
-
   @SuppressWarnings("unused")
   static class Staff {
 
@@ -281,62 +281,118 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends Recur
   // #3129
   @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
   @MethodSource
-  void should_fail_when_non_existent_fields_specified(Object actual, Object expected, List<String> fieldNamesToCompare,
-                                                      String expectedFailureMsg) {
-
+  void should_fail_when_non_existent_fields_specified(Object actual, Object expected, String[] fieldNamesToCompare,
+                                                      String unknownFields) {
     // GIVEN
-    recursiveComparisonConfiguration.compareOnlyFields(arrayOf(fieldNamesToCompare));
+    recursiveComparisonConfiguration.compareOnlyFields(fieldNamesToCompare);
     // WHEN
-    AssertionError test = compareRecursivelyFailsAsExpected(actual, expected);
+    IllegalArgumentException iae = catchIllegalArgumentException(() -> assertThat(actual).usingRecursiveComparison()
+                                                                                         .comparingOnlyFields(fieldNamesToCompare)
+                                                                                         .isEqualTo(expected));
     // THEN
-    then(test).hasMessageContaining(expectedFailureMsg);
-
+    then(iae).hasMessage("The following fields don't exist: " + unknownFields);
   }
 
   private static Stream<Arguments> should_fail_when_non_existent_fields_specified() {
-    Person p1 = new Person("John");
-    Person p2 = new Person("Alice");
-    Person neighbour = new Person("Jack");
-    Person neighbour2 = new Person("Joan");
-
-    p1.neighbour = neighbour;
-    p2.neighbour = neighbour2;
-    neighbour.neighbour = p1;
-    neighbour2.neighbour = p2;
-
-    return Stream.of(arguments(p1, p2, list("naame"), "does not declare all Person fields, it lacks these: [naame]"),
-                     arguments(p1, p2, list("name", "neighbour", "number"),
-                               "does not declare all Person fields, it lacks these: [number]"),
-                     arguments(p1, p2, list("neighbor"), "does not declare all Person fields, it lacks these: [neighbor]"),
-                     arguments(p1, p2, list("neighbour.neighbor.name"),
-                               "does not declare all Person fields, it lacks these: [neighbor]"),
-                     arguments(p1, p2, list("neighbour.neighbour.name", "neighbour.neighbour.number"),
-                               "does not declare all Person fields, it lacks these: [number]"),
-                     arguments(list(p1, p2), list(neighbour,
-                                                  neighbour2),
-                               list("neighbour.neighbour.name"),
-                               "- actual value  : Person [dateOfBirth=null, name=Jack, phone=null, home=Home [address=Address [number=1]]]\n"
-                                                                 +
-                                                                 "- expected value: Person [dateOfBirth=null, name=John, phone=null, home=Home [address=Address [number=1]]]"));
+    Person john = new Person("John");
+    Person alice = new Person("Alice");
+    Person jack = new Person("Jack");
+    Person joan = new Person("Joan");
+    Person joe = new Person("Joe");
+    john.neighbour = jack;
+    alice.neighbour = joan;
+    jack.neighbour = john;
+    joan.neighbour = alice;
+
+    FriendlyPerson sherlockHolmes = friend("Sherlock Holmes");
+    FriendlyPerson drWatson = friend("Dr. John Watson");
+    FriendlyPerson mollyHooper = friend("Molly Hooper");
+    sherlockHolmes.friends.add(drWatson);
+    sherlockHolmes.friends.add(mollyHooper);
+    drWatson.friends.add(mollyHooper);
+    drWatson.friends.add(sherlockHolmes);
+
+    return Stream.of(arguments(john, alice, array("naame"), "{naame}"),
+                     arguments(john, alice, array("name", "neighbour", "number"), "{number}"),
+                     arguments(john, alice, array("neighbor"), "{neighbor}"),
+                     arguments(john, alice, array("neighbour.neighbor.name"), "{neighbor in <neighbour.neighbor.name>}"),
+                     arguments(sherlockHolmes, drWatson, array("friends.other"), "{other in <friends.other>}"),
+                     arguments(sherlockHolmes, drWatson, array("friends.name"), "{name in <friends.name>}"),
+                     arguments(john, alice, array("neighbour.neighbour.name", "neighbour.neighbour.number"),
+                               "{number in <neighbour.neighbour.number>}"));
+  }
+
+  @Test
+  void should_fail_when_actual_differs_from_expected_lists_on_compared_fields() {
+    // GIVEN
+    Person john = new Person("John");
+    Person alice = new Person("Alice");
+    Person jack = new Person("Jack");
+    Person joan = new Person("Joan");
+    john.neighbour = jack;
+    alice.neighbour = joan;
+    jack.neighbour = john;
+    joan.neighbour = alice;
+    List<Person> actual = list(john, alice);
+    List<Person> expected = list(jack, joan);
+
+    recursiveComparisonConfiguration.compareOnlyFields("neighbour.neighbour.name");
+
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+
+    // THEN
+    ComparisonDifference difference1 = diff("[0].neighbour.neighbour.name", "John", "Jack");
+    ComparisonDifference difference2 = diff("[1].neighbour.neighbour.name", "Alice", "Joan");
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference1, difference2);
   }
 
   // #3129
   @Test
   void should_pass_when_fields_are_nested() {
+    // GIVEN
+    Person john = new Person("John");
+    Person alice = new Person("Alice");
+    Person jack = new Person("Jack");
+    Person joan = new Person("Joan");
+    john.neighbour = jack;
+    alice.neighbour = joan;
+    jack.neighbour = jack;
+    joan.neighbour = jack;
+    // WHEN/THEN
+    then(john).usingRecursiveComparison()
+              .comparingOnlyFields("neighbour.neighbour.name")
+              .isEqualTo(alice);
+  }
 
+  @Test
+  void should_pass_with_cycles() {
     // GIVEN
-    Person p1 = new Person("John");
-    Person p2 = new Person("Alice");
-    Person neighbour = new Person("Jack");
-    Person neighbour2 = new Person("Joan");
-
-    p1.neighbour = neighbour;
-    p2.neighbour = neighbour2;
-    neighbour.neighbour = neighbour;
-    neighbour2.neighbour = neighbour;
+    Person john = new Person("John");
+    Person alice = new Person("Alice");
+    Person jack = new Person("Jack");
+    Person joan = new Person("Joan");
+    john.neighbour = jack;
+    alice.neighbour = joan;
+    jack.neighbour = jack;
+    joan.neighbour = jack;
     // WHEN/THEN
-    then(p1).usingRecursiveComparison().comparingOnlyFields("neighbour.neighbour.name").isEqualTo(p2);
+    then(john).usingRecursiveComparison()
+              .comparingOnlyFields("neighbour.neighbour.neighbour.neighbour")
+              .isEqualTo(alice);
+  }
 
+  @Test
+  void cannot_report_unknown_compared_fields_if_parent_object_is_null() {
+    // GIVEN
+    Person john = new Person("John");
+    Person alice = new Person("Alice");
+    // WHEN/THEN
+    // badField is not detected as an unknown field since john.neighbour is null
+    // neighbour fields are compared and match since they are both null
+    then(john).usingRecursiveComparison()
+              .comparingOnlyFields("neighbour.badField")
+              .isEqualTo(alice);
   }
 
   static class Student {
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_isOrIsChildOfAnyComparedFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_isOrIsChildOfAnyComparedFields_Test.java
new file mode 100644
index 000000000..63013f730
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_isOrIsChildOfAnyComparedFields_Test.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.array;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class RecursiveComparisonConfiguration_isOrIsChildOfAnyComparedFields_Test {
+
+  private final RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+
+  @ParameterizedTest(name = "fieldNamesToCompare={0} / currentField={1}")
+  @MethodSource
+  void should_return_true_if_given_field_location_is_or_is_a_child_of_a_compared_field(String[] fieldNamesToCompare,
+                                                                                       String currentField) {
+    // GIVEN
+    recursiveComparisonConfiguration.compareOnlyFields(fieldNamesToCompare);
+    FieldLocation currentFieldLocation = new FieldLocation(currentField);
+    // WHEN
+    boolean isOrIsChildOfAnyComparedFields = recursiveComparisonConfiguration.isOrIsChildOfAnyComparedFields(currentFieldLocation);
+    // THEN
+    then(isOrIsChildOfAnyComparedFields).isTrue();
+  }
+
+  private static Stream<Arguments> should_return_true_if_given_field_location_is_or_is_a_child_of_a_compared_field() {
+
+    return Stream.of(arguments(array("name"), "name"),
+                     arguments(array("name", "age"), "name"),
+                     arguments(array("neighbour"), "neighbour.name"),
+                     arguments(array("neighbour"), "neighbour.name.firstName"),
+                     arguments(array("neighbour.name", "neighbour.number"), "neighbour.name"),
+                     arguments(array("neighbour.name", "neighbour.number"), "neighbour.name.firstName"));
+  }
+
+  @ParameterizedTest(name = "fieldNamesToCompare={0} / currentField={1}")
+  @MethodSource
+  void should_return_false_if_given_field_location_is_parent_of_a_compared_field(String[] fieldNamesToCompare,
+                                                                                 String currentField) {
+    // GIVEN
+    recursiveComparisonConfiguration.compareOnlyFields(fieldNamesToCompare);
+    FieldLocation currentFieldLocation = new FieldLocation(currentField);
+    // WHEN
+    boolean isOrIsChildOfAnyComparedFields = recursiveComparisonConfiguration.isOrIsChildOfAnyComparedFields(currentFieldLocation);
+    // THEN
+    then(isOrIsChildOfAnyComparedFields).isFalse();
+  }
+
+  private static Stream<Arguments> should_return_false_if_given_field_location_is_parent_of_a_compared_field() {
+
+    return Stream.of(arguments(array("name.firstName"), "name"),
+                     arguments(array("neighbour.name", "neighbour.number"), "neighbour"),
+                     arguments(array("neighbour.name.firstName", "neighbour.number"), "neighbour.name"));
+  }
+
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_someComparedFieldsHaveBeenSpecified_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_someComparedFieldsHaveBeenSpecified_Test.java
new file mode 100644
index 000000000..ba343f518
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_someComparedFieldsHaveBeenSpecified_Test.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import org.junit.jupiter.api.Test;
+
+class RecursiveComparisonConfiguration_someComparedFieldsHaveBeenSpecified_Test {
+
+  private final RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+
+  @Test
+  void should_return_true_if_some_compared_fields_have_been_specified() {
+    // GIVEN
+    recursiveComparisonConfiguration.compareOnlyFields("name");
+    // WHEN
+    boolean someComparedFieldsHaveBeenSpecified = recursiveComparisonConfiguration.someComparedFieldsHaveBeenSpecified();
+    // THEN
+    then(someComparedFieldsHaveBeenSpecified).isTrue();
+  }
+
+  @Test
+  void should_return_false_if_no_compared_fields_have_been_specified() {
+    // WHEN
+    boolean someComparedFieldsHaveBeenSpecified = recursiveComparisonConfiguration.someComparedFieldsHaveBeenSpecified();
+    // THEN
+    then(someComparedFieldsHaveBeenSpecified).isFalse();
+  }
+
+}
