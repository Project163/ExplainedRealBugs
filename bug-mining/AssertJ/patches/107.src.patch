diff --git a/src/ide-support/assertj-eclipse-formatter.xml b/src/ide-support/assertj-eclipse-formatter.xml
index 189ab8225..1497e3efd 100644
--- a/src/ide-support/assertj-eclipse-formatter.xml
+++ b/src/ide-support/assertj-eclipse-formatter.xml
@@ -17,7 +17,7 @@
 <setting id="org.eclipse.jdt.core.formatter.insert_space_between_empty_parens_in_annotation_type_member_declaration" value="do not insert"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_method_declaration_throws" value="do not insert"/>
 <setting id="org.eclipse.jdt.core.formatter.comment.format_javadoc_comments" value="true"/>
-<setting id="org.eclipse.jdt.core.formatter.indentation.size" value="2"/>
+<setting id="org.eclipse.jdt.core.formatter.indentation.size" value="4"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_after_postfix_operator" value="do not insert"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_for_increments" value="insert"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_type_arguments" value="insert"/>
@@ -166,7 +166,7 @@
 <setting id="org.eclipse.jdt.core.compiler.source" value="1.8"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_paren_in_synchronized" value="do not insert"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_constructor_declaration_throws" value="insert"/>
-<setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="4"/>
+<setting id="org.eclipse.jdt.core.formatter.tabulation.size" value="2"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_new_line_in_empty_enum_constant" value="insert"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_after_comma_in_allocation_expression" value="insert"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_after_opening_bracket_in_array_reference" value="do not insert"/>
@@ -285,7 +285,7 @@
 <setting id="org.eclipse.jdt.core.formatter.insert_space_before_question_in_conditional" value="insert"/>
 <setting id="org.eclipse.jdt.core.formatter.comment.indent_parameter_description" value="true"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_new_line_before_finally_in_try_statement" value="do not insert"/>
-<setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="mixed"/>
+<setting id="org.eclipse.jdt.core.formatter.tabulation.char" value="space"/>
 <setting id="org.eclipse.jdt.core.formatter.insert_space_before_comma_in_multiple_field_declarations" value="do not insert"/>
 <setting id="org.eclipse.jdt.core.formatter.blank_lines_between_import_groups" value="1"/>
 <setting id="org.eclipse.jdt.core.formatter.lineSplit" value="120"/>
diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 730dc35b8..6538e5ecf 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -12,16 +12,6 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.extractor.Extractors.byName;
-import static org.assertj.core.extractor.Extractors.resultOf;
-import static org.assertj.core.util.Iterables.toArray;
-import static org.assertj.core.util.Lists.newArrayList;
-
-import java.util.Collection;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.List;
-
 import org.assertj.core.api.iterable.Extractor;
 import org.assertj.core.groups.FieldsOrPropertiesExtractor;
 import org.assertj.core.groups.Tuple;
@@ -37,6 +27,16 @@ import org.assertj.core.internal.OnFieldsComparator;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.introspection.IntrospectionError;
 
+import java.util.Collection;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.List;
+
+import static org.assertj.core.extractor.Extractors.byName;
+import static org.assertj.core.extractor.Extractors.resultOf;
+import static org.assertj.core.util.Iterables.toArray;
+import static org.assertj.core.util.Lists.newArrayList;
+
 /**
  * Base class for implementations of <code>{@link ObjectEnumerableAssert}</code> whose actual value type is
  * <code>{@link Collection}</code>.
@@ -822,7 +822,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    *           public) in one of the initial Iterable's element.
    */
   public ListAssert<Tuple> extracting(String... propertiesOrFields) {
-	return extracting(byName(propertiesOrFields));
+    List<Tuple> values = FieldsOrPropertiesExtractor.extract(actual, byName(propertiesOrFields));
+    return new ListAssert<>(values);
   }
 
   /**
diff --git a/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java b/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
index 74392397b..d9beea97c 100644
--- a/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
+++ b/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
@@ -12,24 +12,16 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.util.Arrays.array;
-import net.sf.cglib.proxy.Enhancer;
-
 public class AbstractSoftAssertions {
 
-  protected final ErrorCollector collector;
+  protected final SoftProxies proxies;
 
   public AbstractSoftAssertions() {
 	super();
-	this.collector = new ErrorCollector();
+    proxies = new SoftProxies();
   }
 
-  @SuppressWarnings("unchecked")
   protected <T, V> V proxy(Class<V> assertClass, Class<T> actualClass, T actual) {
-    Enhancer enhancer = new Enhancer();
-    enhancer.setSuperclass(assertClass);
-    enhancer.setCallback(collector);
-    return (V) enhancer.create(array(actualClass), array(actual));
+    return proxies.create(assertClass, actualClass, actual);
   }
-
 }
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/BDDSoftAssertions.java b/src/main/java/org/assertj/core/api/BDDSoftAssertions.java
index 4f9726215..e94604bc0 100644
--- a/src/main/java/org/assertj/core/api/BDDSoftAssertions.java
+++ b/src/main/java/org/assertj/core/api/BDDSoftAssertions.java
@@ -12,10 +12,10 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.groups.Properties.extractProperty;
-
 import java.util.List;
 
+import static org.assertj.core.groups.Properties.extractProperty;
+
 /**
  * <p>
  * Suppose we have a test case and in it we'd like to make numerous BDD assertions. In this case, we're hosting a dinner
@@ -135,7 +135,7 @@ public class BDDSoftAssertions extends AbstractBDDSoftAssertions {
    * @throws SoftAssertionError if any proxied assertion objects threw
    */
   public void assertAll() {
-	List<Throwable> errors = collector.errors();
+	List<Throwable> errors = proxies.errorsCollected();
 	if (!errors.isEmpty()) {
 	  throw new SoftAssertionError(extractProperty("message", String.class).from(errors));
 	}
diff --git a/src/main/java/org/assertj/core/api/ErrorCollector.java b/src/main/java/org/assertj/core/api/ErrorCollector.java
index a84c791d0..764ebafe0 100644
--- a/src/main/java/org/assertj/core/api/ErrorCollector.java
+++ b/src/main/java/org/assertj/core/api/ErrorCollector.java
@@ -12,16 +12,16 @@
  */
 package org.assertj.core.api;
 
+import net.sf.cglib.proxy.MethodInterceptor;
+import net.sf.cglib.proxy.MethodProxy;
+
 import java.lang.reflect.Method;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 
-import net.sf.cglib.proxy.MethodInterceptor;
-import net.sf.cglib.proxy.MethodProxy;
-
 /** Collects error messages of all AssertionErrors thrown by the proxied method. */
-public class ErrorCollector implements MethodInterceptor {
+class ErrorCollector implements MethodInterceptor {
 
   private final List<Throwable> errors = new ArrayList<Throwable>();
 
diff --git a/src/main/java/org/assertj/core/api/JUnitBDDSoftAssertions.java b/src/main/java/org/assertj/core/api/JUnitBDDSoftAssertions.java
index 6d085feda..86ac5dd72 100644
--- a/src/main/java/org/assertj/core/api/JUnitBDDSoftAssertions.java
+++ b/src/main/java/org/assertj/core/api/JUnitBDDSoftAssertions.java
@@ -18,6 +18,8 @@ import org.junit.runner.Description;
 import org.junit.runners.model.MultipleFailureException;
 import org.junit.runners.model.Statement;
 
+import java.util.List;
+
 /**
  * Same as {@link SoftAssertions}, but with the following differences: <br/>
  * First, it's a junit rule, which can be used without having to call {@link SoftAssertions#assertAll() assertAll()},
@@ -46,7 +48,7 @@ public class JUnitBDDSoftAssertions extends AbstractBDDSoftAssertions implements
 	  @Override
 	  public void evaluate() throws Throwable {
 		base.evaluate();
-		MultipleFailureException.assertEmpty(collector.errors());
+		MultipleFailureException.assertEmpty(proxies.errorsCollected());
 	  }
 	};
   }
@@ -55,9 +57,8 @@ public class JUnitBDDSoftAssertions extends AbstractBDDSoftAssertions implements
 	super();
   }
 
-  @VisibleForTesting
-  ErrorCollector getCollector() {
-	return collector;
+  @VisibleForTesting List<Throwable> getErrors() {
+	return proxies.errorsCollected();
   }
 
 }
diff --git a/src/main/java/org/assertj/core/api/JUnitSoftAssertions.java b/src/main/java/org/assertj/core/api/JUnitSoftAssertions.java
index 60bf79e19..4ae8146c3 100644
--- a/src/main/java/org/assertj/core/api/JUnitSoftAssertions.java
+++ b/src/main/java/org/assertj/core/api/JUnitSoftAssertions.java
@@ -18,6 +18,8 @@ import org.junit.runner.Description;
 import org.junit.runners.model.MultipleFailureException;
 import org.junit.runners.model.Statement;
 
+import java.util.List;
+
 /**
  * Same as {@link SoftAssertions}, but with the following differences: <br/>
  * First, it's a junit rule, which can be used without having to call {@link SoftAssertions#assertAll() assertAll()},
@@ -46,7 +48,7 @@ public class JUnitSoftAssertions extends AbstractStandardSoftAssertions implemen
 	  @Override
 	  public void evaluate() throws Throwable {
 		base.evaluate();
-		MultipleFailureException.assertEmpty(collector.errors());
+		MultipleFailureException.assertEmpty(proxies.errorsCollected());
 	  }
 	};
   }
@@ -55,9 +57,8 @@ public class JUnitSoftAssertions extends AbstractStandardSoftAssertions implemen
 	super();
   }
 
-  @VisibleForTesting
-  ErrorCollector getCollector() {
-	return collector;
+  @VisibleForTesting List<Throwable> getErrors() {
+	return proxies.errorsCollected();
   }
 
 }
diff --git a/src/main/java/org/assertj/core/api/ProxifyExtractingResult.java b/src/main/java/org/assertj/core/api/ProxifyExtractingResult.java
new file mode 100644
index 000000000..24548ebda
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/ProxifyExtractingResult.java
@@ -0,0 +1,66 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import net.sf.cglib.proxy.MethodInterceptor;
+import net.sf.cglib.proxy.MethodProxy;
+
+import java.lang.reflect.Array;
+import java.lang.reflect.Method;
+import java.lang.reflect.ParameterizedType;
+import java.lang.reflect.Type;
+
+class ProxifyExtractingResult implements MethodInterceptor {
+
+  private final SoftProxies proxies;
+
+  ProxifyExtractingResult(SoftProxies proxies) {
+    this.proxies = proxies;
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {
+
+    Object result = proxy.invokeSuper(obj, args);
+    return proxies.create(result.getClass(), actualClass(result), actual(result));
+  }
+
+  @SuppressWarnings("rawtypes")
+  private static Class actualClass(Object result) {
+    if (result instanceof ObjectArrayAssert) {
+      return Array.newInstance(Object.class, 0).getClass();
+    }
+
+    // Trying to create a proxy with cglib will only match exact constructor argument types.
+    // To initialize one for ListAssert for example we can't use an ArrayList, we have to use a List.
+    // So we can't just return actual.getClass() as we could read a concrete class whereas
+    // *Assert classes define a constructor using interface (@see ListAssert for example).
+    //
+    // Instead we can read generic types from *Assert definition.
+    // Inspecting: class ListAssert<T> extends AbstractListAssert<ListAssert<T>, List<? extends T>, T>
+    // will return the generic defined by the super class AbstractListAssert at index 1, which is a List<? extends T>
+    Type actualType = ((ParameterizedType) result.getClass().getGenericSuperclass()).getActualTypeArguments()[1];
+    if (actualType instanceof ParameterizedType) {
+      return (Class<?>) ((ParameterizedType) actualType).getRawType();
+    }
+
+    return (Class<?>) actualType;
+  }
+
+  private static Object actual(Object result) {
+    if (result instanceof AbstractAssert) return ((AbstractAssert<?, ?>) result).actual;
+    throw new IllegalStateException("We should be trying to make a proxy of an *Assert class.");
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/api/SoftAssertions.java b/src/main/java/org/assertj/core/api/SoftAssertions.java
index baa6cfae1..fd79dff17 100644
--- a/src/main/java/org/assertj/core/api/SoftAssertions.java
+++ b/src/main/java/org/assertj/core/api/SoftAssertions.java
@@ -12,10 +12,10 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.groups.Properties.extractProperty;
-
 import java.util.List;
 
+import static org.assertj.core.groups.Properties.extractProperty;
+
 /**
  * <p>
  * Suppose we have a test case and in it we'd like to make numerous assertions. In this case, we're hosting a dinner
@@ -134,7 +134,7 @@ public class SoftAssertions extends AbstractStandardSoftAssertions {
    * @throws SoftAssertionError if any proxied assertion objects threw
    */
   public void assertAll() {
-	List<Throwable> errors = collector.errors();
+	List<Throwable> errors = proxies.errorsCollected();
 	if (!errors.isEmpty()) {
 	  throw new SoftAssertionError(extractProperty("message", String.class).from(errors));
 	}
diff --git a/src/main/java/org/assertj/core/api/SoftProxies.java b/src/main/java/org/assertj/core/api/SoftProxies.java
new file mode 100644
index 000000000..b9cba24dd
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/SoftProxies.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import net.sf.cglib.proxy.Callback;
+import net.sf.cglib.proxy.CallbackFilter;
+import net.sf.cglib.proxy.Enhancer;
+
+import java.lang.reflect.Method;
+import java.util.List;
+
+import static org.assertj.core.util.Arrays.array;
+
+class SoftProxies {
+
+  private final ErrorCollector collector = new ErrorCollector();
+
+  List<Throwable> errorsCollected() {
+    return collector.errors();
+  }
+
+  @SuppressWarnings("unchecked")
+  <V, T> V create(Class<V> assertClass, Class<T> actualClass, T actual) {
+    Enhancer enhancer = new Enhancer();
+    enhancer.setSuperclass(assertClass);
+    enhancer.setCallbackFilter(CollectErrorsOrCreateExtractedProxy.FILTER);
+    enhancer.setCallbacks(new Callback[] { collector, new ProxifyExtractingResult(this) });
+    return (V) enhancer.create(array(actualClass), array(actual));
+  }
+
+  private enum CollectErrorsOrCreateExtractedProxy implements CallbackFilter {
+    FILTER;
+
+    private static final int ERROR_COLLECTOR_INDEX = 0;
+    private static final int PROXIFY_EXTRACTING_INDEX = 1;
+
+    public int accept(Method method) {
+      return isExtractingMethod(method) ? PROXIFY_EXTRACTING_INDEX : ERROR_COLLECTOR_INDEX;
+    }
+
+    private boolean isExtractingMethod(Method method) {
+      return method.getName().toLowerCase().contains("extracting");
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/JUnitBDDSoftAssertionsFailureTest.java b/src/test/java/org/assertj/core/api/JUnitBDDSoftAssertionsFailureTest.java
index 23ac173a6..70f586b41 100644
--- a/src/test/java/org/assertj/core/api/JUnitBDDSoftAssertionsFailureTest.java
+++ b/src/test/java/org/assertj/core/api/JUnitBDDSoftAssertionsFailureTest.java
@@ -12,15 +12,15 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-import java.util.List;
-
 import org.assertj.core.util.Lists;
 import org.junit.Test;
 import org.junit.runners.model.MultipleFailureException;
 
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
 public class JUnitBDDSoftAssertionsFailureTest {
 
   // we cannot make it a rule here, because we need to test the failure without this test failing!
@@ -33,7 +33,7 @@ public class JUnitBDDSoftAssertionsFailureTest {
 	  softly.then(1).isEqualTo(1);
 	  softly.then(1).isEqualTo(2);
 	  softly.then(Lists.newArrayList(1, 2)).containsOnly(1, 3);
-	  MultipleFailureException.assertEmpty(softly.getCollector().errors());
+	  MultipleFailureException.assertEmpty(softly.getErrors());
 	  fail("Should not reach here");
 	} catch (MultipleFailureException e) {
 	  List<Throwable> failures = e.getFailures();
diff --git a/src/test/java/org/assertj/core/api/JUnitSoftAssertionsFailureTest.java b/src/test/java/org/assertj/core/api/JUnitSoftAssertionsFailureTest.java
index 154bec028..e3cac94b2 100644
--- a/src/test/java/org/assertj/core/api/JUnitSoftAssertionsFailureTest.java
+++ b/src/test/java/org/assertj/core/api/JUnitSoftAssertionsFailureTest.java
@@ -12,15 +12,15 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.junit.Assert.fail;
-
-import java.util.List;
-
 import org.assertj.core.util.Lists;
 import org.junit.Test;
 import org.junit.runners.model.MultipleFailureException;
 
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.Assert.fail;
+
 public class JUnitSoftAssertionsFailureTest {
 
   //we cannot make it a rule here, because we need to test the failure without this test failing!
@@ -33,7 +33,7 @@ public class JUnitSoftAssertionsFailureTest {
       softly.assertThat(1).isEqualTo(1);
       softly.assertThat(1).isEqualTo(2);
       softly.assertThat(Lists.newArrayList(1, 2)).containsOnly(1, 3);
-      MultipleFailureException.assertEmpty(softly.getCollector().errors());
+      MultipleFailureException.assertEmpty(softly.getErrors());
       fail("Should not reach here");
     } catch (MultipleFailureException e) {
       List<Throwable> failures = e.getFailures();
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index fbae5ebc8..f5dd04160 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -12,21 +12,29 @@
  */
 package org.assertj.core.api;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.util.Dates.parseDatetime;
-import static org.junit.Assert.fail;
+import org.assertj.core.api.iterable.Extractor;
+import org.assertj.core.data.MapEntry;
+import org.assertj.core.test.CartoonCharacter;
+import org.assertj.core.test.Maps;
+import org.assertj.core.test.Name;
+import org.assertj.core.util.Lists;
+import org.junit.Before;
+import org.junit.Test;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
 import java.math.BigDecimal;
+import java.util.Collection;
+import java.util.Iterator;
 import java.util.List;
 import java.util.concurrent.Callable;
 
-import org.assertj.core.data.MapEntry;
-import org.assertj.core.test.Maps;
-import org.assertj.core.util.Lists;
-import org.junit.Before;
-import org.junit.Test;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.shouldHaveThrown;
+import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.util.Dates.parseDatetime;
+import static org.junit.Assert.fail;
 
 /**
  * Tests for <code>{@link SoftAssertions}</code>.
@@ -37,9 +45,25 @@ public class SoftAssertionsTest {
 
   private SoftAssertions softly;
 
+  private CartoonCharacter homer;
+  private CartoonCharacter fred;
+
   @Before
   public void setup() {
-	softly = new SoftAssertions();
+    softly = new SoftAssertions();
+
+    CartoonCharacter bart = new CartoonCharacter("Bart Simpson");
+    CartoonCharacter lisa = new CartoonCharacter("Lisa Simpson");
+    CartoonCharacter maggie = new CartoonCharacter("Maggie Simpson");
+
+    homer = new CartoonCharacter("Homer Simpson");
+    homer.getChildren().add(bart);
+    homer.getChildren().add(lisa);
+    homer.getChildren().add(maggie);
+
+    CartoonCharacter pebbles = new CartoonCharacter("Pebbles Flintstone");
+    fred = new CartoonCharacter("Fred Flintstone");
+    fred.getChildren().add(pebbles);
   }
 
   @Test
@@ -218,4 +242,240 @@ public class SoftAssertionsTest {
 	}
   }
 
+  @Test
+  public void should_pass_when_using_extracting_with_list() {
+
+    List<Name> names = asList(name("John", "Doe"), name("Jane", "Doe"));
+
+    softly.assertThat(names)
+          .extracting("first")
+          .as("using extracting()")
+          .contains("John")
+          .contains("Jane");
+
+    softly.assertThat(names)
+          .extracting(new Extractor<Name, String>() {
+            @Override public String extract(Name input) {
+	          return input.getFirst();
+            }
+          })
+          .as("using extracting(Extractor)")
+          .contains("John")
+          .contains("Jane");
+
+    softly.assertThat(names)
+          .extracting("first", String.class)
+          .as("using extracting(..., Class)")
+          .contains("John")
+          .contains("Jane");
+
+    softly.assertThat(names)
+          .extracting("first", "last")
+          .as("using extracting(...)")
+          .contains(tuple("John", "Doe"))
+          .contains(tuple("Jane", "Doe"));
+
+    softly.assertThat(names)
+          .extractingResultOf("getFirst", String.class)
+          .as("using extractingResultOf(method, Class)")
+          .contains("John")
+          .contains("Jane");
+
+    softly.assertThat(names)
+          .extractingResultOf("getFirst")
+          .as("using extractingResultOf(method)")
+          .contains("John")
+          .contains("Jane");
+
+    softly.assertAll();
+  }
+
+  @Test
+  public void should_pass_when_using_extracting_with_iterable() {
+
+	Iterable<Name> names = asList(name("John", "Doe"), name("Jane", "Doe"));
+
+    try (AutoCloseableSoftAssertions softly = new AutoCloseableSoftAssertions()) {
+      softly.assertThat(names)
+            .extracting("first")
+            .as("using extracting()")
+            .contains("John")
+            .contains("Jane");
+
+      softly.assertThat(names)
+            .extracting(new Extractor<Name, String>() {
+	          @Override public String extract(Name input) {
+	            return input.getFirst();
+	          }
+            })
+            .as("using extracting(Extractor)")
+            .contains("John")
+            .contains("Jane");
+
+      softly.assertThat(names)
+            .extracting("first", String.class)
+            .as("using extracting(..., Class)")
+            .contains("John")
+            .contains("Jane");
+
+      softly.assertThat(names)
+            .extracting("first", "last")
+            .as("using extracting(...)")
+            .contains(tuple("John", "Doe"))
+            .contains(tuple("Jane", "Doe"));
+
+      softly.assertThat(names)
+            .extractingResultOf("getFirst", String.class)
+            .as("using extractingResultOf(method, Class)")
+            .contains("John")
+            .contains("Jane");
+
+      softly.assertThat(names)
+            .extractingResultOf("getFirst")
+            .as("using extractingResultOf(method)")
+            .contains("John")
+            .contains("Jane");
+    }
+  }
+
+  @Test
+  public void should_pass_when_using_extracting_with_array() {
+
+    Name[] namesAsArray = new Name[] { name("John", "Doe"), name("Jane", "Doe") };
+
+    try (AutoCloseableSoftAssertions softly = new AutoCloseableSoftAssertions()) {
+      softly.assertThat(namesAsArray)
+            .extracting("first")
+            .as("using extracting()")
+            .contains("John")
+            .contains("Jane");
+
+      softly.assertThat(namesAsArray)
+            .extracting(new Extractor<Name, String>() {
+	          @Override public String extract(Name input) {
+	            return input.getFirst();
+	          }
+            })
+            .as("using extracting(Extractor)")
+            .contains("John")
+            .contains("Jane");
+
+      softly.assertThat(namesAsArray)
+            .extracting("first", String.class)
+            .as("using extracting(..., Class)")
+            .contains("John")
+            .contains("Jane");
+
+      softly.assertThat(namesAsArray)
+            .extracting("first", "last")
+            .as("using extracting(...)")
+            .contains(tuple("John", "Doe"))
+            .contains(tuple("Jane", "Doe"));
+
+      softly.assertThat(namesAsArray)
+            .extractingResultOf("getFirst", String.class)
+            .as("using extractingResultOf(method, Class)")
+            .contains("John")
+            .contains("Jane");
+
+      softly.assertThat(namesAsArray)
+            .extractingResultOf("getFirst")
+            .as("using extractingResultOf(method)")
+            .contains("John")
+            .contains("Jane");
+    }
+  }
+
+  @Test
+  public void should_pass_when_using_extracting_with_iterator() {
+
+    Iterator<Name> names = asList(name("John", "Doe"), name("Jane", "Doe")).iterator();
+
+    try (AutoCloseableSoftAssertions softly = new AutoCloseableSoftAssertions()) {
+      softly.assertThat(names)
+            .extracting("first")
+            .as("using extracting()")
+            .contains("John")
+            .contains("Jane");
+    }
+  }
+
+  @Test
+  public void should_pass_when_using_flat_extracting() {
+
+    List<CartoonCharacter> characters = asList(homer, fred);
+
+    softly.assertThat(characters)
+          .flatExtracting(children())
+          .as("using flatExtracting on Iterable")
+          .hasSize(4);
+
+    CartoonCharacter[] charactersAsArray = characters.toArray(new CartoonCharacter[characters.size()]);
+
+    softly.assertThat(charactersAsArray)
+          .flatExtracting(children())
+          .as("using flatExtracting on array")
+          .hasSize(4);
+
+    softly.assertAll();
+  }
+
+  @Test
+  public void should_collect_all_errors_when_using_extracting() {
+
+    List<Name> names = asList(name("John", "Doe"), name("Jane", "Doe"));
+
+    softly.assertThat(names)
+          .extracting("first")
+          .overridingErrorMessage("error 1")
+          .contains("gandalf")
+          .overridingErrorMessage("error 2")
+          .contains("frodo");
+
+    softly.assertThat(names)
+          .extracting("last")
+          .overridingErrorMessage("error 3")
+          .isEmpty();
+
+    try {
+	  softly.assertAll();
+	  shouldHaveThrown(SoftAssertionError.class);
+    } catch (SoftAssertionError e) {
+	  assertThat(e.getErrors()).containsExactly("error 1", "error 2", "error 3");
+    }
+  }
+
+  @Test
+  public void should_collect_all_errors_when_using_flat_extracting() throws Exception {
+
+    List<CartoonCharacter> characters = asList(homer, fred);
+
+    softly.assertThat(characters)
+          .flatExtracting(children())
+          .overridingErrorMessage("error 1")
+          .hasSize(0)
+          .overridingErrorMessage("error 2")
+          .isEmpty();
+
+    try {
+	  softly.assertAll();
+	  shouldHaveThrown(SoftAssertionError.class);
+    } catch (SoftAssertionError e) {
+	  assertThat(e.getErrors()).containsExactly("error 1", "error 2");
+    }
+  }
+
+  private static Name name(String first, String last) {
+	return new Name(first, last);
+  }
+
+  private static ChildrenExtractor children() {
+	return new ChildrenExtractor();
+  }
+
+  private static class ChildrenExtractor implements Extractor<CartoonCharacter, Collection<CartoonCharacter>> {
+	@Override public Collection<CartoonCharacter> extract(CartoonCharacter input) {
+		return input.getChildren();
+	}
+  }
 }
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
index fc1a33f7e..289510805 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
@@ -145,14 +145,14 @@ public class IterableAssert_extracting_Test {
   @Test
   public void should_allow_assertions_on_multiple_extracted_values_from_given_iterable() throws Exception {
     assertThat(employees).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
-        tuple("Luke", 26, 2L));
+                                                                             tuple("Luke", 26, 2L));
   }
 
   @Test
   public void should_throw_error_if_one_property_or_field_can_not_be_extracted() throws Exception {
     thrown.expect(IntrospectionError.class);
     assertThat(employees).extracting("unknown", "age", "id")
-        .containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+                         .containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
   }
 
   @Test
