diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 8585f5755..64efae33b 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -1751,6 +1751,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   // The public method for it (the one not ending with "ForProxy") is marked as final and annotated with @SafeVarargs
   // in order to avoid compiler warning in user code
   protected AbstractListAssert<?, List<? extends Object>, Object, ObjectAssert<Object>> flatExtractingForProxy(Function<? super ELEMENT, ?>[] extractors) {
+    if (actual == null) throwAssertionError(shouldNotBeNull());
     Stream<? extends ELEMENT> actualStream = stream(actual.spliterator(), false);
     List<Object> result = actualStream.flatMap(element -> Stream.of(extractors).map(extractor -> extractor.apply(element)))
                                       .collect(toList());
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
index a25e194ea..9fc5f1244 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
@@ -401,8 +401,7 @@ class IterableAssert_extracting_Test {
                                                                                       .extracting(new Extractor<Employee, String>() {
                                                                                         @Override
                                                                                         public String extract(Employee input) {
-                                                                                          return input.getName()
-                                                                                                      .getFirst();
+                                                                                          return input.getName().getFirst();
                                                                                         }
                                                                                       }).isEmpty())
                                                    .withMessageContaining("[check employees first name]");
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_Test.java
index 3df9ddfa2..b7fc4ca75 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_Test.java
@@ -13,8 +13,9 @@
 package org.assertj.core.api.iterable;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithNamesOf;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithTypeOf;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorsByTypeOf;
@@ -22,7 +23,8 @@ import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRES
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TIMESTAMP;
 import static org.assertj.core.test.AlwaysEqualComparator.alwaysEqual;
-import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Lists.list;
 
 import java.sql.Timestamp;
 import java.util.List;
@@ -74,7 +76,6 @@ class IterableAssert_flatExtracting_Test {
     bart = new CartoonCharacter("Bart Simpson");
     lisa = new CartoonCharacter("Lisa Simpson");
     maggie = new CartoonCharacter("Maggie Simpson");
-
     homer = new CartoonCharacter("Homer Simpson");
     homer.addChildren(bart, lisa, maggie);
 
@@ -85,59 +86,85 @@ class IterableAssert_flatExtracting_Test {
 
   @Test
   void should_allow_assertions_on_joined_lists_when_extracting_children_with_extractor() {
-    assertThat(newArrayList(homer, fred)).flatExtracting(childrenExtractor)
-                                         .containsOnly(bart, lisa, maggie, pebbles);
+    assertThat(list(homer, fred)).flatExtracting(childrenExtractor)
+                                 .containsOnly(bart, lisa, maggie, pebbles);
   }
 
   @Test
   void should_allow_assertions_on_joined_lists_when_extracting_children() {
-    assertThat(newArrayList(homer, fred)).flatExtracting(children)
-                                         .containsOnly(bart, lisa, maggie, pebbles);
+    assertThat(list(homer, fred)).flatExtracting(children)
+                                 .containsOnly(bart, lisa, maggie, pebbles);
   }
 
   @Test
   void should_allow_assertions_on_empty_result_lists_with_extractor() {
-    assertThat(newArrayList(bart, lisa, maggie)).flatExtracting(childrenExtractor)
-                                                .isEmpty();
+    assertThat(list(bart, lisa, maggie)).flatExtracting(childrenExtractor)
+                                        .isEmpty();
   }
 
   @Test
   void should_allow_assertions_on_empty_result_lists() {
-    assertThat(newArrayList(bart, lisa, maggie)).flatExtracting(children)
-                                                .isEmpty();
+    assertThat(list(bart, lisa, maggie)).flatExtracting(children)
+                                        .isEmpty();
+  }
+
+  @Test
+  void should_throw_assertion_error_if_actual_is_null() {
+    // GIVEN
+    List<CartoonCharacter> simpsons = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(simpsons).flatExtracting(childrenExtractor));
+    // THEN
+    then(assertionError).hasMessage("Expecting actual not to be null");
   }
 
   @Test
   void should_bubble_up_null_pointer_exception_from_extractor() {
-    assertThatNullPointerException().isThrownBy(() -> assertThat(newArrayList(homer, null)).flatExtracting(childrenExtractor));
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer, null);
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(() -> assertThat(cartoonCharacters).flatExtracting(childrenExtractor));
   }
 
   @Test
   void should_bubble_up_null_pointer_exception_from_lambda_extractor() {
-    assertThatNullPointerException().isThrownBy(() -> assertThat(newArrayList(homer, null)).flatExtracting(children));
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer, null);
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(() -> assertThat(cartoonCharacters).flatExtracting(children));
   }
 
   @Test
   void should_rethrow_throwing_extractor_checked_exception_as_a_runtime_exception() {
-    List<CartoonCharacter> childCharacters = newArrayList(bart, lisa, maggie);
-    assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> assertThat(childCharacters).flatExtracting(cartoonCharacter -> {
+    // GIVEN
+    List<CartoonCharacter> childCharacters = list(bart, lisa, maggie);
+    // WHEN
+    RuntimeException runtimeException = catchThrowableOfType(() -> assertThat(childCharacters).flatExtracting(cartoonCharacter -> {
       if (cartoonCharacter.getChildren().isEmpty()) throw new Exception("no children");
       return cartoonCharacter.getChildren();
-    })).withMessage("java.lang.Exception: no children");
+    }), RuntimeException.class);
+    // THEN
+    then(runtimeException).hasMessage("java.lang.Exception: no children");
   }
 
   @Test
   void should_let_throwing_extractor_runtime_exception_bubble_up() {
-    List<CartoonCharacter> childCharacters = newArrayList(bart, lisa, maggie);
-    assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> assertThat(childCharacters).flatExtracting(cartoonCharacter -> {
+    // GIVEN
+    List<CartoonCharacter> childCharacters = list(bart, lisa, maggie);
+    // WHEN
+    RuntimeException runtimeException = catchThrowableOfType(() -> assertThat(childCharacters).flatExtracting(cartoonCharacter -> {
       if (cartoonCharacter.getChildren().isEmpty()) throw new RuntimeException("no children");
       return cartoonCharacter.getChildren();
-    })).withMessage("no children");
+    }), RuntimeException.class);
+    // THEN
+    then(runtimeException).hasMessage("no children");
   }
 
   @Test
   void should_allow_assertions_on_joined_lists_when_extracting_children_with_throwing_extractor() {
-    List<CartoonCharacter> cartoonCharacters = newArrayList(homer, fred);
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer, fred);
+    // WHEN/THEN
     assertThat(cartoonCharacters).flatExtracting(cartoonCharacter -> {
       if (cartoonCharacter.getChildren().isEmpty()) throw new Exception("no children");
       return cartoonCharacter.getChildren();
@@ -146,7 +173,9 @@ class IterableAssert_flatExtracting_Test {
 
   @Test
   void should_allow_assertions_on_joined_lists_when_extracting_children_with_anonymous_class_throwing_extractor() {
-    List<CartoonCharacter> cartoonCharacters = newArrayList(homer, fred);
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer, fred);
+    // WHEN/THEN
     assertThat(cartoonCharacters).flatExtracting(new ThrowingExtractor<CartoonCharacter, List<CartoonCharacter>, Exception>() {
       @Override
       public List<CartoonCharacter> extractThrows(CartoonCharacter cartoonCharacter) throws Exception {
@@ -158,55 +187,78 @@ class IterableAssert_flatExtracting_Test {
 
   @Test
   void should_keep_existing_description_if_set_when_extracting_using_extractor() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(newArrayList(homer)).as("expected description")
-                                                                                                    .flatExtracting(childrenExtractor)
-                                                                                                    .isEmpty())
-                                                   .withMessageContaining("[expected description]");
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatExtracting(childrenExtractor)
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
   }
 
   @Test
   void should_keep_existing_description_if_set_when_extracting_using_function() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(newArrayList(homer)).as("expected description")
-                                                                                                    .flatExtracting(children)
-                                                                                                    .isEmpty())
-                                                   .withMessageContaining("[expected description]");
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatExtracting(children)
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
   }
 
   @Test
   void should_keep_existing_description_if_set_when_extracting_using_single_field_name() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(newArrayList(homer)).as("expected description")
-                                                                                                    .flatExtracting("children")
-                                                                                                    .isEmpty())
-                                                   .withMessageContaining("[expected description]");
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatExtracting("children")
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
   }
 
   @Test
   void should_keep_existing_description_if_set_when_extracting_using_multiple_field_names() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(newArrayList(homer)).as("expected description")
-                                                                                                    .flatExtracting("children",
-                                                                                                                    "name")
-                                                                                                    .isEmpty())
-                                                   .withMessageContaining("[expected description]");
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatExtracting("children", "name")
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
   }
 
   @Test
   void should_keep_existing_description_if_set_when_extracting_using_multiple_function_varargs() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(newArrayList(homer)).as("expected description")
-                                                                                                    .flatExtracting(children,
-                                                                                                                    children)
-                                                                                                    .isEmpty())
-                                                   .withMessageContaining("[expected description]");
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatExtracting(children, children)
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
   }
 
   @Test
   void should_keep_existing_description_if_set_when_extracting_using_multiple_throwing_extractors_varargs() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(newArrayList(homer)).as("expected description")
-                                                                                                    .flatExtracting(throwingExtractor,
-                                                                                                                    throwingExtractor)
-                                                                                                    .isEmpty())
-                                                   .withMessageContaining("[expected description]");
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatExtracting(throwingExtractor,
+                                                                                                            throwingExtractor)
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void flatExtracting_should_keep_assertion_state_with_extractor() {
     // GIVEN
@@ -215,7 +267,7 @@ class IterableAssert_flatExtracting_Test {
     // not all comparators are used but we want to test that they are passed correctly after extracting
     // @format:off
     AbstractListAssert<?, ?, ?, ?> assertion
-            = assertThat(newArrayList(homer, fred)).as("test description")
+            = assertThat(list(homer, fred)).as("test description")
                                                    .withFailMessage("error message")
                                                    .withRepresentation(UNICODE_REPRESENTATION)
                                                    .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING, "foo")
@@ -225,14 +277,15 @@ class IterableAssert_flatExtracting_Test {
                                                    .contains(bart, lisa, new CartoonCharacter("Unknown"));
     // @format:on
     // THEN
-    assertThat(assertion.descriptionText()).isEqualTo("test description");
-    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
-    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
-    assertThat(comparatorsByTypeOf(assertion).get(CartoonCharacter.class)).isSameAs(cartoonCharacterAlwaysEqualComparator);
-    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
-    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+    then(assertion.descriptionText()).isEqualTo("test description");
+    then(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    then(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    then(comparatorsByTypeOf(assertion).get(CartoonCharacter.class)).isSameAs(cartoonCharacterAlwaysEqualComparator);
+    then(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    then(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void flatExtracting_should_keep_assertion_state() {
     // GIVEN
@@ -241,7 +294,7 @@ class IterableAssert_flatExtracting_Test {
     // not all comparators are used but we want to test that they are passed correctly after extracting
     // @format:off
     AbstractListAssert<?, ?, ?, ?> assertion
-            = assertThat(newArrayList(homer, fred)).as("test description")
+            = assertThat(list(homer, fred)).as("test description")
                                                    .withFailMessage("error message")
                                                    .withRepresentation(UNICODE_REPRESENTATION)
                                                    .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING, "foo")
@@ -251,14 +304,15 @@ class IterableAssert_flatExtracting_Test {
                                                    .contains(bart, lisa, new CartoonCharacter("Unknown"));
     // @format:on
     // THEN
-    assertThat(assertion.descriptionText()).isEqualTo("test description");
-    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
-    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
-    assertThat(comparatorsByTypeOf(assertion).get(CartoonCharacter.class)).isSameAs(cartoonCharacterAlwaysEqualComparator);
-    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
-    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+    then(assertion.descriptionText()).isEqualTo("test description");
+    then(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    then(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    then(comparatorsByTypeOf(assertion).get(CartoonCharacter.class)).isSameAs(cartoonCharacterAlwaysEqualComparator);
+    then(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    then(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void flatExtracting_with_ThrowingExtractor_should_keep_assertion_state() {
     // GIVEN
@@ -267,7 +321,7 @@ class IterableAssert_flatExtracting_Test {
     // not all comparators are used but we want to test that they are passed correctly after extracting
     // @format:off
     AbstractListAssert<?, ?, ?, ?> assertion
-           = assertThat(newArrayList(homer, fred)).as("test description")
+           = assertThat(list(homer, fred)).as("test description")
                                                   .withFailMessage("error message")
                                                   .withRepresentation(UNICODE_REPRESENTATION)
                                                   .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING, "foo")
@@ -277,12 +331,12 @@ class IterableAssert_flatExtracting_Test {
                                                   .contains(bart, lisa, new CartoonCharacter("Unknown"));
     // @format:on
     // THEN
-    assertThat(assertion.descriptionText()).isEqualTo("test description");
-    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
-    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
-    assertThat(comparatorsByTypeOf(assertion).get(CartoonCharacter.class)).isSameAs(cartoonCharacterAlwaysEqualComparator);
-    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
-    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+    then(assertion.descriptionText()).isEqualTo("test description");
+    then(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    then(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    then(comparatorsByTypeOf(assertion).get(CartoonCharacter.class)).isSameAs(cartoonCharacterAlwaysEqualComparator);
+    then(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    then(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_with_multiple_extractors_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_with_multiple_extractors_Test.java
index 13150651f..a2e90b1dc 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_with_multiple_extractors_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatExtracting_with_multiple_extractors_Test.java
@@ -15,6 +15,7 @@ package org.assertj.core.api.iterable;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithNamesOf;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithTypeOf;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorsByTypeOf;
@@ -26,6 +27,7 @@ import static org.assertj.core.data.TolkienCharacter.Race.MAN;
 import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TIMESTAMP;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 
 import java.sql.Timestamp;
 import java.util.ArrayList;
@@ -71,45 +73,60 @@ class IterableAssert_flatExtracting_with_multiple_extractors_Test {
                                    .contains(33, "Frodo", 38, "Sam");
   }
 
+  @Test
+  void should_throw_assertion_error_if_actual_is_null() {
+    // GIVEN
+    List<TolkienCharacter> hobbits = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(hobbits).flatExtracting(age, name));
+    // THEN
+    then(assertionError).hasMessageContaining("Expecting actual not to be null");
+  }
+
   @Test
   void should_throw_IllegalArgumentException_when_no_fields_or_properties_are_specified() {
-    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(fellowshipOfTheRing).flatExtracting(new String[0]));
+    // GIVEN
+    String[] fields = new String[0];
+    // WHEN/THEN
+    assertThatIllegalArgumentException().isThrownBy(() -> assertThat(fellowshipOfTheRing).flatExtracting(fields));
   }
 
   @Test
   void should_throw_IllegalArgumentException_when_null_fields_or_properties_vararg() {
+    // GIVEN
     String[] fields = null;
+    // WHEN/THEN
     assertThatIllegalArgumentException().isThrownBy(() -> assertThat(fellowshipOfTheRing).flatExtracting(fields));
   }
 
   @Test
   void should_throw_IllegalArgumentException_when_extracting_from_null() {
+    // GIVEN
     fellowshipOfTheRing.add(null);
+    // WHEN/THEN
     assertThatIllegalArgumentException().isThrownBy(() -> assertThat(fellowshipOfTheRing).flatExtracting("age", "name"));
   }
 
   @Test
   void should_throw_IllegalArgumentException_when_extracting_from_null_extractors() {
+    // GIVEN
     fellowshipOfTheRing.add(null);
+    // WHEN/THEN
     assertThatNullPointerException().isThrownBy(() -> assertThat(fellowshipOfTheRing).flatExtracting(age, name));
   }
 
   @Test
-  void should_allow_assertions_on_multiple_extracted_values_using_throwingextractor() {
+  void should_allow_assertions_on_multiple_extracted_values_using_throwing_extractor() {
     assertThat(fellowshipOfTheRing).flatExtracting(input -> {
-      if (input.getAge() < 20) {
-        throw new Exception("age < 20");
-      }
+      if (input.getAge() < 20) throw new Exception("age < 20");
       return input.getName();
     }, input2 -> {
-      if (input2.getAge() < 20) {
-        throw new Exception("age < 20");
-      }
+      if (input2.getAge() < 20) throw new Exception("age < 20");
       return input2.getAge();
-      }
-    ).contains(33, "Frodo", 38, "Sam");
+    }).contains(33, "Frodo", 38, "Sam");
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void flatExtracting_with_multiple_extractors_should_keep_assertion_state() {
     // WHEN
@@ -126,14 +143,15 @@ class IterableAssert_flatExtracting_with_multiple_extractors_Test {
                                                   .contains(33, "frodo", 38, "SAM");
     // @format:on
     // THEN
-    assertThat(assertion.descriptionText()).isEqualTo("test description");
-    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
-    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
-    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(CaseInsensitiveStringComparator.instance);
-    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
-    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+    then(assertion.descriptionText()).isEqualTo("test description");
+    then(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    then(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    then(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(CaseInsensitiveStringComparator.instance);
+    then(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    then(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void flatExtracting_with_multiple_ThrowingExtractors_should_keep_assertion_state() {
     // WHEN
@@ -150,11 +168,11 @@ class IterableAssert_flatExtracting_with_multiple_extractors_Test {
                                             .contains(33, "frodo", 38, "SAM");
     // @format:on
     // THEN
-    assertThat(assertion.descriptionText()).isEqualTo("test description");
-    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
-    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
-    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(CaseInsensitiveStringComparator.instance);
-    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
-    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
+    then(assertion.descriptionText()).isEqualTo("test description");
+    then(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    then(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    then(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(CaseInsensitiveStringComparator.instance);
+    then(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
+    then(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 }
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatMap_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatMap_Test.java
new file mode 100644
index 000000000..f1168946d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_flatMap_Test.java
@@ -0,0 +1,179 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+import java.util.function.Function;
+
+import org.assertj.core.api.AbstractIterableAssert;
+import org.assertj.core.test.CartoonCharacter;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for <code>{@link AbstractIterableAssert#flatMap(Function)}</code>
+ *
+ * @author Mateusz Haligowski
+ */
+class IterableAssert_flatMap_Test {
+
+  private CartoonCharacter bart;
+  private CartoonCharacter lisa;
+  private CartoonCharacter maggie;
+  private CartoonCharacter homer;
+  private CartoonCharacter pebbles;
+  private CartoonCharacter fred;
+
+  private static final ThrowingExtractor<CartoonCharacter, List<CartoonCharacter>, Exception> childrenThrowingExtractor = CartoonCharacter::getChildren;
+
+  private static final Function<CartoonCharacter, List<CartoonCharacter>> children = CartoonCharacter::getChildren;
+
+  @BeforeEach
+  void setUp() {
+    bart = new CartoonCharacter("Bart Simpson");
+    lisa = new CartoonCharacter("Lisa Simpson");
+    maggie = new CartoonCharacter("Maggie Simpson");
+    homer = new CartoonCharacter("Homer Simpson");
+    homer.addChildren(bart, lisa, maggie);
+
+    pebbles = new CartoonCharacter("Pebbles Flintstone");
+    fred = new CartoonCharacter("Fred Flintstone");
+    fred.addChildren(pebbles);
+  }
+
+  @Test
+  void should_allow_assertions_on_joined_lists_when_extracting_children() {
+    assertThat(list(homer, fred)).flatMap(children)
+                                 .containsOnly(bart, lisa, maggie, pebbles);
+  }
+
+  @Test
+  void should_allow_assertions_on_empty_result_lists() {
+    assertThat(list(bart, lisa, maggie)).flatMap(children)
+                                        .isEmpty();
+  }
+
+  @Test
+  void should_throw_assertion_error_if_actual_is_null() {
+    // GIVEN
+    List<CartoonCharacter> simpsons = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(simpsons).flatMap(children));
+    // THEN
+    then(assertionError).hasMessage("Expecting actual not to be null");
+  }
+
+  @Test
+  void should_bubble_up_null_pointer_exception_from_lambda_extractor() {
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer, null);
+    // WHEN/THEN
+    assertThatNullPointerException().isThrownBy(() -> assertThat(cartoonCharacters).flatMap(children));
+  }
+
+  @Test
+  void should_rethrow_throwing_extractor_checked_exception_as_a_runtime_exception() {
+    // GIVEN
+    List<CartoonCharacter> childCharacters = list(bart, lisa, maggie);
+    // WHEN
+    RuntimeException runtimeException = catchThrowableOfType(() -> assertThat(childCharacters).flatMap(cartoonCharacter -> {
+      if (cartoonCharacter.getChildren().isEmpty()) throw new Exception("no children");
+      return cartoonCharacter.getChildren();
+    }), RuntimeException.class);
+    // THEN
+    then(runtimeException).hasMessage("java.lang.Exception: no children");
+  }
+
+  @Test
+  void should_let_throwing_extractor_runtime_exception_bubble_up() {
+    // GIVEN
+    List<CartoonCharacter> childCharacters = list(bart, lisa, maggie);
+    // WHEN
+    RuntimeException runtimeException = catchThrowableOfType(() -> assertThat(childCharacters).flatMap(cartoonCharacter -> {
+      if (cartoonCharacter.getChildren().isEmpty()) throw new RuntimeException("no children");
+      return cartoonCharacter.getChildren();
+    }), RuntimeException.class);
+    // THEN
+    then(runtimeException).hasMessage("no children");
+  }
+
+  @Test
+  void should_allow_assertions_on_joined_lists_when_extracting_children_with_throwing_extractor() {
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer, fred);
+    // WHEN/THEN
+    assertThat(cartoonCharacters).flatMap(cartoonCharacter -> {
+      if (cartoonCharacter.getChildren().isEmpty()) throw new Exception("no children");
+      return cartoonCharacter.getChildren();
+    }).containsOnly(bart, lisa, maggie, pebbles);
+  }
+
+  @Test
+  void should_allow_assertions_on_joined_lists_when_extracting_children_with_anonymous_class_throwing_extractor() {
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer, fred);
+    // WHEN/THEN
+    assertThat(cartoonCharacters).flatMap(new ThrowingExtractor<CartoonCharacter, List<CartoonCharacter>, Exception>() {
+      @Override
+      public List<CartoonCharacter> extractThrows(CartoonCharacter cartoonCharacter) throws Exception {
+        if (cartoonCharacter.getChildren().isEmpty()) throw new Exception("no children");
+        return cartoonCharacter.getChildren();
+      }
+    }).containsOnly(bart, lisa, maggie, pebbles);
+  }
+
+  @Test
+  void should_keep_existing_description_if_set_when_extracting_using_function() {
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatMap(children)
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
+  }
+
+  @Test
+  void should_keep_existing_description_if_set_when_extracting_using_multiple_function_varargs() {
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatMap(children, children)
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
+  }
+
+  @Test
+  void should_keep_existing_description_if_set_when_extracting_using_multiple_throwing_extractors_varargs() {
+    // GIVEN
+    List<CartoonCharacter> cartoonCharacters = list(homer);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(cartoonCharacters).as("expected description")
+                                                                                            .flatMap(childrenThrowingExtractor,
+                                                                                                     childrenThrowingExtractor)
+                                                                                            .isEmpty());
+    // THEN
+    then(assertionError).hasMessageContaining("[expected description]");
+  }
+
+}
