diff --git a/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java b/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
index adf62a256..d4d43befe 100644
--- a/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
@@ -15,6 +15,7 @@ package org.assertj.core.internal;
 import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
 import static org.assertj.core.util.IterableUtil.isNullOrEmpty;
 
+import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.Set;
@@ -94,10 +95,15 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   @SuppressWarnings("unchecked")
   public void iterableRemoves(Iterable<?> iterable, Object value) {
     if (iterable == null) return;
-    Iterator<?> iterator = iterable.iterator();
-    while (iterator.hasNext()) {
-      if (comparator.compare(iterator.next(), value) == 0) {
-        iterator.remove();
+    // Avoid O(N^2) complexity of serial removal from an iterator of collections like ArrayList
+    if (iterable instanceof Collection) {
+      ((Collection<?>) iterable).removeIf(o -> comparator.compare(o, value) == 0);
+    } else {
+      Iterator<?> iterator = iterable.iterator();
+      while (iterator.hasNext()) {
+        if (comparator.compare(iterator.next(), value) == 0) {
+          iterator.remove();
+        }
       }
     }
   }
diff --git a/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java b/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
index 03bbd80b8..b91828086 100644
--- a/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
@@ -14,6 +14,7 @@ package org.assertj.core.internal;
 
 import static org.assertj.core.util.Preconditions.checkArgument;
 
+import java.util.Collection;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
@@ -102,10 +103,15 @@ public class StandardComparisonStrategy extends AbstractComparisonStrategy {
     if (iterable == null) {
       return;
     }
-    Iterator<?> iterator = iterable.iterator();
-    while (iterator.hasNext()) {
-      if (areEqual(iterator.next(), value)) {
-        iterator.remove();
+    // Avoid O(N^2) complexity of serial removal from an iterator of collections like ArrayList
+    if (iterable instanceof Collection) {
+      ((Collection<?>) iterable).removeIf(o -> areEqual(o, value));
+    } else {
+      Iterator<?> iterator = iterable.iterator();
+      while (iterator.hasNext()) {
+        if (areEqual(iterator.next(), value)) {
+          iterator.remove();
+        }
       }
     }
   }
diff --git a/src/test/java/org/assertj/core/perf/ContainsOnlyPerfTest.java b/src/test/java/org/assertj/core/perf/ContainsOnlyPerfTest.java
new file mode 100644
index 000000000..95a7fb74d
--- /dev/null
+++ b/src/test/java/org/assertj/core/perf/ContainsOnlyPerfTest.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.perf;
+
+import static java.lang.Boolean.FALSE;
+import static java.lang.Boolean.TRUE;
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.ArrayList;
+import java.util.concurrent.ThreadLocalRandom;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.Timeout;
+
+/**
+ * See https://github.com/joel-costigliola/assertj-core/issues/1718.
+ *
+ * This test ensures assertThat(list_of_1m_elements).containsOnly(...) is an O(N) rather than O(N^2)
+ * operation. Given that the list has 1 million elements, O(N^2) is O(1000 billion), which should
+ * take from several dozens to several thousands seconds, given that the constant in the actual
+ * complexity is low (which indeed is, in case of ArrayList, where the main contributor to the time
+ * consumed by the operation is System.arraycopy()). O(N) is O(1 million), which should take perhaps
+ * from one to a hundred milliseconds, depending on the frequency of the test machine, the JVM
+ * version used, etc.
+ * <p>
+ * Therefore, 5 seconds (the limit used in the tests below) seems to be a good threshold that would
+ * clearly distinguish .containsOnly(...) being O(N) or O(N^2) on any test agent, thus preventing
+ * a regression of .containsOnly(...) back to O(N^2) complexity.
+ */
+public class ContainsOnlyPerfTest {
+
+  @Test
+  @Timeout(value = 5)
+  public void test_containsOnly_1mElements() {
+    final ArrayList<Object> objects = new ArrayList<>();
+    for (int i = 0; i < 1_000_000; i++) {
+      objects.add(ThreadLocalRandom.current().nextBoolean());
+    }
+    assertThat(objects).containsOnly(TRUE, FALSE);
+  }
+
+  @Test
+  @Timeout(value = 5)
+  public void test_containsOnly_1mElements_usingCustomComparator() {
+    final ArrayList<Integer> objects = new ArrayList<>();
+    for (int i = 0; i < 1_000_000; i++) {
+      objects.add(ThreadLocalRandom.current().nextInt(2));
+    }
+    assertThat(objects).usingElementComparator(Integer::compare)
+                       .containsOnly(0, 1);
+  }
+}
