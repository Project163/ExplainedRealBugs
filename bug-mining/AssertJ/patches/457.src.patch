diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java b/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
index 8444e0136..c97446056 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
@@ -16,6 +16,7 @@ import static java.util.Collections.emptyList;
 import static java.util.Collections.unmodifiableList;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.joining;
+import static org.assertj.core.util.Lists.list;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -36,12 +37,16 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     pathToUseInRules = pathToUseInRules(decomposedPath);
   }
 
-  boolean matches(String fieldPath) {
-    return pathToUseInRules.equals(fieldPath);
+  public FieldLocation(String s) {
+    this(list(s.split("\\.")));
   }
 
-  boolean startsWith(String fieldPath) {
-    return pathToUseInRules.startsWith(fieldPath);
+  boolean matches(FieldLocation field) {
+    return pathToUseInRules.equals(field.pathToUseInRules);
+  }
+
+  boolean matches(String fieldPath) {
+    return pathToUseInRules.equals(fieldPath);
   }
 
   public List<String> getDecomposedPath() {
@@ -82,6 +87,10 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     return String.format("FieldLocation [pathToUseInRules=%s, decomposedPath=%s]", pathToUseInRules, decomposedPath);
   }
 
+  public String shortDescription() {
+    return pathToUseInRules;
+  }
+
   private static String pathToUseInRules(List<String> path) {
     // remove the array subpath, so person.children.[2].name -> person.children.name
     // rules for ignoring fields don't apply at the element level (ex: children.[2]) but at the group level (ex: children).
@@ -99,4 +108,52 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     return new FieldLocation(emptyList());
   }
 
+  /**
+   * Returns true if this has the given parent (direct or indirect), false otherwise.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> | field                 | parent       | hasParent? 
+   * -----------------------------------------------  
+   * | "name.first"          | "name"       | true       
+   * | "name.first.nickname" | "name"       | true       
+   * | "name.first.nickname" | "name.first" | true       
+   * | "name"                | "name"       | false      
+   * | "names"               | "name"       | false      
+   * | "nickname"            | "name"       | false      
+   * | "name"                | "nickname"   | false      
+   * | "first.nickname"      | "name"       | false      
+   * </code></pre>
+   *  
+   * @param parent the field to check for being a parent
+   * @return true if this has the given parent (direct or indirect), false otherwise.
+   */
+  public boolean hasParent(FieldLocation parent) {
+    // "." garantees that we compare path elements, this avoid making "name" a parent of "names"
+    return pathToUseInRules.startsWith(parent.pathToUseInRules + ".");
+  }
+
+  /**
+   * Returns true if this field has the given child (direct or indirect), false otherwise.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> | field                 | child           | hasChild? 
+   * -----------------------------------------------  
+   * | "name"                | "name.first"    | true       
+   * | "name"                | "name.last"     | true       
+   * | "one"                 | "one.two.three" | true
+   * | "name.first"          | "name "         | false       
+   * | "name"                | "name"          | false      
+   * | "names"               | "name"          | false      
+   * | "nickname"            | "name"          | false      
+   * | "name"                | "nickname"      | false      
+   * | "first.nickname"      | "name"          | false      
+   * </code></pre>
+   *  
+   * @param child the field to check for being a child
+   * @return true if this has the given child (direct or indirect), false otherwise.
+   */
+  public boolean hasChild(FieldLocation child) {
+    return child.hasParent(this);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 1ef8961ae..35926cad4 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -60,7 +60,7 @@ public class RecursiveComparisonConfiguration {
   private Set<Class<?>> ignoredTypes = new LinkedHashSet<>();
 
   // fields to compare (no other field will be)
-  private Set<String> comparedFields = new LinkedHashSet<>();
+  private Set<FieldLocation> comparedFields = new LinkedHashSet<>();
 
   // overridden equals method to ignore section
   private List<Class<?>> ignoredOverriddenEqualsForTypes = new ArrayList<>();
@@ -233,8 +233,7 @@ public class RecursiveComparisonConfiguration {
    * @param fieldNamesToCompare the fields of the object under test to compare in the comparison.
    */
   public void compareOnlyFields(String... fieldNamesToCompare) {
-    List<String> fieldLocations = list(fieldNamesToCompare);
-    comparedFields.addAll(fieldLocations);
+    Stream.of(fieldNamesToCompare).map(FieldLocation::new).forEach(comparedFields::add);
   }
 
   /**
@@ -292,7 +291,7 @@ public class RecursiveComparisonConfiguration {
    *
    * @return the set of fields from the object under test to compare.
    */
-  public Set<String> getComparedFields() {
+  public Set<FieldLocation> getComparedFields() {
     return comparedFields;
   }
 
@@ -655,12 +654,13 @@ public class RecursiveComparisonConfiguration {
     return comparedFields.stream().anyMatch(matchesComparedField(fieldLocation));
   }
 
-  private static Predicate<String> matchesComparedField(FieldLocation field) {
+  private static Predicate<FieldLocation> matchesComparedField(FieldLocation field) {
     // a field f must be compared if any compared fields is f itself (obviously), a parent of f or a child of f.
-    // Examples:
-    // - "name.first" must be compared if "name" is a compared field (alongwith any other "name" subfields as "name.last")
-    // - "name" must be compared if "name.first" is a compared field otherwise "name" is ignored and "name.first" never evaluated
-    return fieldToCompare -> field.startsWith(fieldToCompare) || fieldToCompare.startsWith(field.getPathToUseInRules());
+    // - "name.first" must be compared if "name" is a compared field so will other "name" subfields like "name.last"
+    // - "name" must be compared if "name.first" is a compared field otherwise "name" is ignored and "name.first" too
+    return comparedField -> field.matches(comparedField) // exact match
+                            || field.hasParent(comparedField) // ex: field "name.first" and "name" compared field
+                            || field.hasChild(comparedField); // ex: field "name" and "name.first" compared field
   }
 
   Set<String> getNonIgnoredActualFieldNames(DualValue dualValue) {
@@ -765,8 +765,7 @@ public class RecursiveComparisonConfiguration {
 
   private void describeIgnoreAllActualEmptyOptionalFields(StringBuilder description) {
     if (getIgnoreAllActualEmptyOptionalFields())
-      description.append(format(
-          "- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n"));
+      description.append(format("- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n"));
   }
 
   private void describeIgnoreAllExpectedNullFields(StringBuilder description) {
@@ -821,9 +820,8 @@ public class RecursiveComparisonConfiguration {
 
   private void describeIgnoredCollectionOrderInFieldsMatchingRegexes(StringBuilder description) {
     if (!ignoredCollectionOrderInFieldsMatchingRegexes.isEmpty())
-      description.append(
-          format("- collection order was ignored in the fields matching the following regexes in the comparison: %s%n",
-                 describeRegexes(ignoredCollectionOrderInFieldsMatchingRegexes)));
+      description.append(format("- collection order was ignored in the fields matching the following regexes in the comparison: %s%n",
+                                describeRegexes(ignoredCollectionOrderInFieldsMatchingRegexes)));
   }
 
   private boolean matchesAnIgnoredOverriddenEqualsRegex(Class<?> clazz) {
@@ -884,7 +882,7 @@ public class RecursiveComparisonConfiguration {
   }
 
   private String describeComparedFields() {
-    return join(comparedFields);
+    return join(comparedFields.stream().map(FieldLocation::shortDescription).collect(toList()));
   }
 
   private String describeIgnoredTypes() {
@@ -1008,7 +1006,7 @@ public class RecursiveComparisonConfiguration {
     private boolean ignoreAllActualEmptyOptionalFields;
     private boolean ignoreAllExpectedNullFields;
     private String[] ignoredFields = {};
-    private String[] comparedFields = {};
+    private FieldLocation[] comparedFields = {};
     private String[] ignoredFieldsMatchingRegexes = {};
     private Class<?>[] ignoredTypes = {};
     private Class<?>[] ignoredOverriddenEqualsForTypes = {};
@@ -1102,7 +1100,7 @@ public class RecursiveComparisonConfiguration {
      * @return this builder.
      */
     public Builder withComparedFields(String... fieldsToCompare) {
-      this.comparedFields = fieldsToCompare;
+      this.comparedFields = Stream.of(fieldsToCompare).map(FieldLocation::new).toArray(FieldLocation[]::new);
       return this;
     }
 
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_Test.java
index 26d3e7ce9..c1c8a2336 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_Test.java
@@ -56,4 +56,20 @@ class FieldLocation_Test {
     then(result).isEqualTo("FieldLocation [pathToUseInRules=location, decomposedPath=[location]]");
   }
 
+  @Test
+  void should_build_from_string_simple_path() {
+    // WHEN
+    FieldLocation underTest = new FieldLocation("name");
+    // THEN
+    then(underTest.getDecomposedPath()).isEqualTo(list("name"));
+  }
+
+  @Test
+  void should_build_from_string_nested_path() {
+    // WHEN
+    FieldLocation underTest = new FieldLocation("name.first.second");
+    // THEN
+    then(underTest.getDecomposedPath()).isEqualTo(list("name", "first", "second"));
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_startsWith_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasChild_Test.java
similarity index 54%
rename from src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_startsWith_Test.java
rename to src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasChild_Test.java
index e090bf3f6..b52a20228 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_startsWith_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasChild_Test.java
@@ -23,25 +23,44 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
-class FieldLocation_startsWith_Test {
+class FieldLocation_hasChild_Test {
 
-  @ParameterizedTest(name = "{0} matches {1}")
-  @MethodSource
-  void startsWith_should_match_fields_starting_with_given_field_path(List<String> fieldPath, String startFieldPath) {
+  @ParameterizedTest(name = "{0} hasChild {1}")
+  @MethodSource("hasChild")
+  void hasChild_should_return_true(List<String> fieldPath, String child) {
     // GIVEN
-    FieldLocation underTest = new FieldLocation(fieldPath);
+    FieldLocation field = new FieldLocation(fieldPath);
     // WHEN
-    boolean match = underTest.startsWith(startFieldPath);
+    boolean result = field.hasChild(new FieldLocation(child));
     // THEN
-    then(match).as("%s starts with %s", underTest, startFieldPath).isTrue();
+    then(result).as("%s hasChild <%s>", field, child).isTrue();
   }
 
-  private static Stream<Arguments> startsWith_should_match_fields_starting_with_given_field_path() {
-    return Stream.of(arguments(list("name"), "name"),
-                     arguments(list("name", "first"), "name"),
+  private static Stream<Arguments> hasChild() {
+    return Stream.of(arguments(list("name"), "name.first"),
+                     arguments(list("name"), "name.first.second"),
+                     arguments(list("one"), "one.two.three"),
+                     arguments(list("name", "first"), "name.first.second"),
+                     arguments(list("name", "[2]", "first"), "name.first.second"));
+  }
+
+  @ParameterizedTest(name = "{0} does not have child {1}")
+  @MethodSource("notChild")
+  void hasChild_should_return_false(List<String> fieldPath, String other) {
+    // GIVEN
+    FieldLocation field = new FieldLocation(fieldPath);
+    // WHEN
+    boolean result = field.hasChild(new FieldLocation(other));
+    // THEN
+    then(result).as("%s does not have child <%s>", field, other).isFalse();
+  }
+
+  private static Stream<Arguments> notChild() {
+    return Stream.of(arguments(list("defaultRole"), "defaultRoleName"),
+                     arguments(list("name"), "name"),
                      arguments(list("name", "first"), "name.first"),
+                     arguments(list("name", "first"), "name"),
                      arguments(list("name", "[2]", "first"), "name"),
-                     arguments(list("name", "[2]", "first"), "name.first"),
                      arguments(list("person", "[1]", "first", "second"), "person.first"),
                      arguments(list("father", "name", "first"), "father"));
   }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasParent_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasParent_Test.java
new file mode 100644
index 000000000..744f065fd
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_hasParent_Test.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.List;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class FieldLocation_hasParent_Test {
+
+  @ParameterizedTest(name = "{0} hasParent {1}")
+  @MethodSource("hasParent")
+  void hasParent_should_return_true(List<String> fieldPath, String parent) {
+    // GIVEN
+    FieldLocation field = new FieldLocation(fieldPath);
+    // WHEN
+    boolean result = field.hasParent(new FieldLocation(parent));
+    // THEN
+    then(result).as("%s hasParent <%s>", field, parent).isTrue();
+  }
+
+  private static Stream<Arguments> hasParent() {
+    return Stream.of(arguments(list("name", "first"), "name"),
+                     arguments(list("name", "[2]", "first"), "name"),
+                     arguments(list("person", "[1]", "first", "second"), "person.first"),
+                     arguments(list("father", "name", "first"), "father"));
+  }
+
+  @ParameterizedTest(name = "{0} does not have parent {1}")
+  @MethodSource("notParent")
+  void hasParent_should_return_false(List<String> fieldPath, String parent) {
+    // GIVEN
+    FieldLocation field = new FieldLocation(fieldPath);
+    // WHEN
+    boolean result = field.hasParent(new FieldLocation(parent));
+    // THEN
+    then(result).as("%s does not have parent <%s>", field, parent).isFalse();
+  }
+
+  private static Stream<Arguments> notParent() {
+    return Stream.of(arguments(list("defaultRole"), "defaultRoleName"),
+                     arguments(list("name"), "name"),
+                     arguments(list("name"), "name.first"),
+                     arguments(list("name", "[2]", "first"), "name.first"),
+                     arguments(list("person", "first"), "person.first.second"),
+                     arguments(list("father"), "father.name.first"));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_matches_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_matches_Test.java
index 12b1e2c01..f711e8994 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_matches_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/FieldLocation_matches_Test.java
@@ -27,7 +27,7 @@ class FieldLocation_matches_Test {
 
   @ParameterizedTest(name = "{0} matches {1}")
   @MethodSource
-  void matches_should_match_fields(List<String> fieldPath, String matchingFieldPath) {
+  void matches_should_match_string_fields(List<String> fieldPath, String matchingFieldPath) {
     // GIVEN
     FieldLocation underTest = new FieldLocation(fieldPath);
     // WHEN
@@ -36,6 +36,27 @@ class FieldLocation_matches_Test {
     then(match).as("%s matches %s", underTest, matchingFieldPath).isTrue();
   }
 
+  private static Stream<Arguments> matches_should_match_string_fields() {
+    return Stream.of(arguments(list("name"), "name"),
+                     arguments(list("name", "first"), "name.first"),
+                     arguments(list("name", "[2]", "first"), "name.first"),
+                     arguments(list("[0]", "first"), "first"),
+                     arguments(list("[1]", "first", "second"), "first.second"),
+                     arguments(list("person", "[1]", "first", "second"), "person.first.second"),
+                     arguments(list("father", "name", "first"), "father.name.first"));
+  }
+
+  @ParameterizedTest(name = "{0} matches {1}")
+  @MethodSource
+  void matches_should_match_fields(List<String> fieldPath, String matchingFieldPath) {
+    // GIVEN
+    FieldLocation underTest = new FieldLocation(fieldPath);
+    // WHEN
+    boolean match = underTest.matches(new FieldLocation(matchingFieldPath));
+    // THEN
+    then(match).as("%s matches %s", underTest, matchingFieldPath).isTrue();
+  }
+
   private static Stream<Arguments> matches_should_match_fields() {
     return Stream.of(arguments(list("name"), "name"),
                      arguments(list("name", "first"), "name.first"),
@@ -43,6 +64,7 @@ class FieldLocation_matches_Test {
                      arguments(list("[0]", "first"), "first"),
                      arguments(list("[1]", "first", "second"), "first.second"),
                      arguments(list("person", "[1]", "first", "second"), "person.first.second"),
+                     arguments(list("person", "[1]", "first", "second"), "person.[2].first.second"),
                      arguments(list("father", "name", "first"), "father.name.first"));
   }
 
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
index 04c804968..e67c75417 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
@@ -16,6 +16,7 @@ import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 
+import java.time.ZonedDateTime;
 import java.util.Date;
 import java.util.List;
 import java.util.stream.Stream;
@@ -151,4 +152,51 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends Recur
     return list.toArray(new String[0]);
   }
 
+  @SuppressWarnings("unused")
+  static class Staff {
+
+    private Boolean deleted;
+    private ZonedDateTime deletedAt;
+    private String defaultRole;
+    private String defaultRoleName;
+
+    void setDeleted(Boolean deleted) {
+      this.deleted = deleted;
+    }
+
+    void setDeletedAt(ZonedDateTime deletedAt) {
+      this.deletedAt = deletedAt;
+    }
+
+    void setDefaultRole(String defaultRole) {
+      this.defaultRole = defaultRole;
+    }
+
+    void setDefaultRoleName(String defaultRoleName) {
+      this.defaultRoleName = defaultRoleName;
+    }
+
+  }
+
+  // #2359
+  @Test
+  void should_not_compare_given_fields_starting_with_given_name_but_fully_matching_name() {
+    // GIVEN
+    Staff actual = new Staff();
+    actual.setDeleted(true);
+    actual.setDeletedAt(ZonedDateTime.parse("2021-10-05T04:21:05.863+00:00"));
+    actual.setDefaultRole("MANAGER");
+    actual.setDefaultRoleName("MANAGER");
+    Staff expected = new Staff();
+    expected.setDeleted(true);
+    expected.setDeletedAt(null);
+    expected.setDefaultRole("MANAGER");
+    expected.setDefaultRoleName("UX MANAGER");
+    // WHEN/THEN
+    // defaultRoleName or deletedAt should not be compared.
+    then(actual).usingRecursiveComparison()
+                .comparingOnlyFields("defaultRole", "deleted")
+                .isEqualTo(expected);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
index 08a154771..ffed100a3 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
@@ -115,7 +115,7 @@ class RecursiveComparisonConfiguration_builder_Test {
     // WHEN
     RecursiveComparisonConfiguration configuration = configBuilder().withComparedFields(values).build();
     // THEN
-    then(configuration.getComparedFields()).containsExactly(values);
+    then(configuration.getComparedFields()).containsExactly(new FieldLocation("foo"), new FieldLocation("bar"));
   }
 
   @Test
