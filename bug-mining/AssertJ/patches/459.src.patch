diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index 1870a2b45..e8c2e6bc0 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -30,6 +30,13 @@ import java.util.OptionalInt;
 import java.util.OptionalLong;
 import java.util.SortedMap;
 import java.util.SortedSet;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.stream.Stream;
 
 // logically immutable
@@ -90,8 +97,20 @@ public final class DualValue {
   }
 
   public boolean isActualJavaType() {
-    if (actual == null) return false;
-    return actual.getClass().getName().startsWith("java.");
+    return isJavaType(actual);
+  }
+
+  public boolean isExpectedJavaType() {
+    return isJavaType(expected);
+  }
+
+  public boolean hasSomeJavaTypeValue() {
+    return isActualJavaType() || isExpectedJavaType();
+  }
+
+  private static boolean isJavaType(Object o) {
+    if (o == null) return false;
+    return o.getClass().getName().startsWith("java.");
   }
 
   public boolean isExpectedFieldAnArray() {
@@ -145,6 +164,62 @@ public final class DualValue {
     return expected instanceof Optional;
   }
 
+  public boolean isExpectedFieldAnAtomicReference() {
+    return expected instanceof AtomicReference;
+  }
+
+  public boolean isActualFieldAnAtomicReference() {
+    return actual instanceof AtomicReference;
+  }
+
+  public boolean isExpectedFieldAnAtomicReferenceArray() {
+    return expected instanceof AtomicReferenceArray;
+  }
+
+  public boolean isActualFieldAnAtomicReferenceArray() {
+    return actual instanceof AtomicReferenceArray;
+  }
+
+  public boolean isExpectedFieldAnAtomicInteger() {
+    return expected instanceof AtomicInteger;
+  }
+
+  public boolean isActualFieldAnAtomicInteger() {
+    return actual instanceof AtomicInteger;
+  }
+
+  public boolean isExpectedFieldAnAtomicIntegerArray() {
+    return expected instanceof AtomicIntegerArray;
+  }
+
+  public boolean isActualFieldAnAtomicIntegerArray() {
+    return actual instanceof AtomicIntegerArray;
+  }
+
+  public boolean isExpectedFieldAnAtomicLong() {
+    return expected instanceof AtomicLong;
+  }
+
+  public boolean isActualFieldAnAtomicLong() {
+    return actual instanceof AtomicLong;
+  }
+
+  public boolean isExpectedFieldAnAtomicLongArray() {
+    return expected instanceof AtomicLongArray;
+  }
+
+  public boolean isActualFieldAnAtomicLongArray() {
+    return actual instanceof AtomicLongArray;
+  }
+
+  public boolean isExpectedFieldAnAtomicBoolean() {
+    return expected instanceof AtomicBoolean;
+  }
+
+  public boolean isActualFieldAnAtomicBoolean() {
+    return actual instanceof AtomicBoolean;
+  }
+
   public boolean isActualFieldAMap() {
     return actual instanceof Map;
   }
@@ -220,9 +295,15 @@ public final class DualValue {
   }
 
   public boolean hasNoContainerValues() {
-    return !isContainer(actual) && !isContainer(expected);
+    return !isContainer(actual) && !isExpectedAContainer();
+  }
+
+  // TODO test
+  public boolean isExpectedAContainer() {
+    return isContainer(expected);
   }
 
+
   public boolean hasNoNullValues() {
     return actual != null && expected != null;
   }
@@ -231,6 +312,13 @@ public final class DualValue {
     return o instanceof Iterable ||
            o instanceof Map ||
            o instanceof Optional ||
+           o instanceof AtomicReference ||
+           o instanceof AtomicReferenceArray ||
+           o instanceof AtomicBoolean ||
+           o instanceof AtomicInteger ||
+           o instanceof AtomicIntegerArray ||
+           o instanceof AtomicLong ||
+           o instanceof AtomicLongArray ||
            isArray(o);
   }
 
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index b674b77ea..6cbfd795c 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -18,7 +18,6 @@ import static java.util.stream.Collectors.joining;
 import static org.assertj.core.api.recursive.comparison.ComparisonDifference.rootComparisonDifference;
 import static org.assertj.core.api.recursive.comparison.DualValue.DEFAULT_ORDERED_COLLECTION_TYPES;
 import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
-import static org.assertj.core.internal.Objects.getDeclaredFieldsIncludingInherited;
 import static org.assertj.core.internal.Objects.getFieldsNames;
 import static org.assertj.core.util.IterableUtil.sizeOf;
 import static org.assertj.core.util.IterableUtil.toCollection;
@@ -27,12 +26,10 @@ import static org.assertj.core.util.Sets.newHashSet;
 import static org.assertj.core.util.introspection.PropertyOrFieldSupport.COMPARISON;
 
 import java.lang.reflect.Array;
-import java.lang.reflect.Field;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Comparator;
-import java.util.HashSet;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
@@ -41,6 +38,13 @@ import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.stream.Stream;
 
 import org.assertj.core.internal.DeepDifference;
@@ -59,11 +63,11 @@ public class RecursiveComparisonDifferenceCalculator {
                                                               + describeOrderedCollectionTypes();
 
   private static final String VALUE_FIELD_NAME = "value";
+  private static final String ARRAY_FIELD_NAME = "array";
   private static final String STRICT_TYPE_ERROR = "the fields are considered different since the comparison enforces strict type check and %s is not a subtype of %s";
   private static final String DIFFERENT_SIZE_ERROR = "actual and expected values are %s of different size, actual size=%s when expected size=%s";
   private static final String MISSING_FIELDS = "%s can't be compared to %s as %s does not declare all %s fields, it lacks these: %s";
   private static final Map<Class<?>, Boolean> customEquals = new ConcurrentHashMap<>();
-  private static final Map<Class<?>, Boolean> customHash = new ConcurrentHashMap<>();
 
   private static class ComparisonState {
     // Not using a Set as we want to precisely track visited values, a set would remove duplicates
@@ -116,8 +120,10 @@ public class RecursiveComparisonDifferenceCalculator {
     private void initDualValuesToCompare(Object actual, Object expected, FieldLocation fieldLocation) {
       DualValue dualValue = new DualValue(fieldLocation, actual, expected);
       boolean mustCompareFieldsRecursively = mustCompareFieldsRecursively(dualValue);
-      if (dualValue.hasNoNullValues() && dualValue.hasNoContainerValues() && mustCompareFieldsRecursively) {
+      if (dualValue.hasNoNullValues() && mustCompareFieldsRecursively) {
         // disregard the equals method and start comparing fields
+        // TODO should fail if actual and expected don't have the same fields to compare (taking into account ignored/compared
+        // fields)
         Set<String> nonIgnoredActualFieldsNames = recursiveComparisonConfiguration.getNonIgnoredActualFieldNames(dualValue);
         if (!nonIgnoredActualFieldsNames.isEmpty()) {
           // fields to ignore are evaluated when adding their corresponding dualValues to dualValuesToCompare which filters
@@ -152,8 +158,10 @@ public class RecursiveComparisonDifferenceCalculator {
     }
 
     private boolean mustCompareFieldsRecursively(DualValue dualValue) {
+
       return !recursiveComparisonConfiguration.hasCustomComparator(dualValue)
-             && !shouldHonorOverriddenEquals(dualValue, recursiveComparisonConfiguration);
+             && !shouldHonorEquals(dualValue, recursiveComparisonConfiguration)
+             && dualValue.hasNoContainerValues();
     }
 
     private String getCustomErrorMessage(DualValue dualValue) {
@@ -271,7 +279,37 @@ public class RecursiveComparisonDifferenceCalculator {
         continue;
       }
 
-      if (shouldCompareDualValue(recursiveComparisonConfiguration, dualValue)) {
+      // compare Atomic types by value manually as they are container type and we can't use introspection in java 17+
+      if (dualValue.isExpectedFieldAnAtomicBoolean()) {
+        compareAtomicBoolean(dualValue, comparisonState);
+        continue;
+      }
+      if (dualValue.isExpectedFieldAnAtomicInteger()) {
+        compareAtomicInteger(dualValue, comparisonState);
+        continue;
+      }
+      if (dualValue.isExpectedFieldAnAtomicIntegerArray()) {
+        compareAtomicIntegerArray(dualValue, comparisonState);
+        continue;
+      }
+      if (dualValue.isExpectedFieldAnAtomicLong()) {
+        compareAtomicLong(dualValue, comparisonState);
+        continue;
+      }
+      if (dualValue.isExpectedFieldAnAtomicLongArray()) {
+        compareAtomicLongArray(dualValue, comparisonState);
+        continue;
+      }
+      if (dualValue.isExpectedFieldAnAtomicReference()) {
+        compareAtomicReference(dualValue, comparisonState);
+        continue;
+      }
+      if (dualValue.isExpectedFieldAnAtomicReferenceArray()) {
+        compareAtomicReferenceArray(dualValue, comparisonState);
+        continue;
+      }
+
+      if (shouldHonorEquals(dualValue, recursiveComparisonConfiguration)) {
         if (!actualFieldValue.equals(expectedFieldValue)) comparisonState.addDifference(dualValue);
         continue;
       }
@@ -314,12 +352,6 @@ public class RecursiveComparisonDifferenceCalculator {
     return comparisonState.getDifferences();
   }
 
-  private static boolean shouldCompareDualValue(RecursiveComparisonConfiguration recursiveComparisonConfiguration,
-                                                final DualValue dualValue) {
-    return !recursiveComparisonConfiguration.shouldIgnoreOverriddenEqualsOf(dualValue)
-           && hasOverriddenEquals(dualValue.actual.getClass());
-  }
-
   // avoid comparing enum recursively since they contain static fields which are ignored in recursive comparison
   // this would make different field enum value to be considered the same!
   private static void compareAsEnums(final DualValue dualValue,
@@ -341,6 +373,15 @@ public class RecursiveComparisonDifferenceCalculator {
     if (!actualEnum.name().equals(expectedEnum.name())) comparisonState.addDifference(dualValue);
   }
 
+  private static boolean shouldHonorEquals(DualValue dualValue,
+                                           RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
+    // since java 17 we can't introspect java types and get their fields so by default we compare them with equals
+    // unless for some container like java types: iterables, array, optional, atomic values where we take the contained values
+    // through accessors and register them in the recursive comparison.
+    boolean shouldHonorJavaTypeEquals = dualValue.hasSomeJavaTypeValue() && !dualValue.isExpectedAContainer();
+    return shouldHonorJavaTypeEquals || shouldHonorOverriddenEquals(dualValue, recursiveComparisonConfiguration);
+  }
+
   private static boolean shouldHonorOverriddenEquals(DualValue dualValue,
                                                      RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     boolean shouldNotIgnoreOverriddenEqualsIfAny = !recursiveComparisonConfiguration.shouldIgnoreOverriddenEqualsOf(dualValue);
@@ -540,129 +581,164 @@ public class RecursiveComparisonDifferenceCalculator {
     comparisonState.registerForComparison(new DualValue(dualValue.fieldLocation.field(VALUE_FIELD_NAME), value1, value2));
   }
 
-  /**
-   * Determine if the passed in class has a non-Object.equals() method. This
-   * method caches its results in static ConcurrentHashMap to benefit
-   * execution performance.
-   *
-   * @param c Class to check.
-   * @return true, if the passed in Class has a .equals() method somewhere
-   *         between itself and just below Object in it's inheritance.
-   */
-  static boolean hasOverriddenEquals(Class<?> c) {
-    if (customEquals.containsKey(c)) {
-      return customEquals.get(c);
+  private static void compareAtomicBoolean(DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isActualFieldAnAtomicBoolean()) {
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an AtomicBoolean"));
+      return;
     }
+    AtomicBoolean actual = (AtomicBoolean) dualValue.actual;
+    AtomicBoolean expected = (AtomicBoolean) dualValue.expected;
+    Object value1 = actual.get();
+    Object value2 = expected.get();
+    // we add VALUE_FIELD_NAME to the path since we register AtomicBoolean.value fields.
+    comparisonState.registerForComparison(new DualValue(dualValue.fieldLocation.field(VALUE_FIELD_NAME), value1, value2));
+  }
 
-    Class<?> origClass = c;
-    while (!Object.class.equals(c)) {
-      try {
-        c.getDeclaredMethod("equals", Object.class);
-        customEquals.put(origClass, true);
-        return true;
-      } catch (Exception ignored) {}
-      c = c.getSuperclass();
+  private static void compareAtomicInteger(DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isActualFieldAnAtomicInteger()) {
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an AtomicInteger"));
+      return;
     }
-    customEquals.put(origClass, false);
-    return false;
+    AtomicInteger actual = (AtomicInteger) dualValue.actual;
+    AtomicInteger expected = (AtomicInteger) dualValue.expected;
+    Object value1 = actual.get();
+    Object value2 = expected.get();
+    // we add VALUE_FIELD_NAME to the path since we register AtomicInteger.value fields.
+    comparisonState.registerForComparison(new DualValue(dualValue.fieldLocation.field(VALUE_FIELD_NAME), value1, value2));
   }
 
-  /**
-   * Get a deterministic hashCode (int) value for an Object, regardless of
-   * when it was created or where it was loaded into memory. The problem with
-   * java.lang.Object.hashCode() is that it essentially relies on memory
-   * location of an object (what identity it was assigned), whereas this
-   * method will produce the same hashCode for any object graph, regardless of
-   * how many times it is created.<br>
-   * <br>
-   *
-   * This method will handle cycles correctly (A-&gt;B-&gt;C-&gt;A). In this
-   * case, Starting with object A, B, or C would yield the same hashCode. If
-   * an object encountered (root, subobject, etc.) has a hashCode() method on
-   * it (that is not Object.hashCode()), that hashCode() method will be called
-   * and it will stop traversal on that branch.
-   *
-   * @param obj Object who hashCode is desired.
-   * @return the 'deep' hashCode value for the passed in object.
-   */
-  static int deepHashCode(Object obj) {
-    Set<Object> visited = new HashSet<>();
-    LinkedList<Object> stack = new LinkedList<>();
-    stack.addFirst(obj);
-    int hash = 0;
-
-    while (!stack.isEmpty()) {
-      obj = stack.removeFirst();
-      if (obj == null || visited.contains(obj)) {
-        continue;
-      }
+  private static void compareAtomicIntegerArray(DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isActualFieldAnAtomicIntegerArray()) {
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an AtomicIntegerArray"));
+      return;
+    }
+    AtomicIntegerArray actual = (AtomicIntegerArray) dualValue.actual;
+    AtomicIntegerArray expected = (AtomicIntegerArray) dualValue.expected;
 
-      visited.add(obj);
+    // both values in dualValue are arrays
+    int actualArrayLength = actual.length();
+    int expectedArrayLength = expected.length();
+    if (actualArrayLength != expectedArrayLength) {
+      comparisonState.addDifference(dualValue,
+                                    format(DIFFERENT_SIZE_ERROR, "AtomicIntegerArrays", actualArrayLength, expectedArrayLength));
+      // no need to inspect elements, arrays are not equal as they don't have the same size
+      return;
+    }
+    // register each pair of actual/expected elements for recursive comparison
+    FieldLocation arrayFieldLocation = dualValue.fieldLocation;
+    for (int i = 0; i < actualArrayLength; i++) {
+      Object actualElement = actual.get(i);
+      Object expectedElement = expected.get(i);
+      FieldLocation elementFieldLocation = arrayFieldLocation.field(format(ARRAY_FIELD_NAME + "[%d]", i));
+      comparisonState.registerForComparison(new DualValue(elementFieldLocation, actualElement, expectedElement));
+    }
+  }
 
-      if (obj.getClass().isArray()) {
-        int len = Array.getLength(obj);
-        for (int i = 0; i < len; i++) {
-          stack.addFirst(Array.get(obj, i));
-        }
-        continue;
-      }
+  private static void compareAtomicLong(DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isActualFieldAnAtomicLong()) {
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an AtomicLong"));
+      return;
+    }
+    AtomicLong actual = (AtomicLong) dualValue.actual;
+    AtomicLong expected = (AtomicLong) dualValue.expected;
+    Object value1 = actual.get();
+    Object value2 = expected.get();
+    // we add VALUE_FIELD_NAME to the path since we register AtomicLong.value fields.
+    comparisonState.registerForComparison(new DualValue(dualValue.fieldLocation.field(VALUE_FIELD_NAME), value1, value2));
+  }
 
-      if (obj instanceof Collection) {
-        stack.addAll(0, (Collection<?>) obj);
-        continue;
-      }
+  private static void compareAtomicLongArray(DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isActualFieldAnAtomicLongArray()) {
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an AtomicLongArray"));
+      return;
+    }
+    AtomicLongArray actual = (AtomicLongArray) dualValue.actual;
+    AtomicLongArray expected = (AtomicLongArray) dualValue.expected;
 
-      if (obj instanceof Map) {
-        stack.addAll(0, ((Map<?, ?>) obj).keySet());
-        stack.addAll(0, ((Map<?, ?>) obj).values());
-        continue;
-      }
+    // both values in dualValue are arrays
+    int actualArrayLength = actual.length();
+    int expectedArrayLength = expected.length();
+    if (actualArrayLength != expectedArrayLength) {
+      comparisonState.addDifference(dualValue,
+                                    format(DIFFERENT_SIZE_ERROR, "AtomicLongArrays", actualArrayLength, expectedArrayLength));
+      // no need to inspect elements, arrays are not equal as they don't have the same size
+      return;
+    }
+    // register each pair of actual/expected elements for recursive comparison
+    FieldLocation arrayFieldLocation = dualValue.fieldLocation;
+    for (int i = 0; i < actualArrayLength; i++) {
+      Object actualElement = actual.get(i);
+      Object expectedElement = expected.get(i);
+      FieldLocation elementFieldLocation = arrayFieldLocation.field(format(ARRAY_FIELD_NAME + "[%d]", i));
+      comparisonState.registerForComparison(new DualValue(elementFieldLocation, actualElement, expectedElement));
+    }
+  }
 
-      if (obj instanceof Double || obj instanceof Float) {
-        // just take the integral value for hashcode
-        // equality tests things more comprehensively
-        stack.add(Math.round(((Number) obj).doubleValue()));
-        continue;
-      }
+  private static void compareAtomicReferenceArray(DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isActualFieldAnAtomicReferenceArray()) {
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an AtomicReferenceArray"));
+      return;
+    }
+    AtomicReferenceArray<?> actual = (AtomicReferenceArray<?>) dualValue.actual;
+    AtomicReferenceArray<?> expected = (AtomicReferenceArray<?>) dualValue.expected;
 
-      if (hasCustomHashCode(obj.getClass())) {
-        // A real hashCode() method exists, call it.
-        hash += obj.hashCode();
-        continue;
-      }
+    // both values in dualValue are arrays
+    int actualArrayLength = actual.length();
+    int expectedArrayLength = expected.length();
+    if (actualArrayLength != expectedArrayLength) {
+      comparisonState.addDifference(dualValue,
+                                    format(DIFFERENT_SIZE_ERROR, "AtomicReferenceArrays", actualArrayLength,
+                                           expectedArrayLength));
+      // no need to inspect elements, arrays are not equal as they don't have the same size
+      return;
+    }
+    // register each pair of actual/expected elements for recursive comparison
+    FieldLocation arrayFieldLocation = dualValue.fieldLocation;
+    for (int i = 0; i < actualArrayLength; i++) {
+      Object actualElement = actual.get(i);
+      Object expectedElement = expected.get(i);
+      FieldLocation elementFieldLocation = arrayFieldLocation.field(format(ARRAY_FIELD_NAME + "[%d]", i));
+      comparisonState.registerForComparison(new DualValue(elementFieldLocation, actualElement, expectedElement));
+    }
+  }
 
-      Collection<Field> fields = getDeclaredFieldsIncludingInherited(obj.getClass());
-      for (Field field : fields) {
-        stack.addFirst(COMPARISON.getSimpleValue(field.getName(), obj));
-      }
+  private static void compareAtomicReference(DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isActualFieldAnAtomicReference()) {
+      comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an AtomicReference"));
+      return;
     }
-    return hash;
+    AtomicReference<?> actual = (AtomicReference<?>) dualValue.actual;
+    AtomicReference<?> expected = (AtomicReference<?>) dualValue.expected;
+    Object value1 = actual.get();
+    Object value2 = expected.get();
+    // we add VALUE_FIELD_NAME to the path since we register AtomicReference.value fields.
+    comparisonState.registerForComparison(new DualValue(dualValue.fieldLocation.field(VALUE_FIELD_NAME), value1, value2));
   }
 
   /**
-   * Determine if the passed in class has a non-Object.hashCode() method. This
+   * Determine if the passed in class has a non-Object.equals() method. This
    * method caches its results in static ConcurrentHashMap to benefit
    * execution performance.
    *
    * @param c Class to check.
-   * @return true, if the passed in Class has a .hashCode() method somewhere
+   * @return true, if the passed in Class has a .equals() method somewhere
    *         between itself and just below Object in it's inheritance.
    */
-  static boolean hasCustomHashCode(Class<?> c) {
-    Class<?> origClass = c;
-    if (customHash.containsKey(c)) {
-      return customHash.get(c);
+  static boolean hasOverriddenEquals(Class<?> c) {
+    if (customEquals.containsKey(c)) {
+      return customEquals.get(c);
     }
 
+    Class<?> origClass = c;
     while (!Object.class.equals(c)) {
       try {
-        c.getDeclaredMethod("hashCode");
-        customHash.put(origClass, true);
+        c.getDeclaredMethod("equals", Object.class);
+        customEquals.put(origClass, true);
         return true;
       } catch (Exception ignored) {}
       c = c.getSuperclass();
     }
-    customHash.put(origClass, false);
+    customEquals.put(origClass, false);
     return false;
   }
 
@@ -693,8 +769,7 @@ public class RecursiveComparisonDifferenceCalculator {
   }
 
   private static ComparisonDifference expectedAndActualTypeDifference(Object actual, Object expected) {
-    String additionalInformation = format(
-                                          "actual and expected are considered different since the comparison enforces strict type check and expected type %s is not a subtype of actual type %s",
+    String additionalInformation = format("actual and expected are considered different since the comparison enforces strict type check and expected type %s is not a subtype of actual type %s",
                                           expected.getClass().getName(), actual.getClass().getName());
     return rootComparisonDifference(actual, expected, additionalInformation);
   }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_atomicValues_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_atomicValues_Test.java
new file mode 100644
index 000000000..ef1e311a9
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_atomicValues_Test.java
@@ -0,0 +1,359 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.NullSource;
+import org.junit.jupiter.params.provider.ValueSource;
+
+class DualValue_atomicValues_Test {
+
+  private static final List<String> PATH = list("foo", "bar");
+
+  // AtomicReference
+
+  @Test
+  void isActualFieldAnAtomicReference_should_return_true_when_actual_is_an_AtomicReference() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, new AtomicReference<>("a"), "");
+    // WHEN
+    boolean isActualFieldAnAtomicReference = dualValue.isActualFieldAnAtomicReference();
+    // THEN
+    then(isActualFieldAnAtomicReference).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isActualFieldAnAtomicReference_should_return_false_when_actual_is_not_an_AtomicReference(String actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual, "");
+    // WHEN
+    boolean isActualFieldAnAtomicReference = dualValue.isActualFieldAnAtomicReference();
+    // THEN
+    then(isActualFieldAnAtomicReference).isFalse();
+  }
+
+  @Test
+  void isExpectedFieldAnAtomicReference_should_return_true_when_expected_is_an_AtomicReference() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", new AtomicReference<>("a"));
+    // WHEN
+    boolean isExpectedFieldAnAtomicReference = dualValue.isExpectedFieldAnAtomicReference();
+    // THEN
+    then(isExpectedFieldAnAtomicReference).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isExpectedFieldAnAtomicReference_should_return_false_when_expected_is_not_an_AtomicReference(String expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected);
+    // WHEN
+    boolean isExpectedFieldAnAtomicReference = dualValue.isExpectedFieldAnAtomicReference();
+    // THEN
+    then(isExpectedFieldAnAtomicReference).isFalse();
+  }
+
+  // AtomicReferenceArray
+
+  @Test
+  void isActualFieldAnAtomicReferenceArray_should_return_true_when_actual_is_an_AtomicReferenceArray() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, new AtomicReferenceArray<>(array("a")), "");
+    // WHEN
+    boolean isActualFieldAnAtomicReferenceArray = dualValue.isActualFieldAnAtomicReferenceArray();
+    // THEN
+    then(isActualFieldAnAtomicReferenceArray).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isActualFieldAnAtomicReferenceArray_should_return_false_when_actual_is_not_an_AtomicReferenceArray(String actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual, "");
+    // WHEN
+    boolean isActualFieldAnAtomicReferenceArray = dualValue.isActualFieldAnAtomicReferenceArray();
+    // THEN
+    then(isActualFieldAnAtomicReferenceArray).isFalse();
+  }
+
+  @Test
+  void isExpectedFieldAnAtomicReferenceArray_should_return_true_when_expected_is_an_AtomicReferenceArray() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", new AtomicReferenceArray<>(array("a")));
+    // WHEN
+    boolean isExpectedFieldAnAtomicReferenceArray = dualValue.isExpectedFieldAnAtomicReferenceArray();
+    // THEN
+    then(isExpectedFieldAnAtomicReferenceArray).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isExpectedFieldAnAtomicReferenceArray_should_return_false_when_expected_is_not_an_AtomicReferenceArray(String expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected);
+    // WHEN
+    boolean isExpectedFieldAnAtomicReferenceArray = dualValue.isExpectedFieldAnAtomicReferenceArray();
+    // THEN
+    then(isExpectedFieldAnAtomicReferenceArray).isFalse();
+  }
+
+  // AtomicInteger
+
+  @Test
+  void isActualFieldAnAtomicInteger_should_return_true_when_actual_is_an_AtomicInteger() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, new AtomicInteger(123), "");
+    // WHEN
+    boolean isActualFieldAnAtomicInteger = dualValue.isActualFieldAnAtomicInteger();
+    // THEN
+    then(isActualFieldAnAtomicInteger).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isActualFieldAnAtomicInteger_should_return_false_when_actual_is_not_an_AtomicInteger(String actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual, "");
+    // WHEN
+    boolean isActualFieldAnAtomicInteger = dualValue.isActualFieldAnAtomicInteger();
+    // THEN
+    then(isActualFieldAnAtomicInteger).isFalse();
+  }
+
+  @Test
+  void isExpectedFieldAnAtomicInteger_should_return_true_when_expected_is_an_AtomicInteger() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", new AtomicInteger(123));
+    // WHEN
+    boolean isExpectedFieldAnAtomicInteger = dualValue.isExpectedFieldAnAtomicInteger();
+    // THEN
+    then(isExpectedFieldAnAtomicInteger).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isExpectedFieldAnAtomicInteger_should_return_false_when_expected_is_not_an_AtomicInteger(String expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected);
+    // WHEN
+    boolean isExpectedFieldAnAtomicInteger = dualValue.isExpectedFieldAnAtomicInteger();
+    // THEN
+    then(isExpectedFieldAnAtomicInteger).isFalse();
+  }
+
+  // AtomicIntegerArray
+
+  @Test
+  void isActualFieldAnAtomicIntegerArray_should_return_true_when_actual_is_an_AtomicIntegerArray() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, new AtomicIntegerArray(new int[] { 1, 2, 3 }), "");
+    // WHEN
+    boolean isActualFieldAnAtomicIntegerArray = dualValue.isActualFieldAnAtomicIntegerArray();
+    // THEN
+    then(isActualFieldAnAtomicIntegerArray).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isActualFieldAnAtomicIntegerArray_should_return_false_when_actual_is_not_an_AtomicIntegerArray(String actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual, "");
+    // WHEN
+    boolean isActualFieldAnAtomicIntegerArray = dualValue.isActualFieldAnAtomicIntegerArray();
+    // THEN
+    then(isActualFieldAnAtomicIntegerArray).isFalse();
+  }
+
+  @Test
+  void isExpectedFieldAnAtomicIntegerArray_should_return_true_when_expected_is_an_AtomicIntegerArray() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", new AtomicIntegerArray(new int[] { 1, 2, 3 }));
+    // WHEN
+    boolean isExpectedFieldAnAtomicIntegerArray = dualValue.isExpectedFieldAnAtomicIntegerArray();
+    // THEN
+    then(isExpectedFieldAnAtomicIntegerArray).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isExpectedFieldAnAtomicIntegerArray_should_return_false_when_expected_is_not_an_AtomicIntegerArray(String expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected);
+    // WHEN
+    boolean isExpectedFieldAnAtomicIntegerArray = dualValue.isExpectedFieldAnAtomicIntegerArray();
+    // THEN
+    then(isExpectedFieldAnAtomicIntegerArray).isFalse();
+  }
+
+  // AtomicLong
+
+  @Test
+  void isActualFieldAnAtomicLong_should_return_true_when_actual_is_an_AtomicLong() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, new AtomicLong(123), "");
+    // WHEN
+    boolean isActualFieldAnAtomicLong = dualValue.isActualFieldAnAtomicLong();
+    // THEN
+    then(isActualFieldAnAtomicLong).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isActualFieldAnAtomicLong_should_return_false_when_actual_is_not_an_AtomicLong(String actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual, "");
+    // WHEN
+    boolean isActualFieldAnAtomicLong = dualValue.isActualFieldAnAtomicLong();
+    // THEN
+    then(isActualFieldAnAtomicLong).isFalse();
+  }
+
+  @Test
+  void isExpectedFieldAnAtomicLong_should_return_true_when_expected_is_an_AtomicLong() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", new AtomicLong(123));
+    // WHEN
+    boolean isExpectedFieldAnAtomicLong = dualValue.isExpectedFieldAnAtomicLong();
+    // THEN
+    then(isExpectedFieldAnAtomicLong).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isExpectedFieldAnAtomicLong_should_return_false_when_expected_is_not_an_AtomicLong(String expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected);
+    // WHEN
+    boolean isExpectedFieldAnAtomicLong = dualValue.isExpectedFieldAnAtomicLong();
+    // THEN
+    then(isExpectedFieldAnAtomicLong).isFalse();
+  }
+
+  // AtomicLongArray
+
+  @Test
+  void isActualFieldAnAtomicLongArray_should_return_true_when_actual_is_an_AtomicLongArray() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, new AtomicLongArray(new long[] { 1, 2, 3 }), "");
+    // WHEN
+    boolean isActualFieldAnAtomicLongArray = dualValue.isActualFieldAnAtomicLongArray();
+    // THEN
+    then(isActualFieldAnAtomicLongArray).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isActualFieldAnAtomicLongArray_should_return_false_when_actual_is_not_an_AtomicLongArray(String actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual, "");
+    // WHEN
+    boolean isActualFieldAnAtomicLongArray = dualValue.isActualFieldAnAtomicLongArray();
+    // THEN
+    then(isActualFieldAnAtomicLongArray).isFalse();
+  }
+
+  @Test
+  void isExpectedFieldAnAtomicLongArray_should_return_true_when_expected_is_an_AtomicLongArray() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", new AtomicLongArray(new long[] { 1, 2, 3 }));
+    // WHEN
+    boolean isExpectedFieldAnAtomicLongArray = dualValue.isExpectedFieldAnAtomicLongArray();
+    // THEN
+    then(isExpectedFieldAnAtomicLongArray).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isExpectedFieldAnAtomicLongArray_should_return_false_when_expected_is_not_an_AtomicLongArray(String expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected);
+    // WHEN
+    boolean isExpectedFieldAnAtomicLongArray = dualValue.isExpectedFieldAnAtomicLongArray();
+    // THEN
+    then(isExpectedFieldAnAtomicLongArray).isFalse();
+  }
+
+  // AtomicBoolean
+
+  @Test
+  void isActualFieldAnAtomicBoolean_should_return_true_when_actual_is_an_AtomicBoolean() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, new AtomicBoolean(true), "");
+    // WHEN
+    boolean isActualFieldAnAtomicBoolean = dualValue.isActualFieldAnAtomicBoolean();
+    // THEN
+    then(isActualFieldAnAtomicBoolean).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isActualFieldAnAtomicBoolean_should_return_false_when_actual_is_not_an_AtomicBoolean(String actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual, "");
+    // WHEN
+    boolean isActualFieldAnAtomicBoolean = dualValue.isActualFieldAnAtomicBoolean();
+    // THEN
+    then(isActualFieldAnAtomicBoolean).isFalse();
+  }
+
+  @Test
+  void isExpectedFieldAnAtomicBoolean_should_return_true_when_expected_is_an_AtomicBoolean() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", new AtomicBoolean(true));
+    // WHEN
+    boolean isExpectedFieldAnAtomicBoolean = dualValue.isExpectedFieldAnAtomicBoolean();
+    // THEN
+    then(isExpectedFieldAnAtomicBoolean).isTrue();
+  }
+
+  @ParameterizedTest
+  @NullSource
+  @ValueSource(strings = { "abc" })
+  void isExpectedFieldAnAtomicBoolean_should_return_false_when_expected_is_not_an_AtomicBoolean(String expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected);
+    // WHEN
+    boolean isExpectedFieldAnAtomicBoolean = dualValue.isExpectedFieldAnAtomicBoolean();
+    // THEN
+    then(isExpectedFieldAnAtomicBoolean).isFalse();
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_hasNoContainerValues_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_hasNoContainerValues_Test.java
index 6bcaae73a..b91b7a79f 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_hasNoContainerValues_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_hasNoContainerValues_Test.java
@@ -19,6 +19,13 @@ import static org.assertj.core.util.Maps.newHashMap;
 
 import java.util.List;
 import java.util.Optional;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.DisplayName;
@@ -56,6 +63,18 @@ class DualValue_hasNoContainerValues_Test {
                      Arguments.of(Optional.of("foo"), Optional.of("bar"), false),
                      Arguments.of(Optional.of("foo"), "abc", false),
                      Arguments.of("abc", Optional.of("foo"), false),
+                     Arguments.of(new AtomicReference<>("abc"), new AtomicReference<>("foo"), false),
+                     Arguments.of(new AtomicReference<>("abc"), Optional.of("foo"), false),
+                     Arguments.of(new AtomicInteger(123), new AtomicInteger(456), false),
+                     Arguments.of(new AtomicLong(123), new AtomicLong(456), false),
+                     Arguments.of(new AtomicInteger(123), new AtomicLong(456), false),
+                     Arguments.of(new AtomicLong(123), new AtomicInteger(456), false),
+                     Arguments.of(new AtomicBoolean(true), new AtomicBoolean(false), false),
+                     Arguments.of(new AtomicBoolean(Boolean.TRUE), new AtomicBoolean(Boolean.FALSE), false),
+                     Arguments.of(new AtomicIntegerArray(new int[] { 1, 2, 3 }), new AtomicIntegerArray(new int[] { 1, 2 }),
+                                  false),
+                     Arguments.of(new AtomicLongArray(new long[] { 1, 2, 3 }), new AtomicLongArray(new long[] { 1, 2 }), false),
+                     Arguments.of(new AtomicReferenceArray<>(array("test")), new AtomicReferenceArray<>(array("foo")), false),
                      Arguments.of("abc", null, true),
                      Arguments.of(null, "abc", true),
                      Arguments.of("abc", "abc", true));
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_hasSomeJavaTypeValue_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_hasSomeJavaTypeValue_Test.java
new file mode 100644
index 000000000..f6d9a0084
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_hasSomeJavaTypeValue_Test.java
@@ -0,0 +1,77 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+
+import org.apache.commons.lang3.tuple.Pair;
+import org.junit.jupiter.api.Test;
+
+class DualValue_hasSomeJavaTypeValue_Test {
+
+  private static final List<String> PATH = list("foo", "bar");
+
+  @Test
+  void hasSomeJavaTypeValue_should_return_true_when_actual_is_a_java_type() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", Pair.of(1, "a"));
+    // WHEN
+    boolean hasSomeJavaTypeValue = dualValue.hasSomeJavaTypeValue();
+    // THEN
+    then(hasSomeJavaTypeValue).isTrue();
+  }
+
+  @Test
+  void hasSomeJavaTypeValue_should_return_true_when_expected_is_a_java_type() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), "");
+    // WHEN
+    boolean hasSomeJavaTypeValue = dualValue.hasSomeJavaTypeValue();
+    // THEN
+    then(hasSomeJavaTypeValue).isTrue();
+  }
+
+  @Test
+  void hasSomeJavaTypeValue_should_return_true_when_both_values_are_java_type() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "1", "2");
+    // WHEN
+    boolean hasSomeJavaTypeValue = dualValue.hasSomeJavaTypeValue();
+    // THEN
+    then(hasSomeJavaTypeValue).isTrue();
+  }
+
+  @Test
+  void hasSomeJavaTypeValue_should_return_true_when_no_values_are_java_type() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), Pair.of(1, "b"));
+    // WHEN
+    boolean hasSomeJavaTypeValue = dualValue.hasSomeJavaTypeValue();
+    // THEN
+    then(hasSomeJavaTypeValue).isFalse();
+  }
+
+  @Test
+  void hasSomeJavaTypeValue_should_return_false_when_both_values_are_null() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, null, null);
+    // WHEN
+    boolean hasSomeJavaTypeValue = dualValue.hasSomeJavaTypeValue();
+    // THEN
+    then(hasSomeJavaTypeValue).isFalse();
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isActualJavaType_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isActualJavaType_Test.java
index 1a63ad5be..ca0565a1b 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isActualJavaType_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isActualJavaType_Test.java
@@ -12,7 +12,7 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
 
 import java.util.List;
@@ -27,11 +27,11 @@ class DualValue_isActualJavaType_Test {
   @Test
   void isActualJavaType_should_return_true_when_actual_is_a_java_type() {
     // GIVEN
-    DualValue dualValue = new DualValue(PATH, "", "");
+    DualValue dualValue = new DualValue(PATH, "", Pair.of(1, "a"));
     // WHEN
-    boolean expectedFieldIsArray = dualValue.isActualJavaType();
+    boolean isActualJavaType = dualValue.isActualJavaType();
     // THEN
-    assertThat(expectedFieldIsArray).isTrue();
+    then(isActualJavaType).isTrue();
   }
 
   @Test
@@ -39,9 +39,9 @@ class DualValue_isActualJavaType_Test {
     // GIVEN
     DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), "");
     // WHEN
-    boolean expectedFieldIsArray = dualValue.isActualJavaType();
+    boolean isActualJavaType = dualValue.isActualJavaType();
     // THEN
-    assertThat(expectedFieldIsArray).isFalse();
+    then(isActualJavaType).isFalse();
   }
 
   @Test
@@ -49,9 +49,9 @@ class DualValue_isActualJavaType_Test {
     // GIVEN
     DualValue dualValue = new DualValue(PATH, null, "");
     // WHEN
-    boolean expectedFieldIsArray = dualValue.isActualJavaType();
+    boolean isActualJavaType = dualValue.isActualJavaType();
     // THEN
-    assertThat(expectedFieldIsArray).isFalse();
+    then(isActualJavaType).isFalse();
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isExpectedJavaType_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isExpectedJavaType_Test.java
new file mode 100644
index 000000000..c2b6fe197
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_isExpectedJavaType_Test.java
@@ -0,0 +1,57 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+
+import org.apache.commons.lang3.tuple.Pair;
+import org.junit.jupiter.api.Test;
+
+class DualValue_isExpectedJavaType_Test {
+
+  private static final List<String> PATH = list("foo", "bar");
+
+  @Test
+  void isExpectedJavaType_should_return_true_when_expected_is_a_java_type() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), "");
+    // WHEN
+    boolean isExpectedJavaType = dualValue.isExpectedJavaType();
+    // THEN
+    then(isExpectedJavaType).isTrue();
+  }
+
+  @Test
+  void isExpectedJavaType_should_return_false_when_expected_is_not_a_java_type() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", Pair.of(1, "a"));
+    // WHEN
+    boolean isExpectedJavaType = dualValue.isExpectedJavaType();
+    // THEN
+    then(isExpectedJavaType).isFalse();
+  }
+
+  @Test
+  void isExpectedJavaType_should_return_false_when_expected_is_null() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", null);
+    // WHEN
+    boolean isExpectedJavaType = dualValue.isExpectedJavaType();
+    // THEN
+    then(isExpectedJavaType).isFalse();
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_java_types_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_java_types_Test.java
new file mode 100644
index 000000000..9d313d8db
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_java_types_Test.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.array;
+
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
+import org.assertj.core.internal.objects.data.Person;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class RecursiveComparisonAssert_isEqualTo_with_java_types_Test extends RecursiveComparisonAssert_isEqualTo_BaseTest {
+
+  @ParameterizedTest
+  @MethodSource
+  void should_pass_when_comparing_java_types(Object actual, Object expected) {
+    then(actual).usingRecursiveComparison()
+                .isEqualTo(expected);
+  }
+
+  static Stream<Arguments> should_pass_when_comparing_java_types() {
+    return Stream.of(Arguments.of(new AtomicInteger(123), new AtomicInteger(123)),
+                     Arguments.of(new AtomicLong(123), new AtomicLong(123)),
+                     Arguments.of(new AtomicBoolean(true), new AtomicBoolean(true)),
+                     Arguments.of(new AtomicBoolean(Boolean.FALSE), new AtomicBoolean(Boolean.FALSE)),
+                     Arguments.of(new AtomicIntegerArray(new int[] { 1, 2, 3 }), new AtomicIntegerArray(new int[] { 1, 2, 3 })),
+                     Arguments.of(new AtomicLongArray(new long[] { 1, 2, 3 }), new AtomicLongArray(new long[] { 1, 2, 3 })),
+                     Arguments.of(new AtomicReference<>("test"), new AtomicReference<>("test")),
+                     Arguments.of(new AtomicReference<>(new Person("Joe")), new AtomicReference<>(new Person("Joe"))),
+                     Arguments.of(new AtomicReferenceArray<>(array("test")), new AtomicReferenceArray<>(array("test"))),
+                     Arguments.of(new Wrapper(new AtomicInteger(123)),
+                                  new Wrapper(new AtomicInteger(123))),
+                     Arguments.of(new Wrapper(new AtomicLong(123)),
+                                  new Wrapper(new AtomicLong(123))),
+                     Arguments.of(new Wrapper(new AtomicBoolean(true)),
+                                  new Wrapper(new AtomicBoolean(true))),
+                     Arguments.of(new Wrapper(new AtomicBoolean(Boolean.FALSE)),
+                                  new Wrapper(new AtomicBoolean(Boolean.FALSE))),
+                     Arguments.of(new Wrapper(new AtomicIntegerArray(new int[] { 1, 2, 3 })),
+                                  new Wrapper(new AtomicIntegerArray(new int[] { 1, 2, 3 }))),
+                     Arguments.of(new Wrapper(new AtomicLongArray(new long[] { 1, 2, 3 })),
+                                  new Wrapper(new AtomicLongArray(new long[] { 1, 2, 3 }))),
+                     Arguments.of(new Wrapper(new AtomicReference<>("test")),
+                                  new Wrapper(new AtomicReference<>("test"))),
+                     Arguments.of(new Wrapper(new AtomicReferenceArray<>(array("test"))),
+                                  new Wrapper(new AtomicReferenceArray<>(array("test")))));
+  }
+
+  @Test
+  void wrapper_comparison_should_fail_and_report_the_proper_difference() {
+    // GIVEN
+    Wrapper actual = new Wrapper(new AtomicReference<>("test1"));
+    Wrapper expected = new Wrapper(new AtomicReference<>("test2"));
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, diff("value.value", "test1", "test2"));
+  }
+
+  @Test
+  void should_fail_and_report_the_proper_difference() {
+    // GIVEN
+    AtomicReference<?> actual = new AtomicReference<>("test1");
+    AtomicReference<?> expected = new AtomicReference<>("test2");
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, diff("value", "test1", "test2"));
+  }
+
+  @Test
+  void should_honor_java_equals_and_fail_comparison() {
+    // GIVEN
+    ReentrantReadWriteLock actualLock = new ReentrantReadWriteLock();
+    ReentrantReadWriteLock expectedLock = new ReentrantReadWriteLock();
+    Wrapper actual = new Wrapper(actualLock);
+    Wrapper expected = new Wrapper(expectedLock);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, diff("value", actualLock, expectedLock));
+  }
+
+  static class Wrapper {
+    Object value;
+
+    Wrapper(Object value) {
+      this.value = value;
+    }
+  }
+
+}
diff --git a/verify.bndrun b/verify.bndrun
index efe43dfeb..5946ef73b 100644
--- a/verify.bndrun
+++ b/verify.bndrun
@@ -37,5 +37,5 @@
 	junit-platform-commons;version='[1.8.2,1.8.3)',\
 	junit-platform-engine;version='[1.8.2,1.8.3)',\
 	junit-platform-launcher;version='[1.8.2,1.8.3)',\
-	net.bytebuddy.byte-buddy;version='[1.12.7,1.12.8)',\
+	net.bytebuddy.byte-buddy;version='[1.12.8,1.12.9)',\
 	org.opentest4j;version='[1.2.0,1.2.1)'
