diff --git a/src/main/java/org/assertj/core/api/AbstractPathAssert.java b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
index 22ca86ac7..fd7e7f282 100644
--- a/src/main/java/org/assertj/core/api/AbstractPathAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
@@ -1749,4 +1749,67 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
     paths.assertIsNotEmptyDirectory(info, actual);
     return myself;
   }
+
+  /**
+   * Verify that the actual {@code Path} is an empty regular file.
+   * <p>
+   * Note that the actual {@link Path} must exist and be a regular file.
+   * <p>
+   * Given the following path structure:
+   * <pre><code class="text">
+   * /root/sub-dir-1/file-1.ext (no content)
+   * /root/sub-dir-1/file-2.ext (content)</code></pre>
+   *
+   * Here are some assertions examples:
+   * <pre><code class="java"> Path no-content-path = Paths.get("/root/sub-dir-1/file-1.ext");
+   * Path content-path = Paths.get("/root/sub-dir-1/file-2.ext");
+   *
+   * // The following assertion succeeds:
+   * assertThat(no-content-path).isEmpty();
+   *
+   * // The following assertion fails:
+   * assertThat(content-path).isEmpty();</code></pre>
+   *
+   * @return {@code this} assertion object.
+   * @throws AssertionError if actual is {@code null}.
+   * @throws AssertionError if actual does not exist.
+   * @throws AssertionError if actual is not empty.
+   * @since 3.19.0
+   */
+  public SELF isEmpty() {
+    paths.assertIsEmptyFile(info, actual);
+    return myself;
+  }
+
+  /**
+   * Verify that the actual {@code Path} is a non-empty regular file.
+   * <p>
+   * Note that the actual {@link Path} must exist and be a regular file.
+   * <p>
+   * Given the following path structure:
+   * <pre><code class="text">
+   * /root/sub-dir-1/file-1.ext (no content)
+   * /root/sub-dir-1/file-2.ext (content)</code></pre>
+   *
+   * Here are some assertions examples:
+   * <pre><code class="java"> Path no-content-path = Paths.get("/root/sub-dir-1/file-1.ext");
+   * Path content-path = Paths.get("/root/sub-dir-1/file-2.ext");
+   *
+   * // The following assertion succeeds:
+   * assertThat(content-path).isNotEmpty();
+   *
+   * // The following assertion fails:
+   * assertThat(no-content-path).isNotEmpty();</code></pre>
+   *
+   * @return {@code this} assertion object.
+   * @throws AssertionError if actual is {@code null}.
+   * @throws AssertionError if actual does not exist.
+   * @throws AssertionError if actual is empty.
+   * @since 3.19.0
+   */
+  public SELF isNotEmpty() {
+    paths.assertIsNotEmptyFile(info, actual);
+    return myself;
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEmpty.java b/src/main/java/org/assertj/core/error/ShouldBeEmpty.java
index 9265b0697..b36081e71 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeEmpty.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeEmpty.java
@@ -13,10 +13,11 @@
 package org.assertj.core.error;
 
 import java.io.File;
+import java.nio.file.Path;
 
 /**
  * Creates an error message indicating that an assertion that verifies a group of elements is empty failed. A group of elements
- * can be a collection, an array, {@code String} or a {@code File}.
+ * can be a collection, an array, a {@code String}, a {@code File} or a {@code Path}.
  * 
  * @author Alex Ruiz
  */
@@ -40,6 +41,15 @@ public class ShouldBeEmpty extends BasicErrorMessageFactory {
     return new ShouldBeEmpty("%nExpecting file <%s> to be empty", actual);
   }
 
+  /**
+   * Creates a new <code>{@link ShouldBeEmpty}</code>.
+   * @param actual the actual path in the failed assertion.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeEmpty(Path actual) {
+    return new ShouldBeEmpty("%nExpecting path <%s> to be empty", actual);
+  }
+
   private ShouldBeEmpty(String format, Object... arguments) {
     super(format, arguments);
   }
diff --git a/src/main/java/org/assertj/core/error/ShouldNotBeEmpty.java b/src/main/java/org/assertj/core/error/ShouldNotBeEmpty.java
index e2d35865a..ebfe0909c 100644
--- a/src/main/java/org/assertj/core/error/ShouldNotBeEmpty.java
+++ b/src/main/java/org/assertj/core/error/ShouldNotBeEmpty.java
@@ -13,10 +13,11 @@
 package org.assertj.core.error;
 
 import java.io.File;
+import java.nio.file.Path;
 
 /**
  * Creates an error message indicating that an assertion that verifies a group of elements is not empty failed. A group of
- * elements can be a collection, an array, {@code String} or a {@code File}.
+ * elements can be a collection, an array, a {@code String}, a {@code File} or a {@code Path}.
  *
  * @author Alex Ruiz
  */
@@ -41,6 +42,15 @@ public class ShouldNotBeEmpty extends BasicErrorMessageFactory {
     return new ShouldNotBeEmpty("%nExpecting file <%s> not to be empty", actual);
   }
 
+  /**
+  * Creates a new <code>{@link ShouldNotBeEmpty}</code>.
+  * @param actual the actual path in the failed assertion.
+  * @return the created {@code ErrorMessageFactory}.
+  */
+  public static ErrorMessageFactory shouldNotBeEmpty(Path actual) {
+    return new ShouldNotBeEmpty("%nExpecting path <%s> not to be empty", actual);
+  }
+
   private ShouldNotBeEmpty(String format, Object... arguments) {
     super(format, arguments);
   }
diff --git a/src/main/java/org/assertj/core/internal/NioFilesWrapper.java b/src/main/java/org/assertj/core/internal/NioFilesWrapper.java
index e97c707f5..9d53c549d 100644
--- a/src/main/java/org/assertj/core/internal/NioFilesWrapper.java
+++ b/src/main/java/org/assertj/core/internal/NioFilesWrapper.java
@@ -34,12 +34,11 @@ public class NioFilesWrapper {
    * Returns the singleton instance of this class.
    * @return the singleton instance of this class.
    */
-  public static NioFilesWrapper instance() {
+  static NioFilesWrapper instance() {
     return INSTANCE;
   }
 
-  @VisibleForTesting
-  NioFilesWrapper() {}
+  private NioFilesWrapper() {}
 
   public boolean isRegularFile(Path path) {
     return Files.isRegularFile(path);
@@ -80,4 +79,9 @@ public class NioFilesWrapper {
   public DirectoryStream<Path> newDirectoryStream(Path path, Predicate<Path> matcher) throws IOException {
     return Files.newDirectoryStream(path, matcher::test);
   }
+
+  public long size(Path path) throws IOException {
+    return Files.size(path);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/internal/Paths.java b/src/main/java/org/assertj/core/internal/Paths.java
index 68f42932f..6726a6753 100644
--- a/src/main/java/org/assertj/core/internal/Paths.java
+++ b/src/main/java/org/assertj/core/internal/Paths.java
@@ -21,6 +21,7 @@ import static java.util.stream.StreamSupport.stream;
 import static org.assertj.core.error.ShouldBeAbsolutePath.shouldBeAbsolutePath;
 import static org.assertj.core.error.ShouldBeCanonicalPath.shouldBeCanonicalPath;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
+import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
 import static org.assertj.core.error.ShouldBeEmptyDirectory.shouldBeEmptyDirectory;
 import static org.assertj.core.error.ShouldBeExecutable.shouldBeExecutable;
 import static org.assertj.core.error.ShouldBeNormalized.shouldBeNormalized;
@@ -89,7 +90,7 @@ public class Paths {
   @VisibleForTesting
   Failures failures = Failures.instance();
 
-  private NioFilesWrapper nioFilesWrapper;
+  private final NioFilesWrapper nioFilesWrapper;
 
   public static Paths instance() {
     return INSTANCE;
@@ -496,4 +497,22 @@ public class Paths {
     requireNonNull(end, "the expected end path should not be null");
   }
 
+  public void assertIsEmptyFile(AssertionInfo info, Path actual) {
+    assertIsRegularFile(info, actual);
+    try {
+      if (nioFilesWrapper.size(actual) > 0) throw failures.failure(info, shouldBeEmpty(actual));
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+    }
+  }
+
+  public void assertIsNotEmptyFile(AssertionInfo info, Path actual) {
+    assertIsRegularFile(info, actual);
+    try {
+      if (nioFilesWrapper.size(actual) == 0) throw failures.failure(info, shouldNotBeEmpty(actual));
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+    }
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isEmpty_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isEmpty_Test.java
new file mode 100644
index 000000000..637851b9a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isEmpty_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.junit.jupiter.api.DisplayName;
+
+/**
+ * Test for <code>{@link PathAssert#isEmpty()}</code>.
+ *
+ * @author Omar Morales
+ */
+@DisplayName("PathAssert isEmpty")
+class PathAssert_isEmpty_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.isEmpty();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertIsEmptyFile(getInfo(assertions), getActual(assertions));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isNotEmpty_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isNotEmpty_Test.java
new file mode 100644
index 000000000..fec558b17
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isNotEmpty_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.junit.jupiter.api.DisplayName;
+
+/**
+ * Test for <code>{@link PathAssert#isNotEmpty()}</code>.
+ *
+ * @author Omar Morales
+ */
+@DisplayName("PathAssert isNotEmpty")
+class PathAssert_isNotEmpty_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.isNotEmpty();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertIsNotEmptyFile(getInfo(assertions), getActual(assertions));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeEmpty_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeEmpty_create_Test.java
index db469073b..ae4f4e134 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeEmpty_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeEmpty_create_Test.java
@@ -19,13 +19,17 @@ import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPR
 import static org.assertj.core.util.Lists.list;
 
 import java.io.File;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 
+import org.assertj.core.description.Description;
 import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.Representation;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
 /**
- * Tests for <code>{@link ShouldBeEmpty#create((org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for <code>{@link ShouldBeEmpty#create(Description, Representation)}</code>.
  *
  * @author Alex Ruiz
  * @author Yvonne Wang
@@ -36,9 +40,9 @@ class ShouldBeEmpty_create_Test {
   @Test
   void should_create_error_message() {
     // GIVEN
-    ErrorMessageFactory errorMessageFactory = shouldBeEmpty(list("Luke", "Yoda"));
+    ErrorMessageFactory underTest = shouldBeEmpty(list("Luke", "Yoda"));
     // WHEN
-    String message = errorMessageFactory.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
+    String message = underTest.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
     // THEN
     then(message).isEqualTo(format("[Test] %nExpecting empty but was:<[\"Luke\", \"Yoda\"]>"));
   }
@@ -46,11 +50,23 @@ class ShouldBeEmpty_create_Test {
   @Test
   void should_create_specific_error_message_for_File() {
     // GIVEN
-    File file = new File("/te%st.txt");
-    ErrorMessageFactory errorMessageFactory = shouldBeEmpty(file);
+    File file = new File("/test.txt");
+    ErrorMessageFactory underTest = shouldBeEmpty(file);
     // WHEN
-    String message = errorMessageFactory.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
+    String message = underTest.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
     // THEN
-    then(message).isEqualTo(format("[Test] %nExpecting file <%s> to be empty", file.getAbsolutePath()));
+    then(message).isEqualTo("[Test] %nExpecting file <%s> to be empty", file.getAbsolutePath());
   }
+
+  @Test
+  void should_create_specific_error_message_for_Path() {
+    // GIVEN
+    Path path = Paths.get("/test.txt");
+    ErrorMessageFactory underTest = shouldBeEmpty(path);
+    // WHEN
+    String message = underTest.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo("[Test] %nExpecting path <%s> to be empty", path);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldNotBeEmpty_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotBeEmpty_create_Test.java
index 569f1c9cd..a2b02b88f 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotBeEmpty_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotBeEmpty_create_Test.java
@@ -18,13 +18,17 @@ import static org.assertj.core.error.ShouldNotBeEmpty.shouldNotBeEmpty;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
 
 import java.io.File;
+import java.nio.file.Path;
+import java.nio.file.Paths;
 
+import org.assertj.core.description.Description;
 import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.Representation;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
 /**
- * Tests for <code>{@link ShouldNotBeEmpty#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for <code>{@link ShouldNotBeEmpty#create(Description, Representation)}</code>.
  *
  * @author Alex Ruiz
  * @author Yvonne Wang
@@ -35,9 +39,9 @@ class ShouldNotBeEmpty_create_Test {
   @Test
   void should_create_error_message() {
     // GIVEN
-    ErrorMessageFactory errorMessageFactory = shouldNotBeEmpty();
+    ErrorMessageFactory underTest = shouldNotBeEmpty();
     // WHEN
-    String message = errorMessageFactory.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
+    String message = underTest.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
     // THEN
     then(message).isEqualTo(format("[Test] %nExpecting actual not to be empty"));
   }
@@ -46,10 +50,22 @@ class ShouldNotBeEmpty_create_Test {
   void should_create_specific_error_message_for_File() {
     // GIVEN
     File file = new File("/test.txt");
-    ErrorMessageFactory errorMessageFactory = shouldNotBeEmpty(file);
+    ErrorMessageFactory underTest = shouldNotBeEmpty(file);
     // WHEN
-    String message = errorMessageFactory.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
+    String message = underTest.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
     // THEN
-    then(message).isEqualTo(format("[Test] %nExpecting file <%s> not to be empty", file.getAbsolutePath()));
+    then(message).isEqualTo("[Test] %nExpecting file <%s> not to be empty", file.getAbsolutePath());
   }
+
+  @Test
+  void should_create_specific_error_message_for_Path() {
+    // GIVEN
+    Path path = Paths.get("/test.txt");
+    ErrorMessageFactory underTest = shouldNotBeEmpty(path);
+    // WHEN
+    String message = underTest.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %nExpecting path <%s> not to be empty", path));
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java b/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java
index db8078b2d..d83e4dbbd 100644
--- a/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java
@@ -64,17 +64,6 @@ public class MockPathsBaseTest extends PathsBaseTest {
     }
   }
 
-  static <T> void failIfStreamIsOpen(DirectoryStream<T> stream) {
-    try {
-      long openCount = mockingDetails(stream).getInvocations().stream()
-                                             .filter(inv -> inv.getMethod().getName().equals("iterator"))
-                                             .count();
-      verify(stream, times((int) openCount)).close();
-    } catch (IOException e) {
-      fail("Should not happen");
-    }
-  }
-
   static DirectoryStream<Path> directoryStream(List<Path> directoryItems) {
     DirectoryStream<Path> stream = mock(DirectoryStream.class);
     given(stream.iterator()).will(inv -> directoryItems.iterator());
@@ -110,7 +99,7 @@ public class MockPathsBaseTest extends PathsBaseTest {
     return path;
   }
 
-  Path mockRegularFile(String... names) {
+  Path mockEmptyRegularFile(String... names) {
     Path path = mockPath(names);
     given(nioFilesWrapper.exists(path)).willReturn(true);
     given(nioFilesWrapper.isRegularFile(path)).willReturn(true);
@@ -122,12 +111,13 @@ public class MockPathsBaseTest extends PathsBaseTest {
     return path;
   }
 
-  Path mockDirectory(String name, DirectoryStream<Path> directoryItems) {
-    Path path = mockPath(name);
+  Path mockNonEmptyRegularFile(String... names) {
+    Path path = mockPath(names);
     given(nioFilesWrapper.exists(path)).willReturn(true);
-    given(nioFilesWrapper.isDirectory(path)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(path)).willReturn(true);
     try {
-      given(nioFilesWrapper.newDirectoryStream(eq(path), any())).will(inv -> filterStream(inv.getArgument(1), directoryItems));
+      given(nioFilesWrapper.size(path)).willReturn(1L);
+      given(nioFilesWrapper.newInputStream(path)).willReturn(new ByteArrayInputStream(new byte[1]));
     } catch (IOException e) {
       fail("Should not happen");
     }
@@ -146,4 +136,5 @@ public class MockPathsBaseTest extends PathsBaseTest {
     }
     return path;
   }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_Predicate_Test.java
index 4fc0ecc5b..c42a14c53 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_Predicate_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_Predicate_Test.java
@@ -57,7 +57,7 @@ class Paths_assertIsDirectoryContaining_Predicate_Test extends MockPathsBaseTest
   @Test
   void should_pass_if_actual_contains_a_file_matching_the_given_predicate() {
     // GIVEN
-    Path file = mockRegularFile("Test.java");
+    Path file = mockEmptyRegularFile("Test.java");
     Path actual = mockDirectory("root", list(file));
     // THEN
     paths.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE);
@@ -66,8 +66,8 @@ class Paths_assertIsDirectoryContaining_Predicate_Test extends MockPathsBaseTest
   @Test
   void should_pass_if_all_actual_files_match_the_given_predicate() {
     // GIVEN
-    Path file1 = mockRegularFile("Test.java");
-    Path file2 = mockRegularFile("Utils.java");
+    Path file1 = mockEmptyRegularFile("Test.java");
+    Path file2 = mockEmptyRegularFile("Utils.java");
     Path actual = mockDirectory("root", list(file1, file2));
     // THEN
     paths.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE);
@@ -76,11 +76,11 @@ class Paths_assertIsDirectoryContaining_Predicate_Test extends MockPathsBaseTest
   @Test
   void should_pass_if_actual_contains_at_least_one_file_matching_the_given_predicate() {
     // GIVEN
-    Path file1 = mockRegularFile("Test.class");
-    Path file2 = mockRegularFile("Test.java");
-    Path file3 = mockRegularFile("Utils.class");
-    Path file4 = mockRegularFile("Utils.java");
-    Path file5 = mockRegularFile("application.yml");
+    Path file1 = mockEmptyRegularFile("Test.class");
+    Path file2 = mockEmptyRegularFile("Test.java");
+    Path file3 = mockEmptyRegularFile("Utils.class");
+    Path file4 = mockEmptyRegularFile("Utils.java");
+    Path file5 = mockEmptyRegularFile("application.yml");
     Path actual = mockDirectory("root", list(file1, file2, file3, file4, file5));
     // THEN
     paths.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE);
@@ -154,7 +154,7 @@ class Paths_assertIsDirectoryContaining_Predicate_Test extends MockPathsBaseTest
   @Test
   void should_fail_if_actual_does_not_contain_any_files_matching_the_given_predicate() {
     // GIVEN
-    Path file = mockRegularFile("root", "Test.class");
+    Path file = mockEmptyRegularFile("root", "Test.class");
     List<Path> files = list(file);
     Path actual = mockDirectory("root", files);
     // WHEN
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
index 796d2159e..5f9a14506 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
@@ -57,7 +57,7 @@ class Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test extends MockPathsB
   @Test
   void should_pass_if_actual_contains_a_file_matching_the_given_pattern() {
     // GIVEN
-    Path file = mockRegularFile("Test.java");
+    Path file = mockEmptyRegularFile("Test.java");
     Path actual = mockDirectory("root", list(file));
     mockPathMatcher(actual);
     // THEN
@@ -67,8 +67,8 @@ class Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test extends MockPathsB
   @Test
   void should_pass_if_all_actual_files_match_the_given_pattern() {
     // GIVEN
-    Path file1 = mockRegularFile("Test.java");
-    Path file2 = mockRegularFile("Utils.java");
+    Path file1 = mockEmptyRegularFile("Test.java");
+    Path file2 = mockEmptyRegularFile("Utils.java");
     Path actual = mockDirectory("root", list(file1, file2));
     mockPathMatcher(actual);
     // THEN
@@ -78,11 +78,11 @@ class Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test extends MockPathsB
   @Test
   void should_pass_if_actual_contains_at_least_one_file_matching_the_given_pattern() {
     // GIVEN
-    Path file1 = mockRegularFile("Test.class");
-    Path file2 = mockRegularFile("Test.java");
-    Path file3 = mockRegularFile("Utils.class");
-    Path file4 = mockRegularFile("Utils.java");
-    Path file5 = mockRegularFile("application.yml");
+    Path file1 = mockEmptyRegularFile("Test.class");
+    Path file2 = mockEmptyRegularFile("Test.java");
+    Path file3 = mockEmptyRegularFile("Utils.class");
+    Path file4 = mockEmptyRegularFile("Utils.java");
+    Path file5 = mockEmptyRegularFile("application.yml");
     Path actual = mockDirectory("root", list(file1, file2, file3, file4, file5));
     mockPathMatcher(actual);
     // THEN
@@ -161,7 +161,7 @@ class Paths_assertIsDirectoryContaining_SyntaxAndPattern_Test extends MockPathsB
   @Test
   void should_fail_if_actual_does_not_contain_any_files_matching_the_given_predicate() {
     // GIVEN
-    Path file = mockRegularFile("root", "Test.class");
+    Path file = mockEmptyRegularFile("root", "Test.class");
     List<Path> files = list(file);
     Path actual = mockDirectory("root", files);
     mockPathMatcher(actual);
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_Predicate_Test.java
index acbfc9732..7a8e41797 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_Predicate_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_Predicate_Test.java
@@ -57,7 +57,7 @@ class Paths_assertIsDirectoryNotContaining_Predicate_Test extends MockPathsBaseT
   @Test
   void should_pass_if_actual_does_not_contain_files_matching_the_given_filter() {
     // GIVEN
-    Path file = mockRegularFile("root", "Test.class");
+    Path file = mockEmptyRegularFile("root", "Test.class");
     List<Path> items = list(file);
     Path actual = mockDirectory("root", items);
     // THEN
@@ -130,7 +130,7 @@ class Paths_assertIsDirectoryNotContaining_Predicate_Test extends MockPathsBaseT
   @Test
   void should_fail_if_one_actual_file_matches_the_filter() {
     // GIVEN
-    Path file = mockRegularFile("Test.java");
+    Path file = mockEmptyRegularFile("Test.java");
     List<Path> items = list(file);
     Path actual = mockDirectory("root", items);
     // WHEN
@@ -142,8 +142,8 @@ class Paths_assertIsDirectoryNotContaining_Predicate_Test extends MockPathsBaseT
   @Test
   void should_fail_if_all_actual_files_match_the_filter() {
     // GIVEN
-    Path file1 = mockRegularFile("Test.java");
-    Path file2 = mockRegularFile("Utils.java");
+    Path file1 = mockEmptyRegularFile("Test.java");
+    Path file2 = mockEmptyRegularFile("Utils.java");
     List<Path> items = list(file1, file2);
     Path actual = mockDirectory("root", items);
     // WHEN
@@ -155,11 +155,11 @@ class Paths_assertIsDirectoryNotContaining_Predicate_Test extends MockPathsBaseT
   @Test
   void should_fail_if_some_actual_files_match_the_filter() {
     // GIVEN
-    Path file1 = mockRegularFile("Test.class");
-    Path file2 = mockRegularFile("Test.java");
-    Path file3 = mockRegularFile("Utils.class");
-    Path file4 = mockRegularFile("Utils.java");
-    Path file5 = mockRegularFile("application.yml");
+    Path file1 = mockEmptyRegularFile("Test.class");
+    Path file2 = mockEmptyRegularFile("Test.java");
+    Path file3 = mockEmptyRegularFile("Utils.class");
+    Path file4 = mockEmptyRegularFile("Utils.java");
+    Path file5 = mockEmptyRegularFile("application.yml");
     List<Path> items = list(file1, file2, file3, file4, file5);
     Path actual = mockDirectory("root", items);
     // WHEN
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
index 9df2b3514..ea5744d70 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
@@ -53,7 +53,7 @@ class Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends MockPat
   @Test
   void should_pass_if_actual_does_not_contain_files_matching_the_given_pattern() {
     // GIVEN
-    Path file = mockRegularFile("root", "Test.class");
+    Path file = mockEmptyRegularFile("root", "Test.class");
     List<Path> items = singletonList(file);
     Path actual = mockDirectory("root", items);
     mockPathMatcher(actual);
@@ -132,7 +132,7 @@ class Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends MockPat
   @Test
   void should_fail_if_one_actual_file_matches_the_given_pattern() {
     // GIVEN
-    Path file = mockRegularFile("Test.java");
+    Path file = mockEmptyRegularFile("Test.java");
     List<Path> items = list(file);
     Path actual = mockDirectory("root", items);
     mockPathMatcher(actual);
@@ -145,8 +145,8 @@ class Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends MockPat
   @Test
   void should_fail_if_actual_contains_only_not_expected() {
     // GIVEN
-    Path file1 = mockRegularFile("Test.java");
-    Path file2 = mockRegularFile("Utils.java");
+    Path file1 = mockEmptyRegularFile("Test.java");
+    Path file2 = mockEmptyRegularFile("Utils.java");
     List<Path> items = list(file1, file2);
     Path actual = mockDirectory("root", items);
     mockPathMatcher(actual);
@@ -159,11 +159,11 @@ class Paths_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends MockPat
   @Test
   void should_fail_if_some_actual_files_match_the_filter() {
     // GIVEN
-    Path file1 = mockRegularFile("Test.class");
-    Path file2 = mockRegularFile("Test.java");
-    Path file3 = mockRegularFile("Utils.class");
-    Path file4 = mockRegularFile("Utils.java");
-    Path file5 = mockRegularFile("application.yml");
+    Path file1 = mockEmptyRegularFile("Test.class");
+    Path file2 = mockEmptyRegularFile("Test.java");
+    Path file3 = mockEmptyRegularFile("Utils.class");
+    Path file4 = mockEmptyRegularFile("Utils.java");
+    Path file5 = mockEmptyRegularFile("application.yml");
     List<Path> items = list(file1, file2, file3, file4, file5);
     Path actual = mockDirectory("root", items);
     mockPathMatcher(actual);
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsEmptyDirectory_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsEmptyDirectory_Test.java
index 79889279e..d223b0265 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsEmptyDirectory_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsEmptyDirectory_Test.java
@@ -54,7 +54,7 @@ class Paths_assertIsEmptyDirectory_Test extends MockPathsBaseTest {
   @Test
   void should_fail_if_actual_is_not_empty() {
     // GIVEN
-    Path file = mockRegularFile("root", "Test.class");
+    Path file = mockEmptyRegularFile("root", "Test.class");
     List<Path> files = list(file);
     Path actual = mockDirectory("root", files);
     // WHEN
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsEmptyFile_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsEmptyFile_Test.java
new file mode 100644
index 000000000..2f1031dac
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsEmptyFile_Test.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.BDDMockito.given;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.api.exception.PathsException;
+import org.assertj.core.internal.Paths;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertIsEmptyFile(AssertionInfo, Path)}</code>
+ *
+ * @author Stefano Cordio
+ */
+@DisplayName("Paths assertIsEmptyFile")
+class Paths_assertIsEmptyFile_Test extends MockPathsBaseTest {
+
+  @Test
+  void should_pass_if_actual_is_empty() {
+    // GIVEN
+    Path actual = mockEmptyRegularFile("file");
+    // WHEN/THEN
+    paths.assertIsEmptyFile(INFO, actual);
+  }
+
+  @Test
+  void should_fail_if_actual_is_not_empty() {
+    // GIVEN
+    Path actual = mockNonEmptyRegularFile("file");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertIsEmptyFile(INFO, actual));
+    // THEN
+    then(error).hasMessage(shouldBeEmpty(actual).create());
+  }
+
+  @Test
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    Path actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertIsEmptyFile(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_exist() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(false);
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertIsEmptyFile(INFO, actual));
+    // THEN
+    then(error).hasMessage(shouldExist(actual).create());
+  }
+
+  @Test
+  void should_fail_if_actual_exists_but_is_not_regular_file() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(false);
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertIsEmptyFile(INFO, actual));
+    // THEN
+    then(error).hasMessage(shouldBeRegularFile(actual).create());
+  }
+
+  @Test
+  void should_throw_runtime_error_wrapping_caught_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.size(actual)).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertIsEmptyFile(INFO, actual));
+    // THEN
+    then(error).isInstanceOf(PathsException.class)
+               .hasCause(cause);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNotEmptyDirectory_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNotEmptyDirectory_Test.java
index 7dbb04b8b..c6c15579d 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNotEmptyDirectory_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNotEmptyDirectory_Test.java
@@ -45,7 +45,7 @@ class Paths_assertIsNotEmptyDirectory_Test extends MockPathsBaseTest {
   @Test
   void should_pass_if_actual_is_not_empty() {
     // GIVEN
-    List<Path> files = list(mockRegularFile("root", "Test.class"));
+    List<Path> files = list(mockEmptyRegularFile("root", "Test.class"));
     Path actual = mockDirectory("root", files);
     // THEN
     paths.assertIsNotEmptyDirectory(INFO, actual);
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNotEmptyFile_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNotEmptyFile_Test.java
new file mode 100644
index 000000000..184034a22
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNotEmptyFile_Test.java
@@ -0,0 +1,104 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldNotBeEmpty.shouldNotBeEmpty;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.BDDMockito.given;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.api.exception.PathsException;
+import org.assertj.core.internal.Paths;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertIsNotEmptyFile(AssertionInfo, Path)}</code>
+ *
+ * @author Stefano Cordio
+ */
+@DisplayName("Paths assertIsNotEmptyFile")
+class Paths_assertIsNotEmptyFile_Test extends MockPathsBaseTest {
+
+  @Test
+  void should_pass_if_actual_is_empty() {
+    // GIVEN
+    Path actual = mockNonEmptyRegularFile("file");
+    // WHEN/THEN
+    paths.assertIsNotEmptyFile(INFO, actual);
+  }
+
+  @Test
+  void should_fail_if_actual_is_not_empty() {
+    // GIVEN
+    Path actual = mockEmptyRegularFile("file");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertIsNotEmptyFile(INFO, actual));
+    // THEN
+    then(error).hasMessage(shouldNotBeEmpty(actual).create());
+  }
+
+  @Test
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    Path actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertIsNotEmptyFile(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_exist() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(false);
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertIsNotEmptyFile(INFO, actual));
+    // THEN
+    then(error).hasMessage(shouldExist(actual).create());
+  }
+
+  @Test
+  void should_fail_if_actual_exists_but_is_not_regular_file() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(false);
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertIsNotEmptyFile(INFO, actual));
+    // THEN
+    then(error).hasMessage(shouldBeRegularFile(actual).create());
+  }
+
+  @Test
+  void should_throw_runtime_error_wrapping_caught_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.size(actual)).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertIsNotEmptyFile(INFO, actual));
+    // THEN
+    then(error).isInstanceOf(PathsException.class)
+               .hasCause(cause);
+  }
+
+}
