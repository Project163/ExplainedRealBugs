diff --git a/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java b/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
index cc2485e4f..516244097 100644
--- a/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
@@ -17,6 +17,7 @@ import static org.assertj.core.util.IterableUtil.toArray;
 
 import java.io.File;
 import java.io.LineNumberReader;
+import java.text.Normalizer;
 import java.util.Comparator;
 import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
@@ -1596,4 +1597,34 @@ public abstract class AbstractCharSequenceAssert<SELF extends AbstractCharSequen
     strings.assertUpperCase(info, actual);
     return myself;
   }
+
+  /**
+   * Verifies that the actual {@code CharSequence} is equal to the given one after they have been normalized
+   * according to the {@link Normalizer.Form#NFC} form, which is a canonical decomposition followed by canonical composition.
+   * <p>
+   * Example:
+   * <pre><code class='java'> // assertions succeed:
+   *
+   * // Ä = &#92;u00C4 - Ä = &#92;u0041&#92;u0308
+   * assertThat(&quot;Ä&quot;).isEqualToNormalizingUnicode(&quot;Ä&quot;);
+   * assertThat(&quot;&#92;u00C4&quot;).isEqualToNormalizingUnicode(&quot;&#92;u0041&#92;u0308&quot;);
+   *
+   * // Amélie = u0041&#92;u006d&#92;u00e9&#92;u006c&#92;u0069&#92;u0065 - Amélie = &#92;u0041&#92;u006d&#92;u0065&#92;u0301&#92;u006c&#92;u0069&#92;u0065
+   * assertThat(&quot;Amélie&quot;).isEqualToNormalizingUnicode(&quot;Amélie&quot;);
+   *
+   * // assertions fail:
+   * assertThat(&quot;ñ&quot;).isEqualToNormalizingUnicode(&quot;n&quot;);
+   * assertThat(&quot;Ä&quot;).isEqualToNormalizingUnicode(&quot;b&quot;);</code></pre>
+   *
+   * @param expected the given {@code CharSequence} to compare the actual {@code CharSequence} to.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual {@code CharSequence} is not equal to the given one
+   *           after both strings have been normalized to according to the {@link Normalizer.Form#NFC} form .
+   * @throws NullPointerException if the actual {@code CharSequence} is not null and the given is.
+   * @since 3.19.0
+   */
+  public SELF isEqualToNormalizingUnicode(CharSequence expected) {
+    strings.assertEqualsToNormalizingUnicode(info, actual, expected);
+    return myself;
+  }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqualNormalizingUnicode.java b/src/main/java/org/assertj/core/error/ShouldBeEqualNormalizingUnicode.java
new file mode 100644
index 000000000..bf5062e80
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqualNormalizingUnicode.java
@@ -0,0 +1,46 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.error;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that two {@code CharSequence}s are equal,
+ * on their canonical form relying on {@link java.text.Normalizer}, failed.
+ *
+ * @author Julieta Navarro
+ */
+public class ShouldBeEqualNormalizingUnicode extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link org.assertj.core.error.ShouldBeEqualNormalizingUnicode}</code>.
+   * @param actual the actual value in the failed assertion.
+   * @param expected the expected value in the failed assertion.
+   * @param normalizedActual the normalized actual value in the failed assertion.
+   * @param normalizedExpected the normalized expected value in the failed assertion.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeEqualNormalizingUnicode(CharSequence actual, CharSequence expected,
+                                                                    CharSequence normalizedActual,
+                                                                    CharSequence normalizedExpected) {
+    return new ShouldBeEqualNormalizingUnicode(actual, expected, normalizedActual, normalizedExpected);
+  }
+
+  private ShouldBeEqualNormalizingUnicode(CharSequence actual, CharSequence expected, CharSequence normalizedActual,
+                                          CharSequence normalizedExpected) {
+    super("%nExpecting actual:%n  %s%nto be equal to:%n  %s%n" +
+          "after they have been normalized according to the Normalizer.Form.NFC form.%n" +
+          "The normalized strings should be equal.%n" +
+          "Normalized actual  : %s%n" +
+          "Normalized expected: %s",
+          actual, expected, normalizedActual, normalizedExpected);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Strings.java b/src/main/java/org/assertj/core/internal/Strings.java
index e95abaa5d..06e213f3b 100644
--- a/src/main/java/org/assertj/core/internal/Strings.java
+++ b/src/main/java/org/assertj/core/internal/Strings.java
@@ -27,6 +27,7 @@ import static org.assertj.core.error.ShouldBeEqualIgnoringNewLineDifferences.sho
 import static org.assertj.core.error.ShouldBeEqualIgnoringNewLines.shouldBeEqualIgnoringNewLines;
 import static org.assertj.core.error.ShouldBeEqualIgnoringWhitespace.shouldBeEqualIgnoringWhitespace;
 import static org.assertj.core.error.ShouldBeEqualNormalizingPunctuationAndWhitespace.shouldBeEqualNormalizingPunctuationAndWhitespace;
+import static org.assertj.core.error.ShouldBeEqualNormalizingUnicode.shouldBeEqualNormalizingUnicode;
 import static org.assertj.core.error.ShouldBeEqualNormalizingWhitespace.shouldBeEqualNormalizingWhitespace;
 import static org.assertj.core.error.ShouldBeLowerCase.shouldBeLowerCase;
 import static org.assertj.core.error.ShouldBeNullOrEmpty.shouldBeNullOrEmpty;
@@ -75,6 +76,7 @@ import static org.assertj.core.util.xml.XmlStringPrettyFormatter.xmlPrettyFormat
 import java.io.IOException;
 import java.io.LineNumberReader;
 import java.io.StringReader;
+import java.text.Normalizer;
 import java.util.Base64;
 import java.util.Comparator;
 import java.util.LinkedHashSet;
@@ -742,6 +744,31 @@ public class Strings {
     return normalizeWhitespace(toNormalize.toString().replaceAll(PUNCTUATION_REGEX, ""));
   }
 
+  /**
+   * Verifies that two {@code CharSequence}s are equal, on their canonical form relying on {@link java.text.Normalizer}.
+   * Using {@link java.text.Normalizer.Form#NFC} for canonical decomposition, followed by canonical composition.
+   * <p>
+   * Examples:
+   * <pre><code class='java'>
+   * // assertion succeeds
+   * assertThat(&quot;\u00C4&quot;).isEqualToNormalizingUnicode(&quot;\u0041\u0308&quot;);
+   * // assertion fails
+   * assertThat(&quot;\u0041\u0308&quot;).isEqualToNormalizingUnicode(&quot;\u0041\u0308&quot;); </code></pre>
+   *
+   * @param info contains information about the assertion.
+   * @param actual the actual {@code CharSequence}.
+   * @param expected the expected {@code CharSequence}.
+   * @throws AssertionError if the given {@code CharSequence}s are not equal.
+   * @since 3.19.0
+   */
+  public void assertEqualsToNormalizingUnicode(AssertionInfo info, CharSequence actual, CharSequence expected) {
+    if (actual != null) checkCharSequenceIsNotNull(expected);
+    String normalizedActual = Normalizer.normalize(actual, Normalizer.Form.NFC);
+    String normalizedExpected = Normalizer.normalize(expected, Normalizer.Form.NFC);
+    if (!java.util.Objects.equals(normalizedActual, normalizedExpected))
+      throw failures.failure(info, shouldBeEqualNormalizingUnicode(actual, expected, normalizedActual, normalizedExpected), normalizedActual, normalizedExpected);
+  }
+
   /**
    * Verifies that actual {@code CharSequence}s contains only once the given sequence.
    *
diff --git a/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isEqualToNormalizingUnicode_Test.java b/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isEqualToNormalizingUnicode_Test.java
new file mode 100644
index 000000000..6d8cc5a3a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isEqualToNormalizingUnicode_Test.java
@@ -0,0 +1,31 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.charsequence;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.CharSequenceAssert;
+import org.assertj.core.api.CharSequenceAssertBaseTest;
+
+class CharSequenceAssert_isEqualToNormalizingUnicode_Test extends CharSequenceAssertBaseTest {
+
+  @Override
+  protected CharSequenceAssert invoke_api_method() {
+    return assertions.isEqualToNormalizingUnicode("Ä");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(strings).assertEqualsToNormalizingUnicode(getInfo(assertions), getActual(assertions), "Ä");
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeEqualNormalizingUnicode_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeEqualNormalizingUnicode_create_Test.java
new file mode 100644
index 000000000..d093a56a4
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeEqualNormalizingUnicode_create_Test.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldBeEqualNormalizingUnicode.shouldBeEqualNormalizingUnicode;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+
+import org.assertj.core.internal.TestDescription;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for
+ * <code>{@link org.assertj.core.error.ShouldBeEqualNormalizingUnicode#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>
+ * .
+ *
+ * @author Julieta Navarro
+ */
+public class ShouldBeEqualNormalizingUnicode_create_Test {
+  @Test
+  void should_create_error_message() {
+    // GIVEN
+    ErrorMessageFactory factory = shouldBeEqualNormalizingUnicode("\u00C4", "\u0041", "Ä", "A");
+    // WHEN
+    String message = factory.create(new TestDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting actual:%n" +
+                                   "  \"\u00C4\"%n" +
+                                   "to be equal to:%n" +
+                                   "  \"\u0041\"%n" +
+                                   "after they have been normalized according to the Normalizer.Form.NFC form.%n" +
+                                   "The normalized strings should be equal.%n" +
+                                   "Normalized actual  : \"Ä\"%n" +
+                                   "Normalized expected: \"A\""));
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertEqualsNormalizingUnicode_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertEqualsNormalizingUnicode_Test.java
new file mode 100644
index 000000000..2dd97a6bb
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertEqualsNormalizingUnicode_Test.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.internal.strings;
+
+import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.error.ShouldBeEqualNormalizingUnicode.shouldBeEqualNormalizingUnicode;
+import static org.assertj.core.internal.ErrorMessages.charSequenceToLookForIsNull;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.verify;
+
+import java.util.stream.Stream;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.StringsBaseTest;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+/**
+ * Tests for <code>{@link org.assertj.core.internal.Strings#assertEqualsToNormalizingUnicode(AssertionInfo, CharSequence, CharSequence)} (org.assertj.core.api.AssertionInfo, CharSequence, CharSequence)} </code>.
+ *
+ * @author Julieta Navarro
+ */
+public class Strings_assertEqualsNormalizingUnicode_Test extends StringsBaseTest {
+  @Test
+  void should_fail_if_actual_is_not_null_and_expected_is_null() {
+    assertThatNullPointerException().isThrownBy(() -> strings.assertEqualsToNormalizingUnicode(someInfo(), "\u0041", null))
+                                    .withMessage(charSequenceToLookForIsNull());
+  }
+
+  @Test
+  void should_fail_if_both_Strings_are_not_equal_after_unicode_is_normalized() {
+    // GIVEN
+    String actual = "\u00C4";
+    String expected = "\u0062";
+    AssertionInfo info = someInfo();
+    // WHEN
+    expectAssertionError(() -> strings.assertEqualsToNormalizingUnicode(info, actual, expected));
+    // THEN
+    verify(failures).failure(info, shouldBeEqualNormalizingUnicode(actual, expected, "Ä", expected), "Ä", expected);
+  }
+
+  @ParameterizedTest
+  @MethodSource("equalNormalizingUnicodeGenerator")
+  void should_pass_if_both_Strings_are_equal_after_unicode_is_normalized(String actual, String expected) {
+    strings.assertEqualsToNormalizingUnicode(someInfo(), actual, expected);
+  }
+
+  public static Stream<Arguments> equalNormalizingUnicodeGenerator() {
+    return Stream.of(
+                     Arguments.of("A", "A"),
+                     Arguments.of("", ""),
+                     // Ä, Ä
+                     Arguments.of("\u00C4", "\u0041\u0308"),
+                     // Amélie, Amélie
+                     Arguments.of("\u0041\u006d\u00e9\u006c\u0069\u0065", "\u0041\u006d\u0065\u0301\u006c\u0069\u0065"),
+                     // ñ, ñ
+                     Arguments.of("\u00F1", "\u006E\u0303"),
+                     Arguments.of("Zoë", "Zoë"),
+                     Arguments.of("sabiá", "sabiá"),
+                     // ﬃ, ﬃ
+                     Arguments.of("ﬃ", "\uFB03"),
+                     // schön, schön
+                     Arguments.of("schön", "scho\u0308n"));
+  }
+}
