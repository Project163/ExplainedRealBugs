diff --git a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 27dfaac90..7a05ada9f 100644
--- a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -19,6 +19,9 @@ import java.util.Date;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
@@ -194,7 +197,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    *                   .ignoringActualNullFields()
    *                   .isEqualTo(sherlock);
    *
-   * // assertion fails as name and home.address.street fields are populated for sherlock but not noName.
+   * // assertion fails as name and home.address.street fields are populated for sherlock but not for noName.
    * assertThat(sherlock).usingRecursiveComparison()
    *                     .ignoringActualNullFields()
    *                     .isEqualTo(noName);</code></pre>
@@ -207,6 +210,58 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Makes the recursive comparison to ignore all <b>actual empty optional fields</b> (including {@link Optional}, {@link OptionalInt}, {@link OptionalLong} and {@link OptionalDouble}),
+   * note that the expected object empty optional fields are not ignored, this only applies to actual's fields.
+   * <p>
+   * Example:
+   * <pre><code class='java'> public class Person {
+   *   String name;
+   *   OptionalInt age;
+   *   OptionalLong id;
+   *   OptionalDouble height;
+   *   Home home = new Home();
+   * }
+   *
+   * public class Home {
+   *   String address;
+   *   Optional&lt;String&gt; phone;
+   * }
+   *
+   * Person homerWithoutDetails = new Person("Homer Simpson");
+   * homerWithoutDetails.home.address.street = "Evergreen Terrace";
+   * homerWithoutDetails.home.address.number = 742;
+   * homerWithoutDetails.home.phone = Optional.empty();
+   * homerWithoutDetails.age = OptionalInt.empty();
+   * homerWithoutDetails.id = OptionalLong.empty();
+   * homerWithoutDetails.height = OptionalDouble.empty();
+   *
+   * Person homerWithDetails = new Person("Homer Simpson");
+   * homerWithDetails.home.address.street = "Evergreen Terrace";
+   * homerWithDetails.home.address.number = 742;
+   * homerWithDetails.home.phone = Optional.of("(939) 555-0113");
+   * homerWithDetails.age = OptionalInt.of(39);
+   * homerWithDetails.id = OptionalLong.of(123456);
+   * homerWithDetails.height = OptionalDouble.of(1.83);
+   *
+   * // assertion succeeds as phone is ignored in the comparison
+   * assertThat(homerWithoutDetails).usingRecursiveComparison()
+   *                                .ignoringActualEmptyOptionalFields()
+   *                                .isEqualTo(homerWithDetails);
+   *
+   * // assertion fails as phone, age, id and height are not ignored and are populated for homerWithDetails but not for homerWithoutDetails.
+   * assertThat(homerWithDetails).usingRecursiveComparison()
+   *                             .ignoringActualEmptyOptionalFields()
+   *                             .isEqualTo(homerWithoutDetails);</code></pre>
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   */
+  @CheckReturnValue
+  public SELF ignoringActualEmptyOptionalFields() {
+    recursiveComparisonConfiguration.setIgnoreAllActualEmptyOptionalFields(true);
+    return myself;
+  }
+
   /**
    * Makes the recursive comparison to ignore all <b>expected null fields</b>.
    * <p>
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index 8e868fcbd..794ba1ce6 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -23,6 +23,9 @@ import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map;
 import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 import java.util.SortedMap;
 import java.util.SortedSet;
 import java.util.stream.Stream;
@@ -38,7 +41,6 @@ final class DualValue {
   final Object expected;
   private final int hashCode;
 
-
   DualValue(List<String> path, Object actual, Object expected) {
     this.path = newArrayList(path);
     this.concatenatedPath = join(path).with(".");
@@ -100,6 +102,41 @@ final class DualValue {
     return actual instanceof Optional;
   }
 
+  public boolean isActualFieldAnOptionalInt() {
+    return actual instanceof OptionalInt;
+  }
+
+  public boolean isActualFieldAnOptionalLong() {
+    return actual instanceof OptionalLong;
+  }
+
+  public boolean isActualFieldAnOptionalDouble() {
+    return actual instanceof OptionalDouble;
+  }
+
+  public boolean isActualFieldAnEmptyOptionalOfAnyType() {
+    return isActualFieldAnEmptyOptional()
+           || isActualFieldAnEmptyOptionalInt()
+           || isActualFieldAnEmptyOptionalLong()
+           || isActualFieldAnEmptyOptionalDouble();
+  }
+
+  private boolean isActualFieldAnEmptyOptional() {
+    return isActualFieldAnOptional() && ((Optional<?>) actual).isPresent() == false;
+  }
+
+  private boolean isActualFieldAnEmptyOptionalInt() {
+    return isActualFieldAnOptionalInt() && ((OptionalInt) actual).isPresent() == false;
+  }
+
+  private boolean isActualFieldAnEmptyOptionalLong() {
+    return isActualFieldAnOptionalLong() && ((OptionalLong) actual).isPresent() == false;
+  }
+
+  private boolean isActualFieldAnEmptyOptionalDouble() {
+    return isActualFieldAnOptionalDouble() && ((OptionalDouble) actual).isPresent() == false;
+  }
+
   public boolean isExpectedFieldAnOptional() {
     return expected instanceof Optional;
   }
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 03aeb213e..091f6d21b 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -45,6 +45,7 @@ public class RecursiveComparisonConfiguration {
 
   // fields to ignore section
   private boolean ignoreAllActualNullFields = false;
+  private boolean ignoreAllActualEmptyOptionalFields = false;
   private boolean ignoreAllExpectedNullFields = false;
   private Set<FieldLocation> ignoredFields = new LinkedHashSet<>();
   private List<Pattern> ignoredFieldsRegexes = new ArrayList<>();
@@ -102,6 +103,22 @@ public class RecursiveComparisonConfiguration {
     return ignoreAllActualNullFields;
   }
 
+  /**
+   * Sets whether actual empty optional fields are ignored in the recursive comparison.
+   * <p>
+   * See {@link RecursiveComparisonAssert#ignoringActualNullFields()} for code examples.
+   *
+   * @param ignoringAllActualEmptyOptionalFields whether to ignore actual empty optional fields in the recursive comparison
+   */
+  public void setIgnoreAllActualEmptyOptionalFields(boolean ignoringAllActualEmptyOptionalFields) {
+    this.ignoreAllActualEmptyOptionalFields = ignoringAllActualEmptyOptionalFields;
+  }
+
+  @VisibleForTesting
+  boolean getIgnoreAllActualEmptyOptionalFields() {
+    return ignoreAllActualEmptyOptionalFields;
+  }
+
   /**
    * Sets whether actual null fields are ignored in the recursive comparison.
    * <p>
@@ -375,6 +392,7 @@ public class RecursiveComparisonConfiguration {
   public String multiLineDescription(Representation representation) {
     StringBuilder description = new StringBuilder();
     describeIgnoreAllActualNullFields(description);
+    describeIgnoreAllActualEmptyOptionalFields(description);
     describeIgnoreAllExpectedNullFields(description);
     describeIgnoredFields(description);
     describeIgnoredFieldsRegexes(description);
@@ -393,12 +411,12 @@ public class RecursiveComparisonConfiguration {
     String concatenatedPath = dualValue.concatenatedPath;
     return matchesAnIgnoredField(concatenatedPath)
            || matchesAnIgnoredFieldRegex(concatenatedPath)
-           || shouldIgnoreNotEvaluatingFieldName(dualValue);
+           || shouldIgnoreFieldButWithoutNeedingEvaluatingFieldName(dualValue);
   }
 
   Set<String> getNonIgnoredActualFieldNames(DualValue dualValue) {
     Set<String> actualFieldsNames = Objects.getFieldsNames(dualValue.actual.getClass());
-    // we are doing the same as shouldIgnore(DualValue dualKey) but in two steps for performance reasons:
+    // we are doing the same as shouldIgnore(DualValue dualValue) but in two steps for performance reasons:
     // - we filter first ignored field by names that don't need building DualValues
     // - then we filter field DualValues with the remaining criteria (shouldIgnoreNotEvalutingFieldName)
     // DualValues are built introspecting fields which is expensive.
@@ -407,7 +425,7 @@ public class RecursiveComparisonConfiguration {
                             .filter(fieldName -> !shouldIgnore(dualValue.path, fieldName))
                             .map(fieldName -> dualValueForField(dualValue, fieldName))
                             // evaluate field value ignoring criteria
-                            .filter(fieldDualValue -> !shouldIgnoreNotEvaluatingFieldName(fieldDualValue))
+                            .filter(fieldDualValue -> !shouldIgnoreFieldButWithoutNeedingEvaluatingFieldName(fieldDualValue))
                             // back to field name
                             .map(DualValue::getFieldName)
                             .filter(fieldName -> !fieldName.isEmpty())
@@ -416,8 +434,10 @@ public class RecursiveComparisonConfiguration {
 
   // non public stuff
 
-  private boolean shouldIgnoreNotEvaluatingFieldName(DualValue dualKey) {
-    return matchesAnIgnoredNullField(dualKey) || matchesAnIgnoredFieldType(dualKey);
+  private boolean shouldIgnoreFieldButWithoutNeedingEvaluatingFieldName(DualValue dualValue) {
+    return matchesAnIgnoredNullField(dualValue)
+           || matchesAnIgnoredFieldType(dualValue)
+           || matchesAnIgnoredEmptyOptionalField(dualValue);
   }
 
   private boolean shouldIgnore(List<String> parentConcatenatedPath, String fieldName) {
@@ -464,10 +484,10 @@ public class RecursiveComparisonConfiguration {
     return matchesAnIgnoredOverriddenEqualsRegex(clazz) || matchesAnIgnoredOverriddenEqualsType(clazz);
   }
 
-  boolean shouldIgnoreCollectionOrder(DualValue dualKey) {
+  boolean shouldIgnoreCollectionOrder(DualValue dualValue) {
     return ignoreCollectionOrder
-           || matchesAnIgnoredCollectionOrderInField(dualKey)
-           || matchesAnIgnoredCollectionOrderInFieldRegex(dualKey);
+           || matchesAnIgnoredCollectionOrderInField(dualValue)
+           || matchesAnIgnoredCollectionOrderInFieldRegex(dualValue);
   }
 
   private void describeIgnoredFieldsRegexes(StringBuilder description) {
@@ -490,6 +510,11 @@ public class RecursiveComparisonConfiguration {
     if (ignoreAllActualNullFields) description.append(format("- all actual null fields were ignored in the comparison%n"));
   }
 
+  private void describeIgnoreAllActualEmptyOptionalFields(StringBuilder description) {
+    if (getIgnoreAllActualEmptyOptionalFields())
+      description.append(format("- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n"));
+  }
+
   private void describeIgnoreAllExpectedNullFields(StringBuilder description) {
     if (ignoreAllExpectedNullFields) description.append(format("- all expected null fields were ignored in the comparison%n"));
   }
@@ -561,9 +586,9 @@ public class RecursiveComparisonConfiguration {
     return ignoredOverriddenEqualsForTypes.contains(clazz);
   }
 
-  private boolean matchesAnIgnoredOverriddenEqualsField(DualValue dualKey) {
+  private boolean matchesAnIgnoredOverriddenEqualsField(DualValue dualValue) {
     return ignoredOverriddenEqualsForFields.stream()
-                                           .anyMatch(fieldLocation -> fieldLocation.matches(dualKey.concatenatedPath));
+                                           .anyMatch(fieldLocation -> fieldLocation.matches(dualValue.concatenatedPath));
   }
 
   private boolean matchesAnIgnoredNullField(DualValue dualValue) {
@@ -571,16 +596,21 @@ public class RecursiveComparisonConfiguration {
            || (ignoreAllExpectedNullFields && dualValue.expected == null);
   }
 
+  private boolean matchesAnIgnoredEmptyOptionalField(DualValue dualValue) {
+    return ignoreAllActualEmptyOptionalFields
+           && dualValue.isActualFieldAnEmptyOptionalOfAnyType();
+  }
+
   private boolean matchesAnIgnoredFieldRegex(String fieldConcatenatedPath) {
     return ignoredFieldsRegexes.stream()
                                .anyMatch(regex -> regex.matcher(fieldConcatenatedPath).matches());
   }
 
-  private boolean matchesAnIgnoredFieldType(DualValue dualKey) {
-    Object actual = dualKey.actual;
+  private boolean matchesAnIgnoredFieldType(DualValue dualValue) {
+    Object actual = dualValue.actual;
     if (actual != null) return ignoredTypes.contains(actual.getClass());
-    Object expected = dualKey.expected;
-    // actual is null => we can't evaluate its type, we can only reliably check dualKey.expected's type if
+    Object expected = dualValue.expected;
+    // actual is null => we can't evaluate its type, we can only reliably check dualValue.expected's type if
     // strictTypeChecking is enabled which guarantees expected is of the same type.
     if (strictTypeChecking && expected != null) return ignoredTypes.contains(expected.getClass());
     // if strictTypeChecking is disabled, we can't safely ignore the field (if we did, we would ignore all null fields!).
@@ -592,14 +622,14 @@ public class RecursiveComparisonConfiguration {
                         .anyMatch(fieldLocation -> fieldLocation.matches(fieldConcatenatedPath));
   }
 
-  private boolean matchesAnIgnoredCollectionOrderInField(DualValue dualKey) {
+  private boolean matchesAnIgnoredCollectionOrderInField(DualValue dualValue) {
     return ignoredCollectionOrderInFields.stream()
-                                         .anyMatch(fieldLocation -> fieldLocation.matches(dualKey.concatenatedPath));
+                                         .anyMatch(fieldLocation -> fieldLocation.matches(dualValue.concatenatedPath));
   }
 
-  private boolean matchesAnIgnoredCollectionOrderInFieldRegex(DualValue dualKey) {
+  private boolean matchesAnIgnoredCollectionOrderInFieldRegex(DualValue dualValue) {
     return ignoredCollectionOrderInFieldsMatchingRegexes.stream()
-                                                        .anyMatch(regex -> regex.matcher(dualKey.concatenatedPath).matches());
+                                                        .anyMatch(regex -> regex.matcher(dualValue.concatenatedPath).matches());
   }
 
   private String describeIgnoredFields() {
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValueUtil.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValueUtil.java
index a01a652cc..f25864c40 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/DualValueUtil.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValueUtil.java
@@ -26,7 +26,7 @@ public class DualValueUtil {
   }
 
   static List<String> randomPath() {
-    return list(RandomStringUtils.random(RandomUtils.nextInt(0, 10)));
+    return list(RandomStringUtils.random(RandomUtils.nextInt(01, 10), true, false));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_optionalValues_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_optionalValues_Test.java
index 11f07d14b..ba5b2684d 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_optionalValues_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_optionalValues_Test.java
@@ -17,6 +17,9 @@ import static org.assertj.core.util.Lists.list;
 
 import java.util.List;
 import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 import java.util.stream.Stream;
 
 import org.apache.commons.lang3.tuple.Pair;
@@ -33,9 +36,9 @@ public class DualValue_optionalValues_Test {
     // GIVEN
     DualValue dualValue = new DualValue(PATH, Optional.empty(), "abc");
     // WHEN
-    boolean actualFieldIsArray = dualValue.isActualFieldAnOptional();
+    boolean actualFieldIsOptional = dualValue.isActualFieldAnOptional();
     // THEN
-    assertThat(actualFieldIsArray).isTrue();
+    assertThat(actualFieldIsOptional).isTrue();
   }
 
   @ParameterizedTest
@@ -44,9 +47,72 @@ public class DualValue_optionalValues_Test {
     // GIVEN
     DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), actualField);
     // WHEN
-    boolean actualFieldIsArray = dualValue.isActualFieldAnOptional();
+    boolean actualFieldIsOptional = dualValue.isActualFieldAnOptional();
     // THEN
-    assertThat(actualFieldIsArray).isFalse();
+    assertThat(actualFieldIsOptional).isFalse();
+  }
+
+  @Test
+  public void isActualFieldAnOptionalInt_should_return_true_when_actual_is_an_optionalInt() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, OptionalInt.empty(), "abc");
+    // WHEN
+    boolean actualFieldIsOptionalInt = dualValue.isActualFieldAnOptionalInt();
+    // THEN
+    assertThat(actualFieldIsOptionalInt).isTrue();
+  }
+
+  @ParameterizedTest
+  @MethodSource("nonOptional")
+  public void isActualFieldAnOptionalInt_should_return_false_when_actual_is_not_an_optionalInt(Object actualField) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), actualField);
+    // WHEN
+    boolean actualFieldIsOptionalInt = dualValue.isActualFieldAnOptionalInt();
+    // THEN
+    assertThat(actualFieldIsOptionalInt).isFalse();
+  }
+
+  @Test
+  public void isActualFieldAnOptionalLong_should_return_true_when_actual_is_an_optionalLong() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, OptionalLong.empty(), "abc");
+    // WHEN
+    boolean actualFieldIsOptionalLong = dualValue.isActualFieldAnOptionalLong();
+    // THEN
+    assertThat(actualFieldIsOptionalLong).isTrue();
+  }
+
+  @ParameterizedTest
+  @MethodSource("nonOptional")
+  public void isActualFieldAnOptionalLong_should_return_false_when_actual_is_not_an_optionalLong(Object actualField) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), actualField);
+    // WHEN
+    boolean actualFieldIsOptionalLong = dualValue.isActualFieldAnOptionalLong();
+    // THEN
+    assertThat(actualFieldIsOptionalLong).isFalse();
+  }
+
+  @Test
+  public void isActualFieldAnOptionalDouble_should_return_true_when_actual_is_an_optionalDouble() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, OptionalDouble.empty(), "abc");
+    // WHEN
+    boolean actualFieldIsOptionalDouble = dualValue.isActualFieldAnOptionalDouble();
+    // THEN
+    assertThat(actualFieldIsOptionalDouble).isTrue();
+  }
+
+  @ParameterizedTest
+  @MethodSource("nonOptional")
+  public void isActualFieldAnOptionalDouble_should_return_false_when_actual_is_not_an_optionalDouble(Object actualField) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), actualField);
+    // WHEN
+    boolean actualFieldIsOptionalDouble = dualValue.isActualFieldAnOptionalDouble();
+    // THEN
+    assertThat(actualFieldIsOptionalDouble).isFalse();
   }
 
   @Test
@@ -54,9 +120,9 @@ public class DualValue_optionalValues_Test {
     // GIVEN
     DualValue dualValue = new DualValue(PATH, "abc", Optional.of(""));
     // WHEN
-    boolean expectedFieldIsArray = dualValue.isExpectedFieldAnOptional();
+    boolean expectedFieldIsOptional = dualValue.isExpectedFieldAnOptional();
     // THEN
-    assertThat(expectedFieldIsArray).isTrue();
+    assertThat(expectedFieldIsOptional).isTrue();
   }
 
   @ParameterizedTest
@@ -65,13 +131,48 @@ public class DualValue_optionalValues_Test {
     // GIVEN
     DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), expectedField);
     // WHEN
-    boolean expectedFieldIsArray = dualValue.isExpectedFieldAnOptional();
+    boolean expectedFieldIsOptional = dualValue.isExpectedFieldAnOptional();
     // THEN
-    assertThat(expectedFieldIsArray).isFalse();
+    assertThat(expectedFieldIsOptional).isFalse();
   }
 
-  static Stream<Object> nonOptional() {
+  private static Stream<Object> nonOptional() {
     return Stream.of(123, null, "abc");
   }
 
+  @ParameterizedTest
+  @MethodSource("emptyOptionals")
+  public void isActualFieldAnEmptyOptionalOfAnyType_should_return_true_when_actual_is_an_empty_optional(Object optional) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, optional, "abc");
+    // WHEN
+    boolean actualFieldIsOptional = dualValue.isActualFieldAnEmptyOptionalOfAnyType();
+    // THEN
+    assertThat(actualFieldIsOptional).isTrue();
+  }
+
+  @ParameterizedTest
+  @MethodSource("populatedOptionals")
+  public void isActualFieldAnEmptyOptionalOfAnyType_should_return_false_when_actual_is_a_populated_optional(Object optional) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, optional, "abc");
+    // WHEN
+    boolean actualFieldIsOptional = dualValue.isActualFieldAnEmptyOptionalOfAnyType();
+    // THEN
+    assertThat(actualFieldIsOptional).isFalse();
+  }
+
+  private static Stream<Object> populatedOptionals() {
+    return Stream.of(Optional.of("123"),
+                     OptionalInt.of(123),
+                     OptionalLong.of(123L),
+                     OptionalDouble.of(123.0));
+  }
+
+  private static Stream<Object> emptyOptionals() {
+    return Stream.of(Optional.empty(),
+                     OptionalInt.empty(),
+                     OptionalLong.empty(),
+                     OptionalDouble.empty());
+  }
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
index fca5fcdea..2bb930353 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
@@ -93,6 +93,16 @@ public class RecursiveComparisonAssert_fluent_API_Test {
     assertThat(configuration.getIgnoreAllActualNullFields()).isTrue();
   }
 
+  @Test
+  public void should_allow_to_ignore_all_actual_empty_optional_fields() {
+    // WHEN
+    RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
+                                                                       .ignoringActualEmptyOptionalFields()
+                                                                       .getRecursiveComparisonConfiguration();
+    // THEN
+    assertThat(configuration.getIgnoreAllActualEmptyOptionalFields()).isTrue();
+  }
+
   @Test
   public void should_allow_to_ignore_fields() {
     // GIVEN
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
index ae0e7f1bb..b0b7a1c3b 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
@@ -18,6 +18,10 @@ import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.util.Date;
 import java.util.List;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
@@ -91,6 +95,77 @@ public class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends Rec
                      arguments(person7, person8, "same data, actual has null fields deep in its graph"));
   }
 
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
+  @MethodSource("recursivelyEqualObjectsIgnoringActualOptionalEmptyValues")
+  public void should_pass_when_actual_empty_optional_fields_are_ignored(Object actual,
+                                                                        Object expected,
+                                                                        @SuppressWarnings("unused") String testDescription) {
+    assertThat(actual).usingRecursiveComparison()
+                      .ignoringActualEmptyOptionalFields()
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> recursivelyEqualObjectsIgnoringActualOptionalEmptyValues() {
+    Person person1 = new Person("John");
+    person1.home.address.number = 1;
+    person1.phone = Optional.empty();
+    person1.age = OptionalInt.empty();
+    person1.id = OptionalLong.empty();
+    person1.weight = OptionalDouble.empty();
+
+    Person person2 = new Person("John");
+    person2.home.address.number = 1;
+    person2.phone = Optional.of("456");
+    person2.age = OptionalInt.of(33);
+    person2.id = OptionalLong.of(123456);
+    person2.weight = OptionalDouble.of(1.80);
+
+    Person person3 = new Person("John");
+    person3.home.address.number = 1;
+    person3.phone = Optional.empty();
+    person3.age = OptionalInt.empty();
+    person3.id = OptionalLong.empty();
+    person3.weight = OptionalDouble.empty();
+
+    Person person4 = new Person("John");
+    person4.home.address.number = 1;
+    person4.phone = null;
+    person4.age = null;
+    person4.id = null;
+    person4.weight = null;
+
+    return Stream.of(arguments(person1, person2, "same data and same type except for actual empty optional fields"),
+                     arguments(person1, person3, "same data, same type, both actual and expected have empty optional fields"),
+                     arguments(person1, person4, "same data and same type except for ignored optional fields"));
+  }
+
+  @Test
+  public void should_fail_when_actual_differs_from_expected_even_when_all_empty_optional_actual_fields_are_ignored() {
+    // GIVEN
+    Person actual = new Person("John");
+    actual.home.address.number = 1;
+    actual.phone = Optional.empty();
+    actual.age = OptionalInt.empty();
+    actual.id = OptionalLong.empty();
+    actual.weight = OptionalDouble.empty();
+
+    Person expected = new Person("John");
+    expected.home.address.number = 2;
+    expected.phone = Optional.of("123-456-789");
+    expected.age = OptionalInt.of(33);
+    expected.id = OptionalLong.of(123456);
+    expected.weight = OptionalDouble.of(1.80);
+
+    recursiveComparisonConfiguration.setIgnoreAllActualEmptyOptionalFields(true);
+
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+
+    // THEN
+    ComparisonDifference comparisonDifference = new ComparisonDifference(list("home.address.number"), 1, 2);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, comparisonDifference);
+  }
+
   @Test
   public void should_fail_when_actual_differs_from_expected_even_when_all_null_actual_fields_are_ignored() {
     // GIVEN
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index c9bb73b12..a366bdb49 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -50,6 +50,16 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
     assertThat(multiLineDescription).contains(format("- all actual null fields were ignored in the comparison%n"));
   }
 
+  @Test
+  public void should_show_that_actual_empty_optional_fields_are_ignored() {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllActualEmptyOptionalFields(true);
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    assertThat(multiLineDescription).contains("- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)");
+  }
+
   @Test
   public void should_show_that_expected_null_fields_are_ignored() {
     // GIVEN
@@ -247,6 +257,7 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
   public void should_show_a_complete_multiline_description() {
     // GIVEN
     recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
+    recursiveComparisonConfiguration.setIgnoreAllActualEmptyOptionalFields(true);
     recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
     recursiveComparisonConfiguration.ignoreFields("foo", "bar", "foo.bar");
     recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("f.*", ".ba.", "..b%sr..");
@@ -267,6 +278,7 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
     // @format:off
     assertThat(multiLineDescription).isEqualTo(format(
                "- all actual null fields were ignored in the comparison%n" +
+               "- all actual empty optional fields were ignored in the comparison (including Optional, OptionalInt, OptionalLong and OptionalDouble)%n" +
                "- all expected null fields were ignored in the comparison%n" +
                "- the following fields were ignored in the comparison: foo, bar, foo.bar%n" +
                "- the fields matching the following regexes were ignored in the comparison: f.*, .ba., ..b%%sr..%n"+
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
index 3aa1e9ab0..7765631ed 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
@@ -22,6 +22,10 @@ import static org.junit.jupiter.params.provider.Arguments.arguments;
 import java.time.ZonedDateTime;
 import java.util.Date;
 import java.util.List;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 import java.util.Set;
 import java.util.UUID;
 import java.util.regex.Pattern;
@@ -73,6 +77,26 @@ public class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
 
   }
 
+  @ParameterizedTest(name = "{0} should be ignored")
+  @MethodSource("ignoringActualOptionalEmptyFieldsSource")
+  public void should_ignore_actual_optional_empty_fields(DualValue dualValue) {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllActualEmptyOptionalFields(true);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldIgnore(dualValue);
+    // THEN
+    assertThat(ignored).as("%s should be ignored", dualValue).isTrue();
+  }
+
+  private static Stream<Arguments> ignoringActualOptionalEmptyFieldsSource() {
+    return Stream.of(arguments(dualValue(Optional.empty(), "John")),
+                     arguments(dualValue(Optional.empty(), Optional.of("John"))),
+                     arguments(dualValue(OptionalInt.empty(), OptionalInt.of(123))),
+                     arguments(dualValue(OptionalLong.empty(), OptionalLong.of(123l))),
+                     arguments(dualValue(OptionalDouble.empty(), OptionalDouble.of(123.0))));
+
+  }
+
   @ParameterizedTest(name = "{0} should be ignored")
   @MethodSource("ignoringNullExpectedFieldsSource")
   public void should_ignore_expected_null_fields(DualValue dualValue) {
diff --git a/src/test/java/org/assertj/core/internal/objects/data/Person.java b/src/test/java/org/assertj/core/internal/objects/data/Person.java
index d01a9cfb3..3b130bd15 100644
--- a/src/test/java/org/assertj/core/internal/objects/data/Person.java
+++ b/src/test/java/org/assertj/core/internal/objects/data/Person.java
@@ -13,10 +13,18 @@
 package org.assertj.core.internal.objects.data;
 
 import java.util.Date;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 
 public class Person {
   public Date dateOfBirth;
   public String name;
+  public Optional<String> phone;
+  public OptionalInt age;
+  public OptionalLong id;
+  public OptionalDouble weight;
   public Home home = new Home();
   public Person neighbour;
 
@@ -28,6 +36,7 @@ public class Person {
 
   @Override
   public String toString() {
-    return "Person [name=" + name + ", home=" + home + "]";
+    return String.format("Person [dateOfBirth=%s, name=%s, phone=%s, home=%s]", dateOfBirth, name, phone, home);
   }
+
 }
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/objects/data/PersonDto.java b/src/test/java/org/assertj/core/internal/objects/data/PersonDto.java
index 9eb76fa5c..1c1cfcdb6 100644
--- a/src/test/java/org/assertj/core/internal/objects/data/PersonDto.java
+++ b/src/test/java/org/assertj/core/internal/objects/data/PersonDto.java
@@ -13,10 +13,18 @@
 package org.assertj.core.internal.objects.data;
 
 import java.util.Date;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 
 public class PersonDto {
   public Date dateOfBirth;
   public String name;
+  public Optional<String> phone;
+  public OptionalInt age;
+  public OptionalLong id;
+  public OptionalDouble weight;
   public HomeDto home = new HomeDto();
   public PersonDto neighbour;
 
