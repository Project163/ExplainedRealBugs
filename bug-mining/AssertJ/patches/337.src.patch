diff --git a/src/main/java/org/assertj/core/api/AbstractFileAssert.java b/src/main/java/org/assertj/core/api/AbstractFileAssert.java
index 428b7daca..37aefc419 100644
--- a/src/main/java/org/assertj/core/api/AbstractFileAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractFileAssert.java
@@ -41,6 +41,7 @@ import org.assertj.core.util.VisibleForTesting;
  * @author Mikhail Mazursky
  * @author Jean-Christophe Gay
  * @author Valeriy Vyrva
+ * @author Nikolaos Georgiou
  */
 public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>> extends AbstractAssert<SELF, File> {
 
@@ -236,7 +237,7 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * @throws UncheckedIOException if an I/O error occurs.
    * @throws AssertionError if the content of the actual {@code File} is not equal to the content of the given one.
    *
-   * @deprecated use {@link #hasSameContentAs(File)} instead
+   * @deprecated use {@link #hasSameTextualContentAs(File)} instead
    */
   @Deprecated
   public SELF hasContentEqualTo(File expected) {
@@ -244,6 +245,8 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
   }
 
   /**
+   * @deprecated use {@link #hasSameTextualContentAs(File)} instead.
+   * <p>
    * Verifies that the content of the actual {@code File} is equal to the content of the given one.
    * The charset to use when reading the actual file can be provided with {@link #usingCharset(Charset)} or
    * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
@@ -260,7 +263,7 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * // The following assertion succeeds (default charset is used):
    * assertThat(xFile).hasSameContentAs(xFileClone);
    * // The following assertion succeeds (UTF-8 charset is used to read xFile):
-   * assertThat(xFileUTF8).usingCharset("UTF-8").hasContent(xFileClone);
+   * assertThat(xFileUTF8).usingCharset("UTF-8").hasSameContentAs(xFileClone);
    *
    * // The following assertion fails:
    * assertThat(xFile).hasSameContentAs(xFileFrench);</code></pre>
@@ -274,11 +277,79 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * @throws UncheckedIOException if an I/O error occurs.
    * @throws AssertionError if the content of the actual {@code File} is not equal to the content of the given one.
    */
+  @Deprecated
   public SELF hasSameContentAs(File expected) {
+    return hasSameTextualContentAs(expected);
+  }
+
+  /**
+   * Verifies that the content of the actual {@code File} is equal to the content of the given one.
+   * The charset to use when reading the actual file can be provided with {@link #usingCharset(Charset)} or
+   * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
+   * {@link Charset#defaultCharset()}) will be used.
+   *
+   * Examples:
+   * <pre><code class="java"> // use the default charset
+   * File xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes()).toFile();
+   * File xFileClone = Files.write(Paths.get("xfile-clone.txt"), "The Truth Is Out There".getBytes()).toFile();
+   * File xFileFrench = Files.write(Paths.get("xfile-french.txt"), "La Vérité Est Ailleurs".getBytes()).toFile();
+   * // use UTF-8 charset
+   * File xFileUTF8 = Files.write(Paths.get("xfile-clone.txt"), Arrays.asList("The Truth Is Out There"), StandardCharsets.UTF_8).toFile();
+   *
+   * // The following assertion succeeds (default charset is used):
+   * assertThat(xFile).hasSameTextualContentAs(xFileClone);
+   * // The following assertion succeeds (UTF-8 charset is used to read xFile):
+   * assertThat(xFileUTF8).usingCharset("UTF-8").hasSameTextualContentAs(xFileClone);
+   *
+   * // The following assertion fails:
+   * assertThat(xFile).hasSameTextualContentAs(xFileFrench);</code></pre>
+   *
+   * @param expected the given {@code File} to compare the actual {@code File} to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given {@code File} is {@code null}.
+   * @throws IllegalArgumentException if the given {@code File} is not an existing file.
+   * @throws AssertionError if the actual {@code File} is {@code null}.
+   * @throws AssertionError if the actual {@code File} is not an existing file.
+   * @throws UncheckedIOException if an I/O error occurs.
+   * @throws AssertionError if the content of the actual {@code File} is not equal to the content of the given one.
+   * @since 3.15
+   */
+  public SELF hasSameTextualContentAs(File expected) {
     files.assertSameContentAs(info, actual, charset, expected, Charset.defaultCharset());
     return myself;
   }
 
+  /**
+   * Verifies that the content of the actual {@code File} is equal to the content of the given one, the comparison is done at the binary level.<br>
+   * For text files, use {@link #hasSameTextualContentAs(File)}.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // The first two files have the same contents, the third does not
+   * File aFile = Files.write(Paths.get("a-file.bin"), new byte[] { 42 }).toFile();
+   * File bFile = Files.write(Paths.get("b-file.bin"), new byte[] { 42 }).toFile();
+   * File cFile = Files.write(Paths.get("c-file.bin"), new byte[] { 24 }).toFile();
+   *
+   * // The following assertion succeeds:
+   * assertThat(aFile).hasSameBinaryContentAs(bFile);
+   *
+   * // The following assertion fails:
+   * assertThat(aFile).hasSameBinaryContent(cFile);</code></pre>
+   *
+   * @param expected the given {@code File} to compare the actual {@code File} to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given {@code File} is {@code null}.
+   * @throws IllegalArgumentException if the given {@code File} is not an existing file.
+   * @throws AssertionError if the actual {@code File} is {@code null}.
+   * @throws AssertionError if the actual {@code File} is not an existing file.
+   * @throws UncheckedIOException if an I/O error occurs.
+   * @throws AssertionError if the content of the actual {@code File} is not equal to the content of the given one.
+   * @since 3.15
+   */
+  public SELF hasSameBinaryContentAs(File expected) {
+    files.assertSameBinaryContentAs(info, actual, expected);
+    return myself;
+  }
+
   /**
    * Verifies that the content of the actual {@code File} is the same as the expected one, the expected {@code File} being read with the given charset while
    * the charset used to read the actual path can be provided with {@link #usingCharset(Charset)} or
@@ -288,13 +359,13 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * Examples:
    * <pre><code class="java"> File fileUTF8 = Files.write(Paths.get("actual"), Collections.singleton("Gerçek"), StandardCharsets.UTF_8).toFile();
    * Charset turkishCharset = Charset.forName("windows-1254");
-   * File fileTurkischCharset = Files.write(Paths.get("expected"), Collections.singleton("Gerçek"), turkishCharset).toFile();
+   * File fileTurkishCharset = Files.write(Paths.get("expected"), Collections.singleton("Gerçek"), turkishCharset).toFile();
    *
    * // The following assertion succeeds:
-   * assertThat(fileUTF8).usingCharset(StandardCharsets.UTF_8).hasSameContentAs(fileTurkischCharset, turkishCharset);
+   * assertThat(fileUTF8).usingCharset(StandardCharsets.UTF_8).hasSameContentAs(fileTurkishCharset, turkishCharset);
    *
    * // The following assertion fails:
-   * assertThat(fileUTF8).usingCharset(StandardCharsets.UTF_8).hasSameContentAs(fileTurkischCharset, StandardCharsets.UTF_8);</code></pre>
+   * assertThat(fileUTF8).usingCharset(StandardCharsets.UTF_8).hasSameContentAs(fileTurkishCharset, StandardCharsets.UTF_8);</code></pre>
    *
    * @param expected the given {@code File} to compare the actual {@code File} to.
    * @param expectedCharset the {@link Charset} used to read the content of the expected file.
@@ -305,8 +376,41 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * @throws AssertionError if the actual {@code File} is not an existing file.
    * @throws UncheckedIOException if an I/O error occurs.
    * @throws AssertionError if the content of the actual {@code File} is not equal to the content of the given one.
+   * @deprecated use {@link #hasSameTextualContentAs(File, Charset)} instead
    */
+  @Deprecated
   public SELF hasSameContentAs(File expected, Charset expectedCharset) {
+    return hasSameTextualContentAs(expected, expectedCharset);
+  }
+
+  /**
+   * Verifies that the content of the actual {@code File} is the same as the expected one, the expected {@code File} being read with the given charset while
+   * the charset used to read the actual path can be provided with {@link #usingCharset(Charset)} or {@link #usingCharset(String)} prior to calling this method;
+   * if not, the platform's default charset (as returned by {@link Charset#defaultCharset()}) will be used.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> File fileUTF8 = Files.write(Paths.get("actual"), Collections.singleton("Gerçek"), StandardCharsets.UTF_8).toFile();
+   * Charset turkishCharset = Charset.forName("windows-1254");
+   * File fileTurkishCharset = Files.write(Paths.get("expected"), Collections.singleton("Gerçek"), turkishCharset).toFile();
+   *
+   * // The following assertion succeeds:
+   * assertThat(fileUTF8).usingCharset(StandardCharsets.UTF_8).hasSameTextualContentAs(fileTurkishCharset, turkishCharset);
+   *
+   * // The following assertion fails:
+   * assertThat(fileUTF8).usingCharset(StandardCharsets.UTF_8).hasSameTextualContentAs(fileTurkishCharset, StandardCharsets.UTF_8);</code></pre>
+   *
+   * @param expected the given {@code File} to compare the actual {@code File} to.
+   * @param expectedCharset the {@link Charset} used to read the content of the expected file.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given {@code File} is {@code null}.
+   * @throws IllegalArgumentException if the given {@code File} is not an existing file.
+   * @throws AssertionError if the actual {@code File} is {@code null}.
+   * @throws AssertionError if the actual {@code File} is not an existing file.
+   * @throws UncheckedIOException if an I/O error occurs.
+   * @throws AssertionError if the content of the actual {@code File} is not equal to the content of the given one.
+   * @since 3.13
+   */
+  public SELF hasSameTextualContentAs(File expected, Charset expectedCharset) {
     files.assertSameContentAs(info, actual, charset, expected, expectedCharset);
     return myself;
   }
diff --git a/src/main/java/org/assertj/core/api/AbstractPathAssert.java b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
index 6bf5ab029..8ef020be1 100644
--- a/src/main/java/org/assertj/core/api/AbstractPathAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
@@ -95,6 +95,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
   }
 
   /**
+   * @deprecated use {@link #hasSameTextualContentAs(Path)} instead
+   * <p>
    * Verifies that the content of the actual {@code Path} is the same as the given one (both paths must be a readable
    * files).
    * The charset to use when reading the actual path can be provided with {@link #usingCharset(Charset)} or
@@ -124,7 +126,43 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @throws AssertionError if the content of the actual {@code Path} is not equal to the content of the given one.
    * @throws PathsException if an I/O error occurs.
    */
+  @Deprecated
   public SELF hasSameContentAs(Path expected) {
+    return hasSameTextualContentAs(expected);
+  }
+
+  /**
+   * Verifies that the content of the actual {@code Path} is the same as the given one (both paths must be a readable
+   * files).
+   * The charset to use when reading the actual path can be provided with {@link #usingCharset(Charset)} or
+   * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
+   * {@link Charset#defaultCharset()}) will be used.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // use the default charset
+   * Path xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes());
+   * Path xFileUTF8 = Files.write(Paths.get("xfile-clone.txt"), "The Truth Is Out There".getBytes("UTF-8"));
+   * Path xFileClone = Files.write(Paths.get("xfile-clone.txt"), "The Truth Is Out There".getBytes());
+   * Path xFileFrench = Files.write(Paths.get("xfile-french.txt"), "La Vérité Est Ailleurs".getBytes());
+   *
+   * // The following assertion succeeds (default charset is used):
+   * assertThat(xFile).hasSameTextualContentAs(xFileClone);
+   * // The following assertion succeeds (UTF-8 charset is used to read xFile):
+   * assertThat(xFileUTF8).usingCharset("UTF-8").hasContent(xFileClone);
+   *
+   * // The following assertion fails:
+   * assertThat(xFile).hasSameTextualContentAs(xFileFrench);</code></pre>
+   *
+   * @param expected the given {@code Path} to compare the actual {@code Path} to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given {@code Path} is {@code null}.
+   * @throws AssertionError if the actual or given {@code Path} is not an existing readable file.
+   * @throws AssertionError if the actual {@code Path} is {@code null}.
+   * @throws AssertionError if the content of the actual {@code Path} is not equal to the content of the given one.
+   * @throws PathsException if an I/O error occurs.
+   * @since 3.15
+   */
+  public SELF hasSameTextualContentAs(Path expected) {
     paths.assertHasSameContentAs(info, actual, charset, expected, Charset.defaultCharset());
     return myself;
   }
@@ -134,7 +172,41 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * the charset used to read the actual path can be provided with {@link #usingCharset(Charset)} or
    * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
    * {@link Charset#defaultCharset()}) will be used.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> Path fileUTF8Charset = Files.write(Paths.get("actual"), Collections.singleton("Gerçek"), StandardCharsets.UTF_8);
+   * Charset turkishCharset = Charset.forName("windows-1254");
+   * Path fileTurkischCharset = Files.write(Paths.get("expected"), Collections.singleton("Gerçek"), turkishCharset);
    *
+   * // The following assertion succeeds:
+   * assertThat(fileUTF8Charset).usingCharset(StandardCharsets.UTF_8).hasSameTextualContentAs(fileTurkischCharset, turkishCharset);
+   *
+   * // The following assertion fails:
+   * assertThat(fileUTF8Charset).usingCharset(StandardCharsets.UTF_8).hasSameTextualContentAs(fileTurkischCharset, StandardCharsets.UTF_8);</code></pre>
+   *
+   * @param expected the given {@code Path} to compare the actual {@code Path} to.
+   * @param expectedCharset the {@link Charset} used to read the content of the expected Path.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given {@code Path} is {@code null}.
+   * @throws AssertionError if the actual or given {@code Path} is not an existing readable file.
+   * @throws AssertionError if the actual {@code Path} is {@code null}.
+   * @throws AssertionError if the content of the actual {@code Path} is not equal to the content of the given one.
+   * @throws PathsException if an I/O error occurs.
+   * @since 3.15
+   */
+  public SELF hasSameTextualContentAs(Path expected, Charset expectedCharset) {
+    paths.assertHasSameContentAs(info, actual, charset, expected, expectedCharset);
+    return myself;
+  }
+
+  /**
+   * @deprecated use {@link #hasSameTextualContentAs(Path, Charset)} instead
+   * <p>
+   * Verifies that the content of the actual {@code Path} is the same as the expected one, the expected {@code Path} being read with the given charset while
+   * the charset used to read the actual path can be provided with {@link #usingCharset(Charset)} or
+   * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
+   * {@link Charset#defaultCharset()}) will be used.
+   * <p>
    * Examples:
    * <pre><code class="java"> Path fileUTF8Charset = Files.write(Paths.get("actual"), Collections.singleton("Gerçek"), StandardCharsets.UTF_8);
    * Charset turkishCharset = Charset.forName("windows-1254");
@@ -155,9 +227,9 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @throws AssertionError if the content of the actual {@code Path} is not equal to the content of the given one.
    * @throws PathsException if an I/O error occurs.
    */
+  @Deprecated
   public SELF hasSameContentAs(Path expected, Charset expectedCharset) {
-    paths.assertHasSameContentAs(info, actual, charset, expected, expectedCharset);
-    return myself;
+    return hasSameTextualContentAs(expected, expectedCharset);
   }
 
   /**
@@ -180,19 +252,50 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * // The following assertion fails ... unless you are in Turkey ;-):
    * assertThat(xFileTurkish).hasBinaryContent("Gerçek Başka bir yerde mi".getBytes());</code></pre>
    *
-   * @param expected the expected binary content to compare the actual {@code File}'s content to.
+   * @param expected the expected binary content to compare the actual {@code Path}'s content to.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given content is {@code null}.
-   * @throws AssertionError if the actual {@code File} is {@code null}.
-   * @throws AssertionError if the actual {@code File} is not an existing file.
+   * @throws AssertionError if the actual {@code Path} is {@code null}.
+   * @throws AssertionError if the actual {@code Path} is not an existing file.
    * @throws UncheckedIOException if an I/O error occurs.
-   * @throws AssertionError if the content of the actual {@code File} is not equal to the given binary content.
+   * @throws AssertionError if the content of the actual {@code Path} is not equal to the given binary content.
    */
   public SELF hasBinaryContent(byte[] expected) {
     paths.assertHasBinaryContent(info, actual, expected);
     return myself;
   }
 
+  /**
+   * Verifies that the content of the actual {@code Path} is equal to the content of the given one, the comparison is done at the binary level.<br>
+   * For text files, use {@link #hasSameTextualContentAs(Path)} or {@link #hasSameTextualContentAs(Path, Charset)}.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // The first two paths have the same contents, the third does not
+   * Path aPath = Files.write(Paths.get("a-file.bin"), new byte[] { 42 });
+   * Path bPath = Files.write(Paths.get("b-file.bin"), new byte[] { 42 });
+   * Path cPath = Files.write(Paths.get("c-file.bin"), new byte[] { 24 });
+   *
+   * // The following assertion succeeds:
+   * assertThat(aPath).hasSameBinaryContentAs(bPath);
+   *
+   * // The following assertion fails:
+   * assertThat(aPath).hasSameBinaryContent(cPath);</code></pre>
+   *
+   * @param expected the given {@code Path} to compare the actual {@code Path} to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given {@code Path} is {@code null}.
+   * @throws IllegalArgumentException if the given {@code Path} is not an existing file.
+   * @throws AssertionError if the actual {@code Path} is {@code null}.
+   * @throws AssertionError if the actual {@code Path} is not an existing file.
+   * @throws UncheckedIOException if any I/O error occurs.
+   * @throws AssertionError if the content of the actual {@code Path} is not equal to the content of the given one.
+   * @since 3.15
+   */
+  public SELF hasSameBinaryContentAs(Path expected) {
+    paths.assertHasSameBinaryContentAs(info, actual, expected);
+    return myself;
+  }
+
   /**
    * Specifies the name of the charset to use for text-based assertions on the path's contents (path must be a readable
    * file).
@@ -262,13 +365,13 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * // The following assertion fails ... unless you are in Turkey ;-):
    * assertThat(xFileTurkish).hasContent("Gerçek Başka bir yerde mi");</code></pre>
    *
-   * @param expected the expected text content to compare the actual {@code File}'s content to.
+   * @param expected the expected text content to compare the actual {@code Path}'s content to.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given content is {@code null}.
    * @throws UncheckedIOException if an I/O error occurs.
    * @throws AssertionError if the actual {@code Path} is {@code null}.
    * @throws AssertionError if the actual {@code Path} is not a {@link Files#isReadable(Path) readable} file.
-   * @throws AssertionError if the content of the actual {@code File} is not equal to the given content.
+   * @throws AssertionError if the content of the actual {@code Path} is not equal to the given content.
    */
   public SELF hasContent(String expected) {
     paths.assertHasContent(info, actual, expected, charset);
diff --git a/src/main/java/org/assertj/core/internal/BinaryDiffResult.java b/src/main/java/org/assertj/core/internal/BinaryDiffResult.java
index 164d8c780..bb2fc6055 100644
--- a/src/main/java/org/assertj/core/internal/BinaryDiffResult.java
+++ b/src/main/java/org/assertj/core/internal/BinaryDiffResult.java
@@ -14,7 +14,7 @@ package org.assertj.core.internal;
 
 /**
  * Value class to hold the result of comparing two binary streams.
- * 
+ *
  * @author Olivier Michallat
  */
 public class BinaryDiffResult {
@@ -23,10 +23,10 @@ public class BinaryDiffResult {
   public final int offset;
   public final String expected;
   public final String actual;
-  
+
   /**
    * Builds a new instance.
-   * 
+   *
    * @param offset the offset at which the difference occurred.
    * @param expected the expected byte as an int in the range 0 to 255, or -1 for EOF.
    * @param actual the actual byte in the same format.
@@ -36,11 +36,15 @@ public class BinaryDiffResult {
     this.expected = describe(expected);
     this.actual = describe(actual);
   }
-  
+
   public boolean hasNoDiff() {
     return offset == EOF;
   }
-  
+
+  public boolean hasDiff() {
+    return !hasNoDiff();
+  }
+
   public static BinaryDiffResult noDiff() {
     return new BinaryDiffResult(EOF, 0, 0);
   }
diff --git a/src/main/java/org/assertj/core/internal/Files.java b/src/main/java/org/assertj/core/internal/Files.java
index c604c570f..2a7c6bc69 100644
--- a/src/main/java/org/assertj/core/internal/Files.java
+++ b/src/main/java/org/assertj/core/internal/Files.java
@@ -136,6 +136,29 @@ public class Files {
     }
   }
 
+  /**
+   * Asserts that the given files have the same binary content.
+   * @param info contains information about the assertion.
+   * @param actual the "actual" file.
+   * @param expected the "expected" file.
+   * @throws NullPointerException if {@code expected} is {@code null}.
+   * @throws IllegalArgumentException if {@code expected} is not an existing file.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if {@code actual} is not an existing file.
+   * @throws UncheckedIOException if an I/O error occurs.
+   * @throws AssertionError if the given files do not have same content.
+   */
+  public void assertSameBinaryContentAs(AssertionInfo info, File actual, File expected) {
+    verifyIsFile(expected);
+    assertIsFile(info, actual);
+    try {
+      BinaryDiffResult binaryDiffResult = binaryDiff.diff(actual, readAllBytes(expected.toPath()));
+      if (binaryDiffResult.hasDiff()) throw failures.failure(info, shouldHaveBinaryContent(actual, binaryDiffResult));
+    } catch (IOException ioe) {
+      throw new UncheckedIOException(format(UNABLE_TO_COMPARE_FILE_CONTENTS, actual, expected), ioe);
+    }
+  }
+
   /**
    * Asserts that the given file has the given binary content.
    * @param info contains information about the assertion.
diff --git a/src/main/java/org/assertj/core/internal/Paths.java b/src/main/java/org/assertj/core/internal/Paths.java
index fa8ad76f9..a90aee6ae 100644
--- a/src/main/java/org/assertj/core/internal/Paths.java
+++ b/src/main/java/org/assertj/core/internal/Paths.java
@@ -13,6 +13,7 @@
 package org.assertj.core.internal;
 
 import static java.lang.String.format;
+import static java.nio.file.Files.readAllBytes;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.StreamSupport.stream;
 import static org.assertj.core.error.ShouldBeAbsolutePath.shouldBeAbsolutePath;
@@ -71,7 +72,8 @@ public class Paths {
 
   private static final String FAILED_TO_RESOLVE_ARGUMENT_REAL_PATH = "failed to resolve argument real path";
   private static final String FAILED_TO_RESOLVE_ACTUAL_REAL_PATH = "failed to resolve actual real path";
-  @VisibleForTesting
+  private static final String UNABLE_TO_COMPARE_PATH_CONTENTS = "Unable to compare contents of paths:<%s> and:<%s>";
+
   public static final String IOERROR_FORMAT = "I/O error attempting to process assertion for path: <%s>";
 
   private static final Paths INSTANCE = new Paths();
@@ -296,9 +298,24 @@ public class Paths {
     }
   }
 
+  public void assertHasSameBinaryContentAs(AssertionInfo info, Path actual, Path expected) {
+    checkNotNull(expected, "The given Path to compare actual content to should not be null");
+    assertIsReadable(info, actual);
+    checkArgument(nioFilesWrapper.exists(expected), "The given Path <%s> to compare actual content to should exist", expected);
+    checkArgument(nioFilesWrapper.isReadable(expected), "The given Path <%s> to compare actual content to should be readable",
+                  expected);
+    try {
+      BinaryDiffResult binaryDiffResult = binaryDiff.diff(actual, readAllBytes(expected));
+      if (binaryDiffResult.hasDiff()) throw failures.failure(info, shouldHaveBinaryContent(actual, binaryDiffResult));
+    } catch (IOException ioe) {
+      throw new UncheckedIOException(format(UNABLE_TO_COMPARE_PATH_CONTENTS, actual, expected), ioe);
+    }
+  }
+
   public void assertHasSameContentAs(AssertionInfo info, Path actual, Charset actualCharset, Path expected,
                                      Charset expectedCharset) {
     checkNotNull(expected, "The given Path to compare actual content to should not be null");
+    checkArgument(nioFilesWrapper.exists(expected), "The given Path <%s> to compare actual content to should exist", expected);
     checkArgument(nioFilesWrapper.isReadable(expected), "The given Path <%s> to compare actual content to should be readable",
                   expected);
     assertIsReadable(info, actual);
@@ -307,7 +324,7 @@ public class Paths {
       if (diffs.isEmpty()) return;
       throw failures.failure(info, shouldHaveSameContent(actual, expected, diffs));
     } catch (IOException e) {
-      throw new UncheckedIOException(format("Unable to compare contents of paths:<%s> and:<%s>", actual, expected), e);
+      throw new UncheckedIOException(format(UNABLE_TO_COMPARE_PATH_CONTENTS, actual, expected), e);
     }
   }
 
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_hasSameBinaryContentAs_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_hasSameBinaryContentAs_Test.java
new file mode 100644
index 000000000..0a573c4d0
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_hasSameBinaryContentAs_Test.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.file;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.TempFileUtil.createTempFileWithContent;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+
+import org.assertj.core.api.FileAssert;
+import org.assertj.core.api.FileAssertBaseTest;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for <code>{@link FileAssert#hasSameBinaryContentAs(File)}</code>.
+ *
+ * @author Nikolaos Georgiou
+ */
+public class FileAssert_hasSameBinaryContentAs_Test extends FileAssertBaseTest {
+
+  private static File expected;
+
+  @BeforeAll
+  public static void beforeOnce() {
+    expected = new File("xyz");
+  }
+
+  @Override
+  protected FileAssert invoke_api_method() {
+    return assertions.hasSameBinaryContentAs(expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(files).assertSameBinaryContentAs(getInfo(assertions), getActual(assertions), expected);
+  }
+
+  @Test
+  public void should_pass_on_equal_files() throws Exception {
+    // GIVEN
+    File actual = createTempFileWithContent("assertJ");
+    File expected = createTempFileWithContent("assertJ");
+    // WHEN/THEN
+    then(actual).hasSameBinaryContentAs(expected);
+  }
+
+  @Test
+  public void should_fail_on_different_files() throws Exception {
+    // GIVEN
+    File actual = createTempFileWithContent("assertJ");
+    File expected = createTempFileWithContent("assertJ++");
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).hasSameBinaryContentAs(expected));
+    // THEN
+    then(assertionError).hasMessageContaining("does not have expected binary content at offset");
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_hasSameContentAs_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_hasSameContentAs_Test.java
index 3d7bdac38..c7c3fa210 100644
--- a/src/test/java/org/assertj/core/api/file/FileAssert_hasSameContentAs_Test.java
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_hasSameContentAs_Test.java
@@ -13,26 +13,15 @@
 package org.assertj.core.api.file;
 
 import static java.nio.charset.Charset.defaultCharset;
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.nio.file.Files;
-import java.nio.file.Path;
 
 import org.assertj.core.api.FileAssert;
 import org.assertj.core.api.FileAssertBaseTest;
 import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.Test;
 
-/**
- * Tests for <code>{@link FileAssert#hasSameContentAs(java.io.File)}</code>.
- * 
- * @author Yvonne Wang
- */
+// tested in FileAssert_hasSameTextualContentAs_Test as hasSameContentAs is deprecated in favor of hasSameTextualContentAs
 public class FileAssert_hasSameContentAs_Test extends FileAssertBaseTest {
 
   private static File expected;
@@ -42,6 +31,7 @@ public class FileAssert_hasSameContentAs_Test extends FileAssertBaseTest {
     expected = new File("xyz");
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   protected FileAssert invoke_api_method() {
     return assertions.hasSameContentAs(expected);
@@ -52,28 +42,4 @@ public class FileAssert_hasSameContentAs_Test extends FileAssertBaseTest {
     verify(files).assertSameContentAs(getInfo(assertions), getActual(assertions), defaultCharset(), expected, defaultCharset());
   }
 
-  @Test
-  public void should_use_charset_specified_by_usingCharset_to_read_actual_file_content() throws Exception {
-    Charset turkishCharset = Charset.forName("windows-1254");
-    File actual = createDeleteOnExitTempFileWithContent("Gerçek", turkishCharset);
-    File expected = createDeleteOnExitTempFileWithContent("Gerçek", defaultCharset());
-
-    assertThat(actual).usingCharset(turkishCharset).hasSameContentAs(expected);
-  }
-
-  @Test
-  public void should_allow_charset_to_be_specified_for_reading_expected_file_content() throws Exception {
-    Charset turkishCharset = Charset.forName("windows-1254");
-    File actual = createDeleteOnExitTempFileWithContent("Gerçek", defaultCharset());
-    File expected = createDeleteOnExitTempFileWithContent("Gerçek", turkishCharset);
-
-    assertThat(actual).hasSameContentAs(expected, turkishCharset);
-  }
-
-  private File createDeleteOnExitTempFileWithContent(String content, Charset charset) throws IOException {
-    Path tempFile = Files.createTempFile("test", "test");
-    tempFile.toFile().deleteOnExit();
-    Files.write(tempFile, asList(content), charset);
-    return tempFile.toFile();
-  }
 }
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_hasSameTextualContentAs_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_hasSameTextualContentAs_Test.java
new file mode 100644
index 000000000..897a823ad
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_hasSameTextualContentAs_Test.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.file;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.TempFileUtil.createTempFileWithContent;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.nio.charset.Charset;
+
+import org.assertj.core.api.FileAssert;
+import org.assertj.core.api.FileAssertBaseTest;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for <code>{@link FileAssert#hasSameTextualContentAs(File)}</code>.
+ *
+ * @author Yvonne Wang
+ * @author Nikolaos Georgiou
+ */
+@DisplayName("FileAssert hasSameTextualContentAs")
+public class FileAssert_hasSameTextualContentAs_Test extends FileAssertBaseTest {
+
+  private static File expected;
+
+  @BeforeAll
+  public static void beforeOnce() {
+    expected = new File("xyz");
+  }
+
+  @Override
+  protected FileAssert invoke_api_method() {
+    return assertions.hasSameTextualContentAs(expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(files).assertSameContentAs(getInfo(assertions), getActual(assertions), defaultCharset, expected, defaultCharset);
+  }
+
+  @Test
+  public void should_use_charset_specified_by_usingCharset_to_read_actual_file_content() throws Exception {
+    // GIVEN
+    Charset turkishCharset = Charset.forName("windows-1254");
+    File actual = createTempFileWithContent("Gerçek", turkishCharset);
+    File expected = createTempFileWithContent("Gerçek", defaultCharset);
+    // WHEN/THEN
+    then(actual).usingCharset(turkishCharset)
+                .hasSameTextualContentAs(expected);
+  }
+
+  @Test
+  public void should_allow_charset_to_be_specified_for_reading_expected_file_content() throws Exception {
+    // GIVEN
+    Charset turkishCharset = Charset.forName("windows-1254");
+    File actual = createTempFileWithContent("Gerçek", defaultCharset);
+    File expected = createTempFileWithContent("Gerçek", turkishCharset);
+    // WHEN/THEN
+    then(actual).hasSameTextualContentAs(expected, turkishCharset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasSameContentAs_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasSameContentAs_Test.java
index e0ca4b464..36b37b0df 100644
--- a/src/test/java/org/assertj/core/api/path/PathAssert_hasSameContentAs_Test.java
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasSameContentAs_Test.java
@@ -12,66 +12,37 @@
  */
 package org.assertj.core.api.path;
 
-import static java.nio.charset.Charset.defaultCharset;
-import static java.util.Arrays.asList;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
-import java.io.IOException;
-import java.nio.charset.Charset;
-import java.nio.file.Files;
 import java.nio.file.Path;
 
 import org.assertj.core.api.PathAssert;
 import org.assertj.core.api.PathAssertBaseTest;
 import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.Test;
 
 /**
  * Tests for <code>{@link PathAssert#hasSameContentAs(java.nio.file.Path)}</code>.
  */
+// deprecated in favor of hasSameTextualContentAs
 public class PathAssert_hasSameContentAs_Test extends PathAssertBaseTest {
 
   private static Path expected;
 
   @BeforeAll
   public static void beforeOnce() {
-	expected = mock(Path.class);
+    expected = mock(Path.class);
   }
 
+  @SuppressWarnings("deprecation")
   @Override
   protected PathAssert invoke_api_method() {
-	return assertions.hasSameContentAs(expected);
+    return assertions.hasSameContentAs(expected);
   }
 
   @Override
   protected void verify_internal_effects() {
-	verify(paths).assertHasSameContentAs(getInfo(assertions), getActual(assertions), defaultCharset(), expected, defaultCharset());
+    verify(paths).assertHasSameContentAs(getInfo(assertions), getActual(assertions), defaultCharset, expected, defaultCharset);
   }
-  
-  @Test
-  public void should_use_charset_specified_by_usingCharset_to_read_actual_file_content() throws Exception {
-    Charset turkishCharset = Charset.forName("windows-1254");
-    Path actual = createDeleteOnExitTempFileWithContent("Gerçek", turkishCharset);
-    Path expected = createDeleteOnExitTempFileWithContent("Gerçek", defaultCharset());
 
-    assertThat(actual).usingCharset(turkishCharset).hasSameContentAs(expected);
-  }
-
-  @Test
-  public void should_allow_charset_to_be_specified_for_reading_expected_file_content() throws Exception {
-    Charset turkishCharset = Charset.forName("windows-1254");
-    Path actual = createDeleteOnExitTempFileWithContent("Gerçek", defaultCharset());
-    Path expected = createDeleteOnExitTempFileWithContent("Gerçek", turkishCharset);
-
-    assertThat(actual).hasSameContentAs(expected, turkishCharset);
-  }
-
-  private Path createDeleteOnExitTempFileWithContent(String content, Charset charset) throws IOException {
-    Path tempFile = Files.createTempFile("test", "test");
-    tempFile.toFile().deleteOnExit();
-    Files.write(tempFile, asList(content), charset);
-    return tempFile;
-  }
 }
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasSameTextualContentAs_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasSameTextualContentAs_Test.java
new file mode 100644
index 000000000..754777122
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasSameTextualContentAs_Test.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.TempFileUtil.createTempPathWithContent;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.nio.charset.Charset;
+import java.nio.file.Path;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("PathAssert hasSameTextualContentAs")
+public class PathAssert_hasSameTextualContentAs_Test extends PathAssertBaseTest {
+
+  private static Path expected;
+
+  @BeforeAll
+  public static void beforeOnce() {
+    expected = mock(Path.class);
+  }
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.hasSameTextualContentAs(expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertHasSameContentAs(getInfo(assertions), getActual(assertions), defaultCharset, expected, defaultCharset);
+  }
+
+  @Test
+  public void should_use_charset_specified_by_usingCharset_to_read_actual_file_content() throws Exception {
+    // GIVEN
+    Charset turkishCharset = Charset.forName("windows-1254");
+    Path actual = createTempPathWithContent("Gerçek", turkishCharset);
+    Path expected = createTempPathWithContent("Gerçek", defaultCharset);
+    // WHEN/THEN
+    then(actual).usingCharset(turkishCharset)
+                .hasSameTextualContentAs(expected);
+  }
+
+  @Test
+  public void should_allow_charset_to_be_specified_for_reading_expected_file_content() throws Exception {
+    // GIVEN
+    Charset turkishCharset = Charset.forName("windows-1254");
+    Path actual = createTempPathWithContent("Gerçek", defaultCharset);
+    Path expected = createTempPathWithContent("Gerçek", turkishCharset);
+    // WHEN/THEN
+    then(actual).hasSameTextualContentAs(expected, turkishCharset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasSameBinaryContentAs_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasSameBinaryContentAs_Test.java
new file mode 100644
index 000000000..0c7cac9be
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasSameBinaryContentAs_Test.java
@@ -0,0 +1,123 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.internal.files;
+
+import static java.nio.file.Files.readAllBytes;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
+import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
+import static org.assertj.core.internal.BinaryDiffResult.noDiff;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+
+import org.assertj.core.internal.BinaryDiffResult;
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+
+public class Files_assertHasSameBinaryContentAs_Test extends FilesBaseTest {
+
+  private static File actual;
+  private static File expected;
+  private static byte[] expectedBytes;
+
+  @BeforeAll
+  public static void setUpOnce() throws IOException {
+    // Does not matter if the values differ, the actual comparison is mocked in this test
+    actual = new File("src/test/resources/actual_file.txt");
+    expected = new File("src/test/resources/expected_file.txt");
+    expectedBytes = readAllBytes(expected.toPath());
+  }
+
+  @Test
+  public void should_pass_if_file_has_expected_binary_content() throws IOException {
+    // GIVEN
+    given(binaryDiff.diff(actual, expectedBytes)).willReturn(noDiff());
+    // WHEN/THEN
+    files.assertSameBinaryContentAs(someInfo(), actual, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    // GIVEN
+    File nullExpected = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertSameBinaryContentAs(someInfo(), actual, nullExpected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The file to compare to should not be null");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    // GIVEN
+    File file = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertSameBinaryContentAs(someInfo(), file, expected));
+    // THEN
+    then(error).hasMessage(actualIsNull());
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_a_file() {
+    // GIVEN
+    File notAFile = new File("xyz");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertSameBinaryContentAs(someInfo(), notAFile, expected));
+    // THEN
+    then(error).hasMessage(shouldBeFile(notAFile).create());
+  }
+
+  @Test
+  public void should_fail_if_expected_is_not_a_file() {
+    // GIVEN
+    File notAFile = new File("xyz");
+    // WHEN
+    IllegalArgumentException iae = catchThrowableOfType(() -> files.assertSameBinaryContentAs(someInfo(), actual, notAFile),
+                                                        IllegalArgumentException.class);
+    // THEN
+    then(iae).hasMessage("Expected file:<'%s'> should be an existing file", notAFile);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_caught_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(binaryDiff.diff(actual, expectedBytes)).willThrow(cause);
+    // WHEN
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertSameBinaryContentAs(someInfo(), actual, expected),
+                                                     UncheckedIOException.class);
+    // THEN
+    then(uioe).hasCause(cause);
+  }
+
+  @Test
+  public void should_fail_if_file_does_not_have_expected_binary_content() throws IOException {
+    // GIVEN
+    BinaryDiffResult diff = new BinaryDiffResult(15, (byte) 0xCA, (byte) 0xFE);
+    when(binaryDiff.diff(actual, expectedBytes)).thenReturn(diff);
+    // WHEN
+    expectAssertionError(() -> files.assertSameBinaryContentAs(someInfo(), actual, expected));
+    // THEN
+    verify(failures).failure(someInfo(), shouldHaveBinaryContent(actual, diff));
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/inputstreams/BinaryDiff_diff_InputStream_Test.java b/src/test/java/org/assertj/core/internal/inputstreams/BinaryDiff_diff_InputStream_Test.java
index 1fdf6f907..0060a3a98 100644
--- a/src/test/java/org/assertj/core/internal/inputstreams/BinaryDiff_diff_InputStream_Test.java
+++ b/src/test/java/org/assertj/core/internal/inputstreams/BinaryDiff_diff_InputStream_Test.java
@@ -26,7 +26,7 @@ import org.junit.jupiter.api.Test;
 
 /**
  * Tests for <code>{@link BinaryDiff#diff(java.io.InputStream, java.io.InputStream)}</code>.
- * 
+ *
  * @author Olivier Michallat
  */
 public class BinaryDiff_diff_InputStream_Test {
@@ -48,32 +48,35 @@ public class BinaryDiff_diff_InputStream_Test {
     BinaryDiffResult result = binaryDiff.diff(actual, expected);
     assertThat(result.hasNoDiff()).isTrue();
   }
-  
+
   @Test
   public void should_return_diff_if_inputstreams_differ_on_one_byte() throws IOException {
     actual = stream(0xCA, 0xFE, 0xBA, 0xBE);
     expected = stream(0xCA, 0xFE, 0xBE, 0xBE);
     BinaryDiffResult result = binaryDiff.diff(actual, expected);
+    assertThat(result.hasDiff()).isTrue();
     assertThat(result.offset).isEqualTo(2);
     assertThat(result.actual).isEqualTo("0xBA");
     assertThat(result.expected).isEqualTo("0xBE");
   }
-  
+
   @Test
   public void should_return_diff_if_actual_is_shorter() throws IOException {
     actual = stream(0xCA, 0xFE, 0xBA);
     expected = stream(0xCA, 0xFE, 0xBA, 0xBE);
     BinaryDiffResult result = binaryDiff.diff(actual, expected);
+    assertThat(result.hasDiff()).isTrue();
     assertThat(result.offset).isEqualTo(3);
     assertThat(result.actual).isEqualTo("EOF");
     assertThat(result.expected).isEqualTo("0xBE");
   }
-  
+
   @Test
   public void should_return_diff_if_expected_is_shorter() throws IOException {
     actual = stream(0xCA, 0xFE, 0xBA, 0xBE);
     expected = stream(0xCA, 0xFE, 0xBA);
     BinaryDiffResult result = binaryDiff.diff(actual, expected);
+    assertThat(result.hasDiff()).isTrue();
     assertThat(result.offset).isEqualTo(3);
     assertThat(result.actual).isEqualTo("0xBE");
     assertThat(result.expected).isEqualTo("EOF");
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameBinaryContentAs_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameBinaryContentAs_Test.java
new file mode 100644
index 000000000..7152a4cd9
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameBinaryContentAs_Test.java
@@ -0,0 +1,151 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static java.nio.charset.Charset.defaultCharset;
+import static java.nio.file.Files.readAllBytes;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
+import static org.assertj.core.internal.BinaryDiffResult.noDiff;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.TempFileUtil.createTempPathWithContent;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+
+import org.assertj.core.internal.BinaryDiffResult;
+import org.assertj.core.internal.PathsBaseTest;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public class Paths_assertHasSameBinaryContentAs_Test extends PathsBaseTest {
+
+  private Path actual;
+  private Path expected;
+  private byte[] expectedBytes;
+
+  @BeforeEach
+  public void setUpOnce() throws IOException {
+    // Does not matter if the values differ, the actual comparison is mocked in this test
+    actual = createTempPathWithContent("foo", defaultCharset());
+    expected = createTempPathWithContent("bar", defaultCharset());
+    expectedBytes = readAllBytes(expected);
+    when(nioFilesWrapper.exists(actual)).thenReturn(true);
+    when(nioFilesWrapper.isReadable(actual)).thenReturn(true);
+    when(nioFilesWrapper.exists(expected)).thenReturn(true);
+    when(nioFilesWrapper.isReadable(expected)).thenReturn(true);
+  }
+
+  @Test
+  public void should_pass_if_path_has_same_binary_content_as_expected() throws IOException {
+    // GIVEN
+    given(binaryDiff.diff(actual, expectedBytes)).willReturn(noDiff());
+    // WHEN/THEN
+    paths.assertHasSameBinaryContentAs(someInfo(), actual, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    // GIVEN
+    Path nullExpected = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> paths.assertHasSameBinaryContentAs(someInfo(), actual, nullExpected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The given Path to compare actual content to should not be null");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    // GIVEN
+    Path path = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertHasSameBinaryContentAs(someInfo(), path, expected));
+    // THEN
+    then(error).hasMessage(actualIsNull());
+  }
+
+  @Test
+  public void should_fail_if_actual_path_does_not_exist() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(false);
+    // WHEN
+    expectAssertionError(() -> paths.assertHasSameBinaryContentAs(someInfo(), actual, expected));
+    // THEN
+    verify(failures).failure(someInfo(), shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_readable() {
+    // GIVEN
+    when(nioFilesWrapper.isReadable(actual)).thenReturn(false);
+    // WHEN
+    expectAssertionError(() -> paths.assertHasSameBinaryContentAs(someInfo(), actual, expected));
+    // THEN
+    verify(failures).failure(someInfo(), shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_fail_if_expected_path_is_does_not_exist() {
+    // GIVEN
+    when(nioFilesWrapper.exists(expected)).thenReturn(false);
+    // WHEN
+    IllegalArgumentException iae = catchThrowableOfType(() -> paths.assertHasSameBinaryContentAs(someInfo(), actual, expected),
+                                                        IllegalArgumentException.class);
+    // THEN
+    then(iae).hasMessage("The given Path <%s> to compare actual content to should exist", expected);
+  }
+
+  @Test
+  public void should_fail_if_expected_path_is_not_readable() {
+    // GIVEN
+    when(nioFilesWrapper.isReadable(expected)).thenReturn(false);
+    // WHEN
+    IllegalArgumentException iae = catchThrowableOfType(() -> paths.assertHasSameBinaryContentAs(someInfo(), actual, expected),
+                                                        IllegalArgumentException.class);
+    // THEN
+    then(iae).hasMessage("The given Path <%s> to compare actual content to should be readable", expected);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_caught_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(binaryDiff.diff(actual, expectedBytes)).willThrow(cause);
+    // WHEN
+    UncheckedIOException uioe = catchThrowableOfType(() -> paths.assertHasSameBinaryContentAs(someInfo(), actual, expected),
+                                                     UncheckedIOException.class);
+    // THEN
+    then(uioe).hasCause(cause);
+  }
+
+  @Test
+  public void should_fail_if_path_does_not_have_expected_binary_content() throws IOException {
+    // GIVEN
+    BinaryDiffResult diff = new BinaryDiffResult(15, (byte) 0xCA, (byte) 0xFE);
+    when(binaryDiff.diff(actual, expectedBytes)).thenReturn(diff);
+    // WHEN
+    expectAssertionError(() -> paths.assertHasSameBinaryContentAs(someInfo(), actual, expected));
+    // THEN
+    verify(failures).failure(someInfo(), shouldHaveBinaryContent(actual, diff));
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameContentAs_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameContentAs_Test.java
index 503e6c370..6996e5481 100644
--- a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameContentAs_Test.java
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameContentAs_Test.java
@@ -12,32 +12,32 @@
  */
 package org.assertj.core.internal.paths;
 
-import static java.lang.String.format;
 import static java.nio.charset.Charset.defaultCharset;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static java.util.Collections.emptyList;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldHaveSameContent.shouldHaveSameContent;
 import static org.assertj.core.test.TestData.someInfo;
-import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.TempFileUtil.createTempPathWithContent;
+import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.nio.charset.Charset;
 import java.nio.file.Path;
-import java.util.ArrayList;
 import java.util.List;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.Paths;
 import org.assertj.core.util.diff.Delta;
+import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -45,103 +45,119 @@ import org.junit.jupiter.api.Test;
  */
 public class Paths_assertHasSameContentAs_Test extends MockPathsBaseTest {
 
+  private static final Charset CHARSET = defaultCharset();
+  private Path actual;
+  private Path expected;
+
+  @BeforeEach
+  public void setUpOnce() throws IOException {
+    // Does not matter if the values differ, the actual comparison is mocked in this test
+    actual = createTempPathWithContent("foo", CHARSET);
+    expected = createTempPathWithContent("bar", CHARSET);
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.exists(expected)).willReturn(true);
+    given(nioFilesWrapper.isReadable(expected)).willReturn(true);
+  }
+
   @Test
-  public void should_pass_if_path_has_same_content_as_other() throws IOException {
-	when(diff.diff(actual, defaultCharset(), other, defaultCharset())).thenReturn(new ArrayList<>());
-	when(nioFilesWrapper.exists(actual)).thenReturn(true);
-	when(nioFilesWrapper.isReadable(actual)).thenReturn(true);
-	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
-	paths.assertHasSameContentAs(someInfo(), actual, defaultCharset(), other, defaultCharset());
+  public void should_pass_if_path_has_same_textual_content_as_expected() throws IOException {
+    // GIVEN
+    given(diff.diff(actual, CHARSET, expected, CHARSET)).willReturn(emptyList());
+    // WHEN/THEN
+    paths.assertHasSameContentAs(someInfo(), actual, CHARSET, expected, CHARSET);
   }
 
   @Test
-  public void should_throw_error_if_other_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> paths.assertHasSameContentAs(someInfo(), actual, defaultCharset(),
-                                                                                   null, defaultCharset()))
-                                    .withMessage("The given Path to compare actual content to should not be null");
+  public void should_throw_error_if_expected_is_null() {
+    // GIVEN
+    Path nullExpected = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> paths.assertHasSameContentAs(someInfo(), actual, CHARSET, nullExpected,
+                                                                                       CHARSET),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The given Path to compare actual content to should not be null");
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-	assertThatExceptionOfType(AssertionError.class).isThrownBy(() ->{
-      when(nioFilesWrapper.isReadable(other)).thenReturn(true);
-      paths.assertHasSameContentAs(someInfo(), null, defaultCharset(), other, defaultCharset());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    Path path = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> paths.assertHasSameContentAs(someInfo(), path, CHARSET, expected,
+                                                                                   CHARSET));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   public void should_fail_if_actual_path_does_not_exist() {
-	AssertionInfo info = someInfo();
-	when(nioFilesWrapper.exists(actual)).thenReturn(false);
-	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
-	try {
-	  paths.assertHasSameContentAs(info, actual, defaultCharset(), other, defaultCharset());
-	} catch (AssertionError e) {
-	  verify(failures).failure(info, shouldExist(actual));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+    // GIVEN
+    AssertionInfo info = someInfo();
+    given(nioFilesWrapper.exists(actual)).willReturn(false);
+    // WHEN
+    expectAssertionError(() -> paths.assertHasSameContentAs(info, actual, CHARSET, expected, CHARSET));
+    // THEN
+    verify(failures).failure(info, shouldExist(actual));
   }
 
   @Test
   public void should_fail_if_actual_is_not_a_readable_file() {
-	AssertionInfo info = someInfo();
-	when(nioFilesWrapper.exists(actual)).thenReturn(true);
-	when(nioFilesWrapper.isReadable(actual)).thenReturn(false);
-	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
-	try {
-	  paths.assertHasSameContentAs(info, actual, defaultCharset(), other, defaultCharset());
-	} catch (AssertionError e) {
-	  verify(failures).failure(info, shouldBeReadable(actual));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+    // GIVEN
+    given(nioFilesWrapper.isReadable(actual)).willReturn(false);
+    // WHEN
+    expectAssertionError(() -> paths.assertHasSameContentAs(someInfo(), actual, CHARSET, expected, CHARSET));
+    // THEN
+    verify(failures).failure(someInfo(), shouldBeReadable(actual));
   }
-  
+
   @Test
-  public void should_fail_if_other_is_not_a_readable_file() {
-    when(nioFilesWrapper.isReadable(other)).thenReturn(false);
+  public void should_fail_if_expected_path_is_does_not_exist() {
+    // GIVEN
+    given(nioFilesWrapper.exists(expected)).willReturn(false);
+    // WHEN
+    IllegalArgumentException iae = catchThrowableOfType(() -> paths.assertHasSameContentAs(someInfo(), actual, CHARSET,
+                                                                                           expected, CHARSET),
+                                                        IllegalArgumentException.class);
+    // THEN
+    then(iae).hasMessage("The given Path <%s> to compare actual content to should exist", expected);
+  }
 
-    assertThatIllegalArgumentException().isThrownBy(() -> paths.assertHasSameContentAs(someInfo(), actual,
-                                                                                       defaultCharset(), other,
-                                                                                       defaultCharset()))
-                                        .withMessage(format("The given Path <%s> to compare actual content to should be readable",
-                                                            other));
+  @Test
+  public void should_fail_if_expected_path_is_not_readable() {
+    // GIVEN
+    given(nioFilesWrapper.isReadable(expected)).willReturn(false);
+    // WHEN
+    IllegalArgumentException iae = catchThrowableOfType(() -> paths.assertHasSameContentAs(someInfo(), actual, CHARSET,
+                                                                                           expected, CHARSET),
+                                                        IllegalArgumentException.class);
+    // THEN
+    then(iae).hasMessage("The given Path <%s> to compare actual content to should be readable", expected);
   }
 
   @Test
   public void should_throw_error_wrapping_caught_IOException() throws IOException {
-	IOException cause = new IOException();
-	when(diff.diff(actual, defaultCharset(), other, defaultCharset())).thenThrow(cause);
-	when(nioFilesWrapper.exists(actual)).thenReturn(true);
-	when(nioFilesWrapper.isReadable(actual)).thenReturn(true);
-	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
-
-    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> paths.assertHasSameContentAs(someInfo(),
-                                                                                                        actual,
-                                                                                                        defaultCharset(),
-                                                                                                        other,
-                                                                                                        defaultCharset()))
-                                                         .withCause(cause);
+    // GIVEN
+    IOException cause = new IOException();
+    given(diff.diff(actual, CHARSET, expected, CHARSET)).willThrow(cause);
+    // WHEN
+    UncheckedIOException uioe = catchThrowableOfType(() -> paths.assertHasSameContentAs(someInfo(), actual, CHARSET,
+                                                                                        expected, CHARSET),
+                                                     UncheckedIOException.class);
+    // THEN
+    then(uioe).hasCause(cause);
   }
 
   @Test
   public void should_fail_if_actual_and_given_path_does_not_have_the_same_content() throws IOException {
-    @SuppressWarnings("unchecked")
-    List<Delta<String>> diffs = newArrayList((Delta<String>) mock(Delta.class));
-	when(diff.diff(actual, defaultCharset(), other, defaultCharset())).thenReturn(diffs);
-	when(nioFilesWrapper.exists(actual)).thenReturn(true);
-	when(nioFilesWrapper.isReadable(actual)).thenReturn(true);
-	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
-	AssertionInfo info = someInfo();
-	try {
-	  paths.assertHasSameContentAs(info, actual, defaultCharset(), other, defaultCharset());
-	} catch (AssertionError e) {
-	  verify(failures).failure(info, shouldHaveSameContent(actual, other, diffs));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+    // GIVEN
+    List<Delta<String>> diffs = list((Delta<String>) mock(Delta.class));
+    given(diff.diff(actual, CHARSET, expected, CHARSET)).willReturn(diffs);
+    AssertionInfo info = someInfo();
+    // WHEN
+    expectAssertionError(() -> paths.assertHasSameContentAs(someInfo(), actual, CHARSET, expected, CHARSET));
+    // THEN
+    verify(failures).failure(info, shouldHaveSameContent(actual, expected, diffs));
   }
 }
-
-
diff --git a/src/test/java/org/assertj/core/util/TempFileUtil.java b/src/test/java/org/assertj/core/util/TempFileUtil.java
new file mode 100644
index 000000000..3f6f368ec
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/TempFileUtil.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.util;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.file.Files;
+import java.nio.file.Path;
+import java.util.Collections;
+
+/**
+ * Utility methods for creating a temporary file for the tests.
+ * @author Nikolaos Georgiou
+ */
+public final class TempFileUtil {
+  private TempFileUtil() {}
+
+  /**
+   * Creates a temporary file with the given content. The file will be deleted automatically when the tests finish.
+   * @param content The content of the file.
+   * @return The newly created file instance.
+   * @throws IOException If an IO error occurs.
+   */
+  public static File createTempFileWithContent(String content) throws IOException {
+    Path tempFile = java.nio.file.Files.createTempFile("test", "test");
+    tempFile.toFile().deleteOnExit();
+    Files.write(tempFile, content.getBytes());
+    return tempFile.toFile();
+  }
+
+  /**
+   * Creates a temporary file with the given content. The file will be deleted automatically when the tests finish.
+   * @param content The content of the file.
+   * @param charset The charset to use.
+   * @return The newly created path instance.
+   * @throws IOException If an IO error occurs.
+   */
+  public static Path createTempPathWithContent(String content, Charset charset) throws IOException {
+    Path tempFile = java.nio.file.Files.createTempFile("test", "test");
+    tempFile.toFile().deleteOnExit();
+    Files.write(tempFile, Collections.singletonList(content), charset);
+    return tempFile;
+  }
+
+  /**
+   * Creates a temporary file with the given content. The file will be deleted automatically when the tests finish.
+   * @param content The content of the file.
+   * @param charset The charset to use.
+   * @return The newly created file instance.
+   * @throws IOException If an IO error occurs.
+   */
+  public static File createTempFileWithContent(String content, Charset charset) throws IOException {
+    return createTempPathWithContent(content, charset).toFile();
+  }
+}
