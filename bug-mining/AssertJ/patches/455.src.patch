diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index b199e86d0..1870a2b45 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -170,16 +170,41 @@ public final class DualValue {
   }
 
   public boolean isActualFieldAnIterable() {
-    // ignore Path to be consistent with isExpectedFieldAnIterable
-    return actual instanceof Iterable && !(actual instanceof Path);
+    return isAnIterable(actual);
   }
 
   public boolean isExpectedFieldAnIterable() {
+    return isAnIterable(expected);
+  }
+
+  private static boolean isAnIterable(Object value) {
     // Don't consider Path as an Iterable as recursively comparing them leads to a stack overflow, here's why:
     // Iterable are compared element by element recursively
     // Ex: /tmp/foo.txt path has /tmp as its first element
     // so /tmp is going to be compared recursively but /tmp first element is itself leading to an infinite recursion
-    return expected instanceof Iterable && !(expected instanceof Path);
+    // Don't consider ValueNode as an Iterable as they only contain one value and iterating them does not make sense.
+    // Don't consider or ObjectNode as an Iterable as it holds a map but would only iterate on values and not entries.
+    return value instanceof Iterable && !(value instanceof Path || isAJsonValueNode(value) || isAnObjectNode(value));
+  }
+
+  private static boolean isAJsonValueNode(Object value) {
+    try {
+      Class<?> valueNodeClass = Class.forName("com.fasterxml.jackson.databind.node.ValueNode");
+      return valueNodeClass.isInstance(value);
+    } catch (ClassNotFoundException e) {
+      // value cannot be a ValueNode because the class couldn't be located
+      return false;
+    }
+  }
+
+  private static boolean isAnObjectNode(Object value) {
+    try {
+      Class<?> objectNodeClass = Class.forName("com.fasterxml.jackson.databind.node.ObjectNode");
+      return objectNodeClass.isInstance(value);
+    } catch (ClassNotFoundException e) {
+      // value cannot be an ObjectNode because the class couldn't be located
+      return false;
+    }
   }
 
   private static boolean isAnOrderedCollection(Object value) {
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_iterableValues_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_iterableValues_Test.java
index 6cddfaa4c..e76851a71 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_iterableValues_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_iterableValues_Test.java
@@ -13,7 +13,7 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static com.google.common.collect.Sets.newHashSet;
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
@@ -26,6 +26,10 @@ import java.util.stream.Stream;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.MethodSource;
 
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
 class DualValue_iterableValues_Test {
 
   private static final List<String> PATH = list("foo", "bar");
@@ -38,7 +42,7 @@ class DualValue_iterableValues_Test {
     // WHEN
     boolean isActualFieldAnOrderedCollection = dualValue.isActualFieldAnOrderedCollection();
     // THEN
-    assertThat(isActualFieldAnOrderedCollection).isTrue();
+    then(isActualFieldAnOrderedCollection).isTrue();
   }
 
   @ParameterizedTest
@@ -49,7 +53,7 @@ class DualValue_iterableValues_Test {
     // WHEN
     boolean isExpectedFieldAnOrderedCollection = dualValue.isExpectedFieldAnOrderedCollection();
     // THEN
-    assertThat(isExpectedFieldAnOrderedCollection).isTrue();
+    then(isExpectedFieldAnOrderedCollection).isTrue();
   }
 
   static Stream<Iterable<?>> orderedCollections() {
@@ -64,7 +68,7 @@ class DualValue_iterableValues_Test {
     // WHEN
     boolean isActualFieldAnOrderedCollection = dualValue.isActualFieldAnOrderedCollection();
     // THEN
-    assertThat(isActualFieldAnOrderedCollection).isFalse();
+    then(isActualFieldAnOrderedCollection).isFalse();
   }
 
   @ParameterizedTest
@@ -75,7 +79,7 @@ class DualValue_iterableValues_Test {
     // WHEN
     boolean isExpectedFieldAnOrderedCollection = dualValue.isExpectedFieldAnOrderedCollection();
     // THEN
-    assertThat(isExpectedFieldAnOrderedCollection).isFalse();
+    then(isExpectedFieldAnOrderedCollection).isFalse();
   }
 
   static Stream<Object> nonOrdered() {
@@ -90,7 +94,7 @@ class DualValue_iterableValues_Test {
     // WHEN
     boolean isActualFieldAnIterable = dualValue.isActualFieldAnIterable();
     // THEN
-    assertThat(isActualFieldAnIterable).isTrue();
+    then(isActualFieldAnIterable).isTrue();
   }
 
   @ParameterizedTest
@@ -101,7 +105,7 @@ class DualValue_iterableValues_Test {
     // WHEN
     boolean isExpectedFieldAnIterable = dualValue.isExpectedFieldAnIterable();
     // THEN
-    assertThat(isExpectedFieldAnIterable).isTrue();
+    then(isExpectedFieldAnIterable).isTrue();
   }
 
   static Stream<Iterable<?>> iterables() {
@@ -116,7 +120,7 @@ class DualValue_iterableValues_Test {
     // WHEN
     boolean isActualFieldAnIterable = dualValue.isActualFieldAnIterable();
     // THEN
-    assertThat(isActualFieldAnIterable).isFalse();
+    then(isActualFieldAnIterable).isFalse();
   }
 
   @ParameterizedTest
@@ -127,12 +131,74 @@ class DualValue_iterableValues_Test {
     // WHEN
     boolean isExpectedFieldAnIterable = dualValue.isExpectedFieldAnIterable();
     // THEN
-    assertThat(isExpectedFieldAnIterable).isFalse();
+    then(isExpectedFieldAnIterable).isFalse();
   }
 
   static Stream<Object> nonIterables() {
-    // even though Path is an iterable, it must not be considered as such
     return Stream.of(123, "abc", array("a", "b"), Paths.get("/tmp"));
   }
 
+  @ParameterizedTest
+  @MethodSource("iterableJsonNodes")
+  void isExpectedFieldAnIterable_should_return_true_when_expected_is_an_array_json_node(JsonNode expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected.findValue("value"));
+    // WHEN
+    boolean isExpectedFieldAnIterable = dualValue.isExpectedFieldAnIterable();
+    // THEN
+    then(isExpectedFieldAnIterable).isTrue();
+  }
+
+  @ParameterizedTest
+  @MethodSource("nonIterableJsonNodes")
+  void isExpectedFieldAnIterable_should_return_false_when_expected_is_a_json_node_that_should_not_be_treated_as_an_iterable(JsonNode expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "", expected.findValue("value"));
+    // WHEN
+    boolean isExpectedFieldAnIterable = dualValue.isExpectedFieldAnIterable();
+    // THEN
+    then(isExpectedFieldAnIterable).isFalse();
+  }
+
+  @ParameterizedTest
+  @MethodSource("iterableJsonNodes")
+  void isActualFieldAnIterable_should_return_true_when_actual_is_an_array_json_node(JsonNode actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual.findValue("value"), "");
+    // WHEN
+    boolean isActualFieldAnIterable = dualValue.isActualFieldAnIterable();
+    // THEN
+    then(isActualFieldAnIterable).isTrue();
+  }
+
+  @ParameterizedTest
+  @MethodSource("nonIterableJsonNodes")
+  void isActualFieldAnIterable_should_return_false_when_actual_is_a_json_node_that_should_not_be_treated_as_an_iterable(JsonNode actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual.findValue("value"), "");
+    // WHEN
+    boolean isActualFieldAnIterable = dualValue.isActualFieldAnIterable();
+    // THEN
+    then(isActualFieldAnIterable).isFalse();
+  }
+
+  static Stream<JsonNode> iterableJsonNodes() {
+    return Stream.of("{\"value\": []}")
+                 .map(json -> toJsonNode(json));
+  }
+
+  static Stream<JsonNode> nonIterableJsonNodes() {
+    return Stream.of("{\"value\": \"foo\"}", "{\"value\": 42}", "{\"value\": true}", "{\"value\": {}}")
+                 .map(json -> toJsonNode(json));
+  }
+
+  private static JsonNode toJsonNode(String value) {
+    ObjectMapper objectMapper = new ObjectMapper();
+    try {
+      return objectMapper.readTree(value);
+    } catch (JsonProcessingException e) {
+      throw new RuntimeException(e);
+    }
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
index 6833078a7..2d00933a2 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -12,8 +12,9 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
+import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.entry;
+import static org.assertj.core.api.BDDAssertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.recursive.comparison.Color.BLUE;
 import static org.assertj.core.api.recursive.comparison.Color.GREEN;
@@ -22,10 +23,12 @@ import static org.assertj.core.api.recursive.comparison.RecursiveComparisonAsser
 import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
 import static org.assertj.core.error.ShouldNotBeNull.shouldNotBeNull;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
+import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.util.Lists.list;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 import static org.mockito.Mockito.verify;
 
+import java.io.IOException;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.sql.Timestamp;
@@ -46,6 +49,9 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
 @DisplayName("RecursiveComparisonAssert isEqualTo")
 class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert_isEqualTo_BaseTest {
 
@@ -422,6 +428,38 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
                 .isEqualTo(expected);
   }
 
+  @Test
+  void should_not_handle_value_node_as_iterable() throws IOException {
+    // GIVEN
+    ObjectMapper om = new ObjectMapper();
+    JsonNode actual = om.readTree("{\"someNotImportantValue\":1,\"importantValue\":\"10\"}");
+    JsonNode expected = om.readTree("{\"someNotImportantValue\":10,\"importantValue\":\"1\"}");
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference1 = diff("_children.importantValue._value", "10", "1");
+    ComparisonDifference difference2 = diff("_children.someNotImportantValue._value", 1, 10);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference1, difference2);
+  }
+
+  // issue #2459
+  @Test
+  void should_not_handle_object_node_as_iterable() throws IOException {
+    // GIVEN
+    ObjectMapper om = new ObjectMapper();
+    JsonNode actual = om.readTree("{\"someNotImportantValue\":1,\"importantValue\":\"10\"}");
+    JsonNode expected = om.readTree("{\"foo\":1,\"bar\":\"10\"}");
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("_children",
+                                           mapOf(entry("importantValue", "10"), entry("someNotImportantValue", 1)),
+                                           mapOf(entry("bar", "10"), entry("foo", 1)),
+                                           format("The following actual map entries were not found in the expected map:%n"
+                                                  + "  {importantValue=\"10\", someNotImportantValue=1}"));
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
+
   public static class Wrappers {
     private List<Wrapper> values;
 
