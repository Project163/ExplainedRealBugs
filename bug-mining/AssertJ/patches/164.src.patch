diff --git a/src/main/java/org/assertj/core/error/ShouldContainCharSequenceSequence.java b/src/main/java/org/assertj/core/error/ShouldContainCharSequenceSequence.java
deleted file mode 100644
index bfb88b996..000000000
--- a/src/main/java/org/assertj/core/error/ShouldContainCharSequenceSequence.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- * Copyright 2012-2015 the original author or authors.
- */
-package org.assertj.core.error;
-
-import org.assertj.core.internal.ComparisonStrategy;
-import org.assertj.core.internal.StandardComparisonStrategy;
-
-/**
- * Creates an error message indicating that an assertion that verifies that a {@code CharSequence} contains a sequence of
- * several {@code CharSequence}s in order failed.
- * 
- * @author Joel Costigliola
- * @author Mikhail Mazursky
- */
-public class ShouldContainCharSequenceSequence extends BasicErrorMessageFactory {
-
-  /**
-   * Creates a new <code>{@link ShouldContainCharSequenceSequence}</code>.
-   * 
-   * @param actual the actual value in the failed assertion.
-   * @param strings the sequence of values expected to be in {@code actual}.
-   * @return the created {@code ErrorMessageFactory}.
-   */
-  public static ErrorMessageFactory shouldContainSequence(CharSequence actual, CharSequence[] strings, int firstBadOrderIndex) {
-    return shouldContainSequence(actual, strings, firstBadOrderIndex, StandardComparisonStrategy.instance());
-  }
-
-  /**
-   * Creates a new <code>{@link ShouldContainCharSequenceSequence}</code>.
-   * 
-   * @param actual the actual value in the failed assertion.
-   * @param strings the sequence of values expected to be in {@code actual}.
-   * @param comparisonStrategy the {@link ComparisonStrategy} used to evaluate assertion.
-   * @return the created {@code ErrorMessageFactory}.
-   */
-  public static ErrorMessageFactory shouldContainSequence(CharSequence actual, CharSequence[] strings, int badOrderIndex,
-      ComparisonStrategy comparisonStrategy) {
-
-    return new ShouldContainCharSequenceSequence(
-                                           "%nExpecting:%n <%s>%nto contain the following CharSequences in this order:%n <%s>%nbut <%s> was found before <%s>%n%s",
-                                           actual, strings, strings[badOrderIndex + 1], strings[badOrderIndex],
-                                           comparisonStrategy);
-  }
-
-  private ShouldContainCharSequenceSequence(String format, CharSequence actual, CharSequence[] strings, CharSequence foundButBadOrder,
-      CharSequence foundButBadOrder2, ComparisonStrategy comparisonStrategy) {
-    super(format, actual, strings, foundButBadOrder, foundButBadOrder2, comparisonStrategy);
-  }
-
-}
diff --git a/src/main/java/org/assertj/core/internal/Iterables.java b/src/main/java/org/assertj/core/internal/Iterables.java
index d10c0fc78..cb80299f6 100644
--- a/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/src/main/java/org/assertj/core/internal/Iterables.java
@@ -340,15 +340,12 @@ public class Iterables {
    * @throws AssertionError if the given {@code Iterable} does not contain the given sequence of objects.
    */
   public void assertContainsSequence(AssertionInfo info, Iterable<?> actual, Object[] sequence) {
-    if (commonCheckThatIterableAssertionSucceeds(info, actual, sequence))
-      return;
+    if (commonCheckThatIterableAssertionSucceeds(info, actual, sequence)) return;
     // check for elements in values that are missing in actual.
     List<?> actualAsList = newArrayList(actual);
     for (int i = 0; i < actualAsList.size(); i++) {
       // look for given sequence in actual starting from current index (i)
-      if (containsSequenceAtGivenIndex(actualAsList, sequence, i)) {
-        return;
-      }
+      if (containsSequenceAtGivenIndex(actualAsList, sequence, i)) return;
     }
     throw actualDoesNotContainSequence(info, actual, sequence);
   }
diff --git a/src/main/java/org/assertj/core/internal/Strings.java b/src/main/java/org/assertj/core/internal/Strings.java
index c0625cfda..e967cc8fb 100644
--- a/src/main/java/org/assertj/core/internal/Strings.java
+++ b/src/main/java/org/assertj/core/internal/Strings.java
@@ -24,9 +24,9 @@ import static org.assertj.core.error.ShouldBeSubstring.shouldBeSubstring;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContainIgnoringCase;
 import static org.assertj.core.error.ShouldContainCharSequenceOnlyOnce.shouldContainOnlyOnce;
-import static org.assertj.core.error.ShouldContainCharSequenceSequence.shouldContainSequence;
 import static org.assertj.core.error.ShouldContainOnlyDigits.shouldContainOnlyDigits;
 import static org.assertj.core.error.ShouldContainPattern.shouldContainPattern;
+import static org.assertj.core.error.ShouldContainSequence.shouldContainSequence;
 import static org.assertj.core.error.ShouldEndWith.shouldEndWith;
 import static org.assertj.core.error.ShouldMatchPattern.shouldMatch;
 import static org.assertj.core.error.ShouldNotBeEmpty.shouldNotBeEmpty;
@@ -51,8 +51,10 @@ import static org.assertj.core.util.xml.XmlStringPrettyFormatter.xmlPrettyFormat
 import java.io.IOException;
 import java.io.LineNumberReader;
 import java.io.StringReader;
+import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -230,7 +232,7 @@ public class Strings {
     assertNotNull(info, actual);
     checkIsNotNull(values);
     checkIsNotEmpty(values);
-    checkCharSequenceIsNotNull(values[0]);
+    checkCharSequenceArrayDoesNotHaveNullElements(values);
     Set<CharSequence> notFound = new LinkedHashSet<>();
     for (CharSequence value : values) {
       if (!stringContains(actual, value)) {
@@ -592,35 +594,64 @@ public class Strings {
     Objects.instance().assertNotNull(info, actual);
   }
 
-  public void assertContainsSequence(AssertionInfo info, CharSequence actual, CharSequence[] values) {
+  public void assertContainsSequence(AssertionInfo info, CharSequence actual, CharSequence[] sequence) {
     assertNotNull(info, actual);
-    checkIsNotNull(values);
-    checkIsNotEmpty(values);
-    checkCharSequenceIsNotNull(values[0]);
+    checkIsNotNull(sequence);
+    checkIsNotEmpty(sequence);
+    checkCharSequenceArrayDoesNotHaveNullElements(sequence);
+
     Set<CharSequence> notFound = new LinkedHashSet<>();
-    for (CharSequence value : values) {
-      if (!stringContains(actual, value))
-        notFound.add(value);
+    for (CharSequence value : sequence) {
+      if (!stringContains(actual, value)) notFound.add(value);
     }
-    if (notFound.isEmpty()) {
-      if (values.length == 1) {
-        // nothing to check, assertion succeeded.
-        return;
-      }
-      // we have found all the given values but were they in the correct order ?
-      String strActual = actual.toString();
-      for (int i = 1; i < values.length; i++) {
-        if (strActual.indexOf(values[i - 1].toString()) > strActual.indexOf(values[i].toString())) {
-          throw failures.failure(info, shouldContainSequence(actual, values, i - 1, comparisonStrategy));
-        }
+
+    if (!notFound.isEmpty()) {
+      // don't bother looking for a sequence, some of the sequence elements were not found !
+      if (notFound.size() == 1 && sequence.length == 1) {
+        throw failures.failure(info, shouldContain(actual, sequence[0], comparisonStrategy));
       }
-      // assertion succeeded
-      return;
+      throw failures.failure(info, shouldContain(actual, sequence, notFound, comparisonStrategy));
     }
-    if (notFound.size() == 1 && values.length == 1) {
-      throw failures.failure(info, shouldContain(actual, values[0], comparisonStrategy));
+
+    // we have found all the given values but were they in the expected sequence ?
+    if (sequence.length == 1) return; // no order chekec needed for a one element sequence
+
+    // convert all to one char CharSequence list to ease comparison
+    List<CharSequence> splitActual = split(actual);
+    List<CharSequence> splitSequence = flatSplit(sequence);
+    for (int i = 0; i < splitActual.size(); i++) {
+      // look for given sequence in actual starting from current index (i)
+      if (containsSequenceAtGivenIndex(splitActual, splitSequence, i)) return;
     }
-    throw failures.failure(info, shouldContain(actual, values, notFound, comparisonStrategy));
+    throw failures.failure(info, shouldContainSequence(actual, sequence, comparisonStrategy));
+  }
+
+  private List<CharSequence> flatSplit(CharSequence[] sequence) {
+    List<CharSequence> flatSplitCharSequence = new ArrayList<>();
+    for (int i = 0; i < sequence.length; i++) {
+      flatSplitCharSequence.addAll(split(sequence[i]));
+    }
+    return flatSplitCharSequence;
+  }
+
+  private List<CharSequence> split(CharSequence charSequence) {
+    checkNotNull(charSequence, "Expecting CharSequence not to be null");
+    int length = charSequence.length();
+    List<CharSequence> splitCharSequence = new ArrayList<>(length);
+    for (int i = 0; i < length; i++) {
+      splitCharSequence.add(String.valueOf(charSequence.charAt(i)));
+    }
+    return splitCharSequence;
+  }
+
+  private boolean containsSequenceAtGivenIndex(List<CharSequence> actualAsList, List<CharSequence> sequence,
+                                               int startingIndex) {
+    // check that, starting from given index, actualAsList has enough remaining elements to contain sequence
+    if (actualAsList.size() - startingIndex < sequence.size()) return false;
+    for (int i = 0; i < sequence.size(); i++) {
+      if (!comparisonStrategy.areEqual(actualAsList.get(startingIndex + i), sequence.get(i))) return false;
+    }
+    return true;
   }
 
   public void assertXmlEqualsTo(AssertionInfo info, CharSequence actualXml, CharSequence expectedXml) {
@@ -679,4 +710,14 @@ public class Strings {
     if (!matcher.find()) throw failures.failure(info, shouldContainPattern(actual, pattern.pattern()));
   }
 
+  private void checkCharSequenceArrayDoesNotHaveNullElements(CharSequence[] values) {
+    if (values.length == 1) {
+      checkCharSequenceIsNotNull(values[0]);
+    } else {
+      for (int i = 0; i < values.length; i++) {
+        checkNotNull(values[i], "Expecting CharSequence elements not to be null but found one at index " + i);
+      }
+    }
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java
deleted file mode 100644
index 0f44748b6..000000000
--- a/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java
+++ /dev/null
@@ -1,67 +0,0 @@
-/**
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- * Copyright 2012-2015 the original author or authors.
- */
-package org.assertj.core.error;
-
-import static org.assertj.core.api.Assertions.assertThat;
-
-import static org.assertj.core.error.ShouldContainCharSequenceSequence.shouldContainSequence;
-
-import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.Test;
-
-import org.assertj.core.description.TextDescription;
-import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
-import org.assertj.core.util.CaseInsensitiveStringComparator;
-
-/**
- * Tests for <code>{@link ShouldContainCharSequenceSequence#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
- * 
- * @author Joel Costigliola
- */
-public class ShouldContainSequenceString_create_Test {
-
-  private ErrorMessageFactory factory;
-
-  @Test
-  public void should_create_error_message() {
-    String[] sequenceValues = { "{", "author", "title", "}" };
-    String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
-
-    factory = shouldContainSequence(actual, sequenceValues, 1);
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertThat(message).isEqualTo(String.format(
-        "[Test] %nExpecting:%n <\"" + actual + "\">%n"
-        + "to contain the following CharSequences in this order:%n"
-        + " <[\"{\", \"author\", \"title\", \"}\"]>%n"
-        + "but <\"title\"> was found before <\"author\">%n"
-    ));
-  }
-
-  @Test
-  public void should_create_error_message_with_custom_comparison_strategy() {
-    String[] sequenceValues = { "{", "author", "title", "}" };
-    String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
-
-    factory = shouldContainSequence(actual, sequenceValues, 1,
-                                    new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertThat(message).isEqualTo(String.format(
-        "[Test] %nExpecting:%n <\"" + actual + "\">%n"
-        + "to contain the following CharSequences in this order:%n"
-        + " <[\"{\", \"author\", \"title\", \"}\"]>%n"
-        + "but <\"title\"> was found before <\"author\">%n"
-        + "when comparing values using 'CaseInsensitiveStringComparator'"
-    ));
-  }
-
-}
diff --git a/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsSequence_Test.java b/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsSequence_Test.java
index 5259aa1d5..9072506a1 100644
--- a/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsSequence_Test.java
+++ b/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsSequence_Test.java
@@ -131,6 +131,12 @@ public class Iterables_assertContainsSequence_Test extends IterablesBaseTest {
     iterables.assertContainsSequence(someInfo(), actual, array("Yoda", "Obi-Wan"));
   }
 
+  @Test
+  public void should_pass_if_actual_contains_sequence_that_specifies_multiple_times_the_same_value_bug_544() {
+    actual = newArrayList("a", "-", "b", "-", "c");
+    iterables.assertContainsSequence(someInfo(), actual, array("a", "-", "b", "-", "c"));
+  }
+  
   // ------------------------------------------------------------------------------------------------------------------
   // tests using a custom comparison strategy
   // ------------------------------------------------------------------------------------------------------------------
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSequence_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSequence_Test.java
index e570ab7ab..831319354 100644
--- a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSequence_Test.java
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSequence_Test.java
@@ -13,7 +13,7 @@
 package org.assertj.core.internal.strings;
 
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
-import static org.assertj.core.error.ShouldContainCharSequenceSequence.shouldContainSequence;
+import static org.assertj.core.error.ShouldContainSequence.shouldContainSequence;
 import static org.assertj.core.test.ErrorMessages.arrayOfValuesToLookForIsEmpty;
 import static org.assertj.core.test.ErrorMessages.arrayOfValuesToLookForIsNull;
 import static org.assertj.core.test.TestData.someInfo;
@@ -21,21 +21,12 @@ import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErr
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
-
 import static org.mockito.Mockito.verify;
 
-import org.junit.Test;
-
 import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.Strings;
 import org.assertj.core.internal.StringsBaseTest;
+import org.junit.Test;
 
-/**
- * Tests for <code>{@link Strings#assertContains(AssertionInfo, CharSequence, CharSequence)}</code>.
- * 
- * @author Alex Ruiz
- * @author Joel Costigliola
- */
 public class Strings_assertContainsSequence_Test extends StringsBaseTest {
 
   @Test
@@ -62,8 +53,9 @@ public class Strings_assertContainsSequence_Test extends StringsBaseTest {
     String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
     try {
       strings.assertContainsSequence(info, actual, sequenceValues);
+      strings.assertContainsSequence(info, actual, sequenceValues);
     } catch (AssertionError e) {
-      verify(failures).failure(info, shouldContainSequence(actual, sequenceValues, 1));
+      verify(failures).failure(info, shouldContainSequence(actual, sequenceValues));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
@@ -84,21 +76,27 @@ public class Strings_assertContainsSequence_Test extends StringsBaseTest {
   @Test
   public void should_fail_if_actual_is_null() {
     thrown.expectAssertionError(actualIsNull());
-    strings.assertContains(someInfo(), null, "Yoda");
+    strings.assertContainsSequence(someInfo(), (CharSequence)null, array("Yo", "da"));
   }
 
   @Test
   public void should_pass_if_actual_contains_all_given_strings() {
-    strings.assertContains(someInfo(), "Yoda", "Yo", "da");
+    strings.assertContainsSequence(someInfo(), "Yoda", array("Yo", "da"));
   }
 
+  @Test
+  public void should_pass_if_actual_contains_sequence_that_specifies_multiple_times_the_same_value_bug_544() {
+    strings.assertContainsSequence(someInfo(), "a-b-c-", array("a", "-", "b", "-", "c"));
+  }
+  
+  
   // tests with custom comparison strategy
 
   @Test
   public void should_pass_if_actual_contains_sequence_according_to_custom_comparison_strategy() {
     stringsWithCaseInsensitiveComparisonStrategy.assertContainsSequence(someInfo(), "Yoda", array("Yo", "da"));
-    stringsWithCaseInsensitiveComparisonStrategy.assertContains(someInfo(), "Yoda", array("Yo", "DA"));
-    stringsWithCaseInsensitiveComparisonStrategy.assertContains(someInfo(), "Yoda", array("YO", "dA"));
+    stringsWithCaseInsensitiveComparisonStrategy.assertContainsSequence(someInfo(), "Yoda", array("Yo", "DA"));
+    stringsWithCaseInsensitiveComparisonStrategy.assertContainsSequence(someInfo(), "Yoda", array("YO", "dA"));
   }
 
   @Test
@@ -123,7 +121,7 @@ public class Strings_assertContainsSequence_Test extends StringsBaseTest {
     try {
       stringsWithCaseInsensitiveComparisonStrategy.assertContainsSequence(info, actual, sequenceValues);
     } catch (AssertionError e) {
-      verify(failures).failure(info, shouldContainSequence(actual, sequenceValues, 1, comparisonStrategy));
+      verify(failures).failure(info, shouldContainSequence(actual, sequenceValues, comparisonStrategy));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
