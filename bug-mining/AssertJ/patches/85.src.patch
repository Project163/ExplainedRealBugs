diff --git a/pom.xml b/pom.xml
index cc477a48a..eca813669 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd ">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd ">
 
   <modelVersion>4.0.0</modelVersion>
   <artifactId>assertj-core-java8</artifactId>
@@ -33,7 +34,7 @@
   </issueManagement>
   <properties>
     <additionalparam>-Xdoclint:none</additionalparam>
-  </properties>  
+  </properties>
   <dependencies>
     <dependency>
       <groupId>org.mockito</groupId>
@@ -46,8 +47,14 @@
     </dependency>
     <dependency>
       <groupId>cglib</groupId>
-      <artifactId>cglib-nodep</artifactId>
-      <version>2.2.2</version>
+      <artifactId>cglib</artifactId>
+      <version>3.1</version>
+      <optional>true</optional>
+    </dependency>
+    <dependency>
+      <groupId>org.ow2.asm</groupId>
+      <artifactId>asm</artifactId>
+      <version>5.0.3</version>
       <optional>true</optional>
     </dependency>
   </dependencies>
@@ -102,7 +109,7 @@
       <plugin>
         <groupId>org.apache.felix</groupId>
         <artifactId>maven-bundle-plugin</artifactId>
-        <version>2.3.7</version>
+        <version>2.5.3</version>
         <extensions>true</extensions>
         <configuration>
           <instructions>
@@ -120,28 +127,28 @@
       <plugin>
         <groupId>org.jacoco</groupId>
         <artifactId>jacoco-maven-plugin</artifactId>
-          <executions>
-            <execution>
-              <id>check</id>
-              <goals>
-                <goal>check</goal>
-              </goals>
-              <configuration>
-		        <rules>
-                  <rule implementation="org.jacoco.maven.RuleConfiguration">
-                    <element>BUNDLE</element>
-                    <limits>
-                      <limit implementation="org.jacoco.report.check.Limit">
-                        <counter>CLASS</counter>
-                        <value>COVEREDRATIO</value>
-                        <minimum>0.99</minimum>
-                      </limit>
-              	   </limits>
-		          </rule>
-                </rules>
-	      </configuration>
-            </execution>
-          </executions>
+        <executions>
+          <execution>
+            <id>check</id>
+            <goals>
+              <goal>check</goal>
+            </goals>
+            <configuration>
+              <rules>
+                <rule implementation="org.jacoco.maven.RuleConfiguration">
+                  <element>BUNDLE</element>
+                  <limits>
+                    <limit implementation="org.jacoco.report.check.Limit">
+                      <counter>CLASS</counter>
+                      <value>COVEREDRATIO</value>
+                      <minimum>0.99</minimum>
+                    </limit>
+                  </limits>
+                </rule>
+              </rules>
+            </configuration>
+          </execution>
+        </executions>
       </plugin>
       <!-- to get jacoco report we need to set argLine in surefire, without this snippet the jacoco argLine is lost -->
       <plugin>
@@ -161,10 +168,16 @@
               <goal>jarjar</goal>
             </goals>
             <configuration>
+              <!-- TODO add ASM / or get rid of CGLIB -->
               <includes>
-                <include>cglib:cglib-nodep</include>
+                <include>cglib:cglib</include>
+                <include>org.ow2.asm:asm</include>
               </includes>
               <rules>
+                <rule>
+                  <pattern>org.objectweb.asm.**</pattern>
+                  <result>org.assertj.core.internal.asm.@1</result>
+                </rule>
                 <rule>
                   <pattern>net.sf.cglib.**</pattern>
                   <result>org.assertj.core.internal.cglib.@1</result>
diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 3fb551b02..c695a02cd 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -12,6 +12,8 @@
  */
 package org.assertj.core.api;
 
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.StreamSupport.stream;
 import static org.assertj.core.extractor.Extractors.byName;
 import static org.assertj.core.extractor.Extractors.resultOf;
 import static org.assertj.core.util.Iterables.toArray;
@@ -21,6 +23,7 @@ import java.util.Collection;
 import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
+import java.util.function.Function;
 
 import org.assertj.core.api.iterable.Extractor;
 import org.assertj.core.groups.FieldsOrPropertiesExtractor;
@@ -51,7 +54,7 @@ import org.assertj.core.util.introspection.IntrospectionError;
  * @author Mathieu Baechler
  * @author Joel Costigliola
  * @author Maciej Jaskowski
- * @author Nicolas François
+ * @author Nicolas François 
  * @author Mikhail Mazursky
  * @author Mateusz Haligowski
  */
@@ -317,7 +320,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
 	iterables.assertAreAtLeast(info, actual, times, condition);
 	return myself;
   }
-  
+
   /**
    * {@inheritDoc}
    */
@@ -837,6 +840,76 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
 	return new ListAssert<V>(result);
   }
 
+  /**
+   * Use the given {@link Function}s to extract the values from the Iterable's elements under test into a new Iterable
+   * composed of {@link Tuple} (a simple data structure containing th extracted values), this new Iterable becoming the
+   * Iterable under test.
+   * <p/>
+   * It allows you to test values from the Iterable's elements instead of testing the elements themselves, it can be
+   * sometimes much less work!
+   * <p/>
+   * The Tuple data corresponds to the extracted values from the Iterable's elements, for instance if you pass functions
+   * extracting "id", "name" and "email" values then each Tuple data will be composed of an id, a name and an email
+   * extracted from the element of the initial Iterable (the Tuple's data order is the same as the given functions
+   * order).
+   * <p/>
+   * Let's take an example to make things clearer :
+   * 
+   * <pre><code class='java'>
+   * // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
+   * // they can be public field or properties, both can be extracted.
+   * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
+   * 
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Legolas&quot;, 1000, ELF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Pippin&quot;, 28, HOBBIT));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
+   * 
+   * // let's verify 'name', 'age' and Race of some TolkienCharacter in fellowshipOfTheRing :
+   * 
+   * assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName,
+   *                                            character -> character.getAge(),
+   *                                            TolkienCharacter::getRace)
+   *                                .containsOnly(tuple("Frodo", 33, HOBBIT),
+   *                                              tuple("Sam", 38, HOBBIT),
+   *                                              tuple("Gandalf", 2020, MAIA),
+   *                                              tuple("Legolas", 1000, ELF),
+   *                                              tuple("Pippin", 28, HOBBIT),
+   *                                              tuple("Gimli", 139, DWARF),
+   *                                              tuple("Aragorn", 87, MAN),
+   *                                              tuple("Boromir", 37, MAN));
+   * </code></pre>
+   * You can use lambda expression or a method reference to extract the expected values.
+   * <p/>
+   * Use {@link Tuple#tuple(Object...)} to initialize the expected values.
+   * <p/>
+   * Note that the order of the extracted tuples list is consistent with the iteration order of the Iterable under test,
+   * for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted tuples order.
+   * 
+   * @param extractors the extractor functions to extract a value from an element of the Iterable under test.
+   * @return a new assertion object whose object under test is the list of Tuple containing the extracted values.
+   */
+  @SafeVarargs
+  public final ListAssert<Tuple> extracting(Function<T, ?>... extractors) {
+	// combine all extractors into one function
+	Function<T, Tuple> tupleExtractor = objectToExtractValueFrom -> {
+	  Tuple tuple = new Tuple();
+	  for (Function<T, ?> extractor : extractors) {
+		// extract value one by one
+		tuple.addData(extractor.apply(objectToExtractValueFrom));
+	  }
+	  return tuple;
+	};
+
+	List<Tuple> tuples = stream(actual.spliterator(), false).map(tupleExtractor)
+	                                                        .collect(toList());
+	return new ListAssert<Tuple>(tuples);
+  }
+
   /**
    * Same as {@link #containsExactly(Object[])} but handle the {@link Iterable} to array conversion. Same semantic as
    * {@link #containsExactly(Object...)} : verifies that actual contains all the elements of the given iterable and
@@ -952,8 +1025,8 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * <p/>
    * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
    * (e.g. public) or fields with an accessible getter.<br/>
-   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other field
-   * using its <code>equals</code> method.
+   * Moreover comparison is <b>not</b> recursive, if one of the field is an Object, it will be compared to the other
+   * field using its <code>equals</code> method.
    * </p>
    * Example:
    *
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
index 48d08a4f7..3a427cd45 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
@@ -15,10 +15,14 @@ package org.assertj.core.api.iterable;
 import static org.assertj.core.api.Assertions.*;
 import static org.assertj.core.test.ExpectedException.*;
 import static org.assertj.core.util.Lists.*;
+import static org.assertj.core.data.TolkienCharacter.Race.*;
 
+import java.util.ArrayList;
 import java.util.Comparator;
+import java.util.List;
 
 import org.assertj.core.api.AbstractIterableAssert;
+import org.assertj.core.data.TolkienCharacter;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
@@ -40,26 +44,35 @@ public class IterableAssert_extracting_Test {
   private Employee yoda;
   private Employee luke;
   private Iterable<Employee> employees;
+  private final List<TolkienCharacter> fellowshipOfTheRing = new ArrayList<>();
 
   private static final Extractor<Employee, String> firstName = new Extractor<Employee, String>() {
-    @Override
-    public String extract(Employee input) {
-      return input.getName().getFirst();
-    }
+	@Override
+	public String extract(Employee input) {
+	  return input.getName().getFirst();
+	}
   };
-  
+
   private static final Extractor<Employee, Integer> age = new Extractor<Employee, Integer>() {
-    @Override
-    public Integer extract(Employee input) {
-      return input.getAge();
-    }
+	@Override
+	public Integer extract(Employee input) {
+	  return input.getAge();
+	}
   };
-  
+
   @Before
   public void setUp() {
-    yoda = new Employee(1L, new Name("Yoda"), 800);
-    luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
-    employees = newArrayList(yoda, luke);
+	yoda = new Employee(1L, new Name("Yoda"), 800);
+	luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+	employees = newArrayList(yoda, luke);
+	fellowshipOfTheRing.add(TolkienCharacter.of("Frodo", 33, HOBBIT));
+	fellowshipOfTheRing.add(TolkienCharacter.of("Sam", 38, HOBBIT));
+	fellowshipOfTheRing.add(TolkienCharacter.of("Gandalf", 2020, MAIA));
+	fellowshipOfTheRing.add(TolkienCharacter.of("Legolas", 1000, ELF));
+	fellowshipOfTheRing.add(TolkienCharacter.of("Pippin", 28, HOBBIT));
+	fellowshipOfTheRing.add(TolkienCharacter.of("Gimli", 139, DWARF));
+	fellowshipOfTheRing.add(TolkienCharacter.of("Aragorn", 87, MAN));
+	fellowshipOfTheRing.add(TolkienCharacter.of("Boromir", 37, MAN));
   }
 
   @Rule
@@ -67,107 +80,206 @@ public class IterableAssert_extracting_Test {
 
   @Test
   public void should_allow_assertions_on_property_values_extracted_from_given_iterable() throws Exception {
-    assertThat(employees).as("extract property backed by a private field")
-                         .extracting("age")
-                         .containsOnly(800, 26);
-    assertThat(employees).as("extract pure property")
-                         .extracting("adult")
-                         .containsOnly(true, true);
-    assertThat(employees).as("nested property")
-                         .extracting("name.first")
-                         .containsOnly("Yoda", "Luke");
-    assertThat(employees).as("extract field that is also a property")
-                         .extracting("name")
-                         .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
-    assertThat(employees).as("extract field that is also a property but specifiying the extracted type")
-                         .extracting("name", Name.class)
-                         .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+	assertThat(employees).as("extract property backed by a private field")
+	                     .extracting("age")
+	                     .containsOnly(800, 26);
+	assertThat(employees).as("extract pure property")
+	                     .extracting("adult")
+	                     .containsOnly(true, true);
+	assertThat(employees).as("nested property")
+	                     .extracting("name.first")
+	                     .containsOnly("Yoda", "Luke");
+	assertThat(employees).as("extract field that is also a property")
+	                     .extracting("name")
+	                     .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+	assertThat(employees).as("extract field that is also a property but specifiying the extracted type")
+	                     .extracting("name", Name.class)
+	                     .containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
   }
 
   @Test
   public void should_allow_assertions_on_null_property_values_extracted_from_given_iterable() throws Exception {
-    yoda.name.setFirst(null);
-    assertThat(employees).as("not null property but null nested property")
-                         .extracting("name.first")
-                         .containsOnly(null, "Luke");
-    yoda.setName(null);
-    assertThat(employees).as("extract nested property when top property is null")
-                         .extracting("name.first")
-                         .containsOnly(null, "Luke");
-    assertThat(employees).as("null property")
-                         .extracting("name")
-                         .containsOnly(null, new Name("Luke", "Skywalker"));
+	yoda.name.setFirst(null);
+	assertThat(employees).as("not null property but null nested property")
+	                     .extracting("name.first")
+	                     .containsOnly(null, "Luke");
+	yoda.setName(null);
+	assertThat(employees).as("extract nested property when top property is null")
+	                     .extracting("name.first")
+	                     .containsOnly(null, "Luke");
+	assertThat(employees).as("null property")
+	                     .extracting("name")
+	                     .containsOnly(null, new Name("Luke", "Skywalker"));
   }
 
   @Test
   public void should_allow_assertions_on_field_values_extracted_from_given_iterable() throws Exception {
-    assertThat(employees).as("extract field")
-                         .extracting("id")
-                         .containsOnly(1L, 2L);
-    assertThat(employees).as("null field")
-                         .extracting("surname")
-                         .containsNull();
-    assertThat(employees).as("null nested field")
-                         .extracting("surname.first")
-                         .containsNull();
-    yoda.surname = new Name();
-    assertThat(employees).as("not null field but null nested field")
-                         .extracting("surname.first")
-                         .containsNull();
-    yoda.surname = new Name("Master");
-    assertThat(employees).as("nested field")
-                         .extracting("surname.first")
-                         .containsOnly("Master", null);
-    assertThat(employees).as("extract field specifiying the extracted type")
-                         .extracting("surname", Name.class)
-                         .containsOnly(new Name("Master"), null);
+	assertThat(employees).as("extract field")
+	                     .extracting("id")
+	                     .containsOnly(1L, 2L);
+	assertThat(employees).as("null field")
+	                     .extracting("surname")
+	                     .containsNull();
+	assertThat(employees).as("null nested field")
+	                     .extracting("surname.first")
+	                     .containsNull();
+	yoda.surname = new Name();
+	assertThat(employees).as("not null field but null nested field")
+	                     .extracting("surname.first")
+	                     .containsNull();
+	yoda.surname = new Name("Master");
+	assertThat(employees).as("nested field")
+	                     .extracting("surname.first")
+	                     .containsOnly("Master", null);
+	assertThat(employees).as("extract field specifiying the extracted type")
+	                     .extracting("surname", Name.class)
+	                     .containsOnly(new Name("Master"), null);
   }
 
   @Test
   public void should_allow_assertions_on_property_values_extracted_from_given_iterable_with_extracted_type_defined()
-      throws Exception {
-    // extract field that is also a property and check generic for comparator.
-    assertThat(employees).extracting("name", Name.class).usingElementComparator(new Comparator<Name>() {
-      @Override
-      public int compare(Name o1, Name o2) {
-        return o1.getFirst().compareTo(o2.getFirst());
-      }
-    }).containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+	  throws Exception {
+	// extract field that is also a property and check generic for comparator.
+	assertThat(employees).extracting("name", Name.class).usingElementComparator(new Comparator<Name>() {
+	  @Override
+	  public int compare(Name o1, Name o2) {
+		return o1.getFirst().compareTo(o2.getFirst());
+	  }
+	}).containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
   }
 
   @Test
   public void should_throw_error_if_no_property_nor_field_with_given_name_can_be_extracted() throws Exception {
-    thrown.expect(IntrospectionError.class);
-    assertThat(employees).extracting("unknown");
+	thrown.expect(IntrospectionError.class);
+	assertThat(employees).extracting("unknown");
   }
 
   @Test
   public void should_allow_assertions_on_multiple_extracted_values_from_given_iterable() throws Exception {
-    assertThat(employees).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
-        tuple("Luke", 26, 2L));
+	assertThat(employees).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
+	                                                                         tuple("Luke", 26, 2L));
   }
 
   @Test
   public void should_throw_error_if_one_property_or_field_can_not_be_extracted() throws Exception {
-    thrown.expect(IntrospectionError.class);
-    assertThat(employees).extracting("unknown", "age", "id")
-        .containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+	thrown.expect(IntrospectionError.class);
+	assertThat(employees).extracting("unknown", "age", "id")
+	                     .containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
   }
 
   @Test
   public void should_allow_extracting_single_values_using_extractor() throws Exception {
-    assertThat(employees).extracting(firstName).containsOnly("Yoda", "Luke");
-    assertThat(employees).extracting(age).containsOnly(26, 800);
+	assertThat(employees).extracting(firstName).containsOnly("Yoda", "Luke");
+	assertThat(employees).extracting(age).containsOnly(26, 800);
   }
 
   @Test
   public void sohuld_allow_extracting_multiple_values_using_extractor() throws Exception {
-    assertThat(employees).extracting(new Extractor<Employee, Tuple>() {
-      @Override
-      public Tuple extract(Employee input) {
-        return new Tuple(input.getName().getFirst(), input.getAge(), input.id);
-      }
-    }).containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
-  }
-  
+	assertThat(employees).extracting(new Extractor<Employee, Tuple>() {
+	  @Override
+	  public Tuple extract(Employee input) {
+		return new Tuple(input.getName().getFirst(), input.getAge(), input.id);
+	  }
+	}).containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+  }
+
+  @Test
+  public void should_allow_assertions_by_using_function_extracted_from_given_iterable() throws Exception {
+	assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName)
+	                               .contains("Boromir", "Gandalf", "Frodo")
+	                               .doesNotContain("Sauron", "Elrond");
+  }
+
+  @Test
+  public void should_throw_error_if_function_fails() throws Exception {
+	RuntimeException thrown = new RuntimeException();
+	assertThatExceptionThrownBy(() -> assertThat(fellowshipOfTheRing).extracting(e -> {
+	  throw thrown;
+	}).isEqualTo(thrown));
+  }
+
+  @Test
+  public void should_allow_assertions_on_two_extracted_values_from_given_iterable_by_using_a_function() {
+
+	assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName, 
+	                                           TolkienCharacter::getAge)
+	                               .containsOnly(tuple("Frodo", 33),
+	                                             tuple("Sam", 38),
+	                                             tuple("Gandalf", 2020),
+	                                             tuple("Legolas", 1000),
+	                                             tuple("Pippin", 28),
+	                                             tuple("Gimli", 139),
+	                                             tuple("Aragorn", 87),
+	                                             tuple("Boromir", 37));
+  }
+
+  @Test
+  public void should_allow_assertions_on_three_extracted_values_from_given_iterable_by_using_a_function() {
+
+	assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName,
+	                                           TolkienCharacter::getAge,
+	                                           TolkienCharacter::getRace)
+	                               .containsOnly(tuple("Frodo", 33, HOBBIT),
+	                                             tuple("Sam", 38, HOBBIT),
+	                                             tuple("Gandalf", 2020, MAIA),
+	                                             tuple("Legolas", 1000, ELF),
+	                                             tuple("Pippin", 28, HOBBIT),
+	                                             tuple("Gimli", 139, DWARF),
+	                                             tuple("Aragorn", 87, MAN),
+	                                             tuple("Boromir", 37, MAN));
+  }
+
+  @Test
+  public void should_allow_assertions_on_four_extracted_values_from_given_iterable_by_using_a_function() {
+
+	assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName,
+	                                           TolkienCharacter::getAge,
+	                                           TolkienCharacter::getRace,
+	                                           character -> character.name)
+	                               .containsOnly(tuple("Frodo", 33, HOBBIT, "Frodo"),
+	                                             tuple("Sam", 38, HOBBIT, "Sam"),
+	                                             tuple("Gandalf", 2020, MAIA, "Gandalf"),
+	                                             tuple("Legolas", 1000, ELF, "Legolas"),
+	                                             tuple("Pippin", 28, HOBBIT, "Pippin"),
+	                                             tuple("Gimli", 139, DWARF, "Gimli"),
+	                                             tuple("Aragorn", 87, MAN, "Aragorn"),
+	                                             tuple("Boromir", 37, MAN, "Boromir"));
+  }
+
+  @Test
+  public void should_allow_assertions_on_five_extracted_values_from_given_iterable_by_using_a_function() {
+
+	assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName,
+	                                           TolkienCharacter::getAge,
+	                                           TolkienCharacter::getRace,
+	                                           character -> character.name,
+	                                           character -> character.age)
+	                               .containsOnly(tuple("Frodo", 33, HOBBIT, "Frodo", 33),
+	                                             tuple("Sam", 38, HOBBIT, "Sam", 38),
+	                                             tuple("Gandalf", 2020, MAIA, "Gandalf", 2020),
+	                                             tuple("Legolas", 1000, ELF, "Legolas", 1000),
+	                                             tuple("Pippin", 28, HOBBIT, "Pippin", 28),
+	                                             tuple("Gimli", 139, DWARF, "Gimli", 139),
+	                                             tuple("Aragorn", 87, MAN, "Aragorn", 87),
+	                                             tuple("Boromir", 37, MAN, "Boromir", 37));
+  }
+
+  @Test
+  public void should_allow_assertions_on_more_than_five_extracted_values_from_given_iterable_by_using_a_function() {
+
+	assertThat(fellowshipOfTheRing).extracting(TolkienCharacter::getName,
+	                                           TolkienCharacter::getAge,
+	                                           TolkienCharacter::getRace,
+	                                           character -> character.name,
+	                                           character -> character.age,
+	                                           character -> character.race)
+	                               .containsOnly(tuple("Frodo", 33, HOBBIT, "Frodo", 33, HOBBIT),
+	                                             tuple("Sam", 38, HOBBIT, "Sam", 38, HOBBIT),
+	                                             tuple("Gandalf", 2020, MAIA, "Gandalf", 2020, MAIA),
+	                                             tuple("Legolas", 1000, ELF, "Legolas", 1000, ELF),
+	                                             tuple("Pippin", 28, HOBBIT, "Pippin", 28, HOBBIT),
+	                                             tuple("Gimli", 139, DWARF, "Gimli", 139, DWARF),
+	                                             tuple("Aragorn", 87, MAN, "Aragorn", 87, MAN),
+	                                             tuple("Boromir", 37, MAN, "Boromir", 37, MAN));
+  }
 }
diff --git a/src/test/java/org/assertj/core/data/TolkienCharacter.java b/src/test/java/org/assertj/core/data/TolkienCharacter.java
new file mode 100644
index 000000000..02c010500
--- /dev/null
+++ b/src/test/java/org/assertj/core/data/TolkienCharacter.java
@@ -0,0 +1,43 @@
+package org.assertj.core.data;
+
+public class TolkienCharacter {
+
+  public static TolkienCharacter of(String name, Integer age, Race race) {
+
+	return new TolkienCharacter(name, age, race);
+  }
+
+  public static enum Race {
+	HOBBIT,
+	MAIA,
+	ELF,
+	DWARF,
+	MAN
+  }
+
+  public final String name;
+  public final Integer age;
+  public final Race race;
+
+  private TolkienCharacter(String name, Integer age, Race race) {
+
+	this.name = name;
+	this.age = age;
+	this.race = race;
+  }
+
+  public String getName() {
+
+	return name;
+  }
+
+  public Integer getAge() {
+
+	return age;
+  }
+
+  public Race getRace() {
+
+	return race;
+  }
+}
