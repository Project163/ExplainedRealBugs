diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index f21d07c95..825636805 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -82,8 +82,8 @@ public class RecursiveComparisonDifferenceCalculator {
       differences.add(new ComparisonDifference(dualValue));
     }
 
-    void addDifference(DualValue dualValue, String description, Object... args) {
-      differences.add(new ComparisonDifference(dualValue, format(description, args)));
+    void addDifference(DualValue dualValue, String description) {
+      differences.add(new ComparisonDifference(dualValue, description));
     }
 
     void addKeyDifference(DualValue parentDualValue, Object actualKey, Object expectedKey) {
@@ -268,8 +268,8 @@ public class RecursiveComparisonDifferenceCalculator {
       Class<?> actualFieldValueClass = actualFieldValue.getClass();
       Class<?> expectedFieldClass = expectedFieldValue.getClass();
       if (recursiveComparisonConfiguration.isInStrictTypeCheckingMode() && expectedTypeIsNotSubtypeOfActualType(dualValue)) {
-        comparisonState.addDifference(dualValue, STRICT_TYPE_ERROR, expectedFieldClass.getName(),
-                                      actualFieldValueClass.getName());
+        comparisonState.addDifference(dualValue,
+                                      format(STRICT_TYPE_ERROR, expectedFieldClass.getName(), actualFieldValueClass.getName()));
         continue;
       }
 
@@ -347,7 +347,7 @@ public class RecursiveComparisonDifferenceCalculator {
     int actualArrayLength = Array.getLength(dualValue.actual);
     int expectedArrayLength = Array.getLength(dualValue.expected);
     if (actualArrayLength != expectedArrayLength) {
-      comparisonState.addDifference(dualValue, DIFFERENT_SIZE_ERROR, "arrays", actualArrayLength, expectedArrayLength);
+      comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "arrays", actualArrayLength, expectedArrayLength));
       // no need to inspect elements, arrays are not equal as they don't have the same size
       return;
     }
@@ -367,15 +367,16 @@ public class RecursiveComparisonDifferenceCalculator {
   private static void compareOrderedCollections(DualValue dualValue, ComparisonState comparisonState) {
     if (!dualValue.isActualFieldAnOrderedCollection()) {
       // at the moment if expected is an ordered collection then actual should also be one
-      comparisonState.addDifference(dualValue, ACTUAL_NOT_ORDERED_COLLECTION, dualValue.actual.getClass().getCanonicalName());
+      comparisonState.addDifference(dualValue,
+                                    format(ACTUAL_NOT_ORDERED_COLLECTION, dualValue.actual.getClass().getCanonicalName()));
       return;
     }
 
     Collection<?> actualCollection = (Collection<?>) dualValue.actual;
     Collection<?> expectedCollection = (Collection<?>) dualValue.expected;
     if (actualCollection.size() != expectedCollection.size()) {
-      comparisonState.addDifference(dualValue, DIFFERENT_SIZE_ERROR,
-                                    "collections", actualCollection.size(), expectedCollection.size());
+      comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "collections", actualCollection.size(),
+                                                      expectedCollection.size()));
       // no need to inspect elements, arrays are not equal as they don't have the same size
       return;
     }
@@ -406,7 +407,7 @@ public class RecursiveComparisonDifferenceCalculator {
     int actualSize = sizeOf(actual);
     int expectedSize = sizeOf(expected);
     if (actualSize != expectedSize) {
-      comparisonState.addDifference(dualValue, DIFFERENT_SIZE_ERROR, "collections", actualSize, expectedSize);
+      comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "collections", actualSize, expectedSize));
       // no need to inspect elements, iterables are not equal as they don't have the same size
       return;
       // TODO instead we could register the diff between expected and actual that is:
@@ -456,7 +457,7 @@ public class RecursiveComparisonDifferenceCalculator {
     @SuppressWarnings("unchecked")
     Map<K, V> expectedMap = (Map<K, V>) dualValue.expected;
     if (actualMap.size() != expectedMap.size()) {
-      comparisonState.addDifference(dualValue, DIFFERENT_SIZE_ERROR, "sorted maps", actualMap.size(), expectedMap.size());
+      comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "sorted maps", actualMap.size(), expectedMap.size()));
       // no need to inspect entries, maps are not equal as they don't have the same size
       return;
       // TODO instead we could register the diff between expected and actual that is:
@@ -487,7 +488,7 @@ public class RecursiveComparisonDifferenceCalculator {
     Map<?, ?> actualMap = (Map<?, ?>) dualValue.actual;
     Map<?, ?> expectedMap = (Map<?, ?>) dualValue.expected;
     if (actualMap.size() != expectedMap.size()) {
-      comparisonState.addDifference(dualValue, DIFFERENT_SIZE_ERROR, "maps", actualMap.size(), expectedMap.size());
+      comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "maps", actualMap.size(), expectedMap.size()));
       // no need to inspect entries, maps are not equal as they don't have the same size
       return;
       // TODO instead we could register the diff between expected and actual that is:
@@ -507,8 +508,9 @@ public class RecursiveComparisonDifferenceCalculator {
                                                                .collect(toMap(entry -> entry.getKey(),
                                                                               entry -> actualMap.get(entry.getKey())));
     if (!unmatchedActualEntries.isEmpty()) {
-      comparisonState.addDifference(dualValue, "The following actual map entries were not found in the expected map:%n  %s",
-                                    unmatchedActualEntries);
+      comparisonState.addDifference(dualValue,
+                                    format("The following actual map entries were not found in the expected map:%n  %s",
+                                           unmatchedActualEntries));
       return;
     }
 
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
index d62a72203..7dc87643e 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
@@ -16,6 +16,8 @@ import static com.google.common.collect.Sets.newHashSet;
 import static java.lang.String.format;
 import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.tuple;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.recursive.comparison.Author.authorsTreeSet;
 import static org.assertj.core.util.Arrays.array;
@@ -29,9 +31,11 @@ import java.util.List;
 import java.util.Map;
 import java.util.Optional;
 import java.util.Set;
+import java.util.UnknownFormatConversionException;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
+import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.objects.data.PersonDto;
 import org.assertj.core.test.Person;
 import org.junit.jupiter.api.Test;
@@ -222,6 +226,20 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends RecursiveC
                                                      + "  [aaa]"));
   }
 
+  // https://github.com/assertj/assertj-core/issues/2279
+  @Test
+  void should_not_throw_UnknownFormatConversionException_when_unmatched_elements_have_percent_in_their_description() {
+    // GIVEN
+    List<Tuple> first = list(tuple("VtQh0ZAo%s2FKCnQcirWL", "foo % %d"), tuple("%F", "VtQh0ZAo%s2FKCnQcirWL"));
+    List<Tuple> second = list(tuple("%F", "VtQh0ZAo%s2FKCnQcirWL"), tuple("VtQh0ZAo%s2FKCnQcirWL", "bar % %d"));
+    // WHEN
+    Throwable thrown = catchThrowable(() -> assertThat(first).usingRecursiveComparison()
+                                                             .ignoringCollectionOrder()
+                                                             .isEqualTo(second));
+    // THEN
+    then(thrown).isNotInstanceOf(UnknownFormatConversionException.class);
+  }
+
   public static class WithCollection<E> {
     public Collection<E> group;
 
