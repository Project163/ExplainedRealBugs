diff --git a/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java b/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
index 65f19eed7..f838815ac 100644
--- a/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
@@ -222,8 +222,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Gandalf the grey&quot;).isEqualToIgnoringCase(&quot;Gandalf the white&quot;);</code></pre>
    * 
-   * </p>
-   * 
    * @param expected the given {@code CharSequence} to compare the actual {@code CharSequence} to.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual {@code CharSequence} is not equal to the given one.
@@ -268,8 +266,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * <pre><code class='java'> assertThat("10$").containsOnlyDigits();
    * assertThat("").containsOnlyDigits();</code></pre>
    *
-   * </p>
-   *
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual {@code CharSequence} contains non-digit characters.
    * @throws AssertionError if the actual {@code CharSequence} is {@code null}.
@@ -289,8 +285,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).containsOnlyOnce(&quot;o&quot;);</code></pre>
    * 
-   * </p>
-   * 
    * @param sequence the sequence to search for.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual {@code CharSequence} either does not contain the given one at all, or contains
@@ -400,8 +394,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Gandalf the grey&quot;).containsIgnoringCase(&quot;white&quot;);</code></pre>
    * 
-   * </p>
-   * 
    * @param sequence the sequence to search for.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given sequence is {@code null}.
@@ -424,8 +416,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).doesNotContain(&quot;Fro&quot;);</code></pre>
    * 
-   * </p>
-   * 
    * @param sequence the sequence to search for.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given sequence is {@code null}.
@@ -449,8 +439,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * assertThat(&quot;Frodo&quot;).startsWith(&quot;fro&quot;);
    * assertThat(&quot;Gandalf the grey&quot;).startsWith(&quot;grey&quot;);</code></pre>
    * 
-   * </p>
-   * 
    * @param prefix the given prefix.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given prefix is {@code null}.
@@ -495,8 +483,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).endsWith(&quot;Fro&quot;);</code></pre>
    * 
-   * </p>
-   * 
    * @param suffix the given suffix.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given suffix is {@code null}.
@@ -540,8 +526,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).matches(&quot;.*d&quot;);</code></pre>
    * 
-   * </p>
-   * 
    * @param regex the regular expression to which the actual {@code CharSequence} is to be matched.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given pattern is {@code null}.
@@ -564,8 +548,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).doesNotMatch(&quot;..o.o&quot;);</code></pre>
    *
-   * </p>
-   *
    * @param regex the regular expression to which the actual {@code CharSequence} is to be matched.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given pattern is {@code null}.
@@ -588,8 +570,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).matches(Pattern.compile(&quot;.*d&quot;));</code></pre>
    *
-   * </p>
-   *
    * @param pattern the regular expression to which the actual {@code CharSequence} is to be matched.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given pattern is {@code null}.
@@ -611,8 +591,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).doesNotMatch(Pattern.compile(&quot;..o.o&quot;));</code></pre>
    *
-   * </p>
-   *
    * @param pattern the regular expression to which the actual {@code CharSequence} is to be matched.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given pattern is {@code null}.
@@ -787,8 +765,6 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot; my\tfoo bar &quot;).isEqualToIgnoringWhitespace(&quot; my foobar&quot;);</code></pre>
    *
-   * </p>
-   *
    * @param expected the given {@code CharSequence} to compare the actual {@code CharSequence} to.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual {@code CharSequence} is not equal ignoring whitespace differences to the given
@@ -798,4 +774,24 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
     strings.assertEqualsIgnoringWhitespace(info, actual, expected);
     return myself;
   }
+
+  /**
+   * Verifies that the actual {@code CharSequence} is a substring of the given one (opposite assertion of {@link #contains(CharSequence...) contains(CharSequence cs)}.
+   * <p>
+   * Example :
+   * <pre><code class='java'> // assertions will pass
+   * assertThat(&quot;Lego&quot;).isSubstringOf(&quot;Legolas&quot;);
+   * assertThat(&quot;Legolas&quot;).isSubstringOf(&quot;Legolas&quot;);
+   * 
+   * // assertion will fail
+   * assertThat(&quot;Frodo&quot;).isSubstringOf(&quot;Frod&quot;);</code></pre>
+   * 
+   * @param sequence the sequence that is expected to contain actual.
+   * @return {@code this} assertion object.
+   * @throws AssertionError if the actual {@code CharSequence} is not a substring of the given parameter.
+   */
+  public S isSubstringOf(CharSequence sequence) {
+    strings.assertIsSubstringOf(info, actual, sequence);
+    return myself;
+  }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeSubstring.java b/src/main/java/org/assertj/core/error/ShouldBeSubstring.java
new file mode 100644
index 000000000..9a8c8bd50
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeSubstring.java
@@ -0,0 +1,34 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.internal.ComparisonStrategy;
+
+public class ShouldBeSubstring extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link org.assertj.core.error.ShouldBeSubstring}</code>.
+   * @param actual the actual value in the failed assertion.
+   * @param expected the expected value in the failed assertion.
+   * @param comparisonStrategy 
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeSubstring(CharSequence actual, CharSequence expected,
+                                                      ComparisonStrategy comparisonStrategy) {
+    return new ShouldBeSubstring(actual, expected, comparisonStrategy);
+  }
+
+  private ShouldBeSubstring(CharSequence actual, CharSequence expected, ComparisonStrategy comparisonStrategy) {
+    super("%nExpecting:%n  <%s>%nto be a substring of:%n  <%s>%n%s", actual, expected, comparisonStrategy);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Strings.java b/src/main/java/org/assertj/core/internal/Strings.java
index 10ea357cf..fd01ad537 100644
--- a/src/main/java/org/assertj/core/internal/Strings.java
+++ b/src/main/java/org/assertj/core/internal/Strings.java
@@ -20,6 +20,7 @@ import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
 import static org.assertj.core.error.ShouldBeEqualIgnoringCase.shouldBeEqual;
 import static org.assertj.core.error.ShouldBeEqualIgnoringWhitespace.shouldBeEqualIgnoringWhitespace;
 import static org.assertj.core.error.ShouldBeNullOrEmpty.shouldBeNullOrEmpty;
+import static org.assertj.core.error.ShouldBeSubstring.shouldBeSubstring;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContainIgnoringCase;
 import static org.assertj.core.error.ShouldContainCharSequenceOnlyOnce.shouldContainOnlyOnce;
@@ -42,6 +43,7 @@ import static org.assertj.core.internal.CommonValidations.checkOtherIsNotNull;
 import static org.assertj.core.internal.CommonValidations.checkSameSizes;
 import static org.assertj.core.internal.CommonValidations.checkSizes;
 import static org.assertj.core.internal.CommonValidations.hasSameSizeAsCheck;
+import static org.assertj.core.util.Preconditions.checkNotNull;
 import static org.assertj.core.util.xml.XmlStringPrettyFormatter.xmlPrettyFormat;
 
 import java.io.IOException;
@@ -618,4 +620,11 @@ public class Strings {
                                                  info.representation()));
   }
 
+  public void assertIsSubstringOf(AssertionInfo info, CharSequence actual, CharSequence sequence) {
+    assertNotNull(info, actual);
+    checkNotNull(sequence, "Expecting CharSequence not to be null");
+    if (stringContains(sequence.toString(), actual.toString())) return;
+    throw failures.failure(info, shouldBeSubstring(actual, sequence, comparisonStrategy));
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isSubstringOf_Test.java b/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isSubstringOf_Test.java
new file mode 100644
index 000000000..d97c688a1
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isSubstringOf_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.charsequence;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.CharSequenceAssert;
+import org.assertj.core.api.CharSequenceAssertBaseTest;
+
+public class CharSequenceAssert_isSubstringOf_Test extends CharSequenceAssertBaseTest {
+
+  @Override
+  protected CharSequenceAssert invoke_api_method() {
+    return assertions.isSubstringOf("foo");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(strings).assertIsSubstringOf(getInfo(assertions), getActual(assertions), "foo");
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeSubstringOf_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeSubstringOf_create_Test.java
new file mode 100644
index 000000000..bebde99e2
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeSubstringOf_create_Test.java
@@ -0,0 +1,52 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeSubstring.shouldBeSubstring;
+
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.StandardComparisonStrategy;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.assertj.core.util.CaseInsensitiveStringComparator;
+import org.junit.Test;
+
+public class ShouldBeSubstringOf_create_Test {
+
+  @Test
+  public void should_create_error_message() {
+    ErrorMessageFactory factory = shouldBeSubstring("bcd", "abcdef", StandardComparisonStrategy.instance());
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(format("[Test] %n" +
+                                         "Expecting:%n" +
+                                         "  <\"bcd\">%n" +
+                                         "to be a substring of:%n" +
+                                         "  <\"abcdef\">%n"));
+  }
+
+  @Test
+  public void should_create_error_message_with_comparison_strategy() {
+    ErrorMessageFactory factory = shouldBeSubstring("bcd", "abcdef",
+                                                    new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(format("[Test] %n" +
+                                         "Expecting:%n" +
+                                         "  <\"bcd\">%n" +
+                                         "to be a substring of:%n" +
+                                         "  <\"abcdef\">%n" +
+                                         "when comparing values using 'CaseInsensitiveStringComparator'"));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertIsSubstringOf_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertIsSubstringOf_Test.java
new file mode 100644
index 000000000..634fd253a
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertIsSubstringOf_Test.java
@@ -0,0 +1,99 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.strings;
+
+import static org.assertj.core.error.ShouldBeSubstring.shouldBeSubstring;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.StandardComparisonStrategy;
+import org.assertj.core.internal.StringsBaseTest;
+import org.junit.Test;
+
+public class Strings_assertIsSubstringOf_Test extends StringsBaseTest {
+
+  @Test
+  public void should_pass_if_actual_is_a_substring_of_given_string() {
+    strings.assertIsSubstringOf(someInfo(), "Yo", "Yoda");
+  }
+
+  @Test
+  public void should_pass_if_actual_is_equal_to_given_string() {
+    strings.assertIsSubstringOf(someInfo(), "Yoda", "Yoda");
+  }
+
+  @Test
+  public void should_pass_if_actual_is_empty() {
+    strings.assertIsSubstringOf(someInfo(), "", "Yoda");
+    strings.assertIsSubstringOf(someInfo(), "", "");
+  }
+
+  @Test
+  public void should_fail_if_actual_contains_given_string() {
+    AssertionInfo info = someInfo();
+    try {
+      strings.assertIsSubstringOf(info, "Yoda", "oda");
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeSubstring("Yoda", "oda", StandardComparisonStrategy.instance()));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_completely_different_from_given_string() {
+    AssertionInfo info = someInfo();
+    try {
+      strings.assertIsSubstringOf(info, "Yoda", "Luke");
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeSubstring("Yoda", "Luke", StandardComparisonStrategy.instance()));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_throw_error_if_sequence_is_null() {
+    thrown.expectNullPointerException("Expecting CharSequence not to be null");
+    strings.assertIsSubstringOf(someInfo(), "Yoda", null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    strings.assertIsSubstringOf(someInfo(), null, "Yoda");
+  }
+
+  @Test
+  public void should_pass_if_actual_is_a_part_of_sequence_only_according_to_custom_comparison_strategy() {
+    stringsWithCaseInsensitiveComparisonStrategy.assertIsSubstringOf(someInfo(), "Yo", "Yoda");
+    stringsWithCaseInsensitiveComparisonStrategy.assertIsSubstringOf(someInfo(), "yo", "Yoda");
+    stringsWithCaseInsensitiveComparisonStrategy.assertIsSubstringOf(someInfo(), "YO", "Yoda");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_a_substring_of_sequence_according_to_custom_comparison_strategy() {
+    AssertionInfo info = someInfo();
+    try {
+      stringsWithCaseInsensitiveComparisonStrategy.assertIsSubstringOf(info, "Yoda", "Luke");
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeSubstring("Yoda", "Luke", comparisonStrategy));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+}
