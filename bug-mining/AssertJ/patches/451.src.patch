diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqual.java b/src/main/java/org/assertj/core/error/ShouldBeEqual.java
index 549dbf81b..13ae8dfa7 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeEqual.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqual.java
@@ -12,6 +12,8 @@
  */
 package org.assertj.core.error;
 
+import static java.lang.String.format;
+import static java.lang.System.lineSeparator;
 import static java.util.Objects.deepEquals;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Objects.HASH_CODE_PRIME;
@@ -157,12 +159,41 @@ public class ShouldBeEqual implements AssertionErrorFactory {
       // only drawback is that it won't look nice in IDEs.
       return defaultDetailedErrorMessage(description, representation);
     }
+    String actualRepresentation = representation.toStringOf(actual);
+    String expectedRepresentation = representation.toStringOf(expected);
+    if (hasMultilineValue(actualRepresentation, expectedRepresentation)) {
+      return errorMessageForMultilineValues(description, representation, actualRepresentation, expectedRepresentation);
+    }
+
     return comparisonStrategy.isStandard()
         ? messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE, expected, actual)
         : messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR,
                                   expected, actual, comparisonStrategy);
   }
 
+  private String errorMessageForMultilineValues(Description description, Representation representation,
+                                                String actualRepresentation, String expectedRepresentation) {
+    String desc = DescriptionFormatter.instance().format(description);
+    return desc + messageForMultilineValues(actualRepresentation, expectedRepresentation, representation);
+  }
+
+  private boolean hasMultilineValue(String actualRepresentation, String expectedRepresentation) {
+    return (actualRepresentation != null && actualRepresentation.contains(lineSeparator())) ||
+           (expectedRepresentation != null && expectedRepresentation.contains(lineSeparator()));
+  }
+
+  private String messageForMultilineValues(String actualRepresentation, String expectedRepresentation,
+                                           Representation representation) {
+    return comparisonStrategy.isStandard()
+        ? format(EXPECTED_BUT_WAS_MESSAGE, indent(expectedRepresentation), indent(actualRepresentation))
+        : format(EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR, indent(expectedRepresentation), indent(actualRepresentation),
+                 comparisonStrategy.asText());
+  }
+
+  protected String indent(String valueRepresentation) {
+    return String.format("%n%s", valueRepresentation).replace(lineSeparator(), lineSeparator() + "  ");
+  }
+
   /**
    * Builds and returns an error message from description using {@link #detailedExpected()} and
    * {@link #detailedActual()} detailed representation.
@@ -174,10 +205,17 @@ public class ShouldBeEqual implements AssertionErrorFactory {
    *         <b>detailed</b> representation.
    */
   protected String defaultDetailedErrorMessage(Description description, Representation representation) {
-    if (comparisonStrategy instanceof ComparatorBasedComparisonStrategy)
-      return messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR,
-                                     detailedExpected(), detailedActual(), comparisonStrategy);
-    return messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE, detailedExpected(), detailedActual());
+    String actualRepresentation = detailedActual();
+    String expectedRepresentation = detailedExpected();
+    if (hasMultilineValue(actualRepresentation, expectedRepresentation)) {
+      return errorMessageForMultilineValues(description, representation, actualRepresentation, expectedRepresentation);
+    }
+
+    return comparisonStrategy instanceof ComparatorBasedComparisonStrategy
+        ? messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR, expectedRepresentation,
+                                  actualRepresentation, comparisonStrategy)
+        : messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE, expectedRepresentation,
+                                  actualRepresentation);
   }
 
   private AssertionError assertionFailedError(String message, Representation representation) {
diff --git a/src/main/java/org/assertj/core/error/ShouldNotBeIn.java b/src/main/java/org/assertj/core/error/ShouldNotBeIn.java
index ba8ed29e7..76273e14a 100644
--- a/src/main/java/org/assertj/core/error/ShouldNotBeIn.java
+++ b/src/main/java/org/assertj/core/error/ShouldNotBeIn.java
@@ -12,7 +12,8 @@
  */
 package org.assertj.core.error;
 
-import org.assertj.core.internal.*;
+import org.assertj.core.internal.ComparisonStrategy;
+import org.assertj.core.internal.StandardComparisonStrategy;
 
 /**
  * Creates an error message indicating that an assertion that verifies that a value is not in a group of values (e.g. an array or
diff --git a/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java b/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
index 1e6cc2235..29d9f08c8 100644
--- a/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
@@ -73,8 +73,6 @@ public abstract class AbstractComparisonStrategy implements ComparisonStrategy {
     return areEqual(actual, other) || isGreaterThan(actual, other);
   }
 
-  public abstract String asText();
-
   @Override
   public boolean isStandard() {
     return false;
diff --git a/src/main/java/org/assertj/core/internal/ComparisonStrategy.java b/src/main/java/org/assertj/core/internal/ComparisonStrategy.java
index 07fce8c0c..e14935a06 100644
--- a/src/main/java/org/assertj/core/internal/ComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/ComparisonStrategy.java
@@ -154,4 +154,16 @@ public interface ComparisonStrategy {
    */
   boolean isStandard();
 
+  /**
+   * Used in error messages when a custom comparison strategy was used to compare values.
+   * <p>
+   * For example {@link ComparatorBasedComparisonStrategy} returns: 
+   * <pre><code>"when comparing values using " + toString()</code></pre>
+   *   
+   * @return the comparison strategy description used in error messages.
+   */
+  default String asText() {
+    return "";
+  };
+
 }
diff --git a/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java b/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
index 2801a1e08..4a1455679 100644
--- a/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
@@ -60,11 +60,6 @@ public class StandardComparisonStrategy extends AbstractComparisonStrategy {
     });
   }
 
-  @Override
-  public String asText() {
-    return "";
-  }
-
   /**
    * Returns {@code true} if the arguments are deeply equal to each other, {@code false} otherwise.
    * <p>
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java
index 785f1df24..580c806df 100644
--- a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java
@@ -15,9 +15,10 @@ package org.assertj.core.api.zoneddatetime;
 import static java.lang.String.format;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
 import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 
 import java.time.ZonedDateTime;
 
@@ -41,11 +42,17 @@ class ZonedDateTimeAssert_isNotIn_errors_Test extends ZonedDateTimeAssertBaseTes
 
   @Test
   void test_isNotIn_assertion_error_message() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0,
-                                                                                                 UTC)).isNotIn(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC).toString(), ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC).toString()))
-                                                   .withMessage(format("%nExpecting actual:%n  2000-01-05T03:00:05Z (java.time.ZonedDateTime)%nnot to be in:%n"
-                                                                       +
-                                                                       "  [2000-01-05T03:00:05Z (java.time.ZonedDateTime),%n    2012-01-01T03:03:03Z (java.time.ZonedDateTime)]%n"));
+    // GIVEN
+    ZonedDateTime actual = ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC);
+    ZonedDateTime other = ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isNotIn(actual.toString(), other.toString()));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting actual:%n" +
+                                           "  2000-01-05T03:00:05Z (java.time.ZonedDateTime)%n" +
+                                           "not to be in:%n" +
+                                           "  [2000-01-05T03:00:05Z (java.time.ZonedDateTime),%n" +
+                                           "    2012-01-01T03:03:03Z (java.time.ZonedDateTime)]%n"));
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/error/ShouldBeEqual_Test.java b/src/test/java/org/assertj/core/error/ShouldBeEqual_Test.java
index bcf252d3e..9fe52ccdc 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeEqual_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeEqual_Test.java
@@ -16,9 +16,16 @@ import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.catchThrowableOfType;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.test.AlwaysDifferentComparator.ALWAY_DIFFERENT;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.Objects;
 
 import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.util.CaseInsensitiveStringComparator;
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
 import org.opentest4j.AssertionFailedError;
 
@@ -59,4 +66,211 @@ class ShouldBeEqual_Test {
                                   " but was: [1, 2, 3]"));
   }
 
+  @Test
+  void should_display_multiline_values_nicely() {
+    // GIVEN
+    Xml actual = new Xml("1");
+    Xml expected = new Xml("2");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(actual).isEqualTo(expected));
+    // THEN
+    then(error).hasMessage(format("%nexpected: %n" +
+                                  "  <xml>%n" +
+                                  "    <value>2</value>%n" +
+                                  "  </xml>%n" +
+                                  " but was: %n" +
+                                  "  <xml>%n" +
+                                  "    <value>1</value>%n" +
+                                  "  </xml>"));
+  }
+
+  @Test
+  void should_display_all_values_as_multiline_if_one_is() {
+    // GIVEN
+    String actual = "foo";
+    Xml expected = new Xml("2");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(actual).isEqualTo(expected));
+    // THEN
+    then(error).hasMessage(format("%nexpected: %n" +
+                                  "  <xml>%n" +
+                                  "    <value>2</value>%n" +
+                                  "  </xml>%n" +
+                                  " but was: %n" +
+                                  "  \"foo\""));
+  }
+
+  @Test
+  void should_display_multiline_values_nicely_with_null() {
+    // GIVEN
+    Xml actual = null;
+    Xml expected = new Xml("2");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(actual).isEqualTo(expected));
+    // THEN
+    then(error).hasMessage(format("%nexpected: %n" +
+                                  "  <xml>%n" +
+                                  "    <value>2</value>%n" +
+                                  "  </xml>%n" +
+                                  " but was: %n" +
+                                  "  null"));
+  }
+
+  @Test
+  void should_display_multiline_values_nicely_for_ambiguous_representation() {
+    // GIVEN
+    Xml actual = new Xml("1");
+    XmlDuplicate expected = new XmlDuplicate("1");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(actual).isEqualTo(expected));
+    // THEN
+    then(error).hasMessageContainingAll(format("%nexpected: %n" +
+                                               "  <xml>%n" +
+                                               "    <value>1</value>%n" +
+                                               "  </xml> (XmlDuplicate@"),
+                                        format("%n but was: %n" +
+                                               "  <xml>%n" +
+                                               "    <value>1</value>%n" +
+                                               "  </xml> (Xml@"));
+  }
+
+  @Test
+  void should_display_multiline_values_nicely_with_comparison_strategy() {
+    // GIVEN
+    Xml actual = new Xml("1");
+    Xml expected = new Xml("2");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(actual).usingComparator(ALWAY_DIFFERENT).isEqualTo(expected));
+    // THEN
+    then(error).hasMessage(format("%nexpected: %n" +
+                                  "  <xml>%n" +
+                                  "    <value>2</value>%n" +
+                                  "  </xml>%n" +
+                                  " but was: %n" +
+                                  "  <xml>%n" +
+                                  "    <value>1</value>%n" +
+                                  "  </xml>%n" +
+                                  "when comparing values using AlwaysDifferentComparator"));
+  }
+
+  @Test
+  void should_display_multiline_values_nicely_for_ambiguous_representation_for_ambiguous_representation() {
+    // GIVEN
+    Xml actual = new Xml("1");
+    XmlDuplicate expected = new XmlDuplicate("1");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(actual).usingComparator(ALWAY_DIFFERENT).isEqualTo(expected));
+    // THEN
+    then(error).hasMessageContainingAll(format("%nexpected: %n" +
+                                               "  <xml>%n" +
+                                               "    <value>1</value>%n" +
+                                               "  </xml> (XmlDuplicate@"),
+                                        format("%n but was: %n" +
+                                               "  <xml>%n" +
+                                               "    <value>1</value>%n" +
+                                               "  </xml> (Xml@"),
+                                        "when comparing values using AlwaysDifferentComparator");
+  }
+
+  @Disabled("future improvement")
+  @Test
+  void should_format_iterable_with_one_element_per_line_when_single_line_description_is_too_long() {
+    // GIVEN
+    String aaa = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
+    String bbb = "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(list(bbb, aaa)).isEqualTo(list(aaa, bbb)));
+    // THEN
+    then(error).hasMessage(format("%nexpected: %n"
+                                  + "  [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",%n"
+                                  + "   \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"]%n"
+                                  + " but was: %n"
+                                  + "  [\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",%n"
+                                  + "   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"]"));
+  }
+
+  @Disabled("future improvement")
+  @Test
+  void should_format_array_with_one_element_per_line_when_single_line_description_is_too_long() {
+    // GIVEN
+    String aaa = "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa";
+    String bbb = "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb";
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(array(bbb, aaa)).isEqualTo(array(aaa, bbb)));
+    // THEN
+    then(error).hasMessage(format("%nexpected: %n"
+                                  + "  [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",%n"
+                                  + "   \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\"]%n"
+                                  + " but was: %n"
+                                  + "  [\"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",%n"
+                                  + "   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"]"));
+  }
+
+  @Disabled("future improvement")
+  @Test
+  void should_display_iterable_with_multiline_element_values_nicely() {
+    // GIVEN
+    Xml xml1 = new Xml("1");
+    Xml xml2 = new Xml("2");
+    // WHEN
+    AssertionError error = expectAssertionError(() -> then(list(xml2, xml1)).isEqualTo(list(xml1, xml2)));
+    // THEN
+    then(error).hasMessage(format("%nexpected: %n" +
+                                  "  [<xml>%n" +
+                                  "     <value>1</value>%n" +
+                                  "   </xml>, %n" +
+                                  "   <xml>%n" +
+                                  "     <value>2</value>%n" +
+                                  "   </xml>]%n" +
+                                  " but was: [%n" +
+                                  "  [<xml>%n" +
+                                  "     <value>2</value>%n" +
+                                  "   </xml>, %n" +
+                                  "   <xml>%n" +
+                                  "     <value>1</value>%n" +
+                                  "   </xml>]"));
+  }
+
+  static class Xml {
+    private final String value;
+
+    public Xml(String value) {
+      this.value = value;
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      Xml xml = (Xml) o;
+      return Objects.equals(value, xml.value);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(value);
+    }
+
+    @Override
+    public String toString() {
+      return format("<xml>%n" +
+                    "  <value>" + value + "</value>%n" +
+                    "</xml>");
+    }
+  }
+
+  // same representation for Xml2 as Xml
+  static class XmlDuplicate extends Xml {
+    public XmlDuplicate(String value) {
+      super(value);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      // to test case where same toString but unequal values
+      return false;
+    }
+
+  }
+
 }
