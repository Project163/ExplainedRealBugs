diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 772d26b1f..e0f299557 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -1046,12 +1046,12 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
 
   /**
    * Allows to register a {@link BiPredicate} to compare fields with the given locations.
-   * A typical usage is for comparing double/float fields with a given precision.
+   * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * BiPredicates specified with this method have precedence over the ones registered with {@link #withEqualsForType(BiPredicate, Class)}
    * or the comparators registered with {@link #withComparatorForType(Comparator, Class)}.
    * <p>
-   * Note that registering a {@link BiPredicate} for a given field will override the previously registered Comparator (if any).
+   * Note that registering a {@link BiPredicate} for a given field will override the previously registered one (if any).
    * <p>
    * The field locations must be specified from the root object,
    * for example if {@code Foo} has a {@code Bar} field which has an {@code id}, one can register to a comparator for Bar's {@code id} by calling:
@@ -1091,9 +1091,60 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Allows to register a {@link BiPredicate} to compare fields whose location matches the given regexes.
+   * A typical usage is to compare double/float fields with a given precision.
+   * <p>
+   * The fields are evaluated from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
+   * one can register a BiPredicate for Foo and Bar's {@code id} by calling:
+   * <pre><code class='java'> withEqualsForFieldsMatchingRegexes(idBiPredicate, ".*id")</code></pre>
+   * or
+   * <pre><code class='java'> withEqualsForFieldsMatchingRegexes(idBiPredicate, "foo.*id")</code></pre>
+   * <p>
+   * BiPredicates registered with this method have precedence over the ones registered with {@link #withEqualsForType(BiPredicate, Class)}
+   * or the comparators registered with {@link #withComparatorForType(Comparator, Class)} but don't have precedence over the
+   * ones registered with exact location match: {@link #withEqualsForFields(BiPredicate, String...)} or {@link #withComparatorForFields(Comparator, String...)}
+   * <p>
+   * If registered regexes for different {@link BiPredicate} match a given field, the latest registered regexes {@link BiPredicate} wins.
+   * <p>
+   * Example:
+   * <pre><code class='java'> public class TolkienCharacter {
+   *   String name;
+   *   double height;
+   *   double weight;
+   * }
+   *
+   * TolkienCharacter frodo = new TolkienCharacter(&quot;Frodo&quot;, 1.2, 40);
+   * TolkienCharacter tallerFrodo = new TolkienCharacter(&quot;Frodo&quot;, 1.3, 40.5);
+   * TolkienCharacter reallyTallFrodo = new TolkienCharacter(&quot;Frodo&quot;, 1.9, 45);
+   *
+   * BiPredicate&lt;Double, Double&gt; closeEnough = (d1, d2) -&gt; Math.abs(d1 - d2) &lt;= 0.5;
+   *
+   * // assertion succeeds
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .withEqualsForFieldsMatchingRegexes(closeEnough, &quot;.eight&quot;)
+   *                  .isEqualTo(tallerFrodo);
+   *
+   * // assertion fails
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .withEqualsForFieldsMatchingRegexes(closeEnough, &quot;.eight&quot;)
+   *                  .isEqualTo(reallyTallFrodo);</code></pre>
+   *
+   * @param equals the {@link BiPredicate} to use to compare the fields matching the given regexes
+   * @param regexes the regexes from the root object of the fields location the BiPredicate should be used for
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   * @throws NullPointerException if the given BiPredicate is null.
+   * @since 3.24.0
+   */
+  public SELF withEqualsForFieldsMatchingRegexes(BiPredicate<?, ?> equals, String... regexes) {
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(equals, regexes);
+    return myself;
+  }
+
   /**
    * Allows to register a comparator to compare fields with the given locations.
-   * A typical usage is for comparing double/float fields with a given precision.
+   * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * Comparators registered with this method have precedence over comparators registered with {@link #withComparatorForType(Comparator, Class)}
    * or {@link BiPredicate} registered with {@link #withEqualsForType(BiPredicate, Class)}.
@@ -1139,7 +1190,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
 
   /**
    * Allows to register a comparator to compare the fields with the given type.
-   * A typical usage is for comparing double/float fields with a given precision.
+   * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * Comparators registered with this method have less precedence than comparators registered with {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)}
    * or BiPredicate registered with {@link #withEqualsForFields(BiPredicate, String...) withEqualsForFields(BiPredicate, String...)}.
@@ -1183,7 +1234,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
 
   /**
    * Allows to register a {@link BiPredicate} to compare the fields with the given type.
-   * A typical usage is for comparing double/float fields with a given precision.
+   * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * BiPredicates registered with this method have less precedence than the one registered  with {@link #withEqualsForFields(BiPredicate, String...) withEqualsForFields(BiPredicate, String...)}
    * or comparators registered with {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)}.
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldComparators.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldComparators.java
index a5329df89..0d687a0c5 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldComparators.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldComparators.java
@@ -12,8 +12,15 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.data.MapEntry.entry;
+
+import java.util.Collections;
 import java.util.Comparator;
+import java.util.LinkedList;
+import java.util.List;
 import java.util.Map.Entry;
+import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
 /**
@@ -23,16 +30,29 @@ import java.util.stream.Stream;
  */
 public class FieldComparators extends FieldHolder<Comparator<?>> {
 
+  protected final LinkedList<ComparatorForPatterns> comparatorByPatterns = new LinkedList<>();
+
   /**
-   * Puts the {@code comparator} for the given {@code fieldLocation}.
+   * Registers the {@code comparator} for the given {@code fieldLocation}.
    *
-   * @param fieldLocation the FieldLocation where to apply the comparator
+   * @param fieldLocation the location where to apply the comparator
    * @param comparator the comparator itself
    */
   public void registerComparator(String fieldLocation, Comparator<?> comparator) {
     super.put(fieldLocation, comparator);
   }
 
+  /**
+   * Registers the {@code comparator} for the given regexes field location.
+   *
+   * @param regexes the regexes field location where to apply the comparator
+   * @param comparator the comparator to use for the regexes
+   */
+  public void registerComparatorForFieldsMatchingRegexes(String[] regexes, Comparator<?> comparator) {
+    List<Pattern> patterns = Stream.of(regexes).map(Pattern::compile).collect(toList());
+    comparatorByPatterns.addFirst(new ComparatorForPatterns(patterns, comparator));
+  }
+
   /**
    * Checks, whether an any comparator is associated with the giving field location.
    *
@@ -41,7 +61,12 @@ public class FieldComparators extends FieldHolder<Comparator<?>> {
    */
   public boolean hasComparatorForField(String fieldLocation) {
     // TODO sanitize here?
-    return super.hasEntity(fieldLocation);
+    boolean hasComparatorForExactFieldLocation = super.hasEntity(fieldLocation);
+    // comparator for exact location takes precedence over the one with location matched by regexes
+    if (hasComparatorForExactFieldLocation) return true;
+    // no comparator for exact location, check if there is a regex that matches the field location
+    return comparatorByPatterns.stream()
+                               .anyMatch(comparatorForPatterns -> comparatorForPatterns.hasComparatorForField(fieldLocation));
   }
 
   /**
@@ -52,7 +77,14 @@ public class FieldComparators extends FieldHolder<Comparator<?>> {
    * @return a custom comparator or null
    */
   public Comparator<?> getComparatorForField(String fieldLocation) {
-    return super.get(fieldLocation);
+    Comparator<?> exactFieldLocationComparator = super.get(fieldLocation);
+    if (exactFieldLocationComparator != null) return exactFieldLocationComparator;
+    // no comparator for exact location, check if there is a regex that matches the field location
+    return comparatorByPatterns.stream()
+                               .map(comparatorForPatterns -> comparatorForPatterns.getComparatorForField(fieldLocation))
+                               .filter(comparator -> comparator != null)
+                               .findFirst()
+                               .orElse(null);
   }
 
   /**
@@ -63,4 +95,48 @@ public class FieldComparators extends FieldHolder<Comparator<?>> {
   public Stream<Entry<String, Comparator<?>>> comparatorByFields() {
     return super.entryByField();
   }
+
+  public Stream<Entry<List<Pattern>, Comparator<?>>> comparatorByRegexFields() {
+    return comparatorByPatterns.stream().map(comparatorForPatterns -> entry(comparatorForPatterns.fieldPatterns,
+                                                                            comparatorForPatterns.comparator));
+  }
+
+  @Override
+  public boolean isEmpty() {
+    return super.isEmpty() && comparatorByPatterns.isEmpty();
+  }
+
+  public boolean hasFieldComparators() {
+    return !super.isEmpty();
+  }
+
+  public boolean hasRegexFieldComparators() {
+    return !comparatorByPatterns.isEmpty();
+  }
+}
+
+/**
+ * Data structure holding the list of field patterns that will lead to use the given comparator.
+ */
+class ComparatorForPatterns {
+  final List<Pattern> fieldPatterns;
+  final Comparator<?> comparator;
+
+  ComparatorForPatterns(List<Pattern> fieldPatterns, Comparator<?> comparator) {
+    this.fieldPatterns = Collections.unmodifiableList(fieldPatterns);
+    this.comparator = comparator;
+  }
+
+  boolean hasComparatorForField(String fieldLocation) {
+    return fieldPatterns.stream().anyMatch(pattern -> pattern.matcher(fieldLocation).matches());
+  }
+
+  Comparator<?> getComparatorForField(String fieldLocation) {
+    return hasComparatorForField(fieldLocation) ? comparator : null;
+  }
+
+  @Override
+  public String toString() {
+    return String.format("ComparatorForPatterns[patterns=%s, comparator=%s]", this.fieldPatterns, this.comparator);
+  }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 29a3bf1ee..3398ce3f9 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -425,6 +425,34 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     registerComparatorForFields(toComparator(equals), fieldLocations);
   }
 
+  /**
+   * Allows to register a {@link BiPredicate} to compare fields whose location matches the given regexes.
+   * A typical usage is to compare double/float fields with a given precision.
+   * <p>
+   * The fields are evaluated from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
+   * one can register a BiPredicate for Foo and Bar's {@code id} by calling:
+   * <pre><code class='java'> registerEqualsForFieldsMatchingRegexes(idBiPredicate, ".*id")</code></pre>
+   * or
+   * <pre><code class='java'> registerEqualsForFieldsMatchingRegexes(idBiPredicate, "foo.*id")</code></pre>
+   * <p>
+   * BiPredicates registered with this method have precedence over the ones registered with {@link #registerEqualsForType(BiPredicate, Class)}
+   * or the comparators registered with {@link #registerComparatorForType(Comparator, Class)} but don't have precedence over the
+   * ones registered with exact location match: {@link #registerEqualsForFields(BiPredicate, String...)} or {@link #registerComparatorForFields(Comparator, String...)}
+   * <p>
+   * If registered regexes for different {@link BiPredicate} match a given field, the latest registered regexes {@link BiPredicate} wins.
+   * <p>
+   * Example: see {@link RecursiveComparisonAssert#withEqualsForFieldsMatchingRegexes(BiPredicate, String...)}
+   *
+   * @param equals the {@link BiPredicate} to use to compare the fields matching the given regexes
+   * @param regexes the regexes from the root object of the fields location the BiPredicate should be used for
+   *
+   * @throws NullPointerException if the given BiPredicate is null.
+   * @since 3.24.0
+   */
+  public void registerEqualsForFieldsMatchingRegexes(BiPredicate<?, ?> equals, String... regexes) {
+    fieldComparators.registerComparatorForFieldsMatchingRegexes(regexes, toComparator(equals));
+  }
+
   /**
    * Registers the giving message which would be shown when differences in the given fields while comparison occurred.
    * <p>
@@ -807,8 +835,17 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private void describeRegisteredComparatorForFields(StringBuilder description) {
     if (!fieldComparators.isEmpty()) {
-      description.append(format("- these fields were compared with the following comparators:%n"));
-      describeComparatorForFields(description);
+      if (fieldComparators.hasFieldComparators()) {
+        description.append(format("- these fields were compared with the following comparators:%n"));
+        describeComparatorForFields(description);
+      }
+      if (fieldComparators.hasRegexFieldComparators()) {
+        description.append(format("- the fields matching these regexes were compared with the following comparators:%n"));
+        describeComparatorForRegexFields(description);
+      }
+      if (fieldComparators.hasFieldComparators() && fieldComparators.hasRegexFieldComparators()) {
+        description.append(format("- field comparators take precedence over regex field matching comparators.%n"));
+      }
       if (!typeComparators.isEmpty()) {
         description.append(format("- field comparators take precedence over type comparators.%n"));
       }
@@ -821,10 +858,21 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
                     .forEach(description::append);
   }
 
+  private void describeComparatorForRegexFields(StringBuilder description) {
+    fieldComparators.comparatorByRegexFields()
+                    .map(this::formatRegisteredComparatorForRegexFields)
+                    .sorted()
+                    .forEach(description::append);
+  }
+
   private String formatRegisteredComparatorForField(Entry<String, Comparator<?>> comparatorForField) {
     return format("%s %s -> %s%n", INDENT_LEVEL_2, comparatorForField.getKey(), comparatorForField.getValue());
   }
 
+  private String formatRegisteredComparatorForRegexFields(Entry<List<Pattern>, Comparator<?>> comparatorForRegexFields) {
+    return format("%s %s -> %s%n", INDENT_LEVEL_2, comparatorForRegexFields.getKey(), comparatorForRegexFields.getValue());
+  }
+
   private void describeTypeCheckingStrictness(StringBuilder description) {
     String str = strictTypeChecking
       ? "- actual and expected objects and their fields were considered different when of incompatible types (i.e. expected type does not extend actual's type) even if all their fields match, for example a Person instance will never match a PersonDto (call strictTypeChecking(false) to change that behavior).%n"
@@ -871,6 +919,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return new Builder();
   }
 
+
   /**
    * Builder to build {@link RecursiveComparisonConfiguration}.
    */
@@ -1148,6 +1197,35 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
       return withComparatorForFields(toComparator(equals), fields);
     }
 
+    /**
+     * Allows to register a {@link BiPredicate} to compare fields whose location matches the given regexes.
+     * A typical usage is to compare double/float fields with a given precision.
+     * <p>
+     * The fields are evaluated from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
+     * one can register a BiPredicate for Foo and Bar's {@code id} by calling:
+     * <pre><code class='java'> withEqualsForFields(idBiPredicate, ".*id")</code></pre>
+     * or
+     * <pre><code class='java'> withEqualsForFields(idBiPredicate, "foo.*id")</code></pre>
+     * <p>
+     * BiPredicates registered with this method have precedence over the ones registered with {@link #registerEqualsForType(BiPredicate, Class)}
+     * or the comparators registered with {@link #registerComparatorForType(Comparator, Class)} but don't have precedence over the
+     * ones registered with exact location match: {@link #registerEqualsForFields(BiPredicate, String...)} or {@link #registerComparatorForFields(Comparator, String...)}
+     * <p>
+     * If registered regexes for different {@link BiPredicate} match a given field, the latest registered regexes {@link BiPredicate} wins.
+     * <p>
+     * See {@link RecursiveComparisonAssert#withEqualsForFieldsMatchingRegexes(BiPredicate, String...)}  RecursiveComparisonAssert#withEqualsForFieldsMatchingRegexes(BiPredicate equals, String...fields)} for examples.
+     *
+     * @param equals the {@link BiPredicate} to use to compare the fields matching the given regexes
+     * @param regexes the regexes to match fields against
+     * @return this builder.
+     * @since 3.24.0
+     * @throws NullPointerException if the given BiPredicate is null.
+     */
+    public Builder withEqualsForFieldsMatchingRegexes(BiPredicate<?, ?> equals, String... regexes) {
+      fieldComparators.registerComparatorForFieldsMatchingRegexes(regexes, toComparator(equals));
+      return this;
+    }
+
     /**
      * Registers the giving message which would be shown when differences in the given fields while comparison occurred.
      * <p>
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 6bd28932b..46a8c215b 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -750,20 +750,28 @@ public class RecursiveComparisonDifferenceCalculator {
     final Object expectedFieldValue = dualValue.expected;
     // check field comparators as they take precedence over type comparators
     Comparator fieldComparator = recursiveComparisonConfiguration.getComparatorForField(fieldName);
-    if (fieldComparator != null) return areEqualUsingComparator(actualFieldValue, expectedFieldValue, fieldComparator);
+    if (fieldComparator != null) return areEqualUsingComparator(actualFieldValue, expectedFieldValue, fieldComparator, fieldName);
     // check if a type comparators exist for the field type
     Class fieldType = actualFieldValue != null ? actualFieldValue.getClass() : expectedFieldValue.getClass();
     Comparator typeComparator = recursiveComparisonConfiguration.getComparatorForType(fieldType);
-    if (typeComparator != null) return areEqualUsingComparator(actualFieldValue, expectedFieldValue, typeComparator);
+    if (typeComparator != null) return areEqualUsingComparator(actualFieldValue, expectedFieldValue, typeComparator, fieldName);
     // default comparison using equals
     return deepEquals(actualFieldValue, expectedFieldValue);
   }
 
-  private static boolean areEqualUsingComparator(final Object actual, final Object expected, Comparator<Object> comparator) {
+  private static boolean areEqualUsingComparator(final Object actual, final Object expected, Comparator<Object> comparator,
+                                                 String fieldName) {
     try {
       return comparator.compare(actual, expected) == 0;
     } catch (ClassCastException e) {
       // this occurs when comparing field of different types, Person.id is an int and PersonDto.id is a long
+      // TODO maybe we should let the exception bubble up?
+      // assertion will fail with the current behavior and report other diff so it might be better to keep things this way
+      System.out.println(format("WARNING: Comparator was not suited to compare '%s' field values:%n" +
+                                "- actual field value  : %s%n" +
+                                "- expected field value: %s%n" +
+                                "- comparator used     : %s",
+                                fieldName, actual, expected, comparator));
       return false;
     }
   }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/FieldComparators_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/FieldComparators_Test.java
new file mode 100644
index 000000000..56d3fc23b
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/FieldComparators_Test.java
@@ -0,0 +1,141 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.test.AlwaysDifferentComparator.ALWAY_DIFFERENT;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAYS_EQUALS;
+import static org.assertj.core.util.Arrays.array;
+
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.ValueSource;
+
+class FieldComparators_Test {
+
+  private FieldComparators fieldComparators;
+
+  @BeforeEach
+  void setup() {
+    fieldComparators = new FieldComparators();
+  }
+
+  @Test
+  void should_register_comparator_for_an_exact_field_location() {
+    // GIVEN
+    String fooLocation = "foo";
+    // WHEN
+    fieldComparators.registerComparator(fooLocation, ALWAYS_EQUALS);
+    // THEN
+    then(fieldComparators.hasComparatorForField(fooLocation)).isTrue();
+    then(fieldComparators.getComparatorForField(fooLocation)).isSameAs(ALWAYS_EQUALS);
+  }
+
+  @Test
+  void should_override_registered_comparator_for_an_exact_field_location() {
+    // GIVEN
+    String fooLocation = "foo";
+    fieldComparators.registerComparator(fooLocation, ALWAYS_EQUALS);
+    then(fieldComparators.hasComparatorForField(fooLocation)).isTrue();
+    then(fieldComparators.getComparatorForField(fooLocation)).isSameAs(ALWAYS_EQUALS);
+    // WHEN
+    fieldComparators.registerComparator(fooLocation, ALWAY_DIFFERENT);
+    // THEN
+    then(fieldComparators.hasComparatorForField(fooLocation)).isTrue();
+    then(fieldComparators.getComparatorForField(fooLocation)).isNotSameAs(ALWAYS_EQUALS);
+    then(fieldComparators.getComparatorForField(fooLocation)).isSameAs(ALWAY_DIFFERENT);
+  }
+
+  @ParameterizedTest
+  @ValueSource(strings = {
+      "foo",
+      "com.foo",
+      "bar",
+      "bar.baz",
+      "com.bar.baz",
+  })
+  void should_register_comparator_for_regexes_field_location(String fieldLocation) {
+    // WHEN
+    fieldComparators.registerComparatorForFieldsMatchingRegexes(array(".*foo", ".*bar.*"), ALWAYS_EQUALS);
+    // THEN
+    then(fieldComparators.hasComparatorForField(fieldLocation)).isTrue();
+    then(fieldComparators.getComparatorForField(fieldLocation)).isSameAs(ALWAYS_EQUALS);
+  }
+
+  @Test
+  void should_use_latest_registered_comparator_when_several_regexes_match_field_location() {
+    // GIVEN
+    fieldComparators.registerComparatorForFieldsMatchingRegexes(array(".*foo", ".*bar.*"), ALWAYS_EQUALS);
+    then(fieldComparators.hasComparatorForField("com.foo")).isTrue();
+    then(fieldComparators.getComparatorForField("com.foo")).isSameAs(ALWAYS_EQUALS);
+    // WHEN
+    fieldComparators.registerComparatorForFieldsMatchingRegexes(array(".*foo.*", ".*baz.*"), ALWAY_DIFFERENT);
+    // THEN
+    then(fieldComparators.hasComparatorForField("com.foo")).isTrue();
+    then(fieldComparators.getComparatorForField("com.foo")).isNotSameAs(ALWAYS_EQUALS);
+    then(fieldComparators.getComparatorForField("com.foo")).isSameAs(ALWAY_DIFFERENT);
+  }
+
+  @Test
+  void should_prefer_exact_field_location_comparator_over_regex_one() {
+    // GIVEN
+    fieldComparators.registerComparator("foo", ALWAYS_EQUALS);
+    fieldComparators.registerComparatorForFieldsMatchingRegexes(array(".*foo.*", ".*baz.*"), ALWAY_DIFFERENT);
+    // THEN
+    then(fieldComparators.hasComparatorForField("foo")).isTrue();
+    then(fieldComparators.getComparatorForField("foo")).isSameAs(ALWAYS_EQUALS);
+    then(fieldComparators.getComparatorForField("com.foo")).isSameAs(ALWAY_DIFFERENT);
+  }
+
+  @Test
+  void hasComparatorForField_should_return_false_for_field_location_without_comparator() {
+    // GIVEN
+    String fooLocation = "foo";
+    // THEN
+    then(fieldComparators.hasComparatorForField(fooLocation)).isFalse();
+  }
+
+  @Test
+  void getComparatorForField_should_return_null_for_field_location_without_comparator() {
+    // GIVEN
+    String fooLocation = "foo";
+    // THEN
+    then(fieldComparators.getComparatorForField(fooLocation)).isNull();
+  }
+
+  @Test
+  void isEmpty_should_return_true_if_no_field_or_field_regexes_comparators_are_registered() {
+    assertThat(fieldComparators.isEmpty()).isTrue();
+  }
+
+  @Test
+  void isEmpty_should_return_false_if_a_field_comparators_is_registered() {
+    // GIVEN
+    fieldComparators.registerComparator("foo", ALWAYS_EQUALS);
+    // WHEN/THEN
+    then(fieldComparators.isEmpty()).isFalse();
+    then(fieldComparators.hasFieldComparators()).isTrue();
+  }
+
+  @Test
+  void isEmpty_should_return_false_if_a_regex_field_comparators_is_registered() {
+    // GIVEN
+    fieldComparators.registerComparatorForFieldsMatchingRegexes(array(".*foo.*"), ALWAYS_EQUALS);
+    // WHEN/THEN
+    then(fieldComparators.isEmpty()).isFalse();
+    then(fieldComparators.hasRegexFieldComparators()).isTrue();
+  }
+
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/FieldComparators_registerComparator_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/FieldComparators_registerComparator_Test.java
deleted file mode 100644
index 3d66fd4f3..000000000
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/FieldComparators_registerComparator_Test.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- * Copyright 2012-2022 the original author or authors.
- */
-package org.assertj.core.api.recursive.comparison;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.test.AlwaysEqualComparator.alwaysEqual;
-
-import org.assertj.core.test.AlwaysEqualComparator;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-class FieldComparators_registerComparator_Test {
-
-  private FieldComparators fieldComparators;
-
-  @BeforeEach
-  void setup() {
-    fieldComparators = new FieldComparators();
-  }
-
-  @Test
-  void should_register_comparator_for_a_given_fieldLocation() {
-    // GIVEN
-    String fooLocation = "foo";
-    // WHEN
-    AlwaysEqualComparator<?> alwaysEqualComparator = alwaysEqual();
-    fieldComparators.registerComparator(fooLocation, alwaysEqualComparator);
-    // THEN
-    assertThat(fieldComparators.hasComparatorForField(fooLocation)).isTrue();
-    assertThat(fieldComparators.getComparatorForField(fooLocation)).isSameAs(alwaysEqualComparator);
-  }
-
-  @Test
-  void hasComparatorForField_should_return_false_for_field_location_without_comparator() {
-    // GIVEN
-    String fooLocation = "foo";
-    // THEN
-    assertThat(fieldComparators.hasComparatorForField(fooLocation)).isFalse();
-  }
-
-  @Test
-  void getComparatorForField_should_return_null_for_field_location_without_comparator() {
-    // GIVEN
-    String fooLocation = "foo";
-    // THEN
-    assertThat(fieldComparators.getComparatorForField(fooLocation)).isNull();
-  }
-
-}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
index de65255d3..17160d407 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
@@ -15,11 +15,14 @@ package org.assertj.core.api.recursive.comparison;
 import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
 import static org.assertj.core.test.AlwaysDifferentComparator.alwaysDifferent;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAYS_EQUALS_TIMESTAMP;
 import static org.assertj.core.test.AlwaysEqualComparator.alwaysEqual;
+import static org.assertj.core.test.BiPredicates.DOUBLE_EQUALS;
+import static org.assertj.core.test.BiPredicates.STRING_EQUALS;
 
 import java.sql.Timestamp;
 import java.util.Comparator;
@@ -245,6 +248,23 @@ class RecursiveComparisonAssert_fluent_API_Test {
     assertThat(configuration.comparatorByFields()).anyMatch(entry -> entry.getKey().equals(field4) && entry.getValue() != null);
   }
 
+  @Test
+  void should_allow_to_register_comparators_by_regex_matching_fields() {
+    // WHEN
+    // @format:off
+    RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
+                                                                       .withEqualsForFieldsMatchingRegexes(STRING_EQUALS, ".*a", ".*b")
+                                                                       .withEqualsForFieldsMatchingRegexes(DOUBLE_EQUALS, ".*d", ".*e")
+                                                                       .getRecursiveComparisonConfiguration();
+    // @format:on
+    // THEN
+    FieldComparators fieldComparators = configuration.getFieldComparators();
+    then(fieldComparators.hasRegexFieldComparators()).isTrue();
+    then(fieldComparators.comparatorByRegexFields()).allMatch(entry -> entry.getValue() != null);
+    then(fieldComparators.comparatorByRegexFields()).anyMatch(entry -> entry.getKey().toString().equals("[.*a, .*b]"));
+    then(fieldComparators.comparatorByRegexFields()).anyMatch(entry -> entry.getKey().toString().equals("[.*d, .*e]"));
+  }
+
   @Test
   void should_allow_to_register_type_comparators() {
     // GIVEN
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withComparatorsForFieldMatchingRegexes_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withComparatorsForFieldMatchingRegexes_Test.java
new file mode 100644
index 000000000..822a94a24
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withComparatorsForFieldMatchingRegexes_Test.java
@@ -0,0 +1,274 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.test.BiPredicates.ALWAYS_DIFFERENT;
+import static org.assertj.core.test.BiPredicates.ALWAYS_EQUALS;
+import static org.assertj.core.test.BiPredicates.STRING_EQUALS;
+import static org.assertj.core.test.NeverEqualComparator.NEVER_EQUALS;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.sql.Timestamp;
+import java.util.Date;
+import java.util.Objects;
+import java.util.function.BiPredicate;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
+import org.assertj.core.internal.objects.data.Giant;
+import org.assertj.core.internal.objects.data.Home;
+import org.assertj.core.test.Patient;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class RecursiveComparisonAssert_isEqualTo_withComparatorsForFieldMatchingRegexes_Test
+    extends RecursiveComparisonAssert_isEqualTo_BaseTest {
+
+  @ParameterizedTest(name = "{4}: actual={0} / expected={1} - fieldRegexes {3}")
+  @MethodSource("recursivelyEqualObjectsWhenUsingFieldComparators")
+  void should_pass_with_registered_BiPredicates_by_fields_matching_regexes(Object actual, Object expected,
+                                                                           BiPredicate<Object, Object> equals,
+                                                                           String[] fieldRegexes, String testDescription) {
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForFieldsMatchingRegexes(equals, fieldRegexes)
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> recursivelyEqualObjectsWhenUsingFieldComparators() {
+    Person person1 = new Person("John", "Doe");
+    person1.home.address.number = 1;
+    Person person2 = new Person("JoHN", "DoE");
+    person2.home.address.number = 1;
+
+    Person person3 = new Person("John", "Doe");
+    person3.home.address.number = 1;
+    Person person4 = new Person("Jack", "Doe");
+    person4.home.address.number = 2;
+
+    Person person5 = new Person("John", "Doe");
+    person5.home.address.number = 1;
+    person5.dateOfBirth = new Date(123);
+    person5.neighbour = new Person("John", "Doe");
+    person5.neighbour.home.address.number = 123;
+    Person person6 = new Person("John", "Doe");
+    person6.home.address.number = 1;
+    person6.dateOfBirth = new Date(123);
+    person6.neighbour = new Person("Jim", "Doe");
+    person6.neighbour.home.address.number = 456;
+
+    Person person7 = new Person("John", "Doe");
+    person7.title = "Sir";
+    Person person8 = new Person("Jack", "Dough");
+    person8.title = "Mr";
+
+    return Stream.of(arguments(person1, person2, STRING_EQUALS, array("name.*name"), "same data except case for strings"),
+                     arguments(person3, person4, ALWAYS_EQUALS, array(".*first..me", "home.address.number"),
+                               "same data except for address number and first name"),
+                     // any neighbour differences should be ignored as we compare persons with ALWAYS_EQUALS
+                     arguments(person5, person6, ALWAYS_EQUALS, array("neigh.*"), "same data except for neighbour"),
+                     arguments(person7, person8, ALWAYS_EQUALS, array(".*stname", "t.tle"), "same data except for strings"));
+  }
+
+  @Test
+  void should_fail_when_actual_differs_from_expected_when_using_BiPredicates_by_fields_matching_regexes() {
+    // GIVEN
+    Person actual = new Person("John", "Doe");
+    actual.home.address.number = 1;
+    actual.dateOfBirth = new Date(123);
+    actual.neighbour = new Person("Jack", "Doe");
+    actual.neighbour.home.address.number = 123;
+    // actually a clone of actual
+    Person expected = new Person("John", "Doe");
+    expected.home.address.number = 1;
+    expected.dateOfBirth = new Date(123);
+    expected.neighbour = new Person("Jack", "Doe");
+    expected.neighbour.home.address.number = 123;
+    // register BiPredicates for some fields that will fail the comparison
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(ALWAYS_DIFFERENT, "dateOf.*", "neighbour.ho.*");
+
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+
+    // THEN
+    ComparisonDifference dateOfBirthDiff = diff("dateOfBirth", actual.dateOfBirth, expected.dateOfBirth);
+    ComparisonDifference neighbourAddressDiff = diff("neighbour.home", actual.neighbour.home, expected.neighbour.home);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, dateOfBirthDiff, neighbourAddressDiff);
+  }
+
+  @Test
+  void should_be_able_to_compare_objects_recursively_using_some_precision_for_numerical_fields() {
+    // GIVEN
+    Giant goliath = new Giant();
+    goliath.name = "Goliath";
+    goliath.height = 3.0;
+
+    Giant goliathTwin = new Giant();
+    goliathTwin.name = "Goliath";
+    goliathTwin.height = 3.1;
+
+    // THEN
+    then(goliath).usingRecursiveComparison()
+                 .withEqualsForFieldsMatchingRegexes((Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.2, "hei...")
+                 .isEqualTo(goliathTwin);
+  }
+
+  @Test
+  void should_be_able_to_compare_objects_recursively_using_given_BiPredicate_for_specified_nested_field() {
+    // GIVEN
+    Giant goliath = new Giant();
+    goliath.name = "Goliath";
+    goliath.height = 3.0;
+    goliath.home.address.number = 1;
+
+    Giant goliathTwin = new Giant();
+    goliathTwin.name = "Goliath";
+    goliathTwin.height = 3.1;
+    goliathTwin.home.address.number = 5;
+
+    // THEN
+    then(goliath).usingRecursiveComparison()
+                 .withEqualsForFieldsMatchingRegexes((Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.2, "height")
+                 .withEqualsForFieldsMatchingRegexes((Integer d1, Integer d2) -> d1 - d2 <= 10, "home.address.number")
+                 .isEqualTo(goliathTwin);
+  }
+
+  @Test
+  void should_handle_null_field_with_BiPredicates_by_fields_matching_regexes() {
+    // GIVEN
+    Patient actual = new Patient(null);
+    Patient expected = new Patient(new Timestamp(3L));
+    // THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForFieldsMatchingRegexes(ALWAYS_EQUALS, "dateOfBirth")
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void field_BiPredicate_should_take_precedence_over_type_comparator_whatever_their_order_of_registration() {
+    // GIVEN
+    Patient actual = new Patient(new Timestamp(1L));
+    Patient expected = new Patient(new Timestamp(3L));
+    // THEN
+    then(actual).usingRecursiveComparison()
+                .withComparatorForType(NEVER_EQUALS, Timestamp.class)
+                .withEqualsForFieldsMatchingRegexes(ALWAYS_EQUALS, "dateOfBirth")
+                .isEqualTo(expected);
+    then(actual).usingRecursiveComparison()
+                .withEqualsForFieldsMatchingRegexes(ALWAYS_EQUALS, "dateOfBirth")
+                .withComparatorForType(NEVER_EQUALS, Timestamp.class)
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void exact_field_location_comparators_should_take_precedence_over_regexes_BiPredicates_matching_field_location_whatever_their_order_of_registration() {
+    // GIVEN
+    Patient actual = new Patient(new Timestamp(1L));
+    Patient expected = new Patient(new Timestamp(3L));
+    // THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForFields(ALWAYS_EQUALS, "dateOfBirth")
+                .withEqualsForFieldsMatchingRegexes(ALWAYS_DIFFERENT, "dateOfB.*")
+                .isEqualTo(expected);
+    then(actual).usingRecursiveComparison()
+                .withEqualsForFieldsMatchingRegexes(ALWAYS_DIFFERENT, "dateOfBi.*")
+                .withEqualsForFields(ALWAYS_EQUALS, "dateOfBirth")
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void biPredicates_matching_field_location_take_precedence_over_overridden_equals() {
+    // GIVEN
+    Person actual = new Person("Fred", "Flint");
+    actual.neighbour = new AlwaysEqualPerson();
+    actual.neighbour.name = new Name("Omar", "Sy");
+    Person expected = new Person("Fred", "Flint");
+    expected.neighbour = new AlwaysEqualPerson();
+    expected.neighbour.name = new Name("Omar2", "Sy");
+    // THEN
+    then(actual).usingRecursiveComparison()
+                .withEqualsForFieldsMatchingRegexes(ALWAYS_EQUALS, "neighbour") // fails if commented
+                .usingOverriddenEquals()
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_use_custom_equal_over_reference_comparison() {
+    // GIVEN
+    Foo actual = new Foo(1);
+    Foo expected = new Foo(1);
+    BiPredicate<Integer, Integer> greaterThan = (i1, i2) -> Objects.equals(i1, i2 + 1);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison()
+                                                                                 .withEqualsForFieldsMatchingRegexes(greaterThan,
+                                                                                                                     "b..")
+                                                                                 .isEqualTo(expected));
+    // THEN
+    then(assertionError).hasMessageContainingAll("- the fields matching these regexes were compared with the following comparators",
+                                                 "  - [b..] -> ");
+  }
+
+  private static class Foo {
+
+    @SuppressWarnings("unused")
+    private final Integer bar;
+
+    private Foo(Integer bar) {
+      this.bar = bar;
+    }
+  }
+
+  static class Person {
+    Date dateOfBirth;
+    Name name;
+    String title;
+    double weight;
+    double height;
+    Home home = new Home();
+    Person neighbour;
+
+    public Person(String firstname, String lastname) {
+      this.name = new Name(firstname, lastname);
+    }
+
+    public Person() {}
+  }
+
+  static class Name {
+    final String firstname;
+    final String lastname;
+
+    public Name(String firstname, String lastname) {
+      this.firstname = firstname;
+      this.lastname = lastname;
+    }
+
+    @Override
+    public String toString() {
+      return String.format("Name[firstname=%s, lastname=%s]", this.firstname, this.lastname);
+    }
+  }
+
+  static class AlwaysEqualPerson extends Person {
+
+    @Override
+    public boolean equals(Object o) {
+      return true;
+    }
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
index ffed100a3..810951d60 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
@@ -15,6 +15,7 @@ package org.assertj.core.api.recursive.comparison;
 import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.test.AlwaysEqualComparator.alwaysEqual;
+import static org.assertj.core.test.BiPredicates.STRING_EQUALS;
 
 import java.util.Comparator;
 import java.util.function.BiPredicate;
@@ -252,14 +253,24 @@ class RecursiveComparisonConfiguration_builder_Test {
                    .hasMessage("Expecting a non null BiPredicate");
   }
 
+  @Test
+  void should_throw_NPE_if_given_BiPredicate_for_fields_matching_regexes_is_null() {
+    // GIVEN
+    BiPredicate<String, String> stringEquals = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> configBuilder().withEqualsForFieldsMatchingRegexes(stringEquals, ".*id"));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null BiPredicate");
+  }
+
   @Test
   void should_set_equalsForField() {
     // GIVEN
     String nameLocation = "name";
     String titleLocation = "title";
-    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
     // WHEN
-    RecursiveComparisonConfiguration configuration = configBuilder().withEqualsForFields(stringEquals, nameLocation,
+    RecursiveComparisonConfiguration configuration = configBuilder().withEqualsForFields(STRING_EQUALS, nameLocation,
                                                                                          titleLocation)
                                                                     .build();
     // THEN
@@ -267,6 +278,23 @@ class RecursiveComparisonConfiguration_builder_Test {
     then(configuration.hasComparatorForField(titleLocation)).isTrue();
   }
 
+  @Test
+  void should_set_equals_for_fields_matching_regexes() {
+    // GIVEN
+    String nameRegex = ".*name";
+    String titleRegex = ".*title";
+    // WHEN
+    RecursiveComparisonConfiguration configuration = configBuilder().withEqualsForFieldsMatchingRegexes(STRING_EQUALS, nameRegex,
+                                                                                                        titleRegex)
+                                                                    .build();
+    // THEN
+    then(configuration.hasComparatorForField("name")).isTrue();
+    then(configuration.hasComparatorForField("firstname")).isTrue();
+    then(configuration.hasComparatorForField("lastname")).isTrue();
+    then(configuration.hasComparatorForField("title")).isTrue();
+    then(configuration.hasComparatorForField("job.title")).isTrue();
+  }
+
   @Test
   void should_set_comparatorForType() {
     // GIVEN
@@ -281,11 +309,8 @@ class RecursiveComparisonConfiguration_builder_Test {
 
   @Test
   void should_set_equalsForType() {
-    // GIVEN
-    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
-
     // WHEN
-    RecursiveComparisonConfiguration configuration = configBuilder().withEqualsForType(stringEquals, String.class).build();
+    RecursiveComparisonConfiguration configuration = configBuilder().withEqualsForType(STRING_EQUALS, String.class).build();
     // THEN
     then(configuration.hasComparatorForType(String.class)).isTrue();
   }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
index ced8ff62f..a89101de2 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
@@ -12,10 +12,12 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assumptions.assumeThat;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAYS_EQUALS_TUPLE;
+import static org.assertj.core.test.BiPredicates.DOUBLE_EQUALS;
+import static org.assertj.core.test.BiPredicates.STRING_EQUALS;
 
 import java.util.Comparator;
 import java.util.function.BiPredicate;
@@ -37,35 +39,32 @@ class RecursiveComparisonConfiguration_fieldComparators_Test {
   void should_register_given_field_comparators() {
     // GIVEN
     AbsValueComparator<Integer> integerComparator = new AbsValueComparator<>();
-    BiPredicate<Double, Double> doubleEquals = (Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.01;
-    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("temperature")).isNull();
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("name")).isNull();
+    assumeThat(recursiveComparisonConfiguration.getComparatorForField("temperature")).isNull();
+    assumeThat(recursiveComparisonConfiguration.getComparatorForField("name")).isNull();
     // WHEN
     recursiveComparisonConfiguration.registerComparatorForFields(integerComparator, "height");
     recursiveComparisonConfiguration.registerComparatorForFields(ALWAYS_EQUALS_TUPLE, "weight");
-    recursiveComparisonConfiguration.registerEqualsForFields(doubleEquals, "temperature");
-    recursiveComparisonConfiguration.registerEqualsForFields(stringEquals, "name");
+    recursiveComparisonConfiguration.registerEqualsForFields(DOUBLE_EQUALS, "temperature");
+    recursiveComparisonConfiguration.registerEqualsForFields(STRING_EQUALS, "name");
     // THEN
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("height")).isSameAs(integerComparator);
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("weight")).isSameAs(ALWAYS_EQUALS_TUPLE);
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("temperature")).isNotNull();
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("name")).isNotNull();
+    then(recursiveComparisonConfiguration.getComparatorForField("height")).isSameAs(integerComparator);
+    then(recursiveComparisonConfiguration.getComparatorForField("weight")).isSameAs(ALWAYS_EQUALS_TUPLE);
+    then(recursiveComparisonConfiguration.getComparatorForField("temperature")).isNotNull();
+    then(recursiveComparisonConfiguration.getComparatorForField("name")).isNotNull();
   }
 
   @Test
   void should_replace_a_registered_field_comparator() {
     // GIVEN
     recursiveComparisonConfiguration.registerComparatorForFields(new AbsValueComparator<>(), "height");
-    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
-    recursiveComparisonConfiguration.registerEqualsForFields(stringEquals, "name");
+    recursiveComparisonConfiguration.registerEqualsForFields(STRING_EQUALS, "name");
     Comparator<?> firstComparator = recursiveComparisonConfiguration.getComparatorForField("name");
     // WHEN
     recursiveComparisonConfiguration.registerComparatorForFields(ALWAYS_EQUALS_TUPLE, "height");
-    recursiveComparisonConfiguration.registerEqualsForFields(stringEquals, "name");
+    recursiveComparisonConfiguration.registerEqualsForFields(STRING_EQUALS, "name");
     // THEN
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("name")).isNotSameAs(firstComparator);
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("height")).isSameAs(ALWAYS_EQUALS_TUPLE);
+    then(recursiveComparisonConfiguration.getComparatorForField("name")).isNotSameAs(firstComparator);
+    then(recursiveComparisonConfiguration.getComparatorForField("height")).isSameAs(ALWAYS_EQUALS_TUPLE);
   }
 
   @Test
@@ -76,7 +75,7 @@ class RecursiveComparisonConfiguration_fieldComparators_Test {
     // WHEN
     recursiveComparisonConfiguration.registerEqualsForFields((Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.01, "weight");
     // THEN
-    assertThat(recursiveComparisonConfiguration.getComparatorForField("weight")).isNotSameAs(firstComparator);
+    then(recursiveComparisonConfiguration.getComparatorForField("weight")).isNotSameAs(firstComparator);
   }
 
   @Test
@@ -102,4 +101,46 @@ class RecursiveComparisonConfiguration_fieldComparators_Test {
                    .hasMessage("Expecting a non null BiPredicate");
   }
 
+  @Test
+  void should_register_bipredicate_for_fields_matching_regexes() {
+    // GIVEN
+    assumeThat(recursiveComparisonConfiguration.getComparatorForField("height")).isNull();
+    assumeThat(recursiveComparisonConfiguration.getComparatorForField("weight")).isNull();
+    assumeThat(recursiveComparisonConfiguration.getComparatorForField("temperature")).isNull();
+    assumeThat(recursiveComparisonConfiguration.getComparatorForField("firstname")).isNull();
+    assumeThat(recursiveComparisonConfiguration.getComparatorForField("lastname")).isNull();
+    // WHEN
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(DOUBLE_EQUALS, ".eight", "temp.*");
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(STRING_EQUALS, ".*name");
+    // THEN
+    then(recursiveComparisonConfiguration.getComparatorForField("height")).isNotNull();
+    then(recursiveComparisonConfiguration.getComparatorForField("weight")).isNotNull();
+    then(recursiveComparisonConfiguration.getComparatorForField("temperature")).isNotNull();
+    then(recursiveComparisonConfiguration.getComparatorForField("firstname")).isNotNull();
+    then(recursiveComparisonConfiguration.getComparatorForField("lastname")).isNotNull();
+  }
+
+  @Test
+  void latest_field_regex_matching_comparator_should_take_precedence_over_previous_ones() {
+    // GIVEN
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(DOUBLE_EQUALS, ".eight");
+    Comparator<?> firstWeightComparator = recursiveComparisonConfiguration.getComparatorForField("weight");
+    // WHEN
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(STRING_EQUALS, "weigh.");
+    // THEN
+    Comparator<?> lastComparator = recursiveComparisonConfiguration.getComparatorForField("weight");
+    then(recursiveComparisonConfiguration.getComparatorForField("weight")).isNotSameAs(firstWeightComparator);
+  }
+
+  @Test
+  void exact_field_comparator_should_take_precedence_over_field_regex_matching_comparator() {
+    // GIVEN
+    recursiveComparisonConfiguration.registerEqualsForFields(DOUBLE_EQUALS, "weight");
+    Comparator<?> weightComparator = recursiveComparisonConfiguration.getComparatorForField("weight");
+    // WHEN
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(STRING_EQUALS, "weigh.");
+    // THEN
+    then(recursiveComparisonConfiguration.getComparatorForField("weight")).isSameAs(weightComparator);
+  }
+
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index bfd0ad794..ca83ae188 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -17,11 +17,12 @@ import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
 import static org.assertj.core.test.AlwaysDifferentComparator.alwaysDifferent;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAYS_EQUALS_TUPLE;
+import static org.assertj.core.test.BiPredicates.DOUBLE_EQUALS;
+import static org.assertj.core.test.BiPredicates.STRING_EQUALS;
 
 import java.time.ZonedDateTime;
 import java.util.Comparator;
 import java.util.UUID;
-import java.util.function.BiPredicate;
 
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.test.AlwaysEqualComparator;
@@ -35,9 +36,6 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
 
   private RecursiveComparisonConfiguration recursiveComparisonConfiguration;
 
-  private static final BiPredicate<String, String> STRING_EQUALS = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
-  private static final BiPredicate<Double, Double> DOUBLE_EQUALS = (Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.01;
-
   @BeforeEach
   void setup() {
     recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
@@ -256,6 +254,22 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                                                "  - height -> %%s %% %%%% %%d%n"));
   }
 
+  @Test
+  void should_show_the_registered_comparator_for_regex_fields_alphabetically() {
+    // GIVEN
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(DOUBLE_EQUALS, ".*bar.*", ".*baz.*");
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(STRING_EQUALS, ".*zoo.*");
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(STRING_EQUALS, ".*foo.*");
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    then(multiLineDescription).containsSubsequence(format("- the fields matching these regexes were compared with the following comparators:%n"),
+                                                   "  - [.*bar.*, .*baz.*] -> ",
+                                                   "  - [.*foo.*] -> ",
+                                                   "  - [.*zoo.*] -> ");
+    System.out.println("multiLineDescription = " + multiLineDescription);
+  }
+
   @Test
   void should_show_the_registered_bipredicate_comparator_for_specific_fields_alphabetically() {
     // GIVEN
@@ -269,6 +283,24 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
                                                    "  - foo -> ");
   }
 
+  @Test
+  void should_show_the_registered_bipredicate_comparator_and_the_precedence_message() {
+    // GIVEN
+    recursiveComparisonConfiguration.registerComparatorForFields(ALWAYS_EQUALS_TUPLE, "foo");
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(DOUBLE_EQUALS, ".*d");
+    recursiveComparisonConfiguration.registerEqualsForFieldsMatchingRegexes(STRING_EQUALS, ".*a", ".*c", ".*b");
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    then(multiLineDescription).containsSubsequence("- these fields were compared with the following comparators:",
+                                                   "  - foo -> ",
+                                                   "- the fields matching these regexes were compared with the following comparators:",
+                                                   "  - [.*a, .*c, .*b] -> ",
+                                                   "  - [.*d] -> ",
+                                                   "- field comparators take precedence over regex field matching comparators.",
+                                                   "- field comparators take precedence over type comparators.");
+  }
+
   @Test
   void should_show_when_strict_type_checking_is_used() {
     // GIVEN
@@ -367,4 +399,5 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     }
 
   }
+
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/test/BiPredicates.java b/assertj-core/src/test/java/org/assertj/core/test/BiPredicates.java
new file mode 100644
index 000000000..3c248f8a6
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/test/BiPredicates.java
@@ -0,0 +1,24 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.test;
+
+import java.util.function.BiPredicate;
+
+public class BiPredicates {
+
+  public static final BiPredicate<Object, Object> ALWAYS_EQUALS = (o1, o2) -> true;
+  public static final BiPredicate<Object, Object> ALWAYS_DIFFERENT = (o1, o2) -> false;
+  public static final BiPredicate<String, String> STRING_EQUALS = (s1, s2) -> s1.equalsIgnoreCase(s2);
+  public static final BiPredicate<Double, Double> DOUBLE_EQUALS = (d1, d2) -> Math.abs(d1 - d2) <= 0.01;
+
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-osgi/verify.bndrun b/assertj-tests/assertj-integration-tests/assertj-core-osgi/verify.bndrun
index 932d353f3..04842d517 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-osgi/verify.bndrun
+++ b/assertj-tests/assertj-integration-tests/assertj-core-osgi/verify.bndrun
@@ -37,5 +37,5 @@
 	junit-platform-commons;version='[1.9.0,1.9.1)',\
 	junit-platform-engine;version='[1.9.0,1.9.1)',\
 	junit-platform-launcher;version='[1.9.0,1.9.1)',\
-	net.bytebuddy.byte-buddy;version='[1.12.14,1.12.15)',\
+	net.bytebuddy.byte-buddy;version='[1.12.16,1.12.17)',\
 	org.opentest4j;version='[1.2.0,1.2.1)'
