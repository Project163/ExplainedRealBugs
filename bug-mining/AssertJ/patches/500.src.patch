diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/PrimitiveArrayList.java b/assertj-core/src/main/java/org/assertj/core/presentation/PrimitiveArrayList.java
new file mode 100644
index 000000000..eda53ef63
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/PrimitiveArrayList.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static java.lang.reflect.Array.getLength;
+import static org.assertj.core.util.Arrays.isArrayTypePrimitive;
+import static org.assertj.core.util.Arrays.isObjectArray;
+import static org.assertj.core.util.Preconditions.checkArgument;
+
+import java.lang.reflect.Array;
+import java.util.AbstractList;
+
+/**
+ * Provides a read-only view of an array as a list.
+ *
+ * <p>This is different from {@link java.util.ArrayList} because the array may be an array of primitives. Arrays of non-primitives
+ * also work, but {@link java.util.ArrayList} would probably be a better choice for these arrays.
+ */
+final class PrimitiveArrayList extends AbstractList<Object> {
+  /** The array to provide a view of. */
+  private final Object array;
+
+  /**
+   * Creates a new {@link PrimitiveArrayList}.
+   *
+   * @param array primitive or object array
+   */
+  PrimitiveArrayList(final Object array) {
+    checkArgument(isObjectArray(array) || isArrayTypePrimitive(array), "input must be an array");
+    this.array = array;
+  }
+
+  @Override
+  public Object get(final int index) {
+    return Array.get(array, index);
+  }
+
+  @Override
+  public int size() {
+    return getLength(array);
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index e7f3fcdce..c444c050f 100644
--- a/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -13,8 +13,6 @@
 package org.assertj.core.presentation;
 
 import static java.lang.Integer.toHexString;
-import static java.lang.reflect.Array.get;
-import static java.lang.reflect.Array.getLength;
 import static java.util.stream.Collectors.toList;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Arrays.isArrayTypePrimitive;
@@ -603,8 +601,8 @@ public class StandardRepresentation implements Representation {
 
   protected String formatPrimitiveArray(Object o) {
     if (!isArrayTypePrimitive(o)) throw notAnArrayOfPrimitives(o);
-    Object[] array = toObjectArray(o);
-    return format(array, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, array);
+    List<Object> objects = new PrimitiveArrayList(o);
+    return format(objects, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, objects);
   }
 
   protected String multiLineFormat(Object[] array, Object root) {
@@ -618,7 +616,15 @@ public class StandardRepresentation implements Representation {
   protected String format(Object[] array, String start, String end, String elementSeparator, String indentation, Object root) {
     if (array == null) return null;
     // root is used to avoid infinite recursion in case one element refers to it.
-    List<String> representedElements = representElements(Stream.of(array), start, end, elementSeparator, indentation, root);
+    return format(java.util.Arrays.asList(array), start, end, elementSeparator, indentation, root);
+  }
+
+  protected String format(List<?> elements, String start, String end, String elementSeparator, String indentation,
+                          Object root) {
+    if (elements == null) return null;
+    if (elements.isEmpty()) return start + end;
+    List<String> representedElements = new TransformingList<>(elements, elem -> safeStringOf(elem, start, end, elementSeparator,
+                                                                                             indentation, root));
     return representGroup(representedElements, start, end, elementSeparator, indentation);
   }
 
@@ -627,7 +633,6 @@ public class StandardRepresentation implements Representation {
     if (iterable == null) return null;
     Iterator<?> iterator = iterable.iterator();
     if (!iterator.hasNext()) return start + end;
-    // alreadyVisited is used to avoid infinite recursion when one element is a container already visited
     List<String> representedElements = representElements(stream(iterable), start, end, elementSeparator, indentation, root);
     return representGroup(representedElements, start, end, elementSeparator, indentation);
   }
@@ -748,14 +753,4 @@ public class StandardRepresentation implements Representation {
   private String format(Map<?, ?> map, Object o) {
     return o == map ? "(this Map)" : toStringOf(o);
   }
-
-  private static Object[] toObjectArray(Object o) {
-    int length = getLength(o);
-    Object[] array = new Object[length];
-    for (int i = 0; i < length; i++) {
-      array[i] = get(o, i);
-    }
-    return array;
-  }
-
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/TransformingList.java b/assertj-core/src/main/java/org/assertj/core/presentation/TransformingList.java
new file mode 100644
index 000000000..3b2eabb47
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/TransformingList.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static java.util.Objects.requireNonNull;
+
+import java.util.AbstractList;
+import java.util.List;
+import java.util.function.Function;
+
+/**
+ * Converts elements of one list to a different type on demand.
+ *
+ * @param <FROM> the type to convert from
+ * @param <TO> the type to convert to
+ */
+final class TransformingList<FROM, TO> extends AbstractList<TO> {
+  /** The list to transform. */
+  private final List<? extends FROM> source;
+
+  /** Converts elements to the new type. */
+  private final Function<? super FROM, ? extends TO> transform;
+
+  /**
+   * Creates a new {@code TransformingList}.
+   *
+   * @param source the list to transform
+   * @param transform transforms elements to the output type
+   */
+  TransformingList(final List<? extends FROM> source, final Function<? super FROM, ? extends TO> transform) {
+    this.source = requireNonNull(source, "source list");
+    this.transform = requireNonNull(transform, "transform function");
+  }
+
+  @Override
+  public TO get(final int index) {
+    return transform.apply(source.get(index));
+  }
+
+  @Override
+  public int size() {
+    return source.size();
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/presentation/PrimitiveArrayListTest.java b/assertj-core/src/test/java/org/assertj/core/presentation/PrimitiveArrayListTest.java
new file mode 100644
index 000000000..16280b196
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/presentation/PrimitiveArrayListTest.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static org.assertj.core.api.BDDAssertions.catchIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+
+class PrimitiveArrayList_Test {
+  @Test
+  void should_not_be_able_to_create_for_non_array() {
+    // WHEN
+    IllegalArgumentException illegalArgumentException = catchIllegalArgumentException(() -> new PrimitiveArrayList("not an array"));
+    // THEN
+    then(illegalArgumentException).hasMessage("input must be an array");
+  }
+
+  @Test
+  void should_not_be_able_to_be_created_from_a_null_input() {
+    // WHEN
+    IllegalArgumentException illegalArgumentException = catchIllegalArgumentException(() -> new PrimitiveArrayList(null));
+    // THEN
+    then(illegalArgumentException).hasMessage("input must be an array");
+  }
+
+  @Test
+  void should_handle_empty() {
+    // GIVEN
+    int[] array = new int[0];
+    // WHEN
+    List<Object> view = new PrimitiveArrayList(array);
+    // THEN
+    then(view).isEmpty();
+  }
+
+  @Test
+  void should_handle_non_empty_primitive() {
+    // GIVEN
+    int[] array = new int[] { 1, 2, 3 };
+    // WHEN
+    List<Object> view = new PrimitiveArrayList(array);
+    // THEN
+    then(view).isEqualTo(list(1, 2, 3));
+  }
+
+  @Test
+  void should_handle_non_empty_objects() {
+    // GIVEN
+    Integer[] array = new Integer[] { 1, 2, 3 };
+    // WHEN
+    List<Object> view = new PrimitiveArrayList(array);
+    // THEN
+    then(view).isEqualTo(list(1, 2, 3));
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java b/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
index 40bae87ab..a97e9cc05 100644
--- a/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
@@ -20,6 +20,8 @@ import static org.assertj.core.util.Strings.quote;
 
 import java.util.stream.Stream;
 
+import org.apache.commons.lang3.StringUtils;
+import org.assertj.core.configuration.Configuration;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
@@ -181,6 +183,28 @@ class StandardRepresentation_array_format_Test extends AbstractBaseRepresentatio
     then(formatted).isEqualTo("[\"Hello\", null]");
   }
 
+  @Test
+  void should_format_big_primitive_array() {
+    // GIVEN
+    int[] array = new int[1 << 28];
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).contains("...");
+    then(StringUtils.countMatches(formatted, "0")).isEqualTo(Configuration.MAX_ELEMENTS_FOR_PRINTING);
+  }
+
+  @Test
+  void should_format_big_object_array() {
+    // GIVEN
+    Object[] array = new Object[1 << 28];
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).contains("...");
+    then(StringUtils.countMatches(formatted, "null")).isEqualTo(Configuration.MAX_ELEMENTS_FOR_PRINTING);
+  }
+
   @Test
   void should_format_array_up_to_the_maximum_allowed_elements() {
     // GIVEN
diff --git a/assertj-core/src/test/java/org/assertj/core/presentation/TransformingListTest.java b/assertj-core/src/test/java/org/assertj/core/presentation/TransformingListTest.java
new file mode 100644
index 000000000..05dfc1204
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/presentation/TransformingListTest.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.presentation;
+
+import static java.util.Collections.emptyList;
+import static org.assertj.core.api.Assertions.catchNullPointerException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+
+import org.junit.jupiter.api.Test;
+
+import com.google.common.collect.ImmutableList;
+
+class TransformingList_Test {
+  @Test
+  void should_handle_empty() {
+    // GIVEN
+    List<Integer> source = emptyList();
+    // WHEN
+    List<String> transformed = new TransformingList<>(source, Object::toString);
+    // THEN
+    then(transformed).isEmpty();
+  }
+
+  @Test
+  void should_handle_non_empty() {
+    // GIVEN
+    List<Integer> source = list(1, 2, 3);
+    // WHEN
+    List<String> transformed = new TransformingList<>(source, Object::toString);
+    // THEN
+    then(transformed).isEqualTo(ImmutableList.of("1", "2", "3"));
+  }
+
+  @Test
+  void should_not_be_able_to_be_created_from_a_null_list() {
+    // WHEN
+    NullPointerException nullPointerException = catchNullPointerException(() -> new TransformingList<>(null, Object::toString));
+    // THEN
+    then(nullPointerException).hasMessage("source list");
+  }
+
+  @Test
+  void should_not_be_able_to_be_created_with_a_null_function() {
+    // WHEN
+    NullPointerException nullPointerException = catchNullPointerException(() -> new TransformingList<>(emptyList(), null));
+    // THEN
+    then(nullPointerException).hasMessage("transform function");
+  }
+
+}
