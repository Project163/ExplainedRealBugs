diff --git a/src/test/java/org/assertj/core/internal/FilesBaseTest.java b/src/test/java/org/assertj/core/internal/FilesBaseTest.java
index 42dadd509..b90ee277a 100644
--- a/src/test/java/org/assertj/core/internal/FilesBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/FilesBaseTest.java
@@ -15,6 +15,7 @@ package org.assertj.core.internal;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
@@ -28,9 +29,12 @@ import java.io.InputStream;
 import java.io.UncheckedIOException;
 import java.nio.file.FileSystem;
 import java.nio.file.Path;
+import java.nio.file.PathMatcher;
 import java.util.LinkedHashMap;
 import java.util.List;
 import java.util.Map;
+import java.util.Optional;
+import java.util.regex.Pattern;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.diff.Delta;
@@ -53,6 +57,7 @@ public class FilesBaseTest {
   protected Failures failures;
   protected Files files;
   protected Files unMockedFiles;
+  protected Failures unMockedFailures;
   protected Diff diff;
   protected Delta<String> delta;
   protected BinaryDiff binaryDiff;
@@ -63,9 +68,11 @@ public class FilesBaseTest {
   public void setUp() {
     actual = mock(File.class);
     failures = spy(new Failures());
+    unMockedFailures = spy(new Failures());
     files = new Files();
     unMockedFiles = new Files();
     files.failures = failures;
+    unMockedFiles.failures = unMockedFailures;
     diff = mock(Diff.class);
     delta = mock(Delta.class);
     when(delta.toString()).thenReturn("Extra lines at line 2 : [line1a, line1b]");
@@ -84,6 +91,25 @@ public class FilesBaseTest {
     }
   }
 
+  protected static void mockPathMatcher(File actual) {
+    FileSystem fileSystem = mock(FileSystem.class);
+    given(fileSystem.getPathMatcher(anyString())).will(invocation -> {
+      String regex = invocation.getArgument(0).toString().split(":")[1];
+      Pattern pattern = Pattern.compile("^" + regex + "$", Pattern.CASE_INSENSITIVE);
+      return (PathMatcher) path -> Optional.ofNullable(path.getFileName())
+                                           .map(Path::toString)
+                                           .filter(pattern.asPredicate())
+                                           .isPresent();
+    });
+    Path path = actual.toPath();
+    if (path == null) {
+      path = mock(Path.class);
+      given(actual.toPath()).willReturn(path);
+      given(path.toFile()).willReturn(actual);
+    }
+    given(path.getFileSystem()).willReturn(fileSystem);
+  }
+
   protected File mockFile(String... names) {
     String name = names[names.length - 1];
     File file = mock(File.class);
diff --git a/src/test/java/org/assertj/core/internal/files/Diff_diff_File_Test.java b/src/test/java/org/assertj/core/internal/files/Diff_diff_File_Test.java
index 164f7a958..a5f81065e 100644
--- a/src/test/java/org/assertj/core/internal/files/Diff_diff_File_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Diff_diff_File_Test.java
@@ -14,7 +14,7 @@ package org.assertj.core.internal.files;
 
 import static java.lang.String.format;
 import static java.nio.charset.Charset.defaultCharset;
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Arrays.array;
 
 import java.io.File;
@@ -58,85 +58,100 @@ class Diff_diff_File_Test {
 
   @Test
   void should_return_empty_diff_list_if_files_have_equal_content() throws IOException {
+    // GIVEN
     String[] content = array("line0", "line1");
     writer.write(actual, content);
     writer.write(expected, content);
+    // WHEN
     List<Delta<String>> diffs = diff.diff(actual, defaultCharset(), expected, defaultCharset());
-    assertThat(diffs).isEmpty();
+    // THEN
+    then(diffs).isEmpty();
   }
 
   @Test
   void should_return_diffs_if_files_do_not_have_equal_content() throws IOException {
+    // GIVEN
     writer.write(actual, "line_0", "line_1");
     writer.write(expected, "line0", "line1");
+    // WHEN
     List<Delta<String>> diffs = diff.diff(actual, defaultCharset(), expected, defaultCharset());
-    assertThat(diffs).hasSize(1);
-    assertThat(diffs.get(0)).hasToString(format("Changed content at line 1:%n"
-                                                + "expecting:%n"
-                                                + "  [\"line0\",%n"
-                                                + "   \"line1\"]%n"
-                                                + "but was:%n"
-                                                + "  [\"line_0\",%n"
-                                                + "   \"line_1\"]%n"));
+    // THEN
+    then(diffs).singleElement().hasToString(format("Changed content at line 1:%n"
+                                                   + "expecting:%n"
+                                                   + "  [\"line0\",%n"
+                                                   + "   \"line1\"]%n"
+                                                   + "but was:%n"
+                                                   + "  [\"line_0\",%n"
+                                                   + "   \"line_1\"]%n"));
   }
 
   @Test
   void should_return_multiple_diffs_if_files_contain_multiple_differences() throws IOException {
+    // GIVEN
     writer.write(actual, "line_0", "line1", "line_2");
     writer.write(expected, "line0", "line1", "line2");
+    // WHEN
     List<Delta<String>> diffs = diff.diff(actual, defaultCharset(), expected, defaultCharset());
-    assertThat(diffs).hasSize(2);
-    assertThat(diffs.get(0)).hasToString(format("Changed content at line 1:%n"
-                                                + "expecting:%n"
-                                                + "  [\"line0\"]%n"
-                                                + "but was:%n"
-                                                + "  [\"line_0\"]%n"));
-    assertThat(diffs.get(1)).hasToString(format("Changed content at line 3:%n"
-                                                + "expecting:%n"
-                                                + "  [\"line2\"]%n"
-                                                + "but was:%n"
-                                                + "  [\"line_2\"]%n"));
+    // THEN
+    then(diffs).hasSize(2);
+    then(diffs.get(0)).hasToString(format("Changed content at line 1:%n"
+                                          + "expecting:%n"
+                                          + "  [\"line0\"]%n"
+                                          + "but was:%n"
+                                          + "  [\"line_0\"]%n"));
+    then(diffs.get(1)).hasToString(format("Changed content at line 3:%n"
+                                          + "expecting:%n"
+                                          + "  [\"line2\"]%n"
+                                          + "but was:%n"
+                                          + "  [\"line_2\"]%n"));
   }
 
   @Test
   void should_be_able_to_detect_mixed_differences() throws IOException {
+    // GIVEN
     // @format:off
     writer.write(actual,   "line1",                     "line2", "line3", "line4", "line5", "line 9", "line 10", "line 11");
     writer.write(expected, "line1", "line1a", "line1b", "line2", "line3", "line7", "line5");
     // @format:on
+    // WHEN
     List<Delta<String>> diffs = diff.diff(actual, defaultCharset(), expected, defaultCharset());
-    assertThat(diffs).hasSize(3);
-    assertThat(diffs.get(0)).hasToString(format("Missing content at line 2:%n"
-                                                + "  [\"line1a\",%n"
-                                                + "   \"line1b\"]%n"));
-    assertThat(diffs.get(1)).hasToString(format("Changed content at line 6:%n"
-                                                + "expecting:%n"
-                                                + "  [\"line7\"]%n"
-                                                + "but was:%n"
-                                                + "  [\"line4\"]%n"));
-    assertThat(diffs.get(2)).hasToString(format("Extra content at line 8:%n"
-                                                + "  [\"line 9\",%n"
-                                                + "   \"line 10\",%n"
-                                                + "   \"line 11\"]%n"));
+    // THEN
+    then(diffs).hasSize(3);
+    then(diffs.get(0)).hasToString(format("Missing content at line 2:%n"
+                                          + "  [\"line1a\",%n"
+                                          + "   \"line1b\"]%n"));
+    then(diffs.get(1)).hasToString(format("Changed content at line 6:%n"
+                                          + "expecting:%n"
+                                          + "  [\"line7\"]%n"
+                                          + "but was:%n"
+                                          + "  [\"line4\"]%n"));
+    then(diffs.get(2)).hasToString(format("Extra content at line 8:%n"
+                                          + "  [\"line 9\",%n"
+                                          + "   \"line 10\",%n"
+                                          + "   \"line 11\"]%n"));
   }
 
   @Test
   void should_return_diffs_if_content_of_actual_is_shorter_than_content_of_expected() throws IOException {
+    // GIVEN
     writer.write(actual, "line_0");
     writer.write(expected, "line_0", "line_1");
+    // WHEN
     List<Delta<String>> diffs = diff.diff(actual, defaultCharset(), expected, defaultCharset());
-    assertThat(diffs).hasSize(1);
-    assertThat(diffs.get(0)).hasToString(format("Missing content at line 2:%n"
-                                                + "  [\"line_1\"]%n"));
+    // THEN
+    then(diffs).singleElement().hasToString(format("Missing content at line 2:%n"
+                                                   + "  [\"line_1\"]%n"));
   }
 
   @Test
   void should_return_diffs_if_content_of_actual_is_longer_than_content_of_expected() throws IOException {
+    // GIVEN
     writer.write(actual, "line_0", "line_1");
     writer.write(expected, "line_0");
+    // WHEN
     List<Delta<String>> diffs = diff.diff(actual, defaultCharset(), expected, defaultCharset());
-    assertThat(diffs).hasSize(1);
-    assertThat(diffs.get(0)).hasToString(format("Extra content at line 2:%n"
-                                                + "  [\"line_1\"]%n"));
+    // THEN
+    then(diffs).singleElement().hasToString(format("Extra content at line 2:%n"
+                                                   + "  [\"line_1\"]%n"));
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/File_assertHasSize_Test.java b/src/test/java/org/assertj/core/internal/files/File_assertHasSize_Test.java
index 32decb85f..3297e9505 100644
--- a/src/test/java/org/assertj/core/internal/files/File_assertHasSize_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/File_assertHasSize_Test.java
@@ -15,7 +15,6 @@ package org.assertj.core.internal.files;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldHaveSize.shouldHaveSize;
-import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.mockito.Mockito.verify;
@@ -26,7 +25,6 @@ import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.Files;
 import org.assertj.core.internal.FilesBaseTest;
 import org.junit.jupiter.api.BeforeAll;
-import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -34,7 +32,6 @@ import org.junit.jupiter.api.Test;
  *
  * @author Krishna Chaithanya Ganta
  */
-@DisplayName("Files.assertHasSize:")
 class File_assertHasSize_Test extends FilesBaseTest {
 
   private static File actual;
@@ -46,8 +43,10 @@ class File_assertHasSize_Test extends FilesBaseTest {
 
   @Test
   void should_throw_error_if_actual_is_null() {
+    // GIVEN
+    File actual = null;
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> files.assertHasSizeInBytes(someInfo(), null, actual.length()));
+    AssertionError assertionError = expectAssertionError(() -> files.assertHasSizeInBytes(INFO, actual, 17));
     // THEN
     assertThat(assertionError).hasMessage(actualIsNull());
   }
@@ -55,26 +54,25 @@ class File_assertHasSize_Test extends FilesBaseTest {
   @Test
   void should_throw_error_if_actual_file_does_not_have_the_expected_size() {
     // GIVEN
-    AssertionInfo info = someInfo();
+    long expectedSizeInBytes = 36L;
     // WHEN
-    expectAssertionError(() -> files.assertHasSizeInBytes(info, actual, 36L));
+    expectAssertionError(() -> files.assertHasSizeInBytes(INFO, actual, expectedSizeInBytes));
     // THEN
-    verify(failures).failure(info, shouldHaveSize(actual, 36L));
+    verify(failures).failure(INFO, shouldHaveSize(actual, expectedSizeInBytes));
   }
 
   @Test
   void should_fail_if_actual_is_not_a_file() {
     // GIVEN
-    AssertionInfo info = someInfo();
     File notAFile = new File("xyz");
     // WHEN
-    expectAssertionError(() -> files.assertHasSizeInBytes(info, notAFile, 36L));
+    expectAssertionError(() -> files.assertHasSizeInBytes(INFO, notAFile, 36L));
     // THEN
-    verify(failures).failure(info, shouldBeFile(notAFile));
+    verify(failures).failure(INFO, shouldBeFile(notAFile));
   }
 
   @Test
   void should_pass_if_actual_has_expected_size() {
-    files.assertHasSizeInBytes(someInfo(), actual, actual.length());
+    files.assertHasSizeInBytes(INFO, actual, actual.length());
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertCanRead_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertCanRead_Test.java
index eed026a47..f4523c83a 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertCanRead_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertCanRead_Test.java
@@ -12,15 +12,11 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 
@@ -34,31 +30,33 @@ import org.junit.jupiter.api.Test;
  * 
  * @author Olivier Demeijer
  * @author Joel Costigliola
- * 
  */
 class Files_assertCanRead_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertCanRead(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertCanRead(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_can_not_read() {
-    when(actual.canRead()).thenReturn(false);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertCanRead(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeReadable(actual));
+    // GIVEN
+    File nonExistentFile = new File("xyz");
+    // WHEN
+    expectAssertionError(() -> files.assertCanRead(INFO, nonExistentFile));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(nonExistentFile));
   }
 
   @Test
   void should_pass_if_actual_can_read() {
-    when(actual.canRead()).thenReturn(true);
-    files.assertCanRead(someInfo(), actual);
+    File actual = new File("src/test/resources/actual_file.txt");
+    files.assertCanRead(INFO, actual);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertCanWrite_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertCanWrite_Test.java
index 8588f4bfb..2e1cb4125 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertCanWrite_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertCanWrite_Test.java
@@ -12,15 +12,12 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeWritable.shouldBeWritable;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
+import static org.assertj.core.util.Files.newFile;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 
@@ -34,31 +31,33 @@ import org.junit.jupiter.api.Test;
  * 
  * @author Olivier Demeijer
  * @author Joel Costigliola
- * 
  */
 class Files_assertCanWrite_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertCanWrite(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertCanWrite(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_can_not_write() {
-    when(actual.canWrite()).thenReturn(false);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertCanWrite(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeWritable(actual));
+    // GIVEN
+    File actual = new File("xyz");
+    // WHEN
+    expectAssertionError(() -> files.assertCanWrite(INFO, actual));
+    // THEN
+    verify(failures).failure(INFO, shouldBeWritable(actual));
   }
 
   @Test
   void should_pass_if_actual_can_write() {
-    when(actual.canWrite()).thenReturn(true);
-    files.assertCanWrite(someInfo(), actual);
+    File actual = newFile(tempDir.getAbsolutePath() + "to_write.txt");
+    files.assertCanWrite(INFO, actual);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertDoesNotExist_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertDoesNotExist_Test.java
index e3e983d83..68ba3fa09 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertDoesNotExist_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertDoesNotExist_Test.java
@@ -12,15 +12,11 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldNotExist.shouldNotExist;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 
@@ -39,24 +35,27 @@ class Files_assertDoesNotExist_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertDoesNotExist(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertDoesNotExist(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_exists() {
-    when(actual.exists()).thenReturn(true);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertDoesNotExist(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldNotExist(actual));
+    // GIVEN
+    File actual = new File("src/test/resources/actual_file.txt");
+    // WHEN
+    expectAssertionError(() -> files.assertDoesNotExist(INFO, actual));
+    // THEN
+    verify(failures).failure(INFO, shouldNotExist(actual));
   }
 
   @Test
   void should_pass_if_actual_does_not_exist() {
-    when(actual.exists()).thenReturn(false);
-    files.assertDoesNotExist(someInfo(), actual);
+    File actual = new File("xyz");
+    files.assertDoesNotExist(INFO, actual);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertExists_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertExists_Test.java
index 9912a3039..fdc3fdbb0 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertExists_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertExists_Test.java
@@ -12,15 +12,11 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldExist.shouldExist;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 
@@ -39,24 +35,27 @@ class Files_assertExists_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertExists(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertExists(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_does_not_exist() {
-    when(actual.exists()).thenReturn(false);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertExists(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldExist(actual));
+    // GIVEN
+    File actual = new File("xyz");
+    // WHEN
+    expectAssertionError(() -> files.assertExists(INFO, actual));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
   }
 
   @Test
   void should_pass_if_actual_exists() {
-    when(actual.exists()).thenReturn(true);
-    files.assertExists(someInfo(), actual);
+    File actual = new File("src/test/resources/actual_file.txt");
+    files.assertExists(INFO, actual);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasBinaryContent_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasBinaryContent_Test.java
index f83bd644e..fd5d3d616 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasBinaryContent_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasBinaryContent_Test.java
@@ -12,14 +12,14 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.apache.commons.io.FileUtils.writeByteArrayToFile;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
@@ -27,7 +27,7 @@ import java.io.File;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 
-import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.BinaryDiff;
 import org.assertj.core.internal.BinaryDiffResult;
 import org.assertj.core.internal.Files;
 import org.assertj.core.internal.FilesBaseTest;
@@ -54,53 +54,68 @@ class Files_assertHasBinaryContent_Test extends FilesBaseTest {
 
   @Test
   void should_throw_error_if_expected_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasBinaryContent(someInfo(), actual, null))
-                                    .withMessage("The binary content to compare to should not be null");
+    // GIVEN
+    byte[] expectedContent = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasBinaryContent(INFO, actual, expectedContent),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The binary content to compare to should not be null");
   }
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasBinaryContent(someInfo(), null, expected))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasBinaryContent(INFO, actual, expected));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_file() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     File notAFile = new File("xyz");
-
-    Throwable error = catchThrowable(() -> files.assertHasBinaryContent(info, notAFile, expected));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeFile(notAFile));
+    // WHEN
+    expectAssertionError(() -> files.assertHasBinaryContent(INFO, notAFile, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeFile(notAFile));
   }
 
   @Test
   void should_pass_if_file_has_expected_binary_content() throws IOException {
-    when(binaryDiff.diff(actual, expected)).thenReturn(BinaryDiffResult.noDiff());
-    files.assertHasBinaryContent(someInfo(), actual, expected);
+    // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    writeByteArrayToFile(actual, "actual".getBytes());
+    byte[] expected = "actual".getBytes();
+    // WHEN/THEN
+    unMockedFiles.assertHasBinaryContent(INFO, actual, expected);
   }
 
   @Test
   void should_throw_error_wrapping_caught_IOException() throws IOException {
+    // GIVEN
     IOException cause = new IOException();
     when(binaryDiff.diff(actual, expected)).thenThrow(cause);
-
-    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> files.assertHasBinaryContent(someInfo(),
-                                                                                                        actual,
-                                                                                                        expected))
-                                                         .withCause(cause);
+    // THEN
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertHasBinaryContent(INFO, actual, expected),
+                                                     UncheckedIOException.class);
+    // THEN
+    then(uioe).hasCause(cause);
   }
 
   @Test
   void should_fail_if_file_does_not_have_expected_binary_content() throws IOException {
-    BinaryDiffResult diff = new BinaryDiffResult(15, (byte) 0xCA, (byte) 0xFE);
-    when(binaryDiff.diff(actual, expected)).thenReturn(diff);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertHasBinaryContent(info, actual, expected));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldHaveBinaryContent(actual, diff));
+    // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    writeByteArrayToFile(actual, "actual".getBytes());
+    byte[] expected = "fake".getBytes();
+    BinaryDiff binaryDiff = new BinaryDiff();
+    BinaryDiffResult diff = binaryDiff.diff(actual, expected);
+    // WHEN
+    expectAssertionError(() -> unMockedFiles.assertHasBinaryContent(INFO, actual, expected));
+    // THEN
+    verify(unMockedFailures).failure(INFO, shouldHaveBinaryContent(actual, diff));
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasContent_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasContent_Test.java
index 22856e763..5febf1a4e 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasContent_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasContent_Test.java
@@ -12,13 +12,11 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldHaveContent.shouldHaveContent;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -27,13 +25,12 @@ import java.io.File;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 import java.nio.charset.Charset;
-import java.util.ArrayList;
 import java.util.List;
 
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Diff;
 import org.assertj.core.internal.Files;
 import org.assertj.core.internal.FilesBaseTest;
-import org.assertj.core.util.Lists;
 import org.assertj.core.util.diff.Delta;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
@@ -60,52 +57,61 @@ class Files_assertHasContent_Test extends FilesBaseTest {
 
   @Test
   void should_throw_error_if_expected_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasContent(someInfo(), actual, null, charset))
-                                    .withMessage("The text to compare to should not be null");
+    // GIVEN
+    String expectedContent = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasContent(INFO, actual, expectedContent, charset),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The text to compare to should not be null");
   }
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasContent(someInfo(), null, expected, charset))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasContent(INFO, actual, expected, charset));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_file() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     File notAFile = new File("xyz");
-
-    Throwable error = catchThrowable(() -> files.assertHasContent(info, notAFile, expected, charset));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeFile(notAFile));
+    // WHEN
+    expectAssertionError(() -> files.assertHasContent(INFO, notAFile, expected, charset));
+    // THEN
+    verify(failures).failure(INFO, shouldBeFile(notAFile));
   }
 
   @Test
-  void should_pass_if_file_has_text_content() throws IOException {
-    when(diff.diff(actual, expected, charset)).thenReturn(new ArrayList<>());
-    files.assertHasContent(someInfo(), actual, expected, charset);
+  void should_pass_if_file_has_text_content() {
+    String expected = "actual";
+    files.assertHasContent(INFO, actual, expected, charset);
   }
 
   @Test
   void should_throw_error_wrapping_caught_IOException() throws IOException {
+    // GIVEN
     IOException cause = new IOException();
     when(diff.diff(actual, expected, charset)).thenThrow(cause);
-
-    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> files.assertHasContent(someInfo(), actual,
-                                                                                                  expected, charset))
-                                                         .withCause(cause);
+    // WHEN
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertHasContent(INFO, actual, expected, charset),
+                                                     UncheckedIOException.class);
+    // THEN
+    then(uioe).hasCause(cause);
   }
 
   @Test
   void should_fail_if_file_does_not_have_expected_text_content() throws IOException {
-    List<Delta<String>> diffs = Lists.newArrayList(delta);
-    when(diff.diff(actual, expected, charset)).thenReturn(diffs);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertHasContent(info, actual, expected, charset));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldHaveContent(actual, charset, diffs));
+    // GIVEN
+    Diff diff = new Diff();
+    List<Delta<String>> diffs = diff.diff(actual, expected, charset);
+    // WHEN
+    expectAssertionError(() -> unMockedFiles.assertHasContent(INFO, actual, expected, charset));
+    // THEN
+    verify(unMockedFailures).failure(INFO, shouldHaveContent(actual, charset, diffs));
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmBytes_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmBytes_Test.java
index 777926b5c..d13108496 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmBytes_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmBytes_Test.java
@@ -12,30 +12,31 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static java.nio.file.Files.readAllBytes;
+import static org.apache.commons.io.FileUtils.writeByteArrayToFile;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.internal.Digests.toHex;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.UncheckedIOException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.DigestDiff;
-import org.assertj.core.internal.Digests;
 import org.assertj.core.internal.Files;
 import org.assertj.core.internal.FilesBaseTest;
 import org.junit.jupiter.api.Test;
@@ -48,21 +49,23 @@ import org.junit.jupiter.api.Test;
 class Files_assertHasDigest_AlgorithmBytes_Test extends FilesBaseTest {
   private final String algorithm = "MD5";
   private final byte[] expected = new byte[0];
-  private final String real = "3AC1AFA2A89B7E4F1866502877BF1DC5";
 
   @Test
   void should_fail_if_actual_is_null() {
-    AssertionInfo info = someInfo();
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasDigest(info, null, algorithm, expected))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_with_should_exist_error_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
+    File actual = new File("xyz");
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
     // THEN
     verify(failures).failure(INFO, shouldExist(actual));
   }
@@ -70,10 +73,9 @@ class Files_assertHasDigest_AlgorithmBytes_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_file() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(false);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/tmp");
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
     // THEN
     verify(failures).failure(INFO, shouldBeFile(actual));
   }
@@ -81,40 +83,47 @@ class Files_assertHasDigest_AlgorithmBytes_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_readable() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(false);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
+    actual.setReadable(false);
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
     // THEN
     verify(failures).failure(INFO, shouldBeReadable(actual));
   }
 
   @Test
   void should_throw_error_if_digest_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO, null, (MessageDigest) null, expected))
-                                    .withMessage("The message digest algorithm should not be null");
+    // GIVEN
+    MessageDigest digest = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, digest, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The message digest algorithm should not be null");
   }
 
   @Test
   void should_throw_error_if_expected_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO, null, algorithm, (byte[]) null))
-                                    .withMessage("The binary representation of digest to compare to should not be null");
+    // GIVEN
+    byte[] expected = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, algorithm, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The binary representation of digest to compare to should not be null");
   }
 
   @Test
   void should_throw_error_wrapping_caught_IOException() throws IOException {
     // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
     IOException cause = new IOException();
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
     given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, algorithm, expected),
+                                                     UncheckedIOException.class);
     // THEN
-    assertThat(error).isInstanceOf(UncheckedIOException.class)
-                     .hasCause(cause);
+    then(uioe).hasCause(cause);
   }
 
   @Test
@@ -122,39 +131,37 @@ class Files_assertHasDigest_AlgorithmBytes_Test extends FilesBaseTest {
     // GIVEN
     String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    IllegalStateException ise = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected),
+                                                     IllegalStateException.class);
     // THEN
-    assertThat(error).isInstanceOf(IllegalStateException.class)
-                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+    then(ise).hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
   }
 
   @Test
   void should_fail_if_actual_does_not_have_expected_digest() throws IOException, NoSuchAlgorithmException {
     // GIVEN
-    InputStream stream = getClass().getResourceAsStream("/red.png");
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
-    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    String algorithm = "MD5";
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    writeByteArrayToFile(actual, "Bad Content".getBytes());
+    MessageDigest digest = MessageDigest.getInstance("MD5");
+    byte[] expected = digest.digest("Content".getBytes());
+    DigestDiff digestDiff = new DigestDiff(toHex(digest.digest(readAllBytes(actual.toPath()))), toHex(expected), digest);
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    expectAssertionError(() -> unMockedFiles.assertHasDigest(INFO, actual, algorithm, expected));
     // THEN
-    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff(real, "", MessageDigest.getInstance(algorithm))));
-    failIfStreamIsOpen(stream);
+    verify(unMockedFailures).failure(INFO, shouldHaveDigest(actual, digestDiff));
   }
 
   @Test
-  void should_pass_if_actual_has_expected_digest() throws IOException {
+  void should_pass_if_actual_has_expected_digest() throws Exception {
     // GIVEN
-    InputStream stream = getClass().getResourceAsStream("/red.png");
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
-    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
-    // WHEN
-    files.assertHasDigest(INFO, actual, algorithm, Digests.fromHex(real));
-    // THEN
-    failIfStreamIsOpen(stream);
+    String algorithm = "MD5";
+    byte[] data = "Content".getBytes();
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    writeByteArrayToFile(actual, data);
+    byte[] expected = MessageDigest.getInstance(algorithm).digest(data);
+    // WHEN/THEN
+    unMockedFiles.assertHasDigest(INFO, actual, algorithm, expected);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmString_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmString_Test.java
index 77a03c000..468b51a57 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmString_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmString_Test.java
@@ -12,23 +12,25 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static java.nio.file.Files.readAllBytes;
+import static org.apache.commons.io.FileUtils.writeByteArrayToFile;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.internal.Digests.toHex;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.UncheckedIOException;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
@@ -48,21 +50,23 @@ import org.junit.jupiter.api.Test;
 class Files_assertHasDigest_AlgorithmString_Test extends FilesBaseTest {
   private final String algorithm = "MD5";
   private final String expected = "";
-  private final String real = "3AC1AFA2A89B7E4F1866502877BF1DC5";
 
   @Test
   void should_fail_if_actual_is_null() {
-    AssertionInfo info = someInfo();
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasDigest(info, null, algorithm, expected))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_with_should_exist_error_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
+    File actual = new File("xyz");
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
     // THEN
     verify(failures).failure(INFO, shouldExist(actual));
   }
@@ -70,10 +74,9 @@ class Files_assertHasDigest_AlgorithmString_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_file() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(false);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/tmp");
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
     // THEN
     verify(failures).failure(INFO, shouldBeFile(actual));
   }
@@ -81,40 +84,47 @@ class Files_assertHasDigest_AlgorithmString_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_readable() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(false);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
+    actual.setReadable(false);
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
     // THEN
     verify(failures).failure(INFO, shouldBeReadable(actual));
   }
 
   @Test
   void should_throw_error_if_digest_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO, null, (MessageDigest) null, expected))
-                                    .withMessage("The message digest algorithm should not be null");
+    // GIVEN
+    MessageDigest digest = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, digest, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The message digest algorithm should not be null");
   }
 
   @Test
   void should_throw_error_if_expected_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO, null, algorithm, (byte[]) null))
-                                    .withMessage("The binary representation of digest to compare to should not be null");
+    // GIVEN
+    byte[] expected = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, algorithm, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The binary representation of digest to compare to should not be null");
   }
 
   @Test
   void should_throw_error_wrapping_caught_IOException() throws IOException {
     // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
     IOException cause = new IOException();
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
     given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, algorithm, expected),
+                                                     UncheckedIOException.class);
     // THEN
-    assertThat(error).isInstanceOf(UncheckedIOException.class)
-                     .hasCause(cause);
+    then(uioe).hasCause(cause);
   }
 
   @Test
@@ -122,39 +132,37 @@ class Files_assertHasDigest_AlgorithmString_Test extends FilesBaseTest {
     // GIVEN
     String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    IllegalStateException ise = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected),
+                                                     IllegalStateException.class);
     // THEN
-    assertThat(error).isInstanceOf(IllegalStateException.class)
-                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+    then(ise).hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
   }
 
   @Test
   void should_fail_if_actual_does_not_have_expected_digest() throws IOException, NoSuchAlgorithmException {
     // GIVEN
-    InputStream stream = getClass().getResourceAsStream("/red.png");
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
-    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    String algorithm = "MD5";
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    writeByteArrayToFile(actual, "Bad Content".getBytes());
+    MessageDigest digest = MessageDigest.getInstance("MD5");
+    String expected = toHex(digest.digest("Content".getBytes()));
+    DigestDiff digestDiff = new DigestDiff(toHex(digest.digest(readAllBytes(actual.toPath()))), expected, digest);
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    expectAssertionError(() -> unMockedFiles.assertHasDigest(INFO, actual, algorithm, expected));
     // THEN
-    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff(real, "", MessageDigest.getInstance(algorithm))));
-    failIfStreamIsOpen(stream);
+    verify(unMockedFailures).failure(INFO, shouldHaveDigest(actual, digestDiff));
   }
 
   @Test
-  void should_pass_if_actual_has_expected_digest() throws IOException {
+  void should_pass_if_actual_has_expected_digest() throws Exception {
     // GIVEN
-    InputStream stream = getClass().getResourceAsStream("/red.png");
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
-    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
-    // WHEN
-    files.assertHasDigest(INFO, actual, algorithm, Digests.fromHex(real));
-    // THEN
-    failIfStreamIsOpen(stream);
+    String algorithm = "MD5";
+    byte[] data = "Content".getBytes();
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    writeByteArrayToFile(actual, data);
+    String expected = toHex(MessageDigest.getInstance(algorithm).digest(data));
+    // WHEN/THEN
+    unMockedFiles.assertHasDigest(INFO, actual, algorithm, Digests.fromHex(expected));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestBytes_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestBytes_Test.java
index c9fe0c23c..a5c7d6fab 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestBytes_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestBytes_Test.java
@@ -12,15 +12,19 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static java.nio.file.Files.readAllBytes;
+import static org.apache.commons.io.FileUtils.writeByteArrayToFile;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.internal.Digests.toHex;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
@@ -28,7 +32,6 @@ import static org.mockito.Mockito.verify;
 
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.UncheckedIOException;
 import java.security.MessageDigest;
 
@@ -44,21 +47,26 @@ import org.junit.jupiter.api.Test;
  * @author Valeriy Vyrva
  */
 class Files_assertHasDigest_DigestBytes_Test extends FilesBaseTest {
+
   private final MessageDigest digest = mock(MessageDigest.class);
   private final byte[] expected = new byte[0];
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasDigest(INFO, null, digest, expected))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_with_should_exist_error_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
+    File actual = new File("xyz");
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, digest, expected));
     // THEN
     verify(failures).failure(INFO, shouldExist(actual));
   }
@@ -66,10 +74,9 @@ class Files_assertHasDigest_DigestBytes_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_file() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(false);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/tmp");
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, digest, expected));
     // THEN
     verify(failures).failure(INFO, shouldBeFile(actual));
   }
@@ -77,40 +84,47 @@ class Files_assertHasDigest_DigestBytes_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_readable() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(false);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
+    actual.setReadable(false);
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, digest, expected));
     // THEN
     verify(failures).failure(INFO, shouldBeReadable(actual));
   }
 
   @Test
   void should_throw_error_if_digest_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO, null, (MessageDigest) null, expected))
-                                    .withMessage("The message digest algorithm should not be null");
+    // GIVEN
+    MessageDigest digest = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, digest, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The message digest algorithm should not be null");
   }
 
   @Test
   void should_throw_error_if_expected_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO, null, digest, (byte[]) null))
-                                    .withMessage("The binary representation of digest to compare to should not be null");
+    // GIVEN
+    byte[] expected = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, digest, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The binary representation of digest to compare to should not be null");
   }
 
   @Test
   void should_throw_error_wrapping_caught_IOException() throws IOException {
     // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
     IOException cause = new IOException();
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
     given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, digest, expected),
+                                                     UncheckedIOException.class);
     // THEN
-    assertThat(error).isInstanceOf(UncheckedIOException.class)
-                     .hasCause(cause);
+    then(uioe).hasCause(cause);
   }
 
   @Test
@@ -118,41 +132,36 @@ class Files_assertHasDigest_DigestBytes_Test extends FilesBaseTest {
     // GIVEN
     String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    IllegalStateException ise = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected),
+                                                     IllegalStateException.class);
     // THEN
-    assertThat(error).isInstanceOf(IllegalStateException.class)
-                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+    then(ise).hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
   }
 
   @Test
-  void should_fail_if_actual_does_not_have_expected_digest() throws IOException {
+  void should_fail_if_actual_does_not_have_expected_digest() throws Exception {
     // GIVEN
-    InputStream stream = getClass().getResourceAsStream("/red.png");
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
-    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
-    given(digest.digest()).willReturn(new byte[] { 0, 1 });
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    writeByteArrayToFile(actual, "Bad Content".getBytes());
+    MessageDigest digest = MessageDigest.getInstance("MD5");
+    byte[] expected = digest.digest("Content".getBytes());
+    DigestDiff digestDiff = new DigestDiff(toHex(digest.digest(readAllBytes(actual.toPath()))), toHex(expected), digest);
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    expectAssertionError(() -> unMockedFiles.assertHasDigest(INFO, actual, digest, expected));
     // THEN
-    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff("0001", "", digest)));
-    failIfStreamIsOpen(stream);
+    verify(unMockedFailures).failure(INFO, shouldHaveDigest(actual, digestDiff));
   }
 
   @Test
-  void should_pass_if_actual_has_expected_digest() throws IOException {
+  void should_pass_if_actual_has_expected_digest() throws Exception {
     // GIVEN
-    InputStream stream = getClass().getResourceAsStream("/red.png");
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
-    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
-    given(digest.digest()).willReturn(expected);
-    // WHEN
-    files.assertHasDigest(INFO, actual, digest, expected);
-    // THEN
-    failIfStreamIsOpen(stream);
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    byte[] data = "Content".getBytes();
+    writeByteArrayToFile(actual, data);
+    MessageDigest digest = MessageDigest.getInstance("MD5");
+    byte[] expected = digest.digest(data);
+    // WHEN/THEN
+    unMockedFiles.assertHasDigest(INFO, actual, digest, expected);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestString_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestString_Test.java
index 3d29bc715..30a5229c8 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestString_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestString_Test.java
@@ -12,15 +12,20 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static java.nio.file.Files.readAllBytes;
+import static org.apache.commons.io.FileUtils.writeByteArrayToFile;
 import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.internal.Digests.toHex;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
@@ -28,7 +33,6 @@ import static org.mockito.Mockito.verify;
 
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.io.UncheckedIOException;
 import java.security.MessageDigest;
 
@@ -44,21 +48,26 @@ import org.junit.jupiter.api.Test;
  * @author Valeriy Vyrva
  */
 class Files_assertHasDigest_DigestString_Test extends FilesBaseTest {
+
   private final MessageDigest digest = mock(MessageDigest.class);
   private final String expected = "";
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasDigest(INFO, null, digest, expected))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_with_should_exist_error_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
+    File actual = new File("xyz");
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, digest, expected));
     // THEN
     verify(failures).failure(INFO, shouldExist(actual));
   }
@@ -66,10 +75,9 @@ class Files_assertHasDigest_DigestString_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_file() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(false);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/tmp");
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, digest, expected));
     // THEN
     verify(failures).failure(INFO, shouldBeFile(actual));
   }
@@ -77,40 +85,47 @@ class Files_assertHasDigest_DigestString_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_readable() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(false);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
+    actual.setReadable(false);
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    expectAssertionError(() -> files.assertHasDigest(INFO, actual, digest, expected));
     // THEN
     verify(failures).failure(INFO, shouldBeReadable(actual));
   }
 
   @Test
   void should_throw_error_if_digest_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO, null, (MessageDigest) null, expected))
-                                    .withMessage("The message digest algorithm should not be null");
+    // GIVEN
+    MessageDigest digest = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, digest, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The message digest algorithm should not be null");
   }
 
   @Test
   void should_throw_error_if_expected_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasDigest(INFO, null, digest, (byte[]) null))
-                                    .withMessage("The binary representation of digest to compare to should not be null");
+    // GIVEN
+    byte[] expected = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, digest, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The binary representation of digest to compare to should not be null");
   }
 
   @Test
   void should_throw_error_wrapping_caught_IOException() throws IOException {
     // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
     IOException cause = new IOException();
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
     given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    Throwable error = catchThrowableOfType(() -> files.assertHasDigest(INFO, actual, digest, expected),
+                                           UncheckedIOException.class);
     // THEN
-    assertThat(error).isInstanceOf(UncheckedIOException.class)
-                     .hasCause(cause);
+    then(error).hasCause(cause);
   }
 
   @Test
@@ -120,39 +135,34 @@ class Files_assertHasDigest_DigestString_Test extends FilesBaseTest {
     // WHEN
     Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
     // THEN
-    assertThat(error).isInstanceOf(IllegalStateException.class)
-                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+    then(error).isInstanceOf(IllegalStateException.class)
+               .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
   }
 
   @Test
-  void should_fail_if_actual_does_not_have_expected_digest() throws IOException {
+  void should_fail_if_actual_does_not_have_expected_digest() throws Exception {
     // GIVEN
-    InputStream stream = getClass().getResourceAsStream("/red.png");
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
-    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
-    given(digest.digest()).willReturn(new byte[] { 0, 1 });
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    writeByteArrayToFile(actual, "Bad Content".getBytes());
+    MessageDigest digest = MessageDigest.getInstance("MD5");
+    String expected = toHex(digest.digest("Content".getBytes()));
+    DigestDiff digestDiff = new DigestDiff(toHex(digest.digest(readAllBytes(actual.toPath()))), expected, digest);
     // WHEN
-    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    expectAssertionError(() -> unMockedFiles.assertHasDigest(INFO, actual, digest, expected));
     // THEN
-    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff("0001", "", digest)));
-    failIfStreamIsOpen(stream);
+    verify(unMockedFailures).failure(INFO, shouldHaveDigest(actual, digestDiff));
   }
 
   @Test
-  void should_pass_if_actual_has_expected_digest() throws IOException {
+  void should_pass_if_actual_has_expected_digest() throws Exception {
     // GIVEN
-    InputStream stream = getClass().getResourceAsStream("/red.png");
-    given(actual.exists()).willReturn(true);
-    given(actual.isFile()).willReturn(true);
-    given(actual.canRead()).willReturn(true);
-    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
-    given(digest.digest()).willReturn(expected.getBytes());
-    // WHEN
-    files.assertHasDigest(INFO, actual, digest, expected);
-    // THEN
-    failIfStreamIsOpen(stream);
+    File actual = newFile(tempDir.getAbsolutePath() + "/tmp.txt");
+    byte[] data = "Content".getBytes();
+    writeByteArrayToFile(actual, data);
+    MessageDigest digest = MessageDigest.getInstance("MD5");
+    String expected = toHex(digest.digest(data));
+    // WHEN/THEN
+    unMockedFiles.assertHasDigest(INFO, actual, digest, expected);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasExtension_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasExtension_Test.java
index 43838d94b..a6fc8144b 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasExtension_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasExtension_Test.java
@@ -37,15 +37,14 @@ import org.junit.jupiter.params.provider.ValueSource;
  */
 class Files_assertHasExtension_Test extends FilesBaseTest {
 
-  private String expectedExtension = "java";
+  private final String expectedExtension = "java";
 
   @Test
   void should_fail_if_actual_is_null() {
     // GIVEN
-    File actual = null;
     String expected = "txt";
     // WHEN
-    AssertionError error = expectAssertionError(() -> files.assertHasExtension(INFO, actual, expected));
+    AssertionError error = expectAssertionError(() -> files.assertHasExtension(INFO, null, expected));
     // THEN
     then(error).hasMessage(actualIsNull());
   }
@@ -54,9 +53,8 @@ class Files_assertHasExtension_Test extends FilesBaseTest {
   void should_fail_if_expected_extension_is_null() {
     // GIVEN
     File actual = new File("file.txt");
-    String expected = null;
     // WHEN
-    Throwable thrown = catchThrowable(() -> files.assertHasExtension(INFO, actual, expected));
+    Throwable thrown = catchThrowable(() -> files.assertHasExtension(INFO, actual, null));
     // THEN
     then(thrown).isInstanceOf(NullPointerException.class)
                 .hasMessage("The expected extension should not be null.");
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasName_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasName_Test.java
index 2acc55ee8..e5c867c8c 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasName_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasName_Test.java
@@ -12,17 +12,16 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldHaveName.shouldHaveName;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
-import org.assertj.core.api.AssertionInfo;
+import java.io.File;
+
 import org.assertj.core.internal.FilesBaseTest;
 import org.junit.jupiter.api.Test;
 
@@ -39,30 +38,38 @@ class Files_assertHasName_Test extends FilesBaseTest {
 
   @Test
   void should_throw_error_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasName(someInfo(), null, expectedName))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasName(INFO, actual, expectedName));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_throw_npe_if_name_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasName(someInfo(), actual, null))
-                                    .withMessage("The expected name should not be null.");
+    // GIVEN
+    String expectedName = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasName(INFO, actual, expectedName),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The expected name should not be null.");
   }
 
   @Test
   void should_throw_error_if_actual_does_not_have_the_expected_name() {
-    AssertionInfo info = someInfo();
-    when(actual.getName()).thenReturn("not.expected.name");
-
-    Throwable error = catchThrowable(() -> files.assertHasName(info, actual, expectedName));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldHaveName(actual, expectedName));
+    // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/not_expected.name");
+    // WHEN
+    expectAssertionError(() -> files.assertHasName(INFO, actual, expectedName));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveName(actual, expectedName));
   }
 
   @Test
   void should_pass_if_actual_has_expected_name() {
-    when(actual.getName()).thenReturn(expectedName);
-    files.assertHasName(someInfo(), actual, expectedName);
+    File actual = newFile(tempDir.getAbsolutePath() + "/expected.name");
+    files.assertHasName(INFO, actual, expectedName);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasNoExtension_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasNoExtension_Test.java
index 1325c541e..f67d8577c 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasNoExtension_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasNoExtension_Test.java
@@ -12,15 +12,14 @@
  */
 package org.assertj.core.internal.files;
 
-import static com.google.common.io.Files.touch;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldHaveNoExtension.shouldHaveNoExtension;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
 
 import java.io.File;
-import java.io.IOException;
 
 import org.assertj.core.internal.FilesBaseTest;
 import org.junit.jupiter.api.Test;
@@ -62,7 +61,7 @@ class Files_assertHasNoExtension_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_has_extension() {
     // GIVEN
-    File actual = new File("src/test/resources/ascii.txt");
+    File actual = newFile(tempDir.getAbsolutePath() + "/text.txt");
     // WHEN
     AssertionError error = expectAssertionError(() -> files.assertHasNoExtension(INFO, actual));
     // THEN
@@ -71,11 +70,10 @@ class Files_assertHasNoExtension_Test extends FilesBaseTest {
 
   @ParameterizedTest
   @ValueSource(strings = { "file", "file." })
-  void should_pass_if_actual_has_no_extension(String filename) throws IOException {
-    // GIVEN
-    File actual = new File(tempDir.getAbsolutePath() + "/" + filename);
-    touch(actual);
-    // WHEN/THEN
+  void should_pass_if_actual_has_no_extension(String filename) {
+    // GIVEN / WHEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/" + filename);
+    // THEN
     files.assertHasNoExtension(INFO, actual);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasNoParent_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasNoParent_Test.java
index c342322c2..fef11e1b2 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasNoParent_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasNoParent_Test.java
@@ -12,21 +12,16 @@
  */
 package org.assertj.core.internal.files;
 
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.FilesBaseTest;
-import org.junit.jupiter.api.Test;
-
-import java.io.File;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldHaveNoParent.shouldHaveNoParent;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
+
+import java.io.File;
+
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.jupiter.api.Test;
 
 /**
  * Tests for
@@ -39,24 +34,27 @@ class Files_assertHasNoParent_Test extends FilesBaseTest {
 
   @Test
   void should_throw_error_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasNoParent(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasNoParent(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_has_parent() {
-    AssertionInfo info = someInfo();
-    when(actual.getParentFile()).thenReturn(mock(File.class));
-
-    Throwable error = catchThrowable(() -> files.assertHasNoParent(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldHaveNoParent(actual));
+    // GIVEN
+    File actual = new File("x/y/z");
+    // WHEN
+    expectAssertionError(() -> files.assertHasNoParent(INFO, actual));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveNoParent(actual));
   }
 
   @Test
   void should_pass_if_actual_has_no_parent() {
-    when(actual.getParentFile()).thenReturn(null);
-    files.assertHasNoParent(someInfo(), actual);
+    File actual = new File("xyz");
+    files.assertHasNoParent(INFO, actual);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasParent_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasParent_Test.java
index d36c6d5d5..a60bb11d9 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasParent_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasParent_Test.java
@@ -12,25 +12,22 @@
  */
 package org.assertj.core.internal.files;
 
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.FilesBaseTest;
-import org.junit.jupiter.api.Test;
-
-import java.io.File;
-import java.io.IOException;
-import java.io.UncheckedIOException;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldHaveParent.shouldHaveParent;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
 
+import java.io.File;
+import java.io.IOException;
+import java.io.UncheckedIOException;
+
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.jupiter.api.Test;
+
 /**
  * Tests for
  * <code>{@link org.assertj.core.internal.Files#assertHasParent(org.assertj.core.api.AssertionInfo, java.io.File, java.io.File)}</code>
@@ -45,71 +42,82 @@ class Files_assertHasParent_Test extends FilesBaseTest {
 
   @Test
   void should_throw_error_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertHasParent(someInfo(), null, expectedParent))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertHasParent(INFO, actual, expectedParent));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_throw_npe_if_expected_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertHasParent(someInfo(), actual, null))
-                                    .withMessage("The expected parent file should not be null.");
+    // GIVEN
+    File expected = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> files.assertHasParent(INFO, actual, expected),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage("The expected parent file should not be null.");
   }
 
   @Test
   void should_fail_if_actual_has_no_parent() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     File withoutParent = new File("without-parent");
-
-    Throwable error = catchThrowable(() -> files.assertHasParent(info, withoutParent, expectedParent));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldHaveParent(withoutParent, expectedParent));
+    // WHEN
+    expectAssertionError(() -> files.assertHasParent(INFO, withoutParent, expectedParent));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveParent(withoutParent, expectedParent));
   }
 
   @Test
   void should_fail_if_actual_does_not_have_the_expected_parent() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     File expectedParent = new File("./expected-parent");
-
-    Throwable error = catchThrowable(() -> files.assertHasParent(info, actual, expectedParent));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldHaveParent(actual, expectedParent));
+    // WHEN
+    expectAssertionError(() -> files.assertHasParent(INFO, actual, expectedParent));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveParent(actual, expectedParent));
   }
 
   @Test
   void should_pass_if_actual_has_expected_parent() {
-    files.assertHasParent(someInfo(), actual, expectedParent);
+    files.assertHasParent(INFO, actual, expectedParent);
   }
 
   @Test
   void should_pass_if_actual_has_expected_parent_when_actual_form_is_absolute() {
-    files.assertHasParent(someInfo(), actual.getAbsoluteFile(), expectedParent);
+    files.assertHasParent(INFO, actual.getAbsoluteFile(), expectedParent);
   }
 
   @Test
   void should_pass_if_actual_has_expected_parent_when_actual_form_is_canonical() throws Exception {
-    files.assertHasParent(someInfo(), actual.getCanonicalFile(), expectedParent);
+    files.assertHasParent(INFO, actual.getCanonicalFile(), expectedParent);
   }
 
   @Test
   void should_throw_exception_when_canonical_form_representation_fail() throws Exception {
+    // GIVEN
     File actual = mock(File.class);
-    File expectedParent = mock(File.class);
-
-    when(actual.getParentFile()).thenReturn(expectedParent);
-    when(expectedParent.getCanonicalFile()).thenThrow(new IOException());
-
-    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> files.assertHasParent(someInfo(), actual,
-                                                                                                 expectedParent));
+    File actualParent = mock(File.class);
+    when(actual.getParentFile()).thenReturn(actualParent);
+    when(actualParent.getCanonicalFile()).thenThrow(new IOException());
+    // WHEN
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertHasParent(INFO, actual, actualParent),
+                                                     UncheckedIOException.class);
+    // THEN
+    then(uioe).hasMessageStartingWith("Unable to get canonical form of");
   }
 
   @Test
   void should_throw_exception_when_canonical_form_representation_fail_for_expected_parent() throws Exception {
     File expectedParent = mock(File.class);
     when(expectedParent.getCanonicalFile()).thenThrow(new IOException());
-
-    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> files.assertHasParent(someInfo(), actual,
-                                                                                                 expectedParent));
+    // WHEN
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertHasParent(INFO, actual, expectedParent),
+                                                     UncheckedIOException.class);
+    // THEN
+    then(uioe).hasMessageStartingWith("Unable to get canonical form of");
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasSameBinaryContentAs_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasSameBinaryContentAs_Test.java
index a3f675be5..269adef2b 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertHasSameBinaryContentAs_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasSameBinaryContentAs_Test.java
@@ -13,27 +13,26 @@
 package org.assertj.core.internal.files;
 
 import static java.nio.file.Files.readAllBytes;
+import static org.apache.commons.io.FileUtils.writeByteArrayToFile;
 import static org.assertj.core.api.Assertions.catchThrowableOfType;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
-import static org.assertj.core.internal.BinaryDiffResult.noDiff;
-import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 import java.io.IOException;
 import java.io.UncheckedIOException;
 
+import org.assertj.core.internal.BinaryDiff;
 import org.assertj.core.internal.BinaryDiffResult;
 import org.assertj.core.internal.FilesBaseTest;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
-
 class Files_assertHasSameBinaryContentAs_Test extends FilesBaseTest {
 
   private static File actual;
@@ -51,17 +50,21 @@ class Files_assertHasSameBinaryContentAs_Test extends FilesBaseTest {
   @Test
   void should_pass_if_file_has_expected_binary_content() throws IOException {
     // GIVEN
-    given(binaryDiff.diff(actual, expectedBytes)).willReturn(noDiff());
-    // WHEN/THEN
-    files.assertSameBinaryContentAs(someInfo(), actual, expected);
+    byte[] data = "some content".getBytes();
+    File actual = newFile(tempDir.getAbsolutePath() + "/actual.txt");
+    writeByteArrayToFile(actual, data);
+    File expected = newFile(tempDir.getAbsolutePath() + "/expected.txt");
+    writeByteArrayToFile(expected, data);
+    // THEN
+    unMockedFiles.assertSameBinaryContentAs(INFO, actual, expected);
   }
 
   @Test
   void should_throw_error_if_expected_is_null() {
     // GIVEN
-    File nullExpected = null;
+    File expected = null;
     // WHEN
-    NullPointerException npe = catchThrowableOfType(() -> files.assertSameBinaryContentAs(someInfo(), actual, nullExpected),
+    NullPointerException npe = catchThrowableOfType(() -> files.assertSameBinaryContentAs(INFO, actual, expected),
                                                     NullPointerException.class);
     // THEN
     then(npe).hasMessage("The file to compare to should not be null");
@@ -70,9 +73,9 @@ class Files_assertHasSameBinaryContentAs_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_is_null() {
     // GIVEN
-    File file = null;
+    File actual = null;
     // WHEN
-    AssertionError error = expectAssertionError(() -> files.assertSameBinaryContentAs(someInfo(), file, expected));
+    AssertionError error = expectAssertionError(() -> files.assertSameBinaryContentAs(INFO, actual, expected));
     // THEN
     then(error).hasMessage(actualIsNull());
   }
@@ -82,7 +85,7 @@ class Files_assertHasSameBinaryContentAs_Test extends FilesBaseTest {
     // GIVEN
     File notAFile = new File("xyz");
     // WHEN
-    AssertionError error = expectAssertionError(() -> files.assertSameBinaryContentAs(someInfo(), notAFile, expected));
+    AssertionError error = expectAssertionError(() -> files.assertSameBinaryContentAs(INFO, notAFile, expected));
     // THEN
     then(error).hasMessage(shouldBeFile(notAFile).create());
   }
@@ -92,7 +95,7 @@ class Files_assertHasSameBinaryContentAs_Test extends FilesBaseTest {
     // GIVEN
     File notAFile = new File("xyz");
     // WHEN
-    IllegalArgumentException iae = catchThrowableOfType(() -> files.assertSameBinaryContentAs(someInfo(), actual, notAFile),
+    IllegalArgumentException iae = catchThrowableOfType(() -> files.assertSameBinaryContentAs(INFO, actual, notAFile),
                                                         IllegalArgumentException.class);
     // THEN
     then(iae).hasMessage("Expected file:<'%s'> should be an existing file", notAFile);
@@ -104,7 +107,7 @@ class Files_assertHasSameBinaryContentAs_Test extends FilesBaseTest {
     IOException cause = new IOException();
     given(binaryDiff.diff(actual, expectedBytes)).willThrow(cause);
     // WHEN
-    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertSameBinaryContentAs(someInfo(), actual, expected),
+    UncheckedIOException uioe = catchThrowableOfType(() -> files.assertSameBinaryContentAs(INFO, actual, expected),
                                                      UncheckedIOException.class);
     // THEN
     then(uioe).hasCause(cause);
@@ -113,11 +116,11 @@ class Files_assertHasSameBinaryContentAs_Test extends FilesBaseTest {
   @Test
   void should_fail_if_file_does_not_have_expected_binary_content() throws IOException {
     // GIVEN
-    BinaryDiffResult diff = new BinaryDiffResult(15, (byte) 0xCA, (byte) 0xFE);
-    when(binaryDiff.diff(actual, expectedBytes)).thenReturn(diff);
+    BinaryDiff binaryDiff = new BinaryDiff();
+    BinaryDiffResult diff = binaryDiff.diff(actual, expectedBytes);
     // WHEN
-    expectAssertionError(() -> files.assertSameBinaryContentAs(someInfo(), actual, expected));
+    expectAssertionError(() -> unMockedFiles.assertSameBinaryContentAs(INFO, actual, expected));
     // THEN
-    verify(failures).failure(someInfo(), shouldHaveBinaryContent(actual, diff));
+    verify(unMockedFailures).failure(INFO, shouldHaveBinaryContent(actual, diff));
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsAbsolute_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsAbsolute_Test.java
index c8061bc27..5cc1b372e 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsAbsolute_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsAbsolute_Test.java
@@ -12,15 +12,11 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeAbsolutePath.shouldBeAbsolutePath;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 
@@ -39,24 +35,27 @@ class Files_assertIsAbsolute_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertIsAbsolute(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertIsAbsolute(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_absolute_path() {
-    when(actual.isAbsolute()).thenReturn(false);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertIsAbsolute(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeAbsolutePath(actual));
+    // GIVEN
+    File actual = new File("xyz");
+    // WHEN
+    expectAssertionError(() -> files.assertIsAbsolute(INFO, actual));
+    // THEN
+    verify(failures).failure(INFO, shouldBeAbsolutePath(actual));
   }
 
   @Test
   void should_pass_if_actual_is_absolute_path() {
-    when(actual.isAbsolute()).thenReturn(true);
-    files.assertIsAbsolute(someInfo(), actual);
+    File actual = new File(tempDir.getAbsolutePath() + "/file.txt");
+    files.assertIsAbsolute(INFO, actual);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_Predicate_Test.java
index c96a9a3dc..f0b3a62e7 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_Predicate_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_Predicate_Test.java
@@ -13,16 +13,19 @@
 package org.assertj.core.internal.files;
 
 import static java.util.Collections.emptyList;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldContain.directoryShouldContain;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.assertj.core.util.Lists.list;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
@@ -47,38 +50,34 @@ class Files_assertIsDirectoryContaining_Predicate_Test extends FilesBaseTest {
   @Test
   void should_pass_if_actual_contains_a_file_matching_the_given_predicate() {
     // GIVEN
-    File file = mockRegularFile("Test.java");
-    List<File> items = list(file);
-    // WHEN
-    File actual = mockDirectory(items, "root");
-    // THEN
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.java");
+
+    // WHEN/THEN
     files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE);
   }
 
   @Test
   void should_pass_if_all_actual_files_match_the_given_predicate() {
     // GIVEN
-    File file1 = mockRegularFile("Test.java");
-    File file2 = mockRegularFile("Utils.java");
-    List<File> items = list(file1, file2);
-    // WHEN
-    File actual = mockDirectory(items, "root");
-    // THEN
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.java");
+    newFile(actual.getAbsolutePath() + "/Utils.java");
+
+    // WHEN/THEN
     files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE);
   }
 
   @Test
   void should_pass_if_actual_contains_at_least_one_file_matching_the_given_predicate() {
     // GIVEN
-    File file1 = mockRegularFile("Test.class");
-    File file2 = mockRegularFile("Test.java");
-    File file3 = mockRegularFile("Utils.class");
-    File file4 = mockRegularFile("Utils.java");
-    File file5 = mockRegularFile("application.yml");
-    List<File> items = list(file1, file2, file3, file4, file5);
-    // WHEN
-    File actual = mockDirectory(items, "root");
-    // THEN
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.java");
+    newFile(actual.getAbsolutePath() + "/Test.class");
+    newFile(actual.getAbsolutePath() + "/Utils.class");
+    newFile(actual.getAbsolutePath() + "/Utils.java");
+    newFile(actual.getAbsolutePath() + "/application.yml");
+    // WHEN/THEN
     files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE);
   }
 
@@ -98,13 +97,13 @@ class Files_assertIsDirectoryContaining_Predicate_Test extends FilesBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    assertThat(error).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
+    File actual = new File("xyz");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE));
     // THEN
@@ -114,32 +113,33 @@ class Files_assertIsDirectoryContaining_Predicate_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_a_directory() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isDirectory()).willReturn(false);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE));
     // THEN
     verify(failures).failure(INFO, shouldBeDirectory(actual));
   }
 
+  // use mock as it's hard to simulate listFiles(FileFilter.class) to return null
   @Test
-  void should_throw_error_on_null_directory_listing() {
+  void should_throw_error_on_null_listing() {
     // GIVEN
+    File actual = mock(File.class);
     given(actual.exists()).willReturn(true);
     given(actual.isDirectory()).willReturn(true);
     given(actual.listFiles(any(FileFilter.class))).willReturn(null);
+    mockPathMatcher(actual);
     // WHEN
     Throwable error = catchThrowable(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    assertThat(error).isInstanceOf(NullPointerException.class)
-                     .hasMessage("Directory listing should not be null");
+    then(error).isInstanceOf(NullPointerException.class)
+               .hasMessage("Directory listing should not be null");
   }
 
   @Test
   void should_fail_if_actual_is_empty() {
     // GIVEN
-    List<File> items = emptyList();
-    File actual = mockDirectory(items, "root");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE));
     // THEN
@@ -149,9 +149,9 @@ class Files_assertIsDirectoryContaining_Predicate_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_does_not_contain_any_files_matching_the_given_predicate() {
     // GIVEN
-    File file = mockRegularFile("root", "Test.class");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file = newFile(actual.getAbsolutePath() + "/Test.class");
     List<File> items = list(file);
-    File actual = mockDirectory(items, "root");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE));
     // THEN
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
index 590e25302..a85988273 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.java
@@ -14,28 +14,24 @@ package org.assertj.core.internal.files;
 
 import static java.lang.String.format;
 import static java.util.Collections.emptyList;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldContain.directoryShouldContain;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.assertj.core.util.Lists.list;
 import static org.mockito.ArgumentMatchers.any;
-import static org.mockito.ArgumentMatchers.anyString;
 import static org.mockito.BDDMockito.given;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
 import java.io.FileFilter;
-import java.nio.file.FileSystem;
-import java.nio.file.Path;
-import java.nio.file.PathMatcher;
 import java.util.List;
-import java.util.Optional;
-import java.util.regex.Pattern;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.Files;
@@ -55,41 +51,32 @@ class Files_assertIsDirectoryContaining_SyntaxAndPattern_Test extends FilesBaseT
   @Test
   void should_pass_if_actual_contains_a_file_matching_the_given_pathMatcherPattern() {
     // GIVEN
-    File file = mockRegularFile("Test.java");
-    List<File> items = list(file);
-    // WHEN
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
-    // THEN
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.java");
+    // WHEN/THEN
     files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN);
   }
 
   @Test
   void should_pass_if_all_actual_files_match_the_given_pathMatcherPattern() {
     // GIVEN
-    File file1 = mockRegularFile("Test.java");
-    File file2 = mockRegularFile("Utils.java");
-    List<File> items = list(file1, file2);
-    // WHEN
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
-    // THEN
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.java");
+    newFile(actual.getAbsolutePath() + "/Utils.java");
+    // WHEN/THEN
     files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN);
   }
 
   @Test
   void should_pass_if_actual_contains_some_files_matching_the_given_pathMatcherPattern() {
     // GIVEN
-    File file1 = mockRegularFile("Test.class");
-    File file2 = mockRegularFile("Test.java");
-    File file3 = mockRegularFile("Utils.class");
-    File file4 = mockRegularFile("Utils.java");
-    File file5 = mockRegularFile("application.yml");
-    List<File> items = list(file1, file2, file3, file4, file5);
-    // WHEN
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
-    // THEN
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.java");
+    newFile(actual.getAbsolutePath() + "/Test.class");
+    newFile(actual.getAbsolutePath() + "/Utils.class");
+    newFile(actual.getAbsolutePath() + "/Utils.java");
+    newFile(actual.getAbsolutePath() + "/application.yml");
+    // WHEN/THEN
     files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN);
   }
 
@@ -109,14 +96,13 @@ class Files_assertIsDirectoryContaining_SyntaxAndPattern_Test extends FilesBaseT
     // WHEN
     AssertionError error = expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
-    assertThat(error).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
-    mockPathMatcher(actual);
+    File actual = new File("xyz");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
@@ -126,18 +112,18 @@ class Files_assertIsDirectoryContaining_SyntaxAndPattern_Test extends FilesBaseT
   @Test
   void should_fail_if_actual_exists_but_is_not_a_directory() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isDirectory()).willReturn(false);
-    mockPathMatcher(actual);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
     verify(failures).failure(INFO, shouldBeDirectory(actual));
   }
 
+  // use mock as it's hard to simulate listFiles(FileFilter.class) to return null
   @Test
   void should_throw_error_on_null_listing() {
     // GIVEN
+    File actual = mock(File.class);
     given(actual.exists()).willReturn(true);
     given(actual.isDirectory()).willReturn(true);
     given(actual.listFiles(any(FileFilter.class))).willReturn(null);
@@ -145,16 +131,14 @@ class Files_assertIsDirectoryContaining_SyntaxAndPattern_Test extends FilesBaseT
     // WHEN
     Throwable error = catchThrowable(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
-    assertThat(error).isInstanceOf(NullPointerException.class)
-                     .hasMessage("Directory listing should not be null");
+    then(error).isInstanceOf(NullPointerException.class)
+               .hasMessage("Directory listing should not be null");
   }
 
   @Test
   void should_fail_if_actual_is_empty() {
     // GIVEN
-    List<File> items = emptyList();
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
@@ -164,32 +148,13 @@ class Files_assertIsDirectoryContaining_SyntaxAndPattern_Test extends FilesBaseT
   @Test
   void should_fail_if_actual_does_not_contain_any_files_matching_the_given_pathMatcherPattern() {
     // GIVEN
-    File file = mockRegularFile("root", "Test.class");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file = newFile(actual.getAbsolutePath() + "/Test.class");
     List<File> items = list(file);
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
     verify(failures).failure(INFO, directoryShouldContain(actual, items, JAVA_SOURCE_PATTERN_DESCRIPTION));
   }
 
-  static void mockPathMatcher(File actual) {
-    FileSystem fileSystem = mock(FileSystem.class);
-    given(fileSystem.getPathMatcher(anyString())).will(invocation -> {
-      String regex = invocation.getArgument(0).toString().split(":")[1];
-      Pattern pattern = Pattern.compile("^" + regex + "$", Pattern.CASE_INSENSITIVE);
-      return (PathMatcher) path -> Optional.ofNullable(path.getFileName())
-                                           .map(Path::toString)
-                                           .filter(pattern.asPredicate())
-                                           .isPresent();
-    });
-    Path path = actual.toPath();
-    if (path == null) {
-      path = mock(Path.class);
-      given(actual.toPath()).willReturn(path);
-      given(path.toFile()).willReturn(actual);
-    }
-    given(path.getFileSystem()).willReturn(fileSystem);
-  }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_Predicate_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_Predicate_Test.java
index aa0c631d4..999fdcead 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_Predicate_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_Predicate_Test.java
@@ -12,17 +12,19 @@
  */
 package org.assertj.core.internal.files;
 
-import static java.util.Collections.emptyList;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldNotContain.directoryShouldNotContain;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.assertj.core.util.Lists.list;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
@@ -47,9 +49,8 @@ class Files_assertIsDirectoryNotContaining_Predicate_Test extends FilesBaseTest
   @Test
   void should_pass_if_actual_does_not_contain_files_matching_the_given_filter() {
     // GIVEN
-    File file = mockRegularFile("root", "Test.class");
-    List<File> items = list(file);
-    File actual = mockDirectory(items, "root");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.class");
     // THEN
     files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE);
   }
@@ -57,8 +58,7 @@ class Files_assertIsDirectoryNotContaining_Predicate_Test extends FilesBaseTest
   @Test
   void should_pass_if_actual_is_empty() {
     // GIVEN
-    List<File> items = emptyList();
-    File actual = mockDirectory(items, "root");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
     // THEN
     files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE);
   }
@@ -79,13 +79,13 @@ class Files_assertIsDirectoryNotContaining_Predicate_Test extends FilesBaseTest
     // WHEN
     AssertionError error = expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    assertThat(error).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
+    File actual = new File("xyz");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
@@ -95,33 +95,35 @@ class Files_assertIsDirectoryNotContaining_Predicate_Test extends FilesBaseTest
   @Test
   void should_fail_if_actual_exists_but_is_not_directory() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isDirectory()).willReturn(false);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
     verify(failures).failure(INFO, shouldBeDirectory(actual));
   }
 
+  // use mock as it's hard to simulate listFiles(FileFilter.class) to return null
   @Test
   void should_throw_error_on_null_listing() {
     // GIVEN
+    File actual = mock(File.class);
     given(actual.exists()).willReturn(true);
     given(actual.isDirectory()).willReturn(true);
     given(actual.listFiles(any(FileFilter.class))).willReturn(null);
+    mockPathMatcher(actual);
     // WHEN
     Throwable error = catchThrowable(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    assertThat(error).isInstanceOf(NullPointerException.class)
-                     .hasMessage("Directory listing should not be null");
+    then(error).isInstanceOf(NullPointerException.class)
+               .hasMessage("Directory listing should not be null");
   }
 
   @Test
   void should_fail_if_one_actual_file_matches_the_filter() {
     // GIVEN
-    File file = mockRegularFile("Test.java");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file = newFile(actual.getAbsolutePath() + "/Test.java");
     List<File> items = list(file);
-    File actual = mockDirectory(items, "root");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
@@ -131,10 +133,10 @@ class Files_assertIsDirectoryNotContaining_Predicate_Test extends FilesBaseTest
   @Test
   void should_fail_if_all_actual_files_match_the_filter() {
     // GIVEN
-    File file1 = mockRegularFile("Test.java");
-    File file2 = mockRegularFile("Utils.java");
-    List<File> items = list(file1, file2);
-    File actual = mockDirectory(items, "root");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file1 = newFile(actual.getAbsolutePath() + "/Test.java");
+    File file2 = newFile(actual.getAbsolutePath() + "/Utils.java");
+    List<File> items = list(file2, file1);
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
@@ -144,17 +146,16 @@ class Files_assertIsDirectoryNotContaining_Predicate_Test extends FilesBaseTest
   @Test
   void should_fail_if_some_actual_files_match_the_filter() {
     // GIVEN
-    File file1 = mockRegularFile("Test.class");
-    File file2 = mockRegularFile("Test.java");
-    File file3 = mockRegularFile("Utils.class");
-    File file4 = mockRegularFile("Utils.java");
-    File file5 = mockRegularFile("application.yml");
-    List<File> items = list(file1, file2, file3, file4, file5);
-    File actual = mockDirectory(items, "root");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file1 = newFile(actual.getAbsolutePath() + "/Test.java");
+    File file2 = newFile(actual.getAbsolutePath() + "/Utils.java");
+    newFile(actual.getAbsolutePath() + "/Test.class");
+    newFile(actual.getAbsolutePath() + "/Utils.class");
+    newFile(actual.getAbsolutePath() + "/application.yml");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE));
     // THEN
-    verify(failures).failure(INFO, directoryShouldNotContain(actual, list(file2, file4), "the given filter"));
+    verify(failures).failure(INFO, directoryShouldNotContain(actual, list(file2, file1), "the given filter"));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
index 63ca001c9..06282170a 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test.java
@@ -13,19 +13,19 @@
 package org.assertj.core.internal.files;
 
 import static java.lang.String.format;
-import static java.util.Collections.emptyList;
-import static java.util.Collections.singletonList;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldNotContain.directoryShouldNotContain;
-import static org.assertj.core.internal.files.Files_assertIsDirectoryContaining_SyntaxAndPattern_Test.mockPathMatcher;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.assertj.core.util.Lists.list;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
@@ -50,10 +50,8 @@ class Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends FilesBa
   @Test
   void should_pass_if_actual_does_not_contain_files_matching_the_given_pathMatcherPattern() {
     // GIVEN
-    File file = mockRegularFile("root", "Test.class");
-    List<File> items = singletonList(file);
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.class");
     // THEN
     files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN);
   }
@@ -61,9 +59,7 @@ class Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends FilesBa
   @Test
   void should_pass_if_actual_is_empty() {
     // GIVEN
-    List<File> items = emptyList();
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
     // THEN
     files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN);
   }
@@ -84,14 +80,13 @@ class Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends FilesBa
     // WHEN
     AssertionError error = expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
-    assertThat(error).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
-    mockPathMatcher(actual);
+    File actual = new File("xyz");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
@@ -101,18 +96,18 @@ class Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends FilesBa
   @Test
   void should_fail_if_actual_exists_but_is_not_directory() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isDirectory()).willReturn(false);
-    mockPathMatcher(actual);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
     verify(failures).failure(INFO, shouldBeDirectory(actual));
   }
 
+  // use mock as it's hard to simulate listFiles(FileFilter.class) to return null
   @Test
   void should_throw_error_on_null_listing() {
     // GIVEN
+    File actual = mock(File.class);
     given(actual.exists()).willReturn(true);
     given(actual.isDirectory()).willReturn(true);
     given(actual.listFiles(any(FileFilter.class))).willReturn(null);
@@ -120,17 +115,16 @@ class Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends FilesBa
     // WHEN
     Throwable error = catchThrowable(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
-    assertThat(error).isInstanceOf(NullPointerException.class)
-                     .hasMessage("Directory listing should not be null");
+    then(error).isInstanceOf(NullPointerException.class)
+               .hasMessage("Directory listing should not be null");
   }
 
   @Test
   void should_fail_if_one_actual_file_matches_the_filter() {
     // GIVEN
-    File file = mockRegularFile("Test.java");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file = newFile(actual.getAbsolutePath() + "/Test.java");
     List<File> items = list(file);
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
@@ -140,11 +134,10 @@ class Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends FilesBa
   @Test
   void should_fail_if_all_actual_files_match_the_filter() {
     // GIVEN
-    File file1 = mockRegularFile("Test.java");
-    File file2 = mockRegularFile("Utils.java");
-    List<File> items = list(file1, file2);
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file1 = newFile(actual.getAbsolutePath() + "/Test.java");
+    File file2 = newFile(actual.getAbsolutePath() + "/Utils.java");
+    List<File> items = list(file2, file1);
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
@@ -154,19 +147,16 @@ class Files_assertIsDirectoryNotContaining_SyntaxAndPattern_Test extends FilesBa
   @Test
   void should_fail_if_some_actual_files_match_the_filter() {
     // GIVEN
-    File file1 = mockRegularFile("Test.class");
-    File file2 = mockRegularFile("Test.java");
-    File file3 = mockRegularFile("Utils.class");
-    File file4 = mockRegularFile("Utils.java");
-    File file5 = mockRegularFile("application.yml");
-    List<File> items = list(file1, file2, file3, file4, file5);
-    File actual = mockDirectory(items, "root");
-    mockPathMatcher(actual);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file1 = newFile(actual.getAbsolutePath() + "/Test.java");
+    File file2 = newFile(actual.getAbsolutePath() + "/Utils.java");
+    newFile(actual.getAbsolutePath() + "/Test.class");
+    newFile(actual.getAbsolutePath() + "/Utils.class");
+    newFile(actual.getAbsolutePath() + "/application.yml");
     // WHEN
     expectAssertionError(() -> files.assertIsDirectoryNotContaining(INFO, actual, JAVA_SOURCE_PATTERN));
     // THEN
     verify(failures).failure(INFO,
-                             directoryShouldNotContain(actual, list(file2, file4), JAVA_SOURCE_PATTERN_DESCRIPTION));
+                             directoryShouldNotContain(actual, list(file2, file1), JAVA_SOURCE_PATTERN_DESCRIPTION));
   }
-
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectory_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectory_Test.java
index c90e4502c..c2b55d8c4 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectory_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsDirectory_Test.java
@@ -12,15 +12,12 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
+import static org.assertj.core.util.Files.newFile;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 
@@ -39,24 +36,27 @@ class Files_assertIsDirectory_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertIsDirectory(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> files.assertIsDirectory(INFO, actual));
+    // THEN
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_directory() {
-    when(actual.isDirectory()).thenReturn(false);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertIsDirectory(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeDirectory(actual));
+    // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/file.txt");
+    // WHEN
+    expectAssertionError(() -> files.assertIsDirectory(INFO, actual));
+    // THEN
+    verify(failures).failure(INFO, shouldBeDirectory(actual));
   }
 
   @Test
   void should_pass_if_actual_is_directory() {
-    when(actual.isDirectory()).thenReturn(true);
-    files.assertIsDirectory(someInfo(), actual);
+    File actual = tempDir;
+    files.assertIsDirectory(INFO, actual);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsEmptyDirectory_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsEmptyDirectory_Test.java
index 3ada1928c..49ce8c4fb 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsEmptyDirectory_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsEmptyDirectory_Test.java
@@ -12,16 +12,18 @@
  */
 package org.assertj.core.internal.files;
 
-import static java.util.Collections.emptyList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldBeEmptyDirectory.shouldBeEmptyDirectory;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.assertj.core.util.Lists.list;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
@@ -39,8 +41,7 @@ class Files_assertIsEmptyDirectory_Test extends FilesBaseTest {
   @Test
   void should_pass_if_actual_is_empty() {
     // GIVEN
-    List<File> items = emptyList();
-    File actual = mockDirectory(items, "root");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
     // THEN
     files.assertIsEmptyDirectory(INFO, actual);
   }
@@ -48,9 +49,9 @@ class Files_assertIsEmptyDirectory_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_is_not_empty() {
     // GIVEN
-    File file = mockRegularFile("root", "Test.class");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    File file = newFile(actual.getAbsolutePath() + "/Test.java");
     List<File> items = list(file);
-    File actual = mockDirectory(items, "root");
     // WHEN
     expectAssertionError(() -> files.assertIsEmptyDirectory(INFO, actual));
     // THEN
@@ -64,13 +65,13 @@ class Files_assertIsEmptyDirectory_Test extends FilesBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> files.assertIsEmptyDirectory(INFO, actual));
     // THEN
-    assertThat(error).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
+    File actual = new File("xyz");
     // WHEN
     expectAssertionError(() -> files.assertIsEmptyDirectory(INFO, actual));
     // THEN
@@ -80,24 +81,24 @@ class Files_assertIsEmptyDirectory_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_a_directory() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isDirectory()).willReturn(false);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
     // WHEN
     expectAssertionError(() -> files.assertIsEmptyDirectory(INFO, actual));
     // THEN
     verify(failures).failure(INFO, shouldBeDirectory(actual));
   }
 
+  // use mock as it's hard to simulate listFiles(FileFilter.class) to return null
   @Test
   void should_throw_error_on_null_listing() {
     // GIVEN
+    File actual = mock(File.class);
     given(actual.exists()).willReturn(true);
     given(actual.isDirectory()).willReturn(true);
     given(actual.listFiles(any(FileFilter.class))).willReturn(null);
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertIsEmptyDirectory(INFO, actual));
+    Throwable error = catchThrowableOfType(() -> files.assertIsEmptyDirectory(INFO, actual), NullPointerException.class);
     // THEN
-    assertThat(error).isInstanceOf(NullPointerException.class)
-                     .hasMessage("Directory listing should not be null");
+    then(error).hasMessage("Directory listing should not be null");
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsEmptyFile_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsEmptyFile_Test.java
index 5f263d27d..c97753bf3 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsEmptyFile_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsEmptyFile_Test.java
@@ -12,34 +12,32 @@
  */
 package org.assertj.core.internal.files;
 
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.Files;
-import org.assertj.core.internal.FilesBaseTest;
-import org.junit.jupiter.api.DisplayName;
-import org.junit.jupiter.api.Test;
-
-import java.io.File;
-
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.verify;
-import static org.mockito.BDDMockito.verifyNoInteractions;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
+
+import java.io.File;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Files;
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.jupiter.api.Test;
 
 /**
  * Tests for <code>{@link Files#assertIsEmptyFile(AssertionInfo, File)}</code>
  */
-@DisplayName("Files assertIsEmptyFile")
 class Files_assertIsEmptyFile_Test extends FilesBaseTest {
 
   @Test
   void should_pass_if_actual_is_empty() {
     // GIVEN
-    given(actual.isFile()).willReturn(true);
-    given(actual.length()).willReturn(0L);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
     // WHEN
     files.assertIsEmptyFile(INFO, actual);
     // THEN
@@ -49,8 +47,7 @@ class Files_assertIsEmptyFile_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_is_not_empty() {
     // GIVEN
-    given(actual.isFile()).willReturn(true);
-    given(actual.length()).willReturn(1L);
+    File actual = new File("src/test/resources/actual_file.txt");
     // WHEN
     expectAssertionError(() -> files.assertIsEmptyFile(INFO, actual));
     // THEN
@@ -60,8 +57,7 @@ class Files_assertIsEmptyFile_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_is_a_directory() {
     // GIVEN
-    given(actual.isFile()).willReturn(false);
-    given(actual.length()).willReturn(1L);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
     // WHEN
     expectAssertionError(() -> files.assertIsEmptyFile(INFO, actual));
     // THEN
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsFile_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsFile_Test.java
index 9ace47f30..1efd8129f 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsFile_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsFile_Test.java
@@ -12,15 +12,12 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
+import static org.assertj.core.util.Files.newFile;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 
@@ -39,24 +36,29 @@ class Files_assertIsFile_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertIsFile(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> files.assertIsFile(INFO, actual));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_file() {
-    when(actual.isFile()).thenReturn(false);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertIsFile(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeFile(actual));
+    // GIVEN
+    File actual = new File("xyz");
+    // WHEN
+    expectAssertionError(() -> files.assertIsFile(INFO, actual));
+    // THEN
+    verify(failures).failure(INFO, shouldBeFile(actual));
   }
 
   @Test
   void should_pass_if_actual_is_file() {
-    when(actual.isFile()).thenReturn(true);
-    files.assertIsFile(someInfo(), actual);
+    // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
+    // THEN
+    files.assertIsFile(INFO, actual);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsNotEmptyDirectory_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsNotEmptyDirectory_Test.java
index 14c0c1a4a..7fc967239 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsNotEmptyDirectory_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsNotEmptyDirectory_Test.java
@@ -12,21 +12,22 @@
  */
 package org.assertj.core.internal.files;
 
-import static java.util.Collections.emptyList;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
 import static org.assertj.core.error.ShouldNotBeEmpty.shouldNotBeEmpty;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import java.io.File;
 import java.io.FileFilter;
-import java.util.List;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.Files;
@@ -43,9 +44,8 @@ class Files_assertIsNotEmptyDirectory_Test extends FilesBaseTest {
   @Test
   void should_pass_if_actual_is_not_empty() {
     // GIVEN
-    File file = mockRegularFile("root", "Test.class");
-    List<File> items = list(file);
-    File actual = mockDirectory(items, "root");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
+    newFile(actual.getAbsolutePath() + "/Test.java");
     // THEN
     files.assertIsNotEmptyDirectory(INFO, actual);
   }
@@ -53,7 +53,7 @@ class Files_assertIsNotEmptyDirectory_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_is_empty() {
     // GIVEN
-    File actual = mockDirectory(emptyList(), "root");
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
     // WHEN
     expectAssertionError(() -> files.assertIsNotEmptyDirectory(INFO, actual));
     // THEN
@@ -67,13 +67,13 @@ class Files_assertIsNotEmptyDirectory_Test extends FilesBaseTest {
     // WHEN
     AssertionError error = expectAssertionError(() -> files.assertIsNotEmptyDirectory(INFO, actual));
     // THEN
-    assertThat(error).hasMessage(actualIsNull());
+    then(error).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_does_not_exist() {
     // GIVEN
-    given(actual.exists()).willReturn(false);
+    File actual = new File("xyz");
     // WHEN
     expectAssertionError(() -> files.assertIsNotEmptyDirectory(INFO, actual));
     // THEN
@@ -83,24 +83,24 @@ class Files_assertIsNotEmptyDirectory_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_exists_but_is_not_directory() {
     // GIVEN
-    given(actual.exists()).willReturn(true);
-    given(actual.isDirectory()).willReturn(false);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
     // WHEN
     expectAssertionError(() -> files.assertIsNotEmptyDirectory(INFO, actual));
     // THEN
     verify(failures).failure(INFO, shouldBeDirectory(actual));
   }
 
+  // use mock as it's hard to simulate listFiles(FileFilter.class) to return null
   @Test
   void should_throw_error_on_null_listing() {
     // GIVEN
+    File actual = mock(File.class);
     given(actual.exists()).willReturn(true);
     given(actual.isDirectory()).willReturn(true);
     given(actual.listFiles(any(FileFilter.class))).willReturn(null);
     // WHEN
-    Throwable error = catchThrowable(() -> files.assertIsNotEmptyDirectory(INFO, actual));
+    Throwable error = catchThrowableOfType(() -> files.assertIsNotEmptyDirectory(INFO, actual), NullPointerException.class);
     // THEN
-    assertThat(error).isInstanceOf(NullPointerException.class)
-                     .hasMessage("Directory listing should not be null");
+    assertThat(error).hasMessage("Directory listing should not be null");
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsNotEmptyFile_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsNotEmptyFile_Test.java
index 78e2cf837..4bdcef80d 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsNotEmptyFile_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsNotEmptyFile_Test.java
@@ -12,34 +12,32 @@
  */
 package org.assertj.core.internal.files;
 
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.Files;
-import org.assertj.core.internal.FilesBaseTest;
-import org.junit.jupiter.api.DisplayName;
-import org.junit.jupiter.api.Test;
-
-import java.io.File;
-
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldNotBeEmpty.shouldNotBeEmpty;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.mockito.BDDMockito.given;
-import static org.mockito.BDDMockito.verify;
-import static org.mockito.BDDMockito.verifyNoInteractions;
+import static org.assertj.core.util.Files.newFile;
+import static org.assertj.core.util.Files.newFolder;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
+
+import java.io.File;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Files;
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.jupiter.api.Test;
 
 /**
  * Tests for <code>{@link Files#assertIsNotEmptyFile(AssertionInfo, File)}</code>
  */
-@DisplayName("Files assertIsNotEmptyFile")
 class Files_assertIsNotEmptyFile_Test extends FilesBaseTest {
 
   @Test
   void should_pass_if_actual_is_not_empty() {
     // GIVEN
-    given(actual.isFile()).willReturn(true);
-    given(actual.length()).willReturn(1L);
+    File actual = new File("src/test/resources/actual_file.txt");
     // WHEN
     files.assertIsNotEmptyFile(INFO, actual);
     // THEN
@@ -49,8 +47,7 @@ class Files_assertIsNotEmptyFile_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_is_empty() {
     // GIVEN
-    given(actual.isFile()).willReturn(true);
-    given(actual.length()).willReturn(0L);
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
     // WHEN
     expectAssertionError(() -> files.assertIsNotEmptyFile(INFO, actual));
     // THEN
@@ -60,8 +57,7 @@ class Files_assertIsNotEmptyFile_Test extends FilesBaseTest {
   @Test
   void should_fail_if_actual_is_a_directory() {
     // GIVEN
-    given(actual.isFile()).willReturn(false);
-    given(actual.length()).willReturn(1L);
+    File actual = newFolder(tempDir.getAbsolutePath() + "/folder");
     // WHEN
     expectAssertionError(() -> files.assertIsNotEmptyFile(INFO, actual));
     // THEN
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertIsRelative_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertIsRelative_Test.java
index c2d4c1be8..a2b214fff 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertIsRelative_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertIsRelative_Test.java
@@ -12,15 +12,12 @@
  */
 package org.assertj.core.internal.files;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeRelativePath.shouldBeRelativePath;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-
+import static org.assertj.core.util.Files.newFile;
 import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
 
 import java.io.File;
 
@@ -39,24 +36,29 @@ class Files_assertIsRelative_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertIsRelative(someInfo(), null))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> files.assertIsRelative(INFO, actual));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_relative_path() {
-    when(actual.isAbsolute()).thenReturn(true);
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertIsRelative(info, actual));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeRelativePath(actual));
+    // GIVEN
+    File actual = newFile(tempDir.getAbsolutePath() + "/Test.java");
+    // WHEN
+    expectAssertionError(() -> files.assertIsRelative(INFO, actual));
+    // THEN
+    verify(failures).failure(INFO, shouldBeRelativePath(actual));
   }
 
   @Test
   void should_pass_if_actual_is_relative_path() {
-    when(actual.isAbsolute()).thenReturn(false);
-    files.assertIsRelative(someInfo(), actual);
+    // GIVEN
+    File actual = new File("src/test/resources/actual_file.txt");
+    // THEN
+    files.assertIsRelative(INFO, actual);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertSameContentAs_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertSameContentAs_Test.java
index 17cbb17e0..8950ad059 100644
--- a/src/test/java/org/assertj/core/internal/files/Files_assertSameContentAs_Test.java
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertSameContentAs_Test.java
@@ -14,15 +14,13 @@ package org.assertj.core.internal.files;
 
 import static java.lang.String.format;
 import static java.nio.charset.Charset.defaultCharset;
-import static java.nio.file.Files.readAllBytes;
-import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
 import static org.assertj.core.error.ShouldHaveSameContent.shouldHaveSameContent;
-import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.mockito.Mockito.verify;
 import static org.mockito.Mockito.when;
@@ -35,11 +33,9 @@ import java.math.BigInteger;
 import java.nio.charset.StandardCharsets;
 import java.util.List;
 
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.BinaryDiffResult;
+import org.assertj.core.internal.Diff;
 import org.assertj.core.internal.FilesBaseTest;
 import org.assertj.core.util.Files;
-import org.assertj.core.util.Lists;
 import org.assertj.core.util.diff.Delta;
 import org.junit.jupiter.api.BeforeAll;
 import org.junit.jupiter.api.Test;
@@ -63,7 +59,7 @@ class Files_assertSameContentAs_Test extends FilesBaseTest {
 
   @Test
   void should_throw_error_if_expected_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> files.assertSameContentAs(someInfo(), actual, defaultCharset(),
+    assertThatNullPointerException().isThrownBy(() -> files.assertSameContentAs(INFO, actual, defaultCharset(),
                                                                                 null, defaultCharset()))
                                     .withMessage("The file to compare to should not be null");
   }
@@ -72,31 +68,35 @@ class Files_assertSameContentAs_Test extends FilesBaseTest {
   void should_throw_error_if_expected_is_not_file() {
     assertThatIllegalArgumentException().isThrownBy(() -> {
       File notAFile = new File("xyz");
-      files.assertSameContentAs(someInfo(), actual, defaultCharset(), notAFile, defaultCharset());
+      files.assertSameContentAs(INFO, actual, defaultCharset(), notAFile, defaultCharset());
     }).withMessage("Expected file:<'xyz'> should be an existing file");
   }
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> files.assertSameContentAs(someInfo(), null, defaultCharset(),
-                                                                                               expected, defaultCharset()))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    File actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> files.assertSameContentAs(INFO, actual, defaultCharset(),
+                                                                                         expected, defaultCharset()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_actual_is_not_file() {
-    AssertionInfo info = someInfo();
-    File notAFile = new File("xyz");
-
-    Throwable error = catchThrowable(() -> files.assertSameContentAs(info, notAFile, defaultCharset(), expected, defaultCharset()));
+    // GIVEN
 
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldBeFile(notAFile));
+    File notAFile = new File("xyz");
+    // WHEN
+    expectAssertionError(() -> files.assertSameContentAs(INFO, notAFile, defaultCharset(), expected, defaultCharset()));
+    // THEN
+    verify(failures).failure(INFO, shouldBeFile(notAFile));
   }
 
   @Test
   void should_pass_if_files_have_equal_content() {
-    unMockedFiles.assertSameContentAs(someInfo(),
+    unMockedFiles.assertSameContentAs(INFO,
                                       actual, defaultCharset(),
                                       actual, defaultCharset());
   }
@@ -106,7 +106,7 @@ class Files_assertSameContentAs_Test extends FilesBaseTest {
     IOException cause = new IOException();
     when(diff.diff(actual, defaultCharset(), expected, defaultCharset())).thenThrow(cause);
 
-    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> files.assertSameContentAs(someInfo(), actual,
+    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> files.assertSameContentAs(INFO, actual,
                                                                                                      defaultCharset(),
                                                                                                      expected,
                                                                                                      defaultCharset()))
@@ -115,20 +115,19 @@ class Files_assertSameContentAs_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_files_do_not_have_equal_content() throws IOException {
-    List<Delta<String>> diffs = Lists.newArrayList(delta);
-    when(diff.diff(actual, defaultCharset(), expected, defaultCharset())).thenReturn(diffs);
-    when(binaryDiff.diff(actual, readAllBytes(expected.toPath()))).thenReturn(new BinaryDiffResult(1, -1, -1));
-    AssertionInfo info = someInfo();
-
-    Throwable error = catchThrowable(() -> files.assertSameContentAs(info, actual, defaultCharset(), expected, defaultCharset()));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldHaveSameContent(actual, expected, diffs));
+    // GIVEN
+    Diff diff = new Diff();
+    List<Delta<String>> diffs = diff.diff(actual, defaultCharset(), expected, defaultCharset());
+
+    // WHEN
+    expectAssertionError(() -> unMockedFiles.assertSameContentAs(INFO, actual, defaultCharset(), expected, defaultCharset()));
+    // THEN
+    verify(unMockedFailures).failure(INFO, shouldHaveSameContent(actual, expected, diffs));
   }
 
   @Test
   void should_throw_an_error_if_files_cant_be_compared_with_the_given_charsets_even_if_binary_identical() {
-    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> unMockedFiles.assertSameContentAs(someInfo(),
+    assertThatExceptionOfType(UncheckedIOException.class).isThrownBy(() -> unMockedFiles.assertSameContentAs(INFO,
                                                                                                              createFileWithNonUTF8Character(),
                                                                                                              StandardCharsets.UTF_8,
                                                                                                              createFileWithNonUTF8Character(),
@@ -138,7 +137,7 @@ class Files_assertSameContentAs_Test extends FilesBaseTest {
 
   @Test
   void should_fail_if_files_are_not_binary_identical() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> unMockedFiles.assertSameContentAs(someInfo(),
+    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> unMockedFiles.assertSameContentAs(INFO,
                                                                                                        createFileWithNonUTF8Character(),
                                                                                                        StandardCharsets.UTF_8,
                                                                                                        expected,
