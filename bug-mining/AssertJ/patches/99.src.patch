diff --git a/pom.xml b/pom.xml
index 5006a657a..0622d8e00 100644
--- a/pom.xml
+++ b/pom.xml
@@ -47,6 +47,22 @@
       <version>2.2.2</version>
       <optional>true</optional>
     </dependency>
+    <!--
+      NEEDED! Unlike File, a Path is not linked to the JRE's filesystem.
+
+      In order to accurately test assertions, we need a decent JSR 203 implementation
+      which lets us test our assertions. Right now, this is memoryfilesystem
+      (https://github.com/marschall/memoryfilesystem).
+
+      Another choice would be jimfs from Google (https://github.com/google/jimfs),
+      but its support for reading/writing file attributes is not as complete as that
+      of memoryfilesystem's.
+    -->
+    <dependency>
+      <groupId>com.github.marschall</groupId>
+      <artifactId>memoryfilesystem</artifactId>
+      <version>0.6.3</version>
+    </dependency>
   </dependencies>
   <build>
     <plugins>
diff --git a/src/main/java/org/assertj/core/api/AbstractFileAssert.java b/src/main/java/org/assertj/core/api/AbstractFileAssert.java
index 30aa4f0d8..8520b7877 100644
--- a/src/main/java/org/assertj/core/api/AbstractFileAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractFileAssert.java
@@ -190,7 +190,7 @@ public abstract class AbstractFileAssert<S extends AbstractFileAssert<S>> extend
    * @throws AssertionError if the actual {@code File} is {@code null}.
    * @throws AssertionError if the actual {@code File} is not an existing file.
    * @throws FilesException if an I/O error occurs.
-   * @throws AssertionError if the content of the actual {@code File} is not equal to the given binary content.
+   * @throws AssertionError if the content of the actual {@code File} is not equal to the given content.
    */
   public S hasContent(String expected) {
     files.assertHasContent(info, actual, expected, charset);
diff --git a/src/main/java/org/assertj/core/api/AbstractPathAssert.java b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
new file mode 100644
index 000000000..14293f242
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
@@ -0,0 +1,1267 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.lang.String.format;
+
+import java.nio.charset.Charset;
+import java.nio.file.ClosedFileSystemException;
+import java.nio.file.FileSystem;
+import java.nio.file.FileSystems;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
+import java.nio.file.ProviderMismatchException;
+import java.nio.file.spi.FileSystemProvider;
+
+import org.assertj.core.internal.Paths;
+import org.assertj.core.util.FilesException;
+import org.assertj.core.util.PathsException;
+import org.assertj.core.util.VisibleForTesting;
+
+/**
+ * Assertions for {@link Path} objects
+ *
+ * <p>
+ * Note that some assertions have two versions: a normal one and a "raw" one (for instance, {@code hasParent()} and
+ * {@code hasParentRaw()}. The difference is that normal assertions will {@link Path#toRealPath(LinkOption...)
+ * canonicalize} or {@link Path#normalize() normalize} the tested path and, where applicable, the path argument, before
+ * performing the actual test. Canonicalization includes normalization.
+ * </p>
+ *
+ * <p>
+ * Canonicalization may lead to an I/O error if a path does not exist, in which case the given assertions will fail with
+ * a {@link PathsException}. Also note that {@link Files#isSymbolicLink(Path) symbolic links} will be followed if the
+ * filesystem supports them. Finally, if a path is not {@link Path#isAbsolute()} absolute}, canonicalization will
+ * resolve the path against the process' current working directory.
+ * </p>
+ *
+ * <p>
+ * These assertions are filesystem independent. You may use them on {@code Path} instances issued from the default
+ * filesystem (ie, instances you get when using {@link java.nio.file.Paths#get(String, String...)}) or from other
+ * filesystems. For more information, see the {@link FileSystem javadoc for {@code FileSystem} .
+ * </p>
+ *
+ * <p>
+ * Furthermore:
+ * </p>
+ *
+ * <ul>
+ * <li>Unless otherwise noted, assertions which accept arguments will not accept {@code null} arguments; if a null
+ * argument is passed, these assertions will throw a {@link NullPointerException}.</li>
+ * <li>It is the caller's responsibility to ensure that paths used in assertions are issued from valid filesystems which
+ * are not {@link FileSystem#close() closed}. If a filesystems is closed, assertions will throw a
+ * {@link ClosedFileSystemException}.</li>
+ * <li>Some assertions take another {@link Path} as an argument. If this path is not issued from the same
+ * {@link FileSystemProvider provider} as the tested path, assertions will throw a {@link ProviderMismatchException}.</li>
+ * <li>Some assertions may need to perform I/O on the path's underlying filesystem; if an I/O error occurs when
+ * accessing the filesystem, these assertions will throw a {@link PathsException}.</li>
+ * </ul>
+ *
+ * @param <S> self type
+ *
+ * @see Path
+ * @see java.nio.file.Paths#get(String, String...)
+ * @see FileSystem
+ * @see FileSystem#getPath(String, String...)
+ * @see FileSystems#getDefault()
+ * @see Files
+ */
+public abstract class AbstractPathAssert<S extends AbstractPathAssert<S>> extends AbstractAssert<S, Path> {
+
+  @VisibleForTesting
+  protected Paths paths = Paths.instance();
+
+  @VisibleForTesting
+  Charset charset = Charset.defaultCharset();
+
+  protected AbstractPathAssert(final Path actual, final Class<?> selfType) {
+	super(actual, selfType);
+  }
+
+  /**
+   * Verifies that the content of the actual {@code Path} is the same as the given one (both paths must be a readable
+   * files). The default charset is used to read each files.
+   * 
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // use the default charset 
+   * Path xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes());
+   * Path xFileClone = Files.write(Paths.get("xfile-clone.txt"), "The Truth Is Out There".getBytes());
+   * Path xFileFrench = Files.write(Paths.get("xfile-french.txt"), "La Vérité Est Ailleurs".getBytes());
+   * 
+   * // The following assertion succeeds (default charset is used):
+   * assertThat(xFile).hasSameContentAs(xFileClone);
+   * 
+   * // The following assertion fails:
+   * assertThat(xFile).hasSameContentAs(xFileFrench);
+   * </code></pre>
+   * 
+   * @param expected the given {@code Path} to compare the actual {@code Path} to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given {@code Path} is {@code null}.
+   * @throws AssertionError if the actual or given {@code Path} is not an existing readable file.
+   * @throws AssertionError if the actual {@code Path} is {@code null}.
+   * @throws AssertionError if the content of the actual {@code Path} is not equal to the content of the given one.
+   * @throws PathsException if an I/O error occurs.
+   */
+  public S hasSameContentAs(Path expected) {
+	paths.assertHasSameContentAs(info, actual, expected);
+	return myself;
+  }
+
+  /**
+   * Verifies that the binary content of the actual {@code Path} is <b>exactly</b> equal to the given one.
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // using the default charset, the following assertion succeeds:
+   * Path xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes());
+   * assertThat(xFile).hasBinaryContent("The Truth Is Out There".getBytes());
+   *
+   * // using a specific charset 
+   * Charset turkishCharset = Charset.forName("windows-1254");
+   * Path xFileTurkish = Files.write(Paths.get("xfile.turk"), Collections.singleton("Gerçek Başka bir yerde mi"), turkishCharset);
+   * 
+   * // The following assertion succeeds:
+   * String expectedContent = "Gerçek Başka bir yerde mi" + System.lineSeparator();
+   * byte[] binaryContent = expectedContent.getBytes(turkishCharset.name());
+   * assertThat(xFileTurkish).hasBinaryContent(binaryContent);
+   * 
+   * // The following assertion fails ... unless you are in Turkey ;-):
+   * assertThat(xFileTurkish).hasBinaryContent("Gerçek Başka bir yerde mi".getBytes());
+   * </code></pre>
+   * 
+   * @param expected the expected binary content to compare the actual {@code File}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given content is {@code null}.
+   * @throws AssertionError if the actual {@code File} is {@code null}.
+   * @throws AssertionError if the actual {@code File} is not an existing file.
+   * @throws FilesException if an I/O error occurs.
+   * @throws AssertionError if the content of the actual {@code File} is not equal to the given binary content.
+   */
+  public S hasBinaryContent(byte[] expected) {
+	paths.assertHasBinaryContent(info, actual, expected);
+	return myself;
+  }
+
+  /**
+   * Specifies the name of the charset to use for text-based assertions on the path's contents (path must be a readable
+   * file).
+   * 
+   * <p>
+   * Examples:
+   * </p>
+   * 
+   * <pre><code class="java">
+   * Charset turkishCharset = Charset.forName("windows-1254");
+   * Path xFileTurkish = Files.write(Paths.get("xfile.turk"), Collections.singleton("Gerçek Başka bir yerde mi"), turkishCharset);
+   * 
+   * // The following assertion succeeds:
+   * assertThat(xFileTurkish).usingCharset("windows-1254").hasContent("Gerçek Başka bir yerde mi");
+   * </code></pre>
+   * 
+   * @param charsetName the name of the charset to use.
+   * @return {@code this} assertion object.
+   * @throws IllegalArgumentException if the given encoding is not supported on this platform.
+   */
+  public S usingCharset(String charsetName) {
+	if (!Charset.isSupported(charsetName))
+	  throw new IllegalArgumentException(format("Charset:<'%s'> is not supported on this system", charsetName));
+	return usingCharset(Charset.forName(charsetName));
+  }
+
+  /**
+   * Specifies the charset to use for text-based assertions on the path's contents (path must be a readable file).
+   * 
+   * <p>
+   * Examples:
+   * </p>
+   * 
+   * <pre><code class="java">
+   * Charset turkishCharset = Charset.forName("windows-1254");
+   * Path xFileTurkish = Files.write(Paths.get("xfile.turk"), Collections.singleton("Gerçek Başka bir yerde mi"), turkishCharset);
+   * 
+   * // The following assertion succeeds:
+   * assertThat(xFileTurkish).usingCharset(turkishCharset).hasContent("Gerçek Başka bir yerde mi");
+   * </code></pre>
+   * 
+   * @param charset the charset to use.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given charset is {@code null}.
+   */
+  public S usingCharset(Charset charset) {
+	if (charset == null) throw new NullPointerException("The charset should not be null");
+	this.charset = charset;
+	return myself;
+  }
+
+  /**
+   * Verifies that the text content of the actual {@code Path} (which must be a readable file) is <b>exactly</b> equal
+   * to the given one.<br/>
+   * The charset to use when reading the file should be provided with {@link #usingCharset(Charset)} or
+   * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
+   * {@link Charset#defaultCharset()}) will be used.
+   * 
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // use the default charset 
+   * Path xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes());
+   * 
+   * // The following assertion succeeds (default charset is used):
+   * assertThat(xFile).hasContent("The Truth Is Out There");
+   * 
+   * // The following assertion fails:
+   * assertThat(xFile).hasContent("La Vérité Est Ailleurs");
+   * 
+   * // using a specific charset 
+   * Charset turkishCharset = Charset.forName("windows-1254");
+   * 
+   * Path xFileTurkish = Files.write(Paths.get("xfile.turk"), Collections.singleton("Gerçek Başka bir yerde mi"), turkishCharset);
+   * 
+   * // The following assertion succeeds:
+   * assertThat(xFileTurkish).usingCharset(turkishCharset).hasContent("Gerçek Başka bir yerde mi");
+   * 
+   * // The following assertion fails ... unless you are in Turkey ;-):
+   * assertThat(xFileTurkish).hasContent("Gerçek Başka bir yerde mi");
+   * </code></pre>
+   *
+   * @param expected the expected text content to compare the actual {@code File}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given content is {@code null}.
+   * @throws FilesException if an I/O error occurs.
+   * @throws AssertionError if the actual {@code Path} is {@code null}.
+   * @throws AssertionError if the actual {@code Path} is not a {@link Files#isReadable(Path) readable} file.
+   * @throws AssertionError if the content of the actual {@code File} is not equal to the given content.
+   */
+  public S hasContent(String expected) {
+	paths.assertHasContent(info, actual, expected, charset);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is a readable file, it checks that the file exists (according to
+   * {@link Files#exists(Path, LinkOption...)}) and that it is readable(according to {@link Files#isReadable(Path)}).
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // Create a file and set permissions to be readable by all.
+   * Path readableFile = Paths.get("readableFile");
+   * Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("r--r--r--");
+   * Files.createFile(readableFile, PosixFilePermissions.asFileAttribute(perms));
+   * 
+   * final Path symlinkToReadableFile = FileSystems.getDefault().getPath("symlinkToReadableFile");
+   * Files.createSymbolicLink(symlinkToReadableFile, readableFile);
+   * 
+   * // Create a file and set permissions not to be readable.
+   * Path nonReadableFile = Paths.get("nonReadableFile");
+   * Set&lt;PosixFilePermission&gt; notReadablePerms = PosixFilePermissions.fromString("-wx------");
+   * Files.createFile(nonReadableFile, PosixFilePermissions.asFileAttribute(notReadablePerms));
+   * 
+   * final Path nonExistentPath = FileSystems.getDefault().getPath("nonexistent");
+   *
+   * // The following assertions succeed:
+   * assertThat(readableFile).isReadable();
+   * assertThat(symlinkToReadableFile).isReadable();
+   *
+   * // The following assertions fail:
+   * assertThat(nonReadableFile).isReadable();
+   * assertThat(nonExistentPath).isReadable();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Files#isReadable(Path)
+   */
+  public S isReadable() {
+	paths.assertIsReadable(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is a writable file, it checks that the file exists (according to
+   * {@link Files#exists(Path, LinkOption...)}) and that it is writable(according to {@link Files#isWritable(Path)}).
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // Create a file and set permissions to be writable by all.
+   * Path writableFile = Paths.get("writableFile");
+   * Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("rw-rw-rw-");
+   * Files.createFile(writableFile, PosixFilePermissions.asFileAttribute(perms));
+   * 
+   * final Path symlinkToWritableFile = FileSystems.getDefault().getPath("symlinkToWritableFile");
+   * Files.createSymbolicLink(symlinkToWritableFile, writableFile);
+   * 
+   * // Create a file and set permissions not to be writable.
+   * Path nonWritableFile = Paths.get("nonWritableFile");
+   * perms = PosixFilePermissions.fromString("r--r--r--");
+   * Files.createFile(nonWritableFile, PosixFilePermissions.asFileAttribute(perms));
+   * 
+   * final Path nonExistentPath = FileSystems.getDefault().getPath("nonexistent");
+   *
+   * // The following assertions succeed:
+   * assertThat(writableFile).isWritable();
+   * assertThat(symlinkToWritableFile).isWritable();
+   *
+   * // The following assertions fail:
+   * assertThat(nonWritableFile).isWritable();
+   * assertThat(nonExistentPath).isWritable();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Files#isWritable(Path)
+   */
+  public S isWritable() {
+	paths.assertIsWritable(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is a executable file, it checks that the file exists (according to
+   * {@link Files#exists(Path, LinkOption...)}) and that it is executable(according to {@link Files#isExecutable(Path)}
+   * ).
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // Create a file and set permissions to be executable by all.
+   * Path executableFile = Paths.get("executableFile");
+   * Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("r-xr-xr-x");
+   * Files.createFile(executableFile, PosixFilePermissions.asFileAttribute(perms));
+   * 
+   * final Path symlinkToExecutableFile = FileSystems.getDefault().getPath("symlinkToExecutableFile");
+   * Files.createSymbolicLink(symlinkToExecutableFile, executableFile);
+   * 
+   * // Create a file and set permissions not to be executable.
+   * Path nonExecutableFile = Paths.get("nonExecutableFile");
+   * perms = PosixFilePermissions.fromString("rw-------");
+   * Files.createFile(nonExecutableFile, PosixFilePermissions.asFileAttribute(perms));
+   * 
+   * final Path nonExistentPath = FileSystems.getDefault().getPath("nonexistent");
+   *
+   * // The following assertions succeed:
+   * assertThat(executableFile).isExecutable();
+   * assertThat(symlinkToExecutableFile).isExecutable();
+   *
+   * // The following assertions fail:
+   * assertThat(nonExecutableFile).isExecutable();
+   * assertThat(nonExistentPath).isExecutable();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Files#isExecutable(Path)
+   */
+  public S isExecutable() {
+	paths.assertIsExecutable(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} exists according to {@link Files#exists(Path, LinkOption...)
+   * Files#exists(Path)})
+   *
+   * <p>
+   * <strong>Note that this assertion will follow symbolic links before asserting the path's existence.</strong>
+   * </p>
+   *
+   * <p>
+   * On Windows system, this has no influence. On Unix systems, this means the assertion result will fail if the path is
+   * a symbolic link whose target does not exist. If you want to assert the existence of the symbolic link itself, use
+   * {@link #existsNoFollowLinks()} instead.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * // Create a regular file, and a symbolic link pointing to it
+   * final Path existingFile = fs.getPath("somefile");
+   * Files.createFile(existingFile);
+   * final Path symlinkToExistingFile = fs.getPath("symlinkToExistingFile");
+   * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
+   *
+   * // Create a symbolic link whose target does not exist
+   * final Path nonExistentPath = fs.getPath("nonexistent");
+   * final Path symlinkToNonExistentPath = fs.getPath("symlinkToNonExistentPath");
+   * Files.createSymbolicLink(symlinkToNonExistentPath, nonExistentPath);
+   *
+   * // The following assertions succeed:
+   * assertThat(existingFile).exists();
+   * assertThat(symlinkToExistingFile).exists();
+   *
+   * // The following assertions fail:
+   * assertThat(nonExistentPath).exists();
+   * assertThat(symlinkToNonExistentPath).exists();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Files#exists(Path, LinkOption...)
+   */
+  public S exists() {
+	paths.assertExists(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} exists, not following symbolic links, by calling
+   * {@link Files#exists(Path, LinkOption...) Files#exists(Path, LinkOption.NOFOLLOW_LINKS)}).
+   *
+   * <p>
+   * This assertion behaves like {@link #exists()}, with the difference that it can be used to assert the existence of a
+   * symbolic link even if its target is invalid.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * // Create a regular file, and a symbolic link pointing to it
+   * final Path existingFile = fs.getPath("somefile");
+   * Files.createFile(existingFile);
+   * final Path symlinkToExistingFile = fs.getPath("symlink");
+   * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
+   * 
+   * // Create a symbolic link whose target does not exist
+   * final Path nonExistentPath = fs.getPath("nonexistent");
+   * final Path symlinkToNonExistentPath = fs.getPath("symlinkToNonExistentPath");
+   * Files.createSymbolicLink(symlinkToNonExistentPath, nonExistentPath);
+   *
+   * // The following assertions succeed
+   * assertThat(existingFile).existsNoFollowLinks();
+   * assertThat(symlinkToExistingFile).existsNoFollowLinks();
+   * assertThat(symlinkToNonExistentPath).existsNoFollowLinks();
+   *
+   * // The following assertion fails
+   * assertThat(nonExistentPath).existsNoFollowLinks();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Files#exists(Path, LinkOption...)
+   */
+  public S existsNoFollowLinks() {
+	paths.assertExistsNoFollowLinks(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} does not exist.
+   *
+   * <p>
+   * <strong>IMPORTANT NOTE:</strong> this method will NOT follow symbolic links (provided that the underlying
+   * {@link FileSystem} of this path supports symbolic links at all).
+   * </p>
+   *
+   * <p>
+   * This means that even if the link exists this assertion will fail even if the link's target does not exists - note
+   * that this is unlike the default behavior of {@link #exists()}.
+   * </p>
+   *
+   * <p>
+   * If you are a Windows user, the above does not apply to you; if you are a Unix user however, this is important.
+   * Consider the following:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a FileSystem
+   * // Create a regular file, and a symbolic link pointing to it
+   * final Path existingFile = fs.getPath("somefile");
+   * Files.createFile(existingFile);
+   * final Path symlinkToExistingFile = fs.getPath("symlink");
+   * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
+   * 
+   * // Create a symbolic link to a nonexistent target file.
+   * final Path nonExistentPath = fs.getPath("nonExistentPath");
+   * final Path symlinkToNonExistentPath = fs.getPath("symlinkToNonExistentPath");
+   * Files.createSymbolicLink(symlinkToNonExistentPath, nonExistentPath);
+   *
+   * // The following assertion succeeds
+   * assertThat(nonExistentPath).doesNotExist();
+   * 
+   * // The following assertions fail:
+   * assertThat(existingFile).doesNotExist();
+   * assertThat(symlinkToExistingFile).doesNotExist();
+   * // fail because symlinkToNonExistentPath exists even though its target does not.
+   * assertThat(symlinkToNonExistentPath).doesNotExist();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Files#notExists(Path, LinkOption...)
+   * @see LinkOption#NOFOLLOW_LINKS
+   */
+  public S doesNotExist() {
+	paths.assertDoesNotExist(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is a regular file.
+   *
+   * <p>
+   * <strong>Note that this method will follow symbolic links.</strong> If you are a Unix user and wish to assert that a
+   * path is a symbolic link instead, use {@link #isSymbolicLink()}.
+   * </p>
+   *
+   * <p>
+   * This assertion first asserts the existence of the path (using {@link #exists()}) then checks whether the path is a
+   * regular file.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   *
+   * // Create a regular file, and a symbolic link to that regular file
+   * final Path existingFile = fs.getPath("existingFile");
+   * final Path symlinkToExistingFile = fs.getPath("symlinkToExistingFile");
+   * Files.createFile(existingFile);
+   * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
+   *
+   * // Create a directory, and a symbolic link to that directory
+   * final Path dir = fs.getPath("dir");
+   * final Path dirSymlink = fs.getPath("dirSymlink");
+   * Files.createDirectories(dir);
+   * Files.createSymbolicLink(dirSymlink, dir);
+   *
+   * // Create a nonexistent entry, and a symbolic link to that entry
+   * final Path nonExistentPath = fs.getPath("nonexistent");
+   * final Path symlinkToNonExistentPath = fs.getPath("symlinkToNonExistentPath");
+   * Files.createSymbolicLink(symlinkToNonExistentPath, nonExistentPath);
+   *
+   * // the following assertions succeed:
+   * assertThat(existingFile).isRegularFile();
+   * assertThat(symlinkToExistingFile).isRegularFile();
+   *
+   * // the following assertions fail because paths do not exist:
+   * assertThat(nonExistentPath).isRegularFile();
+   * assertThat(symlinkToNonExistentPath).isRegularFile();
+   *
+   * // the following assertions fail because paths exist but are not regular files:
+   * assertThat(dir).isRegularFile();
+   * assertThat(dirSymlink).isRegularFile();
+   * </code></pre>
+   *
+   * @return self
+   */
+  public S isRegularFile() {
+	paths.assertIsRegularFile(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is a directory.
+   * <p>
+   * <strong>Note that this method will follow symbolic links.</strong> If you are a Unix user and wish to assert that a
+   * path is a symbolic link instead, use {@link #isSymbolicLink()}.
+   * </p>
+   *
+   * <p>
+   * This assertion first asserts the existence of the path (using {@link #exists()}) then checks whether the path is a
+   * directory.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   *
+   * // Create a regular file, and a symbolic link to that regular file
+   * final Path existingFile = fs.getPath("existingFile");
+   * final Path symlinkToExistingFile = fs.getPath("symlinkToExistingFile");
+   * Files.createFile(existingFile);
+   * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
+   *
+   * // Create a directory, and a symbolic link to that directory
+   * final Path dir = fs.getPath("dir");
+   * final Path dirSymlink = fs.getPath("dirSymlink");
+   * Files.createDirectories(dir);
+   * Files.createSymbolicLink(dirSymlink, dir);
+   *
+   * // Create a nonexistent entry, and a symbolic link to that entry
+   * final Path nonExistentPath = fs.getPath("nonexistent");
+   * final Path symlinkToNonExistentPath = fs.getPath("symlinkToNonExistentPath");
+   * Files.createSymbolicLink(symlinkToNonExistentPath, nonExistentPath);
+   *
+   * // the following assertions succeed:
+   * assertThat(dir).isDirectory();
+   * assertThat(dirSymlink).isDirectory();
+   *
+   * // the following assertions fail because paths do not exist:
+   * assertThat(nonExistentPath).isDirectory();
+   * assertThat(symlinkToNonExistentPath).isDirectory();
+   *
+   * // the following assertions fail because paths exist but are not directories:
+   * assertThat(existingFile).isDirectory();
+   * assertThat(symlinkToExistingFile).isDirectory();
+   * </code></pre>
+   *
+   * @return self
+   */
+  public S isDirectory() {
+	paths.assertIsDirectory(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is a symbolic link.
+   * <p>
+   * This assertion first asserts the existence of the path (using {@link #existsNoFollowLinks()}) then checks whether
+   * the path is a symbolic link.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   *
+   * // Create a regular file, and a symbolic link to that regular file
+   * final Path existingFile = fs.getPath("existingFile");
+   * final Path symlinkToExistingFile = fs.getPath("symlinkToExistingFile");
+   * Files.createFile(existingFile);
+   * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
+   *
+   * // Create a directory, and a symbolic link to that directory
+   * final Path dir = fs.getPath("dir");
+   * final Path dirSymlink = fs.getPath("dirSymlink");
+   * Files.createDirectories(dir);
+   * Files.createSymbolicLink(dirSymlink, dir);
+   *
+   * // Create a nonexistent entry, and a symbolic link to that entry
+   * final Path nonExistentPath = fs.getPath("nonexistent");
+   * final Path symlinkToNonExistentPath = fs.getPath("symlinkToNonExistentPath");
+   * Files.createSymbolicLink(symlinkToNonExistentPath, nonExistentPath);
+   *
+   * // the following assertions succeed:
+   * assertThat(dirSymlink).isSymbolicLink();
+   * assertThat(symlinkToExistingFile).isSymbolicLink();
+   * assertThat(symlinkToNonExistentPath).isSymbolicLink();
+   *
+   * // the following assertion fails because the path does not exist:
+   * assertThat(nonExistentPath).isSymbolicLink();
+   *
+   * // the following assertions fail because paths exist but are not symbolic links
+   * assertThat(existingFile).isSymbolicLink();
+   * assertThat(dir).isSymbolicLink();
+   * </code></pre>
+   *
+   * @return self
+   */
+  public S isSymbolicLink() {
+	paths.assertIsSymbolicLink(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is absolute (the path does not have to exist).
+   *
+   * <p>
+   * Note that the fact that a path is absolute does not mean that it is {@link Path#normalize() normalized}:
+   * {@code /foo/..} is absolute, for instance, but it is not normalized.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // unixFs is a Unix FileSystem
+   *
+   * // The following assertion succeeds:
+   * assertThat(unixFs.getPath("/foo/bar")).isAbsolute();
+   *
+   * // The following assertion fails:
+   * assertThat(unixFs.getPath("foo/bar")).isAbsolute();
+   *
+   * // windowsFs is a Windows FileSystem
+   *
+   * // The following assertion succeeds:
+   * assertThat(windowsFs.getPath("c:\\foo")).isAbsolute();
+   *
+   * // The following assertions fail:
+   * assertThat(windowsFs.getPath("foo\\bar")).isAbsolute();
+   * assertThat(windowsFs.getPath("c:foo")).isAbsolute();
+   * assertThat(windowsFs.getPath("\\foo\\bar")).isAbsolute();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Path#isAbsolute()
+   */
+  public S isAbsolute() {
+	paths.assertIsAbsolute(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is relative (opposite to {@link Path#isAbsolute()}).
+   *
+   * <p>
+   * Examples:
+   * </p>
+   * 
+   * <pre><code class="java">
+   * // unixFs is a Unix FileSystem
+   *
+   * // The following assertions succeed:
+   * assertThat(unixFs.getPath("./foo/bar")).isRelative();
+   * assertThat(unixFs.getPath("foo/bar")).isRelative();
+   *
+   * // The following assertion fails:
+   * assertThat(unixFs.getPath("/foo/bar")).isRelative();
+   *
+   * // windowsFs is a Windows FileSystem
+   *
+   * // The following assertion succeeds:
+   * assertThat(windowsFs.getPath("foo\\bar")).isRelative();
+   * assertThat(windowsFs.getPath("c:foo")).isRelative();
+   * assertThat(windowsFs.getPath("\\foo\\bar")).isRelative();
+   *
+   * // The following assertions fail:
+   * assertThat(windowsFs.getPath("c:\\foo")).isRelative();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Path#isAbsolute()
+   */
+  public S isRelative() {
+	paths.assertIsRelative(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is normalized.
+   *
+   * <p>
+   * A path is normalized if it has no redundant components; typically, on both Unix and Windows, this means that the
+   * path has no "self" components ({@code .}) and that its only parent components ({@code ..}), if any, are at the
+   * beginning of the path.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   *
+   * // the following assertions succeed:
+   * assertThat(fs.getPath("/usr/lib")).isNormalized();
+   * assertThat(fs.getPath("a/b/c")).isNormalized();
+   * assertThat(fs.getPath("../d")).isNormalized();
+   *
+   * // the following assertions fail:
+   * assertThat(fs.getPath("/a/./b")).isNormalized();
+   * assertThat(fs.getPath("c/b/..")).isNormalized();
+   * assertThat(fs.getPath("/../../e")).isNormalized();
+   * </code></pre>
+   *
+   * @return self
+   */
+  public S isNormalized() {
+	paths.assertIsNormalized(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} is canonical by comparing it to its {@link Path#toRealPath(LinkOption...) real
+   * path}.
+   *
+   * <p>
+   * For Windows users, this assertion is no different than {@link #isAbsolute()} expect that the file must exist. For
+   * Unix users, this assertion ensures that the tested path is the actual file system resource, that is, it is not a
+   * {@link Files#isSymbolicLink(Path) symbolic link} to the actual resource, even if the path is absolute.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * // Create a directory
+   * final Path basedir = fs.getPath("/tmp/foo");
+   * Files.createDirectories(basedir);
+   * 
+   * // Create a file in this directory
+   * final Path existingFile = basedir.resolve("existingFile");
+   * Files.createFile(existingFile);
+   * 
+   * // Create a symbolic link to that file
+   * final Path symlinkToExistingFile = basedir.resolve("symlinkToExistingFile");
+   * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
+   *
+   * // The following assertion succeeds:
+   * assertThat(existingFile).isCanonical();
+   *
+   * // The following assertion fails:
+   * assertThat(symlinkToExistingFile).isCanonical();
+   * </code></pre>
+   *
+   * @throws PathsException an I/O error occurred while evaluating the path
+   *
+   * @see Path#toRealPath(LinkOption...)
+   * @see Files#isSameFile(Path, Path)
+   */
+  public S isCanonical() {
+	paths.assertIsCanonical(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} last element String representation is equal to the given filename.
+   *
+   * <p>
+   * Note that the path does not need to exist to check its file name.
+   * </p>
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * final Path file = fs.getPath("/foo/foo.txt");
+   * final Path symlink = fs.getPath("/home/symlink-to-foo");
+   * Files.createSymbolicLink(symlink, file);
+   *
+   * // the following assertions succeed:
+   * assertThat(fs.getPath("/dir1/file.txt")).hasFileName("file.txt");
+   * assertThat(fs.getPath("/dir1/dir2")).hasFileName("dir2");
+   * // you can check file name on non existent paths
+   * assertThat(file).hasFileName("foo.txt");
+   * assertThat(symlink).hasFileName("symlink-to-foo");
+   *
+   * // the following assertions fail:
+   * assertThat(fs.getPath("/dir1/file.txt").hasFileName("other.txt");
+   * // fail because, last element is "." 
+   * assertThat(fs.getPath("/dir1/.")).hasFileName("dir1");
+   * // fail because a link filename is not the same as its target filename
+   * assertThat(symlink).hasFileName("file.txt");
+   * </code></pre>
+   *
+   * @param fileName the expected filename
+   * @return self
+   *
+   * @throws NullPointerException if the given fileName is null.
+   * @see Path#getFileName()
+   */
+  public S hasFileName(final String fileName) {
+	paths.assertHasFileName(info, actual, fileName);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} has the expected parent path.
+   *
+   * <p>
+   * <em>This assertion will perform canonicalization of the tested path and of the given argument before performing the test; see the class
+   * description for more details. If this is not what you want, use {@link #hasParentRaw(Path)} instead.</em>
+   * </p>
+   *
+   * <p>
+   * Checks that the tested path has the given parent. This assertion will fail both if the tested path has no parent,
+   * or has a different parent than what is expected.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * final Path actual = fs.getPath("/dir1/dir2/file");
+   *
+   * // the following assertion succeeds:
+   * assertThat(actual).hasParent(fs.getPath("/dir1/dir2/."));
+   * // this one too as this path will be normalized to "/dir1/dir2":
+   * assertThat(actual).hasParent(fs.getPath("/dir1/dir3/../dir2/."));
+   *
+   * // the following assertion fails:
+   * assertThat(actual).hasParent(fs.getPath("/dir1"));
+   * </code></pre>
+   *
+   * @param expected the expected parent path
+   * @return self
+   *
+   * @throws NullPointerException if the given parent path is null.
+   * @throws PathsException failed to canonicalize the tested path or the path given as an argument
+   * 
+   * @see Path#getParent()
+   */
+  public S hasParent(final Path expected) {
+	paths.assertHasParent(info, actual, expected);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} has the expected parent path.
+   *
+   * <p>
+   * <em>This assertion will not perform any canonicalization of either the tested path or the path given as an argument; 
+   * see class description for more details. If this is not what you want, use {@link #hasParent(Path)} instead.</em>
+   * </p>
+   *
+   * <p>
+   * This assertion uses {@link Path#getParent()} with no modification, which means the only criterion for this
+   * assertion's success is the path's components (its root and its name elements).
+   * </p>
+   *
+   * <p>
+   * This may lead to surprising results if the tested path and the path given as an argument are not normalized. For
+   * instance, if the tested path is {@code /home/foo/../bar} and the argument is {@code /home}, the assertion will
+   * <em>fail</em> since the parent of the tested path is not {@code /home} but... {@code /home/foo/..}.
+   * </p>
+   *
+   * <p>
+   * While this may seem counterintuitive, it has to be recalled here that it is not required for a {@link FileSystem}
+   * to consider that {@code .} and {@code ..} are name elements for respectively the current directory and the parent
+   * directory respectively. In fact, it is not even required that a {@link FileSystem} be hierarchical at all.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * final Path actual = fs.getPath("/dir1/dir2/file");
+   *
+   * // the following assertion succeeds:
+   * assertThat(actual).hasParentRaw(fs.getPath("/dir1/dir2"));
+   *
+   * // the following assertions fails:
+   * assertThat(actual).hasParent(fs.getPath("/dir1"));
+   * // ... and this one too as expected path is not canonicalized.
+   * assertThat(actual).hasParentRaw(fs.getPath("/dir1/dir3/../dir2"));
+   * </code></pre>
+   *
+   * @param expected the expected parent path
+   * @return self
+   *
+   * @throws NullPointerException if the given parent path is null.
+   * 
+   * @see Path#getParent()
+   */
+  public S hasParentRaw(final Path expected) {
+	paths.assertHasParentRaw(info, actual, expected);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} has no parent.
+   *
+   * <p>
+   * <em>This assertion will first canonicalize the tested path before performing the test; if this is not what you want, use {@link #hasNoParentRaw()} instead.</em>
+   * </p>
+   *
+   * <p>
+   * Check that the tested path, after canonicalization, has no parent. See the class description for more information
+   * about canonicalization.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   *
+   * // the following assertion succeeds:
+   * assertThat(fs.getPath("/")).hasNoParent();
+   * // this one too as path will be normalized to "/"
+   * assertThat(fs.getPath("/usr/..")).hasNoParent();
+   *
+   * // the following assertions fail:
+   * assertThat(fs.getPath("/usr/lib")).hasNoParent();
+   * assertThat(fs.getPath("/usr")).hasNoParent();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @throws PathsException failed to canonicalize the tested path
+   *
+   * @see Path#getParent()
+   */
+  public S hasNoParent() {
+	paths.assertHasNoParent(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} has no parent.
+   *
+   * <p>
+   * <em>This assertion will not canonicalize the tested path before performing the test; 
+   * if this is not what you want, use {@link #hasNoParent()} instead.</em>
+   * </p>
+   *
+   * <p>
+   * As canonicalization is not performed, this means the only criterion for this assertion's success is the path's
+   * components (its root and its name elements).
+   * </p>
+   *
+   * <p>
+   * This may lead to surprising results. For instance, path {@code /usr/..} <em>does</em> have a parent, and this
+   * parent is {@code /usr}.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   *
+   * // the following assertions succeed:
+   * assertThat(fs.getPath("/")).hasNoParentRaw();
+   * assertThat(fs.getPath("foo")).hasNoParentRaw();
+   *
+   * // the following assertions fail:
+   * assertThat(fs.getPath("/usr/lib")).hasNoParentRaw();
+   * assertThat(fs.getPath("/usr")).hasNoParentRaw();
+   * // this one fails as canonicalization is not performed, leading to parent being /usr
+   * assertThat(fs.getPath("/usr/..")).hasNoParent();
+   * </code></pre>
+   *
+   * @return self
+   *
+   * @see Path#getParent()
+   */
+  public S hasNoParentRaw() {
+	paths.assertHasNoParentRaw(info, actual);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} starts with the given path.
+   *
+   * <p>
+   * <em>This assertion will perform canonicalization of both the tested path and the path given as an argument; 
+   * see class description for more details. If this is not what you want, use {@link #startsWithRaw(Path)} instead.</em>
+   * </p>
+   *
+   * <p>
+   * Checks that the given {@link Path} starts with another path. Note that the name components matter, not the string
+   * representation; this means that, for example, {@code /home/foobar/baz} <em>does not</em> start with
+   * {@code /home/foo}.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * final Path tested = fs.getPath("/home/joe/myfile");
+   *
+   * // the following assertion succeeds:
+   * assertThat(tested).startsWith(fs.getPath("/home"));
+   * assertThat(tested).startsWith(fs.getPath("/home/"));
+   * assertThat(tested).startsWith(fs.getPath("/home/."));
+   * // assertion succeeds because this path will be canonicalized to "/home/joe"
+   * assertThat(tested).startsWith(fs.getPath("/home/jane/../joe/."));
+   *
+   * // the following assertion fails:
+   * assertThat(tested).startsWith(fs.getPath("/home/harry"));
+   * </code></pre>
+   *
+   * @param other the other path
+   * @return self
+   *
+   * @throws NullPointerException if the given path is null.
+   * @throws PathsException failed to canonicalize the tested path or the path given as an argument
+   *
+   * @see Path#startsWith(Path)
+   * @see Path#toRealPath(LinkOption...)
+   */
+  public S startsWith(final Path other) {
+	paths.assertStartsWith(info, actual, other);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} starts with the given path.
+   *
+   * <p>
+   * <em>This assertions does not perform canonicalization on either the
+   * tested path or the path given as an argument; see class description for
+   * more details. If this is not what you want, use {@link #startsWith(Path)}
+   * instead.</em>
+   * </p>
+   *
+   * <p>
+   * Checks that the given {@link Path} starts with another path, without performing canonicalization on its arguments.
+   * This means that the only criterion to determine whether a path starts with another is the tested path's, and the
+   * argument's, name elements.
+   * </p>
+   *
+   * <p>
+   * This may lead to some surprising results: for instance, path {@code /../home/foo} does <em>not</em> start with
+   * {@code /home} since the first name element of the former ({@code ..}) is different from the first name element of
+   * the latter ({@code home}).
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * final Path tested = fs.getPath("/home/joe/myfile");
+   *
+   * // the following assertion succeeds:
+   * assertThat(tested).startsWithRaw(fs.getPath("/home/joe"));
+   *
+   * // the following assertion fails:
+   * assertThat(tested).startsWithRaw(fs.getPath("/home/harry"));
+   * // .... and this one too as given path is not canonicalized
+   * assertThat(tested).startsWithRaw(fs.getPath("/home/joe/.."));
+   * </code></pre>
+   *
+   * @param other the other path
+   * @return self
+   *
+   * @throws NullPointerException if the given path is null.
+   * 
+   * @see Path#startsWith(Path)
+   */
+  public S startsWithRaw(final Path other) {
+	paths.assertStartsWithRaw(info, actual, other);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} ends with the given path.
+   *
+   * <p>
+   * This assertion will attempt to canonicalize the tested path and normalize the path given as an argument before
+   * performing the actual test.
+   * </p>
+   *
+   * <p>
+   * Note that the criterion to determine success is determined by the path's name elements; therefore,
+   * {@code /home/foobar/baz} does <em>not</em> end with {@code bar/baz}.
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem.
+   * // the current directory is supposed to be /home.
+   * final Path tested = fs.getPath("/home/joe/myfile");
+   * // as tested will be canonicalized, it could have been written: /home/jane/../joe/myfile
+   *
+   * // the following assertion succeeds:
+   * assertThat(tested).endsWith(fs.getPath("joe/myfile"));
+   *
+   * // the following assertions fail:
+   * assertThat(tested).endsWith(fs.getPath("joe/otherfile"));
+   * // this path will be normalized to joe/otherfile
+   * assertThat(tested).endsWith(fs.getPath("joe/myfile/../otherfile"));
+   * </code></pre>
+   *
+   * @param other the other path
+   * @return self
+   *
+   * @throws NullPointerException if the given path is null.
+   * @throws PathsException failed to canonicalize the tested path (see class
+   *           description)
+   * 
+   * @see Path#endsWith(Path)
+   * @see Path#toRealPath(LinkOption...)
+   */
+  public S endsWith(final Path other) {
+	paths.assertEndsWith(info, actual, other);
+	return myself;
+  }
+
+  /**
+   * Assert that the tested {@link Path} ends with the given path.
+   *
+   * <p>
+   * <em>This assertion will not perform any canonicalization (on the
+   * tested path) or normalization (on the path given as an argument); see the
+   * class description for more details. If this is not what you want, use
+   * {@link #endsWith(Path)} instead.</em>
+   * </p>
+   *
+   * <p>
+   * This may lead to some surprising results; for instance, path {@code /home/foo} does <em>not</em> end with
+   * {@code foo/.} since the last name element of the former ({@code foo}) is different from the last name element of
+   * the latter ({@code .}).
+   * </p>
+   *
+   * <p>
+   * Examples:
+   * </p>
+   *
+   * <pre><code class="java">
+   * // fs is a Unix filesystem
+   * // the current directory is supposed to be /home.
+   * final Path tested = fs.getPath("/home/joe/myfile");
+   *
+   * // The following assertion succeeds:
+   * assertThat(tested).endsWithRaw(fs.getPath("joe/myfile"));
+   *
+   * // But the following assertion fails:
+   * assertThat(tested).endsWithRaw(fs.getPath("harry/myfile"));
+   * // and this one too as the given path is not normalized
+   * assertThat(tested).endsWithRaw(fs.getPath("harry/../joe/myfile"));
+   * </code></pre>
+   *
+   * @param other the other path
+   * @return self
+   * 
+   * @throws NullPointerException if the given path is null.
+   * 
+   * @see Path#endsWith(Path)
+   */
+  public S endsWithRaw(final Path other) {
+	paths.assertEndsWithRaw(info, actual, other);
+	return myself;
+  }
+}
diff --git a/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java b/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
index c46dcee90..18aef6e9a 100644
--- a/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
+++ b/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
@@ -17,6 +17,7 @@ import static org.assertj.core.util.Arrays.array;
 import java.io.File;
 import java.io.InputStream;
 import java.math.BigDecimal;
+import java.nio.file.Path;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -217,6 +218,16 @@ public abstract class AbstractSoftAssertions {
 	return proxy(FileAssert.class, File.class, actual);
   }
 
+  /**
+   * Creates a new, proxied instance of a {@link PathAssert}
+   *
+   * @param actual the path
+   * @return the created assertion object
+   */
+  public PathAssert assertThat(Path actual) {
+    return proxy(PathAssert.class, Path.class, actual);
+  }
+
   /**
    * Creates a new instance of <code>{@link InputStreamAssert}</code>.
    *
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index a721d776e..d378e2a65 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -16,6 +16,7 @@ import java.io.File;
 import java.io.InputStream;
 import java.math.BigDecimal;
 import java.nio.charset.Charset;
+import java.nio.file.Path;
 import java.text.DateFormat;
 import java.util.Date;
 import java.util.Iterator;
@@ -252,6 +253,17 @@ public class Assertions {
 	return new FileAssert(actual);
   }
 
+  /**
+   * Creates a new instance of {@link PathAssert}
+   *
+   * @param actual the path to test
+   * @return the created assertion object
+   */
+  public static AbstractPathAssert<?> assertThat(Path actual)
+  {
+    return new PathAssert(actual);
+  }
+
   /**
    * Creates a new instance of <code>{@link InputStreamAssert}</code>.
    *
diff --git a/src/main/java/org/assertj/core/api/PathAssert.java b/src/main/java/org/assertj/core/api/PathAssert.java
new file mode 100644
index 000000000..1b8779ec4
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/PathAssert.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import java.nio.file.Path;
+
+/**
+ * Assertion class for {@link Path}s
+ */
+public class PathAssert extends AbstractPathAssert<PathAssert>
+{
+    /**
+     * Constructor
+     *
+     * @param actual the path to test
+     */
+    protected PathAssert(Path actual)
+    {
+        super(actual, PathAssert.class);
+    }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeAbsolutePath.java b/src/main/java/org/assertj/core/error/ShouldBeAbsolutePath.java
index b8bcb53e0..152b9c96c 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeAbsolutePath.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeAbsolutePath.java
@@ -12,16 +12,24 @@
  */
 package org.assertj.core.error;
 
+import org.assertj.core.util.VisibleForTesting;
+
 import java.io.File;
+import java.nio.file.Path;
 
 /**
- * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> is an absolute path
+ * Creates an error message indicating that an assertion that verifies that a
+ * {@link File} or {@link Path} is an absolute path
  * failed.
  * 
  * @author Yvonne Wang
+ * @author Francis Galiegue
  */
 public class ShouldBeAbsolutePath extends BasicErrorMessageFactory {
 
+  @VisibleForTesting
+  public static final String SHOULD_BE_ABSOLUTE_PATH = "%nExpecting:%n  <%s>%nto be an absolute path.";
+
   /**
    * Creates a new <code>{@link ShouldBeAbsolutePath}</code>.
    * @param actual the actual value in the failed assertion.
@@ -31,7 +39,15 @@ public class ShouldBeAbsolutePath extends BasicErrorMessageFactory {
     return new ShouldBeAbsolutePath(actual);
   }
 
+  public static ErrorMessageFactory shouldBeAbsolutePath(final Path actual) {
+    return new ShouldBeAbsolutePath(actual);
+  }
+
   private ShouldBeAbsolutePath(File actual) {
-    super("\nExpecting:\n <%s>\nto be an absolute path", actual);
+    super(SHOULD_BE_ABSOLUTE_PATH, actual);
+  }
+
+  private ShouldBeAbsolutePath(final Path actual) {
+    super(SHOULD_BE_ABSOLUTE_PATH, actual);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeCanonicalPath.java b/src/main/java/org/assertj/core/error/ShouldBeCanonicalPath.java
new file mode 100644
index 000000000..2de628874
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeCanonicalPath.java
@@ -0,0 +1,40 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.util.VisibleForTesting;
+
+import java.nio.file.Path;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a
+ * {@link Path} is canonical has failed.
+ * 
+ */
+public class ShouldBeCanonicalPath
+    extends BasicErrorMessageFactory
+{
+    @VisibleForTesting
+    public static final String SHOULD_BE_CANONICAL
+        = "%nExpecting:%n  <%s>%nto be a canonical path";
+
+    public static ErrorMessageFactory shouldBeCanonicalPath(final Path actual)
+    {
+        return new ShouldBeCanonicalPath(actual);
+    }
+
+    private ShouldBeCanonicalPath(final Path actual)
+    {
+        super(SHOULD_BE_CANONICAL, actual);
+    }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeDirectory.java b/src/main/java/org/assertj/core/error/ShouldBeDirectory.java
index 889a88ac7..223e528cb 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeDirectory.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeDirectory.java
@@ -13,25 +13,38 @@
 package org.assertj.core.error;
 
 import java.io.File;
+import java.nio.file.Path;
+
+import org.assertj.core.util.VisibleForTesting;
 
 /**
- * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> is an existing directory
- * failed.
+ * Creates an error message indicating that an assertion that verifies that a {@link File} or {@link Path} is an
+ * existing directory failed
  * 
  * @author Yvonne Wang
+ * @author Francis Galiegue
  */
-public class ShouldBeDirectory extends BasicErrorMessageFactory {
-
-  /**
-   * Creates a new <code>{@link ShouldBeDirectory}</code>.
-   * @param actual the actual value in the failed assertion.
-   * @return the created {@code ErrorMessageFactory}.
-   */
-  public static ErrorMessageFactory shouldBeDirectory(File actual) {
-    return new ShouldBeDirectory(actual);
+public class ShouldBeDirectory extends BasicErrorMessageFactory
+{
+  @VisibleForTesting
+  public static final String PATH_SHOULD_BE_DIRECTORY = "%nExpecting path:%n  <%s>%nto be a directory.";
+
+  @VisibleForTesting
+  public static final String FILE_SHOULD_BE_DIRECTORY = "%nExpecting file:%n  <%s>%n to be an existing directory.";
+
+  public static ErrorMessageFactory shouldBeDirectory(final Path actual) {
+	return new ShouldBeDirectory(actual);
+  }
+
+  public static ErrorMessageFactory shouldBeDirectory(final File actual) {
+	return new ShouldBeDirectory(actual);
+  }
+
+  private ShouldBeDirectory(final Path actual) {
+	super(PATH_SHOULD_BE_DIRECTORY, actual);
   }
 
-  private ShouldBeDirectory(File actual) {
-    super("\nExpecting:\n <%s>\nto be an existing directory", actual);
+  private ShouldBeDirectory(final File actual) {
+	super(FILE_SHOULD_BE_DIRECTORY, actual);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeExecutable.java b/src/main/java/org/assertj/core/error/ShouldBeExecutable.java
index d930481d4..fcfac8686 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeExecutable.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeExecutable.java
@@ -13,6 +13,7 @@
 package org.assertj.core.error;
 
 import java.io.File;
+import java.nio.file.Path;
 
 /**
  * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> is executable
@@ -22,17 +23,28 @@ import java.io.File;
  * 
  */
 public class ShouldBeExecutable extends BasicErrorMessageFactory {
+  static final String SHOULD_BE_EXECUTABLE = "%nExpecting:%n  <%s>%nto be executable.";
+
   private ShouldBeExecutable(File actual) {
-    super("\nExpecting:\n <%s>\nto be executable", actual);
+	super(SHOULD_BE_EXECUTABLE, actual);
+  }
+
+  private ShouldBeExecutable(Path actual) {
+	super(SHOULD_BE_EXECUTABLE, actual);
   }
 
   /**
    * Creates a new <code>{@link ShouldBeExecutable}</code>.
+   * 
    * @param actual the actual value in the failed assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ErrorMessageFactory shouldBeExecutable(File actual) {
-    return new ShouldBeExecutable(actual);
+	return new ShouldBeExecutable(actual);
+  }
+
+  public static ErrorMessageFactory shouldBeExecutable(Path actual) {
+	return new ShouldBeExecutable(actual);
   }
 
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeNormalized.java b/src/main/java/org/assertj/core/error/ShouldBeNormalized.java
new file mode 100644
index 000000000..48a299af6
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeNormalized.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.util.VisibleForTesting;
+
+import java.nio.file.Path;
+
+/**
+ * Assertion error message delivered when a {@link Path} is not normalized
+ *
+ * @see Path#normalize()
+ */
+public class ShouldBeNormalized extends BasicErrorMessageFactory
+{
+  @VisibleForTesting
+  public static final String SHOULD_BE_NORMALIZED = "Expected path:%n  <%s>%nto be normalized.";
+
+  private ShouldBeNormalized(Path actual) {
+	super(SHOULD_BE_NORMALIZED, actual);
+  }
+
+  public static ErrorMessageFactory shouldBeNormalized(Path actual) {
+	return new ShouldBeNormalized(actual);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeReadable.java b/src/main/java/org/assertj/core/error/ShouldBeReadable.java
index 3e7a8d7c7..23c421935 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeReadable.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeReadable.java
@@ -13,26 +13,38 @@
 package org.assertj.core.error;
 
 import java.io.File;
+import java.nio.file.Path;
 
 /**
- * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> is readable
- * failed.
+ * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> or a a
+ * <code>{@link Path}</code> is readable failed.
  * 
  * @author Olivier Demeijer
  * 
  */
 public class ShouldBeReadable extends BasicErrorMessageFactory {
+  static final String SHOULD_BE_READABLE = "%nExpecting:%n  <%s>%nto be readable.";
+
   private ShouldBeReadable(File actual) {
-    super("\nExpecting file:\n <%s>\nto be readable", actual);
+	super(SHOULD_BE_READABLE, actual);
+  }
+
+  private ShouldBeReadable(Path actual) {
+	super(SHOULD_BE_READABLE, actual);
   }
 
   /**
    * Creates a new <code>{@link ShouldBeReadable}</code>.
+   * 
    * @param actual the actual value in the failed assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ErrorMessageFactory shouldBeReadable(File actual) {
-    return new ShouldBeReadable(actual);
+	return new ShouldBeReadable(actual);
+  }
+
+  public static ErrorMessageFactory shouldBeReadable(Path actual) {
+	return new ShouldBeReadable(actual);
   }
 
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeRegularFile.java b/src/main/java/org/assertj/core/error/ShouldBeRegularFile.java
new file mode 100644
index 000000000..4ae697407
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeRegularFile.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.util.VisibleForTesting;
+
+import java.nio.file.Path;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a {@link Path} is a regular file has failed.
+ *
+ */
+public class ShouldBeRegularFile extends BasicErrorMessageFactory
+{
+  @VisibleForTesting
+  public static final String SHOULD_BE_REGULAR_FILE = "%nExpecting path:%n  <%s>%nto be a regular file.";
+
+  public static ErrorMessageFactory shouldBeRegularFile(final Path actual) {
+	return new ShouldBeRegularFile(actual);
+  }
+
+  private ShouldBeRegularFile(final Path actual) {
+	super(SHOULD_BE_REGULAR_FILE, actual);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeRelativePath.java b/src/main/java/org/assertj/core/error/ShouldBeRelativePath.java
index 5562990e2..e8551fb3c 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeRelativePath.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeRelativePath.java
@@ -13,24 +13,39 @@
 package org.assertj.core.error;
 
 import java.io.File;
+import java.nio.file.Path;
+
+import org.assertj.core.util.VisibleForTesting;
 
 /**
- * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> is a relative path failed.
- * 
- * @author Yvonne Wang
+ * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> or a
+ * {@link Path} is a relative path failed.
  */
 public class ShouldBeRelativePath extends BasicErrorMessageFactory {
 
+  @VisibleForTesting
+  public static final String SHOULD_BE_RELATIVE_PATH = "%nExpecting:%n  <%s>%nto be a relative path.";
+
   /**
    * Creates a new <code>{@link ShouldBeRelativePath}</code>.
+   * 
    * @param actual the actual value in the failed assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ErrorMessageFactory shouldBeRelativePath(File actual) {
-    return new ShouldBeRelativePath(actual);
+	return new ShouldBeRelativePath(actual);
+  }
+
+  public static ErrorMessageFactory shouldBeRelativePath(final Path actual) {
+	return new ShouldBeRelativePath(actual);
   }
 
   private ShouldBeRelativePath(File actual) {
-    super("\nExpecting file:\n <%s>\nto be a relative path", actual);
+	super(SHOULD_BE_RELATIVE_PATH, actual);
   }
+
+  private ShouldBeRelativePath(final Path actual) {
+	super(SHOULD_BE_RELATIVE_PATH, actual);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeSymbolicLink.java b/src/main/java/org/assertj/core/error/ShouldBeSymbolicLink.java
new file mode 100644
index 000000000..fcf185866
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeSymbolicLink.java
@@ -0,0 +1,34 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.util.VisibleForTesting;
+
+import java.nio.file.Path;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a {@link Path} is a regular file has failed.
+ */
+public class ShouldBeSymbolicLink extends BasicErrorMessageFactory
+{
+  @VisibleForTesting
+  public static final String SHOULD_BE_SYMBOLIC_LINK = "%nExpecting path:%n  <%s>%nto be a symbolic link.";
+
+  public static ErrorMessageFactory shouldBeSymbolicLink(final Path actual) {
+	return new ShouldBeSymbolicLink(actual);
+  }
+
+  private ShouldBeSymbolicLink(final Path actual) {
+	super(SHOULD_BE_SYMBOLIC_LINK, actual);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeWritable.java b/src/main/java/org/assertj/core/error/ShouldBeWritable.java
index b9aad54bb..47f4094f4 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeWritable.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeWritable.java
@@ -13,6 +13,7 @@
 package org.assertj.core.error;
 
 import java.io.File;
+import java.nio.file.Path;
 
 /**
  * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> is writable
@@ -22,17 +23,28 @@ import java.io.File;
  *
  */
 public class ShouldBeWritable extends BasicErrorMessageFactory {
+  static final String SHOULD_BE_WRITABLE = "%nExpecting:%n  <%s>%nto be writable.";
 
   private ShouldBeWritable(File actual) {
-    super("\nFile:\n <%s>\nshould be writable", actual);
+	super(SHOULD_BE_WRITABLE, actual);
+  }
+
+  private ShouldBeWritable(Path actual) {
+	super(SHOULD_BE_WRITABLE, actual);
   }
 
   /**
    * Creates a new <code>{@link ShouldBeWritable}</code>.
+   * 
    * @param actual the actual value in the failed assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ErrorMessageFactory shouldBeWritable(File actual) {
-    return new ShouldBeWritable(actual);
+	return new ShouldBeWritable(actual);
   }
+
+  public static ErrorMessageFactory shouldBeWritable(Path actual) {
+	return new ShouldBeWritable(actual);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldEndWithPath.java b/src/main/java/org/assertj/core/error/ShouldEndWithPath.java
new file mode 100644
index 000000000..99b4c89af
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldEndWithPath.java
@@ -0,0 +1,30 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.util.VisibleForTesting;
+
+import java.nio.file.Path;
+
+public class ShouldEndWithPath extends BasicErrorMessageFactory {
+  @VisibleForTesting
+  public static final String PATH_SHOULD_END_WITH = "%nExpected path:%n  <%s>%nto end with:%n  <%s>%nbut it did not.";
+
+  public static ErrorMessageFactory shouldEndWith(final Path actual, final Path other) {
+	return new ShouldEndWithPath(actual, other);
+  }
+
+  private ShouldEndWithPath(final Path actual, final Path other) {
+	super(PATH_SHOULD_END_WITH, actual, other);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldExist.java b/src/main/java/org/assertj/core/error/ShouldExist.java
index 1f16c8814..030197add 100644
--- a/src/main/java/org/assertj/core/error/ShouldExist.java
+++ b/src/main/java/org/assertj/core/error/ShouldExist.java
@@ -12,25 +12,47 @@
  */
 package org.assertj.core.error;
 
+import org.assertj.core.util.VisibleForTesting;
+
 import java.io.File;
+import java.nio.file.Path;
 
 /**
- * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> exists failed.
+ * Creates an error message indicating that an assertion that verifies that a {@link File} or {@link Path} exists
+ * failed.
  * 
  * @author Yvonne Wang
  */
 public class ShouldExist extends BasicErrorMessageFactory {
 
+  @VisibleForTesting
+  public static final String PATH_SHOULD_EXIST = "%nExpecting path:%n  <%s>%nto exist (symbolic links were followed).";
+  public static final String PATH_SHOULD_EXIST_NO_FOLLOW_LINKS = "%nExpecting path:%n  <%s>%nto exist (symbolic links were not followed).";
+  public static final String FILE_SHOULD_EXIST = "%nExpecting file:%n  <%s>%nto exist.";
+
   /**
    * Creates a new <code>{@link ShouldExist}</code>.
+   * 
    * @param actual the actual value in the failed assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ErrorMessageFactory shouldExist(File actual) {
-    return new ShouldExist(actual);
+	return new ShouldExist(actual);
+  }
+
+  public static ErrorMessageFactory shouldExist(final Path actual) {
+	return new ShouldExist(actual, true);
+  }
+
+  public static ErrorMessageFactory shouldExistNoFollowLinks(final Path actual) {
+	return new ShouldExist(actual, false);
   }
 
   private ShouldExist(File actual) {
-    super("\nExpecting file:<%s> to exist", actual);
+	super(FILE_SHOULD_EXIST, actual);
+  }
+
+  private ShouldExist(final Path actual, boolean followLinks) {
+	super(followLinks ? PATH_SHOULD_EXIST : PATH_SHOULD_EXIST_NO_FOLLOW_LINKS, actual);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveContent.java b/src/main/java/org/assertj/core/error/ShouldHaveContent.java
index 2dea8b639..8d69ad4c2 100644
--- a/src/main/java/org/assertj/core/error/ShouldHaveContent.java
+++ b/src/main/java/org/assertj/core/error/ShouldHaveContent.java
@@ -36,7 +36,7 @@ public class ShouldHaveContent extends AbstractShouldHaveTextContent {
   }
 
   private ShouldHaveContent(File actual, Charset charset, String diffs) {
-    super("\nFile:\n <%s>\nread with charset <%s> does not have the expected content:", actual, charset);
+    super("\nFile:\n  <%s>\nread with charset <%s> does not have the expected content:", actual, charset);
     this.diffs = diffs;
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveEqualContent.java b/src/main/java/org/assertj/core/error/ShouldHaveEqualContent.java
index 8e1ca330d..3818c5838 100644
--- a/src/main/java/org/assertj/core/error/ShouldHaveEqualContent.java
+++ b/src/main/java/org/assertj/core/error/ShouldHaveEqualContent.java
@@ -49,7 +49,7 @@ public class ShouldHaveEqualContent extends AbstractShouldHaveTextContent {
   }
 
   private ShouldHaveEqualContent(File actual, File expected, String diffs) {
-    super("\nFile:\n <%s>\nand file:\n <%s>\ndo not have equal content:", actual, expected);
+    super("\nFile:\n  <%s>\nand file:\n  <%s>\ndo not have equal content:", actual, expected);
     this.diffs = diffs;
   }
 
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveName.java b/src/main/java/org/assertj/core/error/ShouldHaveName.java
index ee40f8910..52e6cf1f0 100644
--- a/src/main/java/org/assertj/core/error/ShouldHaveName.java
+++ b/src/main/java/org/assertj/core/error/ShouldHaveName.java
@@ -13,6 +13,7 @@
 package org.assertj.core.error;
 
 import java.io.File;
+import java.nio.file.Path;
 
 /**
  * Creates an error message indicating that a {@code File} should have name.
@@ -21,11 +22,21 @@ import java.io.File;
  */
 public class ShouldHaveName extends BasicErrorMessageFactory {
 
+  private static final String SHOULD_HAVE_NAME = "%nExpecting%n  <%s>%nto have name:%n  <%s>%nbut had:%n  <%s>";
+
   public static ShouldHaveName shouldHaveName(File actual, String expectedName) {
     return new ShouldHaveName(actual, expectedName);
   }
 
   private ShouldHaveName(File actual, String expectedName) {
-    super("%nExpecting%n  <%s>%nto have name:%n  <%s>%nbut had:%n  <%s>.", actual, expectedName, actual.getName());
+    super(SHOULD_HAVE_NAME, actual, expectedName, actual.getName());
+  }
+  
+  public static ShouldHaveName shouldHaveName(Path actual, String expectedName) {
+	return new ShouldHaveName(actual, expectedName);
+  }
+  
+  private ShouldHaveName(Path actual, String expectedName) {
+	super(SHOULD_HAVE_NAME, actual, expectedName, actual.getFileName());
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveNoParent.java b/src/main/java/org/assertj/core/error/ShouldHaveNoParent.java
index 69b40f98f..cd5641d85 100644
--- a/src/main/java/org/assertj/core/error/ShouldHaveNoParent.java
+++ b/src/main/java/org/assertj/core/error/ShouldHaveNoParent.java
@@ -12,7 +12,10 @@
  */
 package org.assertj.core.error;
 
+import org.assertj.core.util.VisibleForTesting;
+
 import java.io.File;
+import java.nio.file.Path;
 
 /**
  * Creates an error message when a {@code File} should not have a parent.
@@ -21,6 +24,12 @@ import java.io.File;
  */
 public class ShouldHaveNoParent extends BasicErrorMessageFactory {
 
+  @VisibleForTesting
+  public static final String PATH_HAS_PARENT = "%nExpected actual path:%n  <%s>%n not to have a parent, but parent was:%n  <%s>";
+
+  @VisibleForTesting
+  public static final String FILE_HAS_PARENT = "%nExpecting file (or directory):%n  <%s>%nnot to have a parent, but parent was:%n  <%s>";
+
   /**
    * Creates a new </code>{@link ShouldHaveNoParent}</code>.
    * 
@@ -28,10 +37,19 @@ public class ShouldHaveNoParent extends BasicErrorMessageFactory {
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ShouldHaveNoParent shouldHaveNoParent(File actual) {
-    return new ShouldHaveNoParent(actual);
+	return new ShouldHaveNoParent(actual);
+  }
+
+  public static ShouldHaveNoParent shouldHaveNoParent(Path actual) {
+	return new ShouldHaveNoParent(actual);
   }
 
   private ShouldHaveNoParent(File actual) {
-    super("%nExpecting file (or directory) without parent, but parent was:%n  <%s>", actual.getParentFile());
+	super(FILE_HAS_PARENT, actual, actual.getParentFile());
+  }
+
+  private ShouldHaveNoParent(Path actual)
+  {
+	super(PATH_HAS_PARENT, actual, actual.getParent());
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveParent.java b/src/main/java/org/assertj/core/error/ShouldHaveParent.java
index dbef15278..c720087db 100644
--- a/src/main/java/org/assertj/core/error/ShouldHaveParent.java
+++ b/src/main/java/org/assertj/core/error/ShouldHaveParent.java
@@ -12,7 +12,10 @@
  */
 package org.assertj.core.error;
 
+import org.assertj.core.util.VisibleForTesting;
+
 import java.io.File;
+import java.nio.file.Path;
 
 /**
  * Creates an error message indicating that a {@code File} should have a parent.
@@ -21,16 +24,51 @@ import java.io.File;
  */
 public class ShouldHaveParent extends BasicErrorMessageFactory {
 
+  @VisibleForTesting
+  public static final String PATH_NO_PARENT
+      = "%nExpecting path%n  <%s>%nto have parent:%n  <%s>%nbut did not have one.";
+
+  @VisibleForTesting
+  public static final String PATH_NOT_EXPECTED_PARENT
+      = "%nExpecting path%n  <%s>%nto have parent:%n  <%s>%nbut had:%n  <%s>.";
+
+  @VisibleForTesting
+  public static final String FILE_NO_PARENT
+      = "%nExpecting file%n  <%s>%nto have parent:%n  <%s>%nbut did not have one.";
+
+  @VisibleForTesting
+  public static final String FILE_NOT_EXPECTED_PARENT
+      = "%nExpecting file%n  <%s>%nto have parent:%n  <%s>%nbut had:%n  <%s>.";
+
   public static ShouldHaveParent shouldHaveParent(File actual, File expected) {
     return actual.getParentFile() == null ? new ShouldHaveParent(actual, expected) : new ShouldHaveParent(actual,
         actual.getParentFile(), expected);
   }
 
+  public static ShouldHaveParent shouldHaveParent(Path actual, Path expected) {
+    final Path actualParent = actual.getParent();
+    return actualParent == null
+        ? new ShouldHaveParent(actual, expected)
+        : new ShouldHaveParent(actual, actualParent, expected);
+  }
+
+  public static ShouldHaveParent shouldHaveParent(Path actual, Path actualParent, Path expected) {
+    return new ShouldHaveParent(actual, actualParent, expected);
+  }
+
   private ShouldHaveParent(File actual, File expected) {
-    super("%nExpecting file%n  <%s>%nto have parent:%n  <%s>%nbut did not have one.", actual, expected);
+    super(FILE_NO_PARENT, actual, expected);
   }
 
   private ShouldHaveParent(File actual, File actualParent, File expected) {
-    super("%nExpecting file%n  <%s>%nto have parent:%n  <%s>%nbut had:%n  <%s>.", actual, expected, actualParent);
+    super(FILE_NOT_EXPECTED_PARENT, actual, expected, actualParent);
+  }
+
+  private ShouldHaveParent(Path actual, Path expected) {
+    super(PATH_NO_PARENT, actual, expected);
+  }
+
+  private ShouldHaveParent(Path actual, Path actualParent, Path expected) {
+    super(PATH_NOT_EXPECTED_PARENT, actual, expected, actualParent);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldNotExist.java b/src/main/java/org/assertj/core/error/ShouldNotExist.java
index 52e7fc4f3..a4a247bfb 100644
--- a/src/main/java/org/assertj/core/error/ShouldNotExist.java
+++ b/src/main/java/org/assertj/core/error/ShouldNotExist.java
@@ -12,25 +12,54 @@
  */
 package org.assertj.core.error;
 
+import org.assertj.core.util.VisibleForTesting;
+
 import java.io.File;
+import java.nio.file.Path;
 
 /**
- * Creates an error message indicating that an assertion that verifies that a <code>{@link File}</code> does not exist failed.
+ * Creates an error message indicating that an assertion that verifies that a {@link File} or {@link Path} does not
+ * exist failed.
  * 
  * @author Yvonne Wang
+ * @author Francis Galiegue
  */
 public class ShouldNotExist extends BasicErrorMessageFactory {
 
+  @VisibleForTesting
+  public static final String PATH_SHOULD_NOT_EXIST = "%nExpecting path:%n  <%s>%nnot to exist";
+  @VisibleForTesting
+  public static final String FILE_SHOULD_NOT_EXIST = "%nExpecting file:%n  <%s>%nnot to exist";
+  @VisibleForTesting
+  public static final String PATH_SHOULD_NOT_EXIST_NO_FOLLOW_LINKS = "%nExpecting path:%n  <%s>%nnot to exist (symbolic links were not followed).";
+
   /**
    * Creates a new <code>{@link ShouldNotExist}</code>.
+   * 
    * @param actual the actual value in the failed assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
   public static ErrorMessageFactory shouldNotExist(File actual) {
-    return new ShouldNotExist(actual);
+	return new ShouldNotExist(actual);
+  }
+
+  public static ErrorMessageFactory shouldNotExist(final Path actual) {
+	return new ShouldNotExist(actual);
+  }
+
+  public static ErrorMessageFactory shouldExistNoFollowLinks(final Path actual) {
+	return new ShouldNotExist(actual);
   }
 
   private ShouldNotExist(File actual) {
-    super("\nExpecting file:<%s> not to exist", actual);
+	super(FILE_SHOULD_NOT_EXIST, actual);
+  }
+
+  private ShouldNotExist(final Path actual) {
+	super(PATH_SHOULD_NOT_EXIST, actual);
+  }
+
+  private ShouldNotExist(final Path actual, boolean followLinks) {
+	super(followLinks ? PATH_SHOULD_NOT_EXIST : PATH_SHOULD_NOT_EXIST_NO_FOLLOW_LINKS, actual);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldStartWithPath.java b/src/main/java/org/assertj/core/error/ShouldStartWithPath.java
new file mode 100644
index 000000000..5d0c5c975
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldStartWithPath.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.util.VisibleForTesting;
+
+import java.nio.file.Path;
+
+public class ShouldStartWithPath extends BasicErrorMessageFactory {
+  
+  @VisibleForTesting
+  public static final String PATH_SHOULD_START_WITH = "%nExpected path:%n  <%s>%nto start with:%n  <%s>%nbut it did not.";
+
+  public static ErrorMessageFactory shouldStartWith(final Path actual, final Path other) {
+	return new ShouldStartWithPath(actual, other);
+  }
+
+  private ShouldStartWithPath(final Path actual, final Path other) {
+	super(PATH_SHOULD_START_WITH, actual, other);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/NioFilesWrapper.java b/src/main/java/org/assertj/core/internal/NioFilesWrapper.java
new file mode 100644
index 000000000..5449c6814
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/NioFilesWrapper.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
+
+import org.assertj.core.util.VisibleForTesting;
+
+
+/**
+ * Wrapper for <code>{@link java.nio.file.Files}</code> to test {@link Paths}.
+ */
+public class NioFilesWrapper {
+
+  private static final NioFilesWrapper INSTANCE = new NioFilesWrapper();
+
+  /**
+   * Returns the singleton instance of this class.
+   * @return the singleton instance of this class.
+   */
+  public static NioFilesWrapper instance() {
+    return INSTANCE;
+  }
+
+  @VisibleForTesting
+  NioFilesWrapper() {}
+
+  public boolean isRegularFile(Path path) {
+    return Files.isRegularFile(path);
+  }
+  
+  public boolean isSymbolicLink(Path path) {
+	return Files.isSymbolicLink(path);
+  }
+  
+  public boolean isDirectory(Path path) {
+	return Files.isDirectory(path);
+  }
+  
+  public boolean exists(Path path, LinkOption... options) {
+	return Files.exists(path, options);
+  }
+
+  public boolean notExists(Path path, LinkOption... options) {
+	return Files.notExists(path, options);
+  }
+  
+  public boolean isReadable(Path path) {
+	return Files.isReadable(path);
+  }
+  
+  public boolean isWritable(Path path) {
+	return Files.isWritable(path);
+  }
+  
+  public boolean isExecutable(Path path) {
+	return Files.isExecutable(path);
+  }
+  
+}
+
diff --git a/src/main/java/org/assertj/core/internal/Paths.java b/src/main/java/org/assertj/core/internal/Paths.java
new file mode 100644
index 000000000..998ef492f
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/Paths.java
@@ -0,0 +1,318 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.lang.String.format;
+import static org.assertj.core.error.ShouldBeAbsolutePath.shouldBeAbsolutePath;
+import static org.assertj.core.error.ShouldBeCanonicalPath.shouldBeCanonicalPath;
+import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
+import static org.assertj.core.error.ShouldBeExecutable.shouldBeExecutable;
+import static org.assertj.core.error.ShouldBeNormalized.shouldBeNormalized;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.assertj.core.error.ShouldBeRelativePath.shouldBeRelativePath;
+import static org.assertj.core.error.ShouldBeSymbolicLink.shouldBeSymbolicLink;
+import static org.assertj.core.error.ShouldBeWritable.shouldBeWritable;
+import static org.assertj.core.error.ShouldEndWithPath.shouldEndWith;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldExist.shouldExistNoFollowLinks;
+import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
+import static org.assertj.core.error.ShouldHaveContent.shouldHaveContent;
+import static org.assertj.core.error.ShouldHaveEqualContent.shouldHaveEqualContent;
+import static org.assertj.core.error.ShouldHaveName.shouldHaveName;
+import static org.assertj.core.error.ShouldHaveNoParent.shouldHaveNoParent;
+import static org.assertj.core.error.ShouldHaveParent.shouldHaveParent;
+import static org.assertj.core.error.ShouldNotExist.shouldNotExist;
+import static org.assertj.core.error.ShouldStartWithPath.shouldStartWith;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
+import java.util.List;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.util.FilesException;
+import org.assertj.core.util.PathsException;
+import org.assertj.core.util.VisibleForTesting;
+
+/**
+ * Core assertion class for {@link Path} assertions
+ */
+public class Paths {
+
+  private static final String FAILED_TO_RESOLVE_ARGUMENT_REAL_PATH = "failed to resolve argument real path";
+  private static final String FAILED_TO_RESOLVE_ACTUAL_REAL_PATH = "failed to resolve actual real path";
+  @VisibleForTesting
+  public static final String IOERROR_FORMAT = "I/O error attempting to process assertion for path: <%s>";
+
+  private static final Paths INSTANCE = new Paths();
+
+  @VisibleForTesting
+  Diff diff = new Diff();
+  @VisibleForTesting
+  BinaryDiff binaryDiff = new BinaryDiff();
+  @VisibleForTesting
+  Failures failures = Failures.instance();
+
+  private NioFilesWrapper nioFilesWrapper;
+
+  public static Paths instance() {
+	return INSTANCE;
+  }
+
+  @VisibleForTesting
+  Paths(NioFilesWrapper nioFilesWrapper) {
+	this.nioFilesWrapper = nioFilesWrapper;
+  }
+
+  private Paths() {
+	this(NioFilesWrapper.instance());
+  }
+
+  public void assertIsReadable(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	assertExists(info, actual);
+	if (!nioFilesWrapper.isReadable(actual)) throw failures.failure(info, shouldBeReadable(actual));
+  }
+
+  public void assertIsWritable(AssertionInfo info, Path actual) {
+	assertNotNull(info, actual);
+	assertExists(info, actual);
+	if (!nioFilesWrapper.isWritable(actual)) throw failures.failure(info, shouldBeWritable(actual));
+  }
+
+  public void assertIsExecutable(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	assertExists(info, actual);
+	if (!nioFilesWrapper.isExecutable(actual)) throw failures.failure(info, shouldBeExecutable(actual));
+  }
+
+  public void assertExists(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	if (!nioFilesWrapper.exists(actual)) throw failures.failure(info, shouldExist(actual));
+  }
+
+  public void assertExistsNoFollowLinks(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	if (!nioFilesWrapper.exists(actual, LinkOption.NOFOLLOW_LINKS))
+	  throw failures.failure(info, shouldExistNoFollowLinks(actual));
+  }
+
+  public void assertDoesNotExist(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	if (!nioFilesWrapper.notExists(actual, LinkOption.NOFOLLOW_LINKS))
+	  throw failures.failure(info, shouldNotExist(actual));
+  }
+
+  public void assertIsRegularFile(final AssertionInfo info, final Path actual) {
+	assertExists(info, actual);
+	if (!nioFilesWrapper.isRegularFile(actual)) throw failures.failure(info, shouldBeRegularFile(actual));
+  }
+
+  public void assertIsDirectory(final AssertionInfo info, final Path actual) {
+	assertExists(info, actual);
+	if (!nioFilesWrapper.isDirectory(actual)) throw failures.failure(info, shouldBeDirectory(actual));
+  }
+
+  public void assertIsSymbolicLink(final AssertionInfo info, final Path actual) {
+	assertExistsNoFollowLinks(info, actual);
+	if (!nioFilesWrapper.isSymbolicLink(actual)) throw failures.failure(info, shouldBeSymbolicLink(actual));
+  }
+
+  public void assertIsAbsolute(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	if (!actual.isAbsolute()) throw failures.failure(info, shouldBeAbsolutePath(actual));
+  }
+
+  public void assertIsRelative(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	if (actual.isAbsolute()) throw failures.failure(info, shouldBeRelativePath(actual));
+  }
+
+  public void assertIsNormalized(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	if (!actual.normalize().equals(actual)) throw failures.failure(info, shouldBeNormalized(actual));
+  }
+
+  public void assertIsCanonical(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	try {
+	  if (!actual.equals(actual.toRealPath())) throw failures.failure(info, shouldBeCanonicalPath(actual));
+	} catch (IOException e) {
+	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+	}
+  }
+
+  public void assertHasParent(final AssertionInfo info, final Path actual, final Path expected) {
+	assertNotNull(info, actual);
+	checkExpectedParentPathIsNotNull(expected);
+
+	final Path canonicalActual;
+	try {
+	  canonicalActual = actual.toRealPath();
+	} catch (IOException e) {
+	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+	}
+
+	final Path canonicalExpected;
+	try {
+	  canonicalExpected = expected.toRealPath();
+	} catch (IOException e) {
+	  throw new PathsException(FAILED_TO_RESOLVE_ARGUMENT_REAL_PATH, e);
+	}
+
+	final Path actualParent = canonicalActual.getParent();
+	if (actualParent == null) throw failures.failure(info, shouldHaveParent(actual, expected));
+	if (!actualParent.equals(canonicalExpected))
+	  throw failures.failure(info, shouldHaveParent(actual, actualParent, expected));
+  }
+
+  public void assertHasParentRaw(final AssertionInfo info, final Path actual, final Path expected) {
+	assertNotNull(info, actual);
+	checkExpectedParentPathIsNotNull(expected);
+
+	final Path actualParent = actual.getParent();
+	if (actualParent == null) throw failures.failure(info, shouldHaveParent(actual, expected));
+	if (!actualParent.equals(expected))
+	  throw failures.failure(info, shouldHaveParent(actual, actualParent, expected));
+  }
+
+  public void assertHasNoParent(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	try {
+	  final Path canonicalActual = actual.toRealPath();
+	  if (canonicalActual.getParent() != null) throw failures.failure(info, shouldHaveNoParent(actual));
+	} catch (IOException e) {
+	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+	}
+  }
+
+  public void assertHasNoParentRaw(final AssertionInfo info, final Path actual) {
+	assertNotNull(info, actual);
+	if (actual.getParent() != null) throw failures.failure(info, shouldHaveNoParent(actual));
+  }
+
+  public void assertStartsWith(final AssertionInfo info, final Path actual, final Path start) {
+	assertNotNull(info, actual);
+	assertExpectedStartPathIsNotNull(start);
+
+	final Path canonicalActual;
+	try {
+	  canonicalActual = actual.toRealPath();
+	} catch (IOException e) {
+	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+	}
+
+	final Path canonicalOther;
+	try {
+	  canonicalOther = start.toRealPath();
+	} catch (IOException e) {
+	  throw new PathsException(FAILED_TO_RESOLVE_ARGUMENT_REAL_PATH, e);
+	}
+
+	if (!canonicalActual.startsWith(canonicalOther)) throw failures.failure(info, shouldStartWith(actual, start));
+  }
+
+  public void assertStartsWithRaw(final AssertionInfo info, final Path actual, final Path other) {
+	assertNotNull(info, actual);
+	assertExpectedStartPathIsNotNull(other);
+	if (!actual.startsWith(other)) throw failures.failure(info, shouldStartWith(actual, other));
+  }
+
+  public void assertEndsWith(final AssertionInfo info, final Path actual, final Path end) {
+	assertNotNull(info, actual);
+	assertExpectedEndPathIsNotNull(end);
+	try {
+	  final Path canonicalActual = actual.toRealPath();
+	  if (!canonicalActual.endsWith(end.normalize())) throw failures.failure(info, shouldEndWith(actual, end));
+	} catch (IOException e) {
+	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+	}
+  }
+
+  public void assertEndsWithRaw(final AssertionInfo info, final Path actual, final Path end) {
+	assertNotNull(info, actual);
+	assertExpectedEndPathIsNotNull(end);
+	if (!actual.endsWith(end)) throw failures.failure(info, shouldEndWith(actual, end));
+  }
+
+  public void assertHasFileName(final AssertionInfo info, Path actual, String fileName) {
+	assertNotNull(info, actual);
+	if (fileName == null) throw new NullPointerException("expected fileName should not be null");
+	if (!actual.getFileName().endsWith(fileName)) throw failures.failure(info, shouldHaveName(actual, fileName));
+  }
+
+  private static void assertNotNull(final AssertionInfo info, final Path actual) {
+	Objects.instance().assertNotNull(info, actual);
+  }
+
+  private static void checkExpectedParentPathIsNotNull(final Path expected) {
+	if (expected == null) throw new NullPointerException("expected parent path should not be null");
+  }
+
+  private static void assertExpectedStartPathIsNotNull(final Path start) {
+	if (start == null) throw new NullPointerException("the expected start path should not be null");
+  }
+
+  private static void assertExpectedEndPathIsNotNull(final Path end) {
+	if (end == null) throw new NullPointerException("the expected end path should not be null");
+  }
+
+  public void assertHasContent(final AssertionInfo info, Path actual, String expected, Charset charset) {
+	if (expected == null) throw new NullPointerException("The text to compare to should not be null");
+	assertIsReadable(info, actual);
+	try {
+	  File actualAsFile = actual.toFile();
+	  List<String> diffs = diff.diff(actualAsFile, expected, charset);
+	  if (diffs.isEmpty()) return;
+	  throw failures.failure(info, shouldHaveContent(actualAsFile, charset, diffs));
+	} catch (IOException e) {
+	  throw new FilesException(format("Unable to verify text contents of file:<%s>", actual), e);
+	}
+  }
+
+  public void assertHasBinaryContent(AssertionInfo info, Path actual, byte[] expected) {
+	if (expected == null) throw new NullPointerException("The binary content to compare to should not be null");
+	assertIsReadable(info, actual);
+	File actualFile = actual.toFile();
+	try {
+	  BinaryDiffResult diffResult = binaryDiff.diff(actualFile, expected);
+	  if (diffResult.hasNoDiff()) return;
+	  throw failures.failure(info, shouldHaveBinaryContent(actualFile, diffResult));
+	} catch (IOException e) {
+	  throw new FilesException(format("Unable to verify binary contents of file:<%s>", actualFile), e);
+	}
+  }
+
+  public void assertHasSameContentAs(AssertionInfo info, Path actual, Path expected) {
+	// @format:off
+	if (expected == null) 
+	  throw new NullPointerException("The given Path to compare actual content to should not be null");
+	if (!nioFilesWrapper.isReadable(expected))
+	  throw new IllegalArgumentException(format("The given Path <%s> to compare actual content to should be readable", expected));
+	// @format:on
+	assertIsReadable(info, actual);
+	File expectedFile = expected.toFile();
+	File actualFile = actual.toFile();
+	try {
+	  List<String> diffs = diff.diff(actualFile, expectedFile);
+	  if (diffs.isEmpty()) return;
+	  throw failures.failure(info, shouldHaveEqualContent(actualFile, expectedFile, diffs));
+	} catch (IOException e) {
+	  throw new FilesException(format("Unable to compare contents of files:<%s> and:<%s>", actualFile, expectedFile), e);
+	}
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/util/PathsException.java b/src/main/java/org/assertj/core/util/PathsException.java
new file mode 100644
index 000000000..b999c0de3
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/PathsException.java
@@ -0,0 +1,24 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.util;
+
+public final class PathsException
+    extends RuntimeException
+{
+    // TODO: serialUID or not?
+
+    public PathsException(final String message, final Throwable cause)
+    {
+        super(message, cause);
+    }
+}
diff --git a/src/test/java/org/assertj/core/api/PathAssertBaseTest.java b/src/test/java/org/assertj/core/api/PathAssertBaseTest.java
new file mode 100644
index 000000000..2e3b19823
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/PathAssertBaseTest.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.mockito.Mockito.mock;
+
+import java.nio.charset.Charset;
+import java.nio.file.Path;
+
+import org.assertj.core.internal.Paths;
+
+
+/**
+ * Base class for {@link PathAssert} tests.
+ */
+public abstract class PathAssertBaseTest extends BaseTestTemplate<PathAssert, Path> {
+  
+  protected Paths paths;
+  protected Charset defaultCharset;
+  protected Charset otherCharset;
+
+  @Override
+  protected PathAssert create_assertions() {
+    return new PathAssert(mock(Path.class));
+  }
+
+  @Override
+  protected void inject_internal_objects() {
+    super.inject_internal_objects();
+    paths = mock(Paths.class);
+    assertions.paths = paths;
+    defaultCharset = Charset.defaultCharset();
+    for (Charset charset : Charset.availableCharsets().values()) {
+      if (!charset.equals(defaultCharset)) otherCharset = charset;
+    }
+  }
+
+  protected Charset getCharset(PathAssert someAssertions) {
+    return someAssertions.charset;
+  }
+
+  protected Paths getPaths(PathAssert someAssertions) {
+    return someAssertions.paths;
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_doesNotExist_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_doesNotExist_Test.java
new file mode 100644
index 000000000..b61c0358e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_doesNotExist_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_doesNotExist_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.doesNotExist();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertDoesNotExist(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_endsWithRaw_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_endsWithRaw_Test.java
new file mode 100644
index 000000000..55f42a7d5
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_endsWithRaw_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_endsWithRaw_Test extends PathAssertBaseTest {
+  
+  private final Path other = mock(Path.class);
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.endsWithRaw(other);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertEndsWithRaw(getInfo(assertions), getActual(assertions), other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_endsWith_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_endsWith_Test.java
new file mode 100644
index 000000000..620851adf
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_endsWith_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_endsWith_Test extends PathAssertBaseTest {
+  
+  private final Path other = mock(Path.class);
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.endsWith(other);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertEndsWith(getInfo(assertions), getActual(assertions), other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_existsNoFollowLinks_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_existsNoFollowLinks_Test.java
new file mode 100644
index 000000000..252ad733e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_existsNoFollowLinks_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_existsNoFollowLinks_Test extends PathAssertBaseTest {
+  
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.existsNoFollowLinks();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertExistsNoFollowLinks(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_exists_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_exists_Test.java
new file mode 100644
index 000000000..a8fe947db
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_exists_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_exists_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.exists();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertExists(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasBinaryContent_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasBinaryContent_Test.java
new file mode 100644
index 000000000..9c1153bf5
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasBinaryContent_Test.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.junit.BeforeClass;
+
+/**
+ * Tests for <code>{@link PathAssert#hasBinaryContent(byte[])}</code>.
+ */
+public class PathAssert_hasBinaryContent_Test extends PathAssertBaseTest {
+
+  private static byte[] expected;
+
+  @BeforeClass
+  public static void beforeOnce() {
+	expected = new byte[] { 0, 1 };
+  }
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.hasBinaryContent(expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertHasBinaryContent(getInfo(assertions), getActual(assertions), expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasContent_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasContent_Test.java
new file mode 100644
index 000000000..fcaab7422
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasContent_Test.java
@@ -0,0 +1,42 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.junit.BeforeClass;
+
+/**
+ * Tests for <code>{@link PathAssert#hasContent(String)}</code>.
+ */
+public class PathAssert_hasContent_Test extends PathAssertBaseTest {
+
+  private static String expected;
+
+  @BeforeClass
+  public static void beforeOnce() {
+    expected = "xyz";
+  }
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.hasContent(expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertHasContent(getInfo(assertions), getActual(assertions), expected, getCharset(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasFileName_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasFileName_Test.java
new file mode 100644
index 000000000..d33b5c4df
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasFileName_Test.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_hasFileName_Test extends PathAssertBaseTest {
+  
+  private final String other = "file.txt";
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.hasFileName(other);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertHasFileName(getInfo(assertions), getActual(assertions), other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasNoParentRaw_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasNoParentRaw_Test.java
new file mode 100644
index 000000000..dfc66fb4d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasNoParentRaw_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_hasNoParentRaw_Test extends PathAssertBaseTest {
+  
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.hasNoParentRaw();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertHasNoParentRaw(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasNoParent_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasNoParent_Test.java
new file mode 100644
index 000000000..a66b1eb3e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasNoParent_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_hasNoParent_Test extends PathAssertBaseTest {
+  
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.hasNoParent();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertHasNoParent(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasParentRaw_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasParentRaw_Test.java
new file mode 100644
index 000000000..b5cfaf618
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasParentRaw_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_hasParentRaw_Test extends PathAssertBaseTest {
+
+  private final Path expected = mock(Path.class);
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.hasParentRaw(expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertHasParentRaw(getInfo(assertions), getActual(assertions), expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasParent_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasParent_Test.java
new file mode 100644
index 000000000..8be9461b7
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasParent_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_hasParent_Test extends PathAssertBaseTest {
+
+  private final Path expected = mock(Path.class);
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.hasParent(expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertHasParent(getInfo(assertions), getActual(assertions), expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasSameContentAs_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasSameContentAs_Test.java
new file mode 100644
index 000000000..3a4115435
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasSameContentAs_Test.java
@@ -0,0 +1,45 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.junit.BeforeClass;
+
+/**
+ * Tests for <code>{@link PathAssert#hasSameContentAs(java.nio.file.Path)}</code>.
+ */
+public class PathAssert_hasSameContentAs_Test extends PathAssertBaseTest {
+
+  private static Path expected;
+
+  @BeforeClass
+  public static void beforeOnce() {
+	expected = mock(Path.class);
+  }
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.hasSameContentAs(expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertHasSameContentAs(getInfo(assertions), getActual(assertions), expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isAbsolute_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isAbsolute_Test.java
new file mode 100644
index 000000000..44b69a954
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isAbsolute_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_isAbsolute_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.isAbsolute();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertIsAbsolute(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isCanonical_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isCanonical_Test.java
new file mode 100644
index 000000000..0710a7730
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isCanonical_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_isCanonical_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.isCanonical();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertIsCanonical(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isDirectory_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isDirectory_Test.java
new file mode 100644
index 000000000..dc0f5f94c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isDirectory_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_isDirectory_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.isDirectory();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertIsDirectory(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isNormalized_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isNormalized_Test.java
new file mode 100644
index 000000000..c07cd11a6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isNormalized_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_isNormalized_Test extends PathAssertBaseTest {
+  
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.isNormalized();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertIsNormalized(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isReadable_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isReadable_Test.java
new file mode 100644
index 000000000..7d674e949
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isReadable_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_isReadable_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.isReadable();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertIsReadable(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isRegularFile_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isRegularFile_Test.java
new file mode 100644
index 000000000..d5c89aa08
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isRegularFile_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_isRegularFile_Test extends PathAssertBaseTest {
+  
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.isRegularFile();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertIsRegularFile(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isRelative_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isRelative_Test.java
new file mode 100644
index 000000000..642805733
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isRelative_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_isRelative_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.isRelative();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertIsRelative(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_isSymbolicLink_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_isSymbolicLink_Test.java
new file mode 100644
index 000000000..48612094c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_isSymbolicLink_Test.java
@@ -0,0 +1,31 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_isSymbolicLink_Test extends PathAssertBaseTest {
+  
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.isSymbolicLink();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertIsSymbolicLink(getInfo(assertions), getActual(assertions));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_startsWithRaw_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_startsWithRaw_Test.java
new file mode 100644
index 000000000..a253897fa
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_startsWithRaw_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_startsWithRaw_Test extends PathAssertBaseTest {
+
+  private final Path other = mock(Path.class);
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.startsWithRaw(other);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertStartsWithRaw(getInfo(assertions), getActual(assertions), other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_startsWith_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_startsWith_Test.java
new file mode 100644
index 000000000..1d6af32a0
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_startsWith_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.nio.file.Path;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+public class PathAssert_startsWith_Test extends PathAssertBaseTest {
+
+  private final Path other = mock(Path.class);
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	return assertions.startsWith(other);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	verify(paths).assertStartsWith(getInfo(assertions), getActual(assertions), other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_String_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_String_Test.java
new file mode 100644
index 000000000..6ffbb0507
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_String_Test.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+
+/**
+ * Test for <code>{@link PathAssert#usingCharset(String)}</code>.
+ */
+public class PathAssert_usingCharset_String_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.usingCharset(otherCharset.name());
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	assertThat(getCharset(assertions)).isEqualTo(otherCharset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_String_invalid_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_String_invalid_Test.java
new file mode 100644
index 000000000..b4467956e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_String_invalid_Test.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.assertj.core.test.ExpectedException.none;
+
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.assertj.core.test.ExpectedException;
+import org.junit.Rule;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link PathAssert#usingCharset(String)}</code> when the provided string is invalid.
+ */
+public class PathAssert_usingCharset_String_invalid_Test extends PathAssertBaseTest {
+
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Override
+  @Test
+  public void should_have_internal_effects() {
+    thrown.expectIllegalArgumentException("Charset:<'Klingon'> is not supported on this system");
+    assertions.usingCharset("Klingon");
+  }
+  
+  @Override
+  @Test
+  public void should_return_this() {
+    // Disable this test since the call fails
+  }
+  
+  @Override
+  protected PathAssert invoke_api_method() {
+    // not used here
+    return null;
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    // not used here
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_Test.java
new file mode 100644
index 000000000..d62c31550
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_Test.java
@@ -0,0 +1,37 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.nio.charset.Charset;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+
+/**
+ * Test for <code>{@link PathAssert#usingCharset(Charset)}</code>.
+ */
+public class PathAssert_usingCharset_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.usingCharset(otherCharset);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	assertThat(getCharset(assertions)).isEqualTo(otherCharset);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_default_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_default_Test.java
new file mode 100644
index 000000000..830b2e737
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_default_Test.java
@@ -0,0 +1,37 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.nio.charset.Charset;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+/**
+ * Tests the default charset for <code>{@link PathAssert}</code>.
+ */
+public class PathAssert_usingCharset_default_Test extends PathAssertBaseTest {
+
+  @Override
+  protected PathAssert invoke_api_method() {
+	// do nothing
+	return assertions;
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	assertThat(getCharset(assertions)).isEqualTo(Charset.defaultCharset());
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_null_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_null_Test.java
new file mode 100644
index 000000000..712d73d5c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_usingCharset_null_Test.java
@@ -0,0 +1,57 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.assertj.core.test.ExpectedException.none;
+
+import java.nio.charset.Charset;
+
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+import org.assertj.core.test.ExpectedException;
+import org.junit.Rule;
+import org.junit.Test;
+
+/**
+ * Test for <code>{@link PathAssert#usingCharset(Charset)}</code> when the provided charset is null.
+ */
+public class PathAssert_usingCharset_null_Test extends PathAssertBaseTest {
+
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Override
+  @Test
+  public void should_have_internal_effects() {
+    thrown.expectNullPointerException("The charset should not be null");
+    assertions.usingCharset((Charset) null);
+  }
+  
+  @Override
+  @Test
+  public void should_return_this() {
+    // Disable this test since the call fails
+  }
+  
+  @Override
+  protected PathAssert invoke_api_method() {
+    // not used here
+    return null;
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    // not used here
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeAbsolutePath_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeAbsolutePath_create_Test.java
index 14598f1ed..b5a3264a5 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeAbsolutePath_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeAbsolutePath_create_Test.java
@@ -12,14 +12,19 @@
  */
 package org.assertj.core.error;
 
-import static junit.framework.Assert.assertEquals;
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeAbsolutePath.SHOULD_BE_ABSOLUTE_PATH;
 import static org.assertj.core.error.ShouldBeAbsolutePath.shouldBeAbsolutePath;
+import static org.mockito.Mockito.mock;
 
+import java.nio.file.Path;
 
 import org.assertj.core.description.Description;
 import org.assertj.core.internal.TestDescription;
 import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.*;
+import org.junit.Before;
+import org.junit.Test;
 
 /**
  * Tests for <code>{@link ShouldBeAbsolutePath#create(Description, org.assertj.core.presentation.Representation)}</code>.
@@ -28,16 +33,35 @@ import org.junit.*;
  */
 public class ShouldBeAbsolutePath_create_Test {
 
+  private TestDescription description;
+  private StandardRepresentation representation;
+
   private ErrorMessageFactory factory;
+  private String actualMessage;
 
   @Before
   public void setUp() {
-    factory = shouldBeAbsolutePath(new FakeFile("xyz"));
+    description = new TestDescription("Test");
+    representation = new StandardRepresentation();
+  }
+
+  @Test
+  public void should_create_error_message_for_File_Object() {
+    final FakeFile file = new FakeFile("xyz");
+
+    factory = shouldBeAbsolutePath(file);
+    actualMessage = factory.create(description, representation);
+
+    assertThat(actualMessage).isEqualTo(format("[Test] " + SHOULD_BE_ABSOLUTE_PATH, file));
   }
 
   @Test
-  public void should_create_error_message() {
-    String message = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <xyz>\nto be an absolute path", message);
+  public void should_create_error_message_for_Path_object() {
+    final Path path = mock(Path.class);
+
+    factory = shouldBeAbsolutePath(path);
+    actualMessage = factory.create(description, representation);
+
+    assertThat(actualMessage).isEqualTo(format("[Test] " + SHOULD_BE_ABSOLUTE_PATH, path));
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeCanonicalPath_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeCanonicalPath_create_Test.java
new file mode 100644
index 000000000..10f8fcff6
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeCanonicalPath_create_Test.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeCanonicalPath.SHOULD_BE_CANONICAL;
+import static org.assertj.core.error.ShouldBeCanonicalPath.shouldBeCanonicalPath;
+import static org.mockito.Mockito.mock;
+
+import java.nio.file.Path;
+
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+public class ShouldBeCanonicalPath_create_Test {
+  
+  @Test
+  public void should_create_error_message() {
+	final Path actual = mock(Path.class);
+	ErrorMessageFactory factory = shouldBeCanonicalPath(actual);
+	
+	String actualMessage = factory.create(new TextDescription("Test"), new StandardRepresentation());
+
+	assertThat(actualMessage).isEqualTo(format("[Test] " + SHOULD_BE_CANONICAL, actual));
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeDirectory_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeDirectory_create_Test.java
index 128c3c22c..c1864f339 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeDirectory_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeDirectory_create_Test.java
@@ -12,32 +12,62 @@
  */
 package org.assertj.core.error;
 
+import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.Representation;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Before;
+import org.junit.Test;
+
+import java.io.File;
+import java.nio.file.Path;
+
 import static junit.framework.Assert.assertEquals;
+import static org.assertj.core.error.ShouldBeDirectory.FILE_SHOULD_BE_DIRECTORY;
+import static org.assertj.core.error.ShouldBeDirectory.PATH_SHOULD_BE_DIRECTORY;
 import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
+import static org.mockito.Mockito.mock;
 
+public class ShouldBeDirectory_create_Test
+{
+    private TestDescription description;
+    private Representation representation;
 
-import org.assertj.core.description.Description;
-import org.assertj.core.internal.TestDescription;
-import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.*;
+    private ErrorMessageFactory factory;
+    private String message;
+    private String expectedMessage;
 
-/**
- * Tests for <code>{@link ShouldBeDirectory#create(Description, org.assertj.core.presentation.Representation)}</code>.
- * 
- * @author Yvonne Wang
- */
-public class ShouldBeDirectory_create_Test {
+    @Before
+    public void setup()
+    {
+        description = new TestDescription("Test");
+        representation = new StandardRepresentation();
+    }
+
+    @Test
+    public void should_create_error_message_for_Path()
+    {
+        final Path path = mock(Path.class);
+
+        factory = shouldBeDirectory(path);
+        message = factory.create(description, representation);
+
+        expectedMessage = String.format("[Test] " + PATH_SHOULD_BE_DIRECTORY,
+            path);
+
+        assertEquals(expectedMessage, message);
+    }
+
+    @Test
+    public void should_create_error_message_for_File()
+    {
+        final File file = new FakeFile("xyz");
 
-  private ErrorMessageFactory factory;
+        factory = shouldBeDirectory(file);
+        message = factory.create(description, representation);
 
-  @Before
-  public void setUp() {
-    factory = shouldBeDirectory(new FakeFile("xyz"));
-  }
+        expectedMessage = String.format("[Test] " + FILE_SHOULD_BE_DIRECTORY,
+            file);
 
-  @Test
-  public void should_create_error_message() {
-    String message = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <xyz>\nto be an existing directory", message);
-  }
+        assertEquals(expectedMessage, message);
+    }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeExecutable_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeExecutable_create_Test.java
new file mode 100644
index 000000000..3762b9170
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeExecutable_create_Test.java
@@ -0,0 +1,58 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeExecutable.SHOULD_BE_EXECUTABLE;
+import static org.assertj.core.error.ShouldBeExecutable.shouldBeExecutable;
+import static org.mockito.Mockito.mock;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link ShouldBeExecutable}</code>.
+ * 
+ * @author Olivier Demeijer
+ * 
+ */
+
+public class ShouldBeExecutable_create_Test {
+  private static final TestDescription TEST_DESCRIPTION = new TestDescription("Test");
+  private static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
+
+  @Test
+  public void should_create_error_message_for_File() {
+	FakeFile file = new FakeFile("xyz");
+	ErrorMessageFactory factory = shouldBeExecutable(file);
+
+	String message = factory.create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+
+	assertThat(message).isEqualTo(format("[Test] " + SHOULD_BE_EXECUTABLE, file));
+  }
+
+  @Test
+  public void should_create_error_message_for_Path() throws IOException {
+	final Path path = mock(Path.class);
+	ErrorMessageFactory factory = shouldBeExecutable(path);
+
+	String message = factory.create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+
+	assertThat(message).isEqualTo(format("[Test] " + SHOULD_BE_EXECUTABLE, path));
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeNormalized_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeNormalized_create_Test.java
new file mode 100644
index 000000000..e7dc2dad2
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeNormalized_create_Test.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeNormalized.SHOULD_BE_NORMALIZED;
+import static org.assertj.core.error.ShouldBeNormalized.shouldBeNormalized;
+import static org.mockito.Mockito.mock;
+
+import java.nio.file.Path;
+
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+public class ShouldBeNormalized_create_Test {
+  
+  @Test
+  public void should_create_error_message() {
+	final Path actual = mock(Path.class);
+
+	ErrorMessageFactory factory = shouldBeNormalized(actual);
+	String actualMessage = factory.create(new TextDescription("Test"), new StandardRepresentation());
+
+	assertThat(actualMessage).isEqualTo(format("[Test] " + SHOULD_BE_NORMALIZED, actual));
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/error/ShouldBeReadable_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeReadable_create_Test.java
new file mode 100644
index 000000000..1e12e4409
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeReadable_create_Test.java
@@ -0,0 +1,52 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeReadable.SHOULD_BE_READABLE;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.mockito.Mockito.mock;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+public class ShouldBeReadable_create_Test {
+
+  private static final TestDescription TEST_DESCRIPTION = new TestDescription("Test");
+  private static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
+
+  @Test
+  public void should_create_error_message_for_File() {
+	FakeFile file = new FakeFile("xyz");
+	ErrorMessageFactory factory = shouldBeReadable(file);
+
+	String message = factory.create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+
+	assertThat(message).isEqualTo(format("[Test] " + SHOULD_BE_READABLE, file));
+  }
+
+  @Test
+  public void should_create_error_message_for_Path() throws IOException {
+	final Path path = mock(Path.class);
+	ErrorMessageFactory factory = shouldBeReadable(path);
+
+	String message = factory.create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+
+	assertThat(message).isEqualTo(format("[Test] " + SHOULD_BE_READABLE, path));
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeWritableTest.java b/src/test/java/org/assertj/core/error/ShouldBeRegularFile_create_Test.java
similarity index 51%
rename from src/test/java/org/assertj/core/error/ShouldBeWritableTest.java
rename to src/test/java/org/assertj/core/error/ShouldBeRegularFile_create_Test.java
index caf20ff49..177c1481f 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeWritableTest.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeRegularFile_create_Test.java
@@ -12,29 +12,27 @@
  */
 package org.assertj.core.error;
 
-import static org.assertj.core.error.ShouldBeWritable.shouldBeWritable;
-import static org.junit.Assert.assertEquals;
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeRegularFile.SHOULD_BE_REGULAR_FILE;
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.mockito.Mockito.mock;
 
-import org.assertj.core.internal.TestDescription;
+import java.nio.file.Path;
+
+import org.assertj.core.description.TextDescription;
 import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.Before;
 import org.junit.Test;
 
-/**
- * Tests for <code>{@link ShouldBeWritable}</code>.
- * 
- * @author Olivier Demeijer
- */
+public class ShouldBeRegularFile_create_Test {
+  
+  @Test
+  public void should_create_error_message() {
+    final Path actual = mock(Path.class);
 
-public class ShouldBeWritableTest {
-  ErrorMessageFactory factory;
-
-  @Before public void setup() {
-    factory = shouldBeWritable(new FakeFile("pathname"));
-  }
+    ErrorMessageFactory factory = shouldBeRegularFile(actual);
+    String actualMessage = factory.create(new TextDescription("Test"), new StandardRepresentation());
 
-  @Test public void createExpectedMessage() {
-    String actualMessage = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nFile:\n <pathname>\nshould be writable", actualMessage);
+    assertThat(actualMessage).isEqualTo(format("[Test] " + SHOULD_BE_REGULAR_FILE, actual));
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeRelativePath_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeRelativePath_create_Test.java
index 98377b700..4eb3d9cc3 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeRelativePath_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeRelativePath_create_Test.java
@@ -12,31 +12,46 @@
  */
 package org.assertj.core.error;
 
-import static junit.framework.Assert.assertEquals;
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeRelativePath.SHOULD_BE_RELATIVE_PATH;
 import static org.assertj.core.error.ShouldBeRelativePath.shouldBeRelativePath;
+import static org.mockito.Mockito.mock;
 
+import java.io.IOException;
+import java.nio.file.Path;
 
 import org.assertj.core.internal.TestDescription;
 import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.*;
+import org.junit.Test;
 
 /**
- * Tests for <code>{@link ShouldBeRelativePath#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
- * 
- * @author Yvonne Wang
+ * Tests for
+ * <code>{@link ShouldBeRelativePath#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>
+ * .
  */
 public class ShouldBeRelativePath_create_Test {
 
-  private ErrorMessageFactory factory;
+  private static final TestDescription TEST_DESCRIPTION = new TestDescription("Test");
+  private static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
 
-  @Before
-  public void setUp() {
-    factory = shouldBeRelativePath(new FakeFile("xyz"));
+  @Test
+  public void should_create_error_message_for_File() {
+	FakeFile file = new FakeFile("xyz");
+	ErrorMessageFactory factory = shouldBeRelativePath(file);
+	
+	String message = factory.create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+	
+	assertThat(message).isEqualTo(format("[Test] " + SHOULD_BE_RELATIVE_PATH, file));
   }
 
   @Test
-  public void should_create_error_message() {
-    String message = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting file:\n <xyz>\nto be a relative path", message);
+  public void should_create_error_message_for_Path() throws IOException {
+	final Path path = mock(Path.class);
+	ErrorMessageFactory factory = shouldBeRelativePath(path);
+
+	String message = factory.create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+
+	assertThat(message).isEqualTo(format("[Test] " + SHOULD_BE_RELATIVE_PATH, path));
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeSymbolicLink_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeSymbolicLink_create_Test.java
new file mode 100644
index 000000000..c1238a912
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeSymbolicLink_create_Test.java
@@ -0,0 +1,38 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeSymbolicLink.SHOULD_BE_SYMBOLIC_LINK;
+import static org.assertj.core.error.ShouldBeSymbolicLink.shouldBeSymbolicLink;
+import static org.mockito.Mockito.mock;
+
+import java.nio.file.Path;
+
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+public class ShouldBeSymbolicLink_create_Test {
+
+  @Test
+  public void should_create_error_message() {
+	final Path actual = mock(Path.class);
+	ErrorMessageFactory factory = shouldBeSymbolicLink(actual);
+	
+	String actualMessage = factory.create(new TextDescription("Test"), new StandardRepresentation());
+
+	assertThat(actualMessage).isEqualTo(format("[Test] " + SHOULD_BE_SYMBOLIC_LINK, actual));
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeWritable_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeWritable_create_Test.java
new file mode 100644
index 000000000..e207d8ba6
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeWritable_create_Test.java
@@ -0,0 +1,57 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeWritable.SHOULD_BE_WRITABLE;
+import static org.assertj.core.error.ShouldBeWritable.shouldBeWritable;
+import static org.mockito.Mockito.mock;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link ShouldBeWritable}</code>.
+ * 
+ * @author Olivier Demeijer
+ */
+
+public class ShouldBeWritable_create_Test {
+  private static final TestDescription TEST_DESCRIPTION = new TestDescription("Test");
+  private static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
+
+  @Test
+  public void should_create_error_message_for_File() {
+	FakeFile file = new FakeFile("xyz");
+	ErrorMessageFactory factory = shouldBeWritable(file);
+
+	String message = factory.create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+
+	assertThat(message).isEqualTo(format("[Test] " + SHOULD_BE_WRITABLE, file));
+  }
+
+  @Test
+  public void should_create_error_message_for_Path() throws IOException {
+	final Path path = mock(Path.class);
+	ErrorMessageFactory factory = shouldBeWritable(path);
+
+	String message = factory.create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+
+	assertThat(message).isEqualTo(format("[Test] " + SHOULD_BE_WRITABLE, path));
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeExecutableTest.java b/src/test/java/org/assertj/core/error/ShouldEndWithPath_create_Test.java
similarity index 51%
rename from src/test/java/org/assertj/core/error/ShouldBeExecutableTest.java
rename to src/test/java/org/assertj/core/error/ShouldEndWithPath_create_Test.java
index 211370199..5801ae98a 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeExecutableTest.java
+++ b/src/test/java/org/assertj/core/error/ShouldEndWithPath_create_Test.java
@@ -12,30 +12,26 @@
  */
 package org.assertj.core.error;
 
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldEndWithPath.PATH_SHOULD_END_WITH;
+import static org.assertj.core.error.ShouldEndWithPath.shouldEndWith;
+import static org.mockito.Mockito.mock;
 
+import java.nio.file.Path;
 
 import org.assertj.core.internal.TestDescription;
 import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.Before;
 import org.junit.Test;
 
-/**
- * Tests for <code>{@link ShouldBeExecutable}</code>.
- * 
- * @author Olivier Demeijer
- * 
- */
+public final class ShouldEndWithPath_create_Test {
 
-public class ShouldBeExecutableTest {
-  ErrorMessageFactory factory;
-
-  @Before public void setup() {
-    factory = ShouldBeExecutable.shouldBeExecutable(new FakeFile("pathname"));
+  @Test
+  public void should_create_error_message() {
+	final Path actual = mock(Path.class);
+	final Path other = mock(Path.class);
+	String actualMessage = shouldEndWith(actual, other).create(new TestDescription("Test"),
+	                                                           new StandardRepresentation());
+	assertThat(actualMessage).isEqualTo(String.format("[Test] " + PATH_SHOULD_END_WITH, actual, other));
   }
 
-  @Test public void createExpectedMessage() {
-    String actualMessage = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <pathname>\nto be executable", actualMessage);
-  }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldExist_create_Test.java b/src/test/java/org/assertj/core/error/ShouldExist_create_Test.java
index 295ea0e79..04df240c4 100644
--- a/src/test/java/org/assertj/core/error/ShouldExist_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldExist_create_Test.java
@@ -12,31 +12,73 @@
  */
 package org.assertj.core.error;
 
-import static junit.framework.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldExist.PATH_SHOULD_EXIST;
+import static org.assertj.core.error.ShouldExist.PATH_SHOULD_EXIST_NO_FOLLOW_LINKS;
 import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldExist.shouldExistNoFollowLinks;
+import static org.mockito.Mockito.mock;
 
+import java.nio.file.Path;
 
+import org.assertj.core.description.Description;
 import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.Representation;
 import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.*;
+import org.junit.Before;
+import org.junit.Test;
 
 /**
- * Tests for <code>{@link ShouldExist#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for {@link ShouldExist#create(Description, Representation)}
  * 
  * @author Yvonne Wang
  */
 public class ShouldExist_create_Test {
 
+  private TestDescription description;
+  private Representation representation;
+
   private ErrorMessageFactory factory;
+  private String actualMessage;
+  private String expectedMessage;
 
   @Before
   public void setUp() {
+    description = new TestDescription("Test");
+    representation = new StandardRepresentation();
+  }
+
+  @Test
+  public void should_create_error_message_for_File() {
     factory = shouldExist(new FakeFile("xyz"));
+    actualMessage = factory.create(description, representation);
+
+    expectedMessage = "[Test] \nExpecting file:\n  <xyz>\nto exist.";
+
+    assertThat(actualMessage).isEqualTo(expectedMessage);
   }
 
   @Test
-  public void should_create_error_message() {
-    String message = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting file:<xyz> to exist", message);
+  public void should_create_error_message_for_Path_following_symbolic_links() {
+    final Path actual = mock(Path.class);
+
+    factory = shouldExist(actual);
+    actualMessage = factory.create(description, representation);
+
+    expectedMessage = String.format("[Test] " + PATH_SHOULD_EXIST, actual);
+
+    assertThat(actualMessage).isEqualTo(expectedMessage);
+  }
+  
+  @Test
+  public void should_create_error_message_for_Path_not_following_symbolic_links() {
+	final Path actual = mock(Path.class);
+	
+	factory = shouldExistNoFollowLinks(actual);
+	actualMessage = factory.create(description, representation);
+	
+	expectedMessage = String.format("[Test] " + PATH_SHOULD_EXIST_NO_FOLLOW_LINKS, actual);
+	
+	assertThat(actualMessage).isEqualTo(expectedMessage);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveEqualContent_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveEqualContent_create_Test.java
index c70490ca3..16c8924d4 100644
--- a/src/test/java/org/assertj/core/error/ShouldHaveEqualContent_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldHaveEqualContent_create_Test.java
@@ -12,8 +12,8 @@
  */
 package org.assertj.core.error;
 
-import static junit.framework.Assert.assertEquals;
-
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveEqualContent.shouldHaveEqualContent;
 import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.SystemProperties.LINE_SEPARATOR;
 
@@ -25,45 +25,43 @@ import org.assertj.core.presentation.StandardRepresentation;
 import org.junit.Before;
 import org.junit.Test;
 
-
 /**
- * Tests for <code>{@link ShouldHaveEqualContent#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for
+ * <code>{@link ShouldHaveEqualContent#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>
+ * .
  * 
  * @author Yvonne Wang
  * @author Matthieu Baechler
  */
 public class ShouldHaveEqualContent_create_Test {
 
-  private ErrorMessageFactory factory;
   private List<String> diffs;
 
   @Before
   public void setUp() {
-    diffs = newArrayList("line:<0>, \nExpecting:\n<line0> but was:<line_0>", "line:<1>, \nExpecting:\n<line1> but was:<line_1>",
-        "line:<2>, \nExpecting:\n<line2> but was:<line_%s>");
+	diffs = newArrayList("line:<0>, \nExpecting:\n<line0> but was:<line_0>",
+	                     "line:<1>, \nExpecting:\n<line1> but was:<line_1>",
+	                     "line:<2>, \nExpecting:\n<line2> but was:<line_%s>");
   }
 
   @Test
   public void should_create_error_message_file_even_if_content_contains_format_specifier() {
-    factory = ShouldHaveEqualContent.shouldHaveEqualContent(new FakeFile("abc"), new FakeFile("xyz"), diffs);
-
-    StringBuilder b = new StringBuilder();
-    b.append("[Test] \nFile:\n <abc>\nand file:\n <xyz>\ndo not have equal content:");
-    for (String diff : diffs)
-      b.append(LINE_SEPARATOR).append(diff);
-    assertEquals(b.toString(), factory.create(new TextDescription("Test"), new StandardRepresentation()));
+	ErrorMessageFactory factory = shouldHaveEqualContent(new FakeFile("abc"), new FakeFile("xyz"), diffs);
+	StringBuilder b = new StringBuilder("[Test] \nFile:\n  <abc>\nand file:\n  <xyz>\ndo not have equal content:");
+	for (String diff : diffs)
+	  b.append(LINE_SEPARATOR).append(diff);
+	assertThat(factory.create(new TextDescription("Test"), new StandardRepresentation())).isEqualTo(b.toString());
   }
 
   @Test
   public void should_create_error_message_inputstream_even_if_content_contains_format_specifier() {
-    factory = ShouldHaveEqualContent.shouldHaveEqualContent(new ByteArrayInputStream(new byte[] { 'a' }),
-        new ByteArrayInputStream(new byte[] { 'b' }), diffs);
-
-    StringBuilder b = new StringBuilder();
-    b.append("[Test] \nInputStreams do not have equal content:");
-    for (String diff : diffs)
-      b.append(LINE_SEPARATOR).append(diff);
-    assertEquals(b.toString(), factory.create(new TextDescription("Test"), new StandardRepresentation()));
+	ErrorMessageFactory factory = shouldHaveEqualContent(new ByteArrayInputStream(new byte[] { 'a' }),
+	                                                     new ByteArrayInputStream(new byte[] { 'b' }),
+	                                                     diffs);
+	StringBuilder b = new StringBuilder("[Test] \nInputStreams do not have equal content:");
+	for (String diff : diffs)
+	  b.append(LINE_SEPARATOR).append(diff);
+	assertThat(factory.create(new TextDescription("Test"), new StandardRepresentation())).isEqualTo(b.toString());
   }
 
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveName_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveName_create_Test.java
index ed6611b57..acd90edec 100644
--- a/src/test/java/org/assertj/core/error/ShouldHaveName_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldHaveName_create_Test.java
@@ -40,7 +40,7 @@ public class ShouldHaveName_create_Test {
                                                         "to have name:%n" +
                                                         "  <\"" + expectedName + "\">%n" +
                                                         "but had:%n" +
-                                                        "  <\"actual-file\">."));
+                                                        "  <\"actual-file\">"));
   }
 
   private String createMessage() {
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveNoParent_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveNoParent_create_Test.java
index 5ca671cc3..a5a978af5 100644
--- a/src/test/java/org/assertj/core/error/ShouldHaveNoParent_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldHaveNoParent_create_Test.java
@@ -13,41 +13,73 @@
 package org.assertj.core.error;
 
 import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.Representation;
 import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Before;
 import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Mock;
-import org.mockito.runners.MockitoJUnitRunner;
 
 import java.io.File;
+import java.nio.file.Path;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveNoParent.FILE_HAS_PARENT;
+import static org.assertj.core.error.ShouldHaveNoParent.PATH_HAS_PARENT;
 import static org.assertj.core.error.ShouldHaveNoParent.shouldHaveNoParent;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 /**
- * Tests for <code>{@link org.assertj.core.error.ShouldHaveNoParent#shouldHaveNoParent(java.io.File)}</code>
+ * Tests for {@link ShouldHaveNoParent#shouldHaveNoParent(File)} and {@link ShouldHaveNoParent#shouldHaveNoParent(Path)}
  * 
  * @author Jean-Christophe Gay
+ * @author Francis Galiegue
  */
-@RunWith(MockitoJUnitRunner.class)
-public class ShouldHaveNoParent_create_Test {
+public class ShouldHaveNoParent_create_Test
+{
 
-  @Mock
-  private File actual;
+  private TestDescription description;
+  private Representation representation;
+
+  private ErrorMessageFactory factory;
+  private String actualMessage;
+  private String expectedMessage;
+
+  @Before
+  public void setup()
+  {
+	description = new TestDescription("Test");
+	representation = new StandardRepresentation();
+  }
 
   @Test
-  public void should_create_error_message_when_actual_does_not_have_a_parent() {
+  public void should_create_error_message_when_file_has_a_parent()
+  {
+	final File file = mock(File.class);
+	final FakeFile parent = new FakeFile("unexpected.parent");
+	when(file.getParentFile()).thenReturn(parent);
+	String fileAbsolutePath = "/path/to/file";
+	when(file.getAbsolutePath()).thenReturn(fileAbsolutePath);
+
+	factory = shouldHaveNoParent(file);
+	actualMessage = factory.create(description, representation);
 
-    when(actual.getParentFile()).thenReturn(new FakeFile("unexpected.parent"));
+	expectedMessage = String.format("[Test] " + FILE_HAS_PARENT, fileAbsolutePath, parent);
 
-    assertThat(createMessage()).isEqualTo(String.format(
-      "[TEST] %n" +
-      "Expecting file (or directory) without parent, but parent was:%n" +
-      "  <" + actual.getParentFile() + ">"));
+	assertThat(actualMessage).isEqualTo(expectedMessage);
   }
 
-  private String createMessage() {
-    return shouldHaveNoParent(actual).create(new TestDescription("TEST"), new StandardRepresentation());
+  @Test
+  public void should_create_error_message_when_path_has_a_parent()
+  {
+	final Path path = mock(Path.class);
+	final Path parent = mock(Path.class);
+	when(path.getParent()).thenReturn(parent);
+
+	factory = shouldHaveNoParent(path);
+	actualMessage = factory.create(description, representation);
+
+	expectedMessage = String.format("[Test] " + PATH_HAS_PARENT, path, parent);
+
+	assertThat(actualMessage).isEqualTo(expectedMessage);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveParent_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveParent_create_Test.java
index bd16cbc1d..b7c5b6f97 100644
--- a/src/test/java/org/assertj/core/error/ShouldHaveParent_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldHaveParent_create_Test.java
@@ -13,60 +13,107 @@
 package org.assertj.core.error;
 
 import org.assertj.core.internal.TestDescription;
+import org.assertj.core.presentation.Representation;
 import org.assertj.core.presentation.StandardRepresentation;
-
+import org.junit.Before;
 import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.mockito.Spy;
-import org.mockito.runners.MockitoJUnitRunner;
 
 import java.io.File;
+import java.nio.file.Path;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveParent.FILE_NOT_EXPECTED_PARENT;
+import static org.assertj.core.error.ShouldHaveParent.FILE_NO_PARENT;
+import static org.assertj.core.error.ShouldHaveParent.PATH_NOT_EXPECTED_PARENT;
+import static org.assertj.core.error.ShouldHaveParent.PATH_NO_PARENT;
 import static org.assertj.core.error.ShouldHaveParent.shouldHaveParent;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 
 /**
- * Tests for <code>{@link ShouldHaveParent#shouldHaveParent(java.io.File, java.io.File)}</code>
+ * Tests for {@link ShouldHaveParent#shouldHaveParent(File, File)} and {@link
+ * ShouldHaveParent#shouldHaveParent(Path, Path)}
  *
  * @author Jean-Christophe Gay
+ * @author Francis Galiegue
  */
-@RunWith(MockitoJUnitRunner.class)
-public class ShouldHaveParent_create_Test {
+public class ShouldHaveParent_create_Test
+{
+    private final File expectedFileParent = new FakeFile("expected.parent");
+    private final Path expectedPathParent = mock(Path.class);
+
+    private TestDescription description;
+    private Representation representation;
+
+    private ErrorMessageFactory factory;
+    private String actualMessage;
+    private String expectedMessage;
+
+    @Before
+    public void setup()
+    {
+        description = new TestDescription("Test");
+        representation = new StandardRepresentation();
+    }
+
+    @Test
+    public void should_create_error_message_when_file_has_no_parent()
+    {
+        final File actual = spy(new FakeFile("actual"));
+        when(actual.getParentFile()).thenReturn(null);
+
+        factory = shouldHaveParent(actual, expectedFileParent);
+        actualMessage = factory.create(description, representation);
+
+        expectedMessage = String.format("[Test] " + FILE_NO_PARENT,
+            actual, expectedFileParent);
+
+        assertThat(actualMessage).isEqualTo(expectedMessage);
+    }
+
+    @Test
+    public void should_create_error_message_when_file_does_not_have_expected_parent()
+    {
+        final File actual = spy(new FakeFile("actual"));
+        final FakeFile actualParent = new FakeFile("not.expected.parent");
+        when(actual.getParentFile()).thenReturn(actualParent);
+
+        factory = shouldHaveParent(actual, expectedFileParent);
+        actualMessage = factory.create(description, representation);
+
+        expectedMessage = String.format("[Test] " + FILE_NOT_EXPECTED_PARENT,
+            actual, expectedFileParent, actualParent);
 
-  @Spy
-  private File actual = new FakeFile("actual");
+        assertThat(actualMessage).isEqualTo(expectedMessage);
+    }
 
-  private File expectedParent = new FakeFile("expected.parent");
+    @Test
+    public void should_create_error_message_when_path_has_no_parent()
+    {
+        final Path actual = mock(Path.class);
 
-  @Test
-  public void should_create_error_message_when_actual_does_not_have_a_parent() {
+        factory = shouldHaveParent(actual, expectedPathParent);
+        actualMessage = factory.create(description, representation);
 
-    when(actual.getParentFile()).thenReturn(null);
+        expectedMessage = String.format("[Test] " + PATH_NO_PARENT,
+            actual, expectedPathParent);
 
-    assertThat(createMessage()).isEqualTo(String.format("[TEST] %n" +
-                                                        "Expecting file%n" +
-                                                        "  <" + actual + ">%n" +
-                                                        "to have parent:%n" +
-                                                        "  <" + expectedParent + ">%n" +
-                                                        "but did not have one."));
-  }
+        assertThat(actualMessage).isEqualTo(expectedMessage);
+    }
 
-  @Test
-  public void should_create_error_message_when_actual_does_not_have_expected_parent() throws Exception {
+    @Test
+    public void should_create_error_message_when_path_does_not_have_expected_parent()
+    {
+        final Path actual = mock(Path.class);
+        final Path actualParent = mock(Path.class);
 
-    when(actual.getParentFile()).thenReturn(new FakeFile("not.expected.parent"));
+        factory = shouldHaveParent(actual, actualParent, expectedPathParent);
+        actualMessage = factory.create(description, representation);
 
-    assertThat(createMessage()).isEqualTo(String.format("[TEST] %n" +
-                                                        "Expecting file%n" +
-                                                        "  <" + actual + ">%n" +
-                                                        "to have parent:%n" +
-                                                        "  <" + expectedParent + ">%n" +
-                                                        "but had:%n" +
-                                                        "  <" + actual.getParentFile() + ">."));
-  }
+        expectedMessage = String.format("[Test] " + PATH_NOT_EXPECTED_PARENT,
+            actual, expectedPathParent, actualParent);
 
-  private String createMessage() {
-    return shouldHaveParent(actual, expectedParent).create(new TestDescription("TEST"), new StandardRepresentation());
-  }
+        assertThat(actualMessage).isEqualTo(expectedMessage);
+    }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldNotExist_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotExist_create_Test.java
index 23e1f0327..e2051351a 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotExist_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotExist_create_Test.java
@@ -12,31 +12,62 @@
  */
 package org.assertj.core.error;
 
-import static junit.framework.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldNotExist.FILE_SHOULD_NOT_EXIST;
+import static org.assertj.core.error.ShouldNotExist.PATH_SHOULD_NOT_EXIST;
 import static org.assertj.core.error.ShouldNotExist.shouldNotExist;
+import static org.mockito.Mockito.mock;
 
+import java.nio.file.Path;
 
 import org.assertj.core.internal.TestDescription;
 import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.*;
+import org.junit.Before;
+import org.junit.Test;
 
 /**
- * Tests for <code>{@link ShouldNotExist#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for
+ * <code>{@link ShouldNotExist#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>
+ * .
  * 
  * @author Yvonne Wang
  */
 public class ShouldNotExist_create_Test {
 
+  private TestDescription description;
+  private StandardRepresentation representation;
+
   private ErrorMessageFactory factory;
+  private String actualMessage;
+  private String expectedMessage;
 
   @Before
   public void setUp() {
-    factory = shouldNotExist(new FakeFile("xyz"));
+	description = new TestDescription("Test");
+	representation = new StandardRepresentation();
+  }
+
+  @Test
+  public void should_create_error_message_for_File_object() {
+	final FakeFile file = new FakeFile("xyz");
+
+	factory = shouldNotExist(file);
+	actualMessage = factory.create(description, representation);
+
+	expectedMessage = String.format("[Test] " + FILE_SHOULD_NOT_EXIST, file);
+
+	assertThat(actualMessage).isEqualTo(expectedMessage);
   }
 
   @Test
-  public void should_create_error_message() {
-    String message = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting file:<xyz> not to exist", message);
+  public void should_create_error_message_for_Path_object() {
+	final Path path = mock(Path.class);
+
+	factory = shouldNotExist(path);
+	actualMessage = factory.create(description, representation);
+
+	expectedMessage = String.format("[Test] " + PATH_SHOULD_NOT_EXIST, path);
+
+	assertThat(actualMessage).isEqualTo(expectedMessage);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeReadableTest.java b/src/test/java/org/assertj/core/error/ShouldStartWithPath_create_Test.java
similarity index 51%
rename from src/test/java/org/assertj/core/error/ShouldBeReadableTest.java
rename to src/test/java/org/assertj/core/error/ShouldStartWithPath_create_Test.java
index 6b87bfb16..efbfb8a71 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeReadableTest.java
+++ b/src/test/java/org/assertj/core/error/ShouldStartWithPath_create_Test.java
@@ -12,30 +12,25 @@
  */
 package org.assertj.core.error;
 
-import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
-import static org.junit.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldStartWithPath.PATH_SHOULD_START_WITH;
+import static org.assertj.core.error.ShouldStartWithPath.shouldStartWith;
+import static org.mockito.Mockito.mock;
 
+import java.nio.file.Path;
 
 import org.assertj.core.internal.TestDescription;
 import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.Before;
 import org.junit.Test;
 
-/**
- * Tests for <code>{@link ShouldBeReadable}</code>.
- * 
- * @author Olivier Demeijer
- * 
- */
-public class ShouldBeReadableTest {
-  ErrorMessageFactory factory;
-
-  @Before public void setup() {
-    factory = shouldBeReadable(new FakeFile("pathname"));
-  }
+public final class ShouldStartWithPath_create_Test {
 
-  @Test public void createExpectedMessage() {
-    String actualMessage = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting file:\n <pathname>\nto be readable", actualMessage);
+  @Test
+  public void should_create_error_message() {
+	final Path actual = mock(Path.class);
+	final Path other = mock(Path.class);
+	String actualMessage = shouldStartWith(actual, other).create(new TestDescription("Test"),
+	                                                             new StandardRepresentation());
+	assertThat(actualMessage).isEqualTo(String.format("[Test] " + PATH_SHOULD_START_WITH, actual, other));
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/PathsBaseTest.java b/src/test/java/org/assertj/core/internal/PathsBaseTest.java
new file mode 100644
index 000000000..759497b8c
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/PathsBaseTest.java
@@ -0,0 +1,118 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.spy;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.FileSystem;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.test.ExpectedException;
+import org.junit.Before;
+import org.junit.ClassRule;
+import org.junit.Rule;
+import org.junit.rules.ExternalResource;
+
+import com.github.marschall.memoryfilesystem.MemoryFileSystemBuilder;
+
+/**
+ * Base test class for {@link Path} instances
+ *
+ * <p>
+ * Assertion on {@link Path} objects are of two categories:
+ * </p>
+ *
+ * <ul>
+ * <li>assertions on the {@link Path} object themselves: those do not require a {@link FileSystem};</li>
+ * <li>assertions inducing filesystem I/O: those <em>do</em> require a {@link FileSystem}.</li>
+ * </ul>
+ *
+ * <p>
+ * An advantage when compared with {@link File} is that we do not need to pollute the developer's machine with temporary
+ * files/directories/etc for I/O bound tests; all that is required is a filesystem implementation.
+ * </p>
+ *
+ * <p>
+ * <a href="https://github.com/marschall/memoryfilesystem">memoryfilesystem</a> is chosen for its great support of
+ * getting/setting file attributes etc, and for its emulation of both Unix and Windows filesystems.
+ * </p>
+ *
+ * @see Path
+ * @see FileSystem
+ * @see Files
+ */
+public abstract class PathsBaseTest {
+
+  @Rule
+  public ExpectedException thrown = none();
+  protected Failures failures;
+  protected Paths paths;
+  protected NioFilesWrapper nioFilesWrapper;
+  protected AssertionInfo info;
+
+  protected Diff diff;
+  protected BinaryDiff binaryDiff;
+
+  @Before
+  public void setUp() throws IOException {
+	failures = spy(new Failures());
+	nioFilesWrapper = mock(NioFilesWrapper.class);
+	paths = new Paths(nioFilesWrapper);
+	paths.failures = failures;
+	info = someInfo();
+	diff = mock(Diff.class);
+	paths.diff = diff;
+	binaryDiff = mock(BinaryDiff.class);
+	paths.binaryDiff = binaryDiff;
+  }
+
+  /**
+   * A {@link FileSystem} for test classes which need them
+   *
+   * <p>
+   * For test classes which do need a filesystem to test assertions and not only paths, declare a {@code static}
+   * instance field of this class as a {@link ClassRule} and initialize at declaration time.
+   * </p>
+   */
+  public static class FileSystemResource extends ExternalResource {
+
+	private final FileSystem fs;
+
+	public FileSystemResource() {
+	  try {
+		fs = MemoryFileSystemBuilder.newLinux().build("PathsTest");
+	  } catch (IOException e) {
+		throw new RuntimeException("failed to initialize filesystem", e);
+	  }
+	}
+
+	public FileSystem getFileSystem() {
+	  return fs;
+	}
+
+	@Override
+	protected void after() {
+	  try {
+		fs.close();
+	  } catch (IOException e) {
+		throw new RuntimeException("failed to close filesystem", e);
+	  }
+	}
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java b/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java
new file mode 100644
index 000000000..7c2986a5c
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.mockito.Mockito.mock;
+
+import java.nio.file.Path;
+
+import org.assertj.core.internal.PathsBaseTest;
+import org.junit.Before;
+
+public class MockPathsBaseTest extends PathsBaseTest {
+
+  Path actual;
+  Path other;
+
+  @Before
+  public void init() {
+	actual = mock(Path.class);
+	other = mock(Path.class);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertEndsWithRaw_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertEndsWithRaw_Test.java
new file mode 100644
index 000000000..d7cfef4a7
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertEndsWithRaw_Test.java
@@ -0,0 +1,62 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldEndWithPath.shouldEndWith;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertEndsWithRaw_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertEndsWithRaw(info, null, other);
+  }
+
+  @Test
+  public void should_fail_if_other_is_null() {
+	try {
+	  paths.assertEndsWithRaw(info, actual, null);
+	  fail("expected a NullPointerException here");
+	} catch (NullPointerException e) {
+	  assertThat(e).hasMessage("the expected end path should not be null");
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_end_with_other() {
+	// This is the default, but let's make this explicit
+	when(actual.endsWith(other)).thenReturn(false);
+
+	try {
+	  paths.assertEndsWithRaw(info, actual, other);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldEndWith(actual, other));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_ends_with_other() {
+	when(actual.endsWith(other)).thenReturn(true);
+
+	paths.assertEndsWithRaw(info, actual, other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertEndsWith_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertEndsWith_Test.java
new file mode 100644
index 000000000..dcc61eeb1
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertEndsWith_Test.java
@@ -0,0 +1,94 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static junit.framework.TestCase.fail;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldEndWithPath.shouldEndWith;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.util.PathsException;
+import org.junit.Test;
+
+public class Paths_assertEndsWith_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertEndsWith(info, null, other);
+  }
+
+  @Test
+  public void should_fail_if_other_is_null() {
+	try {
+	  paths.assertEndsWith(info, actual, null);
+	  fail("expected a NullPointerException here");
+	} catch (NullPointerException e) {
+	  assertThat(e).hasMessage("the expected end path should not be null");
+	}
+  }
+
+  @Test
+  public void should_fail_with_PathsException_if_actual_cannot_be_resolved() throws IOException {
+	final IOException causeException = new IOException();
+	when(actual.toRealPath()).thenThrow(causeException);
+
+	try {
+	  paths.assertEndsWith(info, actual, other);
+	  fail("expected a PathsException here");
+	} catch (PathsException e) {
+	  assertThat(e).hasMessage("failed to resolve actual real path");
+	  assertThat(e.getCause()).isSameAs(causeException);
+	}
+  }
+
+  @Test
+  public void should_fail_if_canonical_actual_does_not_end_with_normalized_other() throws IOException {
+	final Path canonicalActual = mock(Path.class);
+	final Path normalizedOther = mock(Path.class);
+
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(other.normalize()).thenReturn(normalizedOther);
+
+	// This is the default, but...
+	when(canonicalActual.endsWith(normalizedOther)).thenReturn(false);
+
+	try {
+	  paths.assertEndsWith(info, actual, other);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldEndWith(actual, other));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_canonical_actual_ends_with_normalized_other() throws IOException {
+	final Path canonicalActual = mock(Path.class);
+	final Path normalizedOther = mock(Path.class);
+
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(other.normalize()).thenReturn(normalizedOther);
+
+	// We want the canonical versions to be compared, not the arguments
+	when(canonicalActual.endsWith(normalizedOther)).thenReturn(true);
+
+	paths.assertEndsWith(info, actual, other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertExistsNoFollowLinks_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertExistsNoFollowLinks_Test.java
new file mode 100644
index 000000000..ca31fe3b7
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertExistsNoFollowLinks_Test.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldExist.shouldExistNoFollowLinks;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.nio.file.LinkOption;
+
+import org.junit.Test;
+
+public class Paths_assertExistsNoFollowLinks_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertExistsNoFollowLinks(info, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_exist() {
+	when(nioFilesWrapper.exists(actual, LinkOption.NOFOLLOW_LINKS)).thenReturn(false);
+	try {
+	  paths.assertExistsNoFollowLinks(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExistNoFollowLinks(actual));
+	}
+  }
+
+  @Test
+  public void should_pass_if_actual_exists() {
+	when(nioFilesWrapper.exists(actual, LinkOption.NOFOLLOW_LINKS)).thenReturn(true);
+	paths.assertExistsNoFollowLinks(info, actual);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertExists_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertExists_Test.java
new file mode 100644
index 000000000..6c71332e8
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertExists_Test.java
@@ -0,0 +1,48 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertExists_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertExists(info, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_exist() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(false);
+	try {
+	  paths.assertExists(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(actual));
+	}
+  }
+
+  @Test
+  public void should_pass_if_actual_exists() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	paths.assertExists(info, actual);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasBinaryContent_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasBinaryContent_Test.java
new file mode 100644
index 000000000..cb8b2ef81
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasBinaryContent_Test.java
@@ -0,0 +1,138 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Fail.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
+import static org.assertj.core.internal.BinaryDiffResult.noDiff;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.BinaryDiffResult;
+import org.assertj.core.internal.Paths;
+import org.assertj.core.internal.PathsBaseTest;
+import org.assertj.core.util.FilesException;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertHasBinaryContent(AssertionInfo, Path, byte[])}</code>.
+ */
+public class Paths_assertHasBinaryContent_Test extends PathsBaseTest {
+
+  private static Path path;
+  private static byte[] expected;
+  private Path mockPath;
+
+  @BeforeClass
+  public static void setUpOnce() {
+	// Does not matter if the values binaryDiffer, the actual comparison is mocked in this test
+	path = new File("src/test/resources/actual_file.txt").toPath();
+	expected = new byte[] { 0, 1 };
+  }
+
+  @Before
+  public void init() {
+	mockPath = mock(Path.class);
+  }
+  
+  @Test
+  public void should_pass_if_path_has_expected_text_content() throws IOException {
+	when(binaryDiff.diff(path.toFile(), expected)).thenReturn(noDiff());
+	when(nioFilesWrapper.exists(path)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(path)).thenReturn(true);
+	paths.assertHasBinaryContent(someInfo(), path, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+	thrown.expectNullPointerException("The binary content to compare to should not be null");
+	paths.assertHasBinaryContent(someInfo(), path, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertHasBinaryContent(someInfo(), null, expected);
+  }
+
+  @Test
+  public void should_fail_if_actual_path_does_not_exist() {
+	AssertionInfo info = someInfo();
+	when(nioFilesWrapper.exists(mockPath)).thenReturn(false);
+	try {
+	  paths.assertHasBinaryContent(info, mockPath, expected);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(mockPath));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_a_readable_file() {
+	AssertionInfo info = someInfo();
+	when(nioFilesWrapper.exists(mockPath)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(mockPath)).thenReturn(false);
+	try {
+	  paths.assertHasBinaryContent(info, mockPath, expected);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeReadable(mockPath));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+  
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+	IOException cause = new IOException();
+	when(binaryDiff.diff(path.toFile(), expected)).thenThrow(cause);
+	when(nioFilesWrapper.exists(path)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(path)).thenReturn(true);
+	try {
+	  paths.assertHasBinaryContent(someInfo(), path, expected);
+	  failBecauseExceptionWasNotThrown(FilesException.class);
+	} catch (FilesException e) {
+	  assertThat(e.getCause()).isSameAs(cause);
+	}
+  }
+
+  @Test
+  public void should_fail_if_path_does_not_have_expected_binary_content() throws IOException {
+	BinaryDiffResult binaryDiffs = new BinaryDiffResult(15, (byte) 0xCA, (byte) 0xFE);
+	when(binaryDiff.diff(path.toFile(), expected)).thenReturn(binaryDiffs);
+	when(nioFilesWrapper.exists(path)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(path)).thenReturn(true);
+	AssertionInfo info = someInfo();
+	try {
+	  paths.assertHasBinaryContent(info, path, expected);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveBinaryContent(path.toFile(), binaryDiffs));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasContent_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasContent_Test.java
new file mode 100644
index 000000000..7aca11ea4
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasContent_Test.java
@@ -0,0 +1,145 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Fail.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveContent.shouldHaveContent;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Lists.newArrayList;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.File;
+import java.io.IOException;
+import java.nio.charset.Charset;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Paths;
+import org.assertj.core.internal.PathsBaseTest;
+import org.assertj.core.util.FilesException;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertHasContent(AssertionInfo, Path, String, Charset)}</code>.
+ * 
+ * @author Olivier Michallat
+ * @author Joel Costigliola
+ */
+public class Paths_assertHasContent_Test extends PathsBaseTest {
+
+  private static Path path;
+  private static String expected;
+  private static Charset charset;
+  private Path mockPath;
+
+  @BeforeClass
+  public static void setUpOnce() {
+	// Does not matter if the values differ, the actual comparison is mocked in this test
+	path = new File("src/test/resources/actual_file.txt").toPath();
+	expected = "xyz";
+	charset = Charset.defaultCharset();
+  }
+
+  @Before
+  public void init() {
+	mockPath = mock(Path.class);
+  }
+  
+  @Test
+  public void should_pass_if_path_has_expected_text_content() throws IOException {
+	when(diff.diff(path.toFile(), expected, charset)).thenReturn(new ArrayList<String>());
+	when(nioFilesWrapper.exists(path)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(path)).thenReturn(true);
+	paths.assertHasContent(someInfo(), path, expected, charset);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+	thrown.expectNullPointerException("The text to compare to should not be null");
+	paths.assertHasContent(someInfo(), path, null, charset);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertHasContent(someInfo(), null, expected, charset);
+  }
+
+  @Test
+  public void should_fail_if_actual_path_does_not_exist() {
+	AssertionInfo info = someInfo();
+	when(nioFilesWrapper.exists(mockPath)).thenReturn(false);
+	try {
+	  paths.assertHasContent(info, mockPath, expected, charset);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(mockPath));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_a_readable_file() {
+	AssertionInfo info = someInfo();
+	when(nioFilesWrapper.exists(mockPath)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(mockPath)).thenReturn(false);
+	try {
+	  paths.assertHasContent(info, mockPath, expected, charset);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeReadable(mockPath));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+  
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+	IOException cause = new IOException();
+	when(diff.diff(path.toFile(), expected, charset)).thenThrow(cause);
+	when(nioFilesWrapper.exists(path)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(path)).thenReturn(true);
+	try {
+	  paths.assertHasContent(someInfo(), path, expected, charset);
+	  failBecauseExceptionWasNotThrown(FilesException.class);
+	} catch (FilesException e) {
+	  assertThat(e.getCause()).isSameAs(cause);
+	}
+  }
+
+  @Test
+  public void should_fail_if_path_does_not_have_expected_text_content() throws IOException {
+	List<String> diffs = newArrayList("line:1, expected:<line1> but was:<EOF>");
+	when(diff.diff(path.toFile(), expected, charset)).thenReturn(diffs);
+	when(nioFilesWrapper.exists(path)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(path)).thenReturn(true);
+	AssertionInfo info = someInfo();
+	try {
+	  paths.assertHasContent(info, path, expected, charset);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveContent(path.toFile(), charset, diffs));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasFileName_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasFileName_Test.java
new file mode 100644
index 000000000..a70c600e4
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasFileName_Test.java
@@ -0,0 +1,98 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.junit.Assert.fail;
+
+import java.io.IOException;
+import java.nio.file.FileSystem;
+import java.nio.file.Files;
+import java.nio.file.Path;
+
+import org.assertj.core.internal.PathsBaseTest;
+import org.junit.BeforeClass;
+import org.junit.ClassRule;
+import org.junit.Test;
+
+public class Paths_assertHasFileName_Test extends PathsBaseTest {
+
+  @ClassRule
+  public static FileSystemResource resource = new FileSystemResource();
+
+  private static Path existingFile;
+  private static Path symlinkToExistingFile;
+  private static Path nonExistingPath;
+  private static Path symlinkToNonExistingPath;
+  private static Path existingDirectory;
+  private static Path symlinkToExistingDirectory;
+  
+  @BeforeClass
+  public static void initPaths() throws IOException {
+
+	final FileSystem fs = resource.getFileSystem();
+
+	existingDirectory = fs.getPath("/dir1/dir2");
+	symlinkToExistingDirectory = fs.getPath("/symlinkToExistingDirectory");
+	Files.createDirectory(fs.getPath("/dir1"));
+	Files.createDirectory(existingDirectory);
+	Files.createSymbolicLink(symlinkToExistingDirectory, existingDirectory);
+
+	existingFile = fs.getPath("/dir1/dir2/gc.log");
+	symlinkToExistingFile = fs.getPath("/dir1/good-symlink");
+	Files.createFile(existingFile);
+	Files.createSymbolicLink(symlinkToExistingFile, existingFile);
+
+	nonExistingPath = fs.getPath("/dir1/fake.log");
+	symlinkToNonExistingPath = fs.getPath("/dir1/bad-symlink");
+	Files.createSymbolicLink(symlinkToNonExistingPath, nonExistingPath);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertHasFileName(info, null, "file.txt");
+  }
+
+  @Test
+  public void should_fail_if_given_file_name_is_null() {
+	try {
+	  paths.assertHasFileName(info, existingFile, null);
+	  fail("expected a NullPointerException here");
+	} catch (NullPointerException e) {
+	  assertThat(e).hasMessage("expected fileName should not be null");
+	}
+  }
+
+  @Test
+  public void should_pass_if_actual_file_has_the_given_file_name() {
+	paths.assertHasFileName(info, existingFile, "gc.log");
+  }
+  
+  @Test
+  public void should_pass_if_actual_non_existent_path_has_the_given_file_name() {
+	paths.assertHasFileName(info, nonExistingPath, "fake.log");
+  }
+  
+  @Test
+  public void should_pass_if_actual_symbolic_link_has_the_given_file_name() throws IOException {
+	paths.assertHasFileName(info, symlinkToNonExistingPath, "bad-symlink");
+	paths.assertHasFileName(info, symlinkToExistingFile, "good-symlink");
+  }
+  
+  @Test
+  public void should_pass_if_actual_directory_has_the_given_file_name() {
+	paths.assertHasFileName(info, existingDirectory, "dir2");
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasNoParentRaw_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasNoParentRaw_Test.java
new file mode 100644
index 000000000..7df5a81f4
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasNoParentRaw_Test.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldHaveNoParent.shouldHaveNoParent;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.junit.Test;
+
+public class Paths_assertHasNoParentRaw_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertHasNoParentRaw(info, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_has_parent() throws IOException {
+	final Path parent = mock(Path.class);
+	when(actual.getParent()).thenReturn(parent);
+
+	try {
+	  paths.assertHasNoParentRaw(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveNoParent(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_has_no_parent() throws IOException {
+	// This is the default, but let's make that clear
+	when(actual.getParent()).thenReturn(null);
+
+	paths.assertHasNoParentRaw(info, actual);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasNoParent_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasNoParent_Test.java
new file mode 100644
index 000000000..daccb8d16
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasNoParent_Test.java
@@ -0,0 +1,76 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static junit.framework.TestCase.fail;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveNoParent.shouldHaveNoParent;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.util.PathsException;
+import org.junit.Test;
+
+public class Paths_assertHasNoParent_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertHasNoParent(info, null);
+  }
+
+  @Test
+  public void should_throw_PathsException_if_actual_cannot_be_canonicalized() throws IOException {
+	final IOException exception = new IOException();
+	when(actual.toRealPath()).thenThrow(exception);
+
+	try {
+	  paths.assertHasNoParent(info, actual);
+	  fail("was expecting a PathsException");
+	} catch (PathsException e) {
+	  assertThat(e).hasMessage("failed to resolve actual real path");
+	  assertThat(e.getCause()).isSameAs(exception);
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_has_parent() throws IOException {
+	final Path canonicalActual = mock(Path.class);
+	final Path parent = mock(Path.class);
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(canonicalActual.getParent()).thenReturn(parent);
+
+	try {
+	  paths.assertHasNoParent(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveNoParent(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_has_no_parent() throws IOException {
+	final Path canonicalActual = mock(Path.class);
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	// This is the default, but let's make that clear
+	when(canonicalActual.getParent()).thenReturn(null);
+
+	paths.assertHasNoParent(info, actual);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasParentRaw_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasParentRaw_Test.java
new file mode 100644
index 000000000..32a56e688
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasParentRaw_Test.java
@@ -0,0 +1,88 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveParent.shouldHaveParent;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.junit.Before;
+import org.junit.Test;
+
+public class Paths_assertHasParentRaw_Test extends MockPathsBaseTest {
+
+  private Path expectedParent;
+
+  @Before
+  public void init() {
+	super.init();
+	expectedParent = mock(Path.class);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertHasParentRaw(info, null, expectedParent);
+  }
+
+  @Test
+  public void should_fail_if_provided_parent_is_null() {
+	try {
+	  paths.assertHasParentRaw(info, actual, null);
+	  fail("expected a NullPointerException here");
+	} catch (NullPointerException e) {
+	  assertThat(e).hasMessage("expected parent path should not be null");
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_has_no_parent() throws IOException {
+	// This is the default, but...
+	when(actual.getParent()).thenReturn(null);
+
+	try {
+	  paths.assertHasParentRaw(info, actual, expectedParent);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveParent(actual, expectedParent));
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_parent_is_not_expected_parent() throws IOException {
+	final Path actualParent = mock(Path.class);
+	when(actual.getParent()).thenReturn(actualParent);
+
+	try {
+	  paths.assertHasParentRaw(info, actual, expectedParent);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveParent(actual, actualParent, expectedParent));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_parent_is_expected_parent() {
+	when(actual.getParent()).thenReturn(expectedParent);
+
+	paths.assertHasParentRaw(info, actual, expectedParent);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasParent_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasParent_Test.java
new file mode 100644
index 000000000..5eea1f0b5
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasParent_Test.java
@@ -0,0 +1,133 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveParent.shouldHaveParent;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.util.PathsException;
+import org.junit.Before;
+import org.junit.Test;
+
+public class Paths_assertHasParent_Test extends MockPathsBaseTest {
+
+  private Path canonicalActual;
+  private Path expected;
+  private Path canonicalExpected;
+
+  @Before
+  public void init() {
+	super.init();
+	canonicalActual = mock(Path.class);
+	expected = mock(Path.class);
+	canonicalExpected = mock(Path.class);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertHasParent(info, null, expected);
+  }
+
+  @Test
+  public void should_fail_if_given_parent_is_null() {
+	try {
+	  paths.assertHasParent(info, actual, null);
+	  fail("expected a NullPointerException here");
+	} catch (NullPointerException e) {
+	  assertThat(e).hasMessage("expected parent path should not be null");
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_cannot_be_canonicalized() throws IOException {
+	final IOException exception = new IOException();
+	when(actual.toRealPath()).thenThrow(exception);
+
+	try {
+	  paths.assertHasParent(info, actual, expected);
+	  fail("expected a PathsException here");
+	} catch (PathsException e) {
+	  assertThat(e).hasMessage("failed to resolve actual real path");
+	  assertThat(e.getCause()).isSameAs(exception);
+	}
+  }
+
+  @Test
+  public void should_fail_if_expected_parent_cannot_be_canonicalized() throws IOException {
+	final IOException exception = new IOException();
+
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(expected.toRealPath()).thenThrow(exception);
+
+	try {
+	  paths.assertHasParent(info, actual, expected);
+	  fail("expected a PathsException here");
+	} catch (PathsException e) {
+	  assertThat(e).hasMessage("failed to resolve argument real path");
+	  assertThat(e.getCause()).isSameAs(exception);
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_has_no_parent() throws IOException {
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(expected.toRealPath()).thenReturn(canonicalExpected);
+
+	// This is the default, but...
+	when(canonicalActual.getParent()).thenReturn(null);
+
+	try {
+	  paths.assertHasParent(info, actual, expected);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveParent(actual, expected));
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_parent_is_not_expected_parent() throws IOException {
+	final Path actualParent = mock(Path.class);
+
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(expected.toRealPath()).thenReturn(canonicalExpected);
+
+	when(canonicalActual.getParent()).thenReturn(actualParent);
+
+	try {
+	  paths.assertHasParent(info, actual, expected);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveParent(actual, actualParent, expected));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_canonical_actual_has_expected_parent() throws IOException {
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(expected.toRealPath()).thenReturn(canonicalExpected);
+
+	when(canonicalActual.getParent()).thenReturn(canonicalExpected);
+
+	paths.assertHasParent(info, actual, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameContentAs_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameContentAs_Test.java
new file mode 100644
index 000000000..d29169a85
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasSameContentAs_Test.java
@@ -0,0 +1,137 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Fail.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveEqualContent.shouldHaveEqualContent;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Lists.newArrayList;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Paths;
+import org.assertj.core.util.FilesException;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertHasSameContentAs(AssertionInfo, Path, Path)}</code>.
+ */
+public class Paths_assertHasSameContentAs_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_pass_if_path_has_same_content_as_other() throws IOException {
+	when(diff.diff(actual.toFile(), other.toFile())).thenReturn(new ArrayList<String>());
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(actual)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
+	paths.assertHasSameContentAs(someInfo(), actual, other);
+  }
+
+  @Test
+  public void should_throw_error_if_other_is_null() {
+	thrown.expectNullPointerException("The given Path to compare actual content to should not be null");
+	paths.assertHasSameContentAs(someInfo(), actual, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
+	paths.assertHasSameContentAs(someInfo(), null, other);
+  }
+
+  @Test
+  public void should_fail_if_actual_path_does_not_exist() {
+	AssertionInfo info = someInfo();
+	when(nioFilesWrapper.exists(actual)).thenReturn(false);
+	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
+	try {
+	  paths.assertHasSameContentAs(info, actual, other);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(actual));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_a_readable_file() {
+	AssertionInfo info = someInfo();
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(actual)).thenReturn(false);
+	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
+	try {
+	  paths.assertHasSameContentAs(info, actual, other);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeReadable(actual));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+  
+  @Test
+  public void should_fail_if_other_is_not_a_readable_file() {
+	AssertionInfo info = someInfo();
+	when(nioFilesWrapper.isReadable(other)).thenReturn(false);
+	try {
+	  paths.assertHasSameContentAs(info, actual, other);
+	  failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+	} catch (IllegalArgumentException e) {
+	  assertThat(e).hasMessage(format("The given Path <%s> to compare actual content to should be readable", other));
+	}
+  }
+  
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+	IOException cause = new IOException();
+	when(diff.diff(actual.toFile(), other.toFile())).thenThrow(cause);
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(actual)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
+	try {
+	  paths.assertHasSameContentAs(someInfo(), actual, other);
+	  failBecauseExceptionWasNotThrown(FilesException.class);
+	} catch (FilesException e) {
+	  assertThat(e.getCause()).isSameAs(cause);
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_and_given_path_does_not_have_the_same_content() throws IOException {
+	List<String> diffs = newArrayList("line:1, other:<line1> but was:<EOF>");
+	when(diff.diff(actual.toFile(), other.toFile())).thenReturn(diffs);
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(actual)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(other)).thenReturn(true);
+	AssertionInfo info = someInfo();
+	try {
+	  paths.assertHasSameContentAs(info, actual, other);
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldHaveEqualContent(actual.toFile(), other.toFile(), diffs));
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsAbsolute_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsAbsolute_Test.java
new file mode 100644
index 000000000..2616bdcea
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsAbsolute_Test.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeAbsolutePath.shouldBeAbsolutePath;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertIsAbsolute_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsAbsolute(info, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_absolute() {
+	// This is the default, but make it explicit
+	when(actual.isAbsolute()).thenReturn(false);
+
+	try {
+	  paths.assertIsAbsolute(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeAbsolutePath(actual));
+	}
+  }
+
+  @Test
+  public void should_pass_if_actual_is_absolute() {
+	when(actual.isAbsolute()).thenReturn(true);
+	paths.assertIsAbsolute(info, actual);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsCanonical_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsCanonical_Test.java
new file mode 100644
index 000000000..ed4b0c95c
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsCanonical_Test.java
@@ -0,0 +1,70 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static junit.framework.TestCase.fail;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeCanonicalPath.shouldBeCanonicalPath;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.util.PathsException;
+import org.junit.Test;
+
+public class Paths_assertIsCanonical_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsCanonical(info, null);
+  }
+
+  @Test
+  public void should_throw_PathsException_on_io_error() throws IOException {
+	final IOException exception = new IOException();
+	when(actual.toRealPath()).thenThrow(exception);
+
+	try {
+	  paths.assertIsCanonical(info, actual);
+	  fail("Expected a PathsException here");
+	} catch (PathsException e) {
+	  assertThat(e).hasMessage("failed to resolve actual real path");
+	  assertThat(e.getCause()).isSameAs(exception);
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_real_path_differs_from_actual() throws IOException {
+	final Path other = mock(Path.class);
+	when(actual.toRealPath()).thenReturn(other);
+
+	try {
+	  paths.assertIsCanonical(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeCanonicalPath(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_real_path_is_same_as_actual() throws IOException {
+	when(actual.toRealPath()).thenReturn(actual);
+	paths.assertIsCanonical(info, actual);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectory_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectory_Test.java
new file mode 100644
index 000000000..e116cae0c
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsDirectory_Test.java
@@ -0,0 +1,62 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeDirectory.shouldBeDirectory;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertIsDirectory_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsDirectory(info, null);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(false);
+	try {
+	  paths.assertIsDirectory(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(actual));
+	}
+  }
+
+  @Test
+  public void should_fail_if_target_exists_but_is_not_a_directory() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isDirectory(actual)).thenReturn(false);
+	try {
+	  paths.assertIsDirectory(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeDirectory(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_is_a_directory() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isDirectory(actual)).thenReturn(true);
+	paths.assertIsDirectory(info, actual);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsExecutable_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsExecutable_Test.java
new file mode 100644
index 000000000..5cd6060d9
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsExecutable_Test.java
@@ -0,0 +1,62 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeExecutable.shouldBeExecutable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertIsExecutable_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsExecutable(info, null);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+	try {
+	  when(nioFilesWrapper.exists(actual)).thenReturn(false);
+	  paths.assertIsExecutable(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(actual));
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_executable() {
+	try {
+	  when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	  when(nioFilesWrapper.isExecutable(actual)).thenReturn(false);
+	  paths.assertIsExecutable(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeExecutable(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_exist_and_is_executable() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isExecutable(actual)).thenReturn(true);
+	paths.assertIsExecutable(info, actual);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNormalized_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNormalized_Test.java
new file mode 100644
index 000000000..8d736eaa3
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsNormalized_Test.java
@@ -0,0 +1,52 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeNormalized.shouldBeNormalized;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.nio.file.Path;
+
+import org.junit.Test;
+
+public class Paths_assertIsNormalized_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsNormalized(info, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_normalized() {
+	when(actual.normalize()).thenReturn(mock(Path.class));
+
+	try {
+	  paths.assertIsNormalized(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeNormalized(actual));
+	}
+  }
+
+  @Test
+  public void should_pass_if_actual_is_normalized() {
+	when(actual.normalize()).thenReturn(actual);
+
+	paths.assertIsNormalized(info, actual);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsReadable_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsReadable_Test.java
new file mode 100644
index 000000000..c0e4cfa74
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsReadable_Test.java
@@ -0,0 +1,62 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertIsReadable_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsReadable(info, null);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+	try {
+	  when(nioFilesWrapper.exists(actual)).thenReturn(false);
+	  paths.assertIsReadable(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(actual));
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+	try {
+	  when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	  when(nioFilesWrapper.isReadable(actual)).thenReturn(false);
+	  paths.assertIsReadable(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeReadable(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_exist_and_is_readable() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isReadable(actual)).thenReturn(true);
+	paths.assertIsReadable(info, actual);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsRegularFile_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsRegularFile_Test.java
new file mode 100644
index 000000000..c477c376a
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsRegularFile_Test.java
@@ -0,0 +1,61 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertIsRegularFile_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsRegularFile(info, null);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(false);
+	try {
+	  paths.assertIsRegularFile(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(actual));
+	}
+  }
+
+  @Test
+  public void should_fail_if_target_exists_but_is_not_a_regular_file() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isRegularFile(actual)).thenReturn(false);
+	try {
+	  paths.assertIsRegularFile(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeRegularFile(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_is_an_existing_regular_file() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isRegularFile(actual)).thenReturn(true);
+	paths.assertIsRegularFile(info, actual);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsRelative_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsRelative_Test.java
new file mode 100644
index 000000000..a21af3fa1
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsRelative_Test.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeRelativePath.shouldBeRelativePath;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertIsRelative_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsRelative(info, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_relative() {
+	// This is the default, but make it explicit
+	when(actual.isAbsolute()).thenReturn(true);
+
+	try {
+	  paths.assertIsRelative(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeRelativePath(actual));
+	}
+  }
+
+  @Test
+  public void should_pass_if_actual_is_relative() {
+	when(actual.isAbsolute()).thenReturn(false);
+	paths.assertIsRelative(info, actual);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsSymbolicLink_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsSymbolicLink_Test.java
new file mode 100644
index 000000000..ee5a6678c
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsSymbolicLink_Test.java
@@ -0,0 +1,63 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeSymbolicLink.shouldBeSymbolicLink;
+import static org.assertj.core.error.ShouldExist.shouldExistNoFollowLinks;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.nio.file.LinkOption;
+
+import org.junit.Test;
+
+public class Paths_assertIsSymbolicLink_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsSymbolicLink(info, null);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+	when(nioFilesWrapper.exists(actual, LinkOption.NOFOLLOW_LINKS)).thenReturn(false);
+	try {
+	  paths.assertIsSymbolicLink(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExistNoFollowLinks(actual));
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_a_symbolic_link() {
+	when(nioFilesWrapper.exists(actual, LinkOption.NOFOLLOW_LINKS)).thenReturn(true);
+	when(nioFilesWrapper.isSymbolicLink(actual)).thenReturn(false);
+	try {
+	  paths.assertIsSymbolicLink(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeSymbolicLink(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_is_a_symbolic_link() {
+	when(nioFilesWrapper.exists(actual, LinkOption.NOFOLLOW_LINKS)).thenReturn(true);
+	when(nioFilesWrapper.isSymbolicLink(actual)).thenReturn(true);
+	paths.assertIsSymbolicLink(info, actual);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertIsWritable_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsWritable_Test.java
new file mode 100644
index 000000000..8e866b590
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertIsWritable_Test.java
@@ -0,0 +1,62 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldBeWritable.shouldBeWritable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertIsWritable_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertIsWritable(info, null);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+	try {
+	  when(nioFilesWrapper.exists(actual)).thenReturn(false);
+	  paths.assertIsWritable(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldExist(actual));
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_writable() {
+	try {
+	  when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	  when(nioFilesWrapper.isWritable(actual)).thenReturn(false);
+	  paths.assertIsWritable(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldBeWritable(actual));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_exist_and_is_writable() {
+	when(nioFilesWrapper.exists(actual)).thenReturn(true);
+	when(nioFilesWrapper.isWritable(actual)).thenReturn(true);
+	paths.assertIsWritable(info, actual);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertNotExists_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertNotExists_Test.java
new file mode 100644
index 000000000..21e80867b
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertNotExists_Test.java
@@ -0,0 +1,50 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.error.ShouldNotExist.shouldNotExist;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.nio.file.LinkOption;
+
+import org.junit.Test;
+
+public class Paths_assertNotExists_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertDoesNotExist(info, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_exists() {
+	when(nioFilesWrapper.notExists(actual)).thenReturn(false);
+	try {
+	  paths.assertDoesNotExist(info, actual);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldNotExist(actual));
+	}
+  }
+
+  @Test
+  public void should_pass_if_actual_does_not_exists() {
+	when(nioFilesWrapper.notExists(actual, LinkOption.NOFOLLOW_LINKS)).thenReturn(true);
+	paths.assertDoesNotExist(info, actual);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertStartsWithRaw_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertStartsWithRaw_Test.java
new file mode 100644
index 000000000..b04f26a64
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertStartsWithRaw_Test.java
@@ -0,0 +1,62 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldStartWithPath.shouldStartWith;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import org.junit.Test;
+
+public class Paths_assertStartsWithRaw_Test extends MockPathsBaseTest {
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertStartsWithRaw(info, null, other);
+  }
+
+  @Test
+  public void should_fail_if_other_is_null() {
+	try {
+	  paths.assertStartsWithRaw(info, actual, null);
+	  fail("expected a NullPointerException here");
+	} catch (NullPointerException e) {
+	  assertThat(e).hasMessage("the expected start path should not be null");	  
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_start_with_other() {
+	// This is the default, but let's make this explicit
+	when(actual.startsWith(other)).thenReturn(false);
+
+	try {
+	  paths.assertStartsWithRaw(info, actual, other);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldStartWith(actual, other));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_starts_with_other() {
+	when(actual.startsWith(other)).thenReturn(true);
+
+	paths.assertStartsWithRaw(info, actual, other);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertStartsWith_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertStartsWith_Test.java
new file mode 100644
index 000000000..7229b74b0
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertStartsWith_Test.java
@@ -0,0 +1,114 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldStartWithPath.shouldStartWith;
+import static org.assertj.core.test.TestFailures.wasExpectingAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.junit.Assert.fail;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.when;
+
+import java.io.IOException;
+import java.nio.file.Path;
+
+import org.assertj.core.util.PathsException;
+import org.junit.Before;
+import org.junit.Test;
+
+public class Paths_assertStartsWith_Test extends MockPathsBaseTest {
+
+  private Path canonicalActual;
+  private Path canonicalOther;
+
+  @Before
+  public void init() {
+	super.init();
+	canonicalActual = mock(Path.class);
+	canonicalOther = mock(Path.class);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	thrown.expectAssertionError(actualIsNull());
+	paths.assertStartsWith(info, null, other);
+  }
+
+  @Test
+  public void should_fail_if_other_is_null() {
+	try {
+	  paths.assertStartsWith(info, actual, null);
+	  fail("expected a NullPointerException here");
+	} catch (NullPointerException e) {
+	  assertThat(e).hasMessage("the expected start path should not be null");
+	}
+  }
+
+  @Test
+  public void should_throw_PathsException_if_actual_cannot_be_resolved() throws IOException
+  {
+	final IOException exception = new IOException();
+	when(actual.toRealPath()).thenThrow(exception);
+
+	try {
+	  paths.assertStartsWith(info, actual, other);
+	  fail("was expecting a PathsException here");
+	} catch (PathsException e) {
+	  assertThat(e).hasMessage("failed to resolve actual real path");
+	  assertThat(e.getCause()).isSameAs(exception);
+	}
+  }
+
+  @Test
+  public void should_throw_PathsException_if_other_cannot_be_resolved() throws IOException {
+	final IOException exception = new IOException();
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(other.toRealPath()).thenThrow(exception);
+
+	try {
+	  paths.assertStartsWith(info, actual, other);
+	  fail("was expecting a PathsException here");
+	} catch (PathsException e) {
+	  assertThat(e).hasMessage("failed to resolve argument real path");
+	  assertThat(e.getCause()).isSameAs(exception);
+	}
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_start_with_other() throws IOException {
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(other.toRealPath()).thenReturn(canonicalOther);
+	// This is the default, but let's make this explicit
+	when(canonicalActual.startsWith(canonicalOther)).thenReturn(false);
+
+	try {
+	  paths.assertStartsWith(info, actual, other);
+	  wasExpectingAssertionError();
+	} catch (AssertionError e) {
+	  verify(failures).failure(info, shouldStartWith(actual, other));
+	}
+  }
+
+  @Test
+  public void should_succeed_if_actual_starts_with_other() throws IOException {
+	when(actual.toRealPath()).thenReturn(canonicalActual);
+	when(other.toRealPath()).thenReturn(canonicalOther);
+
+	when(canonicalActual.startsWith(canonicalOther)).thenReturn(true);
+
+	paths.assertStartsWith(info, actual, other);
+  }
+
+}
