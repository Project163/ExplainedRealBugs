diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index a15cddcad..a70dd5e4c 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -196,9 +196,6 @@ public class StandardRepresentation implements Representation {
     if (object instanceof LocalDateTime) return toStringOf((LocalDateTime) object);
     if (object instanceof OffsetDateTime) return toStringOf((OffsetDateTime) object);
     if (object instanceof ZonedDateTime) return toStringOf((ZonedDateTime) object);
-    if (object instanceof AtomicBoolean) return toStringOf((AtomicBoolean) object);
-    if (object instanceof AtomicInteger) return toStringOf((AtomicInteger) object);
-    if (object instanceof AtomicLong) return toStringOf((AtomicLong) object);
     if (object instanceof LongAdder) return toStringOf((LongAdder) object);
     if (object instanceof AtomicReference) return toStringOf((AtomicReference<?>) object);
     if (object instanceof AtomicMarkableReference) return toStringOf((AtomicMarkableReference<?>) object);
@@ -206,7 +203,6 @@ public class StandardRepresentation implements Representation {
     if (object instanceof AtomicIntegerFieldUpdater) return AtomicIntegerFieldUpdater.class.getSimpleName();
     if (object instanceof AtomicLongFieldUpdater) return AtomicLongFieldUpdater.class.getSimpleName();
     if (object instanceof AtomicReferenceFieldUpdater) return AtomicReferenceFieldUpdater.class.getSimpleName();
-    if (object instanceof Number) return toStringOf((Number) object);
     if (object instanceof File) return toStringOf((File) object);
     if (object instanceof Path) return fallbackToStringOf(object);
     if (object instanceof String) return toStringOf((String) object);
@@ -228,6 +224,10 @@ public class StandardRepresentation implements Representation {
     // ex: JsonNode is an Iterable that is best formatted with its own String
     // Path is another example but we can deal with it specifically as it is part of the JDK.
     if (object instanceof Iterable<?> && !hasOverriddenToString((Iterable<?>) object)) return smartFormat((Iterable<?>) object);
+    if (object instanceof AtomicInteger) return toStringOf((AtomicInteger) object);
+    if (object instanceof AtomicBoolean) return toStringOf((AtomicBoolean) object);
+    if (object instanceof AtomicLong) return toStringOf((AtomicLong) object);
+    if (object instanceof Number) return toStringOf((Number) object);
     return fallbackToStringOf(object);
   }
 
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
index a66e69d48..cfb14c2d3 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
@@ -33,15 +33,19 @@ import java.time.LocalDateTime;
 import java.time.OffsetDateTime;
 import java.time.ZoneOffset;
 import java.time.ZonedDateTime;
+import java.util.ArrayList;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.GregorianCalendar;
+import java.util.Iterator;
 import java.util.LinkedHashMap;
 import java.util.List;
+import java.util.ListIterator;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 import java.util.concurrent.atomic.AtomicLongFieldUpdater;
 import java.util.concurrent.atomic.AtomicMarkableReference;
@@ -384,6 +388,140 @@ class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresentationT
     then(durationRepresentation).isEqualTo(expectedDurationRepresentation);
   }
 
+  @Test
+  void should_fix_1483() {
+    // GIVEN
+    VolatileSizeArrayList<String> list = new VolatileSizeArrayList<>();
+    list.add("abc");
+    list.add("def");
+    // WHEN
+    String toString = toStringOf(list);
+    // THEN
+    assertThat(toString).isEqualTo("[\"abc\", \"def\"]");
+  }
+
+  class VolatileSizeArrayList<T> extends AtomicInteger implements List<T> {
+
+    private static final long serialVersionUID = 1L;
+    private final List<T> list = new ArrayList<>();
+
+    @Override
+    public int size() {
+      return list.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+      return list.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+      return list.contains(o);
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+      return list.iterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+      return list.toArray();
+    }
+
+    @Override
+    public T[] toArray(T[] a) {
+      return list.toArray(a);
+    }
+
+    @Override
+    public boolean add(T e) {
+      return list.add(e);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+      return list.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+      return list.containsAll(c);
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> c) {
+      return list.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends T> c) {
+      return list.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(Collection<?> c) {
+      return list.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(Collection<?> c) {
+      return list.retainAll(c);
+    }
+
+    @Override
+    public void clear() {
+      list.clear();
+    }
+
+    @Override
+    public T get(int index) {
+      return list.get(index);
+    }
+
+    @Override
+    public T set(int index, T element) {
+      return list.set(index, element);
+    }
+
+    @Override
+    public void add(int index, T element) {
+      list.add(index, element);
+    }
+
+    @Override
+    public T remove(int index) {
+      return list.remove(index);
+    }
+
+    @Override
+    public int indexOf(Object o) {
+      return list.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+      return list.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+      return list.listIterator();
+    }
+
+    @Override
+    public ListIterator<T> listIterator(int index) {
+      return list.listIterator(index);
+    }
+
+    @Override
+    public List<T> subList(int fromIndex, int toIndex) {
+      return list.subList(fromIndex, toIndex);
+    }
+
+  }
+
   private static Stream<Arguments> durations() {
     return Stream.of(Arguments.of(Duration.of(1L, MILLIS), "0.001S"),
                      Arguments.of(Duration.of(1234L, MILLIS), "1.234S"),
