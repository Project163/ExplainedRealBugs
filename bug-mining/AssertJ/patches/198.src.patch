diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index a948ce0a8..7fa3e0e13 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -47,6 +47,7 @@ import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.ObjectArrays;
 import org.assertj.core.internal.Objects;
 import org.assertj.core.internal.OnFieldsComparator;
+import org.assertj.core.internal.RecursiveFieldByFieldComparator;
 import org.assertj.core.util.IterableUtil;
 import org.assertj.core.util.Preconditions;
 import org.assertj.core.util.Strings;
@@ -62,7 +63,7 @@ import org.assertj.core.util.introspection.IntrospectionError;
  * @param <ACTUAL> the type of the "actual" value.
  * @param <ELEMENT> the type of elements of the "actual" value.
  * @param <ELEMENT_ASSERT> used for navigational assertions to return the right assert type.
- * 
+ *
  * @author Yvonne Wang
  * @author Alex Ruiz
  * @author Mathieu Baechler
@@ -74,9 +75,9 @@ import org.assertj.core.util.introspection.IntrospectionError;
  * @author Lovro Pandzic
  */
 //@format:off
-public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert<SELF, ACTUAL, ELEMENT, ELEMENT_ASSERT>, 
-                                             ACTUAL extends Iterable<? extends ELEMENT>, 
-                                             ELEMENT, 
+public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert<SELF, ACTUAL, ELEMENT, ELEMENT_ASSERT>,
+                                             ACTUAL extends Iterable<? extends ELEMENT>,
+                                             ELEMENT,
                                              ELEMENT_ASSERT extends AbstractAssert<ELEMENT_ASSERT, ELEMENT>>
        extends AbstractAssert<SELF, ACTUAL>
        implements ObjectEnumerableAssert<SELF, ELEMENT> {
@@ -391,10 +392,10 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <pre><code class='java'> List&lt;Number&gt; numbers = new ArrayList&lt;Number&gt;();
    * numbers.add(1);
    * numbers.add(2L);
-   * 
+   *
    * // successful assertion:
    * assertThat(numbers).hasAtLeastOneElementOfType(Long.class);
-   * 
+   *
    * // assertion failure:
    * assertThat(numbers).hasAtLeastOneElementOfType(Float.class);</code></pre>
    *
@@ -420,11 +421,11 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * numbers.add(1);
    * numbers.add(2);
    * numbers.add(3);
-   * 
+   *
    * // successful assertion:
    * assertThat(numbers).hasOnlyElementsOfType(Number.class);
    * assertThat(numbers).hasOnlyElementsOfType(Integer.class);
-   * 
+   *
    * // assertion failure:
    * assertThat(numbers).hasOnlyElementsOfType(Long.class);</code></pre>
    *
@@ -483,7 +484,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
-   * 
+   *
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
@@ -492,15 +493,15 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
-   * 
+   *
    * // let's verify the names of TolkienCharacter in fellowshipOfTheRing :
-   * 
+   *
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;)
    *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
    *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
-   * 
+   *
    * // you can extract nested property/field like the name of Race :
-   * 
+   *
    * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;)
    *                                .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
    *                                .doesNotContain(&quot;Orc&quot;);</code></pre>
@@ -522,29 +523,29 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <pre><code class='java'> Employee yoda = new Employee(1L, new Name("Yoda"), 800);
    * Employee luke = new Employee(2L, new Name("Luke"), 22);
    * Employee han = new Employee(3L, new Name("Han"), 31);
-   * 
+   *
    * // build two maps
    * Map&lt;String, Employee&gt; map1 = new HashMap&lt;&gt;();
    * map1.put("key1", yoda);
    * map1.put("key2", luke);
-   * 
+   *
    * Map&lt;String, Employee&gt; map2 = new HashMap&lt;&gt;();
    * map2.put("key1", yoda);
    * map2.put("key2", han);
-   * 
-   * // instead of a list of objects, we have a list of maps 
+   *
+   * // instead of a list of objects, we have a list of maps
    * List&lt;Map&lt;String, Employee&gt;&gt; maps = asList(map1, map2);
-   * 
+   *
    * // extracting a property in that case = get values from maps using property as a key
    * assertThat(maps).extracting("key2").containsExactly(luke, han);
    * assertThat(maps).extracting("key1").containsExactly(yoda, yoda);
-   * 
+   *
    * // type safe version
-   * assertThat(maps).extracting(key2, Employee.class).containsExactly(luke, han); 
-   * 
+   * assertThat(maps).extracting(key2, Employee.class).containsExactly(luke, han);
+   *
    * // it works with several keys, extracted values being wrapped in a Tuple
    * assertThat(maps).extracting("key1", "key2").containsExactly(tuple(yoda, luke), tuple(yoda, han));
-   * 
+   *
    * // unknown keys leads to null (map behavior)
    * assertThat(maps).extracting("bad key").containsExactly(null, null);</code></pre>
    *
@@ -568,7 +569,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <p>
    * Let's take an example to make things clearer :
    * <pre><code class='java'> // Build a array of WesterosHouse, a WesterosHouse has a method: public String sayTheWords()
-   * 
+   *
    * List&lt;WesterosHouse&gt; greatHouses = new ArrayList&lt;WesterosHouse&gt;();
    * greatHouses.add(new WesterosHouse(&quot;Stark&quot;, &quot;Winter is Coming&quot;));
    * greatHouses.add(new WesterosHouse(&quot;Lannister&quot;, &quot;Hear Me Roar!&quot;));
@@ -576,12 +577,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * greatHouses.add(new WesterosHouse(&quot;Baratheon&quot;, &quot;Our is the Fury&quot;));
    * greatHouses.add(new WesterosHouse(&quot;Martell&quot;, &quot;Unbowed, Unbent, Unbroken&quot;));
    * greatHouses.add(new WesterosHouse(&quot;Tyrell&quot;, &quot;Growing Strong&quot;));
-   * 
+   *
    * // let's verify the words of the great houses of Westeros:
    * assertThat(greatHouses).extractingResultOf(&quot;sayTheWords&quot;)
    *                        .contains(&quot;Winter is Coming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;)
    *                        .doesNotContain(&quot;Lannisters always pay their debts&quot;);</code></pre>
-   * 
+   *
    * Following requirements have to be met to extract method results:
    * <ul>
    * <li>method has to be public,</li>
@@ -619,12 +620,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * greatHouses.add(new WesterosHouse(&quot;Baratheon&quot;, &quot;Our is the Fury&quot;));
    * greatHouses.add(new WesterosHouse(&quot;Martell&quot;, &quot;Unbowed, Unbent, Unbroken&quot;));
    * greatHouses.add(new WesterosHouse(&quot;Tyrell&quot;, &quot;Growing Strong&quot;));
-   * 
+   *
    * // let's verify the words of the great houses of Westeros:
    * assertThat(greatHouses).extractingResultOf(&quot;sayTheWords&quot;, String.class)
    *                        .contains(&quot;Winter is Coming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;)
    *                        .doesNotContain(&quot;Lannisters always pay their debts&quot;);</code></pre>
-   * 
+   *
    * Following requirements have to be met to extract method results:
    * <ul>
    * <li>method has to be public,</li>
@@ -659,7 +660,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
-   * 
+   *
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
@@ -668,17 +669,17 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
-   * 
+   *
    * // let's verify the names of TolkienCharacter in fellowshipOfTheRing :
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, String.class)
    *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
    *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
-   * 
+   *
    * // you can extract nested property/field like the name of Race :
    * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;, String.class)
    *                                .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
    *                                .doesNotContain(&quot;Orc&quot;);</code></pre>
-   * 
+   *
    * A property with the given name is looked for first, if it doesn't exist then a field with the given name is looked
    * for, if the field does not exist an {@link IntrospectionError} is thrown, by default private fields are read but
    * you can change this with {@link Assertions#setAllowComparingPrivateFields(boolean)}, trying to read a private field
@@ -696,29 +697,29 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <pre><code class='java'> Employee yoda = new Employee(1L, new Name("Yoda"), 800);
    * Employee luke = new Employee(2L, new Name("Luke"), 22);
    * Employee han = new Employee(3L, new Name("Han"), 31);
-   * 
+   *
    * // build two maps
    * Map&lt;String, Employee&gt; map1 = new HashMap&lt;&gt;();
    * map1.put("key1", yoda);
    * map1.put("key2", luke);
-   * 
+   *
    * Map&lt;String, Employee&gt; map2 = new HashMap&lt;&gt;();
    * map2.put("key1", yoda);
    * map2.put("key2", han);
-   * 
-   * // instead of a list of objects, we have a list of maps 
+   *
+   * // instead of a list of objects, we have a list of maps
    * List&lt;Map&lt;String, Employee&gt;&gt; maps = asList(map1, map2);
-   * 
+   *
    * // extracting a property in that case = get values from maps using property as a key
-   * assertThat(maps).extracting(key2, Employee.class).containsExactly(luke, han); 
-   * 
+   * assertThat(maps).extracting(key2, Employee.class).containsExactly(luke, han);
+   *
    * // non type safe version
    * assertThat(maps).extracting("key2").containsExactly(luke, han);
    * assertThat(maps).extracting("key1").containsExactly(yoda, yoda);
-   * 
+   *
    * // it works with several keys, extracted values being wrapped in a Tuple
    * assertThat(maps).extracting("key1", "key2").containsExactly(tuple(yoda, luke), tuple(yoda, han));
-   * 
+   *
    * // unknown keys leads to null (map behavior)
    * assertThat(maps).extracting("bad key").containsExactly(null, null);</code></pre>
    *
@@ -749,7 +750,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
-   * 
+   *
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
@@ -758,20 +759,20 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
-   * 
+   *
    * // let's verify 'name' and 'age' of some TolkienCharacter in fellowshipOfTheRing :
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, &quot;age&quot;)
    *                                .contains(tuple(&quot;Boromir&quot;, 37),
    *                                          tuple(&quot;Sam&quot;, 38),
    *                                          tuple(&quot;Legolas&quot;, 1000));
-   * 
-   * 
+   *
+   *
    * // extract 'name', 'age' and Race name values :
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, &quot;age&quot;, &quot;race.name&quot;)
    *                                .contains(tuple(&quot;Boromir&quot;, 37, &quot;Man&quot;),
    *                                          tuple(&quot;Sam&quot;, 38, &quot;Hobbit&quot;),
    *                                          tuple(&quot;Legolas&quot;, 1000, &quot;Elf&quot;));</code></pre>
-   * 
+   *
    * A property with the given name is looked for first, if it doesn't exist then a field with the given name is looked
    * for, if the field does not exist an {@link IntrospectionError} is thrown, by default private fields are read but
    * you can change this with {@link Assertions#setAllowComparingPrivateFields(boolean)}, trying to read a private field
@@ -789,26 +790,26 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <pre><code class='java'> Employee yoda = new Employee(1L, new Name("Yoda"), 800);
    * Employee luke = new Employee(2L, new Name("Luke"), 22);
    * Employee han = new Employee(3L, new Name("Han"), 31);
-   * 
+   *
    * // build two maps
    * Map&lt;String, Employee&gt; map1 = new HashMap&lt;&gt;();
    * map1.put("key1", yoda);
    * map1.put("key2", luke);
-   * 
+   *
    * Map&lt;String, Employee&gt; map2 = new HashMap&lt;&gt;();
    * map2.put("key1", yoda);
    * map2.put("key2", han);
-   * 
-   * // instead of a list of objects, we have a list of maps 
+   *
+   * // instead of a list of objects, we have a list of maps
    * List&lt;Map&lt;String, Employee&gt;&gt; maps = asList(map1, map2);
-   * 
+   *
    * // extracting a property in that case = get values from maps using property as a key
    * assertThat(maps).extracting("key2").containsExactly(luke, han);
    * assertThat(maps).extracting("key1").containsExactly(yoda, yoda);
-   * 
+   *
    * // it works with several keys, extracted values being wrapped in a Tuple
    * assertThat(maps).extracting("key1", "key2").containsExactly(tuple(yoda, luke), tuple(yoda, han));
-   * 
+   *
    * // unknown keys leads to null (map behavior)
    * assertThat(maps).extracting("bad key").containsExactly(null, null);</code></pre>
    *
@@ -834,7 +835,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <pre><code class='java'> // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
    * // they can be public field or properties, both can be extracted.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
-   * 
+   *
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA));
@@ -843,7 +844,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
-   * 
+   *
    * // this extracts the race
    * Extractor&lt;TolkienCharacter, Race&gt; race = new Extractor&lt;TolkienCharacter, Race&gt;() {
    *    &commat;Override
@@ -851,14 +852,14 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *        return input.getRace();
    *    }
    * }
-   * 
+   *
    * // fellowship has hobbitses, right, my presioussss?
    * assertThat(fellowshipOfTheRing).extracting(race).contains(HOBBIT);</code></pre>
-   * 
+   *
    * Note that the order of extracted property/field values is consistent with the iteration order of the Iterable under
    * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted values
    * order.
-   * 
+   *
    * @param extractor the object transforming input object to desired one
    * @return a new assertion object whose object under test is the list of values extracted
    */
@@ -879,26 +880,26 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * CartoonCharacter maggie = new CartoonCharacter("Maggie Simpson");
    * CartoonCharacter homer = new CartoonCharacter("Homer Simpson");
    * homer.addChildren(bart, lisa, maggie);
-   * 
+   *
    * CartoonCharacter pebbles = new CartoonCharacter("Pebbles Flintstone");
    * CartoonCharacter fred = new CartoonCharacter("Fred Flintstone");
    * fred.getChildren().add(pebbles);
-   * 
+   *
    * Extractor&lt;CartoonCharacter, List&lt;CartoonCharacter&gt;&gt; childrenOf = new Extractor&lt;CartoonChildren, List&lt;CartoonChildren&gt;&gt;() {
    *    &commat;Override
    *    public List&lt;CartoonChildren&gt; extract(CartoonCharacter input) {
    *        return input.getChildren();
    *    }
    * }
-   * 
+   *
    * List&lt;CartoonCharacter&gt; parents = newArrayList(homer, fred);
    * // check children
    * assertThat(parent).flatExtracting(childrenOf)
    *                   .containsOnly(bart, lisa, maggie, pebbles);</code></pre>
-   * 
+   *
    * The order of extracted values is consisted with both the order of the collection itself, as well as the extracted
    * collections.
-   * 
+   *
    * @param extractor the object transforming input object to an Iterable of desired ones
    * @return a new assertion object whose object under test is the list of values extracted
    */
@@ -965,23 +966,23 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   }
 
   /**
-   * Extract the given properties/fields values from each {@code Iterable}'s element and 
+   * Extract the given properties/fields values from each {@code Iterable}'s element and
    * flatten the extracted values in a list that is used as the new object under test.
    * <p>
-   * Given 2 properties, if the extracted values were not flattened, instead having a simple list like : 
+   * Given 2 properties, if the extracted values were not flattened, instead having a simple list like :
    * <pre>element1.value1, element1.value2, element2.value1, element2.value2, ...  </pre>
-   * ... we would get a list of list : 
+   * ... we would get a list of list :
    * <pre>list(element1.value1, element1.value2), list(element2.value1, element2.value2), ...  </pre>
    * <p>
    * Code example:
    * <pre><code class='java'> // fellowshipOfTheRing is a List&lt;TolkienCharacter&gt;
-   * 
-   * // values are extracted in order and flattened : age1, name1, age2, name2, age3 ...  
+   *
+   * // values are extracted in order and flattened : age1, name1, age2, name2, age3 ...
    * assertThat(fellowshipOfTheRing).flatExtracting("age", "name")
-   *                                .contains(33 ,"Frodo", 
+   *                                .contains(33 ,"Frodo",
    *                                          1000, "Legolas",
    *                                          87, "Aragorn");</code></pre>
-   * 
+   *
    * @param extractors all the extractors to apply on each actual {@code Iterable}'s elements
    * @return a new assertion object whose object under test is a flattened list of all extracted values.
    * @throws IllegalArgumentException if fieldOrPropertyNames vararg is null or empty
@@ -1032,10 +1033,10 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
    * TolkienCharacter frodoClone = new TolkienCharacter("Frodo", 33, HOBBIT);
-   * 
+   *
    * // Fail if equals has not been overridden in TolkienCharacter as equals default implementation only compares references
    * assertThat(newArrayList(frodo)).contains(frodoClone);
-   * 
+   *
    * // frodo and frodoClone are equals when doing a field by field comparison.
    * assertThat(newArrayList(frodo)).usingFieldByFieldElementComparator().contains(frodoClone);</code></pre>
    *
@@ -1045,6 +1046,49 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return usingElementComparator(new FieldByFieldComparator());
   }
 
+  /**
+   * Use a recursive field/property by field/property comparison (including inherited fields/properties)
+   * instead of relying on actual type A <code>equals</code> method to compare group elements for incoming
+   * assertion checks. This can be useful if actual's {@code equals} implementation does not suit you.
+   * <p>
+   * The recursive property/field comparison is <b>not</b> applied on fields having a custom {@code equals}
+   * implementation, i.e. the overriden {@code equals} method will be used instead of a field/property by field/property comparison.
+   * <p>
+   * The recursive comparison handles cycle. {@code floats} are compared with a precision of 1.0E-6 and {@code doubles} with 1.0E-15.
+   * <p>
+   * The objects to compare can be of different types but must have the same properties/fields. For example if actual object has a
+   * {@code name} String field, the other object must also have one.
+   * <p>
+   * If an object has a field and a property with the same name, the property value will be used over the field.
+   * <p>
+   * Example:
+   * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
+   * TolkienCharacter pippin = new TolkienCharacter("Pippin", 28, HOBBIT);
+   * frodo.setFriend(pippin);
+   * pippin.setFriend(frodo);
+   *
+   * TolkienCharacter frodoClone = new TolkienCharacter("Frodo", 33, HOBBIT);
+   * TolkienCharacter pippinClone = new TolkienCharacter("Pippin", 28, HOBBIT);
+   * frodoClone.setFriend(pippinClone);
+   * pippinClone.setFriend(frodoClone);
+   *
+   * List&lt;TolkienCharacter&gt; hobbits = Arrays.asList(frodo, pippin);
+   *
+   * // fails if equals has not been overridden in TolkienCharacter as it would compares object references
+   * assertThat(hobbits).contains(frodoClone, pippinClone);
+   *
+   * // frodo/frodoClone and pippin/pippinClone are equals when doing a recursive property/field by property/field comparison
+   * assertThat(hobbits).usingRecursiveFieldByFieldElementComparator()
+   *                    .contains(frodoClone, pippinClone);</code>
+   * </pre>
+   *
+   * @return {@code this} assertion object.
+   * @since 2.5.0 / 3.5.0
+   */
+  public SELF usingRecursiveFieldByFieldElementComparator() {
+    return usingElementComparator(new RecursiveFieldByFieldComparator());
+  }
+
   /**
    * Use field/property by field/property comparison on the <b>given fields/properties only</b> (including inherited
    * fields/properties)instead of relying on actual type A <code>equals</code> method to compare group elements for
@@ -1059,10 +1103,10 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
    * TolkienCharacter sam = new TolkienCharacter("Sam", 38, HOBBIT);
-   * 
+   *
    * // frodo and sam both are hobbits, so they are equals when comparing only race
    * assertThat(newArrayList(frodo)).usingElementComparatorOnFields("race").contains(sam); // OK
-   * 
+   *
    * // ... but not when comparing both name and race
    * assertThat(newArrayList(frodo)).usingElementComparatorOnFields("name", "race").contains(sam); // FAIL</code></pre>
    *
@@ -1091,10 +1135,10 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
    * TolkienCharacter sam = new TolkienCharacter("Sam", 38, HOBBIT);
-   * 
+   *
    * // frodo and sam both are hobbits, so they are equals when comparing only race (i.e. ignoring all other fields)
    * assertThat(newArrayList(frodo)).usingElementComparatorIgnoringFields("name", "age").contains(sam); // OK
-   * 
+   *
    * // ... but not when comparing both name and race
    * assertThat(newArrayList(frodo)).usingElementComparatorIgnoringFields("age").contains(sam); // FAIL</code></pre>
    *
@@ -1114,7 +1158,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *
    * With standard error message:
    * <pre><code class='java'> assertThat(bytes).contains((byte)0x30);
-   * 
+   *
    * Expecting:
    *  <[16, 32]>
    * to contain:
@@ -1124,7 +1168,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *
    * With Hexadecimal error message:
    * <pre><code class='java'> assertThat(bytes).inHexadecimal().contains((byte)0x30);
-   * 
+   *
    * Expecting:
    *  <[0x10, 0x20]>
    * to contain:
@@ -1147,7 +1191,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *
    * With standard error message:
    * <pre><code class='java'> assertThat(bytes).contains((byte)0x30);
-   * 
+   *
    * Expecting:
    *  <[16, 32]>
    * to contain:
@@ -1157,7 +1201,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *
    * With binary error message:
    * <pre><code class='java'> assertThat(bytes).inBinary().contains((byte)0x30);
-   * 
+   *
    * Expecting:
    *  <[0b00010000, 0b00100000]>
    * to contain:
@@ -1184,25 +1228,25 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
    * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
    * <p>
-   * 
+   *
    * As an example, let's check all employees 800 years old (yes, special employees):
    * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
    * Employee noname = new Employee(4L, null, 50);
-   * 
+   *
    * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
    *
    * assertThat(employees).filteredOn("age", 800)
    *                      .containsOnly(yoda, obiwan);</code></pre>
-   *                      
+   *
    * Nested properties/fields are supported:
    * <pre><code class='java'> // Name is bean class with 'first' and 'last' String properties
    *
-   * // name is null for noname => it does not match the filter on "name.first" 
+   * // name is null for noname => it does not match the filter on "name.first"
    * assertThat(employees).filteredOn("name.first", "Luke")
    *                      .containsOnly(luke);
-   * 
+   *
    * assertThat(employees).filteredOn("name.last", "Vader")
    *                      .isEmpty();</code></pre>
    * <p>
@@ -1214,15 +1258,15 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <p>
    * You can chain filters:
    * <pre><code class='java'> // fellowshipOfTheRing is a list of TolkienCharacter having race and name fields
-   * // 'not' filter is statically imported from Assertions.not 
-   * 
+   * // 'not' filter is statically imported from Assertions.not
+   *
    * assertThat(fellowshipOfTheRing).filteredOn("race.name", "Man")
    *                                .filteredOn("name", not("Boromir"))
    *                                .containsOnly(aragorn);</code></pre>
-   * 
+   *
    * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
    * filter to apply.
-   * 
+   *
    * @param propertyOrFieldName the name of the property or field to read
    * @param expectedValue the value to compare element's property or field with
    * @return a new assertion object with the filtered iterable under test
@@ -1253,24 +1297,24 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
    * Employee noname = new Employee(4L, null, 50);
-   * 
+   *
    * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
    *
    * assertThat(employees).filteredOnNull("name")
    *                      .containsOnly(noname);</code></pre>
-   * 
+   *
    * Nested properties/fields are supported:
    * <pre><code class='java'> // Name is bean class with 'first' and 'last' String properties
    *
    * assertThat(employees).filteredOnNull("name.last")
    *                      .containsOnly(yoda, obiwan, noname);</code></pre>
-   * 
+   *
    * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the iterable
    * elements.
    * <p>
    * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
    * filter to apply.
-   * 
+   *
    * @param propertyOrFieldName the name of the property or field to read
    * @return a new assertion object with the filtered iterable under test
    * @throws IntrospectionError if the given propertyOrFieldName can't be found in one of the iterable elements.
@@ -1300,27 +1344,27 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
    * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
    * <p>
-   * 
+   *
    * As an example, let's check stuff on some special employees :
    * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
-   * 
+   *
    * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
    *
-   * // 'not' filter is statically imported from Assertions.not 
+   * // 'not' filter is statically imported from Assertions.not
    * assertThat(employees).filteredOn("age", not(800))
    *                      .containsOnly(luke);
-   * 
+   *
    * // 'in' filter is statically imported from Assertions.in
-   * // Name is bean class with 'first' and 'last' String properties 
+   * // Name is bean class with 'first' and 'last' String properties
    * assertThat(employees).filteredOn("name.first", in("Yoda", "Luke"))
    *                      .containsOnly(yoda, luke);
-   * 
+   *
    * // 'notIn' filter is statically imported from Assertions.notIn
    * assertThat(employees).filteredOn("name.first", notIn("Yoda", "Luke"))
    *                      .containsOnly(obiwan);</code></pre>
-   * 
+   *
    * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the iterable
    * elements.
    * <p>
@@ -1332,15 +1376,15 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <p>
    * You can chain filters:
    * <pre><code class='java'> // fellowshipOfTheRing is a list of TolkienCharacter having race and name fields
-   * // 'not' filter is statically imported from Assertions.not 
-   * 
+   * // 'not' filter is statically imported from Assertions.not
+   *
    * assertThat(fellowshipOfTheRing).filteredOn("race.name", "Man")
    *                                .filteredOn("name", not("Boromir"))
    *                                .containsOnly(aragorn);</code></pre>
-   * 
+   *
    * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
    * filter to apply.
-   * 
+   *
    * @param propertyOrFieldName the name of the property or field to read
    * @param filterOperator the filter operator to apply
    * @return a new assertion object with the filtered iterable under test
@@ -1363,11 +1407,11 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
    * Employee noname = new Employee(4L, null, 50);
-   * 
+   *
    * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
-   * 
+   *
    * // old employee condition, "old employees" describes the condition in error message
-   * // you just have to implement 'matches' method 
+   * // you just have to implement 'matches' method
    * Condition&lt;Employee&gt; oldEmployees = new Condition&lt;Employee&gt;("old employees") {
    *       {@literal @}Override
    *       public boolean matches(Employee employee) {
@@ -1377,12 +1421,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *   }
    * assertThat(employees).filteredOn(oldEmployees)
    *                      .containsOnly(yoda, obiwan);</code></pre>
-   * 
+   *
    * You can combine {@link Condition} with condition operator like {@link Not}:
    * <pre><code class='java'> // 'not' filter is statically imported from Assertions.not
    * assertThat(employees).filteredOn(not(oldEmployees))
    *                      .contains(luke, noname);</code></pre>
-   * 
+   *
    * @param condition the filter condition / predicate
    * @return a new assertion object with the filtered iterable under test
    * @throws IllegalArgumentException if the given condition is {@code null}.
@@ -1407,23 +1451,23 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * </ul>
    * <p>
    * Example: default {@code Object} assertions
-   * <pre><code class='java'> // default iterable assert => element assert is ObjectAssert 
+   * <pre><code class='java'> // default iterable assert => element assert is ObjectAssert
    * Iterable&lt;TolkienCharacter&gt; hobbits = newArrayList(frodo, sam, pippin);
-   * 
+   *
    * // assertion succeeds, only Object assertions are available after first()
    * assertThat(hobbits).first()
    *                    .isEqualTo(frodo);
-   * 
+   *
    * // assertion fails
    * assertThat(hobbits).first()
    *                    .isEqualTo(pippin);</code></pre>
    * <p>
-   * If you have created the Iterable assertion using an {@link AssertFactory} or the element assert class, 
+   * If you have created the Iterable assertion using an {@link AssertFactory} or the element assert class,
    * you will be able to chain {@code first()} with more specific typed assertion.
    * <p>
-   * Example: use of {@code String} assertions after {@code first()} 
+   * Example: use of {@code String} assertions after {@code first()}
    * <pre><code class='java'> Iterable&lt;String&gt; hobbits = newArrayList("frodo", "sam", "pippin");
-   * 
+   *
    * // assertion succeeds
    * // String assertions are available after first()
    * assertThat(hobbits, StringAssert.class).first()
@@ -1434,7 +1478,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *                                        .startsWith("pip");</code></pre>
    *
    * @return the assertion on the first element
-   * @throws AssertionError if the actual {@link Iterable} is empty. 
+   * @throws AssertionError if the actual {@link Iterable} is empty.
    * @since 2.5.0 / 3.5.0
    */
   public ELEMENT_ASSERT first() {
@@ -1453,23 +1497,23 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * </ul>
    * <p>
    * Example: default {@code Object} assertions
-   * <pre><code class='java'> // default iterable assert => element assert is ObjectAssert 
+   * <pre><code class='java'> // default iterable assert => element assert is ObjectAssert
    * Iterable&lt;TolkienCharacter&gt; hobbits = newArrayList(frodo, sam, pippin);
-   * 
+   *
    * // assertion succeeds, only Object assertions are available after last()
    * assertThat(hobbits).last()
    *                    .isEqualTo(pippin);
-   * 
+   *
    * // assertion fails
    * assertThat(hobbits).last()
    *                    .isEqualTo(frodo);</code></pre>
    * <p>
-   * If you have created the Iterable assertion using an {@link AssertFactory} or the element assert class, 
+   * If you have created the Iterable assertion using an {@link AssertFactory} or the element assert class,
    * you will be able to chain {@code last()} with more specific typed assertion.
    * <p>
-   * Example: use of {@code String} assertions after {@code last()} 
+   * Example: use of {@code String} assertions after {@code last()}
    * <pre><code class='java'> Iterable&lt;String&gt; hobbits = newArrayList("frodo", "sam", "pippin");
-   * 
+   *
    * // assertion succeeds
    * // String assertions are available after last()
    * assertThat(hobbits, StringAssert.class).last()
@@ -1480,8 +1524,8 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *                                        .startsWith("fro");</code></pre>
    *
    * @return the assertion on the first element
-   * @throws AssertionError if the actual {@link Iterable} is empty. 
-   * @since 2.5.0 / 3.5.0 
+   * @throws AssertionError if the actual {@link Iterable} is empty.
+   * @since 2.5.0 / 3.5.0
    */
   public ELEMENT_ASSERT last() {
     isNotEmpty();
@@ -1512,23 +1556,23 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * </ul>
    * <p>
    * Example: default {@code Object} assertions
-   * <pre><code class='java'> // default iterable assert => element assert is ObjectAssert 
+   * <pre><code class='java'> // default iterable assert => element assert is ObjectAssert
    * Iterable&lt;TolkienCharacter&gt; hobbits = newArrayList(frodo, sam, pippin);
-   * 
+   *
    * // assertion succeeds, only Object assertions are available after element(index)
    * assertThat(hobbits).element(1)
    *                    .isEqualTo(sam);
-   * 
+   *
    * // assertion fails
    * assertThat(hobbits).element(1)
    *                    .isEqualTo(pippin);</code></pre>
    * <p>
-   * If you have created the Iterable assertion using an {@link AssertFactory} or the element assert class, 
+   * If you have created the Iterable assertion using an {@link AssertFactory} or the element assert class,
    * you will be able to chain {@code element(index)} with more specific typed assertion.
    * <p>
-   * Example: use of {@code String} assertions after {@code element(index)} 
+   * Example: use of {@code String} assertions after {@code element(index)}
    * <pre><code class='java'> Iterable&lt;String&gt; hobbits = newArrayList("frodo", "sam", "pippin");
-   * 
+   *
    * // assertion succeeds
    * // String assertions are available after element(index)
    * assertThat(hobbits, StringAssert.class).element(1)
@@ -1746,22 +1790,22 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   /**
    * Return an {@code Assert} object that allows to perform assertions on the size of the {@link Iterable} under test.
    * <p>
-   * Once this method is called, the object under test is no more the initial {@link Iterable} but its size, 
-   * to perform assertions on the initial {@link Iterable}, call {@link AbstractIterableSizeAssert#returnToIterable()}. 
+   * Once this method is called, the object under test is no more the initial {@link Iterable} but its size,
+   * to perform assertions on the initial {@link Iterable}, call {@link AbstractIterableSizeAssert#returnToIterable()}.
    * <p>
    * Example:
    * <pre><code class='java'> Iterable&lt;Ring&gt; elvesRings = newArrayList(vilya, nenya, narya);
-   * 
+   *
    * // assertion will pass:
-   * assertThat(elvesRings).size().isGreaterThan(1)                
-   *                              .isLessThanOrEqualTo(3)          
-   *                       .returnToIterable().contains(narya)       
+   * assertThat(elvesRings).size().isGreaterThan(1)
+   *                              .isLessThanOrEqualTo(3)
+   *                       .returnToIterable().contains(narya)
    *                                          .doesNotContain(oneRing);
-   * 
+   *
    * // assertion will fail:
    * assertThat(elvesRings).size().isGreaterThan(3);</code></pre>
-   *   
-   * @return AbstractIterableSizeAssert built with the {@code Iterable}'s size. 
+   *
+   * @return AbstractIterableSizeAssert built with the {@code Iterable}'s size.
    * @throws NullPointerException if the given {@code Iterable} is {@code null}.
    */
   @SuppressWarnings({ "rawtypes", "unchecked" })
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 6eeb6e8c7..1bb176db5 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -42,6 +42,7 @@ import org.assertj.core.internal.ObjectArrayElementComparisonStrategy;
 import org.assertj.core.internal.ObjectArrays;
 import org.assertj.core.internal.Objects;
 import org.assertj.core.internal.OnFieldsComparator;
+import org.assertj.core.internal.RecursiveFieldByFieldComparator;
 import org.assertj.core.util.IterableUtil;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.introspection.IntrospectionError;
@@ -51,9 +52,9 @@ import org.assertj.core.util.introspection.IntrospectionError;
  * <p>
  * To create an instance of this class, invoke <code>{@link Assertions#assertThat(T[])}</code>.
  * </p>
- * 
+ *
  * @param <T> the type of elements of the "actual" value.
- * 
+ *
  * @author Yvonne Wang
  * @author Alex Ruiz
  * @author Joel Costigliola
@@ -75,7 +76,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
 
   /**
    * {@inheritDoc}
-   * 
+   *
    * @throws AssertionError {@inheritDoc}
    */
   @Override
@@ -85,7 +86,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
 
   /**
    * {@inheritDoc}
-   * 
+   *
    * @throws AssertionError {@inheritDoc}
    */
   @Override
@@ -95,7 +96,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
 
   /**
    * {@inheritDoc}
-   * 
+   *
    * @throws AssertionError {@inheritDoc}
    */
   @Override
@@ -106,7 +107,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
 
   /**
    * {@inheritDoc}
-   * 
+   *
    * @throws AssertionError {@inheritDoc}
    */
   @Override
@@ -122,11 +123,11 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Example:
    * <pre><code class='java'> int[] oneTwoThree = {1, 2, 3};
-   * int[] fourFiveSix = {4, 5, 6}; 
-   * 
+   * int[] fourFiveSix = {4, 5, 6};
+   *
    * // assertions will pass
    * assertThat(oneTwoThree).hasSameSizeAs(fourFiveSix);</code></pre>
-   * 
+   *
    * @param array the array to compare size with actual group.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual group is {@code null}.
@@ -145,11 +146,11 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Example:
    * <pre><code class='java'> int[] oneTwoThree = {1, 2, 3};
-   * Iterable&lt;Ring&gt; elvesRings = newArrayList(vilya, nenya, narya); 
-   * 
+   * Iterable&lt;Ring&gt; elvesRings = newArrayList(vilya, nenya, narya);
+   *
    * // assertions will pass
    * assertThat(oneTwoThree).hasSameSizeAs(elvesRings);</code></pre>
-   * 
+   *
    * @param other the {@code Iterable} to compare size with actual group.
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual group is {@code null}.
@@ -167,14 +168,14 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Example :
    * <pre><code class='java'> String[] abc = {"a", "b", "c"};
-   * 
+   *
    * // assertions will pass
    * assertThat(abc).contains("b", "a");
    * assertThat(abc).contains("b", "a", "b");
-   * 
+   *
    * // assertion will fail
    * assertThat(abc).contains("d");</code></pre>
-   * 
+   *
    * @param values the given values.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
@@ -196,10 +197,10 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *
    * // assertion will pass
    * assertThat(abc).containsOnly("c", "b", "a");
-   * 
+   *
    * // assertion will fail because "c" is missing
    * assertThat(abc).containsOnly("a", "b");</code></pre>
-   * 
+   *
    * @param values the given values.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
@@ -220,16 +221,16 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Example :
    * <pre><code class='java'> Ring[] rings = {nenya, vilya};
-   * 
+   *
    * // assertion will pass
    * assertThat(rings).containsOnlyElementsOf(newArrayList(nenya, vilya));
    * assertThat(rings).containsOnlyElementsOf(newArrayList(nenya, nenya, vilya, vilya));
-   * 
+   *
    * // assertion will fail as actual does not contain narya
    * assertThat(rings).containsOnlyElementsOf(newArrayList(nenya, vilya, narya));
    * // assertion will fail as actual contains nenya
    * assertThat(rings).containsOnlyElementsOf(newArrayList(vilya));</code></pre>
-   * 
+   *
    * @param iterable the given {@code Iterable} we will get elements from.
    */
   @Override
@@ -243,15 +244,15 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * </p>
    * Example:
    * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya};
-   * 
+   *
    * // assertions will pass:
    * assertThat(elvesRings).hasSameElementsAs(newArrayList(nenya, narya, vilya));
    * assertThat(elvesRings).hasSameElementsAs(newArrayList(nenya, narya, vilya, nenya));
-   * 
+   *
    * // assertions will fail:
    * assertThat(elvesRings).hasSameElementsAs(newArrayList(nenya, narya));
    * assertThat(elvesRings).hasSameElementsAs(newArrayList(nenya, narya, vilya, oneRing));</code></pre>
-   * 
+   *
    * @param iterable the {@code Iterable} whose elements we expect to be present
    * @return this assertion object
    * @throws AssertionError if the actual group is {@code null}
@@ -269,16 +270,16 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Examples :
    * <pre><code class='java'> // array if a factory method to create arrays.
-   * 
+   *
    * // assertions will pass
    * assertThat(array(&quot;winter&quot;, &quot;is&quot;, &quot;coming&quot;)).containsOnlyOnce(&quot;winter&quot;);
    * assertThat(array(&quot;winter&quot;, &quot;is&quot;, &quot;coming&quot;)).containsOnlyOnce(&quot;coming&quot;, &quot;winter&quot;);
-   * 
+   *
    * // assertions will fail
    * assertThat(array(&quot;winter&quot;, &quot;is&quot;, &quot;coming&quot;)).containsOnlyOnce(&quot;Lannister&quot;);
    * assertThat(array(&quot;Aria&quot;, &quot;Stark&quot;, &quot;daughter&quot;, &quot;of&quot;, &quot;Ned&quot;, &quot;Stark&quot;)).containsOnlyOnce(&quot;Stark&quot;);
    * assertThat(array(&quot;Aria&quot;, &quot;Stark&quot;, &quot;daughter&quot;, &quot;of&quot;, &quot;Ned&quot;, &quot;Stark&quot;)).containsOnlyOnce(&quot;Stark&quot;, &quot;Lannister&quot;, &quot;Aria&quot;);</code></pre>
-   * 
+   *
    * @param values the given values.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
@@ -298,13 +299,13 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Example :
    * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya};
-   * 
+   *
    * // assertion will pass
    * assertThat(elvesRings).containsExactly(vilya, nenya, narya);
-   * 
+   *
    * // assertion will fail as actual and expected order differ
    * assertThat(elvesRings).containsExactly(nenya, vilya, narya);</code></pre>
-   * 
+   *
    * @param values the given values.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
@@ -332,10 +333,10 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Example :
    * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya};
-   * 
+   *
    * // assertion will pass
    * assertThat(elvesRings).containsExactlyElementsOf(newLinkedList(vilya, nenya, narya));
-   * 
+   *
    * // assertion will fail as actual and expected order differ
    * assertThat(elvesRings).containsExactlyElementsOf(newLinkedList(nenya, vilya, narya));</code></pre>
    *
@@ -348,20 +349,20 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
 
   /**
    * Verifies that the actual array contains the given sequence in the correct order and <b>without extra value between the sequence values</b>.
-   * <p> 
+   * <p>
    * Use {@link #containsSubsequence(Object...)} to allow values between the expected sequence values.
    * <p>
    * Example:
    * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya};
-   * 
+   *
    * // assertion will pass
    * assertThat(elvesRings).containsSequence(vilya, nenya);
    * assertThat(elvesRings).containsSequence(nenya, narya);
-   * 
-   * // assertions will fail, the elements order is correct but there is a value between them (nenya) 
-   * assertThat(elvesRings).containsSequence(vilya, narya);  
+   *
+   * // assertions will fail, the elements order is correct but there is a value between them (nenya)
+   * assertThat(elvesRings).containsSequence(vilya, narya);
    * assertThat(elvesRings).containsSequence(nenya, vilya);</code></pre>
-   * 
+   *
    * @param sequence the sequence of objects to look for.
    * @return this assertion object.
    * @throws AssertionError if the actual group is {@code null}.
@@ -379,14 +380,14 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Example:
    * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya};
-   * 
+   *
    * // assertions will pass
    * assertThat(elvesRings).containsSubsequence(vilya, nenya);
    * assertThat(elvesRings).containsSubsequence(vilya, narya);
-   * 
+   *
    * // assertion will fail
    * assertThat(elvesRings).containsSubsequence(nenya, vilya);</code></pre>
-   * 
+   *
    * @param sequence the sequence of objects to look for.
    * @return this assertion object.
    * @throws AssertionError if the actual group is {@code null}.
@@ -462,16 +463,16 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that the actual array does not contain the given values.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc = {"a", "b", "c"}; 
+   * <pre><code class='java'> String[] abc = {"a", "b", "c"};
    *
    * // assertion will pass
    * assertThat(abc).doesNotContain("d", "e");
-   * 
+   *
    * // assertions will fail
    * assertThat(abc).doesNotContain("a");
    * assertThat(abc).doesNotContain("a", "b", "c");
    * assertThat(abc).doesNotContain("a", "x");</code></pre>
-   * 
+   *
    * @param values the given values.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
@@ -489,11 +490,11 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that the actual array does not contain any elements of the given {@link Iterable} (i.e. none).
    * <p>
    * Example:
-   * <pre><code class='java'> String[] abc = {"a", "b", "c"}; 
-   * 
+   * <pre><code class='java'> String[] abc = {"a", "b", "c"};
+   *
    * // assertion will pass
    * assertThat(actual).doesNotContainAnyElementsOf(newArrayList("d", "e"));
-   * 
+   *
    * // assertions will fail
    * assertThat(actual).doesNotContainAnyElementsOf(newArrayList("a", "b"));
    * assertThat(actual).doesNotContainAnyElementsOf(newArrayList("d", "e", "a"));</code></pre>
@@ -515,15 +516,15 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that the actual array does not contain duplicates.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc = {"a", "b", "c"}; 
-   * String[] lotsOfAs = {"a", "a", "a"}; 
+   * <pre><code class='java'> String[] abc = {"a", "b", "c"};
+   * String[] lotsOfAs = {"a", "a", "a"};
    *
    * // assertion will pass
    * assertThat(abc).doesNotHaveDuplicates();
-   * 
+   *
    * // assertion will fail
    * assertThat(lotsOfAs).doesNotHaveDuplicates();</code></pre>
-   * 
+   *
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual group is {@code null}.
    * @throws AssertionError if the actual group contains duplicates.
@@ -534,21 +535,20 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
     return myself;
   }
 
-
   /**
    * Verifies that the actual array starts with the given sequence of objects, without any other objects between them.
    * Similar to <code>{@link #containsSequence(Object...)}</code>, but it also verifies that the first element in the
    * sequence is also the first element of the actual array.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc = {"a", "b", "c"}; 
+   * <pre><code class='java'> String[] abc = {"a", "b", "c"};
    *
    * // assertion will pass
    * assertThat(abc).startsWith("a", "b");
-   * 
+   *
    * // assertion will fail
    * assertThat(abc).startsWith("c");</code></pre>
-   * 
+   *
    * @param sequence the sequence of objects to look for.
    * @return this assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
@@ -568,14 +568,14 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * sequence is also last element of the actual array.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc = {"a", "b", "c"}; 
+   * <pre><code class='java'> String[] abc = {"a", "b", "c"};
    *
    * // assertion will pass
    * assertThat(abc).endsWith("b", "c");
-   * 
+   *
    * // assertion will fail
    * assertThat(abc).endsWith("a");</code></pre>
-   * 
+   *
    * @param sequence the sequence of objects to look for.
    * @return this assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
@@ -593,15 +593,15 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that all elements of actual are present in the given {@code Iterable}.
    * <p>
    * Example:
-   * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya}; 
+   * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya};
    * List&lt;Ring&gt; ringsOfPower = newArrayList(oneRing, vilya, nenya, narya, dwarfRing, manRing);
-   * 
+   *
    * // assertion will pass:
    * assertThat(elvesRings).isSubsetOf(ringsOfPower);
-   * 
+   *
    * // assertion will fail:
    * assertThat(elvesRings).isSubsetOf(newArrayList(nenya, narya));</code></pre>
-   * 
+   *
    * @param values the {@code Iterable} that should contain all actual elements.
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Iterable} is {@code null}.
@@ -618,16 +618,16 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that all elements of actual are present in the given values.
    * <p>
    * Example:
-   * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya}; 
-   * 
+   * <pre><code class='java'> Ring[] elvesRings = {vilya, nenya, narya};
+   *
    * // assertions will pass:
    * assertThat(elvesRings).isSubsetOf(vilya, nenya, narya);
    * assertThat(elvesRings).isSubsetOf(vilya, nenya, narya, dwarfRing);
-   * 
+   *
    * // assertions will fail:
    * assertThat(elvesRings).isSubsetOf(vilya, nenya);
    * assertThat(elvesRings).isSubsetOf(vilya, nenya, dwarfRing);</code></pre>
-   * 
+   *
    * @param values the values that should be used for checking the elements of actual.
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Iterable} is {@code null}.
@@ -638,20 +638,20 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
     arrays.assertIsSubsetOf(info, actual, Arrays.asList(values));
     return myself;
   }
-  
+
   /**
    * Verifies that the actual array contains at least a null element.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc = {"a", "b", "c"}; 
-   * String[] abNull = {"a", "b", null}; 
+   * <pre><code class='java'> String[] abc = {"a", "b", "c"};
+   * String[] abNull = {"a", "b", null};
    *
    * // assertion will pass
    * assertThat(abNull).containsNull();
-   * 
+   *
    * // assertion will fail
    * assertThat(abc).containsNull();</code></pre>
-   * 
+   *
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual group is {@code null}.
    * @throws AssertionError if the actual group does not contain a null element.
@@ -666,15 +666,15 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that the actual array does not contain null elements.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc = {"a", "b", "c"}; 
-   * String[] abNull = {"a", "b", null}; 
+   * <pre><code class='java'> String[] abc = {"a", "b", "c"};
+   * String[] abNull = {"a", "b", null};
    *
    * // assertion will pass
    * assertThat(abc).doesNotContainNull();
    *
    * // assertion will fail
    * assertThat(abNull).doesNotContainNull();</code></pre>
-   * 
+   *
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual group is {@code null}.
    * @throws AssertionError if the actual group contains a null element.
@@ -689,15 +689,15 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that each element value satisfies the given condition
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc  = {"a", "b", "c"}; 
-   * String[] abcc = {"a", "b", "cc"}; 
-   * 
-   * Condition&lt;String&gt; singleCharacterString 
+   * <pre><code class='java'> String[] abc  = {"a", "b", "c"};
+   * String[] abcc = {"a", "b", "cc"};
+   *
+   * Condition&lt;String&gt; singleCharacterString
    *      = new Condition&lt;&gt;(s -> s.length() == 1, "single character String");
    *
    * // assertion will pass
    * assertThat(abc).are(singleCharacterString);
-   * 
+   *
    * // assertion will fail
    * assertThat(abcc).are(singleCharacterString);</code></pre>
    *
@@ -717,18 +717,18 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that each element value does not satisfy the given condition
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc  = {"a", "b", "c"}; 
-   * String[] abcc = {"a", "b", "cc"}; 
+   * <pre><code class='java'> String[] abc  = {"a", "b", "c"};
+   * String[] abcc = {"a", "b", "cc"};
    *
-   * Condition&lt;String&gt; moreThanOneCharacter = 
+   * Condition&lt;String&gt; moreThanOneCharacter =
    *     = new Condition&lt;&gt;(s -> s.length() > 1, "more than one character");
    *
    * // assertion will pass
    * assertThat(abc).areNot(moreThanOneCharacter);
-   * 
+   *
    * // assertion will fail
    * assertThat(abcc).areNot(moreThanOneCharacter);</code></pre>
-   * 
+   *
    * @param condition the given condition.
    * @return {@code this} object.
    * @throws NullPointerException if the given condition is {@code null}.
@@ -745,18 +745,18 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that all elements satisfy the given condition.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc  = {"a", "b", "c"}; 
-   * String[] abcc = {"a", "b", "cc"}; 
+   * <pre><code class='java'> String[] abc  = {"a", "b", "c"};
+   * String[] abcc = {"a", "b", "cc"};
    *
-   * Condition&lt;String&gt; onlyOneCharacter = 
+   * Condition&lt;String&gt; onlyOneCharacter =
    *     = new Condition&lt;&gt;(s -> s.length() == 1, "only one character");
    *
    * // assertion will pass
    * assertThat(abc).have(onlyOneCharacter);
-   * 
+   *
    * // assertion will fail
    * assertThat(abcc).have(onlyOneCharacter);</code></pre>
-   * 
+   *
    * @param condition the given condition.
    * @return {@code this} object.
    * @throws NullPointerException if the given condition is {@code null}.
@@ -773,18 +773,18 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that all elements don't satisfy the given condition.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc  = {"a", "b", "c"}; 
-   * String[] abcc = {"a", "b", "cc"}; 
+   * <pre><code class='java'> String[] abc  = {"a", "b", "c"};
+   * String[] abcc = {"a", "b", "cc"};
    *
-   * Condition&lt;String&gt; moreThanOneCharacter = 
+   * Condition&lt;String&gt; moreThanOneCharacter =
    *     = new Condition&lt;&gt;(s -> s.length() > 1, "more than one character");
    *
    * // assertion will pass
    * assertThat(abc).doNotHave(moreThanOneCharacter);
-   * 
+   *
    * // assertion will fail
    * assertThat(abcc).doNotHave(moreThanOneCharacter);</code></pre>
-   * 
+   *
    * @param condition the given condition.
    * @return {@code this} object.
    * @throws NullPointerException if the given condition is {@code null}.
@@ -807,10 +807,10 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *
    * // assertion will pass
    * oneTwoThree.areAtLeast(2, oddNumber);
-   * 
+   *
    * // assertion will fail
    * oneTwoThree.areAtLeast(3, oddNumber);</code></pre>
-   * 
+   *
    * @param n the minimum number of times the condition should be verified.
    * @param condition the given condition.
    * @return {@code this} object.
@@ -852,10 +852,10 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * // assertions will pass
    * oneTwoThree.areAtMost(2, oddNumber);
    * oneTwoThree.areAtMost(3, oddNumber);
-   * 
+   *
    * // assertion will fail
    * oneTwoThree.areAtMost(1, oddNumber);</code></pre>
-   * 
+   *
    * @param n the number of times the condition should be at most verified.
    * @param condition the given condition.
    * @return {@code this} object.
@@ -879,11 +879,11 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *
    * // assertion will pass
    * oneTwoThree.areExactly(2, oddNumber);
-   * 
+   *
    * // assertions will fail
    * oneTwoThree.areExactly(1, oddNumber);
    * oneTwoThree.areExactly(3, oddNumber);</code></pre>
-   * 
+   *
    * @param n the exact number of times the condition should be verified.
    * @param condition the given condition.
    * @return {@code this} object.
@@ -904,7 +904,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * Example:
    * <pre><code class='java'> BasketBallPlayer[] bullsPlayers = {butler, rose};
-   * 
+   *
    * // potentialMvp is a Condition&lt;BasketBallPlayer&gt;
    * assertThat(bullsPlayers).haveAtLeastOne(potentialMvp);</code></pre>
    *
@@ -925,7 +925,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *
    * // assertion will pass
    * oneTwoThree.haveAtLeast(2, oddNumber);
-   * 
+   *
    * // assertion will fail
    * oneTwoThree.haveAtLeast(3, oddNumber);</code></pre>
    *
@@ -948,7 +948,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * // assertions will pass
    * oneTwoThree.haveAtMost(2, oddNumber);
    * oneTwoThree.haveAtMost(3, oddNumber);
-   * 
+   *
    * // assertion will fail
    * oneTwoThree.haveAtMost(1, oddNumber);</code></pre>
    *
@@ -970,7 +970,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *
    * // assertion will pass
    * oneTwoThree.haveExactly(2, oddNumber);
-   * 
+   *
    * // assertions will fail
    * oneTwoThree.haveExactly(1, oddNumber);
    * oneTwoThree.haveExactly(3, oddNumber);</code></pre>
@@ -1015,12 +1015,12 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Verifies that the actual array contains all the elements of given {@code Iterable}, in any order.
    * <p>
    * Example :
-   * <pre><code class='java'> String[] abc = {"a", "b", "c"}; 
-   * String[] bc = {"b", "c"}; 
+   * <pre><code class='java'> String[] abc = {"a", "b", "c"};
+   * String[] bc = {"b", "c"};
    *
    * // assertion will pass
    * assertThat(abc).containsAll(bc);</code></pre>
-   * 
+   *
    * @param iterable the given {@code Iterable} we will get elements from.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
@@ -1044,22 +1044,22 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Examples :
    * <pre><code class='java'> // compares invoices by payee
    * assertThat(invoiceArray).usingComparator(invoicePayeeComparator).isEqualTo(expectedinvoiceArray).
-   * 
+   *
    * // compares invoices by date, doesNotHaveDuplicates and contains both use the given invoice date comparator
    * assertThat(invoiceArray).usingComparator(invoiceDateComparator).doesNotHaveDuplicates().contains(may2010Invoice)
-   * 
-   * // as assertThat(invoiceArray) creates a new assertion, it falls back to standard comparison strategy 
+   *
+   * // as assertThat(invoiceArray) creates a new assertion, it falls back to standard comparison strategy
    * // based on Invoice's equal method to compare invoiceArray elements to lowestInvoice.
    * assertThat(invoiceArray).contains(lowestInvoice).
-   * 
+   *
    * // standard comparison : the fellowshipOfTheRing includes Gandalf but not Sauron (believe me) ...
    * assertThat(fellowshipOfTheRing).contains(gandalf)
    *                                .doesNotContain(sauron);
-   * 
+   *
    * // ... but if we compare only races, Sauron is in fellowshipOfTheRing because he's a Maia like Gandalf.
    * assertThat(fellowshipOfTheRing).usingElementComparator(raceComparator)
    *                                .contains(sauron);</code></pre>
-   * 
+   *
    * @param customComparator the comparator to use for incoming assertion checks.
    * @throws NullPointerException if the given comparator is {@code null}.
    * @return {@code this} assertion object.
@@ -1092,10 +1092,10 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
    * TolkienCharacter frodoClone = new TolkienCharacter("Frodo", 33, HOBBIT);
-   * 
+   *
    * // Fail if equals has not been overridden in TolkienCharacter as equals default implementation only compares references
    * assertThat(array(frodo)).contains(frodoClone);
-   * 
+   *
    * // frodo and frodoClone are equals when doing a field by field comparison.
    * assertThat(array(frodo)).usingFieldByFieldElementComparator().contains(frodoClone);</code></pre>
    *
@@ -1105,6 +1105,49 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
     return usingElementComparator(new FieldByFieldComparator());
   }
 
+  /**
+   * Use a recursive field/property by field/property comparison (including inherited fields/properties)
+   * instead of relying on actual type A <code>equals</code> method to compare group elements for incoming
+   * assertion checks. This can be useful if actual's {@code equals} implementation does not suit you.
+   * <p>
+   * The recursive property/field comparison is <b>not</b> applied on fields having a custom {@code equals}
+   * implementation, i.e. the overriden {@code equals} method will be used instead of a field/property by field/property comparison.
+   * <p>
+   * The recursive comparison handles cycle. {@code floats} are compared with a precision of 1.0E-6 and {@code doubles} with 1.0E-15.
+   * <p>
+   * The objects to compare can be of different types but must have the same properties/fields. For example if actual object has a
+   * {@code name} String field, the other object must also have one.
+   * <p>
+   * If an object has a field and a property with the same name, the property value will be used over the field.
+   * <p>
+   * Example:
+   *
+   * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
+   * TolkienCharacter pippin = new TolkienCharacter("Pippin", 28, HOBBIT);
+   * frodo.setFriend(pippin);
+   * pippin.setFriend(frodo);
+   *
+   * TolkienCharacter frodoClone = new TolkienCharacter("Frodo", 33, HOBBIT);
+   * TolkienCharacter pippinClone = new TolkienCharacter("Pippin", 28, HOBBIT);
+   * frodoClone.setFriend(pippinClone);
+   * pippinClone.setFriend(frodoClone);
+   *
+   * TolkienCharacter[] hobbits = new TolkienCharacter[] {frodo, pippin};
+   *
+   * // fails if equals has not been overridden in TolkienCharacter as it would compares object references
+   * assertThat(hobbits).contains(frodoClone, pippinClone);
+   *
+   * // frodo/frodoClone and pippin/pippinClone are equals when doing a recursive property/field by property/field comparison
+   * assertThat(hobbits).usingRecursiveFieldByFieldElementComparator()
+   *                    .contains(frodoClone, pippinClone);</code></pre>
+   *
+   * @return {@code this} assertion object.
+   * @since 2.5.0 / 3.5.0
+   */
+  public S usingRecursiveFieldByFieldElementComparator() {
+    return usingElementComparator(new RecursiveFieldByFieldComparator());
+  }
+
   /**
    * Use field/property by field/property comparison on the <b>given fields/properties only</b> (including inherited
    * fields/properties)instead of relying on actual type A <code>equals</code> method to compare group elements for
@@ -1119,10 +1162,10 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
    * TolkienCharacter sam = new TolkienCharacter("Sam", 38, HOBBIT);
-   * 
+   *
    * // frodo and sam both are hobbits, so they are equals when comparing only race
    * assertThat(array(frodo)).usingElementComparatorOnFields("race").contains(sam); // OK
-   * 
+   *
    * // ... but not when comparing both name and race
    * assertThat(array(frodo)).usingElementComparatorOnFields("name", "race").contains(sam); // FAIL</code></pre>
    *
@@ -1146,10 +1189,10 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Example:
    * <pre><code class='java'> TolkienCharacter frodo = new TolkienCharacter("Frodo", 33, HOBBIT);
    * TolkienCharacter sam = new TolkienCharacter("Sam", 38, HOBBIT);
-   * 
+   *
    * // frodo and sam both are hobbits, so they are equals when comparing only race (i.e. ignoring all other fields)
    * assertThat(array(frodo)).usingElementComparatorIgnoringFields("name", "age").contains(sam); // OK
-   * 
+   *
    * // ... but not when comparing both name and race
    * assertThat(array(frodo)).usingElementComparatorIgnoringFields("age").contains(sam); // FAIL</code></pre>
    *
@@ -1179,24 +1222,24 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *   new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN,
    *   new TolkienCharacter(&quot;Boromir&quot;, 37, MAN)
    * };
-   * 
+   *
    * // let's verify the names of TolkienCharacter in fellowshipOfTheRing :
-   * 
+   *
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;)
    *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
    *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
-   *         
+   *
    * // you can also extract nested field/property like the name of Race :
-   * 
+   *
    * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;)
    *                                .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
    *                                .doesNotContain(&quot;Orc&quot;);</code></pre>
-   * 
+   *
    * A property with the given name is looked for first, if it does not exist then a field with the given name
    * is looked for.
    * <p>
    * Note that the order of extracted field/property values is consistent with the array order.
-   * 
+   *
    * @param fieldOrProperty the field/property to extract from the array under test
    * @return a new assertion object whose object under test is the array of extracted field/property values.
    * @throws IntrospectionError if no field or property exists with the given name
@@ -1226,24 +1269,24 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *   new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN,
    *   new TolkienCharacter(&quot;Boromir&quot;, 37, MAN)
    * };
-   * 
+   *
    * // let's verify the names of TolkienCharacter in fellowshipOfTheRing :
-   * 
+   *
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, String.class)
    *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
    *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
-   * 
+   *
    * // you can also extract nested field/property like the name of Race :
-   * 
+   *
    * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;, String.class)
    *                                .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
    *                                .doesNotContain(&quot;Orc&quot;);</code></pre>
-   * 
+   *
    * A property with the given name is looked for first, if it does not exist then a field with the given name
    * is looked for.
    * <p>
    * Note that the order of extracted field/property values is consistent with the order of the array under test.
-   * 
+   *
    * @param fieldOrProperty the field/property to extract from the array under test
    * @param extractingType type to return
    * @return a new assertion object whose object under test is the array of extracted field/property values.
@@ -1279,22 +1322,22 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *   new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN,
    *   new TolkienCharacter(&quot;Boromir&quot;, 37, MAN)
    * };
-   * 
+   *
    * // let's verify 'name' and 'age' of some TolkienCharacter in fellowshipOfTheRing :
-   * 
+   *
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, &quot;age&quot;)
    *                                .contains(tuple(&quot;Boromir&quot;, 37),
    *                                          tuple(&quot;Sam&quot;, 38),
    *                                          tuple(&quot;Legolas&quot;, 1000));
-   * 
-   * 
+   *
+   *
    * // extract 'name', 'age' and Race name values.
-   * 
+   *
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;, &quot;age&quot;, &quot;race.name&quot;)
    *                                .contains(tuple(&quot;Boromir&quot;, 37, &quot;Man&quot;),
    *                                          tuple(&quot;Sam&quot;, 38, &quot;Hobbit&quot;),
    *                                          tuple(&quot;Legolas&quot;, 1000, &quot;Elf&quot;));</code></pre>
-   * 
+   *
    * A property with the given name is looked for first, if it does not exist the a field with the given name is
    * looked for.
    * <p>
@@ -1334,8 +1377,8 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *   new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN,
    *   new TolkienCharacter(&quot;Boromir&quot;, 37, MAN)
    * };
-   * 
-   * 
+   *
+   *
    * // this extracts the race
    * Extractor&lt;TolkienCharacter, Race&gt; race = new Extractor&lt;TolkienCharacter, Race&gt;() {
    *    &commat;Override
@@ -1343,14 +1386,14 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *        return input.getRace();
    *    }
    * }
-   * 
+   *
    * // fellowship has hobbitses, right, my presioussss?
    * assertThat(fellowshipOfTheRing).extracting(race).contains(HOBBIT);</code></pre>
-   * 
+   *
    * Note that the order of extracted property/field values is consistent with the iteration order of the Iterable under
    * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions on the extracted values
    * order.
-   * 
+   *
    * @param extractor the object transforming input object to desired one
    * @return a new assertion object whose object under test is the list of values extracted
    */
@@ -1372,26 +1415,26 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * CartoonCharacter maggie = new CartoonCharacter("Maggie Simpson");
    * CartoonCharacter homer = new CartoonCharacter("Homer Simpson");
    * homer.addChildren(bart, lisa, maggie);
-   * 
+   *
    * CartoonCharacter pebbles = new CartoonCharacter("Pebbles Flintstone");
    * CartoonCharacter fred = new CartoonCharacter("Fred Flintstone");
    * fred.getChildren().add(pebbles);
-   * 
+   *
    * Extractor&lt;CartoonCharacter, List&lt;CartoonCharacter&gt;&gt; childrenOf = new Extractor&lt;CartoonCharacter, List&lt;CartoonCharacter&gt;&gt;() {
    *    &commat;Override
    *    public List&lt;CartoonChildren&gt; extract(CartoonCharacter input) {
    *        return input.getChildren();
    *    }
    * }
-   * 
+   *
    * CartoonCharacter[] parents = new CartoonCharacter[] { homer, fred };
    * // check children
    * assertThat(parents).flatExtracting(childrenOf)
    *                    .containsOnly(bart, lisa, maggie, pebbles);</code></pre>
-   * 
+   *
    * The order of extracted values is consisted with both the order of the collection itself, as well as the extracted
    * collections.
-   * 
+   *
    * @param extractor the object transforming input object to an Iterable of desired ones
    * @return a new assertion object whose object under test is the list of values extracted
    */
@@ -1473,12 +1516,12 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *     new WesterosHouse(&quot;Lannister&quot;, &quot;Hear Me Roar!&quot;), new WesterosHouse(&quot;Greyjoy&quot;, &quot;We Do Not Sow&quot;),
    *     new WesterosHouse(&quot;Baratheon&quot;, &quot;Our is the Fury&quot;), new WesterosHouse(&quot;Martell&quot;, &quot;Unbowed, Unbent, Unbroken&quot;),
    *     new WesterosHouse(&quot;Tyrell&quot;, &quot;Growing Strong&quot;) };
-   * 
+   *
    * // let's verify the words of the great houses of Westeros:
    * assertThat(greatHousesOfWesteros).extractingResultOf(&quot;sayTheWords&quot;)
    *                                  .contains(&quot;Winter is Coming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;)
    *                                  .doesNotContain(&quot;Lannisters always pay their debts&quot;);</code></pre>
-   * 
+   *
    * <p>
    * Following requirements have to be met to extract method results:
    * <ul>
@@ -1488,7 +1531,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * </ul>
    * <p>
    * Note that the order of extracted values is consistent with the order of the array under test.
-   * 
+   *
    * @param method the name of the method which result is to be extracted from the array under test
    * @return a new assertion object whose object under test is the array of extracted values.
    * @throws IllegalArgumentException if no method exists with the given name, or method is not public, or method does
@@ -1515,12 +1558,12 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *     new WesterosHouse(&quot;Lannister&quot;, &quot;Hear Me Roar!&quot;), new WesterosHouse(&quot;Greyjoy&quot;, &quot;We Do Not Sow&quot;),
    *     new WesterosHouse(&quot;Baratheon&quot;, &quot;Our is the Fury&quot;), new WesterosHouse(&quot;Martell&quot;, &quot;Unbowed, Unbent, Unbroken&quot;),
    *     new WesterosHouse(&quot;Tyrell&quot;, &quot;Growing Strong&quot;) };
-   * 
+   *
    * // let's verify the words of the great houses of Westeros:
    * assertThat(greatHousesOfWesteros).extractingResultOf(&quot;sayTheWords&quot;, String.class)
    *                                  .contains(&quot;Winter is Coming&quot;, &quot;We Do Not Sow&quot;, &quot;Hear Me Roar&quot;)
    *                                  .doesNotContain(&quot;Lannisters always pay their debts&quot;);</code></pre>
-   * 
+   *
    * <p>
    * Following requirements have to be met to extract method results:
    * <ul>
@@ -1530,7 +1573,7 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * </ul>
    * <p>
    * Note that the order of extracted values is consistent with the order of the array under test.
-   * 
+   *
    * @param method the name of the method which result is to be extracted from the array under test
    * @param extractingType type to return
    * @return a new assertion object whose object under test is the array of extracted values.
@@ -1592,25 +1635,25 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
    * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
    * <p>
-   * 
+   *
    * As an example, let's check all employees 800 years old (yes, special employees):
    * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
    * Employee noname = new Employee(4L, null, 50);
-   * 
+   *
    * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
    *
    * assertThat(employees).filteredOn("age", 800)
    *                      .containsOnly(yoda, obiwan);</code></pre>
-   *                      
+   *
    * Nested properties/fields are supported:
    * <pre><code class='java'> // Name is bean class with 'first' and 'last' String properties
    *
-   * // name is null for noname => it does not match the filter on "name.first" 
+   * // name is null for noname => it does not match the filter on "name.first"
    * assertThat(employees).filteredOn("name.first", "Luke")
    *                      .containsOnly(luke);
-   * 
+   *
    * assertThat(employees).filteredOn("name.last", "Vader")
    *                      .isEmpty();</code></pre>
    * <p>
@@ -1622,14 +1665,14 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * You can chain filters:
    * <pre><code class='java'> // fellowshipOfTheRing is an array of TolkienCharacter having race and name fields
-   * // 'not' filter is statically imported from Assertions.not 
-   * 
+   * // 'not' filter is statically imported from Assertions.not
+   *
    * assertThat(fellowshipOfTheRing).filteredOn("race.name", "Man")
    *                                .filteredOn("name", not("Boromir"))
    *                                .containsOnly(aragorn);</code></pre>
    * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
    * filter to apply.
-   * 
+   *
    * @param propertyOrFieldName the name of the property or field to read
    * @param expectedValue the value to compare element's property or field with
    * @return a new assertion object with the filtered array under test
@@ -1658,24 +1701,24 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
    * Employee noname = new Employee(4L, null, 50);
-   * 
+   *
    * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
    *
    * assertThat(employees).filteredOnNull("name")
    *                      .containsOnly(noname);</code></pre>
-   *                      
+   *
    * Nested properties/fields are supported:
    * <pre><code class='java'> // Name is bean class with 'first' and 'last' String properties
    *
    * assertThat(employees).filteredOnNull("name.last")
    *                      .containsOnly(yoda, obiwan, noname);</code></pre>
-   * 
+   *
    * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the array
    * elements.
    * <p>
    * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
    * filter to apply.
-   * 
+   *
    * @param propertyOrFieldName the name of the property or field to read
    * @return a new assertion object with the filtered array under test
    * @throws IntrospectionError if the given propertyOrFieldName can't be found in one of the array elements.
@@ -1705,27 +1748,27 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
    * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
    * <p>
-   * 
+   *
    * As an example, let's check stuff on some special employees :
    * <pre><code class='java'> Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
-   * 
+   *
    * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
    *
-   * // 'not' filter is statically imported from Assertions.not 
+   * // 'not' filter is statically imported from Assertions.not
    * assertThat(employees).filteredOn("age", not(800))
    *                      .containsOnly(luke);
-   * 
+   *
    * // 'in' filter is statically imported from Assertions.in
-   * // Name is bean class with 'first' and 'last' String properties 
+   * // Name is bean class with 'first' and 'last' String properties
    * assertThat(employees).filteredOn("name.first", in("Yoda", "Luke"))
    *                      .containsOnly(yoda, luke);
-   * 
+   *
    * // 'notIn' filter is statically imported from Assertions.notIn
    * assertThat(employees).filteredOn("name.first", notIn("Yoda", "Luke"))
    *                      .containsOnly(obiwan);</code></pre>
-   *                      
+   *
    * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the array
    * elements.
    * <p>
@@ -1737,15 +1780,15 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * <p>
    * You can chain filters:
    * <pre><code class='java'> // fellowshipOfTheRing is an array of TolkienCharacter having race and name fields
-   * // 'not' filter is statically imported from Assertions.not 
-   * 
+   * // 'not' filter is statically imported from Assertions.not
+   *
    * assertThat(fellowshipOfTheRing).filteredOn("race.name", "Man")
    *                                .filteredOn("name", not("Boromir"))
    *                                .containsOnly(aragorn);</code></pre>
-   * 
+   *
    * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
    * filter to apply.
-   * 
+   *
    * @param propertyOrFieldName the name of the property or field to read
    * @param filterOperator the filter operator to apply
    * @return a new assertion object with the filtered array under test
@@ -1767,11 +1810,11 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
    * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
    * Employee noname = new Employee(4L, null, 50);
-   * 
+   *
    * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
-   * 
+   *
    * // old employee condition, "old employees" describes the condition in error message
-   * // you just have to implement 'matches' method 
+   * // you just have to implement 'matches' method
    * Condition&lt;Employee&gt; oldEmployees = new Condition&lt;Employee&gt;("old employees") {
    *       {@literal @}Override
    *       public boolean matches(Employee employee) {
@@ -1781,12 +1824,12 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
    *   }
    * assertThat(employees).filteredOn(oldEmployees)
    *                      .containsOnly(yoda, obiwan);</code></pre>
-   *                      
+   *
    * You can combine {@link Condition} with condition operator like {@link Not}:
    * <pre><code class='java'> // 'not' filter is statically imported from Assertions.not
    * assertThat(employees).filteredOn(not(oldEmployees))
    *                      .contains(luke, noname);</code></pre>
-   * 
+   *
    * @param condition the filter condition / predicate
    * @return a new assertion object with the filtered array under test
    * @throws IllegalArgumentException if the given condition is {@code null}.
diff --git a/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java b/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java
index 36a9fbbea..028c4d980 100644
--- a/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java
+++ b/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java
@@ -20,8 +20,8 @@ import org.assertj.core.api.Assertions;
 import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
- * Compare Object field by field including private fields unless
- * {@link Assertions#setAllowComparingPrivateFields(boolean)}has been called with false.
+ * Compares objects field/property by field/property including private fields unless
+ * {@link Assertions#setAllowComparingPrivateFields(boolean)} has been called with false.
  */
 public class FieldByFieldComparator implements Comparator<Object> {
 
@@ -46,7 +46,7 @@ public class FieldByFieldComparator implements Comparator<Object> {
 
   @Override
   public String toString() {
-	return "field by field comparator on all fields";
+    return "field/property by field/property comparator on all fields/properties";
   }
 
 }
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/internal/RecursiveFieldByFieldComparator.java b/src/main/java/org/assertj/core/internal/RecursiveFieldByFieldComparator.java
new file mode 100644
index 000000000..9d1bba1e5
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/RecursiveFieldByFieldComparator.java
@@ -0,0 +1,51 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2016 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.util.Collections.EMPTY_MAP;
+import static org.assertj.core.api.AbstractObjectAssert.defaultTypeComparators;
+import static org.assertj.core.internal.DeepDifference.determineDifferences;
+
+import java.util.Comparator;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+
+/**
+ * Compares objects field/property by field/property recursively.
+ */
+public class RecursiveFieldByFieldComparator implements Comparator<Object> {
+
+  private static final int NOT_EQUAL = -1;
+
+  @Override
+  public int compare(Object actual, Object other) {
+    if (actual == null && other == null) return 0;
+    if (actual == null || other == null) return NOT_EQUAL;
+    // value returned is not relevant for ordering if objects are not equal.
+    return areEqual(actual, other) ? 0 : NOT_EQUAL;
+  }
+
+  @SuppressWarnings("unchecked")
+  protected boolean areEqual(Object actual, Object other) {
+    try {
+      return determineDifferences(actual, other, EMPTY_MAP, defaultTypeComparators()).isEmpty();
+    } catch (IntrospectionError e) {
+      return false;
+    }
+  }
+
+  @Override
+  public String toString() {
+    return "recursive field/property by field/property comparator on all fields/properties";
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingFieldByFieldElementComparator_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingFieldByFieldElementComparator_Test.java
index 98df6980b..08851f39b 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingFieldByFieldElementComparator_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingFieldByFieldElementComparator_Test.java
@@ -124,7 +124,7 @@ public class IterableAssert_usingFieldByFieldElementComparator_Test extends Iter
                                       " <[Foo(id=id, bar=1)]>%n" +
                                       "to be equal to:%n" +
                                       " <[Foo(id=id, bar=2)]>%n" +
-                                      "when comparing elements using 'field by field comparator on all fields' but was not."));
+                                      "when comparing elements using 'field/property by field/property comparator on all fields/properties' but was not."));
       // @format:on
       return;
     }
@@ -142,7 +142,7 @@ public class IterableAssert_usingFieldByFieldElementComparator_Test extends Iter
                                              " <[Foo(id=id, bar=1)]>%n" +
                                              "to be in:%n" +
                                              " <[[Foo(id=id, bar=2)]]>%n" +
-                                             "when comparing elements using 'field by field comparator on all fields'"));
+                                             "when comparing elements using 'field/property by field/property comparator on all fields/properties'"));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparator_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparator_Test.java
new file mode 100644
index 000000000..1f3e1cfbf
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparator_Test.java
@@ -0,0 +1,128 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2016 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static java.lang.String.format;
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+
+import java.util.List;
+
+import org.assertj.core.api.ConcreteIterableAssert;
+import org.assertj.core.api.IterableAssertBaseTest;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.IterableElementComparisonStrategy;
+import org.assertj.core.internal.Iterables;
+import org.junit.Before;
+import org.junit.Test;
+
+public class IterableAssert_usingRecursiveFieldByFieldElementComparator_Test extends IterableAssertBaseTest {
+
+  private Iterables iterablesBefore;
+
+  @Before
+  public void before() {
+    iterablesBefore = getIterables(assertions);
+  }
+
+  @Override
+  protected ConcreteIterableAssert<Object> invoke_api_method() {
+    return assertions.usingRecursiveFieldByFieldElementComparator();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    assertThat(iterablesBefore).isNotSameAs(getIterables(assertions));
+    assertThat(getIterables(assertions).getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+    assertThat(getObjects(assertions).getComparisonStrategy()).isInstanceOf(IterableElementComparisonStrategy.class);
+  }
+
+  @Test
+  public void successful_isEqualTo_assertion_using_recursive_field_by_field_element_comparator() {
+    List<Foo> list1 = singletonList(new Foo("id", new Bar(1)));
+    List<Foo> list2 = singletonList(new Foo("id", new Bar(1)));
+    assertThat(list1).usingRecursiveFieldByFieldElementComparator().isEqualTo(list2);
+  }
+
+  @Test
+  public void successful_isIn_assertion_using_recursive_field_by_field_element_comparator() {
+    List<Foo> list1 = singletonList(new Foo("id", new Bar(1)));
+    List<Foo> list2 = singletonList(new Foo("id", new Bar(1)));
+    assertThat(list1).usingRecursiveFieldByFieldElementComparator().isIn(singletonList(list2));
+  }
+
+  @Test
+  public void failed_isEqualTo_assertion_using_recursive_field_by_field_element_comparator() {
+    List<Foo> list1 = singletonList(new Foo("id", new Bar(1)));
+    List<Foo> list2 = singletonList(new Foo("id", new Bar(2)));
+    try {
+      assertThat(list1).usingRecursiveFieldByFieldElementComparator().isEqualTo(list2);
+    } catch (AssertionError e) {
+      // @format:off
+      assertThat(e).hasMessage(format("%nExpecting:%n" +
+                                      " <[Foo(id=id, bar=Bar [id=1])]>%n" +
+                                      "to be equal to:%n" +
+                                      " <[Foo(id=id, bar=Bar [id=2])]>%n" +
+                                      "when comparing elements using 'recursive field/property by field/property comparator on all fields/properties' but was not."));
+      // @format:on
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void failed_isIn_assertion_using_recursive_field_by_field_element_comparator() {
+    List<Foo> list1 = singletonList(new Foo("id", new Bar(1)));
+    List<Foo> list2 = singletonList(new Foo("id", new Bar(2)));
+    try {
+      assertThat(list1).usingRecursiveFieldByFieldElementComparator().isIn(singletonList(list2));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage(String.format("%nExpecting:%n" +
+                                             " <[Foo(id=id, bar=Bar [id=1])]>%n" +
+                                             "to be in:%n" +
+                                             " <[[Foo(id=id, bar=Bar [id=2])]]>%n" +
+                                             "when comparing elements using 'recursive field/property by field/property comparator on all fields/properties'"));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  public static class Foo {
+    public String id;
+    public Bar bar;
+
+    public Foo(String id, Bar bar) {
+      this.id = id;
+      this.bar = bar;
+    }
+
+    @Override
+    public String toString() {
+      return "Foo(id=" + id + ", bar=" + bar + ")";
+    }
+  }
+
+  public static class Bar {
+    public int id;
+
+    public Bar(int id) {
+      this.id = id;
+    }
+
+    @Override
+    public String toString() {
+      return "Bar [id=" + id + "]";
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_usingFieldByFieldElementComparator_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_usingFieldByFieldElementComparator_Test.java
index 42ab2c405..daf69d8eb 100644
--- a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_usingFieldByFieldElementComparator_Test.java
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_usingFieldByFieldElementComparator_Test.java
@@ -150,7 +150,7 @@ public class ObjectArrayAssert_usingFieldByFieldElementComparator_Test extends O
                                       " <[Foo(id=id, bar=1)]>%n" +
                                       "to be equal to:%n" +
                                       " <[Foo(id=id, bar=2)]>%n" +
-                                      "when comparing elements using 'field by field comparator on all fields' but was not."));
+                                      "when comparing elements using 'field/property by field/property comparator on all fields/properties' but was not."));
       // @format:on
       return;
     }
@@ -168,7 +168,7 @@ public class ObjectArrayAssert_usingFieldByFieldElementComparator_Test extends O
                                              " <[Foo(id=id, bar=1)]>%n" +
                                              "to be in:%n" +
                                              " <[[Foo(id=id, bar=2)], [Foo(id=id, bar=2)]]>%n" +
-                                             "when comparing elements using 'field by field comparator on all fields'"));
+                                             "when comparing elements using 'field/property by field/property comparator on all fields/properties'"));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_usingRecursiveFieldByFieldElementComparator_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_usingRecursiveFieldByFieldElementComparator_Test.java
new file mode 100644
index 000000000..e7aef1505
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_usingRecursiveFieldByFieldElementComparator_Test.java
@@ -0,0 +1,125 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2016 the original author or authors.
+ */
+package org.assertj.core.api.objectarray;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+
+import org.assertj.core.api.ObjectArrayAssert;
+import org.assertj.core.api.ObjectArrayAssertBaseTest;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.ObjectArrayElementComparisonStrategy;
+import org.assertj.core.internal.ObjectArrays;
+import org.junit.Before;
+import org.junit.Test;
+
+public class ObjectArrayAssert_usingRecursiveFieldByFieldElementComparator_Test extends ObjectArrayAssertBaseTest {
+
+  private ObjectArrays arraysBefore;
+
+  @Before
+  public void before() {
+    arraysBefore = getArrays(assertions);
+  }
+
+  @Override
+  protected ObjectArrayAssert<Object> invoke_api_method() {
+    return assertions.usingRecursiveFieldByFieldElementComparator();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    assertThat(arraysBefore).isNotSameAs(getArrays(assertions));
+    assertThat(getArrays(assertions).getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+    assertThat(getObjects(assertions).getComparisonStrategy()).isInstanceOf(ObjectArrayElementComparisonStrategy.class);
+  }
+
+  @Test
+  public void successful_isEqualTo_assertion_using_recursive_field_by_field_element_comparator() {
+    Foo [] array1 = { new Foo("id", new Bar(1)) };
+    Foo [] array2 = { new Foo("id", new Bar(1)) };
+    assertThat(array1).usingRecursiveFieldByFieldElementComparator().isEqualTo(array2);
+  }
+
+  @Test
+  public void successful_isIn_assertion_using_recursive_field_by_field_element_comparator() {
+    Foo [] array1 = { new Foo("id", new Bar(1)) };
+    Foo [] array2 = { new Foo("id", new Bar(1)) };
+    assertThat(array1).usingRecursiveFieldByFieldElementComparator().isIn(new Object[] {(array2)});
+  }
+
+  @Test
+  public void failed_isEqualTo_assertion_using_recursive_field_by_field_element_comparator() {
+    Foo [] array1 = { new Foo("id", new Bar(1)) };
+    Foo [] array2 = { new Foo("id", new Bar(2)) };
+    try {
+      assertThat(array1).usingRecursiveFieldByFieldElementComparator().isEqualTo(array2);
+    } catch (AssertionError e) {
+      // @format:off
+      assertThat(e).hasMessage(format("%nExpecting:%n" +
+                                      " <[Foo(id=id, bar=Bar [id=1])]>%n" +
+                                      "to be equal to:%n" +
+                                      " <[Foo(id=id, bar=Bar [id=2])]>%n" +
+                                      "when comparing elements using 'recursive field/property by field/property comparator on all fields/properties' but was not."));
+      // @format:on
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void failed_isIn_assertion_using_recursive_field_by_field_element_comparator() {
+    Foo[] array1 = { new Foo("id", new Bar(1)) };
+    Foo[] arry2 = { new Foo("id", new Bar(2)) };
+    try {
+      assertThat(array1).usingRecursiveFieldByFieldElementComparator().isIn(new Object[] { arry2 });
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage(String.format("%nExpecting:%n" +
+                                             " <[Foo(id=id, bar=Bar [id=1])]>%n" +
+                                             "to be in:%n" +
+                                             " <[[Foo(id=id, bar=Bar [id=2])]]>%n" +
+                                             "when comparing elements using 'recursive field/property by field/property comparator on all fields/properties'"));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  public static class Foo {
+    public String id;
+    public Bar bar;
+
+    public Foo(String id, Bar bar) {
+      this.id = id;
+      this.bar = bar;
+    }
+
+    @Override
+    public String toString() {
+      return "Foo(id=" + id + ", bar=" + bar + ")";
+    }
+  }
+
+  public static class Bar {
+    public int id;
+
+    public Bar(int id) {
+      this.id = id;
+    }
+
+    @Override
+    public String toString() {
+      return "Bar [id=" + id + "]";
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/FieldByFieldComparator_toString_Test.java b/src/test/java/org/assertj/core/internal/FieldByFieldComparator_toString_Test.java
index f6195c333..150a561cc 100644
--- a/src/test/java/org/assertj/core/internal/FieldByFieldComparator_toString_Test.java
+++ b/src/test/java/org/assertj/core/internal/FieldByFieldComparator_toString_Test.java
@@ -20,7 +20,7 @@ public class FieldByFieldComparator_toString_Test {
 
   @Test
   public void should_return_description_of_FieldByFieldComparator() {
-	assertThat(new FieldByFieldComparator().toString()).isEqualTo("field by field comparator on all fields");
+    assertThat(new FieldByFieldComparator()).hasToString("field/property by field/property comparator on all fields/properties");
   }
 
 }
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/RecursiveFieldByFieldComparator_compareTo_Test.java b/src/test/java/org/assertj/core/internal/RecursiveFieldByFieldComparator_compareTo_Test.java
new file mode 100644
index 000000000..4ee276995
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/RecursiveFieldByFieldComparator_compareTo_Test.java
@@ -0,0 +1,68 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2016 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.Test;
+
+public class RecursiveFieldByFieldComparator_compareTo_Test {
+
+  private static final RecursiveFieldByFieldComparator RECURSIVE_FIELD_BY_FIELD_COMPARATOR = new RecursiveFieldByFieldComparator();
+
+  @Test
+  public void should_return_true_if_Objects_are_equal() {
+    assertThat(RECURSIVE_FIELD_BY_FIELD_COMPARATOR.compare(new Foo("id", new Bar(1)),
+                                                           new Foo("id", new Bar(1)))).isZero();
+  }
+
+  @Test
+  public void should_return_false_if_Objects_are_not_equal() {
+    assertThat(RECURSIVE_FIELD_BY_FIELD_COMPARATOR.compare(new Foo("id", new Bar(1)),
+                                                           new Foo("id", new Bar(2)))).isNotZero();
+  }
+
+  @Test
+  public void should_return_are_not_equal_if_first_Object_is_null_and_second_is_not() {
+    assertThat(RECURSIVE_FIELD_BY_FIELD_COMPARATOR.compare(null, new Foo("id", new Bar(1)))).isNotZero();
+  }
+
+  @Test
+  public void should_return_are_not_equal_if_second_Object_is_null_and_first_is_not() {
+    assertThat(RECURSIVE_FIELD_BY_FIELD_COMPARATOR.compare(new Foo("id", new Bar(1)), null)).isNotZero();
+  }
+
+  @Test
+  public void should_return_are_not_equal_if_Objects_do_not_have_the_same_properties() {
+    assertThat(RECURSIVE_FIELD_BY_FIELD_COMPARATOR.compare(new Foo("id", new Bar(1)), 2)).isNotZero();
+  }
+
+  public static class Foo {
+    public String id;
+    public Bar bar;
+
+    public Foo(String id, Bar bar) {
+      this.id = id;
+      this.bar = bar;
+    }
+  }
+
+  public static class Bar {
+    public int id;
+
+    public Bar(int id) {
+      this.id = id;
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/RecursiveFieldByFieldComparator_toString_Test.java b/src/test/java/org/assertj/core/internal/RecursiveFieldByFieldComparator_toString_Test.java
new file mode 100644
index 000000000..eab0a49f6
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/RecursiveFieldByFieldComparator_toString_Test.java
@@ -0,0 +1,25 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2016 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.junit.Test;
+
+public class RecursiveFieldByFieldComparator_toString_Test {
+
+  @Test
+  public void should_return_description_of_RecursiveFieldByFieldComparator() {
+    assertThat(new RecursiveFieldByFieldComparator()).hasToString("recursive field/property by field/property comparator on all fields/properties");
+  }
+}
\ No newline at end of file
