diff --git a/src/main/java/org/assertj/core/api/AbstractFileAssert.java b/src/main/java/org/assertj/core/api/AbstractFileAssert.java
index a2034a46c..0017a1d2f 100644
--- a/src/main/java/org/assertj/core/api/AbstractFileAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractFileAssert.java
@@ -18,17 +18,19 @@ import static org.assertj.core.util.Preconditions.checkNotNull;
 import java.io.File;
 import java.io.UncheckedIOException;
 import java.nio.charset.Charset;
+import java.security.MessageDigest;
+
 import org.assertj.core.internal.Files;
 import org.assertj.core.util.CheckReturnValue;
 import org.assertj.core.util.VisibleForTesting;
 
 /**
  * Base class for all implementations of assertions for {@link File}s.
- * 
+ *
  * @param <SELF> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/1IZIRcY"
  *          target="_blank">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;
  *          for more details.
- * 
+ *
  * @author David DIDIER
  * @author Yvonne Wang
  * @author Alex Ruiz
@@ -55,11 +57,11 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * Example:
    * <pre><code class='java'> File tmpFile = File.createTempFile(&quot;tmp&quot;, &quot;txt&quot;);
    * File tmpDir = Files.createTempDirectory(&quot;tmpDir&quot;).toFile();
-   * 
+   *
    * // assertions will pass
    * assertThat(tmpFile).exists();
    * assertThat(tmpDir).exists();
-   * 
+   *
    * tmpFile.delete();
    * tmpDir.delete();
    *
@@ -83,14 +85,14 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * <pre><code class='java'> File parentDir = Files.createTempDirectory(&quot;tmpDir&quot;).toFile();
    * File tmpDir = new File(parentDir, &quot;subDir&quot;);
    * File tmpFile = new File(parentDir, &quot;a.txt&quot;);
-   * 
+   *
    * // assertions will pass
    * assertThat(tmpDir).doesNotExist();
    * assertThat(tmpFile).doesNotExist();
-   * 
+   *
    * tmpDir.mkdir();
    * tmpFile.createNewFile();
-   * 
+   *
    * // assertions will fail
    * assertThat(tmpFile).doesNotExist();
    * assertThat(tmpDir).doesNotExist();</code></pre>
@@ -109,13 +111,13 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * <p>
    * Example:
    * <pre><code class='java'> File tmpFile = File.createTempFile(&quot;tmp&quot;, &quot;txt&quot;);
-   * 
+   *
    * // assertion will pass
    * assertThat(tmpFile).isFile();
-   * 
+   *
    * tmpFile.delete();
    * File tmpDir = Files.createTempDirectory(&quot;tmpDir&quot;).toFile();
-   * 
+   *
    * // assertions will fail
    * assertThat(tmpFile).isFile();
    * assertThat(tmpDir).isFile();</code></pre>
@@ -134,13 +136,13 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * <p>
    * Example:
    * <pre><code class='java'> File tmpDir = Files.createTempDirectory(&quot;tmpDir&quot;).toFile();
-   * 
+   *
    * // assertion will pass
    * assertThat(tmpDir).isDirectory();
-   * 
+   *
    * tmpDir.delete();
    * File tmpFile = File.createTempFile(&quot;tmp&quot;, &quot;txt&quot;);
-   * 
+   *
    * // assertions will fail
    * assertThat(tmpFile).isDirectory();
    * assertThat(tmpDir).isDirectory();</code></pre>
@@ -159,12 +161,12 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * <p>
    * Example:
    * <pre><code class='java'> File absoluteFile = File.createTempFile(&quot;tmp&quot;, &quot;txt&quot;);
-   * 
+   *
    * // assertions will pass
    * assertThat(absoluteFile).isAbsolute();
-   * 
+   *
    * File relativeFile = new File(&quot;./test&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(relativeFile).isAbsolute();</code></pre>
    *
@@ -182,12 +184,12 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * <p>
    * Example:
    * <pre><code class='java'> File relativeFile = new File(&quot;./test&quot;);
-   * 
+   *
    * // assertion will pass
    * assertThat(relativeFile).isRelative();
-   * 
+   *
    * File absoluteFile = File.createTempFile(&quot;tmp&quot;, &quot;txt&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(absoluteFile).isRelative();</code></pre>
    *
@@ -205,7 +207,7 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * The charset to use when reading the actual file can be provided with {@link #usingCharset(Charset)} or
    * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
    * {@link Charset#defaultCharset()}) will be used.
-   * 
+   *
    * Examples:
    * <pre><code class="java"> // use the default charset
    * File xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes()).toFile();
@@ -213,15 +215,15 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * File xFileFrench = Files.write(Paths.get("xfile-french.txt"), "La Vérité Est Ailleurs".getBytes()).toFile();
    * // use UTF-8 charset
    * File xFileUTF8 = Files.write(Paths.get("xfile-clone.txt"), Arrays.asList("The Truth Is Out There"), StandardCharsets.UTF_8).toFile();
-   * 
+   *
    * // The following assertion succeeds (default charset is used):
    * assertThat(xFile).hasSameContentAs(xFileClone);
    * // The following assertion succeeds (UTF-8 charset is used to read xFile):
    * assertThat(xFileUTF8).usingCharset("UTF-8").hasContent(xFileClone);
-   * 
+   *
    * // The following assertion fails:
    * assertThat(xFile).hasSameContentAs(xFileFrench);</code></pre>
-   * 
+   *
    * @param expected the given {@code File} to compare the actual {@code File} to.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given {@code File} is {@code null}.
@@ -243,7 +245,7 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * The charset to use when reading the actual file can be provided with {@link #usingCharset(Charset)} or
    * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
    * {@link Charset#defaultCharset()}) will be used.
-   * 
+   *
    * Examples:
    * <pre><code class="java"> // use the default charset
    * File xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes()).toFile();
@@ -251,15 +253,15 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * File xFileFrench = Files.write(Paths.get("xfile-french.txt"), "La Vérité Est Ailleurs".getBytes()).toFile();
    * // use UTF-8 charset
    * File xFileUTF8 = Files.write(Paths.get("xfile-clone.txt"), Arrays.asList("The Truth Is Out There"), StandardCharsets.UTF_8).toFile();
-   * 
+   *
    * // The following assertion succeeds (default charset is used):
    * assertThat(xFile).hasSameContentAs(xFileClone);
    * // The following assertion succeeds (UTF-8 charset is used to read xFile):
    * assertThat(xFileUTF8).usingCharset("UTF-8").hasContent(xFileClone);
-   * 
+   *
    * // The following assertion fails:
    * assertThat(xFile).hasSameContentAs(xFileFrench);</code></pre>
-   * 
+   *
    * @param expected the given {@code File} to compare the actual {@code File} to.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given {@code File} is {@code null}.
@@ -270,8 +272,8 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * @throws AssertionError if the content of the actual {@code File} is not equal to the content of the given one.
    */
   public SELF hasSameContentAs(File expected) {
-      files.assertSameContentAs(info, actual, charset, expected, Charset.defaultCharset());
-      return myself;
+    files.assertSameContentAs(info, actual, charset, expected, Charset.defaultCharset());
+    return myself;
   }
 
   /**
@@ -284,10 +286,10 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * <pre><code class="java"> File fileUTF8 = Files.write(Paths.get("actual"), Collections.singleton("Gerçek"), StandardCharsets.UTF_8).toFile();
    * Charset turkishCharset = Charset.forName("windows-1254");
    * File fileTurkischCharset = Files.write(Paths.get("expected"), Collections.singleton("Gerçek"), turkishCharset).toFile();
-   * 
+   *
    * // The following assertion succeeds:
    * assertThat(fileUTF8).usingCharset(StandardCharsets.UTF_8).hasSameContentAs(fileTurkischCharset, turkishCharset);
-   * 
+   *
    * // The following assertion fails:
    * assertThat(fileUTF8).usingCharset(StandardCharsets.UTF_8).hasSameContentAs(fileTurkischCharset, StandardCharsets.UTF_8);</code></pre>
    *
@@ -302,8 +304,8 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * @throws AssertionError if the content of the actual {@code File} is not equal to the content of the given one.
    */
   public SELF hasSameContentAs(File expected, Charset expectedCharset) {
-      files.assertSameContentAs(info, actual, charset, expected, expectedCharset);
-      return myself;
+    files.assertSameContentAs(info, actual, charset, expected, expectedCharset);
+    return myself;
   }
 
   /**
@@ -312,10 +314,10 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * Example:
    * <pre><code class='java'> File bin = File.createTempFile(&quot;tmp&quot;, &quot;bin&quot;);
    * Files.write(bin.toPath(), new byte[] {1, 1});
-   * 
+   *
    * // assertion will pass
    * assertThat(bin).hasBinaryContent(new byte[] {1, 1});
-   * 
+   *
    * // assertions will fail
    * assertThat(bin).hasBinaryContent(new byte[] { });
    * assertThat(bin).hasBinaryContent(new byte[] {0, 0});</code></pre>
@@ -335,7 +337,7 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
 
   /**
    * Specifies the name of the charset to use for text-based assertions on the file's contents.
-   * 
+   *
    * @param charsetName the name of the charset to use.
    * @return {@code this} assertion object.
    * @throws IllegalArgumentException if the given encoding is not supported on this platform.
@@ -348,7 +350,7 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
 
   /**
    * Specifies the charset to use for text-based assertions on the file's contents.
-   * 
+   *
    * @param charset the charset to use.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given charset is {@code null}.
@@ -368,21 +370,21 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * Example:
    * <pre><code class='java'> // use the default charset
    * File xFile = Files.write(Paths.get(&quot;xfile.txt&quot;), &quot;The Truth Is Out There&quot;.getBytes()).toFile();
-   * 
+   *
    * // The following assertion succeeds (default charset is used):
    * assertThat(xFile).hasContent(&quot;The Truth Is Out There&quot;);
-   * 
+   *
    * // The following assertion fails:
    * assertThat(xFile).hasContent(&quot;La Vérité Est Ailleurs&quot;);
-   * 
-   * // using a specific charset 
+   *
+   * // using a specific charset
    * Charset turkishCharset = Charset.forName(&quot;windows-1254&quot;);
-   * 
+   *
    * File xFileTurkish = Files.write(Paths.get(&quot;xfile.turk&quot;), Collections.singleton(&quot;Gerçek&quot;), turkishCharset).toFile();
-   * 
+   *
    * // The following assertion succeeds:
    * assertThat(xFileTurkish).usingCharset(turkishCharset).hasContent(&quot;Gerçek&quot;);
-   * 
+   *
    * // The following assertion fails :
    * assertThat(xFileTurkish).usingCharset(StandardCharsets.UTF_8).hasContent(&quot;Gerçek&quot;);</code></pre>
    *
@@ -405,14 +407,14 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * Example:
    * <pre><code class='java'> File tmpFile = File.createTempFile(&quot;tmp&quot;, &quot;txt&quot;);
    * File tmpDir = Files.createTempDirectory(&quot;tmp&quot;).toFile();
-   * 
+   *
    * // assertions will pass
    * assertThat(tmpFile).canWrite();
    * assertThat(tmpDir).canWrite();
-   * 
+   *
    * tmpFile.setReadOnly();
    * tmpDir.setReadOnly();
-   * 
+   *
    * // assertions will fail
    * assertThat(tmpFile).canWrite();
    * assertThat(tmpDir).canWrite();</code></pre>
@@ -432,14 +434,14 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * Example:
    * <pre><code class='java'> File tmpFile = File.createTempFile(&quot;tmp&quot;, &quot;txt&quot;);
    * File tmpDir = Files.createTempDirectory(&quot;tmp&quot;).toFile();
-   * 
+   *
    * // assertions will pass
    * assertThat(tmpFile).canRead();
    * assertThat(tmpDir).canRead();
-   * 
+   *
    * tmpFile.setReadable(false);
    * tmpDir.setReadable(false);
-   * 
+   *
    * // assertions will fail
    * assertThat(tmpFile).canRead();
    * assertThat(tmpDir).canRead();</code></pre>
@@ -459,20 +461,20 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
    * <p>
    * Example:
    * <pre><code class='java'> File xFile = new File(&quot;mulder/xFile&quot;);
-   * 
+   *
    * // assertion will pass
    * assertThat(xFile).hasParent(new File(&quot;mulder&quot;));
    *
    * // assertion will fail
    * assertThat(xFile).hasParent(new File(&quot;scully&quot;));</code></pre>
-   * 
+   *
    * @param expected the expected parent {@code File}.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the expected parent {@code File} is {@code null}.
    * @throws UncheckedIOException if an I/O error occurs.
    * @throws AssertionError if the actual {@code File} is {@code null}.
    * @throws AssertionError if the actual {@code File} parent is not equal to the expected one.
-   * 
+   *
    * @see java.io.File#getParentFile() parent definition.
    */
   public SELF hasParent(File expected) {
@@ -482,17 +484,17 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
 
   /**
    * Same as {@link #hasParent(java.io.File)} but takes care of converting given {@code String} as {@code File} for you
-   * 
+   *
    * <p>
    * Example:
    * <pre><code class='java'> File xFile = new File(&quot;mulder/xFile&quot;);
-   * 
+   *
    * // assertion will pass
    * assertThat(xFile).hasParent(&quot;mulder&quot;);
    *
    * // assertion will fail
    * assertThat(xFile).hasParent(&quot;scully&quot;);</code></pre>
-   * 
+   *
    * @param expected the expected parent file path.
    * @return {@code this} assertion object.
    */
@@ -503,24 +505,24 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
 
   /**
    * Verifies that the actual {@code File} has given extension.
-   * 
+   *
    * <p>
    * Example:
    * <pre><code class='java'> File xFile = new File(&quot;xFile.java&quot;);
-   * 
+   *
    * // assertion will pass
    * assertThat(xFile).hasExtension(&quot;java&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(xFile).hasExtension(&quot;png&quot;);</code></pre>
-   * 
+   *
    * @param expected the expected extension, it does not contains the {@code '.'}
    * @return {@code this} assertion object.
    * @throws NullPointerException if the expected extension is {@code null}.
    * @throws AssertionError if the actual {@code File} is {@code null}.
    * @throws AssertionError if the actual {@code File} is not a file (ie a directory).
    * @throws AssertionError if the actual {@code File} does not have the expected extension.
-   * 
+   *
    * @see <a href="http://en.wikipedia.org/wiki/Filename_extension">Filename extension</a>
    */
   public SELF hasExtension(String expected) {
@@ -530,26 +532,26 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
 
   /**
    * Verifies that the actual {@code File} has given name.
-   * 
+   *
    * <p>
    * Example:
    * <pre><code class='java'> File xFile = new File(&quot;somewhere/xFile.java&quot;);
    * File xDirectory = new File(&quot;somewhere/xDirectory&quot;);
-   * 
+   *
    * // assertion will pass
    * assertThat(xFile).hasName(&quot;xFile.java&quot;);
    * assertThat(xDirectory).hasName(&quot;xDirectory&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(xFile).hasName(&quot;xFile&quot;);
    * assertThat(xDirectory).hasName(&quot;somewhere&quot;);</code></pre>
-   * 
+   *
    * @param expected the expected {@code File} name.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the expected name is {@code null}.
    * @throws AssertionError if the actual {@code File} is {@code null}.
    * @throws AssertionError if the actual {@code File} does not have the expected name.
-   * 
+   *
    * @see java.io.File#getName() name definition.
    */
   public SELF hasName(String expected) {
@@ -559,20 +561,20 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
 
   /**
    * Verifies that the actual {@code File} does not have a parent.
-   * 
+   *
    * <p>
    * Example:
    * <pre><code class='java'> File xFile = new File(&quot;somewhere/xFile.java&quot;);
    * File xDirectory = new File(&quot;xDirectory&quot;);
-   * 
+   *
    * // assertion will pass
    * assertThat(xDirectory).hasNoParent();
-   * 
+   *
    * // assertion will fail
    * assertThat(xFile).hasNoParent();</code></pre>
-   * 
+   *
    * @return {@code this} assertion object.
-   * 
+   *
    * @throws AssertionError if the actual {@code File} is {@code null}.
    * @throws AssertionError if the actual {@code File} has a parent.
    */
@@ -580,4 +582,144 @@ public abstract class AbstractFileAssert<SELF extends AbstractFileAssert<SELF>>
     files.assertHasNoParent(info, actual);
     return myself;
   }
+
+  /**
+   * Verifies that the tested {@link File} digest (calculated with the specified {@link MessageDigest}) is equal to the given one.
+   * <p>
+   * Note that the {@link File} must be readable.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that assertj-core-2.9.0.jar was downloaded from https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * File tested = new File("assertj-core-2.9.0.jar");
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "5c5ae45b58f12023817abe492447cdc7912c1a2c".getBytes());
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "dcb3015cd28447644c810af352832c19".getBytes());
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad".getBytes());
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "3735dff8e1f9df0492a34ef075205b8f".getBytes()); </code></pre>
+   *
+   * @param digest the MessageDigest used to calculate the digests.
+   * @param expected the expected binary content to compare the actual {@code File}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given algorithm is {@code null}.
+   * @throws NullPointerException if the given digest is {@code null}.
+   * @throws AssertionError       if the actual {@code File} is {@code null}.
+   * @throws AssertionError       if the actual {@code File} does not exist.
+   * @throws AssertionError       if the actual {@code File} is not an file.
+   * @throws AssertionError       if the actual {@code File} is not readable.
+   * @throws UncheckedIOException if an I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code File}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(MessageDigest digest, byte[] expected) {
+    files.assertHasDigest(info, actual, digest, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link File} digest (calculated with the specified {@link MessageDigest}) is equal to the given one.
+   * <p>
+   * Note that the {@link File} must be readable.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that assertj-core-2.9.0.jar was downloaded from https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * File tested = new File("assertj-core-2.9.0.jar");
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "5c5ae45b58f12023817abe492447cdc7912c1a2c");
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "dcb3015cd28447644c810af352832c19");
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad");
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "3735dff8e1f9df0492a34ef075205b8f"); </code></pre>
+   *
+   * @param digest the MessageDigest used to calculate the digests.
+   * @param expected the expected binary content to compare the actual {@code File}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given algorithm is {@code null}.
+   * @throws NullPointerException if the given digest is {@code null}.
+   * @throws AssertionError       if the actual {@code File} is {@code null}.
+   * @throws AssertionError       if the actual {@code File} does not exist.
+   * @throws AssertionError       if the actual {@code File} is not an file.
+   * @throws AssertionError       if the actual {@code File} is not readable.
+   * @throws UncheckedIOException if an I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code File}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(MessageDigest digest, String expected) {
+    files.assertHasDigest(info, actual, digest, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link File} digest (calculated with the specified algorithm) is equal to the given one.
+   * <p>
+   * Note that the {@link File} must be readable.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that assertj-core-2.9.0.jar was downloaded from https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * File tested = new File("assertj-core-2.9.0.jar");
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest("SHA1", "5c5ae45b58f12023817abe492447cdc7912c1a2c".getBytes());
+   * assertThat(tested).hasDigest("MD5", "dcb3015cd28447644c810af352832c19".getBytes());
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest("SHA1", "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad".getBytes());
+   * assertThat(tested).hasDigest("MD5", "3735dff8e1f9df0492a34ef075205b8f".getBytes()); </code></pre>
+   *
+   * @param algorithm the algorithm used to calculate the digests.
+   * @param expected the expected digest to compare the actual {@code File}'s digest to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given algorithm is {@code null}.
+   * @throws NullPointerException if the given digest is {@code null}.
+   * @throws AssertionError       if the actual {@code File} is {@code null}.
+   * @throws AssertionError       if the actual {@code File} does not exist.
+   * @throws AssertionError       if the actual {@code File} is not an file.
+   * @throws AssertionError       if the actual {@code File} is not readable.
+   * @throws UncheckedIOException if any I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code File}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(String algorithm, byte[] expected) {
+    files.assertHasDigest(info, actual, algorithm, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link File} digest (calculated with the specified algorithm) is equal to the given one.
+   * <p>
+   * Note that the {@link File} must be readable.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that assertj-core-2.9.0.jar was downloaded from https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * File tested = new File("assertj-core-2.9.0.jar");
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest("SHA1", "5c5ae45b58f12023817abe492447cdc7912c1a2c");
+   * assertThat(tested).hasDigest("MD5", "dcb3015cd28447644c810af352832c19");
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest("SHA1", "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad");
+   * assertThat(tested).hasDigest("MD5", "3735dff8e1f9df0492a34ef075205b8f"); </code></pre>
+   *
+   * @param algorithm the algorithm used to calculate the digests.
+   * @param expected the expected digest to compare the actual {@code File}'s digest to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given algorithm is {@code null}.
+   * @throws NullPointerException if the given digest is {@code null}.
+   * @throws AssertionError       if the actual {@code File} is {@code null}.
+   * @throws AssertionError       if the actual {@code File} does not exist.
+   * @throws AssertionError       if the actual {@code File} is not an file.
+   * @throws AssertionError       if the actual {@code File} is not readable.
+   * @throws UncheckedIOException if any I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code File}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(String algorithm, String expected) {
+    files.assertHasDigest(info, actual, algorithm, expected);
+    return myself;
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/AbstractInputStreamAssert.java b/src/main/java/org/assertj/core/api/AbstractInputStreamAssert.java
index e6044de96..29652dc9e 100644
--- a/src/main/java/org/assertj/core/api/AbstractInputStreamAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractInputStreamAssert.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api;
 
 import java.io.InputStream;
+import java.security.MessageDigest;
 
 import org.assertj.core.internal.InputStreams;
 import org.assertj.core.internal.InputStreamsException;
@@ -66,7 +67,7 @@ public abstract class AbstractInputStreamAssert<SELF extends AbstractInputStream
    * // assertions will fail
    * assertThat(new ByteArrayInputStream(new byte[] {0xa})).hasSameContentAs(new ByteArrayInputStream(new byte[] {}));
    * assertThat(new ByteArrayInputStream(new byte[] {0xa})).hasSameContentAs(new ByteArrayInputStream(new byte[] {0xa, 0xc, 0xd}));</code></pre>
-   * 
+   *
    * @param expected the given {@code InputStream} to compare the actual {@code InputStream} to.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given {@code InputStream} is {@code null}.
@@ -102,4 +103,128 @@ public abstract class AbstractInputStreamAssert<SELF extends AbstractInputStream
     inputStreams.assertHasContent(info, actual, expected);
     return myself;
   }
+
+  /**
+   * Verifies that the tested {@link InputStream} digest (calculated with the specified {@link MessageDigest}) is equal to the given one.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that assertj-core-2.9.0.jar was downloaded from https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * InputStream tested = new FileInputStream(new File("assertj-core-2.9.0.jar"));
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "5c5ae45b58f12023817abe492447cdc7912c1a2c".getBytes());
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "dcb3015cd28447644c810af352832c19".getBytes());
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad".getBytes());
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "3735dff8e1f9df0492a34ef075205b8f".getBytes());</code></pre>
+   *
+   * @param digest the MessageDigest used to calculate the digests.
+   * @param expected the expected binary content to compare the actual {@code InputStream}'s digest to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException  if the given algorithm is {@code null}.
+   * @throws NullPointerException  if the given digest is {@code null}.
+   * @throws AssertionError        if the actual {@code InputStream} is {@code null}.
+   * @throws AssertionError        if the actual {@code InputStream} is not readable.
+   * @throws InputStreamsException if an I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code InputStream}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(MessageDigest digest, byte[] expected) {
+    inputStreams.assertHasDigest(info, actual, digest, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link InputStream} digest (calculated with the specified {@link MessageDigest}) is equal to the given one.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that assertj-core-2.9.0.jar was downloaded from https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * InputStream tested = new FileInputStream(new File("assertj-core-2.9.0.jar"));
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "5c5ae45b58f12023817abe492447cdc7912c1a2c");
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "dcb3015cd28447644c810af352832c19");
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad");
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "3735dff8e1f9df0492a34ef075205b8f");</code></pre>
+   *
+   * @param digest the MessageDigest used to calculate the digests.
+   * @param expected the expected binary content to compare the actual {@code InputStream}'s digest to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException  if the given algorithm is {@code null}.
+   * @throws NullPointerException  if the given digest is {@code null}.
+   * @throws AssertionError        if the actual {@code InputStream} is {@code null}.
+   * @throws AssertionError        if the actual {@code InputStream} is not readable.
+   * @throws InputStreamsException if an I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code InputStream}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(MessageDigest digest, String expected) {
+    inputStreams.assertHasDigest(info, actual, digest, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link InputStream} digest (calculated with the specified algorithm) is equal to the given one.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that assertj-core-2.9.0.jar was downloaded from https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * InputStream tested = new FileInputStream(new File("assertj-core-2.9.0.jar"));
+   *
+   * // The following assertion succeeds:
+   * assertThat(tested).hasDigest("SHA1", "5c5ae45b58f12023817abe492447cdc7912c1a2c".getBytes());
+   * assertThat(tested).hasDigest("MD5", "dcb3015cd28447644c810af352832c19".getBytes());
+   *
+   * // The following assertion fails:
+   * assertThat(tested).hasDigest("SHA1", "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad".getBytes());
+   * assertThat(tested).hasDigest("MD5", "3735dff8e1f9df0492a34ef075205b8f".getBytes()); </code></pre>
+   *
+   * @param algorithm the algorithm used to calculate the digests.
+   * @param expected the expected binary content to compare the actual {@code InputStream}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException  if the given algorithm is {@code null}.
+   * @throws NullPointerException  if the given digest is {@code null}.
+   * @throws AssertionError        if the actual {@code InputStream} is {@code null}.
+   * @throws AssertionError        if the actual {@code InputStream} is not readable.
+   * @throws InputStreamsException if an I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code InputStream}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(String algorithm, byte[] expected) {
+    inputStreams.assertHasDigest(info, actual, algorithm, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link InputStream} digest (calculated with the specified algorithm) is equal to the given one.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that assertj-core-2.9.0.jar was downloaded from https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * InputStream tested = new FileInputStream(new File("assertj-core-2.9.0.jar"));
+   *
+   * // The following assertion succeeds:
+   * assertThat(tested).hasDigest("SHA1", "5c5ae45b58f12023817abe492447cdc7912c1a2c");
+   * assertThat(tested).hasDigest("MD5", "dcb3015cd28447644c810af352832c19");
+   *
+   * // The following assertion fails:
+   * assertThat(tested).hasDigest("SHA1", "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad");
+   * assertThat(tested).hasDigest("MD5", "3735dff8e1f9df0492a34ef075205b8f"); </code></pre>
+   *
+   * @param algorithm the algorithm used to calculate the digests.
+   * @param expected the expected binary content to compare the actual {@code InputStream}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException  if the given algorithm is {@code null}.
+   * @throws NullPointerException  if the given digest is {@code null}.
+   * @throws AssertionError        if the actual {@code InputStream} is {@code null}.
+   * @throws AssertionError        if the actual {@code InputStream} is not readable.
+   * @throws InputStreamsException if an I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code InputStream}'s digest is not equal to the given one.
+   * @since 3.110.0
+   */
+  public SELF hasDigest(String algorithm, String expected) {
+    inputStreams.assertHasDigest(info, actual, algorithm, expected);
+    return myself;
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/AbstractPathAssert.java b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
index 56f5d358f..32fae757e 100644
--- a/src/main/java/org/assertj/core/api/AbstractPathAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractPathAssert.java
@@ -24,6 +24,7 @@ import java.nio.file.LinkOption;
 import java.nio.file.Path;
 import java.nio.file.ProviderMismatchException;
 import java.nio.file.spi.FileSystemProvider;
+import java.security.MessageDigest;
 
 import org.assertj.core.api.exception.PathsException;
 import org.assertj.core.internal.Paths;
@@ -87,7 +88,7 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
   Charset charset = Charset.defaultCharset();
 
   public AbstractPathAssert(final Path actual, final Class<?> selfType) {
-	super(actual, selfType);
+    super(actual, selfType);
   }
 
   /**
@@ -96,22 +97,22 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * The charset to use when reading the actual path can be provided with {@link #usingCharset(Charset)} or
    * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
    * {@link Charset#defaultCharset()}) will be used.
-   * 
+   *
    * Examples:
    * <pre><code class="java"> // use the default charset
    * Path xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes());
    * Path xFileUTF8 = Files.write(Paths.get("xfile-clone.txt"), "The Truth Is Out There".getBytes("UTF-8"));
    * Path xFileClone = Files.write(Paths.get("xfile-clone.txt"), "The Truth Is Out There".getBytes());
    * Path xFileFrench = Files.write(Paths.get("xfile-french.txt"), "La Vérité Est Ailleurs".getBytes());
-   * 
+   *
    * // The following assertion succeeds (default charset is used):
    * assertThat(xFile).hasSameContentAs(xFileClone);
    * // The following assertion succeeds (UTF-8 charset is used to read xFile):
    * assertThat(xFileUTF8).usingCharset("UTF-8").hasContent(xFileClone);
-   * 
+   *
    * // The following assertion fails:
    * assertThat(xFile).hasSameContentAs(xFileFrench);</code></pre>
-   * 
+   *
    * @param expected the given {@code Path} to compare the actual {@code Path} to.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given {@code Path} is {@code null}.
@@ -121,8 +122,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @throws PathsException if an I/O error occurs.
    */
   public SELF hasSameContentAs(Path expected) {
-	paths.assertHasSameContentAs(info, actual, charset, expected, Charset.defaultCharset());
-	return myself;
+    paths.assertHasSameContentAs(info, actual, charset, expected, Charset.defaultCharset());
+    return myself;
   }
 
   /**
@@ -130,18 +131,18 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * the charset used to read the actual path can be provided with {@link #usingCharset(Charset)} or
    * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
    * {@link Charset#defaultCharset()}) will be used.
-   * 
+   *
    * Examples:
    * <pre><code class="java"> Path fileUTF8Charset = Files.write(Paths.get("actual"), Collections.singleton("Gerçek"), StandardCharsets.UTF_8);
    * Charset turkishCharset = Charset.forName("windows-1254");
    * Path fileTurkischCharset = Files.write(Paths.get("expected"), Collections.singleton("Gerçek"), turkishCharset);
-   * 
+   *
    * // The following assertion succeeds:
    * assertThat(fileUTF8Charset).usingCharset(StandardCharsets.UTF_8).hasSameContentAs(fileTurkischCharset, turkishCharset);
-   * 
+   *
    * // The following assertion fails:
    * assertThat(fileUTF8Charset).usingCharset(StandardCharsets.UTF_8).hasSameContentAs(fileTurkischCharset, StandardCharsets.UTF_8);</code></pre>
-   * 
+   *
    * @param expected the given {@code Path} to compare the actual {@code Path} to.
    * @param expectedCharset the {@link Charset} used to read the content of the expected Path.
    * @return {@code this} assertion object.
@@ -152,9 +153,9 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @throws PathsException if an I/O error occurs.
    */
   public SELF hasSameContentAs(Path expected, Charset expectedCharset) {
-      paths.assertHasSameContentAs(info, actual, charset, expected, expectedCharset);
-      return myself;
-    }
+    paths.assertHasSameContentAs(info, actual, charset, expected, expectedCharset);
+    return myself;
+  }
 
   /**
    * Verifies that the binary content of the actual {@code Path} is <b>exactly</b> equal to the given one.
@@ -164,18 +165,18 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * Path xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes());
    * assertThat(xFile).hasBinaryContent("The Truth Is Out There".getBytes());
    *
-   * // using a specific charset 
+   * // using a specific charset
    * Charset turkishCharset = Charset.forName("windows-1254");
    * Path xFileTurkish = Files.write(Paths.get("xfile.turk"), Collections.singleton("Gerçek Başka bir yerde mi"), turkishCharset);
-   * 
+   *
    * // The following assertion succeeds:
    * String expectedContent = "Gerçek Başka bir yerde mi" + org.assertj.core.util.Compatibility.System.lineSeparator();
    * byte[] binaryContent = expectedContent.getBytes(turkishCharset.name());
    * assertThat(xFileTurkish).hasBinaryContent(binaryContent);
-   * 
+   *
    * // The following assertion fails ... unless you are in Turkey ;-):
    * assertThat(xFileTurkish).hasBinaryContent("Gerçek Başka bir yerde mi".getBytes());</code></pre>
-   * 
+   *
    * @param expected the expected binary content to compare the actual {@code File}'s content to.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given content is {@code null}.
@@ -185,21 +186,21 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @throws AssertionError if the content of the actual {@code File} is not equal to the given binary content.
    */
   public SELF hasBinaryContent(byte[] expected) {
-	paths.assertHasBinaryContent(info, actual, expected);
-	return myself;
+    paths.assertHasBinaryContent(info, actual, expected);
+    return myself;
   }
 
   /**
    * Specifies the name of the charset to use for text-based assertions on the path's contents (path must be a readable
    * file).
-   * 
+   *
    * Examples:
    * <pre><code class="java"> Charset turkishCharset = Charset.forName("windows-1254");
    * Path xFileTurkish = Files.write(Paths.get("xfile.turk"), Collections.singleton("Gerçek Başka bir yerde mi"), turkishCharset);
-   * 
+   *
    * // The following assertion succeeds:
    * assertThat(xFileTurkish).usingCharset("windows-1254").hasContent("Gerçek Başka bir yerde mi");</code></pre>
-   * 
+   *
    * @param charsetName the name of the charset to use.
    * @return {@code this} assertion object.
    * @throws IllegalArgumentException if the given encoding is not supported on this platform.
@@ -212,22 +213,22 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
 
   /**
    * Specifies the charset to use for text-based assertions on the path's contents (path must be a readable file).
-   * 
+   *
    * Examples:
    * <pre><code class="java"> Charset turkishCharset = Charset.forName("windows-1254");
    * Path xFileTurkish = Files.write(Paths.get("xfile.turk"), Collections.singleton("Gerçek Başka bir yerde mi"), turkishCharset);
-   * 
+   *
    * // The following assertion succeeds:
    * assertThat(xFileTurkish).usingCharset(turkishCharset).hasContent("Gerçek Başka bir yerde mi");</code></pre>
-   * 
+   *
    * @param charset the charset to use.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given charset is {@code null}.
    */
   @CheckReturnValue
   public SELF usingCharset(Charset charset) {
-	this.charset = checkNotNull(charset, "The charset should not be null");
-	return myself;
+    this.charset = checkNotNull(charset, "The charset should not be null");
+    return myself;
   }
 
   /**
@@ -236,25 +237,25 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * The charset to use when reading the actual path should be provided with {@link #usingCharset(Charset)} or
    * {@link #usingCharset(String)} prior to calling this method; if not, the platform's default charset (as returned by
    * {@link Charset#defaultCharset()}) will be used.
-   * 
+   *
    * Examples:
    * <pre><code class="java"> // use the default charset
    * Path xFile = Files.write(Paths.get("xfile.txt"), "The Truth Is Out There".getBytes());
-   * 
+   *
    * // The following assertion succeeds (default charset is used):
    * assertThat(xFile).hasContent("The Truth Is Out There");
-   * 
+   *
    * // The following assertion fails:
    * assertThat(xFile).hasContent("La Vérité Est Ailleurs");
-   * 
-   * // using a specific charset 
+   *
+   * // using a specific charset
    * Charset turkishCharset = Charset.forName("windows-1254");
-   * 
+   *
    * Path xFileTurkish = Files.write(Paths.get("xfile.turk"), Collections.singleton("Gerçek Başka bir yerde mi"), turkishCharset);
-   * 
+   *
    * // The following assertion succeeds:
    * assertThat(xFileTurkish).usingCharset(turkishCharset).hasContent("Gerçek Başka bir yerde mi");
-   * 
+   *
    * // The following assertion fails ... unless you are in Turkey ;-):
    * assertThat(xFileTurkish).hasContent("Gerçek Başka bir yerde mi");</code></pre>
    *
@@ -267,8 +268,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @throws AssertionError if the content of the actual {@code File} is not equal to the given content.
    */
   public SELF hasContent(String expected) {
-	paths.assertHasContent(info, actual, expected, charset);
-	return myself;
+    paths.assertHasContent(info, actual, expected, charset);
+    return myself;
   }
 
   /**
@@ -280,15 +281,15 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * Path readableFile = Paths.get("readableFile");
    * Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("r--r--r--");
    * Files.createFile(readableFile, PosixFilePermissions.asFileAttribute(perms));
-   * 
+   *
    * final Path symlinkToReadableFile = FileSystems.getDefault().getPath("symlinkToReadableFile");
    * Files.createSymbolicLink(symlinkToReadableFile, readableFile);
-   * 
+   *
    * // Create a file and set permissions not to be readable.
    * Path nonReadableFile = Paths.get("nonReadableFile");
    * Set&lt;PosixFilePermission&gt; notReadablePerms = PosixFilePermissions.fromString("-wx------");
    * Files.createFile(nonReadableFile, PosixFilePermissions.asFileAttribute(notReadablePerms));
-   * 
+   *
    * final Path nonExistentPath = FileSystems.getDefault().getPath("nonexistent");
    *
    * // The following assertions succeed:
@@ -304,8 +305,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Files#isReadable(Path)
    */
   public SELF isReadable() {
-	paths.assertIsReadable(info, actual);
-	return myself;
+    paths.assertIsReadable(info, actual);
+    return myself;
   }
 
   /**
@@ -317,15 +318,15 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * Path writableFile = Paths.get("writableFile");
    * Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("rw-rw-rw-");
    * Files.createFile(writableFile, PosixFilePermissions.asFileAttribute(perms));
-   * 
+   *
    * final Path symlinkToWritableFile = FileSystems.getDefault().getPath("symlinkToWritableFile");
    * Files.createSymbolicLink(symlinkToWritableFile, writableFile);
-   * 
+   *
    * // Create a file and set permissions not to be writable.
    * Path nonWritableFile = Paths.get("nonWritableFile");
    * perms = PosixFilePermissions.fromString("r--r--r--");
    * Files.createFile(nonWritableFile, PosixFilePermissions.asFileAttribute(perms));
-   * 
+   *
    * final Path nonExistentPath = FileSystems.getDefault().getPath("nonexistent");
    *
    * // The following assertions succeed:
@@ -341,8 +342,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Files#isWritable(Path)
    */
   public SELF isWritable() {
-	paths.assertIsWritable(info, actual);
-	return myself;
+    paths.assertIsWritable(info, actual);
+    return myself;
   }
 
   /**
@@ -355,15 +356,15 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * Path executableFile = Paths.get("executableFile");
    * Set&lt;PosixFilePermission&gt; perms = PosixFilePermissions.fromString("r-xr-xr-x");
    * Files.createFile(executableFile, PosixFilePermissions.asFileAttribute(perms));
-   * 
+   *
    * final Path symlinkToExecutableFile = FileSystems.getDefault().getPath("symlinkToExecutableFile");
    * Files.createSymbolicLink(symlinkToExecutableFile, executableFile);
-   * 
+   *
    * // Create a file and set permissions not to be executable.
    * Path nonExecutableFile = Paths.get("nonExecutableFile");
    * perms = PosixFilePermissions.fromString("rw-------");
    * Files.createFile(nonExecutableFile, PosixFilePermissions.asFileAttribute(perms));
-   * 
+   *
    * final Path nonExistentPath = FileSystems.getDefault().getPath("nonexistent");
    *
    * // The following assertions succeed:
@@ -379,8 +380,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Files#isExecutable(Path)
    */
   public SELF isExecutable() {
-	paths.assertIsExecutable(info, actual);
-	return myself;
+    paths.assertIsExecutable(info, actual);
+    return myself;
   }
 
   /**
@@ -423,8 +424,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Files#exists(Path, LinkOption...)
    */
   public SELF exists() {
-	paths.assertExists(info, actual);
-	return myself;
+    paths.assertExists(info, actual);
+    return myself;
   }
 
   /**
@@ -443,7 +444,7 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * Files.createFile(existingFile);
    * final Path symlinkToExistingFile = fs.getPath("symlink");
    * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
-   * 
+   *
    * // Create a symbolic link whose target does not exist
    * final Path nonExistentPath = fs.getPath("nonexistent");
    * final Path symlinkToNonExistentPath = fs.getPath("symlinkToNonExistentPath");
@@ -462,8 +463,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Files#exists(Path, LinkOption...)
    */
   public SELF existsNoFollowLinks() {
-	paths.assertExistsNoFollowLinks(info, actual);
-	return myself;
+    paths.assertExistsNoFollowLinks(info, actual);
+    return myself;
   }
 
   /**
@@ -488,7 +489,7 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * Files.createFile(existingFile);
    * final Path symlinkToExistingFile = fs.getPath("symlink");
    * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
-   * 
+   *
    * // Create a symbolic link to a nonexistent target file.
    * final Path nonExistentPath = fs.getPath("nonExistentPath");
    * final Path symlinkToNonExistentPath = fs.getPath("symlinkToNonExistentPath");
@@ -496,7 +497,7 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    *
    * // The following assertion succeeds
    * assertThat(nonExistentPath).doesNotExist();
-   * 
+   *
    * // The following assertions fail:
    * assertThat(existingFile).doesNotExist();
    * assertThat(symlinkToExistingFile).doesNotExist();
@@ -509,8 +510,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see LinkOption#NOFOLLOW_LINKS
    */
   public SELF doesNotExist() {
-	paths.assertDoesNotExist(info, actual);
-	return myself;
+    paths.assertDoesNotExist(info, actual);
+    return myself;
   }
 
   /**
@@ -561,8 +562,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @return self
    */
   public SELF isRegularFile() {
-	paths.assertIsRegularFile(info, actual);
-	return myself;
+    paths.assertIsRegularFile(info, actual);
+    return myself;
   }
 
   /**
@@ -612,8 +613,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @return self
    */
   public SELF isDirectory() {
-	paths.assertIsDirectory(info, actual);
-	return myself;
+    paths.assertIsDirectory(info, actual);
+    return myself;
   }
 
   /**
@@ -658,8 +659,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @return self
    */
   public SELF isSymbolicLink() {
-	paths.assertIsSymbolicLink(info, actual);
-	return myself;
+    paths.assertIsSymbolicLink(info, actual);
+    return myself;
   }
 
   /**
@@ -694,8 +695,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Path#isAbsolute()
    */
   public SELF isAbsolute() {
-	paths.assertIsAbsolute(info, actual);
-	return myself;
+    paths.assertIsAbsolute(info, actual);
+    return myself;
   }
 
   /**
@@ -726,8 +727,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Path#isAbsolute()
    */
   public SELF isRelative() {
-	paths.assertIsRelative(info, actual);
-	return myself;
+    paths.assertIsRelative(info, actual);
+    return myself;
   }
 
   /**
@@ -755,8 +756,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @return self
    */
   public SELF isNormalized() {
-	paths.assertIsNormalized(info, actual);
-	return myself;
+    paths.assertIsNormalized(info, actual);
+    return myself;
   }
 
   /**
@@ -774,11 +775,11 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * // Create a directory
    * final Path basedir = fs.getPath("/tmp/foo");
    * Files.createDirectories(basedir);
-   * 
+   *
    * // Create a file in this directory
    * final Path existingFile = basedir.resolve("existingFile");
    * Files.createFile(existingFile);
-   * 
+   *
    * // Create a symbolic link to that file
    * final Path symlinkToExistingFile = basedir.resolve("symlinkToExistingFile");
    * Files.createSymbolicLink(symlinkToExistingFile, existingFile);
@@ -796,8 +797,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Files#isSameFile(Path, Path)
    */
   public SELF isCanonical() {
-	paths.assertIsCanonical(info, actual);
-	return myself;
+    paths.assertIsCanonical(info, actual);
+    return myself;
   }
 
   /**
@@ -822,7 +823,7 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    *
    * // the following assertions fail:
    * assertThat(fs.getPath("/dir1/file.txt").hasFileName("other.txt");
-   * // fail because, last element is "." 
+   * // fail because, last element is "."
    * assertThat(fs.getPath("/dir1/.")).hasFileName("dir1");
    * // fail because a link filename is not the same as its target filename
    * assertThat(symlink).hasFileName("file.txt");</code></pre>
@@ -834,8 +835,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Path#getFileName()
    */
   public SELF hasFileName(final String fileName) {
-	paths.assertHasFileName(info, actual, fileName);
-	return myself;
+    paths.assertHasFileName(info, actual, fileName);
+    return myself;
   }
 
   /**
@@ -868,19 +869,19 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    *
    * @throws NullPointerException if the given parent path is null.
    * @throws PathsException failed to canonicalize the tested path or the path given as an argument
-   * 
+   *
    * @see Path#getParent()
    */
   public SELF hasParent(final Path expected) {
-	paths.assertHasParent(info, actual, expected);
-	return myself;
+    paths.assertHasParent(info, actual, expected);
+    return myself;
   }
 
   /**
    * Assert that the tested {@link Path} has the expected parent path.
    *
    * <p>
-   * <em>This assertion will not perform any canonicalization of either the tested path or the path given as an argument; 
+   * <em>This assertion will not perform any canonicalization of either the tested path or the path given as an argument;
    * see class description for more details. If this is not what you want, use {@link #hasParent(Path)} instead.</em>
    * </p>
    *
@@ -917,12 +918,12 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @return self
    *
    * @throws NullPointerException if the given parent path is null.
-   * 
+   *
    * @see Path#getParent()
    */
   public SELF hasParentRaw(final Path expected) {
-	paths.assertHasParentRaw(info, actual, expected);
-	return myself;
+    paths.assertHasParentRaw(info, actual, expected);
+    return myself;
   }
 
   /**
@@ -956,15 +957,15 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Path#getParent()
    */
   public SELF hasNoParent() {
-	paths.assertHasNoParent(info, actual);
-	return myself;
+    paths.assertHasNoParent(info, actual);
+    return myself;
   }
 
   /**
    * Assert that the tested {@link Path} has no parent.
    *
    * <p>
-   * <em>This assertion will not canonicalize the tested path before performing the test; 
+   * <em>This assertion will not canonicalize the tested path before performing the test;
    * if this is not what you want, use {@link #hasNoParent()} instead.</em>
    * </p>
    *
@@ -996,15 +997,15 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Path#getParent()
    */
   public SELF hasNoParentRaw() {
-	paths.assertHasNoParentRaw(info, actual);
-	return myself;
+    paths.assertHasNoParentRaw(info, actual);
+    return myself;
   }
 
   /**
    * Assert that the tested {@link Path} starts with the given path.
    *
    * <p>
-   * <em>This assertion will perform canonicalization of both the tested path and the path given as an argument; 
+   * <em>This assertion will perform canonicalization of both the tested path and the path given as an argument;
    * see class description for more details. If this is not what you want, use {@link #startsWithRaw(Path)} instead.</em>
    * </p>
    *
@@ -1038,8 +1039,8 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @see Path#toRealPath(LinkOption...)
    */
   public SELF startsWith(final Path other) {
-	paths.assertStartsWith(info, actual, other);
-	return myself;
+    paths.assertStartsWith(info, actual, other);
+    return myself;
   }
 
   /**
@@ -1080,12 +1081,12 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @return self
    *
    * @throws NullPointerException if the given path is null.
-   * 
+   *
    * @see Path#startsWith(Path)
    */
   public SELF startsWithRaw(final Path other) {
-	paths.assertStartsWithRaw(info, actual, other);
-	return myself;
+    paths.assertStartsWithRaw(info, actual, other);
+    return myself;
   }
 
   /**
@@ -1121,13 +1122,13 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    * @throws NullPointerException if the given path is null.
    * @throws PathsException failed to canonicalize the tested path (see class
    *           description)
-   * 
+   *
    * @see Path#endsWith(Path)
    * @see Path#toRealPath(LinkOption...)
    */
   public SELF endsWith(final Path other) {
-	paths.assertEndsWith(info, actual, other);
-	return myself;
+    paths.assertEndsWith(info, actual, other);
+    return myself;
   }
 
   /**
@@ -1161,13 +1162,156 @@ public abstract class AbstractPathAssert<SELF extends AbstractPathAssert<SELF>>
    *
    * @param other the other path
    * @return self
-   * 
+   *
    * @throws NullPointerException if the given path is null.
-   * 
+   *
    * @see Path#endsWith(Path)
    */
   public SELF endsWithRaw(final Path other) {
-	paths.assertEndsWithRaw(info, actual, other);
-	return myself;
+    paths.assertEndsWithRaw(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link Path} digest (calculated with the specified {@link MessageDigest}) is equal to the given one.
+   * <p>
+   * Note that the {@link Path} must be readable.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // fs is a filesystem
+   * // assume that the current directory contains https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar.
+   * Path tested = fs.getPath("assertj-core-2.9.0.jar");
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "5c5ae45b58f12023817abe492447cdc7912c1a2c".getBytes());
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "dcb3015cd28447644c810af352832c19".getBytes());
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad".getBytes());
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "3735dff8e1f9df0492a34ef075205b8f".getBytes()); </code></pre>
+   *
+   * @param digest the MessageDigest used to calculate the digests.
+   * @param expected the expected binary content to compare the actual {@code Path}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given algorithm is {@code null}.
+   * @throws NullPointerException if the given digest is {@code null}.
+   * @throws AssertionError       if the actual {@code Path} is {@code null}.
+   * @throws AssertionError       if the actual {@code Path} does not exist.
+   * @throws AssertionError       if the actual {@code Path} is not an file.
+   * @throws AssertionError       if the actual {@code Path} is not readable.
+   * @throws UncheckedIOException if any I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code Path}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(MessageDigest digest, byte[] expected) {
+    paths.assertHasDigest(info, actual, digest, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link Path} digest (calculated with the specified {@link MessageDigest}) is equal to the given one.
+   * <p>
+   * Note that the {@link Path} must be readable.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // fs is a filesystem
+   * // assume that the current directory contains https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar.
+   * Path tested = fs.getPath("assertj-core-2.9.0.jar");
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "5c5ae45b58f12023817abe492447cdc7912c1a2c");
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "dcb3015cd28447644c810af352832c19");
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("SHA1"), "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad");
+   * assertThat(tested).hasDigest(MessageDigest.getInstance("MD5"), "3735dff8e1f9df0492a34ef075205b8f"); </code></pre>
+   *
+   * @param digest the MessageDigest used to calculate the digests.
+   * @param expected the expected binary content to compare the actual {@code Path}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given algorithm is {@code null}.
+   * @throws NullPointerException if the given digest is {@code null}.
+   * @throws AssertionError       if the actual {@code Path} is {@code null}.
+   * @throws AssertionError       if the actual {@code Path} does not exist.
+   * @throws AssertionError       if the actual {@code Path} is not an file.
+   * @throws AssertionError       if the actual {@code Path} is not readable.
+   * @throws UncheckedIOException if any I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code Path}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(MessageDigest digest, String expected) {
+    paths.assertHasDigest(info, actual, digest, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link Path} digest (calculated with the specified algorithm) is equal to the given one.
+   * <p>
+   * Note that the {@link Path} must be readable.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // fs is a filesystem
+   * // assume that the current directory contains https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar.
+   * Path tested = fs.getPath("assertj-core-2.9.0.jar");
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest("SHA1", "5c5ae45b58f12023817abe492447cdc7912c1a2c".getBytes());
+   * assertThat(tested).hasDigest("MD5", "dcb3015cd28447644c810af352832c19".getBytes());
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest("SHA1", "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad".getBytes());
+   * assertThat(tested).hasDigest("MD5", "3735dff8e1f9df0492a34ef075205b8f".getBytes()); </code></pre>
+   *
+   * @param algorithm the algorithm used to calulate the digests to compare.
+   * @param expected the expected binary content to compare the actual {@code Path}'s content to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given algorithm is {@code null}.
+   * @throws NullPointerException if the given digest is {@code null}.
+   * @throws AssertionError       if the actual {@code Path} is {@code null}.
+   * @throws AssertionError       if the actual {@code Path} does not exist.
+   * @throws AssertionError       if the actual {@code Path} is not an file.
+   * @throws AssertionError       if the actual {@code Path} is not readable.
+   * @throws UncheckedIOException if any I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code Path}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(String algorithm, byte[] expected) {
+    paths.assertHasDigest(info, actual, algorithm, expected);
+    return myself;
+  }
+
+  /**
+   * Verifies that the tested {@link Path} digest (calculated with the specified algorithm) is equal to the given one.
+   * <p>
+   * Note that the {@link Path} must be readable.
+   * <p>
+   * Examples:
+   * <pre><code class="java"> // assume that fs is a filesystem containing https://repo1.maven.org/maven2/org/assertj/assertj-core/2.9.0/assertj-core-2.9.0.jar
+   * Path tested = fs.getPath("assertj-core-2.9.0.jar");
+   *
+   * // The following assertions succeed:
+   * assertThat(tested).hasDigest("SHA1", "5c5ae45b58f12023817abe492447cdc7912c1a2c");
+   * assertThat(tested).hasDigest("MD5", "dcb3015cd28447644c810af352832c19");
+   *
+   * // The following assertions fail:
+   * assertThat(tested).hasDigest("SHA1", "93b9ced2ee5b3f0f4c8e640e77470dab031d4cad");
+   * assertThat(tested).hasDigest("MD5", "3735dff8e1f9df0492a34ef075205b8f"); </code></pre>
+   *
+   * @param algorithm the algorithm used to calculate the digests.
+   * @param expected the expected digest to compare the actual {@code Path}'s digest to.
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given algorithm is {@code null}.
+   * @throws NullPointerException if the given digest is {@code null}.
+   * @throws AssertionError       if the actual {@code Path} is {@code null}.
+   * @throws AssertionError       if the actual {@code Path} does not exist.
+   * @throws AssertionError       if the actual {@code Path} is not an file.
+   * @throws AssertionError       if the actual {@code Path} is not readable.
+   * @throws UncheckedIOException if any I/O error occurs.
+   * @throws AssertionError       if the content of the tested {@code Path}'s digest is not equal to the given one.
+   * @since 3.11.0
+   */
+  public SELF hasDigest(String algorithm, String expected) {
+    paths.assertHasDigest(info, actual, algorithm, expected);
+    return myself;
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveDigest.java b/src/main/java/org/assertj/core/error/ShouldHaveDigest.java
new file mode 100644
index 000000000..84e8c745d
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldHaveDigest.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import java.io.File;
+import java.io.InputStream;
+import java.nio.file.Path;
+
+import org.assertj.core.internal.DigestDiff;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that file/inputStream/path have digest failed.
+ *
+ * @author Valeriy Vyrva
+ */
+public class ShouldHaveDigest extends BasicErrorMessageFactory {
+
+  public static ErrorMessageFactory shouldHaveDigest(Path actualSource, DigestDiff diff) {
+    return new ShouldHaveDigest(actualSource, diff);
+  }
+
+  public static ErrorMessageFactory shouldHaveDigest(File actualSource, DigestDiff diff) {
+    return new ShouldHaveDigest(actualSource, diff);
+  }
+
+  public static ErrorMessageFactory shouldHaveDigest(InputStream actualSource, DigestDiff diff) {
+    return new ShouldHaveDigest(actualSource, diff);
+  }
+
+  private ShouldHaveDigest(Path actualSource, DigestDiff diff) {
+    super(errorMessage("Path", diff), actualSource, diff.getExpected(), diff.getActual());
+  }
+
+  private ShouldHaveDigest(File actualSource, DigestDiff diff) {
+    super(errorMessage("File", diff), actualSource, diff.getExpected(), diff.getActual());
+  }
+
+  private ShouldHaveDigest(InputStream actualSource, DigestDiff diff) {
+    super(errorMessage("InputStream", diff), actualSource, diff.getExpected(), diff.getActual());
+  }
+
+  private static String errorMessage(String actualType, DigestDiff diff) {
+    return "%nExpecting " + actualType + " %s " + diff.getDigestAlgorithm() + " digest to be:%n" +
+           "  <%s>%n" +
+           "but was:%n" +
+           "  <%s>";
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/internal/DigestDiff.java b/src/main/java/org/assertj/core/internal/DigestDiff.java
new file mode 100644
index 000000000..7b39cb5fb
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/DigestDiff.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import java.security.MessageDigest;
+
+/**
+ * Compares the digest values
+ *
+ * @author Valeriy Vyrva
+ */
+public class DigestDiff {
+  private final MessageDigest digest;
+  private final String expected;
+  private final String actual;
+
+  public DigestDiff(String actual, String expected, MessageDigest digest) {
+    this.digest = digest;
+    this.expected = expected;
+    this.actual = actual;
+  }
+
+  public String getExpected() {
+    return expected;
+  }
+
+  public String getActual() {
+    return actual;
+  }
+
+  public boolean digestsDiffer() {
+    return !expected.equals(actual);
+  }
+
+  public String getDigestAlgorithm() {
+    return digest.getAlgorithm();
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Digests.java b/src/main/java/org/assertj/core/internal/Digests.java
new file mode 100644
index 000000000..62c1dacac
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/Digests.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.util.Hexadecimals.byteToHexString;
+import static org.assertj.core.util.Preconditions.checkNotNull;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+
+/**
+ * Reusable utils for digest processing
+ *
+ * @author Valeriy Vyrva
+ */
+public final class Digests {
+
+  private static final int BUFFER_SIZE = 1024 * 8;
+
+  private Digests() {
+  }
+
+  public static String toHex(byte[] digest) {
+    checkNotNull(digest, "The digest should not be null");
+    StringBuilder hex = new StringBuilder(digest.length * 2);
+    for (byte b : digest) {
+      hex.append(byteToHexString(b));
+    }
+    return hex.toString();
+  }
+
+  public static byte[] fromHex(String digest) {
+    checkNotNull(digest, "The digest should not be null");
+    byte[] bytes = new byte[digest.length() / 2];
+    for (int i = 0; i < bytes.length; i++) {
+      bytes[i] = Integer.valueOf(digest.substring(i * 2, (i + 1) * 2), 16).byteValue();
+    }
+    return bytes;
+  }
+
+  public static DigestDiff digestDiff(InputStream stream, MessageDigest messageDigest, byte[] expected) throws IOException {
+    checkNotNull(stream, "The stream should not be null");
+    checkNotNull(messageDigest, "The digest should not be null");
+    checkNotNull(expected, "The expected should not be null");
+    messageDigest.reset();
+    byte[] buffer = new byte[BUFFER_SIZE];
+    int len;
+    while ((len = stream.read(buffer)) > 0) {
+      messageDigest.update(buffer, 0, len);
+    }
+    byte[] actualDigest = messageDigest.digest();
+    String expectedHex = toHex(expected);
+    String actualHex = toHex(actualDigest);
+    return new DigestDiff(actualHex, expectedHex, messageDigest);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Files.java b/src/main/java/org/assertj/core/internal/Files.java
index e74bc0f5e..ab15fc3d5 100644
--- a/src/main/java/org/assertj/core/internal/Files.java
+++ b/src/main/java/org/assertj/core/internal/Files.java
@@ -23,21 +23,26 @@ import static org.assertj.core.error.ShouldBeWritable.shouldBeWritable;
 import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
 import static org.assertj.core.error.ShouldHaveContent.shouldHaveContent;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
 import static org.assertj.core.error.ShouldHaveExtension.shouldHaveExtension;
 import static org.assertj.core.error.ShouldHaveName.shouldHaveName;
 import static org.assertj.core.error.ShouldHaveNoParent.shouldHaveNoParent;
 import static org.assertj.core.error.ShouldHaveParent.shouldHaveParent;
 import static org.assertj.core.error.ShouldHaveSameContent.shouldHaveSameContent;
 import static org.assertj.core.error.ShouldNotExist.shouldNotExist;
+import static org.assertj.core.internal.Digests.digestDiff;
 import static org.assertj.core.util.Objects.areEqual;
 import static org.assertj.core.util.Preconditions.checkArgument;
 import static org.assertj.core.util.Preconditions.checkNotNull;
 
 import java.io.File;
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.UncheckedIOException;
 import java.nio.charset.Charset;
 import java.nio.charset.MalformedInputException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.List;
 
 import org.assertj.core.api.AssertionInfo;
@@ -46,7 +51,7 @@ import org.assertj.core.util.diff.Delta;
 
 /**
  * Reusable assertions for <code>{@link File}</code>s.
- * 
+ *
  * @author David DIDIER
  * @author Yvonne Wang
  * @author Alex Ruiz
@@ -71,6 +76,8 @@ public class Files {
   BinaryDiff binaryDiff = new BinaryDiff();
   @VisibleForTesting
   Failures failures = Failures.instance();
+  @VisibleForTesting
+  NioFilesWrapper nioFilesWrapper = NioFilesWrapper.instance();
 
   @VisibleForTesting
   Files() {}
@@ -280,7 +287,7 @@ public class Files {
 
   /**
    * Asserts that the given {@code File} has the given parent.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given file.
    * @param expected the expected parent {@code File}.
@@ -305,7 +312,7 @@ public class Files {
 
   /**
    * Asserts that the given {@code File} has the given extension.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given file.
    * @param expected the expected extension, it does not contains the {@code '.'}
@@ -330,7 +337,7 @@ public class Files {
 
   /**
    * Asserts that the given {@code File} has the given name.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given file.
    * @param expected the expected file name.
@@ -351,7 +358,7 @@ public class Files {
 
   /**
    * Asserts that the given {@code File} does not have a parent.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given file.
    * @throws AssertionError if the actual {@code File} is {@code null}.
@@ -362,4 +369,37 @@ public class Files {
     if (actual.getParentFile() == null) return;
     throw failures.failure(info, shouldHaveNoParent(actual));
   }
+
+  public void assertHasDigest(AssertionInfo info, File actual, MessageDigest digest, byte[] expected) {
+    checkNotNull(digest, "The message digest algorithm should not be null");
+    checkNotNull(expected, "The binary representation of digest to compare to should not be null");
+    assertExists(info, actual);
+    assertIsFile(info, actual);
+    assertCanRead(info, actual);
+    try (InputStream actualStream = nioFilesWrapper.newInputStream(actual.toPath())) {
+      DigestDiff digestDiff = digestDiff(actualStream, digest, expected);
+      if (digestDiff.digestsDiffer()) throw failures.failure(info, shouldHaveDigest(actual, digestDiff));
+    } catch (IOException e) {
+      throw new UncheckedIOException(format("Unable to calculate digest of path:<%s>", actual), e);
+    }
+  }
+
+  public void assertHasDigest(AssertionInfo info, File actual, MessageDigest digest, String expected) {
+    checkNotNull(expected, "The string representation of digest to compare to should not be null");
+    assertHasDigest(info, actual, digest, Digests.fromHex(expected));
+  }
+
+  public void assertHasDigest(AssertionInfo info, File actual, String algorithm, byte[] expected) {
+    checkNotNull(algorithm, "The message digest algorithm should not be null");
+    try {
+      assertHasDigest(info, actual, MessageDigest.getInstance(algorithm), expected);
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException(format("Unable to find digest implementation for: <%s>", algorithm), e);
+    }
+  }
+
+  public void assertHasDigest(AssertionInfo info, File actual, String algorithm, String expected) {
+    checkNotNull(expected, "The string representation of digest to compare to should not be null");
+    assertHasDigest(info, actual, algorithm, Digests.fromHex(expected));
+  }
 }
diff --git a/src/main/java/org/assertj/core/internal/InputStreams.java b/src/main/java/org/assertj/core/internal/InputStreams.java
index d17456a97..4db701016 100644
--- a/src/main/java/org/assertj/core/internal/InputStreams.java
+++ b/src/main/java/org/assertj/core/internal/InputStreams.java
@@ -13,21 +13,24 @@
 package org.assertj.core.internal;
 
 import static java.lang.String.format;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
 import static org.assertj.core.error.ShouldHaveSameContent.shouldHaveSameContent;
+import static org.assertj.core.internal.Digests.digestDiff;
 import static org.assertj.core.util.Preconditions.checkNotNull;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.List;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.diff.Delta;
 
-
 /**
  * Reusable assertions for <code>{@link InputStream}</code>s.
- * 
+ *
  * @author Matthieu Baechler
  */
 public class InputStreams {
@@ -52,7 +55,7 @@ public class InputStreams {
 
   /**
    * Asserts that the given InputStreams have same content.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the "actual" InputStream.
    * @param expected the "expected" InputStream.
@@ -102,4 +105,36 @@ public class InputStreams {
   private static void assertNotNull(AssertionInfo info, InputStream stream) {
     Objects.instance().assertNotNull(info, stream);
   }
+
+  public void assertHasDigest(AssertionInfo info, InputStream actual, MessageDigest digest, byte[] expected) {
+    checkNotNull(digest, "The message digest algorithm should not be null");
+    checkNotNull(expected, "The binary representation of digest to compare to should not be null");
+    assertNotNull(info, actual);
+    try {
+      DigestDiff diff = digestDiff(actual, digest, expected);
+      if (diff.digestsDiffer()) throw failures.failure(info, shouldHaveDigest(actual, diff));
+    } catch (IOException e) {
+      String msg = format("Unable to calculate digest of InputStream:%n  <%s>", actual);
+      throw new InputStreamsException(msg, e);
+    }
+  }
+
+  public void assertHasDigest(AssertionInfo info, InputStream actual, MessageDigest digest, String expected) {
+    checkNotNull(expected, "The string representation of digest to compare to should not be null");
+    assertHasDigest(info, actual, digest, Digests.fromHex(expected));
+  }
+
+  public void assertHasDigest(AssertionInfo info, InputStream actual, String algorithm, byte[] expected) {
+    checkNotNull(algorithm, "The message digest algorithm should not be null");
+    try {
+      assertHasDigest(info, actual, MessageDigest.getInstance(algorithm), expected);
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException(format("Unable to find digest implementation for: <%s>", algorithm), e);
+    }
+  }
+
+  public void assertHasDigest(AssertionInfo info, InputStream actual, String algorithm, String expected) {
+    checkNotNull(expected, "The string representation of digest to compare to should not be null");
+    assertHasDigest(info, actual, algorithm, Digests.fromHex(expected));
+  }
 }
diff --git a/src/main/java/org/assertj/core/internal/NioFilesWrapper.java b/src/main/java/org/assertj/core/internal/NioFilesWrapper.java
index 838a31616..ed8f1318b 100644
--- a/src/main/java/org/assertj/core/internal/NioFilesWrapper.java
+++ b/src/main/java/org/assertj/core/internal/NioFilesWrapper.java
@@ -12,13 +12,15 @@
  */
 package org.assertj.core.internal;
 
+import java.io.IOException;
+import java.io.InputStream;
 import java.nio.file.Files;
 import java.nio.file.LinkOption;
+import java.nio.file.OpenOption;
 import java.nio.file.Path;
 
 import org.assertj.core.util.VisibleForTesting;
 
-
 /**
  * Wrapper for <code>{@link java.nio.file.Files}</code> to test {@link Paths}.
  */
@@ -40,34 +42,36 @@ public class NioFilesWrapper {
   public boolean isRegularFile(Path path) {
     return Files.isRegularFile(path);
   }
-  
+
   public boolean isSymbolicLink(Path path) {
-	return Files.isSymbolicLink(path);
+    return Files.isSymbolicLink(path);
   }
-  
+
   public boolean isDirectory(Path path) {
-	return Files.isDirectory(path);
+    return Files.isDirectory(path);
   }
-  
+
   public boolean exists(Path path, LinkOption... options) {
-	return Files.exists(path, options);
+    return Files.exists(path, options);
   }
 
   public boolean notExists(Path path, LinkOption... options) {
-	return Files.notExists(path, options);
+    return Files.notExists(path, options);
   }
-  
+
   public boolean isReadable(Path path) {
-	return Files.isReadable(path);
+    return Files.isReadable(path);
   }
-  
+
   public boolean isWritable(Path path) {
-	return Files.isWritable(path);
+    return Files.isWritable(path);
   }
-  
+
   public boolean isExecutable(Path path) {
-	return Files.isExecutable(path);
+    return Files.isExecutable(path);
   }
-  
-}
 
+  public InputStream newInputStream(Path path, OpenOption... options) throws IOException {
+    return Files.newInputStream(path, options);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Paths.java b/src/main/java/org/assertj/core/internal/Paths.java
index 9b196a50a..ad9a4df31 100644
--- a/src/main/java/org/assertj/core/internal/Paths.java
+++ b/src/main/java/org/assertj/core/internal/Paths.java
@@ -28,6 +28,7 @@ import static org.assertj.core.error.ShouldExist.shouldExist;
 import static org.assertj.core.error.ShouldExist.shouldExistNoFollowLinks;
 import static org.assertj.core.error.ShouldHaveBinaryContent.shouldHaveBinaryContent;
 import static org.assertj.core.error.ShouldHaveContent.shouldHaveContent;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
 import static org.assertj.core.error.ShouldHaveName.shouldHaveName;
 import static org.assertj.core.error.ShouldHaveNoParent.shouldHaveNoParent;
 import static org.assertj.core.error.ShouldHaveParent.shouldHaveParent;
@@ -38,10 +39,13 @@ import static org.assertj.core.util.Preconditions.checkArgument;
 import static org.assertj.core.util.Preconditions.checkNotNull;
 
 import java.io.IOException;
+import java.io.InputStream;
 import java.io.UncheckedIOException;
 import java.nio.charset.Charset;
 import java.nio.file.LinkOption;
 import java.nio.file.Path;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
 import java.util.List;
 
 import org.assertj.core.api.AssertionInfo;
@@ -71,193 +75,193 @@ public class Paths {
   private NioFilesWrapper nioFilesWrapper;
 
   public static Paths instance() {
-	return INSTANCE;
+    return INSTANCE;
   }
 
   @VisibleForTesting
   Paths(NioFilesWrapper nioFilesWrapper) {
-	this.nioFilesWrapper = nioFilesWrapper;
+    this.nioFilesWrapper = nioFilesWrapper;
   }
 
   private Paths() {
-	this(NioFilesWrapper.instance());
+    this(NioFilesWrapper.instance());
   }
 
   public void assertIsReadable(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	assertExists(info, actual);
-	if (!nioFilesWrapper.isReadable(actual)) throw failures.failure(info, shouldBeReadable(actual));
+    assertNotNull(info, actual);
+    assertExists(info, actual);
+    if (!nioFilesWrapper.isReadable(actual)) throw failures.failure(info, shouldBeReadable(actual));
   }
 
   public void assertIsWritable(AssertionInfo info, Path actual) {
-	assertNotNull(info, actual);
-	assertExists(info, actual);
-	if (!nioFilesWrapper.isWritable(actual)) throw failures.failure(info, shouldBeWritable(actual));
+    assertNotNull(info, actual);
+    assertExists(info, actual);
+    if (!nioFilesWrapper.isWritable(actual)) throw failures.failure(info, shouldBeWritable(actual));
   }
 
   public void assertIsExecutable(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	assertExists(info, actual);
-	if (!nioFilesWrapper.isExecutable(actual)) throw failures.failure(info, shouldBeExecutable(actual));
+    assertNotNull(info, actual);
+    assertExists(info, actual);
+    if (!nioFilesWrapper.isExecutable(actual)) throw failures.failure(info, shouldBeExecutable(actual));
   }
 
   public void assertExists(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	if (!nioFilesWrapper.exists(actual)) throw failures.failure(info, shouldExist(actual));
+    assertNotNull(info, actual);
+    if (!nioFilesWrapper.exists(actual)) throw failures.failure(info, shouldExist(actual));
   }
 
   public void assertExistsNoFollowLinks(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	if (!nioFilesWrapper.exists(actual, LinkOption.NOFOLLOW_LINKS))
-	  throw failures.failure(info, shouldExistNoFollowLinks(actual));
+    assertNotNull(info, actual);
+    if (!nioFilesWrapper.exists(actual, LinkOption.NOFOLLOW_LINKS))
+      throw failures.failure(info, shouldExistNoFollowLinks(actual));
   }
 
   public void assertDoesNotExist(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	if (!nioFilesWrapper.notExists(actual, LinkOption.NOFOLLOW_LINKS))
-	  throw failures.failure(info, shouldNotExist(actual));
+    assertNotNull(info, actual);
+    if (!nioFilesWrapper.notExists(actual, LinkOption.NOFOLLOW_LINKS))
+      throw failures.failure(info, shouldNotExist(actual));
   }
 
   public void assertIsRegularFile(final AssertionInfo info, final Path actual) {
-	assertExists(info, actual);
-	if (!nioFilesWrapper.isRegularFile(actual)) throw failures.failure(info, shouldBeRegularFile(actual));
+    assertExists(info, actual);
+    if (!nioFilesWrapper.isRegularFile(actual)) throw failures.failure(info, shouldBeRegularFile(actual));
   }
 
   public void assertIsDirectory(final AssertionInfo info, final Path actual) {
-	assertExists(info, actual);
-	if (!nioFilesWrapper.isDirectory(actual)) throw failures.failure(info, shouldBeDirectory(actual));
+    assertExists(info, actual);
+    if (!nioFilesWrapper.isDirectory(actual)) throw failures.failure(info, shouldBeDirectory(actual));
   }
 
   public void assertIsSymbolicLink(final AssertionInfo info, final Path actual) {
-	assertExistsNoFollowLinks(info, actual);
-	if (!nioFilesWrapper.isSymbolicLink(actual)) throw failures.failure(info, shouldBeSymbolicLink(actual));
+    assertExistsNoFollowLinks(info, actual);
+    if (!nioFilesWrapper.isSymbolicLink(actual)) throw failures.failure(info, shouldBeSymbolicLink(actual));
   }
 
   public void assertIsAbsolute(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	if (!actual.isAbsolute()) throw failures.failure(info, shouldBeAbsolutePath(actual));
+    assertNotNull(info, actual);
+    if (!actual.isAbsolute()) throw failures.failure(info, shouldBeAbsolutePath(actual));
   }
 
   public void assertIsRelative(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	if (actual.isAbsolute()) throw failures.failure(info, shouldBeRelativePath(actual));
+    assertNotNull(info, actual);
+    if (actual.isAbsolute()) throw failures.failure(info, shouldBeRelativePath(actual));
   }
 
   public void assertIsNormalized(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	if (!actual.normalize().equals(actual)) throw failures.failure(info, shouldBeNormalized(actual));
+    assertNotNull(info, actual);
+    if (!actual.normalize().equals(actual)) throw failures.failure(info, shouldBeNormalized(actual));
   }
 
   public void assertIsCanonical(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	try {
-	  if (!actual.equals(actual.toRealPath())) throw failures.failure(info, shouldBeCanonicalPath(actual));
-	} catch (IOException e) {
-	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
-	}
+    assertNotNull(info, actual);
+    try {
+      if (!actual.equals(actual.toRealPath())) throw failures.failure(info, shouldBeCanonicalPath(actual));
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+    }
   }
 
   public void assertHasParent(final AssertionInfo info, final Path actual, final Path expected) {
-	assertNotNull(info, actual);
-	checkExpectedParentPathIsNotNull(expected);
+    assertNotNull(info, actual);
+    checkExpectedParentPathIsNotNull(expected);
 
-	final Path canonicalActual;
-	try {
-	  canonicalActual = actual.toRealPath();
-	} catch (IOException e) {
-	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
-	}
+    final Path canonicalActual;
+    try {
+      canonicalActual = actual.toRealPath();
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+    }
 
-	final Path canonicalExpected;
-	try {
-	  canonicalExpected = expected.toRealPath();
-	} catch (IOException e) {
-	  throw new PathsException(FAILED_TO_RESOLVE_ARGUMENT_REAL_PATH, e);
-	}
+    final Path canonicalExpected;
+    try {
+      canonicalExpected = expected.toRealPath();
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ARGUMENT_REAL_PATH, e);
+    }
 
-	final Path actualParent = canonicalActual.getParent();
-	if (actualParent == null) throw failures.failure(info, shouldHaveParent(actual, expected));
-	if (!actualParent.equals(canonicalExpected))
-	  throw failures.failure(info, shouldHaveParent(actual, actualParent, expected));
+    final Path actualParent = canonicalActual.getParent();
+    if (actualParent == null) throw failures.failure(info, shouldHaveParent(actual, expected));
+    if (!actualParent.equals(canonicalExpected))
+      throw failures.failure(info, shouldHaveParent(actual, actualParent, expected));
   }
 
   public void assertHasParentRaw(final AssertionInfo info, final Path actual, final Path expected) {
-	assertNotNull(info, actual);
-	checkExpectedParentPathIsNotNull(expected);
+    assertNotNull(info, actual);
+    checkExpectedParentPathIsNotNull(expected);
 
-	final Path actualParent = actual.getParent();
-	if (actualParent == null) throw failures.failure(info, shouldHaveParent(actual, expected));
-	if (!actualParent.equals(expected))
-	  throw failures.failure(info, shouldHaveParent(actual, actualParent, expected));
+    final Path actualParent = actual.getParent();
+    if (actualParent == null) throw failures.failure(info, shouldHaveParent(actual, expected));
+    if (!actualParent.equals(expected))
+      throw failures.failure(info, shouldHaveParent(actual, actualParent, expected));
   }
 
   public void assertHasNoParent(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	try {
-	  final Path canonicalActual = actual.toRealPath();
-	  if (canonicalActual.getParent() != null) throw failures.failure(info, shouldHaveNoParent(actual));
-	} catch (IOException e) {
-	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
-	}
+    assertNotNull(info, actual);
+    try {
+      final Path canonicalActual = actual.toRealPath();
+      if (canonicalActual.getParent() != null) throw failures.failure(info, shouldHaveNoParent(actual));
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+    }
   }
 
   public void assertHasNoParentRaw(final AssertionInfo info, final Path actual) {
-	assertNotNull(info, actual);
-	if (actual.getParent() != null) throw failures.failure(info, shouldHaveNoParent(actual));
+    assertNotNull(info, actual);
+    if (actual.getParent() != null) throw failures.failure(info, shouldHaveNoParent(actual));
   }
 
   public void assertStartsWith(final AssertionInfo info, final Path actual, final Path start) {
-	assertNotNull(info, actual);
-	assertExpectedStartPathIsNotNull(start);
+    assertNotNull(info, actual);
+    assertExpectedStartPathIsNotNull(start);
 
-	final Path canonicalActual;
-	try {
-	  canonicalActual = actual.toRealPath();
-	} catch (IOException e) {
-	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
-	}
+    final Path canonicalActual;
+    try {
+      canonicalActual = actual.toRealPath();
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+    }
 
-	final Path canonicalOther;
-	try {
-	  canonicalOther = start.toRealPath();
-	} catch (IOException e) {
-	  throw new PathsException(FAILED_TO_RESOLVE_ARGUMENT_REAL_PATH, e);
-	}
+    final Path canonicalOther;
+    try {
+      canonicalOther = start.toRealPath();
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ARGUMENT_REAL_PATH, e);
+    }
 
-	if (!canonicalActual.startsWith(canonicalOther)) throw failures.failure(info, shouldStartWith(actual, start));
+    if (!canonicalActual.startsWith(canonicalOther)) throw failures.failure(info, shouldStartWith(actual, start));
   }
 
   public void assertStartsWithRaw(final AssertionInfo info, final Path actual, final Path other) {
-	assertNotNull(info, actual);
-	assertExpectedStartPathIsNotNull(other);
-	if (!actual.startsWith(other)) throw failures.failure(info, shouldStartWith(actual, other));
+    assertNotNull(info, actual);
+    assertExpectedStartPathIsNotNull(other);
+    if (!actual.startsWith(other)) throw failures.failure(info, shouldStartWith(actual, other));
   }
 
   public void assertEndsWith(final AssertionInfo info, final Path actual, final Path end) {
-	assertNotNull(info, actual);
-	assertExpectedEndPathIsNotNull(end);
-	try {
-	  final Path canonicalActual = actual.toRealPath();
-	  if (!canonicalActual.endsWith(end.normalize())) throw failures.failure(info, shouldEndWith(actual, end));
-	} catch (IOException e) {
-	  throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
-	}
+    assertNotNull(info, actual);
+    assertExpectedEndPathIsNotNull(end);
+    try {
+      final Path canonicalActual = actual.toRealPath();
+      if (!canonicalActual.endsWith(end.normalize())) throw failures.failure(info, shouldEndWith(actual, end));
+    } catch (IOException e) {
+      throw new PathsException(FAILED_TO_RESOLVE_ACTUAL_REAL_PATH, e);
+    }
   }
 
   public void assertEndsWithRaw(final AssertionInfo info, final Path actual, final Path end) {
-	assertNotNull(info, actual);
-	assertExpectedEndPathIsNotNull(end);
-	if (!actual.endsWith(end)) throw failures.failure(info, shouldEndWith(actual, end));
+    assertNotNull(info, actual);
+    assertExpectedEndPathIsNotNull(end);
+    if (!actual.endsWith(end)) throw failures.failure(info, shouldEndWith(actual, end));
   }
 
   public void assertHasFileName(final AssertionInfo info, Path actual, String fileName) {
-	assertNotNull(info, actual);
-	checkNotNull(fileName, "expected fileName should not be null");
-	if (!actual.getFileName().endsWith(fileName)) throw failures.failure(info, shouldHaveName(actual, fileName));
+    assertNotNull(info, actual);
+    checkNotNull(fileName, "expected fileName should not be null");
+    if (!actual.getFileName().endsWith(fileName)) throw failures.failure(info, shouldHaveName(actual, fileName));
   }
 
   private static void assertNotNull(final AssertionInfo info, final Path actual) {
-	Objects.instance().assertNotNull(info, actual);
+    Objects.instance().assertNotNull(info, actual);
   }
 
   private static void checkExpectedParentPathIsNotNull(final Path expected) {
@@ -274,39 +278,72 @@ public class Paths {
 
   public void assertHasContent(final AssertionInfo info, Path actual, String expected, Charset charset) {
     checkNotNull(expected, "The text to compare to should not be null");
-	assertIsReadable(info, actual);
-	try {
-	  List<Delta<String>> diffs = diff.diff(actual, expected, charset);
-	  if (diffs.isEmpty()) return;
-	  throw failures.failure(info, shouldHaveContent(actual, charset, diffs));
-	} catch (IOException e) {
-	  throw new UncheckedIOException(format("Unable to verify text contents of path:<%s>", actual), e);
-	}
+    assertIsReadable(info, actual);
+    try {
+      List<Delta<String>> diffs = diff.diff(actual, expected, charset);
+      if (diffs.isEmpty()) return;
+      throw failures.failure(info, shouldHaveContent(actual, charset, diffs));
+    } catch (IOException e) {
+      throw new UncheckedIOException(format("Unable to verify text contents of path:<%s>", actual), e);
+    }
   }
 
   public void assertHasBinaryContent(AssertionInfo info, Path actual, byte[] expected) {
     checkNotNull(expected, "The binary content to compare to should not be null");
-	assertIsReadable(info, actual);
-	try {
-	  BinaryDiffResult diffResult = binaryDiff.diff(actual, expected);
-	  if (diffResult.hasNoDiff()) return;
-	  throw failures.failure(info, shouldHaveBinaryContent(actual, diffResult));
-	} catch (IOException e) {
-	  throw new UncheckedIOException(format("Unable to verify binary contents of path:<%s>", actual), e);
-	}
-  }
-
-  public void assertHasSameContentAs(AssertionInfo info, Path actual, Charset actualCharset, Path expected, Charset expectedCharset) {
+    assertIsReadable(info, actual);
+    try {
+      BinaryDiffResult diffResult = binaryDiff.diff(actual, expected);
+      if (diffResult.hasNoDiff()) return;
+      throw failures.failure(info, shouldHaveBinaryContent(actual, diffResult));
+    } catch (IOException e) {
+      throw new UncheckedIOException(format("Unable to verify binary contents of path:<%s>", actual), e);
+    }
+  }
+
+  public void assertHasSameContentAs(AssertionInfo info, Path actual, Charset actualCharset, Path expected,
+                                     Charset expectedCharset) {
     checkNotNull(expected, "The given Path to compare actual content to should not be null");
-    checkArgument(nioFilesWrapper.isReadable(expected), "The given Path <%s> to compare actual content to should be readable", expected);
-	assertIsReadable(info, actual);
-	try {
-	  List<Delta<String>> diffs = diff.diff(actual, actualCharset, expected, expectedCharset);
-	  if (diffs.isEmpty()) return;
-	  throw failures.failure(info, shouldHaveSameContent(actual, expected, diffs));
-	} catch (IOException e) {
-	  throw new UncheckedIOException(format("Unable to compare contents of paths:<%s> and:<%s>", actual, expected), e);
-	}
+    checkArgument(nioFilesWrapper.isReadable(expected), "The given Path <%s> to compare actual content to should be readable",
+                  expected);
+    assertIsReadable(info, actual);
+    try {
+      List<Delta<String>> diffs = diff.diff(actual, actualCharset, expected, expectedCharset);
+      if (diffs.isEmpty()) return;
+      throw failures.failure(info, shouldHaveSameContent(actual, expected, diffs));
+    } catch (IOException e) {
+      throw new UncheckedIOException(format("Unable to compare contents of paths:<%s> and:<%s>", actual, expected), e);
+    }
+  }
+
+  public void assertHasDigest(AssertionInfo info, Path actual, MessageDigest digest, byte[] expected) {
+    checkNotNull(digest, "The message digest algorithm should not be null");
+    checkNotNull(expected, "The binary representation of digest to compare to should not be null");
+    assertIsRegularFile(info, actual);
+    assertIsReadable(info, actual);
+    try (InputStream actualStream = nioFilesWrapper.newInputStream(actual)) {
+      DigestDiff diff = Digests.digestDiff(actualStream, digest, expected);
+      if (diff.digestsDiffer()) throw failures.failure(info, shouldHaveDigest(actual, diff));
+    } catch (IOException e) {
+      throw new UncheckedIOException(format("Unable to calculate digest of path:<%s>", actual), e);
+    }
+  }
+
+  public void assertHasDigest(AssertionInfo info, Path actual, MessageDigest digest, String expected) {
+    checkNotNull(expected, "The string representation of digest to compare to should not be null");
+    assertHasDigest(info, actual, digest, Digests.fromHex(expected));
+  }
+
+  public void assertHasDigest(AssertionInfo info, Path actual, String algorithm, byte[] expected) {
+    checkNotNull(algorithm, "The message digest algorithm should not be null");
+    try {
+      assertHasDigest(info, actual, MessageDigest.getInstance(algorithm), expected);
+    } catch (NoSuchAlgorithmException e) {
+      throw new IllegalStateException(format("Unable to find digest implementation for: <%s>", algorithm), e);
+    }
+  }
+
+  public void assertHasDigest(AssertionInfo info, Path actual, String algorithm, String expected) {
+    checkNotNull(expected, "The string representation of digest to compare to should not be null");
+    assertHasDigest(info, actual, algorithm, Digests.fromHex(expected));
   }
-
 }
diff --git a/src/main/java/org/assertj/core/util/Hexadecimals.java b/src/main/java/org/assertj/core/util/Hexadecimals.java
index c5722970d..36caa7b22 100644
--- a/src/main/java/org/assertj/core/util/Hexadecimals.java
+++ b/src/main/java/org/assertj/core/util/Hexadecimals.java
@@ -19,9 +19,9 @@ public class Hexadecimals {
 
   protected static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
 
-  public static String byteToHexString(Byte b) {
+  public static String byteToHexString(byte b) {
     int v = b & 0xFF;
-    return new String(new char[]{HEX_ARRAY[v >>> 4], HEX_ARRAY[v & 0x0F]});
+    return new String(new char[] { HEX_ARRAY[v >>> 4], HEX_ARRAY[v & 0x0F] });
   }
 
   private Hexadecimals() {
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_AlgorithmBytes_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_AlgorithmBytes_Test.java
new file mode 100644
index 000000000..0f072ba3b
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_AlgorithmBytes_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.file;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.FileAssert;
+import org.assertj.core.api.FileAssertBaseTest;
+
+/**
+ * Tests for <code>{@link FileAssert#hasDigest(String, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class FileAssert_hasDigest_AlgorithmBytes_Test extends FileAssertBaseTest {
+
+  private final String algorithm = "MD5";
+  private final byte[] expected = new byte[0];
+
+  @Override
+  protected FileAssert invoke_api_method() {
+    return assertions.hasDigest(algorithm, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(files).assertHasDigest(getInfo(assertions), getActual(assertions), algorithm, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_AlgorithmString_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_AlgorithmString_Test.java
new file mode 100644
index 000000000..6a180ea5c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_AlgorithmString_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.file;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.FileAssert;
+import org.assertj.core.api.FileAssertBaseTest;
+
+/**
+ * Tests for <code>{@link FileAssert#hasDigest(String, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class FileAssert_hasDigest_AlgorithmString_Test extends FileAssertBaseTest {
+
+  private final String algorithm = "MD5";
+  private final String expected = "";
+
+  @Override
+  protected FileAssert invoke_api_method() {
+    return assertions.hasDigest(algorithm, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(files).assertHasDigest(getInfo(assertions), getActual(assertions), algorithm, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_DigestBytes_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_DigestBytes_Test.java
new file mode 100644
index 000000000..f4c7cde76
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_DigestBytes_Test.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.file;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.security.MessageDigest;
+
+import org.assertj.core.api.FileAssert;
+import org.assertj.core.api.FileAssertBaseTest;
+
+/**
+ * Tests for <code>{@link FileAssert#hasDigest(MessageDigest, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class FileAssert_hasDigest_DigestBytes_Test extends FileAssertBaseTest {
+
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final byte[] expected = new byte[0];
+
+  @Override
+  protected FileAssert invoke_api_method() {
+    return assertions.hasDigest(digest, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(files).assertHasDigest(getInfo(assertions), getActual(assertions), digest, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_DigestString_Test.java b/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_DigestString_Test.java
new file mode 100644
index 000000000..8415b297b
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/file/FileAssert_hasDigest_DigestString_Test.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.file;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.security.MessageDigest;
+
+import org.assertj.core.api.FileAssert;
+import org.assertj.core.api.FileAssertBaseTest;
+
+/**
+ * Tests for <code>{@link FileAssert#hasDigest(MessageDigest, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class FileAssert_hasDigest_DigestString_Test extends FileAssertBaseTest {
+
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final String expected = "";
+
+  @Override
+  protected FileAssert invoke_api_method() {
+    return assertions.hasDigest(digest, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(files).assertHasDigest(getInfo(assertions), getActual(assertions), digest, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_AlgorithmBytes_Test.java b/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_AlgorithmBytes_Test.java
new file mode 100644
index 000000000..d97ce9640
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_AlgorithmBytes_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.inputstream;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.InputStreamAssert;
+import org.assertj.core.api.InputStreamAssertBaseTest;
+
+/**
+ * Tests for <code>{@link InputStreamAssert#hasDigest(String, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class InputStreamAssert_hasDigest_AlgorithmBytes_Test extends InputStreamAssertBaseTest {
+
+  private final String algorithm = "MD5";
+  private final byte[] expected = new byte[0];
+
+  @Override
+  protected InputStreamAssert invoke_api_method() {
+    return assertions.hasDigest(algorithm, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(inputStreams).assertHasDigest(getInfo(assertions), getActual(assertions), algorithm, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_AlgorithmString_Test.java b/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_AlgorithmString_Test.java
new file mode 100644
index 000000000..27d8e71f0
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_AlgorithmString_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.inputstream;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.InputStreamAssert;
+import org.assertj.core.api.InputStreamAssertBaseTest;
+
+/**
+ * Tests for <code>{@link InputStreamAssert#hasDigest(String, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class InputStreamAssert_hasDigest_AlgorithmString_Test extends InputStreamAssertBaseTest {
+
+  private final String algorithm = "MD5";
+  private final String expected = "";
+
+  @Override
+  protected InputStreamAssert invoke_api_method() {
+    return assertions.hasDigest(algorithm, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(inputStreams).assertHasDigest(getInfo(assertions), getActual(assertions), algorithm, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_DigestBytes_Test.java b/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_DigestBytes_Test.java
new file mode 100644
index 000000000..53f4f90d9
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_DigestBytes_Test.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.inputstream;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.security.MessageDigest;
+
+import org.assertj.core.api.InputStreamAssert;
+import org.assertj.core.api.InputStreamAssertBaseTest;
+
+/**
+ * Tests for <code>{@link InputStreamAssert#hasDigest(MessageDigest, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class InputStreamAssert_hasDigest_DigestBytes_Test extends InputStreamAssertBaseTest {
+
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final byte[] expected = new byte[0];
+
+  @Override
+  protected InputStreamAssert invoke_api_method() {
+    return assertions.hasDigest(digest, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(inputStreams).assertHasDigest(getInfo(assertions), getActual(assertions), digest, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_DigestString_Test.java b/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_DigestString_Test.java
new file mode 100644
index 000000000..8f341fabf
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/inputstream/InputStreamAssert_hasDigest_DigestString_Test.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.inputstream;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.security.MessageDigest;
+
+import org.assertj.core.api.InputStreamAssert;
+import org.assertj.core.api.InputStreamAssertBaseTest;
+
+/**
+ * Tests for <code>{@link InputStreamAssert#hasDigest(MessageDigest, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class InputStreamAssert_hasDigest_DigestString_Test extends InputStreamAssertBaseTest {
+
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final String expected = "";
+
+  @Override
+  protected InputStreamAssert invoke_api_method() {
+    return assertions.hasDigest(digest, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(inputStreams).assertHasDigest(getInfo(assertions), getActual(assertions), digest, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_AlgorithmBytes_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_AlgorithmBytes_Test.java
new file mode 100644
index 000000000..dbf683623
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_AlgorithmBytes_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+/**
+ * Tests for <code>{@link PathAssert#hasDigest(String, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class PathAssert_hasDigest_AlgorithmBytes_Test extends PathAssertBaseTest {
+
+  private final String algorithm = "MD5";
+  private final byte[] expected = new byte[0];
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.hasDigest(algorithm, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertHasDigest(getInfo(assertions), getActual(assertions), algorithm, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_AlgorithmString_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_AlgorithmString_Test.java
new file mode 100644
index 000000000..e5846caa6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_AlgorithmString_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+/**
+ * Tests for <code>{@link PathAssert#hasDigest(String, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class PathAssert_hasDigest_AlgorithmString_Test extends PathAssertBaseTest {
+
+  private final String algorithm = "MD5";
+  private final String expected = "";
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.hasDigest(algorithm, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertHasDigest(getInfo(assertions), getActual(assertions), algorithm, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_DigestBytes_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_DigestBytes_Test.java
new file mode 100644
index 000000000..05c8cf1ff
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_DigestBytes_Test.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.security.MessageDigest;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+/**
+ * Tests for <code>{@link PathAssert#hasDigest(MessageDigest, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class PathAssert_hasDigest_DigestBytes_Test extends PathAssertBaseTest {
+
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final byte[] expected = new byte[0];
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.hasDigest(digest, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertHasDigest(getInfo(assertions), getActual(assertions), digest, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_DigestString_Test.java b/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_DigestString_Test.java
new file mode 100644
index 000000000..9b55e27d5
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/path/PathAssert_hasDigest_DigestString_Test.java
@@ -0,0 +1,42 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.api.path;
+
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.security.MessageDigest;
+
+import org.assertj.core.api.PathAssert;
+import org.assertj.core.api.PathAssertBaseTest;
+
+/**
+ * Tests for <code>{@link PathAssert#hasDigest(MessageDigest, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class PathAssert_hasDigest_DigestString_Test extends PathAssertBaseTest {
+
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final String expected = "";
+
+  @Override
+  protected PathAssert invoke_api_method() {
+    return assertions.hasDigest(digest, expected);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(paths).assertHasDigest(getInfo(assertions), getActual(assertions), digest, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveDigest_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveDigest_create_Test.java
new file mode 100644
index 000000000..caa6cf984
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldHaveDigest_create_Test.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.mockito.Mockito.mock;
+
+import java.io.File;
+import java.io.InputStream;
+import java.nio.file.Path;
+import java.security.MessageDigest;
+
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.TestDescription;
+import org.junit.Before;
+import org.junit.Test;
+
+public class ShouldHaveDigest_create_Test {
+
+  private static final TestDescription TEST_DESCRIPTION = new TestDescription("TEST");
+
+  private DigestDiff diff;
+
+  @Before
+  public void setup() throws Exception {
+    diff = new DigestDiff("actualHex", "actualHex", MessageDigest.getInstance("MD5"));
+  }
+
+  @Test
+  public void should_create_error_message_with_File() throws Exception {
+    // GIVEN
+    File actual = new FakeFile("actual.png");
+    // WHEN
+    String message = shouldHaveDigest(actual, diff).create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+    // THEN
+    assertThat(message).isEqualTo(format("[TEST] %n" +
+                                         "Expecting File " + actual + " MD5 digest to be:%n" +
+                                         "  <\"" + diff.getExpected() + "\">%n" +
+                                         "but was:%n" +
+                                         "  <\"" + diff.getActual() + "\">"));
+  }
+
+  @Test
+  public void should_create_error_message_with_Path() throws Exception {
+    // GIVEN
+    Path actual = mock(Path.class);
+    // WHEN
+    String message = shouldHaveDigest(actual, diff).create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+    // THEN
+    assertThat(message).isEqualTo(format("[TEST] %n" +
+                                         "Expecting Path " + actual + " MD5 digest to be:%n" +
+                                         "  <\"" + diff.getExpected() + "\">%n" +
+                                         "but was:%n" +
+                                         "  <\"" + diff.getActual() + "\">"));
+  }
+
+  @Test
+  public void should_create_error_message_with_InputStream() throws Exception {
+    // GIVEN
+    InputStream actual = mock(InputStream.class);
+    // WHEN
+    String message = shouldHaveDigest(actual, diff).create(TEST_DESCRIPTION, STANDARD_REPRESENTATION);
+    // THEN
+    assertThat(message).isEqualTo(format("[TEST] %n" +
+                                         "Expecting InputStream " + actual + " MD5 digest to be:%n" +
+                                         "  <\"" + diff.getExpected() + "\">%n" +
+                                         "but was:%n" +
+                                         "  <\"" + diff.getActual() + "\">"));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/DigestsBaseTest.java b/src/test/java/org/assertj/core/internal/DigestsBaseTest.java
new file mode 100644
index 000000000..7a3c85829
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/DigestsBaseTest.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import org.junit.Rule;
+
+import org.assertj.core.test.ExpectedException;
+
+import static org.assertj.core.test.ExpectedException.none;
+
+/**
+ * Base class for {@link Digests} unit tests.
+ *
+ * @author Valeriy Vyrva
+ */
+public abstract class DigestsBaseTest {
+  static final byte[] DIGEST_TEST_1_BYTES = {-38, 57, -93, -18, 94, 107, 75, 13, 50, 85, -65, -17, -107, 96, 24, -112, -81, -40, 7, 9};
+  static final String DIGEST_TEST_1_STR = "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709";
+  static final byte[] EXPECTED_MD5_DIGEST = {58, -63, -81, -94, -88, -101, 126, 79, 24, 102, 80, 40, 119, -65, 29, -59};
+  static final String EXPECTED_MD5_DIGEST_STR = "3AC1AFA2A89B7E4F1866502877BF1DC5";
+
+  @Rule
+  public ExpectedException thrown = none();
+}
diff --git a/src/test/java/org/assertj/core/internal/Digests_digestDiff_Test.java b/src/test/java/org/assertj/core/internal/Digests_digestDiff_Test.java
new file mode 100644
index 000000000..f654917e9
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/Digests_digestDiff_Test.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.internal.Digests.digestDiff;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Digests#digestDiff(InputStream, MessageDigest, byte[])}</code>.
+ *
+ * @author Valeriy Vyrva
+ */
+public class Digests_digestDiff_Test extends DigestsBaseTest {
+
+  private InputStream stream;
+  private MessageDigest digest;
+  private byte[] expected = new byte[] { 0, 1 };
+
+  @Before
+  public void init() {
+    stream = mock(InputStream.class);
+    digest = mock(MessageDigest.class);
+  }
+
+  @Test
+  public void should_fail_if_stream_is_null() throws IOException {
+    thrown.expectNullPointerException("The stream should not be null");
+    digestDiff(null, null, null);
+  }
+
+  @Test
+  public void should_fail_if_digest_is_null() throws IOException {
+    thrown.expectNullPointerException("The digest should not be null");
+    digestDiff(stream, null, null);
+  }
+
+  @Test
+  public void should_fail_if_expected_is_null() throws IOException {
+    thrown.expectNullPointerException("The expected should not be null");
+    digestDiff(stream, digest, null);
+  }
+
+  // todo should_error_if_IO
+
+  @Test
+  public void should_pass_if_stream_is_readable() throws IOException {
+    // GIVEN
+    given(digest.digest()).willReturn(expected);
+    // THEN
+    digestDiff(stream, digest, expected);
+  }
+
+  @Test
+  public void should_pass_if_digest_is_MD5() throws IOException, NoSuchAlgorithmException {
+    // GIVEN
+    InputStream inputStream = getClass().getResourceAsStream("/red.png");
+    // WHEN
+    DigestDiff diff = digestDiff(inputStream, MessageDigest.getInstance("MD5"), EXPECTED_MD5_DIGEST);
+    // THEN
+    assertThat(diff.digestsDiffer()).isFalse();
+  }
+
+  @Test
+  public void should_pass_if_digest_is_MD5_and_updated() throws IOException, NoSuchAlgorithmException {
+    // GIVEN
+    InputStream inputStream = getClass().getResourceAsStream("/red.png");
+    MessageDigest digest = MessageDigest.getInstance("MD5");
+    digest.update(expected);
+    // WHEN
+    DigestDiff diff = digestDiff(inputStream, digest, EXPECTED_MD5_DIGEST);
+    // THEN
+    assertThat(diff.digestsDiffer()).isFalse();
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/Digests_fromHex_Test.java b/src/test/java/org/assertj/core/internal/Digests_fromHex_Test.java
new file mode 100644
index 000000000..25387288e
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/Digests_fromHex_Test.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+
+import org.assertj.core.presentation.Representation;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Digests#fromHex(String)}</code>.
+ *
+ * @author Valeriy Vyrva
+ */
+public class Digests_fromHex_Test extends DigestsBaseTest {
+
+  @Test
+  public void should_fail_if_digest_is_null() {
+    thrown.expectNullPointerException("The digest should not be null");
+    Digests.fromHex(null);
+  }
+
+  @Test
+  public void should_pass_if_digest_is_empty() {
+    assertThat(Digests.fromHex("")).isEmpty();
+  }
+
+  @Test
+  public void should_pass_if_digest_converted_correctly() {
+    assertThat(Digests.fromHex(DIGEST_TEST_1_STR)).isEqualTo(DIGEST_TEST_1_BYTES);
+  }
+
+  @Test
+  public void should_fail_if_digest_converted_incorrectly() {
+    // GIVEN
+    Representation representation = STANDARD_REPRESENTATION;
+    // THEN
+    thrown.expectAssertionError(shouldBeEqual(EXPECTED_MD5_DIGEST, DIGEST_TEST_1_BYTES, representation));
+    // WHEN
+    assertThat(Digests.fromHex(EXPECTED_MD5_DIGEST_STR)).isEqualTo(DIGEST_TEST_1_BYTES);
+  }
+
+  @Test
+  public void should_pass_if_digest_length_is_not_even() {
+    assertThat(Digests.fromHex("A")).isEmpty();
+    assertThat(Digests.fromHex("AA")).containsExactly(170);
+    assertThat(Digests.fromHex("AAA")).containsExactly(170);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/Digests_toHex_Test.java b/src/test/java/org/assertj/core/internal/Digests_toHex_Test.java
new file mode 100644
index 000000000..7fc49d845
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/Digests_toHex_Test.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Digests#toHex(byte[])}</code>.
+ *
+ * @author Valeriy Vyrva
+ */
+public class Digests_toHex_Test extends DigestsBaseTest {
+
+  @Test
+  public void should_fail_if_digest_is_null() {
+    thrown.expectNullPointerException("The digest should not be null");
+    Digests.toHex(null);
+  }
+
+  @Test
+  public void should_pass_if_digest_is_empty() {
+    assertThat(Digests.toHex(new byte[0])).isEqualTo("");
+  }
+
+  @Test
+  public void should_pass_if_digest_is_correctly_converted() {
+    assertThat(Digests.toHex(DIGEST_TEST_1_BYTES)).isEqualTo(DIGEST_TEST_1_STR);
+  }
+
+  @Test
+  public void should_fail_if_digest_conversion__incorrect() {
+    thrown.expectAssertionError(shouldBeEqual(DIGEST_TEST_1_STR, EXPECTED_MD5_DIGEST_STR, STANDARD_REPRESENTATION));
+    assertThat(Digests.toHex(DIGEST_TEST_1_BYTES)).isEqualTo(EXPECTED_MD5_DIGEST_STR);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/FilesBaseTest.java b/src/test/java/org/assertj/core/internal/FilesBaseTest.java
index 8b4b2c5c6..4f808bd8d 100644
--- a/src/test/java/org/assertj/core/internal/FilesBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/FilesBaseTest.java
@@ -12,13 +12,18 @@
  */
 package org.assertj.core.internal;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.test.TestData.someInfo;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 import static org.mockito.Mockito.when;
 
 import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
 
+import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.util.diff.Delta;
 import org.junit.Before;
@@ -28,11 +33,13 @@ import org.junit.Rule;
 /**
  * Base class for testing <code>{@link Files}</code>, set up diff and failures attributes (which is why it is in
  * <code>org.assertj.core.internal</code> package.
- * 
+ *
  * @author Joel Costigliola
  */
 public class FilesBaseTest {
 
+  protected static final AssertionInfo INFO = someInfo();
+
   @Rule
   public ExpectedException thrown = none();
   protected File actual;
@@ -42,13 +49,13 @@ public class FilesBaseTest {
   protected Diff diff;
   protected Delta<String> delta;
   protected BinaryDiff binaryDiff;
+  protected NioFilesWrapper nioFilesWrapper;
 
-  @SuppressWarnings("unchecked")
   @Before
   public void setUp() {
     actual = mock(File.class);
     failures = spy(new Failures());
-    files = new Files(); 
+    files = new Files();
     unMockedFiles = new Files();
     files.failures = failures;
     diff = mock(Diff.class);
@@ -57,6 +64,16 @@ public class FilesBaseTest {
     files.diff = diff;
     binaryDiff = mock(BinaryDiff.class);
     files.binaryDiff = binaryDiff;
+    nioFilesWrapper = mock(NioFilesWrapper.class);
+    files.nioFilesWrapper = nioFilesWrapper;
+  }
+
+  protected static void failIfStreamIsOpen(InputStream stream) {
+    try {
+      assertThat(stream.read()).as("Stream should be closed").isNegative();
+    } catch (IOException e) {
+      assertThat(e).hasNoCause().hasMessage("Stream closed");
+    }
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/InputStreamsBaseTest.java b/src/test/java/org/assertj/core/internal/InputStreamsBaseTest.java
index ce5f91e09..8c8038881 100644
--- a/src/test/java/org/assertj/core/internal/InputStreamsBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/InputStreamsBaseTest.java
@@ -12,17 +12,17 @@
  */
 package org.assertj.core.internal;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.ExpectedException.none;
-
+import static org.assertj.core.test.TestData.someInfo;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.spy;
 
 import java.io.ByteArrayInputStream;
+import java.io.IOException;
 import java.io.InputStream;
 
-import org.assertj.core.internal.Diff;
-import org.assertj.core.internal.Failures;
-import org.assertj.core.internal.InputStreams;
+import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.test.ExpectedException;
 import org.junit.Before;
 import org.junit.BeforeClass;
@@ -33,12 +33,14 @@ import org.junit.Rule;
  * Base class for {@link InputStreams} unit tests
  * <p>
  * Is in <code>org.assertj.core.internal</code> package to be able to set {@link InputStreams} attributes appropriately.
- * 
+ *
  * @author Joel Costigliola
- * 
+ *
  */
 public class InputStreamsBaseTest {
 
+  protected static final AssertionInfo INFO = someInfo();
+
   @Rule
   public ExpectedException thrown = none();
   protected Diff diff;
@@ -65,4 +67,12 @@ public class InputStreamsBaseTest {
     inputStreams.failures = failures;
   }
 
+  protected static void failIfStreamIsOpen(InputStream stream) {
+    try {
+      assertThat(stream.read()).as("Stream should be closed").isNegative();
+    } catch (IOException e) {
+      assertThat(e).hasNoCause().hasMessage("Stream closed");
+    }
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmBytes_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmBytes_Test.java
new file mode 100644
index 000000000..68031f169
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmBytes_Test.java
@@ -0,0 +1,158 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.files;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Digests;
+import org.assertj.core.internal.Files;
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Files#assertHasDigest(AssertionInfo, File, String, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class Files_assertHasDigest_AlgorithmBytes_Test extends FilesBaseTest {
+  private final String algorithm = "MD5";
+  private final byte[] expected = new byte[0];
+  private final String real = "3AC1AFA2A89B7E4F1866502877BF1DC5";
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    AssertionInfo info = someInfo();
+    thrown.expectAssertionError(actualIsNull());
+    files.assertHasDigest(info, null, algorithm, expected);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+    // GIVEN
+    given(actual.exists()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_file() {
+    // GIVEN
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeFile(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+    // GIVEN
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    files.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    files.assertHasDigest(INFO, null, algorithm, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(UncheckedIOException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_NoSuchAlgorithmException() {
+    // GIVEN
+    String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
+    // WHEN
+    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(IllegalStateException.class)
+                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws IOException, NoSuchAlgorithmException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff(real, "", MessageDigest.getInstance(algorithm))));
+    failIfStreamIsOpen(stream);
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    // WHEN
+    files.assertHasDigest(INFO, actual, algorithm, Digests.fromHex(real));
+    // THEN
+    failIfStreamIsOpen(stream);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmString_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmString_Test.java
new file mode 100644
index 000000000..072f6a2c5
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_AlgorithmString_Test.java
@@ -0,0 +1,158 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.files;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Digests;
+import org.assertj.core.internal.Files;
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Files#assertHasDigest(AssertionInfo, File, MessageDigest, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class Files_assertHasDigest_AlgorithmString_Test extends FilesBaseTest {
+  private final String algorithm = "MD5";
+  private final String expected = "";
+  private final String real = "3AC1AFA2A89B7E4F1866502877BF1DC5";
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    AssertionInfo info = someInfo();
+    thrown.expectAssertionError(actualIsNull());
+    files.assertHasDigest(info, null, algorithm, expected);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+    // GIVEN
+    given(actual.exists()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_file() {
+    // GIVEN
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeFile(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+    // GIVEN
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    files.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    files.assertHasDigest(INFO, null, algorithm, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(UncheckedIOException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_NoSuchAlgorithmException() {
+    // GIVEN
+    String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
+    // WHEN
+    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(IllegalStateException.class)
+                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws IOException, NoSuchAlgorithmException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff(real, "", MessageDigest.getInstance(algorithm))));
+    failIfStreamIsOpen(stream);
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    // WHEN
+    files.assertHasDigest(INFO, actual, algorithm, Digests.fromHex(real));
+    // THEN
+    failIfStreamIsOpen(stream);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestBytes_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestBytes_Test.java
new file mode 100644
index 000000000..dedaf251c
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestBytes_Test.java
@@ -0,0 +1,156 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.files;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.security.MessageDigest;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Files;
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Files#assertHasDigest(AssertionInfo, File, MessageDigest, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class Files_assertHasDigest_DigestBytes_Test extends FilesBaseTest {
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final byte[] expected = new byte[0];
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    files.assertHasDigest(INFO, null, digest, expected);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+    // GIVEN
+    given(actual.exists()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_file() {
+    // GIVEN
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeFile(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+    // GIVEN
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    files.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    files.assertHasDigest(INFO, null, digest, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    assertThat(error).isInstanceOf(UncheckedIOException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_NoSuchAlgorithmException() {
+    // GIVEN
+    String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
+    // WHEN
+    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(IllegalStateException.class)
+                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    given(digest.digest()).willReturn(new byte[] { 0, 1 });
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff("0001", "", digest)));
+    failIfStreamIsOpen(stream);
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    given(digest.digest()).willReturn(expected);
+    // WHEN
+    files.assertHasDigest(INFO, actual, digest, expected);
+    // THEN
+    failIfStreamIsOpen(stream);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestString_Test.java b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestString_Test.java
new file mode 100644
index 000000000..a70cac2ef
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/files/Files_assertHasDigest_DigestString_Test.java
@@ -0,0 +1,156 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.files;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldBeFile.shouldBeFile;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.security.MessageDigest;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Files;
+import org.assertj.core.internal.FilesBaseTest;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Files#assertHasDigest(AssertionInfo, File, MessageDigest, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class Files_assertHasDigest_DigestString_Test extends FilesBaseTest {
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final String expected = "";
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    files.assertHasDigest(INFO, null, digest, expected);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+    // GIVEN
+    given(actual.exists()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_file() {
+    // GIVEN
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeFile(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+    // GIVEN
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(false);
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    files.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    files.assertHasDigest(INFO, null, digest, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    assertThat(error).isInstanceOf(UncheckedIOException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_NoSuchAlgorithmException() {
+    // GIVEN
+    String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
+    // WHEN
+    Throwable error = catchThrowable(() -> files.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(IllegalStateException.class)
+                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    given(digest.digest()).willReturn(new byte[] { 0, 1 });
+    // WHEN
+    catchThrowable(() -> files.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff("0001", "", digest)));
+    failIfStreamIsOpen(stream);
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(actual.exists()).willReturn(true);
+    given(actual.isFile()).willReturn(true);
+    given(actual.canRead()).willReturn(true);
+    given(nioFilesWrapper.newInputStream(any())).willReturn(stream);
+    given(digest.digest()).willReturn(expected.getBytes());
+    // WHEN
+    files.assertHasDigest(INFO, actual, digest, expected);
+    // THEN
+    failIfStreamIsOpen(stream);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_AlgorithmBytes_Test.java b/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_AlgorithmBytes_Test.java
new file mode 100644
index 000000000..de76a4d14
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_AlgorithmBytes_Test.java
@@ -0,0 +1,95 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.inputstreams;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Digests;
+import org.assertj.core.internal.InputStreams;
+import org.assertj.core.internal.InputStreamsBaseTest;
+import org.assertj.core.internal.InputStreamsException;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link InputStreams#assertHasDigest(AssertionInfo, InputStream, String, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class InputStreams_assertHasDigest_AlgorithmBytes_Test extends InputStreamsBaseTest {
+  private static final String MD5 = "MD5";
+  private final byte[] expected = new byte[0];
+  private static final String RED_PNG_DIGEST = "3AC1AFA2A89B7E4F1866502877BF1DC5";
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    inputStreams.assertHasDigest(INFO, null, MD5, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    inputStreams.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    inputStreams.assertHasDigest(INFO, null, MD5, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    actual = mock(InputStream.class);
+    given(actual.read(any())).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> inputStreams.assertHasDigest(INFO, actual, MD5, expected));
+    // THEN
+    assertThat(error).isInstanceOf(InputStreamsException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws NoSuchAlgorithmException {
+    // GIVEN
+    actual = getClass().getResourceAsStream("/red.png");
+    // WHEN
+    catchThrowable(() -> inputStreams.assertHasDigest(INFO, actual, MD5, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff(RED_PNG_DIGEST, "", MessageDigest.getInstance(MD5))));
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() {
+    // GIVEN
+    actual = getClass().getResourceAsStream("/red.png");
+    // THEN
+    inputStreams.assertHasDigest(INFO, actual, MD5, Digests.fromHex(RED_PNG_DIGEST));
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_AlgorithmString_Test.java b/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_AlgorithmString_Test.java
new file mode 100644
index 000000000..73cc7c272
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_AlgorithmString_Test.java
@@ -0,0 +1,96 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.inputstreams;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Digests;
+import org.assertj.core.internal.InputStreams;
+import org.assertj.core.internal.InputStreamsBaseTest;
+import org.assertj.core.internal.InputStreamsException;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link InputStreams#assertHasDigest(AssertionInfo, InputStream, String, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class InputStreams_assertHasDigest_AlgorithmString_Test extends InputStreamsBaseTest {
+  private static final String MD5 = "MD5";
+  private final String expected = "";
+  private static final String RED_PNG_DIGEST = "3AC1AFA2A89B7E4F1866502877BF1DC5";
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    inputStreams.assertHasDigest(INFO, null, MD5, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    inputStreams.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    inputStreams.assertHasDigest(INFO, null, MD5, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    actual = mock(InputStream.class);
+    given(actual.read(any())).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> inputStreams.assertHasDigest(INFO, actual, MD5, expected));
+    // THEN
+    assertThat(error).isInstanceOf(InputStreamsException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws NoSuchAlgorithmException {
+    // GIVEN
+    actual = getClass().getResourceAsStream("/red.png");
+    // WHEN
+    catchThrowable(() -> inputStreams.assertHasDigest(INFO, actual, MD5, expected));
+    // THEN
+    verify(failures).failure(INFO,
+                             shouldHaveDigest(actual, new DigestDiff(RED_PNG_DIGEST, "", MessageDigest.getInstance(MD5))));
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() {
+    // GIVEN
+    actual = getClass().getResourceAsStream("/red.png");
+    // THEN
+    inputStreams.assertHasDigest(INFO, actual, MD5, Digests.fromHex(RED_PNG_DIGEST));
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_DigestBytes_Test.java b/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_DigestBytes_Test.java
new file mode 100644
index 000000000..9bb4b422d
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_DigestBytes_Test.java
@@ -0,0 +1,95 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.inputstreams;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.InputStreams;
+import org.assertj.core.internal.InputStreamsBaseTest;
+import org.assertj.core.internal.InputStreamsException;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link InputStreams#assertHasDigest(AssertionInfo, InputStream, MessageDigest, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class InputStreams_assertHasDigest_DigestBytes_Test extends InputStreamsBaseTest {
+
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final byte[] expected = new byte[0];
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    inputStreams.assertHasDigest(INFO, null, digest, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    inputStreams.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    inputStreams.assertHasDigest(INFO, null, digest, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    actual = mock(InputStream.class);
+    given(actual.read(any())).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> inputStreams.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    assertThat(error).isInstanceOf(InputStreamsException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() {
+    // GIVEN
+    actual = getClass().getResourceAsStream("/red.png");
+    given(digest.digest()).willReturn(new byte[] { 0, 1 });
+    // WHEN
+    catchThrowable(() -> inputStreams.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff("0001", "", digest)));
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() {
+    // GIVEN
+    actual = getClass().getResourceAsStream("/red.png");
+    given(digest.digest()).willReturn(expected);
+    // THEN
+    inputStreams.assertHasDigest(INFO, actual, digest, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_DigestString_Test.java b/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_DigestString_Test.java
new file mode 100644
index 000000000..1f549dddd
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/inputstreams/InputStreams_assertHasDigest_DigestString_Test.java
@@ -0,0 +1,94 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.inputstreams;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.security.MessageDigest;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.InputStreams;
+import org.assertj.core.internal.InputStreamsBaseTest;
+import org.assertj.core.internal.InputStreamsException;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link InputStreams#assertHasDigest(AssertionInfo, InputStream, MessageDigest, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class InputStreams_assertHasDigest_DigestString_Test extends InputStreamsBaseTest {
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final String expected = "";
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    inputStreams.assertHasDigest(INFO, null, digest, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    inputStreams.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    inputStreams.assertHasDigest(INFO, null, digest, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    actual = mock(InputStream.class);
+    given(actual.read(any())).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> inputStreams.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    assertThat(error).isInstanceOf(InputStreamsException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() {
+    // GIVEN
+    actual = getClass().getResourceAsStream("/red.png");
+    given(digest.digest()).willReturn(new byte[] { 0, 1 });
+    // WHEN
+    catchThrowable(() -> inputStreams.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff("0001", "", digest)));
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() {
+    // GIVEN
+    actual = getClass().getResourceAsStream("/red.png");
+    given(digest.digest()).willReturn(expected.getBytes());
+    // THEN
+    inputStreams.assertHasDigest(INFO, actual, digest, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java b/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java
index 8b3741224..2b7d0d48a 100644
--- a/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/paths/MockPathsBaseTest.java
@@ -12,22 +12,37 @@
  */
 package org.assertj.core.internal.paths;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.TestData.someInfo;
 import static org.mockito.Mockito.mock;
 
+import java.io.IOException;
+import java.io.InputStream;
 import java.nio.file.Path;
 
+import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.PathsBaseTest;
 import org.junit.Before;
 
 public class MockPathsBaseTest extends PathsBaseTest {
 
+  static final AssertionInfo INFO = someInfo();
+
   Path actual;
   Path other;
 
   @Before
   public void init() {
-	actual = mock(Path.class);
-	other = mock(Path.class);
+    actual = mock(Path.class);
+    other = mock(Path.class);
+  }
+
+  static void failIfStreamIsOpen(InputStream stream) {
+    try {
+      assertThat(stream.read()).as("Stream should be closed").isNegative();
+    } catch (IOException e) {
+      assertThat(e).hasNoCause().hasMessage("Stream closed");
+    }
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_AlgorithmBytes_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_AlgorithmBytes_Test.java
new file mode 100644
index 000000000..427b2dd63
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_AlgorithmBytes_Test.java
@@ -0,0 +1,153 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.verify;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Digests;
+import org.assertj.core.internal.Paths;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertHasDigest(AssertionInfo, Path, String, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class Paths_assertHasDigest_AlgorithmBytes_Test extends MockPathsBaseTest {
+  private final String algorithm = "MD5";
+  private final byte[] expected = new byte[0];
+  private final String real = "3AC1AFA2A89B7E4F1866502877BF1DC5";
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    paths.assertHasDigest(info, null, algorithm, expected);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_file() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeRegularFile(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    paths.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    paths.assertHasDigest(INFO, null, algorithm, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(UncheckedIOException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_NoSuchAlgorithmException() {
+    // GIVEN
+    String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(IllegalStateException.class)
+                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws IOException, NoSuchAlgorithmException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff(real, "", MessageDigest.getInstance(algorithm))));
+    failIfStreamIsOpen(stream);
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
+    // WHEN
+    paths.assertHasDigest(INFO, actual, algorithm, Digests.fromHex(real));
+    // THEN
+    failIfStreamIsOpen(stream);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_AlgorithmString_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_AlgorithmString_Test.java
new file mode 100644
index 000000000..548522ed5
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_AlgorithmString_Test.java
@@ -0,0 +1,153 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.verify;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Digests;
+import org.assertj.core.internal.Paths;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertHasDigest(AssertionInfo, Path, String, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class Paths_assertHasDigest_AlgorithmString_Test extends MockPathsBaseTest {
+  private final String algorithm = "MD5";
+  private final String expected = "";
+  private final String real = "3AC1AFA2A89B7E4F1866502877BF1DC5";
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    paths.assertHasDigest(info, null, algorithm, expected);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_file() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeRegularFile(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    paths.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    paths.assertHasDigest(INFO, null, algorithm, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(UncheckedIOException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_NoSuchAlgorithmException() {
+    // GIVEN
+    String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(IllegalStateException.class)
+                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws IOException, NoSuchAlgorithmException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, algorithm, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff(real, "", MessageDigest.getInstance(algorithm))));
+    failIfStreamIsOpen(stream);
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
+    // WHEN
+    paths.assertHasDigest(INFO, actual, algorithm, Digests.fromHex(real));
+    // THEN
+    failIfStreamIsOpen(stream);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_DigestBytes_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_DigestBytes_Test.java
new file mode 100644
index 000000000..fdbc25ccc
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_DigestBytes_Test.java
@@ -0,0 +1,153 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+import java.security.MessageDigest;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Paths;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertHasDigest(AssertionInfo, Path, MessageDigest, byte[])}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class Paths_assertHasDigest_DigestBytes_Test extends MockPathsBaseTest {
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final byte[] expected = new byte[0];
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    paths.assertHasDigest(info, null, digest, expected);
+  }
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_file() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeRegularFile(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    paths.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    paths.assertHasDigest(INFO, null, digest, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    assertThat(error).isInstanceOf(UncheckedIOException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_NoSuchAlgorithmException() {
+    // GIVEN
+    String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(IllegalStateException.class)
+                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
+    given(digest.digest()).willReturn(new byte[] { 0, 1 });
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff("0001", "", digest)));
+    failIfStreamIsOpen(stream);
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
+    given(digest.digest()).willReturn(expected);
+    // WHEN
+    paths.assertHasDigest(INFO, actual, digest, expected);
+    // THEN
+    failIfStreamIsOpen(stream);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_DigestString_Test.java b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_DigestString_Test.java
new file mode 100644
index 000000000..de05f2d4b
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/paths/Paths_assertHasDigest_DigestString_Test.java
@@ -0,0 +1,146 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2018 the original author or authors.
+ */
+package org.assertj.core.internal.paths;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.error.ShouldBeReadable.shouldBeReadable;
+import static org.assertj.core.error.ShouldBeRegularFile.shouldBeRegularFile;
+import static org.assertj.core.error.ShouldExist.shouldExist;
+import static org.assertj.core.error.ShouldHaveDigest.shouldHaveDigest;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.UncheckedIOException;
+import java.nio.file.Path;
+import java.security.MessageDigest;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DigestDiff;
+import org.assertj.core.internal.Paths;
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Paths#assertHasDigest(AssertionInfo, Path, MessageDigest, String)}</code>
+ *
+ * @author Valeriy Vyrva
+ */
+public class Paths_assertHasDigest_DigestString_Test extends MockPathsBaseTest {
+  private final MessageDigest digest = mock(MessageDigest.class);
+  private final String expected = "";
+
+  @Test
+  public void should_fail_with_should_exist_error_if_actual_does_not_exist() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldExist(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_file() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeRegularFile(actual));
+  }
+
+  @Test
+  public void should_fail_if_actual_exists_but_is_not_readable() {
+    // GIVEN
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(false);
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldBeReadable(actual));
+  }
+
+  @Test
+  public void should_throw_error_if_digest_is_null() {
+    thrown.expectNullPointerException("The message digest algorithm should not be null");
+    paths.assertHasDigest(INFO, null, (MessageDigest) null, expected);
+  }
+
+  @Test
+  public void should_throw_error_if_expected_is_null() {
+    thrown.expectNullPointerException("The binary representation of digest to compare to should not be null");
+    paths.assertHasDigest(INFO, null, digest, (byte[]) null);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_IOException() throws IOException {
+    // GIVEN
+    IOException cause = new IOException();
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willThrow(cause);
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    assertThat(error).isInstanceOf(UncheckedIOException.class)
+                     .hasCause(cause);
+  }
+
+  @Test
+  public void should_throw_error_wrapping_catched_NoSuchAlgorithmException() {
+    // GIVEN
+    String unknownDigestAlgorithm = "UnknownDigestAlgorithm";
+    // WHEN
+    Throwable error = catchThrowable(() -> paths.assertHasDigest(INFO, actual, unknownDigestAlgorithm, expected));
+    // THEN
+    assertThat(error).isInstanceOf(IllegalStateException.class)
+                     .hasMessage("Unable to find digest implementation for: <UnknownDigestAlgorithm>");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_have_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
+    given(digest.digest()).willReturn(new byte[] { 0, 1 });
+    // WHEN
+    catchThrowable(() -> paths.assertHasDigest(INFO, actual, digest, expected));
+    // THEN
+    verify(failures).failure(INFO, shouldHaveDigest(actual, new DigestDiff("0001", "", digest)));
+    failIfStreamIsOpen(stream);
+  }
+
+  @Test
+  public void should_pass_if_actual_has_expected_digest() throws IOException {
+    // GIVEN
+    InputStream stream = getClass().getResourceAsStream("/red.png");
+    given(nioFilesWrapper.exists(actual)).willReturn(true);
+    given(nioFilesWrapper.isRegularFile(actual)).willReturn(true);
+    given(nioFilesWrapper.isReadable(actual)).willReturn(true);
+    given(nioFilesWrapper.newInputStream(actual)).willReturn(stream);
+    given(digest.digest()).willReturn(expected.getBytes());
+    // WHEN
+    paths.assertHasDigest(INFO, actual, digest, expected);
+    // THEN
+    failIfStreamIsOpen(stream);
+  }
+}
