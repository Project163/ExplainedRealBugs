diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 8e38e003e..5eb26c26e 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -494,16 +494,17 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   /**
    * Makes the recursive comparison to only compare given actual fields of the specified types and their subfields (no other fields will be compared).
    * <p>
-   * Specifying a field of type will make all its subfields to be compared, for example specifying the {@code Person} type will
+   * Specifying a compared type will make any fields of this type and its subfields to be compared, for example specifying the {@code Person} type will
    * lead to compare {@code Person.name}, {@code Person.address} and all other {@code Person} fields.<br>
    * In case actual's field is null, expected's field type will be checked to match one of the given types (we assume actual and expected fields have the same type).
    * <p>
-   * {@code ", "} can be combined with {@link #comparingOnlyFields(String...)} to compare fields of the given types <b>or</b> names (union of both sets of fields).
+   * {@code comparingOnlyFieldsOfTypes} can be combined with {@link #comparingOnlyFields(String...)} to compare fields of the given types <b>or</b> names (union of both sets of fields).
    * <p>
-   * {@code ", "} can be also combined with ignoring fields or compare only fields by name methods to restrict further the fields actually compared,
+   * {@code comparingOnlyFieldsOfTypes} can be also combined with ignoring fields to restrict further the fields actually compared,
    * the resulting compared fields = {specified compared fields of types} {@code -} {specified ignored fields}.<br>
-   * For example if the specified compared fields of types = {@code {String.class, Integer.class, Double.class}}, when there are fields  String foo, {@code Integer baz} and {@code Double bar}
-   * and the ignored fields = {"bar"} set with {@link RecursiveComparisonAssert#ignoringFields(String...)} that will remove {@code bar} field from comparison, then only {@code {foo, baz}} fields will be compared.
+   * For example, we specify the following compared types: {@code {String.class, Integer.class, Double.class}}, and the
+   * object to compare has fields {@code String foo}, {@code Integer baz} and {@code Double bar},
+   * if we ignore the {"bar"} field with {@link RecursiveComparisonAssert#ignoringFields(String...)} the comparison will only report differences on {@code {foo, baz}} fields..
    * <p>
    * Usage example:
    * <pre><code class='java'> class Person {
@@ -532,12 +533,12 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    *
    * // assertion succeeds as it only compared fields height and home.address.number since their types match compared types
    * assertThat(sherlock).usingRecursiveComparison()
-   *                     .", "(Integer.class, Double.class)
+   *                     .comparingOnlyFieldsOfTypes(Integer.class, Double.class)
    *                     .isEqualTo(moriarty);
    *
    * // assertion fails as home.address.street fields differ (Home fields and its subfields were compared)
    * assertThat(sherlock).usingRecursiveComparison()
-   *                     .", "(Home.class)
+   *                     .comparingOnlyFieldsOfTypes(Home.class)
    *                     .isEqualTo(moriarty);</code></pre>
    * <p>
    * Note that the recursive comparison checks whether the fields actually exist and throws an {@link IllegalArgumentException} if some of them don't,
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java
index e9c4c5db2..5b4b075c3 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java
@@ -175,12 +175,13 @@ public abstract class AbstractRecursiveOperationConfiguration {
   }
 
   public boolean matchesAnIgnoredFieldRegex(FieldLocation fieldLocation) {
-    return getIgnoredFieldsRegexes().stream()
-                                    .anyMatch(regex -> regex.matcher(fieldLocation.getPathToUseInRules()).matches());
+    // checks parent fields as if a parent field is ignored all subfields (including this field location) should be too.
+    return getIgnoredFieldsRegexes().stream().anyMatch(fieldLocation::hierarchyMatchesRegex);
   }
 
   public boolean matchesAnIgnoredField(FieldLocation fieldLocation) {
-    return getIgnoredFields().stream().anyMatch(fieldLocation::matches);
+    // checks parent fields as if a parent field is ignored all subfields (including this field location) should be too.
+    return getIgnoredFields().stream().anyMatch(fieldLocation::hierarchyMatches);
   }
 
   private String describeIgnoredFields() {
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValueDeque.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValueDeque.java
index e2f22ab30..ad7442fe2 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValueDeque.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValueDeque.java
@@ -28,13 +28,13 @@ class DualValueDeque extends LinkedList<DualValue> {
 
   @Override
   public boolean add(DualValue dualKey) {
-    if (shouldIgnore(dualKey)) return false;
+    if (shouldNotEvaluate(dualKey)) return false;
     return super.add(dualKey);
   }
 
   @Override
   public void add(int index, DualValue dualKey) {
-    if (shouldIgnore(dualKey)) return;
+    if (shouldNotEvaluate(dualKey)) return;
     super.add(index, dualKey);
   }
 
@@ -45,22 +45,31 @@ class DualValueDeque extends LinkedList<DualValue> {
 
   @Override
   public void addFirst(DualValue dualKey) {
-    if (shouldIgnore(dualKey)) return;
+    if (shouldNotEvaluate(dualKey)) return;
     super.addFirst(dualKey);
   }
 
   @Override
   public void addLast(DualValue dualKey) {
-    if (shouldIgnore(dualKey)) return;
+    if (shouldNotEvaluate(dualKey)) return;
     super.addLast(dualKey);
   }
 
-  private boolean shouldIgnore(DualValue dualKey) {
-    return recursiveComparisonConfiguration.shouldIgnore(dualKey);
+  /**
+   * Decides whether the value needs to evaluated, note that we need to evaluate all values if we have
+   * compared types registered as a value could have fields of type to compare.
+   * <p>
+   * For example if we want to compare Employee in a Company, we need to evaluate company as it holds a list of Employee.
+   *
+   * @param dualValue the value to check
+   * @return true if we want to register the value for evaluation, false otherwise
+   */
+  private boolean shouldNotEvaluate(DualValue dualValue) {
+    return recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
   }
 
   private boolean shouldAddDualKey(DualValue dualKey) {
-    return !shouldIgnore(dualKey);
+    return !shouldNotEvaluate(dualKey);
   }
 
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
index 3167a2992..e430b695e 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
@@ -16,11 +16,13 @@ import static java.util.Collections.emptyList;
 import static java.util.Collections.unmodifiableList;
 import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toList;
 import static org.assertj.core.util.Lists.list;
 
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
+import java.util.regex.Pattern;
 
 /**
  * Represents the path to a given field. Immutable
@@ -31,24 +33,105 @@ public final class FieldLocation implements Comparable<FieldLocation> {
 
   private final String pathToUseInRules;
   private final List<String> decomposedPath;
+  private final List<String> pathsHierarchyToUseInRules;
 
   public FieldLocation(List<String> path) {
     decomposedPath = unmodifiableList(requireNonNull(path, "path cannot be null"));
     pathToUseInRules = pathToUseInRules(decomposedPath);
+    pathsHierarchyToUseInRules = pathsHierarchyToUseInRules();
   }
 
   public FieldLocation(String s) {
     this(list(s.split("\\.")));
   }
 
-  public boolean matches(FieldLocation field) {
-    return pathToUseInRules.equals(field.pathToUseInRules);
+  public boolean exactlyMatches(FieldLocation field) {
+    return exactlyMatches(field.pathToUseInRules);
   }
 
-  public boolean matches(String fieldPath) {
+  public boolean exactlyMatches(String fieldPath) {
     return pathToUseInRules.equals(fieldPath);
   }
 
+  /**
+   * Reruns true if it exactly matches this field, false otherwise.
+   *
+   * @param fieldPath field path to check
+   * @return true if it exactly matches this field, false otherwise
+   * @deprecated use {@link #exactlyMatches(String)} instead.
+   */
+  @Deprecated
+  public boolean matches(String fieldPath) {
+    return exactlyMatches(fieldPath);
+  }
+
+  /**
+   * Reruns true if it exactly matches this field, false otherwise.
+   *
+   * @param field field to check
+   * @return true if it exactly matches this field, false otherwise
+   * @deprecated use {@link #exactlyMatches(String)} instead.
+   */
+  @Deprecated
+  public boolean matches(FieldLocation field) {
+    return exactlyMatches(field);
+  }
+
+  /**
+   * Checks whether this fieldLocation or any of its parents matches the given fieldPath.
+   * <p>
+   * Examples:
+   * <pre><code class='java'>
+   * | fieldLocation       | fieldPath    | matches?
+   * -----------------------------------------------
+   * | name.first          | "name"       | true
+   * | name.first.nickname | "name"       | true
+   * | name.first          | "name.first" | true
+   * | name.first.nickname | "name.first" | true
+   * | name                | "name"       | true
+   * | name                | "name.first" | false
+   * | person.name         | "name"       | false
+   * | names               | "name"       | false
+   * | nickname            | "name"       | false
+   * | name                | "nickname"   | false
+   * | first.nickname      | "name"       | false
+   * </code></pre>
+   *
+   * @param fieldPath the field path to test
+   * @return true if this fieldLocation is the given fieldPath or a child of it, false otherwise.
+   */
+  public boolean hierarchyMatches(String fieldPath) {
+    return pathsHierarchyToUseInRules.contains(fieldPath);
+  }
+
+  /**
+   * Checks whether this fieldLocation or any of its parents matches the given regex.
+   * <p>
+   * Examples:
+   * <pre><code class='java'>
+   * | fieldLocation       | regex        | matches?
+   * -----------------------------------------------
+   * | name.first          | "name"       | true
+   * | name.first          | "..me"       | true
+   * | name.first.nickname | "name"       | true
+   * | name.first          | "name.first" | true
+   * | name.first.nickname | "name.first" | true
+   * | name                | "name"       | true
+   * | name                | "name.first" | false
+   * | person.name         | "name"       | false
+   * | names               | "name"       | false
+   * | nickname            | "name"       | false
+   * | name                | "nickname"   | false
+   * | first.nickname      | "name"       | false
+   * </code></pre>
+   *
+   * @param regex the regex to test
+   * @return true this fieldLocation or any of its parent matches the given regex., false otherwise.
+   */
+  public boolean hierarchyMatchesRegex(Pattern regex) {
+    return pathsHierarchyToUseInRules.stream().anyMatch(path -> regex.matcher(path).matches());
+  }
+
   public List<String> getDecomposedPath() {
     return decomposedPath;
   }
@@ -74,12 +157,13 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     if (!(obj instanceof FieldLocation)) return false;
     FieldLocation that = (FieldLocation) obj;
     return Objects.equals(pathToUseInRules, that.pathToUseInRules)
-           && Objects.equals(decomposedPath, that.decomposedPath);
+           && Objects.equals(decomposedPath, that.decomposedPath)
+           && Objects.equals(pathsHierarchyToUseInRules, that.pathsHierarchyToUseInRules);
   }
 
   @Override
   public int hashCode() {
-    return Objects.hash(pathToUseInRules, decomposedPath);
+    return Objects.hash(pathToUseInRules, decomposedPath, pathsHierarchyToUseInRules);
   }
 
   @Override
@@ -126,7 +210,8 @@ public final class FieldLocation implements Comparable<FieldLocation> {
    * Returns true if this has the given parent (direct or indirect), false otherwise.
    * <p>
    * Examples:
-   * <pre><code class='java'> | field                 | parent       | hasParent? 
+   * <pre><code class='java'>
+   * | field                 | parent       | hasParent?
    * -----------------------------------------------  
    * | "name.first"          | "name"       | true       
    * | "name.first.nickname" | "name"       | true       
@@ -171,4 +256,21 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     return child.hasParent(this);
   }
 
+  private List<String> pathsHierarchyToUseInRules() {
+    List<FieldLocation> fieldAndParentFields = list();
+    FieldLocation currentLocation = this;
+    while (!currentLocation.isRoot()) {
+      fieldAndParentFields.add(currentLocation);
+      currentLocation = currentLocation.parent();
+    }
+    return fieldAndParentFields.stream()
+                               .map(fieldLocation -> fieldLocation.pathToUseInRules)
+                               .collect(toList());
+  }
+
+  private FieldLocation parent() {
+    List<String> parentPath = new ArrayList<>(decomposedPath);
+    parentPath.remove(decomposedPath.size() - 1);
+    return new FieldLocation(parentPath);
+  }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index cdbb79c5b..98cc3d599 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -83,8 +83,12 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   private FieldMessages fieldMessages = new FieldMessages();
 
   // track field locations of fields of type to compare, needed to compare child nodes
-  // for example if we want to compare Person type, we must compare Person fields too event thought they are not of type Person
-  private final Set<FieldLocation> fieldLocationOfFieldsOfTypesToCompare = new LinkedHashSet<>();
+  // for example if we want to compare Person type, we must compare Person fields too event though they are not of type Person
+  private final Set<FieldLocation> fieldLocationsToCompareBecauseOfTypesToCompare = new LinkedHashSet<>();
+
+  public void registerFieldLocationToCompareBecauseOfTypesToCompare(FieldLocation fieldLocation) {
+    fieldLocationsToCompareBecauseOfTypesToCompare.add(fieldLocation);
+  }
 
   private RecursiveComparisonIntrospectionStrategy introspectionStrategy = DEFAULT_RECURSIVE_COMPARISON_INTROSPECTION_STRATEGY;
 
@@ -679,20 +683,23 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return description.toString();
   }
 
+  boolean shouldNotEvaluate(DualValue dualValue) {
+    // if we have some compared types, we can't discard any values since they could have fields we need to compare.
+    if (!comparedTypes.isEmpty()) return false;
+    return shouldIgnore(dualValue);
+  }
+
   boolean shouldIgnore(DualValue dualValue) {
-    return !shouldBeCompared(dualValue)
-           || shouldIgnoreFieldBasedOnFieldLocation(dualValue.fieldLocation)
+    return shouldIgnoreFieldBasedOnFieldLocation(dualValue.fieldLocation)
            || shouldIgnoreFieldBasedOnFieldValue(dualValue);
   }
 
   private boolean shouldBeCompared(DualValue dualValue) {
-    // empty comparedFields and comparedTypes <=> no restriction on compared fields <=> must be compared
+    // no comparedFields and comparedTypes <=> no restriction on compared fields => everything must be compared
     if (comparedFields.isEmpty() && comparedTypes.isEmpty()) return true;
-    return shouldBeComparedBasedOnFieldLocation(dualValue.fieldLocation) || shouldBeComparedBasedOnFieldValue(dualValue);
-  }
-
-  private boolean shouldBeComparedBasedOnFieldLocation(FieldLocation fieldLocation) {
-    return comparedFields.stream().anyMatch(matchesComparedField(fieldLocation));
+    // if we have compared types, we can't ignore any values since they could have fields of types to compare
+    if (!comparedTypes.isEmpty()) return true;
+    return comparedFields.stream().anyMatch(matchesComparedField(dualValue.fieldLocation));
   }
 
   private static Predicate<FieldLocation> matchesComparedField(FieldLocation field) {
@@ -700,13 +707,20 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     // - "name.first" must be compared if "name" is a compared field so will other "name" subfields like "name.last"
     // - "name" must be compared if "name.first" is a compared field otherwise "name" is ignored and "name.first" too
     return comparedField -> field.isRoot() // always compare root!
-                            || field.matches(comparedField) // exact match
+                            || field.exactlyMatches(comparedField)
                             || field.hasParent(comparedField) // ex: field "name.first" and "name" compared field
                             || field.hasChild(comparedField); // ex: field "name" and "name.first" compared field
   }
 
   Set<String> getActualChildrenNodeNamesToCompare(DualValue dualValue) {
     Set<String> actualChildrenNodeNames = getChildrenNodeNamesOf(dualValue.actual);
+    // if we have some compared types, we can't discard any nodes since they could have fields we need to compare.
+    // we could evaluate the whole graphs to figure that but that would be bad performance wise so add everything
+    // and exclude later on any differences that were on fields not to compare
+    if (!comparedTypes.isEmpty()) {
+      registerFieldLocationOfFieldsOfTypesToCompare(dualValue);
+      return actualChildrenNodeNames;
+    }
     // we are doing the same as shouldIgnore(DualValue dualValue) but in two steps for performance reasons:
     // - we filter first ignored nodes by names that don't need building DualValues
     // - then we filter field DualValues with the remaining criteria that need to get the node value
@@ -889,7 +903,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   }
 
   private boolean matchesAnIgnoredOverriddenEqualsField(FieldLocation fieldLocation) {
-    return ignoredOverriddenEqualsForFields.stream().anyMatch(fieldLocation::matches)
+    return ignoredOverriddenEqualsForFields.stream().anyMatch(fieldLocation::exactlyMatches)
            || matchesAnIgnoredOverriddenEqualsRegex(fieldLocation);
   }
 
@@ -914,21 +928,18 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return false;
   }
 
-  private boolean shouldBeComparedBasedOnFieldValue(DualValue dualValue) {
-    // first check if the value has a parent of a type we need to compare, ex: we compare Person types and the value is
-    // corresponds to one of the Person fields. If this is not the case, we check actual type against the types
-    // to compare, we use expected type in case actual was null assuming expected has the same type as actual
-    if (fieldLocationOfFieldsOfTypesToCompare.stream().anyMatch(dualValue.fieldLocation::hasParent)
-        || (dualValue.actual != null && comparedTypes.contains(dualValue.actual.getClass()))
+  private void registerFieldLocationOfFieldsOfTypesToCompare(DualValue dualValue) {
+    if (comparedTypes.isEmpty()) return;
+    // We check actual type against the types to compare or expected type in case actual was null assuming expected
+    // has the same type as actual
+    if ((dualValue.actual != null && comparedTypes.contains(dualValue.actual.getClass()))
         || (dualValue.expected != null && comparedTypes.contains(dualValue.expected.getClass()))) {
-      fieldLocationOfFieldsOfTypesToCompare.add(dualValue.fieldLocation);
-      return true;
+      fieldLocationsToCompareBecauseOfTypesToCompare.add(dualValue.fieldLocation);
     }
-    return false;
   }
 
   private boolean matchesAnIgnoredCollectionOrderInField(FieldLocation fieldLocation) {
-    return ignoredCollectionOrderInFields.stream().anyMatch(fieldLocation::matches);
+    return ignoredCollectionOrderInFields.stream().anyMatch(fieldLocation::exactlyMatches);
   }
 
   private boolean matchesAnIgnoredCollectionOrderInFieldRegex(FieldLocation fieldLocation) {
@@ -1099,6 +1110,29 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
         : format("{%s in %s}", unknownNodeNameElement, fieldLocation);
   }
 
+  boolean hierarchyMatchesAnyComparedTypes(DualValue dualValue) {
+    if (isFieldOfTypeToCompare(dualValue)) return true;
+    // dualValue is not a type to compare but could be a child of one
+    return fieldLocationsToCompareBecauseOfTypesToCompare.stream().anyMatch(dualValue.fieldLocation::hasParent);
+  }
+
+  boolean matchesOrIsChildOfFieldMatchingAnyComparedTypes(DualValue dualValue) {
+    return fieldLocationsToCompareBecauseOfTypesToCompare.stream().anyMatch(dualValue.fieldLocation::exactlyMatches);
+  }
+
+  boolean hasComparedTypes() {
+    return !comparedTypes.isEmpty();
+  }
+
+  private boolean isFieldOfTypeToCompare(DualValue dualValue) {
+    Object valueToCheck = dualValue.actual != null ? dualValue.actual : dualValue.expected;
+    return valueToCheck != null && comparedTypes.contains(valueToCheck.getClass());
+  }
+
+  boolean exactlyMatchesAnyComparedFields(DualValue dualValue) {
+    return comparedFields.stream().anyMatch(comparedField -> comparedField.exactlyMatches(dualValue.fieldLocation));
+  }
+
   /**
    * Builder to build {@link RecursiveComparisonConfiguration}.
    */
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 023f112e6..231307751 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -89,6 +89,22 @@ public class RecursiveComparisonDifferenceCalculator {
     }
 
     void addDifference(DualValue dualValue, String description) {
+      // to evaluate differences on fields of compared types, we have to traverse the whole graph of objects to compare
+      // and decide afterward if differences were relevant, for example if we compare only the Employee type, and we
+      // come across a Company having a list of Employee, we should evaluate the Company but ignore any of its
+      // differences unless the ones on Employees.
+      if (recursiveComparisonConfiguration.hasComparedTypes()) {
+        // the comparison includes the union of fields of compared types and compared fields, if the difference is
+        // reported on a field whose type is not in the compared types, we should ignore the difference unless it was
+        // on a field from the set of compared fields.
+        if (!recursiveComparisonConfiguration.exactlyMatchesAnyComparedFields(dualValue)
+            && !recursiveComparisonConfiguration.matchesOrIsChildOfFieldMatchingAnyComparedTypes(dualValue))
+          // was not a field we had to compared
+          return;
+        // check if the value was meant to be ignored, if it is the case simply skip the difference
+        if (recursiveComparisonConfiguration.shouldIgnore(dualValue)) return;
+      }
+
       String customErrorMessage = getCustomErrorMessage(dualValue);
       ComparisonDifference comparisonDifference = new ComparisonDifference(dualValue, description, customErrorMessage);
       differences.add(comparisonDifference);
@@ -219,6 +235,12 @@ public class RecursiveComparisonDifferenceCalculator {
     while (comparisonState.hasDualValuesToCompare()) {
 
       final DualValue dualValue = comparisonState.pickDualValueToCompare();
+      if (recursiveComparisonConfiguration.hierarchyMatchesAnyComparedTypes(dualValue)) {
+        // keep track of field locations of type to compare, needed to compare child nodes, for example if we want to
+        // only compare the Person type, we must compare the Person fields too even though they are not of type Person
+        recursiveComparisonConfiguration.registerFieldLocationToCompareBecauseOfTypesToCompare(dualValue.fieldLocation);
+      }
+
       // if we have already visited the dual value, no need to compute the comparison differences again, this also avoid cycles
       Optional<List<ComparisonDifference>> comparisonDifferences = comparisonState.visitedDualValues.registeredComparisonDifferencesOf(dualValue);
       if (comparisonDifferences.isPresent()) {
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_matches_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_exactlyMatches_Test.java
similarity index 76%
rename from assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_matches_Test.java
rename to assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_exactlyMatches_Test.java
index 0540c8eb3..fdf029d2b 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_matches_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_exactlyMatches_Test.java
@@ -24,20 +24,20 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
-class FieldLocation_matches_Test {
+class FieldLocation_exactlyMatches_Test {
 
-  @ParameterizedTest(name = "{0} matches {1}")
+  @ParameterizedTest(name = "{0} exactly matches {1}")
   @MethodSource
-  void matches_should_match_string_fields(List<String> fieldPath, String matchingFieldPath) {
+  void exactlyMatches_should_match_string_fields(List<String> fieldPath, String matchingFieldPath) {
     // GIVEN
     FieldLocation underTest = new FieldLocation(fieldPath);
     // WHEN
-    boolean match = underTest.matches(matchingFieldPath);
+    boolean match = underTest.exactlyMatches(matchingFieldPath);
     // THEN
-    then(match).as("%s matches %s", underTest, matchingFieldPath).isTrue();
+    then(match).as("%s exactly matches %s", underTest, matchingFieldPath).isTrue();
   }
 
-  private static Stream<Arguments> matches_should_match_string_fields() {
+  private static Stream<Arguments> exactlyMatches_should_match_string_fields() {
     return Stream.of(arguments(list("name"), "name"),
                      arguments(list("name", "first"), "name.first"),
                      arguments(list("name", "[2]", "first"), "name.first"),
@@ -47,18 +47,18 @@ class FieldLocation_matches_Test {
                      arguments(list("father", "name", "first"), "father.name.first"));
   }
 
-  @ParameterizedTest(name = "{0} matches {1}")
+  @ParameterizedTest(name = "{0} exactly matches {1}")
   @MethodSource
-  void matches_should_match_fields(List<String> fieldPath, String matchingFieldPath) {
+  void exactlyMatches_should_match_fields(List<String> fieldPath, String matchingFieldPath) {
     // GIVEN
     FieldLocation underTest = new FieldLocation(fieldPath);
     // WHEN
-    boolean match = underTest.matches(new FieldLocation(matchingFieldPath));
+    boolean match = underTest.exactlyMatches(new FieldLocation(matchingFieldPath));
     // THEN
-    then(match).as("%s matches %s", underTest, matchingFieldPath).isTrue();
+    then(match).as("%s exactly matches %s", underTest, matchingFieldPath).isTrue();
   }
 
-  private static Stream<Arguments> matches_should_match_fields() {
+  private static Stream<Arguments> exactlyMatches_should_match_fields() {
     return Stream.of(arguments(list("name"), "name"),
                      arguments(list("name", "first"), "name.first"),
                      arguments(list("name", "[2]", "first"), "name.first"),
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_hierarchyMatchesRegex_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_hierarchyMatchesRegex_Test.java
new file mode 100644
index 000000000..c5eef5150
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_hierarchyMatchesRegex_Test.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.List;
+import java.util.regex.Pattern;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.FieldLocation;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class FieldLocation_hierarchyMatchesRegex_Test {
+
+  @ParameterizedTest(name = "{0} field hierarchy matches regex {1}")
+  @MethodSource
+  void hierarchyMatchesRegex_should_return_true(List<String> fieldPath, String regex) {
+    // GIVEN
+    FieldLocation field = new FieldLocation(fieldPath);
+    Pattern pattern = Pattern.compile(regex);
+    // WHEN
+    boolean result = field.hierarchyMatchesRegex(pattern);
+    // THEN
+    then(result).as("%s field hierarchy matches regex %s", field, regex).isTrue();
+  }
+
+  private static Stream<Arguments> hierarchyMatchesRegex_should_return_true() {
+    return Stream.of(arguments(list("name"), "name"),
+                     arguments(list("name", "first"), "name"),
+                     arguments(list("name", "first"), ".ame"),
+                     arguments(list("name", "first", "nickname"), "name"),
+                     arguments(list("name", "first", "nickname"), ".*me"),
+                     arguments(list("name", "first", "nickname"), "name\\.first"),
+                     arguments(list("name", "first", "nickname"), ".*first"),
+                     arguments(list("name", "first"), "name\\.first"),
+                     arguments(list("name", "first"), "nam....rst"));
+  }
+
+  @ParameterizedTest(name = "{0} field hierarchy does not match regex {1}")
+  @MethodSource
+  void hierarchyMatchesRegex_should_return_false(List<String> fieldPath, String regex) {
+    // GIVEN
+    FieldLocation field = new FieldLocation(fieldPath);
+    Pattern pattern = Pattern.compile(regex);
+    // WHEN
+    boolean result = field.hierarchyMatchesRegex(pattern);
+    // THEN
+    then(result).as("%s field hierarchy does not match regex %s", field, regex).isFalse();
+  }
+
+  private static Stream<Arguments> hierarchyMatchesRegex_should_return_false() {
+    return Stream.of(arguments(list("person", "name"), "name"),
+                     arguments(list("person", "name"), "na.*"),
+                     arguments(list("names"), "name"),
+                     arguments(list("names"), ".*name"),
+                     arguments(list("nickname"), "..name"),
+                     arguments(list("name"), "ni.*"),
+                     arguments(list("name"), "name\\.first"),
+                     arguments(list("name"), "name.first"),
+                     arguments(list("name"), "name.+"),
+                     arguments(list("first", "nickname"), "name"),
+                     arguments(list("first", "nickname"), "...name"));
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_hierarchyMatches_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_hierarchyMatches_Test.java
new file mode 100644
index 000000000..1b25da4b8
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_hierarchyMatches_Test.java
@@ -0,0 +1,66 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.List;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.FieldLocation;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class FieldLocation_hierarchyMatches_Test {
+
+  @ParameterizedTest(name = "{0} is or is a child of {1}")
+  @MethodSource
+  void hierarchyMatches_should_return_true(List<String> fieldPath, String other) {
+    // GIVEN
+    FieldLocation field = new FieldLocation(fieldPath);
+    // WHEN
+    boolean result = field.hierarchyMatches(other);
+    // THEN
+    then(result).as("%s is or is a child of %s", field, other).isTrue();
+  }
+
+  private static Stream<Arguments> hierarchyMatches_should_return_true() {
+    return Stream.of(arguments(list("name"), "name"),
+                     arguments(list("name", "first"), "name"),
+                     arguments(list("name", "first", "nickname"), "name"),
+                     arguments(list("name", "first", "nickname"), "name.first"),
+                     arguments(list("name", "first"), "name.first"));
+  }
+
+  @ParameterizedTest(name = "{0} is not nor a child of {1}")
+  @MethodSource
+  void hierarchyMatches_should_return_false(List<String> fieldPath, String other) {
+    // GIVEN
+    FieldLocation field = new FieldLocation(fieldPath);
+    // WHEN
+    boolean result = field.hierarchyMatches(other);
+    // THEN
+    then(result).as("%s is not nor a child of %s", field, other).isFalse();
+  }
+
+  private static Stream<Arguments> hierarchyMatches_should_return_false() {
+    return Stream.of(arguments(list("person", "name"), "name"),
+                     arguments(list("names"), "name"),
+                     arguments(list("nickname"), "name"),
+                     arguments(list("name"), "nickname"),
+                     arguments(list("first", "nickname"), "name"));
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test.java
index dce1b20f8..66be76c7d 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test.java
@@ -149,7 +149,7 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test extend
     recursiveComparisonConfiguration.compareOnlyFieldsOfTypes(OptionalInt.class);
     recursiveComparisonConfiguration.compareOnlyFields("weight");
     // WHEN
-    compareRecursivelyFailsAsExpected(billie, anotherBillie);
+    AssertionError assertionError = compareRecursivelyFailsAsExpected(billie, anotherBillie);
     // THEN
     ComparisonDifference ageDifference = diff("age", billie.age, anotherBillie.age);
     ComparisonDifference weightDifference = diff("weight", billie.weight, anotherBillie.weight);
@@ -161,7 +161,7 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test extend
     // john and jill have the same age, that's the only field they have in common
     assertThat(john).usingRecursiveComparison()
                     .comparingOnlyFieldsOfTypes(String.class, OptionalInt.class) // name and age fields
-                    .ignoringFields("name")
+                    .ignoringFieldsMatchingRegexes("name", "neighbour")
                     .isEqualTo(jill);
   }
 
@@ -169,7 +169,7 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test extend
   void should_fail_when_combined_with_ignoringFields() {
     // GIVEN
     recursiveComparisonConfiguration.compareOnlyFieldsOfTypes(String.class, OptionalLong.class); // name and id fields
-    recursiveComparisonConfiguration.ignoreFields("id");
+    recursiveComparisonConfiguration.ignoreFields("id", "neighbour");
     // WHEN
     compareRecursivelyFailsAsExpected(john, jill);
     // THEN
@@ -181,7 +181,7 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test extend
   void should_pass_when_combined_with_ignoringFieldsMatchingRegexes() {
     assertThat(john).usingRecursiveComparison()
                     .comparingOnlyFieldsOfTypes(String.class, OptionalInt.class) // name and age fields
-                    .ignoringFieldsMatchingRegexes(".*ame")
+                    .ignoringFieldsMatchingRegexes(".*ame", ".*age")
                     .isEqualTo(jill);
   }
 
@@ -190,7 +190,7 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test extend
     // GIVEN
     // name, age and weight fields
     recursiveComparisonConfiguration.compareOnlyFieldsOfTypes(String.class, OptionalInt.class, OptionalDouble.class);
-    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("w..ght");
+    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("w..ght", "neighbour");
     // WHEN
     compareRecursivelyFailsAsExpected(john, jill);
     // THEN
@@ -204,6 +204,7 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test extend
     assertThat(john).usingRecursiveComparison()
                     .comparingOnlyFieldsOfTypes(String.class, OptionalInt.class) // name and age fields
                     .ignoringFieldsOfTypes(String.class)
+                    .ignoringFields("neighbour")
                     .isEqualTo(jill);
   }
 
@@ -218,4 +219,63 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFieldsOfTypes_Test extend
     ComparisonDifference weightDifference = diff("weight", billie.weight, anotherBillie.weight);
     verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(billie, anotherBillie, weightDifference);
   }
+
+  @Test
+  void succeeding_javadoc_example_should_pass() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock");
+    sherlock.home.address.number = 221;
+    Person moriarty = new Person("Moriarty");
+    moriarty.home.address.number = 221;
+    // WHEN/THEN
+    assertThat(sherlock).usingRecursiveComparison()
+                        .comparingOnlyFieldsOfTypes(Double.class, Integer.class)
+                        .isEqualTo(moriarty);
+  }
+
+  @Test
+  void failing_javadoc_example_should_fail() {
+    // GIVEN
+    Person sherlock = new Person("Sherlock");
+    sherlock.home.address.number = 221;
+    Person moriarty = new Person("Moriarty");
+    moriarty.home.address.number = 222;
+    recursiveComparisonConfiguration.compareOnlyFieldsOfTypes(Home.class);
+    // WHEN
+    compareRecursivelyFailsAsExpected(sherlock, moriarty);
+    // THEN
+    ComparisonDifference streetNumberDifference = diff("home.address.number", 221, 222);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(sherlock, moriarty, streetNumberDifference);
+
+  }
+
+  @Test
+  void should_compare_fields_of_specified_compared_types_even_if_parent_field_is_not_of_any_compared_types() {
+    // GIVEN
+    Dog lassie = new Dog(new Breed("Collie"));
+    Dog snoopy = new Dog(new Breed("Beagle"));
+    recursiveComparisonConfiguration.compareOnlyFieldsOfTypes(String.class);
+    // WHEN
+    compareRecursivelyFailsAsExpected(lassie, snoopy);
+    // THEN
+    ComparisonDifference weightDifference = diff("breed.name", lassie.breed.name, snoopy.breed.name);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(lassie, snoopy, weightDifference);
+  }
+
+  static class Dog {
+    Breed breed;
+
+    Dog(Breed breed) {
+      this.breed = breed;
+    }
+  }
+
+  static class Breed {
+    String name;
+
+    Breed(String name) {
+      this.name = name;
+    }
+  }
+
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
index 19a4b8ca2..9e38734db 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
 import static org.assertj.core.util.Lists.list;
 
 import java.util.Date;
@@ -20,6 +21,7 @@ import java.util.Set;
 
 import org.assertj.core.internal.objects.data.Person;
 import org.assertj.core.internal.objects.data.PersonDtoWithPersonNeighbour;
+import org.assertj.core.test.Employee;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -91,4 +93,26 @@ class RecursiveComparisonConfiguration_getActualFieldNamesToCompare_Test {
     // THEN
     then(fields).containsExactly("name");
   }
+
+  @Test
+  void should_return_all_fields_when_some_compared_types_are_specified_as_a_value_not_to_compare_could_have_a_field_to_compare() {
+    // GIVEN
+    Company microsoft = new Company(new Person("Bill"));
+    DualValue dualValue = new DualValue(rootFieldLocation(), microsoft, microsoft);
+    recursiveComparisonConfiguration.compareOnlyFieldsOfTypes(Person.class);
+    recursiveComparisonConfiguration.compareOnlyFields("ceo");
+    // WHEN
+    Set<String> fields = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
+    // THEN includes engineers in case any subfields of engineers is of a type to compare
+    then(fields).containsOnly("ceo", "engineers");
+  }
+
+  static class Company {
+    Person ceo;
+    Employee[] engineers;
+
+    public Company(Person ceo) {
+      this.ceo = ceo;
+    }
+  }
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_ignoreFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_ignoreFields_Test.java
new file mode 100644
index 000000000..b7291ef52
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_ignoreFields_Test.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+
+import java.util.Set;
+
+import org.junit.jupiter.api.Test;
+
+class RecursiveComparisonConfiguration_ignoreFields_Test {
+
+  @Test
+  void should_register_fields_path_to_ignore_without_duplicates() {
+    // GIVEN
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+    recursiveComparisonConfiguration.ignoreFields("foo", "bar", "foo.bar", "bar");
+    // WHEN
+    Set<String> fields = recursiveComparisonConfiguration.getIgnoredFields();
+    // THEN
+    then(fields).containsExactlyInAnyOrder("foo", "bar", "foo.bar");
+  }
+
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
index ac1302c6b..de297d121 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
@@ -26,9 +26,7 @@ import java.util.Optional;
 import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
-import java.util.Set;
 import java.util.UUID;
-import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.BeforeEach;
@@ -46,16 +44,6 @@ class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
     recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
   }
 
-  @Test
-  void should_register_fields_path_to_ignore_without_duplicates() {
-    // GIVEN
-    recursiveComparisonConfiguration.ignoreFields("foo", "bar", "foo.bar", "bar");
-    // WHEN
-    Set<String> fields = recursiveComparisonConfiguration.getIgnoredFields();
-    // THEN
-    then(fields).containsExactlyInAnyOrder("foo", "bar", "foo.bar");
-  }
-
   @ParameterizedTest(name = "{0} should be ignored")
   @MethodSource
   void should_ignore_actual_null_fields(DualValue dualValue) {
@@ -124,6 +112,9 @@ class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
 
   private static Stream<Arguments> should_ignore_specified_fields() {
     return Stream.of(arguments(dualValueWithPath("name"), list("name")),
+                     arguments(dualValueWithPath("name", "first"), list("name")),
+                     arguments(dualValueWithPath("name", "first", "nickname"), list("name")),
+                     arguments(dualValueWithPath("name", "first", "nickname"), list("name.first")),
                      arguments(dualValueWithPath("name"), list("foo", "name", "foo")),
                      arguments(dualValueWithPath("name", "first"), list("name.first")),
                      arguments(dualValueWithPath("name", "[2]", "first"), list("name.first")),
@@ -132,14 +123,24 @@ class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
                      arguments(dualValueWithPath("father", "name", "first"), list("father", "name.first", "father.name.first")));
   }
 
-  @Test
-  void ignoring_fields_with_regex_does_not_replace_previous_regexes() {
+  @ParameterizedTest(name = "{0} should not be ignored with these ignored fields {1}")
+  @MethodSource
+  void should_not_ignore_specified_fields(DualValue dualValue, List<String> ignoredFields) {
+    // GIVEN
+    recursiveComparisonConfiguration.ignoreFields(ignoredFields.toArray(new String[0]));
     // WHEN
-    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("foo");
-    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("bar", "baz");
+    boolean ignored = recursiveComparisonConfiguration.shouldIgnore(dualValue);
     // THEN
-    then(recursiveComparisonConfiguration.getIgnoredFieldsRegexes()).extracting(Pattern::pattern)
-                                                                    .containsExactlyInAnyOrder("foo", "bar", "baz");
+    then(ignored).as("%s should not be ignored with these ignored fields %s", dualValue, ignoredFields).isFalse();
+  }
+
+  private static Stream<Arguments> should_not_ignore_specified_fields() {
+    return Stream.of(arguments(dualValueWithPath("names"), list("name")),
+                     arguments(dualValueWithPath("nickname"), list("name")),
+                     arguments(dualValueWithPath("name"), list("nickname")),
+                     arguments(dualValueWithPath("name"), list("name.first")),
+                     arguments(dualValueWithPath("person", "name"), list("name")),
+                     arguments(dualValueWithPath("first", "nickname"), list("name")));
   }
 
   @ParameterizedTest(name = "{0} should be ignored with these regexes {1}")
@@ -156,6 +157,7 @@ class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
   private static Stream<Arguments> should_ignore_fields_matching_given_regexes() {
     return Stream.of(arguments(dualValueWithPath("name"), list(".*name")),
                      arguments(dualValueWithPath("name"), list("foo", "n.m.", "foo")),
+                     arguments(dualValueWithPath("name", "first"), list("name")),
                      arguments(dualValueWithPath("name", "first"), list("name\\.first")),
                      arguments(dualValueWithPath("name", "first"), list(".*first")),
                      arguments(dualValueWithPath("name", "first"), list("name.*")),
@@ -359,40 +361,14 @@ class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
     then(ignored).isTrue();
   }
 
-  @ParameterizedTest(name = "{0} should be compared: {1}")
-  @MethodSource
-  void should_honor_compared_fields(DualValue dualValue, boolean toCompare) {
-    // GIVEN
-    recursiveComparisonConfiguration.compareOnlyFields("number", "name", "address.street.geolocation", "person.children");
-    // WHEN
-    boolean shoudlBeCompared = !recursiveComparisonConfiguration.shouldIgnore(dualValue);
-    // THEN
-    then(shoudlBeCompared).as("%s should be %s", dualValue, toCompare ? "compared" : "ignored").isEqualTo(toCompare);
-  }
-
-  private static Stream<Arguments> should_honor_compared_fields() {
-    return Stream.of(arguments(dualValueWithPath("name"), true),
-                     arguments(dualValueWithPath("number"), true),
-                     arguments(dualValueWithPath("surname"), false),
-                     arguments(dualValueWithPath("name", "first"), true),
-                     arguments(dualValueWithPath("name", "last"), true),
-                     arguments(dualValueWithPath("address"), true),
-                     arguments(dualValueWithPath("address", "street"), true),
-                     arguments(dualValueWithPath("address", "street", "geolocation"), true),
-                     arguments(dualValueWithPath("street"), false),
-                     arguments(dualValueWithPath("street", "geolocation"), false),
-                     arguments(dualValueWithPath("person", "children", "[0]"), true),
-                     arguments(dualValueWithPath("address", "number"), false));
-  }
-
   @Test
   void should_treat_empty_compared_fields_as_not_restricting_comparison() {
     // GIVEN
     recursiveComparisonConfiguration.compareOnlyFields();
     // WHEN
-    boolean shoudlBeCompared = !recursiveComparisonConfiguration.shouldIgnore(dualValueWithPath("name"));
+    boolean shouldBeCompared = !recursiveComparisonConfiguration.shouldIgnore(dualValueWithPath("name"));
     // THEN
-    then(shoudlBeCompared).isTrue();
+    then(shouldBeCompared).isTrue();
   }
 
   static DualValue dualValue(Object value1, Object value2) {
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldNotEvaluate_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldNotEvaluate_Test.java
new file mode 100644
index 000000000..e342b59be
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldNotEvaluate_Test.java
@@ -0,0 +1,377 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static java.util.UUID.randomUUID;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.recursive.comparison.DualValueUtil.dualValueWithPath;
+import static org.assertj.core.api.recursive.comparison.DualValueUtil.randomPath;
+import static org.assertj.core.util.Lists.list;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.time.ZonedDateTime;
+import java.util.Date;
+import java.util.List;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
+import java.util.UUID;
+import java.util.regex.Pattern;
+import java.util.stream.Stream;
+
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.Person;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class RecursiveComparisonConfiguration_shouldNotEvaluate_Test {
+
+  private RecursiveComparisonConfiguration recursiveComparisonConfiguration;
+
+  @BeforeEach
+  void setup() {
+    recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+  }
+
+  @Test
+  void should_evaluate_all_fields_when_compared_types_are_specified_as_a_value_not_to_compare_could_have_a_field_to_compare() {
+    // GIVEN
+    recursiveComparisonConfiguration.compareOnlyFieldsOfTypes(Person.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue("ceo", new Employee()));
+    // THEN
+    then(ignored).isFalse();
+  }
+
+  @ParameterizedTest(name = "{0} should be not be evaluated")
+  @MethodSource
+  void should_not_evaluate_actual_null_fields(DualValue dualValue) {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).as("%s should not be evaluated", dualValue).isTrue();
+  }
+
+  private static Stream<Arguments> should_not_evaluate_actual_null_fields() {
+    return Stream.of(arguments(dualValue(null, "John")),
+                     arguments(dualValue(null, 123)),
+                     arguments(dualValue(null, null)),
+                     arguments(dualValue(null, new Date())));
+  }
+
+  @ParameterizedTest(name = "{0} should not be evaluated")
+  @MethodSource
+  void should_not_evaluate_actual_optional_empty_fields(DualValue dualValue) {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllActualEmptyOptionalFields(true);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).as("%s should not be evaluated", dualValue).isTrue();
+  }
+
+  private static Stream<Arguments> should_not_evaluate_actual_optional_empty_fields() {
+    return Stream.of(arguments(dualValue(Optional.empty(), "John")),
+                     arguments(dualValue(Optional.empty(), Optional.of("John"))),
+                     arguments(dualValue(OptionalInt.empty(), OptionalInt.of(123))),
+                     arguments(dualValue(OptionalLong.empty(), OptionalLong.of(123L))),
+                     arguments(dualValue(OptionalDouble.empty(), OptionalDouble.of(123.0))));
+  }
+
+  @ParameterizedTest(name = "{0} should not be evaluated")
+  @MethodSource
+  void should_not_evaluate_expected_null_fields(DualValue dualValue) {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).as("%s should not be evaluated", dualValue).isTrue();
+  }
+
+  private static Stream<Arguments> should_not_evaluate_expected_null_fields() {
+    return Stream.of(arguments(dualValue("John", null)),
+                     arguments(dualValue(123, null)),
+                     arguments(dualValue(null, null)),
+                     arguments(dualValue(new Date(), null)));
+  }
+
+  @ParameterizedTest(name = "{0} should be ignored with these ignored fields {1}")
+  @MethodSource
+  void should_not_evaluate_specified_fields(DualValue dualValue, List<String> ignoredFields) {
+    // GIVEN
+    recursiveComparisonConfiguration.ignoreFields(ignoredFields.toArray(new String[0]));
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).as("%s should be ignored with these ignored fields %s", dualValue, ignoredFields).isTrue();
+  }
+
+  private static Stream<Arguments> should_not_evaluate_specified_fields() {
+    return Stream.of(arguments(dualValueWithPath("name"), list("name")),
+                     arguments(dualValueWithPath("name"), list("foo", "name", "foo")),
+                     arguments(dualValueWithPath("name", "first"), list("name.first")),
+                     arguments(dualValueWithPath("name", "[2]", "first"), list("name.first")),
+                     arguments(dualValueWithPath("[0]", "first"), list("first")),
+                     arguments(dualValueWithPath("[1]", "first", "second"), list("first.second")),
+                     arguments(dualValueWithPath("father", "name", "first"), list("father", "name.first", "father.name.first")));
+  }
+
+  @Test
+  void ignoring_fields_with_regex_does_not_replace_previous_regexes() {
+    // WHEN
+    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("foo");
+    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("bar", "baz");
+    // THEN
+    then(recursiveComparisonConfiguration.getIgnoredFieldsRegexes()).extracting(Pattern::pattern)
+                                                                    .containsExactlyInAnyOrder("foo", "bar", "baz");
+  }
+
+  @ParameterizedTest(name = "{0} should be ignored with these regexes {1}")
+  @MethodSource
+  void should_not_evaluate_fields_matching_given_regexes(DualValue dualValue, List<String> regexes) {
+    // GIVEN
+    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes(regexes.toArray(new String[0]));
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).as("%s should be ignored with these regexes %s", dualValue, regexes).isTrue();
+  }
+
+  private static Stream<Arguments> should_not_evaluate_fields_matching_given_regexes() {
+    return Stream.of(arguments(dualValueWithPath("name"), list(".*name")),
+                     arguments(dualValueWithPath("name"), list("foo", "n.m.", "foo")),
+                     arguments(dualValueWithPath("name", "first"), list("name\\.first")),
+                     arguments(dualValueWithPath("name", "first"), list(".*first")),
+                     arguments(dualValueWithPath("name", "first"), list("name.*")),
+                     arguments(dualValueWithPath("name", "[2]", "first"), list("name\\.first")),
+                     arguments(dualValueWithPath("[0]", "first"), list("fir.*")),
+                     arguments(dualValueWithPath("[1]", "first", "second"), list("f..st\\..*nd")),
+                     arguments(dualValueWithPath("father", "name", "first"),
+                               list("father", "name.first", "father\\.name\\.first")));
+  }
+
+  @ParameterizedTest(name = "{0} should not be evaluated")
+  @MethodSource
+  void should_not_evaluate_fields(DualValue dualValue) {
+    // GIVEN
+    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes(".*name");
+    recursiveComparisonConfiguration.ignoreFields("number");
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(String.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).as("%s should not be evaluated", dualValue).isTrue();
+  }
+
+  private static Stream<Arguments> should_not_evaluate_fields() {
+    return Stream.of(arguments(dualValueWithPath("name")),
+                     arguments(dualValueWithPath("number")),
+                     arguments(dualValueWithPath("surname")),
+                     arguments(dualValueWithPath("first", "name")),
+                     arguments(new DualValue(randomPath(), "actual", "expected")));
+  }
+
+  @Test
+  void ignoring_fields_for_types_does_not_replace_previous_ignored_types() {
+    // WHEN
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(UUID.class);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(ZonedDateTime.class, String.class);
+    // THEN
+    then(recursiveComparisonConfiguration.getIgnoredTypes()).containsExactlyInAnyOrder(UUID.class, ZonedDateTime.class,
+                                                                                       String.class);
+  }
+
+  @ParameterizedTest(name = "{0} should be ignored with these ignored types {1}")
+  @MethodSource
+  void should_not_evaluate_fields_of_specified_types(DualValue dualValue, List<Class<?>> ignoredTypes) {
+    // GIVEN
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(ignoredTypes.toArray(new Class<?>[0]));
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).as("%s should be ignored with these ignored types %s", dualValue, ignoredTypes)
+                 .isTrue();
+  }
+
+  private static Stream<Arguments> should_not_evaluate_fields_of_specified_types() {
+    return Stream.of(arguments(new DualValue(randomPath(), "actual", "expected"), list(String.class)),
+                     arguments(new DualValue(randomPath(), randomUUID(), randomUUID()), list(String.class, UUID.class)));
+  }
+
+  @Test
+  void should_evaluate_field_if_its_type_is_not_ignored() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), "actual", "expected");
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(UUID.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isFalse();
+  }
+
+  @Test
+  void should_be_able_to_ignore_boolean() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), true, false);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(boolean.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  @Test
+  void should_be_able_to_ignore_byte() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), (byte) 0, (byte) 1);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(byte.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  @Test
+  void should_be_able_to_ignore_char() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), 'a', 'b');
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(char.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  @Test
+  void should_be_able_to_ignore_short() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), (short) 123, (short) 123);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(short.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  @Test
+  void should_be_able_to_ignore_int() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), 123, 123);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(int.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  @Test
+  void should_be_able_to_ignore_float() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), 123.0f, 123.0f);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(float.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  @Test
+  void should_be_able_to_ignore_double() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), 123.0, 123.0);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(double.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  @ParameterizedTest(name = "{0} should be ignored by specifying to ignore {1}")
+  @MethodSource
+  void should_be_able_to_ignore_primitive_field_by_specifying_their_wrapper_type(Object fieldValue, Class<?> wrapperType) {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), fieldValue, fieldValue);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(wrapperType);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  private static Stream<Arguments> should_be_able_to_ignore_primitive_field_by_specifying_their_wrapper_type() {
+    return Stream.of(arguments(false, Boolean.class),
+                     arguments((byte) 0, Byte.class),
+                     arguments('b', Character.class),
+                     arguments(123, Integer.class),
+                     arguments(123.0f, Float.class),
+                     arguments(123.0, Double.class),
+                     arguments((short) 123, Short.class));
+  }
+
+  @Test
+  void should_return_false_if_the_field_type_is_subtype_of_an_ignored_type() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), Double.MAX_VALUE, "expected");
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(Number.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isFalse();
+  }
+
+  @Test
+  void should_not_ignore_actual_null_fields_for_specified_types_if_strictTypeChecking_is_disabled() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), null, "expected");
+    recursiveComparisonConfiguration.strictTypeChecking(false);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(String.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isFalse();
+  }
+
+  @Test
+  void should_not_evaluate_actual_null_fields_for_specified_types_if_strictTypeChecking_is_enabled_and_expected_is_not_null() {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), null, "expected");
+    recursiveComparisonConfiguration.strictTypeChecking(true);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(String.class);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldNotEvaluate(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  @Test
+  void should_treat_empty_compared_fields_as_not_restricting_comparison() {
+    // GIVEN
+    recursiveComparisonConfiguration.compareOnlyFields();
+    // WHEN
+    boolean shouldBeCompared = !recursiveComparisonConfiguration.shouldNotEvaluate(dualValueWithPath("name"));
+    // THEN
+    then(shouldBeCompared).isTrue();
+  }
+
+  static DualValue dualValue(Object value1, Object value2) {
+    return new DualValue(randomPath(), value1, value2);
+  }
+
+}
