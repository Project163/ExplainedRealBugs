diff --git a/src/main/java/org/assertj/core/api/AbstractByteArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractByteArrayAssert.java
index 752bd8914..c6c75c235 100644
--- a/src/main/java/org/assertj/core/api/AbstractByteArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractByteArrayAssert.java
@@ -12,6 +12,9 @@
  */
 package org.assertj.core.api;
 
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.Hexadecimals.toHexString;
+
 import java.util.Comparator;
 
 import org.assertj.core.data.Index;
@@ -910,4 +913,30 @@ public abstract class AbstractByteArrayAssert<SELF extends AbstractByteArrayAsse
     return myself;
   }
 
+  /**
+   * Converts the actual byte array under test to an hexadecimal String and returns assertions for the computed String allowing String specific assertions from this call.
+   * <p>
+   * The Hex String representation is in upper case.
+   * <p>
+   * Example :
+   * <pre><code class='java'> byte[] bytes = new byte[] { -1, 0, 1 };
+   *
+   * // assertions will pass
+   * assertThat(bytes).asHexString()
+   *                  .startsWith("FF")
+   *                  .isEqualTo("FF0001");
+   *
+   * // assertion will fail
+   * assertThat(bytes).asHexString()
+   *                  .isEqualTo("FF0000");</code></pre>
+   *
+   * @return a String assertion object
+   *
+   * @since 3.16.0
+   */
+  @CheckReturnValue
+  public AbstractStringAssert<?> asHexString() {
+    objects.assertNotNull(info, actual);
+    return assertThat(toHexString(actual));
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/SoftProxies.java b/src/main/java/org/assertj/core/api/SoftProxies.java
index 5bd958b58..9d3bb5bbb 100644
--- a/src/main/java/org/assertj/core/api/SoftProxies.java
+++ b/src/main/java/org/assertj/core/api/SoftProxies.java
@@ -41,6 +41,7 @@ class SoftProxies {
 
   private static final Junction<MethodDescription> METHODS_CHANGING_THE_OBJECT_UNDER_TEST = methodsNamed("asInstanceOf").or(named("asList"))
                                                                                                                         .or(named("asString"))
+                                                                                                                        .or(named("asHexString"))
                                                                                                                         .or(named("decodedAsBase64"))
                                                                                                                         .or(named("extracting"))
                                                                                                                         .or(named("extractingByKey"))
diff --git a/src/main/java/org/assertj/core/util/Hexadecimals.java b/src/main/java/org/assertj/core/util/Hexadecimals.java
index c6d78fe20..12d7c3e9f 100644
--- a/src/main/java/org/assertj/core/util/Hexadecimals.java
+++ b/src/main/java/org/assertj/core/util/Hexadecimals.java
@@ -24,8 +24,13 @@ public class Hexadecimals {
     return new String(new char[] { HEX_ARRAY[v >>> 4], HEX_ARRAY[v & 0x0F] });
   }
 
-  private Hexadecimals() {
+  public static String toHexString(byte... bytes) {
+    StringBuilder stringBuilder = new StringBuilder();
+    for (byte b : bytes)
+      stringBuilder.append(byteToHexString(b));
 
+    return stringBuilder.toString();
   }
 
+  private Hexadecimals() {}
 }
diff --git a/src/test/java/org/assertj/core/api/bytearray/ByteArrayAssert_asHexString_Test.java b/src/test/java/org/assertj/core/api/bytearray/ByteArrayAssert_asHexString_Test.java
new file mode 100644
index 000000000..ea8388d16
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/bytearray/ByteArrayAssert_asHexString_Test.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.bytearray;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatCode;
+import static org.assertj.core.api.Assumptions.assumeThat;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.AssertionsUtil.expectAssumptionViolatedException;
+
+import org.assertj.core.api.SoftAssertions;
+import org.assertj.core.error.AssertJMultipleFailuresError;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.opentest4j.AssertionFailedError;
+
+/**
+ * Tests for <code>{@link org.assertj.core.api.ByteArrayAssert#asHexString()}</code>.
+ */
+@DisplayName("ByteArrayAssert asHexString")
+public class ByteArrayAssert_asHexString_Test {
+
+  private static final byte[] BYTES = new byte[] { -1, 0, 1 };
+
+  @Test
+  public void should_pass() {
+    // GIVEN
+    // WHEN / THEN
+    assertThat(BYTES).asHexString()
+                     .startsWith("FF")
+                     .isEqualTo("FF0001");
+  }
+
+  @Test
+  public void should_fail_if_actual_does_not_match() {
+    // GIVEN
+    byte[] actual = new byte[] { -1, 0, 1 };
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).asHexString().isEqualTo("010203"));
+    // THEN
+    assertThat(assertionError).hasMessageContainingAll("Expecting:",
+                                                       "<\"FF0001\">",
+                                                       "to be equal to:",
+                                                       "<\"010203\">",
+                                                       "but was not.")
+                              .isExactlyInstanceOf(AssertionFailedError.class);
+  }
+
+  @Test
+  public void should_pass_with_soft_assertions() {
+    // GIVEN
+    SoftAssertions softly = new SoftAssertions();
+    // WHEN / THEN
+    softly.assertThat(BYTES).asHexString().isEqualTo("FF0001");
+    softly.assertAll();
+  }
+
+  @Test
+  public void should_fail_with_soft_assertions_capturing_all_errors() {
+    // GIVEN
+    SoftAssertions softly = new SoftAssertions();
+    // WHEN
+    softly.assertThat(BYTES)
+          .asHexString()
+          .isEqualTo("010203")
+          .isBlank();
+    AssertionError assertionError = expectAssertionError(softly::assertAll);
+    // THEN
+    assertThat(assertionError).hasMessageContainingAll("Multiple Failures (2 failures)",
+                                                       "-- failure 1 --",
+                                                       "Expecting:",
+                                                       "<\"FF0001\">",
+                                                       "to be equal to:",
+                                                       "<\"010203\">",
+                                                       "but was not.",
+                                                       "-- failure 2 --",
+                                                       "Expecting blank but was:<\"FF0001\">")
+                              .isExactlyInstanceOf(AssertJMultipleFailuresError.class);
+  }
+
+  @Test
+  public void should_ignore_test_when_assumption_for_internally_created_hex_string_assertion_fails() {
+    expectAssumptionViolatedException(() -> assumeThat(BYTES).asHexString().isEqualTo("other"));
+  }
+
+  @Test
+  public void should_run_test_when_assumption_for_internally_created_string_passes() {
+    assertThatCode(() -> assumeThat(BYTES).asHexString().startsWith("FF")).doesNotThrowAnyException();
+  }
+
+}
