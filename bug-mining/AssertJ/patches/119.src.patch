diff --git a/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java b/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
index 01b4a833a..becc645fe 100644
--- a/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
+++ b/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
@@ -12,52 +12,83 @@
  */
 package org.assertj.core.extractor;
 
-import static java.lang.String.*;
+import static java.lang.String.format;
+
+import java.util.Map;
 
 import org.assertj.core.api.iterable.Extractor;
 import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.util.introspection.FieldSupport;
 import org.assertj.core.util.introspection.IntrospectionError;
 
-import java.util.Map;
-
 class ByNameSingleExtractor<T> implements Extractor<T, Object> {
+  private static final String SEPARATOR = ".";
+
   private final String propertyOrFieldName;
 
   ByNameSingleExtractor(String propertyOrFieldName) {
-	this.propertyOrFieldName = propertyOrFieldName;
+    this.propertyOrFieldName = propertyOrFieldName;
   }
 
   @Override
   public Object extract(T input) {
-	if (propertyOrFieldName == null)
-	  throw new IllegalArgumentException("The name of the field/property to read should not be null");
-	if (propertyOrFieldName.length() == 0)
-	  throw new IllegalArgumentException("The name of the field/property to read should not be empty");
-	if (input == null)
-	  throw new IllegalArgumentException("The object to extract field/property from should not be null");
-
-	// if input is a map, use propertyOrFieldName as a key
-	if (input instanceof Map) {
-	  Map<?, ?> map = (Map<?, ?>) input;
-	  return map.get(propertyOrFieldName);
-	}
-
-	// first try to get given property values from objects, then try properties
-	try {
-	  return PropertySupport.instance().propertyValueOf(propertyOrFieldName, Object.class, input);
-	} catch (IntrospectionError fieldIntrospectionError) {
-	  // no luck with properties, let's try fields
-	  try {
-		return FieldSupport.extraction().fieldValue(propertyOrFieldName, Object.class, input);
-	  } catch (IntrospectionError propertyIntrospectionError) {
-		// no field nor property found with given name, it is considered as an error
-		String message = format("%nCan't find any field or property with name '%s'.%nError when introspecting fields was :%n- %s %nError when introspecting properties was :%n- %s",
-		                        propertyOrFieldName, fieldIntrospectionError.getMessage(),
-		                        propertyIntrospectionError.getMessage());
-		throw new IntrospectionError(message);
-	  }
-	}
+    if (propertyOrFieldName == null)
+      throw new IllegalArgumentException("The name of the field/property to read should not be null");
+    if (propertyOrFieldName.length() == 0)
+      throw new IllegalArgumentException("The name of the field/property to read should not be empty");
+    if (input == null)
+      throw new IllegalArgumentException("The object to extract field/property from should not be null");
+
+    // if input is a map, use propertyOrFieldName as a key
+    if (input instanceof Map) {
+      Map<?, ?> map = (Map<?, ?>) input;
+      return map.get(propertyOrFieldName);
+    }
+
+    return extract(propertyOrFieldName, input);
+  }
+
+  private Object extract(String propertyOrFieldName, Object input) {
+    if (isNested(propertyOrFieldName)) {
+      String firstPropertyName = popNameFrom(propertyOrFieldName);
+      Object propertyOrFieldValue = extractValue(firstPropertyName, input);
+      // extract next sub-property/field value until reaching the last sub-property/field
+      return extract(nextNameFrom(propertyOrFieldName), propertyOrFieldValue);
+    }
+    return extractValue(propertyOrFieldName, input);
+  }
+
+  private Object extractValue(String propertyOrFieldName, Object input) {
+    // first try to get given property values from objects, then try fields
+    try {
+      return PropertySupport.instance().propertyValueOf(propertyOrFieldName, Object.class, input);
+    } catch (IntrospectionError fieldIntrospectionError) {
+      // no luck with properties, let's try fields
+      try {
+        return FieldSupport.extraction().fieldValue(propertyOrFieldName, Object.class, input);
+      } catch (IntrospectionError propertyIntrospectionError) {
+        // no field nor property found with given name, it is considered as an error
+        String message = format("%nCan't find any field or property with name '%s'.%nError when introspecting fields was :%n- %s %nError when introspecting properties was :%n- %s",
+                                propertyOrFieldName, fieldIntrospectionError.getMessage(),
+                                propertyIntrospectionError.getMessage());
+        throw new IntrospectionError(message);
+      }
+    }
+  }
+
+  private String popNameFrom(String propertyOrFieldNameChain) {
+    if (!isNested(propertyOrFieldNameChain)) return propertyOrFieldNameChain;
+    return propertyOrFieldNameChain.substring(0, propertyOrFieldNameChain.indexOf(SEPARATOR));
+  }
+
+  private String nextNameFrom(String propertyOrFieldNameChain) {
+    if (!isNested(propertyOrFieldNameChain)) return "";
+    return propertyOrFieldNameChain.substring(propertyOrFieldNameChain.indexOf(SEPARATOR) + 1);
   }
 
+  private boolean isNested(String propertyOrFieldName) {
+    return propertyOrFieldName.contains(SEPARATOR)
+           && !propertyOrFieldName.startsWith(SEPARATOR)
+           && !propertyOrFieldName.endsWith(SEPARATOR);
+  }
 }
diff --git a/src/test/java/org/assertj/core/extractor/ByNameSingleExtractorTest.java b/src/test/java/org/assertj/core/extractor/ByNameSingleExtractorTest.java
index 0e594b47c..2bb05b7d6 100644
--- a/src/test/java/org/assertj/core/extractor/ByNameSingleExtractorTest.java
+++ b/src/test/java/org/assertj/core/extractor/ByNameSingleExtractorTest.java
@@ -14,6 +14,7 @@ package org.assertj.core.extractor;
 
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.extractor.Extractors.byName;
 
 import java.util.HashMap;
 import java.util.List;
@@ -33,7 +34,7 @@ public class ByNameSingleExtractorTest {
   public ExpectedException thrown = ExpectedException.none();
 
   @Test
-  public void should_extract_field_values_even_if_property_exist() {
+  public void should_extract_field_values_even_if_property_does_not_exist() {
 	Object extractedValues = idExtractor().extract(yoda);
 
 	assertThat(extractedValues).isEqualTo(1L);
@@ -75,22 +76,21 @@ public class ByNameSingleExtractorTest {
   }
 
   @Test
-  public void should_fallback_to_field_if_exception_has_been_thrown_on_property_access() throws Exception {
+  public void should_fallback_to_field_if_exception_has_been_thrown_on_property_access() {
 	Object extractedValue = nameExtractor().extract(employeeWithBrokenName("Name"));
 
 	assertThat(extractedValue).isEqualTo(new Name("Name"));
   }
 
   @Test
-  public void should_prefer_properties_over_fields() throws Exception {
-	Object extractedValue = nameExtractor().extract(employeeWithOverriddenName("Overridden Name"));
+  public void should_prefer_properties_over_fields() {
+    Object extractedValue = nameExtractor().extract(employeeWithOverridenName("Overriden Name"));
 
-	assertThat(extractedValue).isEqualTo(new Name("Overridden Name"));
+    assertThat(extractedValue).isEqualTo(new Name("Overriden Name"));
   }
 
   @Test
-  public void should_throw_exception_if_property_cannot_be_extracted_due_to_runtime_exception_during_property_access()
-	  throws Exception {
+  public void should_throw_exception_if_property_cannot_be_extracted_due_to_runtime_exception_during_property_access() {
 	thrown.expect(IntrospectionError.class);
 
 	Employee employee = brokenEmployee();
@@ -98,7 +98,7 @@ public class ByNameSingleExtractorTest {
   }
 
   @Test
-  public void should_throw_exception_if_no_object_is_given() throws Exception {
+  public void should_throw_exception_if_no_object_is_given() {
 	thrown.expect(IllegalArgumentException.class);
 
 	idExtractor().extract(null);
@@ -125,6 +125,17 @@ public class ByNameSingleExtractorTest {
 	assertThat(maps).extracting("bad key").containsExactly(null, null);
   }
 
+  @Test
+  public void should_extract_property_field_combinations() {
+    Employee darth = new Employee(1L, new Name("Darth", "Vader"), 100);
+    Employee luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+    darth.field = luke;
+    luke.field = darth;
+    luke.surname = new Name("Young", "Padawan");
+    Object extracted = byName("me.field.me.field.me.field.surname.name").extract(darth);
+    assertThat(extracted).isEqualTo("Young Padawan");
+  }
+
   private Employee employeeWithBrokenName(String name) {
 	return new Employee(1L, new Name(name), 0) {
 	  @Override
@@ -134,11 +145,11 @@ public class ByNameSingleExtractorTest {
 	};
   }
 
-  private Employee employeeWithOverriddenName(final String overriddenName) {
+  private Employee employeeWithOverridenName(final String overridenName) {
 	return new Employee(1L, new Name("Name"), 0) {
 	  @Override
 	  public Name getName() {
-		return new Name(overriddenName);
+		return new Name(overridenName);
 	  }
 	};
   }
diff --git a/src/test/java/org/assertj/core/test/Employee.java b/src/test/java/org/assertj/core/test/Employee.java
index 479c8fb99..2b2bbc423 100644
--- a/src/test/java/org/assertj/core/test/Employee.java
+++ b/src/test/java/org/assertj/core/test/Employee.java
@@ -57,6 +57,12 @@ public class Employee {
   public boolean isAdult() {
     return age > 18;
   }
+  
+  // testing nested combinations of field/property
+  public Employee field;
+  public Employee getMe(){
+    return this;
+  }
 
   @Override
   public String toString() {
diff --git a/src/test/java/org/assertj/core/test/Name.java b/src/test/java/org/assertj/core/test/Name.java
index b9f91364f..8a34812f6 100644
--- a/src/test/java/org/assertj/core/test/Name.java
+++ b/src/test/java/org/assertj/core/test/Name.java
@@ -51,6 +51,11 @@ public class Name {
   public void setLast(String last) {
     this.last = last;
   }
+  
+  // property without field in order to test field/property combinations
+  public String getName(){
+    return String.format("%s %s", getFirst(), getLast());
+  }
 
   @Override
   public String toString() {
