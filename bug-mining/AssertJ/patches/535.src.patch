diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractAssert.java
index e5fa0468a..f3dcbd488 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractAssert.java
@@ -1091,7 +1091,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
   // this method is meant to be overridden and made public in subclasses that want to expose it
   // this would avoid duplicating this code in all subclasses
   protected RecursiveComparisonAssert<?> usingRecursiveComparison() {
-    return usingRecursiveComparison(new RecursiveComparisonConfiguration());
+    return usingRecursiveComparison(new RecursiveComparisonConfiguration(info.representation()));
   }
 
   // this method is meant to be overridden and made public in subclasses that want to expose it
diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 872196066..f7ee3dac3 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -2407,7 +2407,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    */
   @CheckReturnValue
   public SELF usingRecursiveFieldByFieldElementComparator() {
-    return usingRecursiveFieldByFieldElementComparator(new RecursiveComparisonConfiguration());
+    return usingRecursiveFieldByFieldElementComparator(new RecursiveComparisonConfiguration(info.representation()));
   }
 
   /**
diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 67f36a105..e06ef4d1a 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -2088,7 +2088,7 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
    */
   @CheckReturnValue
   public SELF usingRecursiveFieldByFieldElementComparator() {
-    return usingRecursiveFieldByFieldElementComparator(new RecursiveComparisonConfiguration());
+    return usingRecursiveFieldByFieldElementComparator(new RecursiveComparisonConfiguration(info.representation()));
   }
 
   /**
diff --git a/assertj-core/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
index 7e32ae422..858fb387b 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
@@ -2207,7 +2207,7 @@ public class AtomicReferenceArrayAssert<T>
    */
   @CheckReturnValue
   public AtomicReferenceArrayAssert<T> usingRecursiveFieldByFieldElementComparator() {
-    return usingRecursiveFieldByFieldElementComparator(new RecursiveComparisonConfiguration());
+    return usingRecursiveFieldByFieldElementComparator(new RecursiveComparisonConfiguration(info.representation()));
   }
 
   /**
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparator.java
index 991be3b3e..2f82e7425 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparator.java
@@ -37,8 +37,7 @@ public class RecursiveComparator implements Comparator<Object> {
    * @since 3.25.0
    */
   public RecursiveComparator() {
-    this.recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
-    this.recursiveComparisonDifferenceCalculator = new RecursiveComparisonDifferenceCalculator();
+    this(new RecursiveComparisonConfiguration());
   }
 
   /**
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 2bf055d60..75868b667 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -50,6 +50,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private static final boolean DEFAULT_IGNORE_ALL_OVERRIDDEN_EQUALS = true;
   public static final String INDENT_LEVEL_2 = "  -";
+  private final Representation representation;
   public static final DefaultRecursiveComparisonIntrospectionStrategy DEFAULT_RECURSIVE_COMPARISON_INTROSPECTION_STRATEGY = new DefaultRecursiveComparisonIntrospectionStrategy();
   private boolean strictTypeChecking = false;
 
@@ -115,10 +116,20 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     this.fieldMessages = builder.fieldMessages;
     this.typeMessages = builder.typeMessages;
     this.introspectionStrategy = builder.introspectionStrategy;
+    this.representation = builder.representation;
   }
 
-  public RecursiveComparisonConfiguration() {
+  public RecursiveComparisonConfiguration(Representation representation) {
     super();
+    this.representation = representation;
+  }
+
+  public RecursiveComparisonConfiguration() {
+    this(CONFIGURATION_PROVIDER.representation());
+  }
+
+  public Representation getRepresentation() {
+    return representation;
   }
 
   public boolean hasComparatorForField(String fieldName) {
@@ -437,7 +448,6 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * @throws NullPointerException if the given BiPredicate is null.
    * @since 3.17.0
    */
-  @SuppressWarnings("unchecked")
   public <T> void registerEqualsForType(BiPredicate<? super T, ? super T> equals, Class<T> type) {
     registerComparatorForType(toComparator(equals), type);
   }
@@ -1164,6 +1174,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
    * Builder to build {@link RecursiveComparisonConfiguration}.
    */
   public static final class Builder extends AbstractBuilder<Builder> {
+    private Representation representation;
     private boolean strictTypeChecking;
     private boolean ignoreAllActualNullFields;
     private boolean ignoreAllActualEmptyOptionalFields;
@@ -1188,6 +1199,17 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
       super(Builder.class);
     }
 
+    /**
+     * Sets the {@link Representation} used when formatting the differences.
+     *
+     * @param representation the {@link Representation} used when formatting the differences.
+     * @return this builder.
+     */
+    public Builder withRepresentation(Representation representation) {
+      this.representation = representation;
+      return this;
+    }
+
     /**
      * Sets whether the recursive comparison will check that actual's type is compatible with expected's type (the same applies for each field).
      * Compatible means that the expected's type is the same or a subclass of actual's type.
@@ -1398,7 +1420,6 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
      * @since 3.17.0
      * @throws NullPointerException if the given BiPredicate is null.
      */
-    @SuppressWarnings("unchecked")
     public <T> Builder withEqualsForType(BiPredicate<? super T, ? super T> equals, Class<T> type) {
       return withComparatorForType(toComparator(equals), type);
     }
@@ -1554,7 +1575,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     }
   }
 
-  @SuppressWarnings({ "rawtypes", "unchecked", "ComparatorMethodParameterNotUsed" })
+  @SuppressWarnings({ "rawtypes", "ComparatorMethodParameterNotUsed" })
   private static Comparator toComparator(BiPredicate equals) {
     requireNonNull(equals, "Expecting a non null BiPredicate");
     return (o1, o2) -> equals.test(o1, o2) ? 0 : 1;
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 0802fb138..4a8509ba3 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -199,6 +199,10 @@ public class RecursiveComparisonDifferenceCalculator {
 
       return null;
     }
+
+    String toStringOf(Object value) {
+      return recursiveComparisonConfiguration.getRepresentation().toStringOf(value);
+    }
   }
 
   /**
@@ -582,10 +586,10 @@ public class RecursiveComparisonDifferenceCalculator {
         if (!expectedElementMatched) expectedElementsNotFound.add(expectedElement);
       }
     }
-
     if (!expectedElementsNotFound.isEmpty()) {
       String unmatched = format("The following expected elements were not matched in the actual %s:%n  %s",
-                                actual.getClass().getSimpleName(), expectedElementsNotFound);
+                                actual.getClass().getSimpleName(),
+                                comparisonState.toStringOf(expectedElementsNotFound));
       comparisonState.addDifference(dualValue, unmatched);
       // TODO could improve the error by listing the actual elements not in expected but that would need
       // another double loop inverting actual and expected to find the actual elements not matched in expected
@@ -669,7 +673,7 @@ public class RecursiveComparisonDifferenceCalculator {
     expectedKeysNotFound.removeAll(actualMap.keySet());
     if (!expectedKeysNotFound.isEmpty()) {
       comparisonState.addDifference(dualValue, format("The following keys were not found in the actual map value:%n  %s",
-                                                      expectedKeysNotFound));
+                                                      comparisonState.toStringOf(expectedKeysNotFound)));
       return;
     }
     // actual and expected maps have the same keys, we need now to compare their values
@@ -878,7 +882,7 @@ public class RecursiveComparisonDifferenceCalculator {
     return false;
   }
 
-  @SuppressWarnings({ "rawtypes", "unchecked" })
+  @SuppressWarnings({ "rawtypes" })
   private static boolean areDualValueEqual(DualValue dualValue,
                                            RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     final String fieldName = dualValue.getConcatenatedPath();
diff --git a/assertj-core/src/test/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively_create_Test.java b/assertj-core/src/test/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively_create_Test.java
index 8372469b9..2bf31d6d7 100644
--- a/assertj-core/src/test/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively_create_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursively_create_Test.java
@@ -12,6 +12,21 @@
  */
 package org.assertj.core.error;
 
+import static java.lang.Integer.toHexString;
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
+import static org.assertj.core.error.ShouldBeEqualByComparingFieldByFieldRecursively.shouldBeEqualByComparingFieldByFieldRecursive;
+import static org.assertj.core.error.ShouldBeEqualByComparingFieldByFieldRecursively.shouldBeEqualByComparingFieldByFieldRecursively;
+import static org.assertj.core.internal.DeepDifference.determineDifferences;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.TreeMap;
+import java.util.TreeSet;
+
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCalculator;
@@ -24,21 +39,6 @@ import org.assertj.core.testkit.Jedi;
 import org.assertj.core.testkit.Name;
 import org.junit.jupiter.api.Test;
 
-import java.util.LinkedHashMap;
-import java.util.LinkedHashSet;
-import java.util.List;
-import java.util.TreeMap;
-import java.util.TreeSet;
-
-import static java.lang.Integer.toHexString;
-import static java.lang.String.format;
-import static org.assertj.core.api.BDDAssertions.then;
-import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
-import static org.assertj.core.error.ShouldBeEqualByComparingFieldByFieldRecursively.shouldBeEqualByComparingFieldByFieldRecursive;
-import static org.assertj.core.error.ShouldBeEqualByComparingFieldByFieldRecursively.shouldBeEqualByComparingFieldByFieldRecursively;
-import static org.assertj.core.internal.DeepDifference.determineDifferences;
-import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
-
 class ShouldBeEqualByComparingFieldByFieldRecursively_create_Test {
 
   private static final TextDescription TEST_DESCRIPTION = new TextDescription("Test");
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
index c660480f1..7f0e482a8 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -12,14 +12,39 @@
  */
 package org.assertj.tests.core.api.recursive.comparison;
 
-import com.fasterxml.jackson.databind.JsonNode;
-import com.fasterxml.jackson.databind.ObjectMapper;
-import com.google.common.base.Stopwatch;
+import static java.lang.String.format;
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.entry;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Maps.newHashMap;
+import static org.assertj.tests.core.api.recursive.comparison.ColorWithCode.RED;
+import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
+import static org.assertj.tests.core.testkit.Maps.mapOf;
+import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.io.IOException;
+import java.net.InetAddress;
+import java.nio.file.Path;
+import java.nio.file.Paths;
+import java.sql.Timestamp;
+import java.time.Duration;
+import java.util.Date;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.IntStream;
+import java.util.stream.Stream;
+import javax.xml.datatype.DatatypeFactory;
+
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCalculator;
 import org.assertj.core.internal.StandardComparisonStrategy;
-import org.assertj.core.presentation.StandardRepresentation;
 import org.assertj.core.util.DoubleComparator;
 import org.assertj.tests.core.api.recursive.data.AlwaysEqualPerson;
 import org.assertj.tests.core.api.recursive.data.FriendlyPerson;
@@ -32,33 +57,9 @@ import org.junit.jupiter.params.ParameterizedTest;
 import org.junit.jupiter.params.provider.Arguments;
 import org.junit.jupiter.params.provider.MethodSource;
 
-import javax.xml.datatype.DatatypeFactory;
-import java.io.IOException;
-import java.net.InetAddress;
-import java.nio.file.Path;
-import java.nio.file.Paths;
-import java.sql.Timestamp;
-import java.time.Duration;
-import java.util.Date;
-import java.util.List;
-import java.util.Map;
-import java.util.stream.IntStream;
-import java.util.stream.Stream;
-
-import static java.lang.String.format;
-import static java.util.stream.Collectors.toList;
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.BDDAssertions.entry;
-import static org.assertj.core.api.BDDAssertions.then;
-import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
-import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.assertj.core.util.Lists.list;
-import static org.assertj.core.util.Maps.newHashMap;
-import static org.assertj.tests.core.api.recursive.comparison.ColorWithCode.RED;
-import static org.assertj.tests.core.testkit.AlwaysEqualComparator.ALWAYS_EQUALS_STRING;
-import static org.assertj.tests.core.testkit.Maps.mapOf;
-import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
-import static org.junit.jupiter.params.provider.Arguments.arguments;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.common.base.Stopwatch;
 
 class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert_isEqualTo_BaseTest {
 
@@ -92,7 +93,7 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
     var assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison().isEqualTo(expected));
     // THEN
     var shouldBeEqual = shouldBeEqual(actual, null, StandardComparisonStrategy.instance(), info.representation());
-    var expectedAssertionError = shouldBeEqual.newAssertionError(null, StandardRepresentation.STANDARD_REPRESENTATION);
+    var expectedAssertionError = shouldBeEqual.newAssertionError(null, STANDARD_REPRESENTATION);
     then(assertionError).hasMessage(expectedAssertionError.getMessage());
   }
 
@@ -402,7 +403,7 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
     ComparisonDifference difference = diff("_children",
                                            mapOf(entry("importantValue", "10"), entry("someNotImportantValue", 1)),
                                            mapOf(entry("bar", "10"), entry("foo", 1)),
-                                           format("The following keys were not found in the actual map value:%n  [foo, bar]"));
+                                           format("The following keys were not found in the actual map value:%n  [\"foo\", \"bar\"]"));
     compareRecursivelyFailsWithDifferences(actual, expected, difference);
   }
 
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
index 456b3a856..09b3401d2 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
@@ -12,28 +12,30 @@
  */
 package org.assertj.tests.core.api.recursive.comparison;
 
-import org.assertj.core.api.recursive.comparison.ComparisonDifference;
-import org.assertj.tests.core.api.recursive.data.FriendlyPerson;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.Arguments;
-import org.junit.jupiter.params.provider.MethodSource;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Objects;
-import java.util.stream.Stream;
-
 import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.registerFormatterForType;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.tests.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.Type.FIRST;
 import static org.assertj.tests.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.Type.SECOND;
 import static org.assertj.tests.core.api.recursive.data.FriendlyPerson.friend;
+import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.ComparisonDifference;
+import org.assertj.tests.core.api.recursive.data.FriendlyPerson;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
 class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
     extends RecursiveComparisonAssert_isEqualTo_BaseTest {
 
@@ -531,4 +533,22 @@ class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
     }
   }
 
+  record Item(String name, int quantity) {
+  }
+
+  @Test
+  void should_honor_representation_in_unmatched_elements_when_comparing_iterables_ignoring_order() {
+    // GIVEN
+    List<Item> expectedItems = List.of(new Item("Shoes", 2), new Item("Pants", 3));
+    List<Item> actualItems = List.of(new Item("Pants", 3), new Item("Loafers", 1));
+    registerFormatterForType(Item.class, item -> String.format("Item(%s, %d)", item.name(), item.quantity()));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actualItems).usingRecursiveComparison()
+                                                                                      .ignoringCollectionOrder()
+                                                                                      .isEqualTo(expectedItems));
+    // THEN
+    then(assertionError).hasMessageContaining(format("The following expected elements were not matched in the actual List12:%n" +
+                                                     "  [Item(Shoes, 2)]"));
+  }
+
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
index 388ed8999..6351c8ae2 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
@@ -12,19 +12,6 @@
  */
 package org.assertj.tests.core.api.recursive.comparison;
 
-import org.assertj.core.api.recursive.comparison.ComparisonDifference;
-import org.assertj.core.groups.Tuple;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.Arguments;
-import org.junit.jupiter.params.provider.MethodSource;
-
-import java.util.Collection;
-import java.util.List;
-import java.util.Set;
-import java.util.UnknownFormatConversionException;
-import java.util.stream.Stream;
-
 import static com.google.common.collect.Sets.newHashSet;
 import static java.lang.String.format;
 import static java.util.Collections.emptyList;
@@ -32,12 +19,26 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.Assertions.tuple;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.registerFormatterForType;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
 import static org.assertj.tests.core.api.recursive.comparison.Author.authorsTreeSet;
 import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 
+import java.util.Collection;
+import java.util.List;
+import java.util.Set;
+import java.util.UnknownFormatConversionException;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.ComparisonDifference;
+import org.assertj.core.groups.Tuple;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
 class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends RecursiveComparisonAssert_isEqualTo_BaseTest
     implements PersonData {
 
@@ -184,7 +185,7 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends RecursiveC
                                                                                  .ignoringCollectionOrder()
                                                                                  .isEqualTo(expected));
     // THEN
-    then(assertionError).hasMessageContaining(format("The following expected elements were not matched in the actual ArrayList:%n  [bbb]"));
+    then(assertionError).hasMessageContaining(format("The following expected elements were not matched in the actual ArrayList:%n  [\"bbb\"]"));
   }
 
   // https://github.com/assertj/assertj/issues/2279
@@ -215,4 +216,20 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends RecursiveC
 
   }
 
+  record Item(String name, int quantity) {
+  }
+
+  @Test
+  void should_honor_representation_in_unmatched_elements_when_comparing_unordered_set() {
+    // GIVEN
+    Set<Item> expectedItems = newHashSet(new Item("Shoes", 2), new Item("Pants", 3));
+    Set<Item> actualItems = newHashSet(new Item("Pants", 3), new Item("Loafers", 1));
+    registerFormatterForType(Item.class, item -> String.format("Item(%s, %d)", item.name(), item.quantity()));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actualItems).usingRecursiveComparison()
+                                                                                      .isEqualTo(expectedItems));
+    // THEN
+    then(assertionError).hasMessageContaining(format("The following expected elements were not matched in the actual HashSet:%n" +
+                                                     "  [Item(Shoes, 2)]"));
+  }
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
index f8c7f8455..45543bc9c 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
@@ -19,6 +19,7 @@ import static java.util.Collections.singletonMap;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.registerFormatterForType;
 import static org.assertj.tests.core.testkit.Maps.mapOf;
 import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 
@@ -112,7 +113,7 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
     Map<String, Author> singletonGeorgeMartinMap = singletonMap(georgeMartin.name, georgeMartin);
     return Stream.of(Arguments.of(singletonPratchettMap, singletonGeorgeMartinMap, "map",
                                   singletonPratchettMap, singletonGeorgeMartinMap,
-                                  format("The following keys were not found in the actual map value:%n  [George Martin]")),
+                                  format("The following keys were not found in the actual map value:%n  [\"George Martin\"]")),
                      Arguments.of(nonSortedPratchettAndMartin, singletonPratchettMap, "map",
                                   nonSortedPratchettAndMartin, singletonPratchettMap,
                                   "actual and expected values are maps of different size, actual size=2 when expected size=1"),
@@ -126,7 +127,7 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
                                   none, pratchett, null),
                      Arguments.of(singletonPratchettMap, singletonMap(georgeMartin.name, pratchett), "map",
                                   singletonPratchettMap, singletonMap(georgeMartin.name, pratchett),
-                                  format("The following keys were not found in the actual map value:%n  [George Martin]")),
+                                  format("The following keys were not found in the actual map value:%n  [\"George Martin\"]")),
                      Arguments.of(singletonPratchettMap, empty, "map",
                                   singletonPratchettMap, empty,
                                   "actual and expected values are maps of different size, actual size=1 when expected size=0"));
@@ -152,7 +153,7 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
     // WHEN
     var assertionError = expectAssertionError(() -> assertThat(actual).usingRecursiveComparison().isEqualTo(expected));
     // THEN
-    then(assertionError).hasMessageContaining(format("The following keys were not found in the actual map value:%n  [c, d]"));
+    then(assertionError).hasMessageContaining(format("The following keys were not found in the actual map value:%n  [\"c\", \"d\"]"));
   }
 
   static Stream<Arguments> should_fail_when_comparing_map_to_non_map() {
@@ -165,4 +166,21 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
                      Arguments.of(none, mapOfTwoAuthors, "group", none, mapOfTwoAuthors, null));
   }
 
+  record Item(String name, int quantity) {
+  }
+
+  @Test
+  void should_honor_representation_in_unmatched_elements_when_comparing_unordered_iterables() {
+    // GIVEN
+    Map<String, Item> expectedItems = mapOf(entry("Shoes", new Item("Shoes", 2)), entry("Pants", new Item("Pants", 3)));
+    Map<String, Item> actualItems = mapOf(entry("Pants", new Item("Pants", 3)), entry("Hat", new Item("Hat", 1)));
+    registerFormatterForType(Item.class, item -> String.format("Item(%s, %d)", item.name(), item.quantity()));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actualItems).usingRecursiveComparison()
+                                                                                      .isEqualTo(expectedItems));
+    // THEN
+    then(assertionError).hasMessageContaining(format("The following keys were not found in the actual map value:%n" +
+                                                     "  [\"Shoes\"]"));
+  }
+
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/util/AssertionsUtil.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/util/AssertionsUtil.java
index cc7928244..c84090b48 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/util/AssertionsUtil.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/util/AssertionsUtil.java
@@ -12,25 +12,19 @@
  */
 package org.assertj.tests.core.util;
 
-import static java.nio.charset.Charset.forName;
-import static java.nio.charset.StandardCharsets.UTF_16;
-import static java.nio.charset.StandardCharsets.UTF_8;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.Assertions.catchThrowableOfType;
 
-import java.nio.charset.Charset;
 import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.assertj.core.api.ThrowableAssertAlternative;
 import org.junit.AssumptionViolatedException;
 
 public class AssertionsUtil {
 
-  public static final Charset TURKISH_CHARSET = forName("windows-1254");
-
   public static AssertionError expectAssertionError(ThrowingCallable shouldRaiseAssertionError) {
-    AssertionError error = catchThrowableOfType(shouldRaiseAssertionError, AssertionError.class);
+    AssertionError error = catchThrowableOfType(AssertionError.class, shouldRaiseAssertionError);
     assertThat(error).as("The code under test should have raised an AssertionError").isNotNull();
     return error;
   }
@@ -42,9 +36,4 @@ public class AssertionsUtil {
   public static void expectAssumptionNotMetException(ThrowingCallable shouldRaiseError) {
     assertThatThrownBy(shouldRaiseError).isInstanceOf(AssumptionViolatedException.class);
   }
-
-  public static Charset getDifferentCharsetFrom(Charset charset) {
-    return charset.equals(UTF_8) ? UTF_16 : UTF_8;
-  }
-
 }
