diff --git a/src/main/java/org/assertj/core/api/Java6BDDSoftAssertionsProvider.java b/src/main/java/org/assertj/core/api/Java6BDDSoftAssertionsProvider.java
index 22452cec7..f4d5e1592 100644
--- a/src/main/java/org/assertj/core/api/Java6BDDSoftAssertionsProvider.java
+++ b/src/main/java/org/assertj/core/api/Java6BDDSoftAssertionsProvider.java
@@ -15,6 +15,7 @@ package org.assertj.core.api;
 import static org.assertj.core.api.Assertions.catchThrowable;
 
 import java.io.File;
+import java.io.IOException;
 import java.io.InputStream;
 import java.math.BigDecimal;
 import java.math.BigInteger;
@@ -945,4 +946,112 @@ public interface Java6BDDSoftAssertionsProvider extends SoftAssertionsProvider {
     return proxy(UrlAssert.class, URL.class, actual);
   }
 
+  /**
+   * Entry point to check that an exception of type T is thrown by a given {@code throwingCallable}
+   * which allows to chain assertions on the thrown exception.
+   * <p>
+   * Example:
+   * <pre><code class='java'> softly.thenExceptionOfType(IOException.class)
+   *           .isThrownBy(() -&gt; { throw new IOException("boom!"); })
+   *           .withMessage("boom!"); </code></pre>
+   *
+   * This method is more or less the same of {@link #thenThrownBy(ThrowingCallable)} but in a more natural way.
+   *
+   * @param <T> the Throwable type.
+   * @param throwableType the Throwable type class.
+   * @return the created {@link ThrowableTypeAssert}.
+   * @since 3.23.0.
+   */
+  default <T extends Throwable> ThrowableTypeAssert<T> thenExceptionOfType(final Class<T> throwableType) {
+    return new SoftThrowableTypeAssert<>(throwableType, this);
+  }
+
+  /**
+   * Alias for {@link #thenExceptionOfType(Class)} for {@link RuntimeException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<RuntimeException> thenRuntimeException() {
+    return thenExceptionOfType(RuntimeException.class);
+  }
+
+  /**
+   * Alias for {@link #thenExceptionOfType(Class)} for {@link NullPointerException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<NullPointerException> thenNullPointerException() {
+    return thenExceptionOfType(NullPointerException.class);
+  }
+
+  /**
+   * Alias for {@link #thenExceptionOfType(Class)} for {@link IllegalArgumentException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<IllegalArgumentException> thenIllegalArgumentException() {
+    return thenExceptionOfType(IllegalArgumentException.class);
+  }
+
+  /**
+   * Alias for {@link #thenExceptionOfType(Class)} for {@link IOException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<IOException> thenIOException() {
+    return thenExceptionOfType(IOException.class);
+  }
+
+  /**
+   * Alias for {@link #thenExceptionOfType(Class)} for {@link IllegalStateException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<IllegalStateException> thenIllegalStateException() {
+    return thenExceptionOfType(IllegalStateException.class);
+  }
+
+  /**
+   * Alias for {@link #thenExceptionOfType(Class)} for {@link Exception}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<Exception> thenException() {
+    return thenExceptionOfType(Exception.class);
+  }
+
+  /**
+   * Alias for {@link #thenExceptionOfType(Class)} for {@link ReflectiveOperationException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<ReflectiveOperationException> thenReflectiveOperationException() {
+    return thenExceptionOfType(ReflectiveOperationException.class);
+  }
+
+  /**
+   * Alias for {@link #thenExceptionOfType(Class)} for {@link IndexOutOfBoundsException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<IndexOutOfBoundsException> thenIndexOutOfBoundsException() {
+    return thenExceptionOfType(IndexOutOfBoundsException.class);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/Java6StandardSoftAssertionsProvider.java b/src/main/java/org/assertj/core/api/Java6StandardSoftAssertionsProvider.java
index ac0fab6c9..51755dc3b 100644
--- a/src/main/java/org/assertj/core/api/Java6StandardSoftAssertionsProvider.java
+++ b/src/main/java/org/assertj/core/api/Java6StandardSoftAssertionsProvider.java
@@ -15,6 +15,7 @@ package org.assertj.core.api;
 import static org.assertj.core.api.Assertions.catchThrowable;
 
 import java.io.File;
+import java.io.IOException;
 import java.io.InputStream;
 import java.math.BigDecimal;
 import java.math.BigInteger;
@@ -928,4 +929,113 @@ public interface Java6StandardSoftAssertionsProvider extends SoftAssertionsProvi
   default AbstractUrlAssert<?> assertThat(URL actual) {
     return proxy(UrlAssert.class, URL.class, actual);
   }
+
+  /**
+   * Entry point to check that an exception of type T is thrown by a given {@code throwingCallable}
+   * which allows to chain assertions on the thrown exception.
+   * <p>
+   * Example:
+   * <pre><code class='java'> softly.assertThatExceptionOfType(IOException.class)
+   *           .isThrownBy(() -&gt; { throw new IOException("boom!"); })
+   *           .withMessage("boom!"); </code></pre>
+   *
+   * This method is more or less the same of {@link #assertThatThrownBy(ThrowingCallable)} but in a more natural way.
+   *
+   * @param <T> the Throwable type.
+   * @param throwableType the Throwable type class.
+   * @return the created {@link ThrowableTypeAssert}.
+   * @since 3.23.0.
+   */
+  default <T extends Throwable> ThrowableTypeAssert<T> assertThatExceptionOfType(final Class<T> throwableType) {
+    return new SoftThrowableTypeAssert<>(throwableType, this);
+  }
+
+  /**
+   * Alias for {@link #assertThatExceptionOfType(Class)} for {@link RuntimeException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<RuntimeException> assertThatRuntimeException() {
+    return assertThatExceptionOfType(RuntimeException.class);
+  }
+
+  /**
+   * Alias for {@link #assertThatExceptionOfType(Class)} for {@link NullPointerException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<NullPointerException> assertThatNullPointerException() {
+    return assertThatExceptionOfType(NullPointerException.class);
+  }
+
+  /**
+   * Alias for {@link #assertThatExceptionOfType(Class)} for {@link IllegalArgumentException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<IllegalArgumentException> assertThatIllegalArgumentException() {
+    return assertThatExceptionOfType(IllegalArgumentException.class);
+  }
+
+  /**
+   * Alias for {@link #assertThatExceptionOfType(Class)} for {@link IOException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<IOException> assertThatIOException() {
+    return assertThatExceptionOfType(IOException.class);
+  }
+
+  /**
+   * Alias for {@link #assertThatExceptionOfType(Class)} for {@link IllegalStateException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<IllegalStateException> assertThatIllegalStateException() {
+    return assertThatExceptionOfType(IllegalStateException.class);
+  }
+
+  /**
+   * Alias for {@link #assertThatExceptionOfType(Class)} for {@link Exception}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<Exception> assertThatException() {
+    return assertThatExceptionOfType(Exception.class);
+  }
+
+  /**
+   * Alias for {@link #assertThatExceptionOfType(Class)} for {@link ReflectiveOperationException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<ReflectiveOperationException> assertThatReflectiveOperationException() {
+    return assertThatExceptionOfType(ReflectiveOperationException.class);
+  }
+
+  /**
+   * Alias for {@link #assertThatExceptionOfType(Class)} for {@link IndexOutOfBoundsException}.
+   *
+   * @return the created {@link ThrowableTypeAssert}.
+   *
+   * @since 3.23.0
+   */
+  default ThrowableTypeAssert<IndexOutOfBoundsException> assertThatIndexOutOfBoundsException() {
+    return assertThatExceptionOfType(IndexOutOfBoundsException.class);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/SoftThrowableAssertAlternative.java b/src/main/java/org/assertj/core/api/SoftThrowableAssertAlternative.java
new file mode 100644
index 000000000..baec44eda
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/SoftThrowableAssertAlternative.java
@@ -0,0 +1,52 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import org.assertj.core.description.Description;
+
+/**
+ * {@link ThrowableAssertAlternative} subclass used in soft assertions.
+ * <p> 
+ * Assertion methods for {@link java.lang.Throwable} similar to {@link ThrowableAssert} but with assertions methods named
+ * differently to make testing code fluent (ex : <code>withMessage</code> instead of <code>hasMessage</code>.
+ * <pre><code class='java'> SoftAssertions softly = new SoftAssertions();
+ * 
+ * softly.assertThatExceptionOfType(IOException.class)
+ *           .isThrownBy(() -&gt; { throw new IOException("boom! tcha!"); });
+ *           .withMessage("boom! %s", "tcha!"); </code></pre>
+ *           
+ * This class is linked with the {@link ThrowableTypeAssert} and allow to check that an exception type is thrown by a lambda.
+ * 
+ * @since 3.23.0
+ */
+public class SoftThrowableAssertAlternative<ACTUAL extends Throwable> extends ThrowableAssertAlternative<ACTUAL> {
+
+  private final ThrowableAssert<ACTUAL> proxyedThrowableAssert;
+
+  @SuppressWarnings("unchecked")
+  public SoftThrowableAssertAlternative(final ACTUAL actual, SoftAssertionsProvider softAssertionsProvider) {
+    super(actual);
+    proxyedThrowableAssert = softAssertionsProvider.proxy(ThrowableAssert.class, Throwable.class, actual);
+  }
+
+  @Override
+  public SoftThrowableAssertAlternative<ACTUAL> as(Description description) {
+    super.as(description);
+    return this;
+  }
+
+  @Override
+  protected ThrowableAssert<ACTUAL> getDelegate() {
+    return proxyedThrowableAssert;
+  }
+}
diff --git a/src/main/java/org/assertj/core/api/SoftThrowableTypeAssert.java b/src/main/java/org/assertj/core/api/SoftThrowableTypeAssert.java
new file mode 100644
index 000000000..e3c32ec6c
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/SoftThrowableTypeAssert.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import org.assertj.core.description.Description;
+import org.assertj.core.util.CheckReturnValue;
+
+/**
+ * ThrowableTypeAssert for soft assertions.
+ * 
+ * @since 3.23.0
+ */
+public class SoftThrowableTypeAssert<T extends Throwable> extends ThrowableTypeAssert<T> {
+
+  private SoftAssertionsProvider softAssertionsProvider;
+
+  /**
+   * Default constructor.
+   *
+   * @param throwableType class representing the target (expected) exception
+   * @param softAssertionsProvider the soft assertion instance used later on to proxy {@link ThrowableAssert}
+   */
+  public SoftThrowableTypeAssert(final Class<? extends T> throwableType, SoftAssertionsProvider softAssertionsProvider) {
+    super(throwableType);
+    this.softAssertionsProvider = softAssertionsProvider;
+  }
+
+  @Override
+  protected ThrowableAssertAlternative<T> buildThrowableTypeAssert(T throwable) {
+    return new SoftThrowableAssertAlternative<>(throwable, softAssertionsProvider);
+  }
+
+  @Override
+  @CheckReturnValue
+  public SoftThrowableTypeAssert<T> describedAs(Description description) {
+    this.description = description;
+    return this;
+  }
+}
diff --git a/src/main/java/org/assertj/core/api/ThrowableAssertAlternative.java b/src/main/java/org/assertj/core/api/ThrowableAssertAlternative.java
index a6f08a4cd..1e0da1284 100644
--- a/src/main/java/org/assertj/core/api/ThrowableAssertAlternative.java
+++ b/src/main/java/org/assertj/core/api/ThrowableAssertAlternative.java
@@ -36,6 +36,15 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
     delegate = new ThrowableAssert<>(actual);
   }
 
+  protected ThrowableAssert<ACTUAL> getDelegate() {
+    return delegate;
+  }
+
+  @Override
+  public ThrowableAssertAlternative<ACTUAL> as(Description description) {
+    return super.as(description);
+  }
+
   /**
    * Verifies that the message of the actual {@code Throwable} is equal to the given one.
    * <p>
@@ -59,7 +68,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessage(String)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessage(String message) {
-    delegate.hasMessage(message);
+    getDelegate().hasMessage(message);
     return myself;
   }
 
@@ -87,7 +96,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessage(String)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessage(String message, Object... parameters) {
-    delegate.hasMessage(message, parameters);
+    getDelegate().hasMessage(message, parameters);
     return myself;
   }
 
@@ -126,7 +135,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasCause(Throwable)
    */
   public ThrowableAssertAlternative<ACTUAL> withCause(Throwable cause) {
-    delegate.hasCause(cause);
+    getDelegate().hasCause(cause);
     return myself;
   }
 
@@ -153,7 +162,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasNoCause()
    */
   public ThrowableAssertAlternative<ACTUAL> withNoCause() {
-    delegate.hasNoCause();
+    getDelegate().hasNoCause();
     return myself;
   }
 
@@ -180,7 +189,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageStartingWith(String)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageStartingWith(String description) {
-    delegate.hasMessageStartingWith(description);
+    getDelegate().hasMessageStartingWith(description);
     return myself;
   }
 
@@ -210,7 +219,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageStartingWith(String, Object...)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageStartingWith(String description, Object... parameters) {
-    delegate.hasMessageStartingWith(description, parameters);
+    getDelegate().hasMessageStartingWith(description, parameters);
     return myself;
   }
 
@@ -237,7 +246,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageContaining(String)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageContaining(String description) {
-    delegate.hasMessageContaining(description);
+    getDelegate().hasMessageContaining(description);
     return myself;
   }
 
@@ -267,7 +276,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageContaining(String, Object...)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageContaining(String description, Object... parameters) {
-    delegate.hasMessageContaining(description, parameters);
+    getDelegate().hasMessageContaining(description, parameters);
     return myself;
   }
 
@@ -294,7 +303,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageContainingAll(CharSequence...)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageContainingAll(CharSequence... values) {
-    delegate.hasMessageContainingAll(values);
+    getDelegate().hasMessageContainingAll(values);
     return myself;
   }
 
@@ -323,7 +332,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageNotContaining(String)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageNotContaining(String content) {
-    delegate.hasMessageNotContaining(content);
+    getDelegate().hasMessageNotContaining(content);
     return myself;
   }
 
@@ -352,7 +361,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageNotContainingAny(CharSequence...)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageNotContainingAny(CharSequence... values) {
-    delegate.hasMessageNotContainingAny(values);
+    getDelegate().hasMessageNotContainingAny(values);
     return myself;
   }
 
@@ -379,7 +388,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasStackTraceContaining(String)
    */
   public ThrowableAssertAlternative<ACTUAL> withStackTraceContaining(String description) {
-    delegate.hasStackTraceContaining(description);
+    getDelegate().hasStackTraceContaining(description);
     return myself;
   }
 
@@ -409,7 +418,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasStackTraceContaining(String, Object...)
    */
   public ThrowableAssertAlternative<ACTUAL> withStackTraceContaining(String description, Object... parameters) {
-    delegate.hasStackTraceContaining(description, parameters);
+    getDelegate().hasStackTraceContaining(description, parameters);
     return myself;
   }
 
@@ -437,7 +446,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageMatching(String)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageMatching(String regex) {
-    delegate.hasMessageMatching(regex);
+    getDelegate().hasMessageMatching(regex);
     return myself;
   }
 
@@ -464,7 +473,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageEndingWith(String)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageEndingWith(String description) {
-    delegate.hasMessageEndingWith(description);
+    getDelegate().hasMessageEndingWith(description);
     return myself;
   }
 
@@ -494,7 +503,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasMessageEndingWith(String, Object...)
    */
   public ThrowableAssertAlternative<ACTUAL> withMessageEndingWith(String description, Object... parameters) {
-    delegate.hasMessageEndingWith(description, parameters);
+    getDelegate().hasMessageEndingWith(description, parameters);
     return myself;
   }
 
@@ -526,7 +535,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasCauseInstanceOf(Class)
    */
   public ThrowableAssertAlternative<ACTUAL> withCauseInstanceOf(Class<? extends Throwable> type) {
-    delegate.hasCauseInstanceOf(type);
+    getDelegate().hasCauseInstanceOf(type);
     return myself;
   }
 
@@ -559,7 +568,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasCauseExactlyInstanceOf(Class)
    */
   public ThrowableAssertAlternative<ACTUAL> withCauseExactlyInstanceOf(Class<? extends Throwable> type) {
-    delegate.hasCauseExactlyInstanceOf(type);
+    getDelegate().hasCauseExactlyInstanceOf(type);
     return myself;
   }
 
@@ -593,7 +602,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasRootCauseInstanceOf(Class)
    */
   public ThrowableAssertAlternative<ACTUAL> withRootCauseInstanceOf(Class<? extends Throwable> type) {
-    delegate.hasRootCauseInstanceOf(type);
+    getDelegate().hasRootCauseInstanceOf(type);
     return myself;
   }
 
@@ -628,7 +637,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @see AbstractThrowableAssert#hasRootCauseExactlyInstanceOf(Class)
    */
   public ThrowableAssertAlternative<ACTUAL> withRootCauseExactlyInstanceOf(Class<? extends Throwable> type) {
-    delegate.hasRootCauseExactlyInstanceOf(type);
+    getDelegate().hasRootCauseExactlyInstanceOf(type);
     return myself;
   }
 
@@ -636,7 +645,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
   @Override
   @CheckReturnValue
   public ThrowableAssertAlternative<ACTUAL> describedAs(String description, Object... args) {
-    delegate.describedAs(description, args);
+    getDelegate().describedAs(description, args);
     return super.describedAs(description, args);
   }
 
@@ -644,7 +653,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
   @Override
   @CheckReturnValue
   public ThrowableAssertAlternative<ACTUAL> describedAs(Description description) {
-    delegate.describedAs(description);
+    getDelegate().describedAs(description);
     return super.describedAs(description);
   }
 
@@ -659,7 +668,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @since 3.16.0
    */
   public ThrowableAssertAlternative<?> havingCause() {
-    AbstractThrowableAssert<?, ?> causeAssert = delegate.cause();
+    AbstractThrowableAssert<?, ?> causeAssert = getDelegate().cause();
     return new ThrowableAssertAlternative<>(causeAssert.actual);
   }
 
@@ -674,7 +683,7 @@ public class ThrowableAssertAlternative<ACTUAL extends Throwable>
    * @since 3.16.0
    */
   public ThrowableAssertAlternative<?> havingRootCause() {
-    AbstractThrowableAssert<?, ?> rootCauseAssert = delegate.rootCause();
+    AbstractThrowableAssert<?, ?> rootCauseAssert = getDelegate().rootCause();
     return new ThrowableAssertAlternative<>(rootCauseAssert.actual);
   }
 
diff --git a/src/main/java/org/assertj/core/api/ThrowableTypeAssert.java b/src/main/java/org/assertj/core/api/ThrowableTypeAssert.java
index 1ab21e404..6b69bc7f8 100644
--- a/src/main/java/org/assertj/core/api/ThrowableTypeAssert.java
+++ b/src/main/java/org/assertj/core/api/ThrowableTypeAssert.java
@@ -59,8 +59,12 @@ public class ThrowableTypeAssert<T extends Throwable> implements Descriptable<Th
     Throwable throwable = ThrowableAssert.catchThrowable(throwingCallable);
     assertThat(throwable).as(description).hasBeenThrown().isInstanceOf(expectedThrowableType);
     @SuppressWarnings("unchecked")
-    T c = (T) throwable;
-    return new ThrowableAssertAlternative<>(c).as(description);
+    T castThrowable = (T) throwable;
+    return buildThrowableTypeAssert(castThrowable).as(description);
+  }
+
+  protected ThrowableAssertAlternative<T> buildThrowableTypeAssert(T throwable) {
+    return new ThrowableAssertAlternative<>(throwable);
   }
 
   /** {@inheritDoc} */
@@ -70,4 +74,5 @@ public class ThrowableTypeAssert<T extends Throwable> implements Descriptable<Th
     this.description = description;
     return this;
   }
+
 }
diff --git a/src/test/java/org/assertj/core/api/Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test.java b/src/test/java/org/assertj/core/api/Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test.java
index 572233032..3f27c50cb 100644
--- a/src/test/java/org/assertj/core/api/Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test.java
@@ -14,89 +14,121 @@ package org.assertj.core.api;
 
 import static java.util.Arrays.stream;
 import static java.util.stream.Collectors.toSet;
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
 
 import java.lang.reflect.Method;
 import java.util.List;
 import java.util.Set;
+import java.util.stream.Stream;
 
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * @author Filip Hrisafov
  */
 class Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test extends BaseAssertionsTest {
 
+  // Assertions - BDDAssertions sync tests
+
   @Test
   void standard_assertions_and_bdd_assertions_should_have_the_same_assertions_methods() {
+    // GIVEN
     Method[] assertThat_Assertions_methods = findMethodsWithName(Assertions.class, "assertThat");
     Method[] then_Assertions_methods = findMethodsWithName(BDDAssertions.class, "then");
-
-    assertThat(then_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_METHOD_NAME)
-                                       .containsExactlyInAnyOrder(assertThat_Assertions_methods);
+    // THEN
+    then(then_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_METHOD_NAME)
+                                 .containsExactlyInAnyOrder(assertThat_Assertions_methods);
   }
 
   @Test
-  void standard_assertions_and_with_assertions_should_have_the_same_assertions_methods() {
-    Method[] assertThat_Assertions_methods = findMethodsWithName(Assertions.class, "assertThat");
-    Method[] assertThat_WithAssertions_methods = findMethodsWithName(WithAssertions.class, "assertThat");
+  void standard_assertions_and_bdd_assertions_should_have_the_same_non_assertions_methods() {
+    // GIVEN
+    List<String> methodsToIgnore = list("failBecauseExceptionWasNotThrown", "filter", "offset");
+    Set<Method> non_assertThat_methods = non_assertThat_methodsOf(Assertions.class.getDeclaredMethods());
+    non_assertThat_methods = removeMethods(non_assertThat_methods, methodsToIgnore);
+    Set<Method> non_then_methods = non_then_methodsOf(BDDAssertions.class.getDeclaredMethods());
+    non_then_methods = removeMethods(non_then_methods, methodsToIgnore);
+    // THEN
+    then(non_then_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_METHOD_NAME)
+                          .containsExactlyInAnyOrderElementsOf(non_assertThat_methods);
+  }
 
-    assertThat(assertThat_WithAssertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_ONLY)
-                                                 .containsExactlyInAnyOrder(assertThat_Assertions_methods);
+  // Assertions - WithAssertions sync tests
+
+  @ParameterizedTest
+  @MethodSource("assertion_methods")
+  void standard_assertions_and_with_assertions_should_have_the_same_assertions_methods(String assertionMethod) {
+    // GIVEN
+    Method[] assertThat_Assertions_methods = findMethodsWithName(Assertions.class, assertionMethod);
+    Method[] assertThat_WithAssertions_methods = findMethodsWithName(WithAssertions.class, assertionMethod);
+    // THEN
+    then(assertThat_WithAssertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_ONLY)
+                                           .containsExactlyInAnyOrder(assertThat_Assertions_methods);
   }
 
   @Test
   void standard_assertions_and_with_assertions_should_have_the_same_non_assertions_methods() {
-
+    // GIVEN
     Set<Method> non_assertThat_Assertions_methods = non_assertThat_methodsOf(Assertions.class.getDeclaredMethods());
     Set<Method> non_assertThat_WithAssertions_methods = non_assertThat_methodsOf(WithAssertions.class.getDeclaredMethods());
-
-    assertThat(non_assertThat_WithAssertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_ONLY)
-                                                     .containsExactlyInAnyOrderElementsOf(non_assertThat_Assertions_methods);
+    // THEN
+    then(non_assertThat_WithAssertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_ONLY)
+                                               .containsExactlyInAnyOrderElementsOf(non_assertThat_Assertions_methods);
   }
 
-  @Test
-  void standard_assertions_and_bdd_assertions_should_have_the_same_non_assertions_methods() {
-
-    List<String> methodsToIgnore = list("failBecauseExceptionWasNotThrown", "filter", "offset");
-    Set<Method> non_assertThat_methods = non_assertThat_methodsOf(Assertions.class.getDeclaredMethods());
-    non_assertThat_methods = removeMethods(non_assertThat_methods, methodsToIgnore);
-    Set<Method> non_then_methods = non_then_methodsOf(BDDAssertions.class.getDeclaredMethods());
-    non_then_methods = removeMethods(non_then_methods, methodsToIgnore);
+  // Assertions - SoftAssertions sync tests
 
-    assertThat(non_then_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_METHOD_NAME)
-                                .containsExactlyInAnyOrderElementsOf(non_assertThat_methods);
+  @ParameterizedTest
+  @MethodSource("assertion_methods")
+  void standard_assertions_and_soft_assertions_should_have_the_same_assertions_methods(String assertionMethod) {
+    // GIVEN
+    Method[] assertThat_Assertions_methods = findMethodsWithName(Assertions.class, assertionMethod, SPECIAL_IGNORED_RETURN_TYPES);
+    Method[] assertThat_SoftAssertions_methods = findMethodsWithName(StandardSoftAssertionsProvider.class, assertionMethod);
+    // THEN
+    // ignore the return type of soft assertions until they have the same as the Assertions
+    then(assertThat_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_RETURN_TYPE)
+                                       .containsExactlyInAnyOrder(assertThat_SoftAssertions_methods);
   }
 
-  private static Set<Method> removeMethods(Set<Method> methods, List<String> methodsToRemove) {
-    return methods.stream()
-                  .filter(method -> !methodsToRemove.contains(method.getName()))
-                  .collect(toSet());
-  }
+  // BDDAssertions - BDDSoftAssertions sync tests
 
-  @Test
-  void standard_assertions_and_soft_assertions_should_have_the_same_assertions_methods() {
+  @ParameterizedTest
+  @MethodSource("bdd_assertion_methods")
+  void bdd_assertions_and_bdd_soft_assertions_should_have_the_same_assertions_methods(String assertionMethod) {
+    // GIVEN
     // Until the SpecialIgnoredReturnTypes like AssertProvider, XXXNavigableXXXAssert are implemented for
     // the soft assertions we need to ignore them
-    Method[] assertThat_Assertions_methods = findMethodsWithName(Assertions.class, "assertThat", SPECIAL_IGNORED_RETURN_TYPES);
-    Method[] assertThat_SoftAssertions_methods = findMethodsWithName(StandardSoftAssertionsProvider.class, "assertThat");
-
+    Method[] then_Assertions_methods = findMethodsWithName(BDDAssertions.class, assertionMethod, SPECIAL_IGNORED_RETURN_TYPES);
+    Method[] then_BDDSoftAssertions_methods = findMethodsWithName(BDDSoftAssertionsProvider.class, assertionMethod);
+    // THEN
     // ignore the return type of soft assertions until they have the same as the Assertions
-    assertThat(assertThat_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_RETURN_TYPE)
-                                             .containsExactlyInAnyOrder(assertThat_SoftAssertions_methods);
+    then(then_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_RETURN_TYPE)
+                                 .containsExactlyInAnyOrder(then_BDDSoftAssertions_methods);
   }
 
-  @Test
-  void bdd_assertions_and_bdd_soft_assertions_should_have_the_same_assertions_methods() {
-    // Until the SpecialIgnoredReturnTypes like AssertProvider, XXXNavigableXXXAssert are implemented for
-    // the soft assertions we need to ignore them
-    Method[] then_Assertions_methods = findMethodsWithName(BDDAssertions.class, "then", SPECIAL_IGNORED_RETURN_TYPES);
-    Method[] then_BDDSoftAssertions_methods = findMethodsWithName(BDDSoftAssertionsProvider.class, "then");
+  private static Stream<String> assertion_methods() {
+    return Stream.of("assertThat",
+                     "assertThatException",
+                     "assertThatRuntimeException",
+                     "assertThatNullPointerException",
+                     "assertThatIllegalArgumentException",
+                     "assertThatIOException",
+                     "assertThatIndexOutOfBoundsException",
+                     "assertThatReflectiveOperationException");
+  }
 
-    // ignore the return type of soft assertions until they have the same as the Assertions
-    assertThat(then_Assertions_methods).usingElementComparator(IGNORING_DECLARING_CLASS_AND_RETURN_TYPE)
-                                       .containsExactlyInAnyOrder(then_BDDSoftAssertions_methods);
+  private static Stream<String> bdd_assertion_methods() {
+    return Stream.of("then",
+                     "thenException",
+                     "thenRuntimeException",
+                     "thenNullPointerException",
+                     "thenIllegalArgumentException",
+                     "thenIOException",
+                     "thenIndexOutOfBoundsException",
+                     "thenReflectiveOperationException");
   }
 
   private static Set<Method> non_assertThat_methodsOf(Method[] declaredMethods) {
@@ -107,4 +139,10 @@ class Assertions_sync_assertThat_with_BDD_and_Soft_variants_Test extends BaseAss
     return stream(declaredMethods).filter(method -> !method.getName().startsWith("then")).collect(toSet());
   }
 
+  private static Set<Method> removeMethods(Set<Method> methods, List<String> methodsToRemove) {
+    return methods.stream()
+                  .filter(method -> !methodsToRemove.contains(method.getName()))
+                  .collect(toSet());
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/BDDSoftAssertions_ThrowableTypeAssert_Test.java b/src/test/java/org/assertj/core/api/BDDSoftAssertions_ThrowableTypeAssert_Test.java
new file mode 100644
index 000000000..2b65da604
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/BDDSoftAssertions_ThrowableTypeAssert_Test.java
@@ -0,0 +1,127 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.test.ThrowingCallableFactory.codeThrowing;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class BDDSoftAssertions_ThrowableTypeAssert_Test {
+
+  private BDDSoftAssertions softly;
+
+  @BeforeEach
+  void setup() {
+    softly = new BDDSoftAssertions();
+  }
+
+  @Test
+  void should_collect_errors_with_their_description() {
+    // GIVEN
+    ThrowingCallable codeThrowingRuntimeException = codeThrowing(new RuntimeException("boom"));
+    // WHEN
+    softly.thenExceptionOfType(RuntimeException.class)
+          .isThrownBy(codeThrowingRuntimeException)
+          .as("withMessage error 1")
+          .withMessage("bam")
+          .as("withMessage error 2")
+          .withMessage("bim");
+    // THEN
+    List<Throwable> errorsCollected = softly.errorsCollected();
+    then(errorsCollected).hasSize(2);
+    then(errorsCollected.get(0)).hasMessageContaining("withMessage error 1");
+    then(errorsCollected.get(1)).hasMessageContaining("withMessage error 2");
+  }
+
+  @ParameterizedTest(name = "[{index}] {0}")
+  @MethodSource("then_exception_methods")
+  void should_collect_errors_from_then_exception(SoftAssertionsFunction<?> assertionFunction, Throwable throwable) {
+    // GIVEN
+    ThrowingCallable codeThrowingThrowable = codeThrowing(throwable);
+    // WHEN
+    assertionFunction.apply(softly)
+                     .isThrownBy(codeThrowingThrowable)
+                     .withMessage("bam")
+                     .withMessage("bim");
+    // THEN
+    List<Throwable> errorsCollected = softly.errorsCollected();
+    then(errorsCollected).hasSize(2);
+    then(errorsCollected.get(0)).hasMessageContaining("bam");
+    then(errorsCollected.get(1)).hasMessageContaining("bim");
+  }
+
+  private static Stream<Arguments> then_exception_methods() {
+    return Stream.of(arguments(softAssertionFunction("thenExceptionOfType",
+                                                     softly -> softly.thenExceptionOfType(RuntimeException.class)),
+                               new NullPointerException("boom")),
+                     arguments(softAssertionFunction("thenRuntimeException",
+                                                     softly -> softly.thenRuntimeException()),
+                               new RuntimeException("boom")),
+                     arguments(softAssertionFunction("thenNullPointerException",
+                                                     softly -> softly.thenNullPointerException()),
+                               new NullPointerException("boom")),
+                     arguments(softAssertionFunction("thenIllegalArgumentException",
+                                                     softly -> softly.thenIllegalArgumentException()),
+                               new IllegalArgumentException("boom")),
+                     arguments(softAssertionFunction("thenIOException",
+                                                     softly -> softly.thenIOException()),
+                               new IOException("boom")),
+                     arguments(softAssertionFunction("thenIndexOutOfBoundsException",
+                                                     softly -> softly.thenIndexOutOfBoundsException()),
+                               new IndexOutOfBoundsException("boom")),
+                     arguments(softAssertionFunction("thenReflectiveOperationException",
+                                                     softly -> softly.thenReflectiveOperationException()),
+                               new ReflectiveOperationException("boom")));
+  }
+
+  private static <T extends Throwable> Function<BDDSoftAssertions, ThrowableTypeAssert<T>> softAssertionFunction(String assertionMethod,
+                                                                                                                 Function<BDDSoftAssertions, ThrowableTypeAssert<T>> softAssertionsFunction) {
+    return new SoftAssertionsFunction<>(assertionMethod, softAssertionsFunction);
+  }
+
+  // just here to get a nice toString for the ParameterizedTest display name
+  private static class SoftAssertionsFunction<T extends Throwable>
+      implements Function<BDDSoftAssertions, ThrowableTypeAssert<T>> {
+
+    private Function<BDDSoftAssertions, ThrowableTypeAssert<T>> function;
+    private String assertionMethod;
+
+    SoftAssertionsFunction(String assertionMethod, Function<BDDSoftAssertions, ThrowableTypeAssert<T>> softAssertionsFunction) {
+      this.function = softAssertionsFunction;
+      this.assertionMethod = assertionMethod;
+    }
+
+    @Override
+    public ThrowableTypeAssert<T> apply(BDDSoftAssertions softly) {
+      return function.apply(softly);
+    }
+
+    @Override
+    public String toString() {
+      return this.assertionMethod;
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/SoftAssertions_ThrowableTypeAssert_Test.java b/src/test/java/org/assertj/core/api/SoftAssertions_ThrowableTypeAssert_Test.java
new file mode 100644
index 000000000..5e70f0b54
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/SoftAssertions_ThrowableTypeAssert_Test.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2022 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.test.ThrowingCallableFactory.codeThrowing;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.function.Function;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class SoftAssertions_ThrowableTypeAssert_Test {
+
+  private SoftAssertions softly;
+
+  @BeforeEach
+  void setup() {
+    softly = new SoftAssertions();
+  }
+
+  @Test
+  void should_collect_errors_with_their_description() {
+    // GIVEN
+    ThrowingCallable codeThrowingRuntimeException = codeThrowing(new RuntimeException("boom"));
+    // WHEN
+    softly.assertThatExceptionOfType(RuntimeException.class)
+          .isThrownBy(codeThrowingRuntimeException)
+          .as("withMessage error 1")
+          .withMessage("bam")
+          .as("withMessage error 2")
+          .withMessage("bim");
+    // THEN
+    List<Throwable> errorsCollected = softly.errorsCollected();
+    then(errorsCollected).hasSize(2);
+    then(errorsCollected.get(0)).hasMessageContaining("withMessage error 1");
+    then(errorsCollected.get(1)).hasMessageContaining("withMessage error 2");
+  }
+
+  @ParameterizedTest(name = "[{index}] {0}")
+  @MethodSource("assertThat_exception_methods")
+  void should_collect_errors_from_assertThat_exception(SoftAssertionsFunction<?> assertionFunction, Throwable throwable) {
+    // GIVEN
+    ThrowingCallable codeThrowingThrowable = codeThrowing(throwable);
+    // WHEN
+    assertionFunction.apply(softly)
+                     .isThrownBy(codeThrowingThrowable)
+                     .withMessage("bam")
+                     .withMessage("bim");
+    // THEN
+    List<Throwable> errorsCollected = softly.errorsCollected();
+    then(errorsCollected).hasSize(2);
+    then(errorsCollected.get(0)).hasMessageContaining("bam");
+    then(errorsCollected.get(1)).hasMessageContaining("bim");
+  }
+
+  private static Stream<Arguments> assertThat_exception_methods() {
+    return Stream.of(arguments(softAssertionFunction("assertThatExceptionOfType",
+                                                     softly -> softly.assertThatExceptionOfType(RuntimeException.class)),
+                               new NullPointerException("boom")),
+                     arguments(softAssertionFunction("assertThatRuntimeException",
+                                                     softly -> softly.assertThatRuntimeException()),
+                               new RuntimeException("boom")),
+                     arguments(softAssertionFunction("assertThatNullPointerException",
+                                                     softly -> softly.assertThatNullPointerException()),
+                               new NullPointerException("boom")),
+                     arguments(softAssertionFunction("assertThatIllegalArgumentException",
+                                                     softly -> softly.assertThatIllegalArgumentException()),
+                               new IllegalArgumentException("boom")),
+                     arguments(softAssertionFunction("assertThatIOException",
+                                                     softly -> softly.assertThatIOException()),
+                               new IOException("boom")),
+                     arguments(softAssertionFunction("assertThatIndexOutOfBoundsException",
+                                                     softly -> softly.assertThatIndexOutOfBoundsException()),
+                               new IndexOutOfBoundsException("boom")),
+                     arguments(softAssertionFunction("assertThatReflectiveOperationException",
+                                                     softly -> softly.assertThatReflectiveOperationException()),
+                               new ReflectiveOperationException("boom")));
+  }
+
+  private static <T extends Throwable> Function<SoftAssertions, ThrowableTypeAssert<T>> softAssertionFunction(String assertionMethod,
+                                                                                                              Function<SoftAssertions, ThrowableTypeAssert<T>> softAssertionsFunction) {
+    return new SoftAssertionsFunction<>(assertionMethod, softAssertionsFunction);
+  }
+
+  // just here to get a nice toString for the ParameterizedTest display name
+  private static class SoftAssertionsFunction<T extends Throwable> implements Function<SoftAssertions, ThrowableTypeAssert<T>> {
+
+    private Function<SoftAssertions, ThrowableTypeAssert<T>> function;
+    private String assertionMethod;
+
+    SoftAssertionsFunction(String assertionMethod, Function<SoftAssertions, ThrowableTypeAssert<T>> softAssertionsFunction) {
+      this.function = softAssertionsFunction;
+      this.assertionMethod = assertionMethod;
+    }
+
+    @Override
+    public ThrowableTypeAssert<T> apply(SoftAssertions softly) {
+      return function.apply(softly);
+    }
+
+    @Override
+    public String toString() {
+      return this.assertionMethod;
+    }
+  }
+
+}
