diff --git a/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java b/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
index 688a95ed2..f18fc9739 100644
--- a/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
+++ b/src/main/java/org/assertj/core/api/AbstractSoftAssertions.java
@@ -21,64 +21,26 @@ import java.util.List;
 import org.assertj.core.error.AssertionErrorCreator;
 import org.assertj.core.internal.Failures;
 
-public abstract class AbstractSoftAssertions implements SoftAssertionsProvider, InstanceOfAssertFactories {
+public abstract class AbstractSoftAssertions extends DefaultAssertionErrorCollector
+    implements SoftAssertionsProvider, InstanceOfAssertFactories {
 
   protected final SoftProxies proxies;
 
   public AbstractSoftAssertions() {
-    // pass itself as a AfterAssertionErrorCollected instance
+    // pass itself as an AssertionErrorCollector instance
     proxies = new SoftProxies(this);
   }
 
-  /**
-   * Register a callback allowing to react after an {@link AssertionError} is collected by the current soft assertion.
-   * <p>
-   * The callback is an instance of {@link AfterAssertionErrorCollected} which can be expressed as lambda.
-   * <p>
-   * Example:
-   * <pre><code class='java'> SoftAssertions softly = new SoftAssertions();
-   * StringBuilder reportBuilder = new StringBuilder(format("Assertions report:%n"));
-  
-   * // register our callback
-   * softly.setAfterAssertionErrorCollected(error -&gt; reportBuilder.append(String.format("------------------%n%s%n", error.getMessage())));
-   *
-   * // the AssertionError corresponding to the failing assertions are registered in the report
-   * softly.assertThat("The Beatles").isEqualTo("The Rolling Stones");
-   * softly.assertThat(123).isEqualTo(123)
-   *                       .isEqualTo(456);</code></pre>
-   * <p>
-   * resulting {@code reportBuilder}:
-   * <pre><code class='java'> Assertions report:
-   * ------------------
-   * Expecting:
-   *  &lt;"The Beatles"&gt;
-   * to be equal to:
-   *  &lt;"The Rolling Stones"&gt;
-   * but was not.
-   * ------------------
-   * Expecting:
-   *  &lt;123&gt;
-   * to be equal to:
-   *  &lt;456&gt;
-   * but was not.</code></pre>
-   * <p>
-   * Alternatively, if you have defined your own SoftAssertions subclass and inherited from {@link AbstractSoftAssertions},
-   * the only thing you have to do is to override {@link AfterAssertionErrorCollected#onAssertionErrorCollected(AssertionError)}.
-   *
-   * @param afterAssertionErrorCollected the callback.
-   *
-   * @since 3.17.0
-   */
-  public void setAfterAssertionErrorCollected(AfterAssertionErrorCollected afterAssertionErrorCollected) {
-    proxies.setAfterAssertionErrorCollected(afterAssertionErrorCollected);
-  }
+  private static final AssertionErrorCreator ASSERTION_ERROR_CREATOR = new AssertionErrorCreator();
 
-  private final AssertionErrorCreator assertionErrorCreator = new AssertionErrorCreator();
+  public static void assertAll(AssertionErrorCollector collector) {
+    List<AssertionError> errors = collector.assertionErrorsCollected();
+    if (!errors.isEmpty()) throw ASSERTION_ERROR_CREATOR.multipleSoftAssertionsError(errors);
+  }
 
   @Override
   public void assertAll() {
-    List<AssertionError> errors = assertionErrorsCollected();
-    if (!errors.isEmpty()) throw assertionErrorCreator.multipleSoftAssertionsError(errors);
+    assertAll(this);
   }
 
   @Override
@@ -87,11 +49,6 @@ public abstract class AbstractSoftAssertions implements SoftAssertionsProvider,
     return proxies.createSoftAssertionProxy(assertClass, actualClass, actual);
   }
 
-  @Override
-  public void collectAssertionError(AssertionError error) {
-    proxies.collectError(error);
-  }
-
   /**
    * Fails with the given message.
    *
@@ -100,7 +57,7 @@ public abstract class AbstractSoftAssertions implements SoftAssertionsProvider,
    */
   public void fail(String failureMessage) {
     AssertionError error = Failures.instance().failure(failureMessage);
-    proxies.collectError(error);
+    collectAssertionError(error);
   }
 
   /**
@@ -112,7 +69,7 @@ public abstract class AbstractSoftAssertions implements SoftAssertionsProvider,
    */
   public void fail(String failureMessage, Object... args) {
     AssertionError error = Failures.instance().failure(format(failureMessage, args));
-    proxies.collectError(error);
+    collectAssertionError(error);
   }
 
   /**
@@ -125,7 +82,7 @@ public abstract class AbstractSoftAssertions implements SoftAssertionsProvider,
   public void fail(String failureMessage, Throwable realCause) {
     AssertionError error = Failures.instance().failure(failureMessage);
     error.initCause(realCause);
-    proxies.collectError(error);
+    collectAssertionError(error);
   }
 
   /**
@@ -154,16 +111,12 @@ public abstract class AbstractSoftAssertions implements SoftAssertionsProvider,
    */
   public void shouldHaveThrown(Class<? extends Throwable> throwableClass) {
     AssertionError error = Failures.instance().expectedThrowableNotThrown(throwableClass);
-    proxies.collectError(error);
+    collectAssertionError(error);
   }
 
-  /**
-   * Returns a copy of list of soft assertions collected errors.
-   * @return a copy of list of soft assertions collected errors.
-   */
   @Override
   public List<AssertionError> assertionErrorsCollected() {
-    return decorateErrorsCollected(proxies.errorsCollected());
+    return decorateErrorsCollected(super.assertionErrorsCollected());
   }
 
   /**
@@ -171,7 +124,7 @@ public abstract class AbstractSoftAssertions implements SoftAssertionsProvider,
    * @return a copy of list of soft assertions collected errors.
    */
   public List<Throwable> errorsCollected() {
-    return decorateErrorsCollected(proxies.errorsCollected());
+    return decorateErrorsCollected(super.assertionErrorsCollected());
   }
 
   /**
@@ -184,23 +137,6 @@ public abstract class AbstractSoftAssertions implements SoftAssertionsProvider,
     return addLineNumberToErrorMessages(errors);
   }
 
-  /**
-   * Returns the result of last soft assertion which can be used to decide what the next one should be.
-   * <p>
-   * Example:
-   * <pre><code class='java'> Person person = ...
-   * SoftAssertions soft = new SoftAssertions();
-   * if (soft.assertThat(person.getAddress()).isNotNull().wasSuccess()) {
-   *     soft.assertThat(person.getAddress().getStreet()).isNotNull();
-   * }</code></pre>
-   *
-   * @return true if the last assertion was a success.
-   */
-  @Override
-  public boolean wasSuccess() {
-    return proxies.wasSuccess();
-  }
-
   private <T extends Throwable> List<T> addLineNumberToErrorMessages(List<? extends T> errors) {
     return errors.stream()
                  .map(this::addLineNumberToErrorMessage)
diff --git a/src/main/java/org/assertj/core/api/AssertionErrorCollector.java b/src/main/java/org/assertj/core/api/AssertionErrorCollector.java
index 13db53bdd..608b85c53 100644
--- a/src/main/java/org/assertj/core/api/AssertionErrorCollector.java
+++ b/src/main/java/org/assertj/core/api/AssertionErrorCollector.java
@@ -13,16 +13,28 @@
 package org.assertj.core.api;
 
 import java.util.List;
+import java.util.Optional;
 
 public interface AssertionErrorCollector extends AfterAssertionErrorCollected {
 
   /**
-   * This method can be used to collect soft assertion errors.
+   * Optionally sets a "delegate" collector into which the collected assertions will be deposited.
    * <p>
-   * <b>Warning:</b> this is not the method used internally by AssertJ to collect all of them, overriding it to react to each
-   * collected assertion error will not work.
+   * Note that if you set a delegate, this instance will no longer collect or report assertion errors itself but will
+   * forward them all to the delegate for collection.
+   *
+   * @param delegate the {@link AssertionErrorCollector} to which the assertions will be forwarded.
+   */
+  default void setDelegate(AssertionErrorCollector delegate) {}
+
+  default Optional<AssertionErrorCollector> getDelegate() {
+    return Optional.empty();
+  }
+
+  /**
+   * This method can be used to collect soft assertion errors.
    * <p>
-   * To be able to react after an assertion error is collected, use @{@link #onAssertionErrorCollected(AssertionError)} instead.
+   * To be able to react after an assertion error is collected, use {@link #onAssertionErrorCollected(AssertionError)}.
    *
    * @param error the {@link AssertionError} to collect.
    */
@@ -34,4 +46,23 @@ public interface AssertionErrorCollector extends AfterAssertionErrorCollected {
   default void onAssertionErrorCollected(AssertionError assertionError) {
     // nothing by default
   }
+
+  /**
+   * Indicates/sets that the last assertion was a success.
+   */
+  void succeeded();
+
+  /**
+   * Returns the result of last soft assertion which can be used to decide what the next one should be.
+   * <p>
+   * Example:
+   * <pre><code class='java'> Person person = ...
+   * SoftAssertions soft = new SoftAssertions();
+   * if (soft.assertThat(person.getAddress()).isNotNull().wasSuccess()) {
+   *     soft.assertThat(person.getAddress().getStreet()).isNotNull();
+   * }</code></pre>
+   *
+   * @return true if the last assertion was a success.
+   */
+  boolean wasSuccess();
 }
diff --git a/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java b/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java
new file mode 100644
index 000000000..9e08f692a
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java
@@ -0,0 +1,129 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.util.Collections.synchronizedList;
+import static java.util.Collections.unmodifiableList;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+public class DefaultAssertionErrorCollector implements AssertionErrorCollector {
+
+  // Marking this field as volatile doesn't ensure complete thread safety
+  // (mutual exclusion, race-free behaviour), but guarantees eventual visibility
+  private volatile boolean wasSuccess = true;
+  private List<AssertionError> collectedAssertionErrors = synchronizedList(new ArrayList<>());
+
+  private AfterAssertionErrorCollected callback = this;
+
+  private AssertionErrorCollector delegate = null;
+
+  public DefaultAssertionErrorCollector() {
+    super();
+  }
+
+  // I think ideally, this would be set in the constructor and made final;
+  // however that would require a new constructor that would not make it
+  // backward compatible with existing SoftAssertionProvider implementations.
+  @Override
+  public void setDelegate(AssertionErrorCollector delegate) {
+    this.delegate = delegate;
+  }
+
+  @Override
+  public Optional<AssertionErrorCollector> getDelegate() {
+    return Optional.ofNullable(delegate);
+  }
+
+  @Override
+  public void collectAssertionError(AssertionError error) {
+    if (delegate == null) {
+      collectedAssertionErrors.add(error);
+      wasSuccess = false;
+    } else {
+      delegate.collectAssertionError(error);
+    }
+    callback.onAssertionErrorCollected(error);
+  }
+
+  /**
+   * Returns a list of soft assertions collected errors. If a delegate
+   * has been set (see {@link #setDelegate(AssertionErrorCollector) setDelegate()},
+   * then this method will return the result of the delegate's {@code assertErrorsCollected()}.
+   *
+   * @return A list of soft assertions collected errors.
+   */
+  @Override
+  public List<AssertionError> assertionErrorsCollected() {
+    return delegate != null ? delegate.assertionErrorsCollected() : unmodifiableList(collectedAssertionErrors);
+  }
+
+  /**
+   * Register a callback allowing to react after an {@link AssertionError} is collected by the current soft assertion.
+   * <p>
+   * The callback is an instance of {@link AfterAssertionErrorCollected} which can be expressed as lambda.
+   * <p>
+   * Example:
+   * <pre><code class='java'> SoftAssertions softly = new SoftAssertions();
+   * StringBuilder reportBuilder = new StringBuilder(format("Assertions report:%n"));
+  
+   * // register our callback
+   * softly.setAfterAssertionErrorCollected(error -&gt; reportBuilder.append(String.format("------------------%n%s%n", error.getMessage())));
+   *
+   * // the AssertionError corresponding to the failing assertions are registered in the report
+   * softly.assertThat("The Beatles").isEqualTo("The Rolling Stones");
+   * softly.assertThat(123).isEqualTo(123)
+   *                       .isEqualTo(456);</code></pre>
+   * <p>
+   * resulting {@code reportBuilder}:
+   * <pre><code class='java'> Assertions report:
+   * ------------------
+   * Expecting:
+   *  &lt;"The Beatles"&gt;
+   * to be equal to:
+   *  &lt;"The Rolling Stones"&gt;
+   * but was not.
+   * ------------------
+   * Expecting:
+   *  &lt;123&gt;
+   * to be equal to:
+   *  &lt;456&gt;
+   * but was not.</code></pre>
+   * <p>
+   * Alternatively, if you have defined your own SoftAssertions subclass and inherited from {@link AbstractSoftAssertions},
+   * the only thing you have to do is to override {@link AfterAssertionErrorCollected#onAssertionErrorCollected(AssertionError)}.
+   *
+   * @param afterAssertionErrorCollected the callback.
+   *
+   * @since 3.17.0
+   */
+  public void setAfterAssertionErrorCollected(AfterAssertionErrorCollected afterAssertionErrorCollected) {
+    callback = afterAssertionErrorCollected;
+  }
+
+  @Override
+  public void succeeded() {
+    if (delegate == null) {
+      wasSuccess = true;
+    } else {
+      delegate.succeeded();
+    }
+  }
+
+  @Override
+  public boolean wasSuccess() {
+    return delegate == null ? wasSuccess : delegate.wasSuccess();
+  }
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/ErrorCollector.java b/src/main/java/org/assertj/core/api/ErrorCollector.java
index 248f420cc..23a10aaf7 100644
--- a/src/main/java/org/assertj/core/api/ErrorCollector.java
+++ b/src/main/java/org/assertj/core/api/ErrorCollector.java
@@ -13,10 +13,7 @@
 package org.assertj.core.api;
 
 import java.lang.reflect.Method;
-import java.util.ArrayList;
 import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
 import java.util.concurrent.Callable;
 
 import net.bytebuddy.implementation.bind.annotation.FieldValue;
@@ -34,16 +31,10 @@ public class ErrorCollector {
   private static final String INTERCEPT_METHOD_NAME = "intercept";
   private static final String CLASS_NAME = ErrorCollector.class.getName();
 
-  // The list is synchronized in case errors arrive from more than a single thread.
-  // scope : the current softassertion object
-  private final List<AssertionError> errors = Collections.synchronizedList(new ArrayList<>());
-  // scope : the last assertion call (might be nested)
-  private final LastResult lastResult = new LastResult();
+  private AssertionErrorCollector assertionErrorCollector;
 
-  private AfterAssertionErrorCollected afterAssertionErrorCollected;
-
-  void setAfterAssertionErrorCollected(AfterAssertionErrorCollected afterAssertionErrorCollected) {
-    this.afterAssertionErrorCollected = afterAssertionErrorCollected;
+  ErrorCollector(AssertionErrorCollector collector) {
+    this.assertionErrorCollector = collector;
   }
 
   /**
@@ -63,10 +54,10 @@ public class ErrorCollector {
                                  @StubValue Object stub) throws Exception {
     try {
       Object result = proxy.call();
-      errorCollector.lastResult.setSuccess(true);
+      errorCollector.succeeded();
       return result;
     } catch (AssertionError assertionError) {
-      if (errorCollector.isNestedErrorCollectorProxyCall()) {
+      if (isNestedErrorCollectorProxyCall()) {
         // let the most outer call handle the assertion error
         throw assertionError;
       }
@@ -80,23 +71,15 @@ public class ErrorCollector {
     return assertion;
   }
 
-  void addError(AssertionError error) {
-    errors.add(error);
-    lastResult.setSuccess(false);
-    if (afterAssertionErrorCollected != null) {
-      afterAssertionErrorCollected.onAssertionErrorCollected(error);
-    }
+  private void addError(AssertionError error) {
+    assertionErrorCollector.collectAssertionError(error);
   }
 
-  public List<AssertionError> errors() {
-    return Collections.unmodifiableList(errors);
+  private void succeeded() {
+    assertionErrorCollector.succeeded();
   }
 
-  public boolean wasSuccess() {
-    return lastResult.wasSuccess();
-  }
-
-  private boolean isNestedErrorCollectorProxyCall() {
+  private static boolean isNestedErrorCollectorProxyCall() {
     return countErrorCollectorProxyCalls() > 1;
   }
 
@@ -106,43 +89,4 @@ public class ErrorCollector {
                                               && stackTraceElement.getMethodName().startsWith(INTERCEPT_METHOD_NAME))
                  .count();
   }
-
-  private static class LastResult {
-    // Marking these fields as volatile doesn't ensure complete thread safety
-    // (mutual exclusion, race-free behaviour), but guarantees eventual visibility
-    private volatile boolean wasSuccess = true;
-    private volatile boolean errorFound = false;
-
-    private boolean wasSuccess() {
-      return wasSuccess;
-    }
-
-    private void setSuccess(boolean success) {
-
-      // errorFound must be true if any nested call ends up in error
-      // Nested call Example : softly.assertThat(true).isFalse()
-      // call chain :
-      // -- softly.assertThat(true).isFalse()
-      // ----- proxied isFalse() -> calls isEqualTo(false) which is proxied
-      // ------- proxied isEqualTo(false) : catch AssertionError => last result success = false, back to outer call
-      // ---- proxied isFalse() : no AssertionError caught => last result success = true
-      errorFound |= !success;
-      wasSuccess = success;
-
-      if (resolvingOutermostErrorCollectorProxyNestedCall()) {
-        // need to reset errorFound for the next soft assertion
-        errorFound = false;
-      }
-    }
-
-    private boolean resolvingOutermostErrorCollectorProxyNestedCall() {
-      return countErrorCollectorProxyCalls() == 1;
-    }
-
-    @Override
-    public String toString() {
-      return String.format("LastResult [wasSuccess=%s, errorFound=%s]", wasSuccess, errorFound);
-    }
-
-  }
 }
diff --git a/src/main/java/org/assertj/core/api/SoftAssertionsProvider.java b/src/main/java/org/assertj/core/api/SoftAssertionsProvider.java
index f18b7e868..a5a9e6a09 100644
--- a/src/main/java/org/assertj/core/api/SoftAssertionsProvider.java
+++ b/src/main/java/org/assertj/core/api/SoftAssertionsProvider.java
@@ -60,20 +60,6 @@ public interface SoftAssertionsProvider extends AssertionErrorCollector {
     collector.assertionErrorsCollected().forEach(this::collectAssertionError);
   }
 
-  /**
-   * Returns the result of last soft assertion which can be used to decide what the next one should be.
-   * <p>
-   * Example :
-   * <pre><code class='java'> Person person = ...
-   * SoftAssertions soft = new SoftAssertions();
-   * if (soft.assertThat(person.getAddress()).isNotNull().wasSuccess()) {
-   *     soft.assertThat(person.getAddress().getStreet()).isNotNull();
-   * }</code></pre>
-   *
-   * @return true if the last assertion was a success.
-   */
-  boolean wasSuccess();
-
   /**
    * Catch and collect assertion errors coming from standard and <b>custom</b> assertions.
    * <p>
@@ -88,6 +74,7 @@ public interface SoftAssertionsProvider extends AssertionErrorCollector {
   default void check(ThrowingRunnable assertion) {
     try {
       assertion.run();
+      succeeded();
     } catch (AssertionError error) {
       collectAssertionError(error);
     } catch (RuntimeException runtimeException) {
diff --git a/src/main/java/org/assertj/core/api/SoftProxies.java b/src/main/java/org/assertj/core/api/SoftProxies.java
index cec4f62ac..73f31be2c 100644
--- a/src/main/java/org/assertj/core/api/SoftProxies.java
+++ b/src/main/java/org/assertj/core/api/SoftProxies.java
@@ -20,7 +20,6 @@ import static org.assertj.core.api.ClassLoadingStrategyFactory.classLoadingStrat
 
 import java.lang.reflect.Constructor;
 import java.lang.reflect.InvocationTargetException;
-import java.util.List;
 
 import org.assertj.core.api.ClassLoadingStrategyFactory.ClassLoadingStrategyPair;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
@@ -98,25 +97,8 @@ class SoftProxies {
 
   private ErrorCollector collector;
 
-  public SoftProxies(AfterAssertionErrorCollected afterAssertionErrorCollected) {
-    collector = new ErrorCollector();
-    setAfterAssertionErrorCollected(afterAssertionErrorCollected);
-  }
-
-  void setAfterAssertionErrorCollected(AfterAssertionErrorCollected afterAssertionErrorCollected) {
-    collector.setAfterAssertionErrorCollected(afterAssertionErrorCollected);
-  }
-
-  public boolean wasSuccess() {
-    return collector.wasSuccess();
-  }
-
-  void collectError(AssertionError error) {
-    collector.addError(error);
-  }
-
-  List<AssertionError> errorsCollected() {
-    return collector.errors();
+  public SoftProxies(AssertionErrorCollector assertionErrorCollector) {
+    collector = new ErrorCollector(assertionErrorCollector);
   }
 
   <SELF extends Assert<? extends SELF, ? extends ACTUAL>, ACTUAL> SELF createSoftAssertionProxy(Class<SELF> assertClass,
diff --git a/src/main/java/org/assertj/core/api/junit/jupiter/InjectSoftAssertions.java b/src/main/java/org/assertj/core/api/junit/jupiter/InjectSoftAssertions.java
new file mode 100644
index 000000000..fd6b62c34
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/junit/jupiter/InjectSoftAssertions.java
@@ -0,0 +1,33 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import static java.lang.annotation.ElementType.FIELD;
+import static java.lang.annotation.RetentionPolicy.RUNTIME;
+
+import java.lang.annotation.Retention;
+import java.lang.annotation.Target;
+
+import org.assertj.core.api.BDDSoftAssertions;
+import org.assertj.core.api.SoftAssertions;
+import org.assertj.core.api.SoftAssertionsProvider;
+
+/**
+ * Annotation used with {@link SoftAssertionsExtension} for specify wich test instance fields should be initialised with
+ * a {@link SoftAssertionsProvider} concrete implementation, for example {@link SoftAssertions}, {@link BDDSoftAssertions} or any
+ * custom soft assertions class.
+ */
+@Retention(RUNTIME)
+@Target(FIELD)
+public @interface InjectSoftAssertions {
+}
diff --git a/src/main/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension.java b/src/main/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension.java
index fe462f565..b2f5e7389 100644
--- a/src/main/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension.java
+++ b/src/main/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension.java
@@ -14,58 +14,90 @@ package org.assertj.core.api.junit.jupiter;
 
 import static java.lang.String.format;
 import static java.lang.reflect.Modifier.isAbstract;
+import static org.junit.platform.commons.support.AnnotationSupport.findAnnotation;
 import static org.junit.platform.commons.support.AnnotationSupport.isAnnotated;
+import static org.junit.platform.commons.support.ReflectionSupport.findFields;
 
 import java.lang.reflect.Executable;
+import java.lang.reflect.Field;
 import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
 import java.lang.reflect.Parameter;
+import java.util.Collection;
+import java.util.List;
 import java.util.Optional;
+import java.util.concurrent.ConcurrentLinkedQueue;
 
+import org.assertj.core.annotations.Beta;
+import org.assertj.core.api.AbstractSoftAssertions;
+import org.assertj.core.api.AssertionErrorCollector;
 import org.assertj.core.api.BDDSoftAssertions;
+import org.assertj.core.api.DefaultAssertionErrorCollector;
 import org.assertj.core.api.SoftAssertions;
 import org.assertj.core.api.SoftAssertionsProvider;
+import org.junit.jupiter.api.TestInstance.Lifecycle;
 import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
+import org.junit.jupiter.api.extension.BeforeEachCallback;
+import org.junit.jupiter.api.extension.ExtensionConfigurationException;
 import org.junit.jupiter.api.extension.ExtensionContext;
 import org.junit.jupiter.api.extension.ExtensionContext.Namespace;
 import org.junit.jupiter.api.extension.ExtensionContext.Store;
 import org.junit.jupiter.api.extension.ParameterContext;
 import org.junit.jupiter.api.extension.ParameterResolutionException;
 import org.junit.jupiter.api.extension.ParameterResolver;
+import org.junit.jupiter.api.extension.TestInstancePostProcessor;
+import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.ExecutionMode;
 import org.junit.platform.commons.annotation.Testable;
+import org.junit.platform.commons.support.HierarchyTraversalMode;
 import org.junit.platform.commons.support.ReflectionSupport;
 
 /**
- * Extension for JUnit Jupiter that provides support for injecting a concrete
- * implementation of {@link SoftAssertionsProvider} into test methods. Two examples that
- * come packaged with AssertJ are {@link SoftAssertions} and
- * {@link BDDSoftAssertions}, but custom implementations are also supported as
- * long as they have a default constructor.
+ * Extension for JUnit Jupiter that provides support for injecting a concrete implementation of {@link SoftAssertionsProvider}
+ * into test methods and (since 3.18.0) into test fields annotated with {@code @InjectSoftAssertions}.
+ * <p>
+ * Two examples of {@code SoftAssertionsProvider}s that come packaged with AssertJ are {@link SoftAssertions} and
+ * {@link BDDSoftAssertions}, but custom implementations are also supported as long as they are non-abstract and have a default
+ * constructor.
  *
  * <h2>Applicability</h2>
  *
  * <p>
- * In this context, the term "test method" refers to any method annotated with
- * {@code @Test}, {@code @RepeatedTest}, {@code @ParameterizedTest},
- * {@code @TestFactory}, or {@code @TestTemplate}.<br>
- * This extension does not inject {@code SoftAssertionsProvider} arguments into test
- * constructors or lifecycle methods.
+ * In this context, the term "test method" refers to any method annotated with {@code @Test}, {@code @RepeatedTest},
+ * {@code @ParameterizedTest}, {@code @TestFactory}, or {@code @TestTemplate}.<br>
+ * This extension does not inject {@code SoftAssertionsProvider} arguments into test constructors or lifecycle methods.
  *
  * <h2>Scope</h2>
  *
- * <p>
- * The scope of the {@code SoftAssertionsProvider} instance managed by this extension
- * begins when a parameter of type {@code SoftAssertionsProvider} is resolved for a test
- * method.<br>
- * The scope of the instance ends after the test method has been executed, this
- * is when {@code assertAll()} will be invoked on the instance to verify that no
- * soft assertions failed.
+ * Annotated {@code SoftAssertionsProvider} fields become valid from the `@BeforeEach` lifecycle phase.
+ * For parameters, they become are valid when the parameter is resolved.<br>
+ * In the {@code afterTestExecution} phase (immediately after the test has returned, but before the {@code AfterEach} phase, all
+ * collected errors (if any) will wrapped in a single multiple-failures error.<br>
+ * All {@code SoftAssertionsProvider} instances (fields &amp; parameters) created within the scope of the same test method
+ * (including its {@code BeforeEach} phase) will share the same state object to collect the failed assertions, so that all
+ * assertion failures from all {@link SoftAssertionsProvider}s will be reported in the order that they failed.
+ *
+ * <h2>Integration with third-party extensions</h2>
  *
- * <h3>Example with {@code SoftAssertions}</h3>
+ * Sometimes a third-party extension may wish to softly assert something as part of the main test. Or sometimes a third-party
+ * extension may be a wrapper around another assertion library (eg, Mockito) and it would be nice for that library's soft
+ * assertions to mix well with AssertJ's. This can be achieved through the use of the {@code SoftAssertionExtension}'s API.
+ * Calling {@link #getAssertionErrorCollector(ExtensionContext)} will return a handle to the error collector used for the current
+ * context into which a third-party extension can directly store its assertion failures. Alternatively, calling
+ * {@link #getSoftAssertionsProvider(ExtensionContext, Class) getSoftAssertionsProvider()} will instantiate a
+ * {@link SoftAssertionsProvider} for the given context that can then be used to make assertions.
+ *
+ * <h2>Examples</h2>
+ *
+ * <h3>Example parameter injection</h3>
  *
  * <pre>
  * <code class='java'> {@literal @}ExtendWith(SoftAssertionsExtension.class)
  * class ExampleTestCase {
  *
+ *    {@literal @}InjectSoftAssertions
+ *    BDDSoftAssertions bdd;
+ *
  *    {@literal @}Test
  *    void multipleFailures(SoftAssertions softly) {
  *       softly.assertThat(2 * 3).isEqualTo(0);
@@ -75,28 +107,181 @@ import org.junit.platform.commons.support.ReflectionSupport;
  * }</code>
  * </pre>
  *
- * <h3>Example with {@code BDDSoftAssertions}</h3>
+ * <h3>Example field injection</h3>
+ * <pre><code> {@literal @}ExtendWith(SoftlyExtension.class)
+ * public class SoftlyExtensionExample {
+ *
+ *   // initialized by the SoftlyExtension extension
+ *   {@literal @}InjectSoftAssertions
+ *   private SoftAssertions soft;
+ *
+ *   {@literal @}Test
+ *   public void chained_soft_assertions_example() {
+ *     String name = "Michael Jordan - Bulls";
+ *     soft.assertThat(name)
+ *         .startsWith("Mi")
+ *         .contains("Bulls");
+ *     // no need to call softly.assertAll(), this is done by the extension
+ *   }
+ *
+ *   // nested classes test work too
+ *   {@literal @}Nested
+ *   class NestedExample {
+ *
+ *     {@literal @}Test
+ *     public void football_assertions_example() {
+ *       String kylian = "Kylian Mbapp√©";
+ *       soft.assertThat(kylian)
+ *           .startsWith("Ky")
+ *           .contains("bap");
+ *       // no need to call softly.assertAll(), this is done by the extension
+ *     }
+ *   }
+ * } </code></pre>
+ *
+ * <h3>Example using a mix of field and parameter injection</h3>
  *
  * <pre>
  * <code class='java'> {@literal @}ExtendWith(SoftAssertionsExtension.class)
  * class ExampleTestCase {
  *
+ *    {@literal @}InjectSoftAssertions
+ *    SoftAssertions softly
+ *
  *    {@literal @}Test
- *    void multipleFailures(BDDSoftAssertions softly) {
- *       softly.then(2 * 3).isEqualTo(0);
- *       softly.then(Arrays.asList(1, 2)).containsOnly(1);
- *       softly.then(1 + 1).isEqualTo(2);
+ *    void multipleFailures(BDDSoftAssertions bdd) {
+ *       bdd.then(2 * 3).isEqualTo(0);
+ *       softly.assertThat(Arrays.asList(1, 2)).containsOnly(1);
+ *       bdd.then(1 + 1).isEqualTo(2);
+ *       // When SoftAssertionsExtension calls assertAll(), the three
+ *       // above failures above will be reported in-order.
+ *    }
+ * }</code>
+ * </pre>
+ *
+ * <h3>Example third-party extension using {@code SoftAssertionsExtension}</h3>
+ *
+ * <pre>
+ * <code class='java'>
+ * class ExampleTestCase implements BeforeEachCallback {
+ *
+ *    {@literal @}Override
+ *    public void beforeEach(ExtensionContext context) {
+ *      SoftAssertions softly = SoftAssertionsExtension
+ *        .getSoftAssertionsProvider(context, SoftAssertions.class);
+ *      softly.assertThat(false).isTrue();
+ *      // When SoftAssertionsExtension calls assertAll(), the
+ *      // above failure will be included in the list of reported failures.
  *    }
  * }</code>
  * </pre>
  *
  * @author Sam Brannen
+ * @author Arthur Mita (author of {@link SoftlyExtension})
+ * @author Fr Jeremy Krieg
  * @since 3.13
  */
-public class SoftAssertionsExtension implements ParameterResolver, AfterTestExecutionCallback {
+public class SoftAssertionsExtension
+    implements TestInstancePostProcessor, BeforeEachCallback, ParameterResolver, AfterTestExecutionCallback {
 
   private static final Namespace SOFT_ASSERTIONS_EXTENSION_NAMESPACE = Namespace.create(SoftAssertionsExtension.class);
 
+  static class ThreadLocalErrorCollector implements AssertionErrorCollector {
+
+    InheritableThreadLocal<AssertionErrorCollector> threadLocal = new InheritableThreadLocal<>();
+
+    @Override
+    public Optional<AssertionErrorCollector> getDelegate() {
+      return Optional.of(threadLocal.get());
+    }
+
+    @Override
+    public void setDelegate(AssertionErrorCollector assertionErrorCollector) {
+      threadLocal.set(assertionErrorCollector);
+    }
+
+    public void reset() {
+      threadLocal.remove();
+    }
+
+    @Override
+    public void collectAssertionError(AssertionError assertionError) {
+      threadLocal.get().collectAssertionError(assertionError);
+    }
+
+    @Override
+    public List<AssertionError> assertionErrorsCollected() {
+      return threadLocal.get().assertionErrorsCollected();
+    }
+
+    @Override
+    public void succeeded() {
+      threadLocal.get().succeeded();
+    }
+
+    @Override
+    public boolean wasSuccess() {
+      return threadLocal.get().wasSuccess();
+    }
+  }
+
+  static boolean isPerClass(ExtensionContext context) {
+    return context.getTestInstanceLifecycle().map(x -> x == Lifecycle.PER_CLASS).orElse(false);
+  }
+
+  static boolean isAnnotatedConcurrent(ExtensionContext context) {
+    return findAnnotation(context.getRequiredTestClass(), Execution.class).map(Execution::value)
+                                                                          .map(x -> x == ExecutionMode.CONCURRENT)
+                                                                          .orElse(false);
+  }
+
+  static boolean isPerClassConcurrent(ExtensionContext context) {
+    return isPerClass(context) && isAnnotatedConcurrent(context);
+  }
+
+  @Override
+  public void postProcessTestInstance(Object testInstance, ExtensionContext context) throws Exception {
+    // find SoftAssertions fields in the test class hierarchy
+    Collection<Field> softAssertionsFields = findFields(testInstance.getClass(),
+                                                        field -> isAnnotated(field, InjectSoftAssertions.class),
+                                                        HierarchyTraversalMode.BOTTOM_UP);
+    for (Field softAssertionsField : softAssertionsFields) {
+      checkIsNotStaticOrFinal(softAssertionsField);
+      Class<? extends SoftAssertionsProvider> softAssertionsProviderClass = asSoftAssertionsProviderClass(softAssertionsField,
+                                                                                                          softAssertionsField.getType());
+      checkIsNotAbstract(softAssertionsField, softAssertionsProviderClass);
+      checkHasDefaultConstructor(softAssertionsField, softAssertionsProviderClass);
+      SoftAssertionsProvider softAssertions = getSoftAssertionsProvider(context, softAssertionsProviderClass);
+      setTestInstanceSoftAssertionsField(testInstance, softAssertionsField, softAssertions);
+    }
+  }
+
+  @Override
+  public void beforeEach(ExtensionContext context) throws Exception {
+    AssertionErrorCollector collector = getAssertionErrorCollector(context);
+
+    if (isPerClassConcurrent(context)) {
+      // If the current context is "per class+concurrent", then getSoftAssertionsProvider() will have already set the delegate
+      // for all the soft assertions provider to the thread-local error collector, so all we need to do is set the tlec's value
+      // for the current thread.
+      ThreadLocalErrorCollector tlec = getThreadLocalCollector(context);
+      tlec.setDelegate(collector);
+    } else {
+      // Make sure that all of the soft assertion provider instances have their delegate initialised to the assertion error
+      // collector for the current context. Also check parents (in the case of nested tests).
+      while (initialiseDelegate(context, collector)) {
+        context = context.getParent().get();
+      }
+    }
+  }
+
+  private static boolean initialiseDelegate(ExtensionContext context, AssertionErrorCollector collector) {
+    Collection<SoftAssertionsProvider> providers = getSoftAssertionsProviders(context);
+    if (providers == null) return false;
+    providers.forEach(x -> x.setDelegate(collector));
+    return context.getParent().isPresent();
+  }
+
   @Override
   public boolean supportsParameter(ParameterContext parameterContext, ExtensionContext extensionContext) {
     // Abort if parameter type is unsupported.
@@ -129,15 +314,23 @@ public class SoftAssertionsExtension implements ParameterResolver, AfterTestExec
     @SuppressWarnings("unchecked")
     Class<? extends SoftAssertionsProvider> concreteSoftAssertionsProviderType = (Class<? extends SoftAssertionsProvider>) parameterContext.getParameter()
                                                                                                                                            .getType();
-    return getStore(extensionContext).getOrComputeIfAbsent(SoftAssertionsProvider.class,
-                                                           unused -> ReflectionSupport.newInstance(concreteSoftAssertionsProviderType),
-                                                           SoftAssertionsProvider.class);
+    SoftAssertionsProvider provider = ReflectionSupport.newInstance(concreteSoftAssertionsProviderType);
+    provider.setDelegate(getAssertionErrorCollector(extensionContext));
+    return provider;
   }
 
   @Override
   public void afterTestExecution(ExtensionContext extensionContext) {
-    Optional.ofNullable(getStore(extensionContext).remove(SoftAssertionsProvider.class, SoftAssertionsProvider.class))
-            .ifPresent(SoftAssertionsProvider::assertAll);
+    AssertionErrorCollector collector;
+    if (isPerClassConcurrent(extensionContext)) {
+      ThreadLocalErrorCollector tlec = getThreadLocalCollector(extensionContext);
+      collector = tlec.getDelegate().get();
+      // Clear the tlec just in case this thread gets re-used.
+      tlec.reset();
+    } else {
+      collector = getAssertionErrorCollector(extensionContext);
+    }
+    AbstractSoftAssertions.assertAll(collector);
   }
 
   private static boolean isUnsupportedParameterType(Parameter parameter) {
@@ -149,4 +342,142 @@ public class SoftAssertionsExtension implements ParameterResolver, AfterTestExec
     return extensionContext.getStore(SOFT_ASSERTIONS_EXTENSION_NAMESPACE);
   }
 
+  private static ThreadLocalErrorCollector getThreadLocalCollector(ExtensionContext context) {
+    return getStore(context).getOrComputeIfAbsent(ThreadLocalErrorCollector.class, unused -> new ThreadLocalErrorCollector(),
+                                                  ThreadLocalErrorCollector.class);
+  }
+
+  /**
+   * Returns the {@link AssertionErrorCollector} for the given extension context, if none exists for the current context then
+   * one is created.
+   * <p>
+   * This method is thread safe - all extensions attempting to access the {@code AssertionErrorCollector} for a given context
+   * through this method will get a reference to the same {@code AssertionErrorCollector} instance, regardless of the order
+   * in which they are called.
+   * <p>
+   * Third-party extensions that wish to provide soft-asserting behavior can use this method to obtain the current
+   * {@code AssertionErrorCollector} instance and record their assertion failures into it by calling
+   * {@link AssertionErrorCollector#collectAssertionError(AssertionError) collectAssertionError(AssertionError)}.<br>
+   * In this way their soft assertions will integrate with the existing AssertJ soft assertions and the assertion failures (both
+   * AssertJ's and the third-party extension's) will be reported in the order that they occurred.
+   *
+   * @param context the {@code ExtensionContext} whose error collector we are attempting to retrieve.
+   * @return The {@code AssertionErrorCollector} for the given context.
+   */
+  @Beta
+  public static AssertionErrorCollector getAssertionErrorCollector(ExtensionContext context) {
+    return getStore(context).getOrComputeIfAbsent(AssertionErrorCollector.class, unused -> new DefaultAssertionErrorCollector(),
+                                                  AssertionErrorCollector.class);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Collection<SoftAssertionsProvider> getSoftAssertionsProviders(ExtensionContext context) {
+    return getStore(context).getOrComputeIfAbsent(Collection.class, unused -> new ConcurrentLinkedQueue<>(), Collection.class);
+  }
+
+  private static <T extends SoftAssertionsProvider> T instantiateProvider(ExtensionContext context, Class<T> providerType) {
+    T softAssertions = ReflectionSupport.newInstance(providerType);
+    // If we are running single-threaded, we won't have any concurrency issues. Likewise,
+    // if we are running "per-method", then every test gets its own instance and again there
+    // won't be any concurrency issues. But we need to special-case the situation where
+    // we are running *both* per class and concurrent - use a thread-local so that each thread
+    // gets its own copy. The beforeEach() callback above will take care of setting the
+    // ThreadLocal collector's value for the thread in which it is executing.
+    if (isPerClassConcurrent(context)) {
+      softAssertions.setDelegate(getThreadLocalCollector(context));
+    } else if (context.getTestMethod().isPresent()) {
+      // If we're already in a method, then set our delegate as the beforeEach() which sets it may have already run.
+      softAssertions.setDelegate(getAssertionErrorCollector(context));
+    }
+    getSoftAssertionsProviders(context).add(softAssertions);
+    return softAssertions;
+  }
+
+  /**
+   * Returns a {@link SoftAssertionsProvider} instance of the given type for the given extension context.
+   * If no instance of the given type exists for the supplied context, then one is created.<br>
+   * Note that the given type must be a concrete type with an accessible no-arg constructor for this method to work.
+   * <p>
+   * This method is thread safe - all extensions attempting to access the {@code SoftAssertionsProvider} for a
+   * given context through this method will receive end up getting a reference to the same
+   * {@code SoftAssertionsProvider} instance of that same type, regardless of the order in which they are called.
+   * <p>
+   * Third party extensions that wish to use soft assertions in their own implementation can use this
+   * to get a {@code SoftAssertionsProvider} instance that interoperates with other soft-asserting
+   * extensions (including {@code SoftAssertionsExtension}).
+   * <p>
+   * The {@code SoftAssertionExtension} will take care of initialising this provider instance's delegate
+   * at the appropriate time, so that collected soft assertions are routed to the {@link AssertionErrorCollector}
+   * instance for the current context.
+   *
+   * <pre><code class='java'> public class CustomExtension implements BeforeEachCallback {
+   *
+   *   {@literal @}Override
+   *   public void beforeEach(ExtensionContext context) {
+   *     CustomSoftAssertions softly = SoftAssertionsExtension.getSoftAssertionsProvider(context, CustomSoftAssertions.class);
+   *     softly.assertThat(1).isOne();
+   *   }
+   * }</code>
+   * </pre>
+   *
+   * @param <T> the type of {@link SoftAssertionsProvider} to instantiate.
+   * @param context the {@code ExtensionContext} whose error collector we are attempting to retrieve.
+   * @param concreteSoftAssertionsProviderType the class instance for the type of soft assertions
+   * @return The {@code AssertionErrorCollector} for the given context.
+   */
+  @Beta
+  public static <T extends SoftAssertionsProvider> T getSoftAssertionsProvider(ExtensionContext context,
+                                                                               Class<T> concreteSoftAssertionsProviderType) {
+    return getStore(context).getOrComputeIfAbsent(concreteSoftAssertionsProviderType,
+                                                  unused -> instantiateProvider(context, concreteSoftAssertionsProviderType),
+                                                  concreteSoftAssertionsProviderType);
+  }
+
+  private static void setTestInstanceSoftAssertionsField(Object testInstance, Field softAssertionsField,
+                                                         SoftAssertionsProvider softAssertions) {
+    softAssertionsField.setAccessible(true);
+    try {
+      softAssertionsField.set(testInstance, softAssertions);
+    } catch (IllegalAccessException e) {
+      throw new ExtensionConfigurationException(format("[%s] Could not gain access to field", softAssertionsField.getName()), e);
+    }
+  }
+
+  private static void checkHasDefaultConstructor(Field softAssertionsField,
+                                                 Class<? extends SoftAssertionsProvider> softAssertionsProviderClass) {
+    try {
+      softAssertionsProviderClass.getDeclaredConstructor();
+    } catch (@SuppressWarnings("unused") Exception e) {
+      throw new ExtensionConfigurationException(format("[%s] SoftAssertionsProvider [%s] does not have a default constructor",
+                                                       softAssertionsField.getName(), softAssertionsProviderClass.getName()));
+    }
+  }
+
+  private static void checkIsNotAbstract(Field softAssertionsField,
+                                         Class<? extends SoftAssertionsProvider> softAssertionsProviderClass) {
+    if (Modifier.isAbstract(softAssertionsProviderClass.getModifiers())) {
+      throw new ExtensionConfigurationException(format("[%s] SoftAssertionsProvider [%s] is abstract and cannot be instantiated.",
+                                                       softAssertionsField.getName(), softAssertionsProviderClass));
+    }
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Class<? extends SoftAssertionsProvider> asSoftAssertionsProviderClass(Field softAssertionsField,
+                                                                                       Class<?> providerClass) {
+    if (!SoftAssertionsProvider.class.isAssignableFrom(providerClass)) {
+      throw new ExtensionConfigurationException(format("[%s] field is not a SoftAssertionsProvider (%s).",
+                                                       softAssertionsField.getName(), providerClass.getTypeName()));
+    }
+    // Guaranteed because of the sanity check
+    return (Class<? extends SoftAssertionsProvider>) providerClass;
+  }
+
+  private static void checkIsNotStaticOrFinal(Field softAssertionsField) {
+    int fieldModifiers = softAssertionsField.getModifiers();
+    if (Modifier.isStatic(fieldModifiers) || Modifier.isFinal(fieldModifiers)) {
+      throw new ExtensionConfigurationException(format("[%s] SoftAssertionsProvider field must not be static or final.",
+                                                       softAssertionsField.getName()));
+    }
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/junit/jupiter/SoftlyExtension.java b/src/main/java/org/assertj/core/api/junit/jupiter/SoftlyExtension.java
index a46ea4698..5c9759b76 100644
--- a/src/main/java/org/assertj/core/api/junit/jupiter/SoftlyExtension.java
+++ b/src/main/java/org/assertj/core/api/junit/jupiter/SoftlyExtension.java
@@ -19,7 +19,6 @@ import java.lang.reflect.Field;
 import java.util.Collection;
 import java.util.Optional;
 
-import org.assertj.core.annotations.Beta;
 import org.assertj.core.api.SoftAssertions;
 import org.junit.jupiter.api.TestInstance.Lifecycle;
 import org.junit.jupiter.api.extension.AfterTestExecutionCallback;
@@ -52,7 +51,8 @@ import org.junit.platform.commons.support.HierarchyTraversalMode;
  *   <li>May exhibit unpredictable behaviour in concurrent test execution</li>
  * </ol>
  * <p>
- * If you hit such limitations, consider using {@link SoftAssertionsExtension} instead.
+ * <b>If you hit such limitations, consider using {@link SoftAssertionsExtension} instead, since 3.18.0,
+ * {@code SoftAssertionsExtension} supports field injection with neither of these two limitations.</b>
  * <p>
  * Example:
  * <pre><code> {@literal @}ExtendWith(SoftlyExtension.class)
@@ -85,8 +85,10 @@ import org.junit.platform.commons.support.HierarchyTraversalMode;
  *   }
  * } </code></pre>
  * @author Arthur Mita
+ * @deprecated This functionality (and more) has been rolled into {@link SoftAssertionsExtension}
+ * as of AssertJ 3.18.0.
  **/
-@Beta
+@Deprecated
 public class SoftlyExtension implements AfterTestExecutionCallback, TestInstancePostProcessor {
 
   private static final Namespace SOFTLY_EXTENSION_NAMESPACE = Namespace.create(SoftlyExtension.class);
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/CustomSoftAssertions.java b/src/test/java/org/assertj/core/api/junit/jupiter/CustomSoftAssertions.java
new file mode 100644
index 000000000..d2cf4d6f6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/CustomSoftAssertions.java
@@ -0,0 +1,30 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import java.util.List;
+
+import org.assertj.core.api.AbstractSoftAssertions;
+import org.assertj.core.api.IntegerAssert;
+import org.assertj.core.api.ProxyableListAssert;
+
+class CustomSoftAssertions extends AbstractSoftAssertions {
+  public IntegerAssert expectThat(int value) {
+    return proxy(IntegerAssert.class, Integer.class, value);
+  }
+
+  @SuppressWarnings("unchecked")
+  public <T> ProxyableListAssert<T> expectThat(List<? extends T> actual) {
+    return proxy(ProxyableListAssert.class, List.class, actual);
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/CustomSoftAssertionsExtensionIntegrationTest.java b/src/test/java/org/assertj/core/api/junit/jupiter/CustomSoftAssertionsExtensionIntegrationTest.java
index d3fbb717c..3d84b82b2 100644
--- a/src/test/java/org/assertj/core/api/junit/jupiter/CustomSoftAssertionsExtensionIntegrationTest.java
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/CustomSoftAssertionsExtensionIntegrationTest.java
@@ -16,11 +16,7 @@ import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
 import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_METHOD;
 
 import java.util.Arrays;
-import java.util.List;
 
-import org.assertj.core.api.AbstractSoftAssertions;
-import org.assertj.core.api.IntegerAssert;
-import org.assertj.core.api.ProxyableListAssert;
 import org.assertj.core.api.SoftAssertionsProvider;
 import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.DisplayName;
@@ -66,17 +62,6 @@ class CustomSoftAssertionsExtensionIntegrationTest extends AbstractSoftAssertion
     return TestInstancePerClassNestedExample.class;
   }
 
-  private static class CustomSoftAssertions extends AbstractSoftAssertions {
-    public IntegerAssert expectThat(int value) {
-      return proxy(IntegerAssert.class, Integer.class, value);
-    }
-
-    @SuppressWarnings("unchecked")
-    public <T> ProxyableListAssert<T> expectThat(List<? extends T> actual) {
-      return proxy(ProxyableListAssert.class, List.class, actual);
-    }
-  }
-
   // -------------------------------------------------------------------------
 
   @ExtendWith(SoftAssertionsExtension.class)
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/ExtensionInjector.java b/src/test/java/org/assertj/core/api/junit/jupiter/ExtensionInjector.java
new file mode 100644
index 000000000..d14262ecc
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/ExtensionInjector.java
@@ -0,0 +1,34 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.extension.ParameterContext;
+import org.junit.jupiter.api.extension.ParameterResolutionException;
+import org.junit.jupiter.api.extension.ParameterResolver;
+
+class ExtensionInjector implements ParameterResolver {
+
+  @Override
+  public boolean supportsParameter(ParameterContext parameterContext,
+                                   ExtensionContext extensionContext) throws ParameterResolutionException {
+    return parameterContext.getParameter().getType() == ExtensionContext.class;
+  }
+
+  @Override
+  public Object resolveParameter(ParameterContext parameterContext,
+                                 ExtensionContext extensionContext) throws ParameterResolutionException {
+    return extensionContext;
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/InheritingSoftlyExtensionFieldTest.java b/src/test/java/org/assertj/core/api/junit/jupiter/InheritingSoftlyExtensionFieldTest.java
index 3d115ce56..4d95ec7c0 100644
--- a/src/test/java/org/assertj/core/api/junit/jupiter/InheritingSoftlyExtensionFieldTest.java
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/InheritingSoftlyExtensionFieldTest.java
@@ -20,6 +20,7 @@ import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
+@SuppressWarnings("deprecation")
 @DisplayName("SoftlyExtension inheriting SoftAssertions field")
 class InheritingSoftlyExtensionFieldTest extends WithSoftlyExtension {
 
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtensionAPIIntegrationTest.java b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtensionAPIIntegrationTest.java
new file mode 100644
index 000000000..f2be091a3
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtensionAPIIntegrationTest.java
@@ -0,0 +1,136 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.testkit.engine.EventConditions.event;
+import static org.junit.platform.testkit.engine.EventConditions.finishedWithFailure;
+import static org.junit.platform.testkit.engine.EventConditions.test;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.instanceOf;
+import static org.junit.platform.testkit.engine.TestExecutionResultConditions.message;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.assertj.core.api.AssertionErrorCollector;
+import org.assertj.core.api.AutoCloseableSoftAssertions;
+import org.assertj.core.api.BDDSoftAssertions;
+import org.assertj.core.api.SoftAssertions;
+import org.assertj.core.error.AssertJMultipleFailuresError;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.platform.testkit.engine.EngineTestKit;
+
+/**
+ * Integration tests for the public API functions of {@link SoftAssertionsExtension}.
+ *
+ * @author Fr Jeremy Krieg
+ * @since 3.18
+ */
+class SoftAssertionsExtensionAPIIntegrationTest {
+
+  @Disabled("Executed via the JUnit Platform Test Kit")
+  @ExtendWith(ExtensionInjector.class)
+  @ExtendWith(SoftAssertionsExtension.class)
+  static class APITest {
+
+    static Map<String, AssertionErrorCollector> map = new HashMap<>();
+
+    @BeforeAll
+    static void beforeAll() {
+      map.clear();
+    }
+
+    @BeforeEach
+    void beforeEach(ExtensionContext context) {
+      SoftAssertions provider = SoftAssertionsExtension.getSoftAssertionsProvider(context, SoftAssertions.class);
+      assertThat(provider.assertionErrorsCollected()).isEmpty();
+      provider.assertThat("something").isEqualTo("nothing");
+      assertThat(provider.assertionErrorsCollected()).as("beforeEach:after assert").hasSize(1);
+      AssertionErrorCollector collector = SoftAssertionsExtension.getAssertionErrorCollector(context);
+      assertThat(provider.getDelegate()).contains(collector);
+      map.put(context.getTestMethod().get().getName(), collector);
+    }
+
+    @Test
+    void multipleFailuresCustom(ExtensionContext context, CustomSoftAssertions softly) {
+      AssertionErrorCollector collector = SoftAssertionsExtension.getAssertionErrorCollector(context);
+      assertThat(collector.assertionErrorsCollected()).as("init").hasSize(1);
+      softly.expectThat(1).isEqualTo(0);
+      assertThat(collector.assertionErrorsCollected()).as("after first").hasSize(2);
+      SoftAssertions provider = SoftAssertionsExtension.getSoftAssertionsProvider(context, SoftAssertions.class);
+      provider.assertThat(2).isEqualTo(2);
+      assertThat(collector.assertionErrorsCollected()).as("after second").hasSize(2);
+      provider.assertThat(2).isEqualTo(1);
+      assertThat(collector.assertionErrorsCollected()).as("after third").hasSize(3);
+      softly.expectThat(3).isEqualTo(4);
+      assertThat(collector.assertionErrorsCollected()).as("after fourth").hasSize(4);
+    }
+
+    @Test
+    void multipleFailuresBDD(ExtensionContext context, BDDSoftAssertions softly) {
+      AssertionErrorCollector collector = SoftAssertionsExtension.getAssertionErrorCollector(context);
+      assertThat(collector.assertionErrorsCollected()).as("init").hasSize(1);
+      softly.then(1).isEqualTo(0);
+      assertThat(collector.assertionErrorsCollected()).as("after first").hasSize(2);
+      CustomSoftAssertions provider = SoftAssertionsExtension.getSoftAssertionsProvider(context, CustomSoftAssertions.class);
+      provider.expectThat(2).isEqualTo(2);
+      assertThat(collector.assertionErrorsCollected()).as("after second").hasSize(2);
+      softly.then(3).isEqualTo(4);
+      assertThat(collector.assertionErrorsCollected()).as("after third").hasSize(3);
+    }
+
+  }
+
+  @Test
+  void apiTest() {
+    EngineTestKit.engine("junit-jupiter")
+                 .selectors(selectClass(APITest.class))
+                 .configurationParameter("junit.jupiter.conditions.deactivate", "*")
+                 .execute()
+                 .testEvents()
+                 .assertStatistics(stats -> stats.started(2).succeeded(0).failed(2))
+                 .failed()
+                 // @format:off
+                 .assertThatEvents().haveExactly(1,
+                                                 event(test("multipleFailuresCustom"),
+                                                       finishedWithFailure(instanceOf(AssertJMultipleFailuresError.class),
+                                                                           message(msg -> msg.contains("Multiple Failures (4 failures)")))))
+                                    .haveExactly(1,
+                                                 event(test("multipleFailuresBDD"),
+                                                       finishedWithFailure(instanceOf(AssertJMultipleFailuresError.class),
+                                                                           message(msg -> msg.contains("Multiple Failures (3 failures)")))));
+                 // @format:on
+    try (AutoCloseableSoftAssertions softly = new AutoCloseableSoftAssertions()) {
+      List<AssertionError> collected = APITest.map.get("multipleFailuresCustom").assertionErrorsCollected();
+      softly.assertThat(collected).as("size").hasSize(4);
+      softly.assertThat(collected.get(0)).as("zero").hasMessageContaining("something").hasMessageContaining("nothing");
+      softly.assertThat(collected.get(1)).as("one").hasMessageContaining("1").hasMessageContaining("0");
+      softly.assertThat(collected.get(2)).as("two").hasMessageContaining("2").hasMessageContaining("1");
+      softly.assertThat(collected.get(3)).as("three").hasMessageContaining("3").hasMessageContaining("4");
+
+      collected = APITest.map.get("multipleFailuresBDD").assertionErrorsCollected();
+      softly.assertThat(collected).as("size2").hasSize(3);
+      softly.assertThat(collected.get(0)).as("zero2").hasMessageContaining("something").hasMessageContaining("nothing");
+      softly.assertThat(collected.get(1)).as("one2").hasMessageContaining("1").hasMessageContaining("0");
+      softly.assertThat(collected.get(2)).as("two2").hasMessageContaining("3").hasMessageContaining("4");
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_InjectionSanityChecking_Test.java b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_InjectionSanityChecking_Test.java
new file mode 100644
index 000000000..2605a0be6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_InjectionSanityChecking_Test.java
@@ -0,0 +1,115 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import static org.assertj.core.api.junit.jupiter.TestKitUtils.assertThatTest;
+
+import org.assertj.core.api.AbstractSoftAssertions;
+import org.assertj.core.api.SoftAssertions;
+import org.assertj.core.api.SoftAssertionsProvider;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionConfigurationException;
+
+@DisplayName("SoftAssertionsExtension injection sanity checking test")
+class SoftAssertionsExtension_InjectionSanityChecking_Test {
+
+  @ExtendWith(SoftAssertionsExtension.class)
+  static private class TestBase {
+    @Test
+    void myTest() {}
+  }
+
+  class NoDefaultSoftAssertionsProvider extends AbstractSoftAssertions {
+    public NoDefaultSoftAssertionsProvider(@SuppressWarnings("unused") String param) {}
+  }
+
+  @Disabled("Run by the testkit")
+  static class NoDefaultConstructorTest extends TestBase {
+    @InjectSoftAssertions
+    NoDefaultSoftAssertionsProvider usp;
+  }
+
+  @Test
+  void field_with_no_default_constructor_throws_exception() {
+    assertThatTest(NoDefaultConstructorTest.class).isInstanceOf(ExtensionConfigurationException.class)
+                                                  .hasMessage("[usp] SoftAssertionsProvider [%s] does not have a default constructor",
+                                                              NoDefaultSoftAssertionsProvider.class.getName());
+  }
+
+  static abstract class AbstractProvider implements SoftAssertionsProvider {
+  }
+
+  @Disabled("Run by the testkit")
+  static class AbstractProviderTest extends TestBase {
+    @InjectSoftAssertions
+    AbstractProvider usp;
+  }
+
+  @Test
+  void field_with_abstract_provider_throws_exception() {
+    assertThatTest(AbstractProviderTest.class).isInstanceOf(ExtensionConfigurationException.class)
+                                              .hasMessage("[usp] SoftAssertionsProvider [%s] is abstract and cannot be instantiated.",
+                                                          AbstractProvider.class);
+  }
+
+  @Disabled("Run by the testkit")
+  static class FinalField extends TestBase {
+    @InjectSoftAssertions
+    final SoftAssertions usp = null;
+
+    @Override
+    @Test
+    void myTest() {}
+  }
+
+  @Test
+  void final_field__throws_exception() {
+    assertThatTest(FinalField.class).isInstanceOf(ExtensionConfigurationException.class)
+                                    .hasMessage("[usp] SoftAssertionsProvider field must not be static or final.");
+  }
+
+  @Disabled("Run by the testkit")
+  static class StaticField extends TestBase {
+    @InjectSoftAssertions
+    static SoftAssertions usp = null;
+
+    @Override
+    @Test
+    void myTest() {}
+  }
+
+  @Test
+  void static_field_throws_exception() {
+    assertThatTest(StaticField.class).isInstanceOf(ExtensionConfigurationException.class)
+                                     .hasMessage("[usp] SoftAssertionsProvider field must not be static or final.");
+  }
+
+  @Disabled("Run by the testkit")
+  static class WrongType extends TestBase {
+    @InjectSoftAssertions
+    String usp;
+
+    @Override
+    @Test
+    void myTest() {}
+  }
+
+  @Test
+  void wrong_type_throws_exception() {
+    assertThatTest(WrongType.class).isInstanceOf(ExtensionConfigurationException.class)
+                                   .hasMessage("[usp] field is not a SoftAssertionsProvider (java.lang.String).");
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_Injection_Test.java b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_Injection_Test.java
new file mode 100644
index 000000000..af215a380
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_Injection_Test.java
@@ -0,0 +1,84 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.assertj.core.api.BDDSoftAssertions;
+import org.assertj.core.api.SoftAssertions;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.extension.ExtendWith;
+
+@ExtendWith(SoftAssertionsExtension.class)
+@DisplayName("SoftAssertionsExtension injection test")
+class SoftAssertionsExtension_Injection_Test {
+
+  // use a mix of private and package-private here to test behaviour in the variety of different circumstances.
+  @InjectSoftAssertions
+  SoftAssertions softly;
+
+  @InjectSoftAssertions
+  private BDDSoftAssertions deftly;
+
+  SoftAssertions unannotated;
+
+  @Test
+  void should_pass_if_not_null() {
+    assertThat(softly).isNotNull();
+  }
+
+  @Test
+  void bdd_should_pass_if_not_null() {
+    assertThat(deftly).isNotNull();
+    assertThat(deftly.getDelegate().get()).isSameAs(softly.getDelegate().get());
+  }
+
+  @Test
+  void should_have_same_collector_as_parameter(CustomSoftAssertions custom) {
+    assertThat(custom.getDelegate().get()).isSameAs(softly.getDelegate().get());
+  }
+
+  @Test
+  void should_not_inject_into_unannotated_field() {
+    assertThat(unannotated).isNull();
+  }
+
+  @Nested
+  @ExtendWith(SoftAssertionsExtension.class)
+  @DisplayName("nested test class without SoftAssertions field")
+  class NestedMethodLifecycle {
+
+    @Test
+    void should_use_parent_SoftAssertions_initialized_field() {
+      assertThat(softly).isNotNull();
+    }
+  }
+
+  @Nested
+  @ExtendWith(SoftAssertionsExtension.class)
+  @DisplayName("nested test class with SoftAssertions field")
+  class SoftlyNestedMethodLifecycle {
+
+    @InjectSoftAssertions
+    SoftAssertions nestedSoftly;
+
+    @Test
+    void should_use_own_SoftAssertions_initialized_field() {
+      assertThat(nestedSoftly).isNotNull();
+      assertThat(nestedSoftly.getDelegate().get()).isSameAs(softly.getDelegate().get());
+    }
+
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_PER_CLASS_Concurrency_Test.java b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_PER_CLASS_Concurrency_Test.java
new file mode 100644
index 000000000..76e6f517e
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_PER_CLASS_Concurrency_Test.java
@@ -0,0 +1,126 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.CountDownLatch;
+
+import org.assertj.core.api.AssertionErrorCollector;
+import org.assertj.core.api.AutoCloseableSoftAssertions;
+import org.assertj.core.api.SoftAssertions;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Disabled;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.extension.ExtensionContext;
+import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.ExecutionMode;
+import org.junit.platform.testkit.engine.EngineTestKit;
+
+@DisplayName("SoftAssertionsExtension PER_CLASS concurrent injection test")
+public class SoftAssertionsExtension_PER_CLASS_Concurrency_Test {
+  // Use CountDownLatches to synchronize between the two parallel running tests to make sure that they overlap in time.
+  @Disabled("Run by the testkit")
+  @ExtendWith(SoftAssertionsExtension.class)
+  @ExtendWith(ExtensionInjector.class)
+  @Execution(ExecutionMode.CONCURRENT)
+  @TestInstance(Lifecycle.PER_CLASS)
+  static class ConcurrencyTest {
+
+    @InjectSoftAssertions
+    SoftAssertions softly;
+
+    static CountDownLatch[] flags = new CountDownLatch[6];
+    static Map<String, AssertionErrorCollector> map = new HashMap<>();
+
+    @BeforeAll
+    static void beforeAll() {
+      map.clear();
+      for (int i = 0; i < flags.length; i++) {
+        flags[i] = new CountDownLatch(1);
+      }
+    }
+
+    @BeforeEach
+    void beforeEach(ExtensionContext context) {
+      map.put(context.getTestMethod().get().getName(), SoftAssertionsExtension.getAssertionErrorCollector(context));
+    }
+
+    static void waitForFlag(int flagNum) {
+      try {
+        if (!flags[flagNum].await(5000, MILLISECONDS)) {
+          throw new IllegalStateException("Timed out while waiting for flag " + flagNum);
+        }
+      } catch (InterruptedException e) {
+        throw new IllegalStateException("Interrupted while waiting for flag " + flagNum, e);
+      }
+    }
+
+    @Test
+    void test1(ExtensionContext context) {
+      softly.assertThat(1).isEqualTo(0);
+      flags[0].countDown();
+      waitForFlag(1);
+      softly.assertThat(3).isEqualTo(4);
+      flags[2].countDown();
+      waitForFlag(3);
+      softly.assertThat(5).isEqualTo(6);
+      map.put(context.getTestMethod().get().getName(), SoftAssertionsExtension.getAssertionErrorCollector(context));
+    }
+
+    @Test
+    void test2(@SuppressWarnings("unused") ExtensionContext context) {
+      waitForFlag(0);
+      softly.assertThat(2).isEqualTo(1);
+      flags[1].countDown();
+      waitForFlag(2);
+      softly.assertThat(4).isEqualTo(5);
+      flags[3].countDown();
+    }
+  }
+
+  @Test
+  void concurrent_tests_with_explicit_per_class_annotation_do_not_interfere() {
+    EngineTestKit.engine("junit-jupiter")
+                 .selectors(selectClass(ConcurrencyTest.class))
+                 .configurationParameter("junit.jupiter.conditions.deactivate", "*")
+                 .configurationParameter("junit.jupiter.execution.parallel.enabled", "true")
+                 .execute()
+                 .testEvents()
+                 .debug(System.err)
+                 .assertStatistics(stats -> stats.started(2).succeeded(0).failed(2))
+                 .failed();
+
+    try (AutoCloseableSoftAssertions softly = new AutoCloseableSoftAssertions()) {
+      List<AssertionError> collected = ConcurrencyTest.map.get("test1").assertionErrorsCollected();
+      softly.assertThat(collected).as("size").hasSize(3);
+      softly.assertThat(collected.get(0)).as("zero").hasMessageContainingAll("1", "0");
+      softly.assertThat(collected.get(1)).as("one").hasMessageContainingAll("3", "4");
+      softly.assertThat(collected.get(2)).as("two").hasMessageContainingAll("5", "6");
+
+      collected = ConcurrencyTest.map.get("test2").assertionErrorsCollected();
+      softly.assertThat(collected).as("size2").hasSize(2);
+      softly.assertThat(collected.get(0)).as("zero2").hasMessageContainingAll("2", "1");
+      softly.assertThat(collected.get(1)).as("one2").hasMessageContainingAll("4", "5");
+    }
+  }
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_PER_CLASS_Injection_Test.java b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_PER_CLASS_Injection_Test.java
new file mode 100644
index 000000000..c1a8273f0
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/SoftAssertionsExtension_PER_CLASS_Injection_Test.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import org.assertj.core.api.BDDSoftAssertions;
+import org.assertj.core.api.SoftAssertions;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Nested;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInstance;
+import org.junit.jupiter.api.TestInstance.Lifecycle;
+import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.api.parallel.Execution;
+import org.junit.jupiter.api.parallel.ExecutionMode;
+
+@ExtendWith(SoftAssertionsExtension.class)
+@DisplayName("SoftAssertionsExtension PER_CLASS injection test")
+@TestInstance(Lifecycle.PER_CLASS)
+@Execution(ExecutionMode.SAME_THREAD) // Just in case we move to parallel threads in the future
+class SoftAssertionsExtension_PER_CLASS_Injection_Test {
+
+  // use mix of private and package-private here to test behaviour in the variety of different circumstances.
+  @InjectSoftAssertions
+  SoftAssertions softly;
+
+  @InjectSoftAssertions
+  private BDDSoftAssertions deftly;
+
+  SoftAssertions unannotated;
+
+  @Test
+  void should_pass_if_not_null() {
+    assertThat(softly).isNotNull();
+  }
+
+  @Test
+  void bdd_should_pass_if_not_null() {
+    assertThat(deftly).isNotNull();
+    assertThat(deftly.getDelegate().get()).isSameAs(softly.getDelegate().get());
+  }
+
+  @Test
+  void should_have_same_collector_as_parameter(CustomSoftAssertions custom) {
+    assertThat(custom.getDelegate().get()).isSameAs(softly.getDelegate().get());
+  }
+
+  @Test
+  void should_not_inject_into_unannotated_field() {
+    assertThat(unannotated).isNull();
+  }
+
+  @Nested
+  @ExtendWith(SoftAssertionsExtension.class)
+  @DisplayName("nested test class without SoftAssertions field")
+  class NestedMethodLifecycle {
+
+    @Test
+    void should_use_parent_SoftAssertions_initialized_field() {
+      assertThat(softly).isNotNull();
+    }
+  }
+
+  @Nested
+  @ExtendWith(SoftAssertionsExtension.class)
+  @DisplayName("nested test class with SoftAssertions field")
+  class SoftlyNestedMethodLifecycle {
+
+    @InjectSoftAssertions
+    SoftAssertions nestedSoftly;
+
+    @Test
+    void should_use_own_SoftAssertions_initialized_field() {
+      assertThat(nestedSoftly).isNotNull();
+      assertThat(nestedSoftly.getDelegate().get()).isSameAs(softly.getDelegate().get());
+    }
+
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/SoftlyAssertionsExtensionIntegrationTest.java b/src/test/java/org/assertj/core/api/junit/jupiter/SoftlyAssertionsExtensionIntegrationTest.java
index c610da53d..76c1f5ff3 100644
--- a/src/test/java/org/assertj/core/api/junit/jupiter/SoftlyAssertionsExtensionIntegrationTest.java
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/SoftlyAssertionsExtensionIntegrationTest.java
@@ -39,6 +39,7 @@ import org.junit.platform.testkit.engine.EventType;
 /**
  * Integration tests for {@link SoftlyExtension}.
  */
+@SuppressWarnings("deprecation")
 @DisplayName("JUnit Jupiter SoftlyExtension integration tests")
 class SoftlyAssertionsExtensionIntegrationTest extends AbstractSoftAssertionsExtensionIntegrationTests {
 
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/SoftlyExtensionTest.java b/src/test/java/org/assertj/core/api/junit/jupiter/SoftlyExtensionTest.java
index f637c9b1e..09b2a8ed4 100644
--- a/src/test/java/org/assertj/core/api/junit/jupiter/SoftlyExtensionTest.java
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/SoftlyExtensionTest.java
@@ -20,6 +20,7 @@ import org.junit.jupiter.api.Nested;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.extension.ExtendWith;
 
+@SuppressWarnings("deprecation")
 @ExtendWith(SoftlyExtension.class)
 @DisplayName("SoftlyExtension")
 class SoftlyExtensionTest {
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/TestKitUtils.java b/src/test/java/org/assertj/core/api/junit/jupiter/TestKitUtils.java
new file mode 100644
index 000000000..500fcc1de
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/TestKitUtils.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.junit.jupiter;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.platform.engine.discovery.DiscoverySelectors.selectClass;
+import static org.junit.platform.testkit.engine.EventType.FINISHED;
+
+import java.lang.reflect.Modifier;
+import java.util.Arrays;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+import org.assertj.core.api.AbstractThrowableAssert;
+import org.junit.jupiter.engine.JupiterTestEngine;
+import org.junit.platform.engine.TestExecutionResult;
+import org.junit.platform.testkit.engine.EngineTestKit;
+import org.junit.platform.testkit.engine.Event;
+
+public class TestKitUtils {
+
+  private TestKitUtils() {}
+
+  public static AbstractThrowableAssert<?, ? extends Throwable> assertThatTest(Class<?> testClass, String... config) {
+    checkClass(testClass);
+
+    Logger logger = Logger.getLogger("org.junit.jupiter");
+    Level oldLevel = logger.getLevel();
+    try {
+      // Suppress log output while the testkit is running
+      logger.setLevel(Level.OFF);
+      EngineTestKit.Builder builder = EngineTestKit.engine(new JupiterTestEngine())
+                                                   .selectors(selectClass(testClass))
+                                                   .configurationParameter("junit.jupiter.conditions.deactivate", "*");
+
+      if (config != null) {
+        if (config.length % 2 != 0) {
+          throw new IllegalStateException("Odd number of config parameters provided: " + Arrays.toString(config));
+        }
+        for (int i = 0; i < config.length; i++) {
+          builder.configurationParameter(config[i++], config[i]);
+        }
+      }
+
+      Event testEvent = builder.execute()
+                               .allEvents()
+                               .filter(event -> event.getType().equals(FINISHED))
+                               .findAny()
+                               .orElseThrow(() -> new IllegalStateException("Test failed to run at all"));
+
+      TestExecutionResult result = testEvent.getPayload(TestExecutionResult.class)
+                                            .orElseThrow(() -> new IllegalStateException("Test result payload missing"));
+
+      return assertThat(result.getThrowable().orElse(null));
+    } finally {
+      // Restore the filter to what it was so that we do not interfere with the parent test
+      logger.setLevel(oldLevel);
+    }
+  }
+
+  private static void checkClass(Class<?> testClass) {
+    // This is to protect against developer slip-ups that can be costly...
+    if (!Modifier.isStatic(testClass.getModifiers())) throw new IllegalStateException("Test class is not static: " + testClass);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/junit/jupiter/WithSoftlyExtension.java b/src/test/java/org/assertj/core/api/junit/jupiter/WithSoftlyExtension.java
index 97fa9d3d9..e651ecf3a 100644
--- a/src/test/java/org/assertj/core/api/junit/jupiter/WithSoftlyExtension.java
+++ b/src/test/java/org/assertj/core/api/junit/jupiter/WithSoftlyExtension.java
@@ -15,6 +15,7 @@ package org.assertj.core.api.junit.jupiter;
 import org.assertj.core.api.SoftAssertions;
 import org.junit.jupiter.api.extension.ExtendWith;
 
+@SuppressWarnings("deprecation")
 @ExtendWith(SoftlyExtension.class)
 class WithSoftlyExtension {
 
