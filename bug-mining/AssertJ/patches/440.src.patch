diff --git a/src/main/java/org/assertj/core/error/ShouldContainSubsequence.java b/src/main/java/org/assertj/core/error/ShouldContainSubsequence.java
index 8c647af41..0d4e92bd8 100644
--- a/src/main/java/org/assertj/core/error/ShouldContainSubsequence.java
+++ b/src/main/java/org/assertj/core/error/ShouldContainSubsequence.java
@@ -12,8 +12,15 @@
  */
 package org.assertj.core.error;
 
+import static org.assertj.core.util.Arrays.isArray;
+import static org.assertj.core.util.Arrays.sizeOf;
+
+import java.lang.reflect.Array;
+
 import org.assertj.core.internal.ComparisonStrategy;
 import org.assertj.core.internal.StandardComparisonStrategy;
+import org.assertj.core.util.Arrays;
+import org.assertj.core.util.IterableUtil;
 
 /**
  * Creates an error message indicating that an assertion that verifies that a group of elements contains a subsequence
@@ -23,31 +30,61 @@ import org.assertj.core.internal.StandardComparisonStrategy;
  */
 public class ShouldContainSubsequence extends BasicErrorMessageFactory {
 
+  public static ShouldContainSubsequence actualDoesNotHaveEnoughElementsToContainSubsequence(Object actual, Object subsequence) {
+    return new ShouldContainSubsequence(actual, subsequence);
+  }
+
+  private ShouldContainSubsequence(Object actual, Object subsequence) {
+    super("%nExpecting actual to contain the specified subsequence but actual does not have enough elements to contain it, actual size is %s when subsequence size is %s%nactual:%n  %s%nsubsequence:%n  %s",
+          sizeOfArrayOrIterable(actual), sizeOf(subsequence), actual, subsequence);
+  }
+
+  public static ShouldContainSubsequence actualDoesNotHaveEnoughElementsLeftToContainSubsequence(Object actual,
+                                                                                                 Object subsequence,
+                                                                                                 int actualIndex,
+                                                                                                 int subsequenceIndex) {
+    return new ShouldContainSubsequence(actual, subsequence, actualIndex, subsequenceIndex);
+  }
+
+  private ShouldContainSubsequence(Object actual, Object subsequence, int actualIndex, int subsequenceIndex) {
+    super("%nExpecting actual to contain the specified subsequence but actual does not have enough elements left to compare after reaching element %s out of %s with %s subsequence element(s) still to find."
+          + "%nactual:%n  %s%nsubsequence:%n  %s",
+          actualIndex + 1, sizeOfArrayOrIterable(actual), sizeOf(subsequence) - subsequenceIndex, actual, subsequence);
+  }
+
+  private static Object sizeOfArrayOrIterable(Object actual) {
+    return isArray(actual) ? Arrays.sizeOf(actual) : IterableUtil.sizeOf((Iterable<?>) actual);
+  }
+
   /**
    * Creates a new <code>{@link ShouldContainSubsequence}</code>.
    * 
    * @param actual the actual value in the failed assertion.
    * @param subsequence the subsequence of values expected to be in {@code actual}.
+   * @param subsequenceIndex the index of the first token in {@code subsequence} that was not found in {@code actual}.
    * @param comparisonStrategy the {@link ComparisonStrategy} used to evaluate assertion.
    * @return the created {@code ErrorMessageFactory}.
    */
-  public static ErrorMessageFactory shouldContainSubsequence(Object actual, Object subsequence,
-      ComparisonStrategy comparisonStrategy) {
-    return new ShouldContainSubsequence(actual, subsequence, comparisonStrategy);
+  public static ShouldContainSubsequence shouldContainSubsequence(Object actual, Object subsequence, int subsequenceIndex,
+                                                                  ComparisonStrategy comparisonStrategy) {
+    return new ShouldContainSubsequence(actual, subsequence, subsequenceIndex, comparisonStrategy);
   }
 
-  /**
-   * Creates a new <code>{@link ShouldContainSubsequence}</code>.
-   * 
-   * @param actual the actual value in the failed assertion.
-   * @param subsequence the subsequence of values expected to be in {@code actual}.
-   * @return the created {@code ErrorMessageFactory}.
-   */
-  public static ErrorMessageFactory shouldContainSubsequence(Object actual, Object subsequence) {
-    return new ShouldContainSubsequence(actual, subsequence, StandardComparisonStrategy.instance());
+  private ShouldContainSubsequence(Object actual, Object subsequence, int subsequenceIndex,
+                                   ComparisonStrategy comparisonStrategy) {
+    // Failed to find token at subsequence index %s in actual:%n %s
+    super("%nExpecting actual to contain the specified subsequence but failed to find the element at subsequence index %s in actual"
+          + describeComparisonStrategy(comparisonStrategy) + ":%n"
+          + "subsequence element not found in actual:%n"
+          + "  %s%n"
+          + "actual:%n"
+          + "  %s%n"
+          + "subsequence:%n  %s",
+          subsequenceIndex, Array.get(subsequence, subsequenceIndex), actual, subsequence);
   }
 
-  private ShouldContainSubsequence(Object actual, Object subsequence, ComparisonStrategy comparisonStrategy) {
-    super("%nExpecting actual:%n  %s%nto contain subsequence:%n  %s%n%s", actual, subsequence, comparisonStrategy);
+  private static String describeComparisonStrategy(ComparisonStrategy comparisonStrategy) {
+    return comparisonStrategy == StandardComparisonStrategy.instance() ? ""
+        : " when comparing elements using " + comparisonStrategy;
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/Arrays.java b/src/main/java/org/assertj/core/internal/Arrays.java
index 6078c3320..5476ba9e8 100644
--- a/src/main/java/org/assertj/core/internal/Arrays.java
+++ b/src/main/java/org/assertj/core/internal/Arrays.java
@@ -43,6 +43,7 @@ import static org.assertj.core.error.ShouldContainNull.shouldContainNull;
 import static org.assertj.core.error.ShouldContainOnly.shouldContainOnly;
 import static org.assertj.core.error.ShouldContainOnlyNulls.shouldContainOnlyNulls;
 import static org.assertj.core.error.ShouldContainSequence.shouldContainSequence;
+import static org.assertj.core.error.ShouldContainSubsequence.actualDoesNotHaveEnoughElementsToContainSubsequence;
 import static org.assertj.core.error.ShouldContainSubsequence.shouldContainSubsequence;
 import static org.assertj.core.error.ShouldContainsOnlyOnce.shouldContainsOnlyOnce;
 import static org.assertj.core.error.ShouldEndWith.shouldEndWith;
@@ -71,6 +72,7 @@ import static org.assertj.core.internal.IterableDiff.diff;
 import static org.assertj.core.util.ArrayWrapperList.wrap;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Arrays.prepend;
+import static org.assertj.core.util.Arrays.sizeOf;
 import static org.assertj.core.util.IterableUtil.isNullOrEmpty;
 import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.Preconditions.checkArgument;
@@ -277,7 +279,7 @@ public class Arrays {
     assertIsArray(info, values);
 
     List<Object> actualAsList = asList(actual);
-    IterableDiff diff = diff(actualAsList, asList(values), comparisonStrategy);
+    IterableDiff<?> diff = diff(actualAsList, asList(values), comparisonStrategy);
     if (!diff.differencesFound()) {
       // actual and values have the same elements but are they in the same order ?
       int arrayLength = sizeOf(actual);
@@ -289,9 +291,7 @@ public class Arrays {
       }
       return;
     }
-    throw failures.failure(info,
-                           shouldContainExactly(actual, asList(values), diff.missing, diff.unexpected,
-                                                comparisonStrategy));
+    throw failures.failure(info, shouldContainExactly(actual, asList(values), diff.missing, diff.unexpected, comparisonStrategy));
   }
 
   void assertContainsExactlyInAnyOrder(AssertionInfo info, Failures failures, Object actual, Object values) {
@@ -308,8 +308,7 @@ public class Arrays {
 
     if (notExpected.isEmpty() && notFound.isEmpty()) return;
 
-    throw failures.failure(info,
-                           shouldContainExactlyInAnyOrder(actual, values, notFound, notExpected, comparisonStrategy));
+    throw failures.failure(info, shouldContainExactlyInAnyOrder(actual, values, notFound, notExpected, comparisonStrategy));
   }
 
   void assertContainsOnlyOnce(AssertionInfo info, Failures failures, Object actual, Object values) {
@@ -375,8 +374,7 @@ public class Arrays {
   private boolean containsSequenceAtGivenIndex(int actualStartIndex, Object actualArray, Object sequence) {
     int sequenceSize = sizeOf(sequence);
     for (int i = 0; i < sequenceSize; i++) {
-      if (areEqual(Array.get(sequence, i), Array.get(actualArray, i + actualStartIndex)))
-        continue;
+      if (areEqual(Array.get(sequence, i), Array.get(actualArray, i + actualStartIndex))) continue;
       return false;
     }
     return true;
@@ -387,21 +385,20 @@ public class Arrays {
 
     int sizeOfActual = sizeOf(actual);
     int sizeOfSubsequence = sizeOf(subsequence);
-    // look for given subsequence, stop check when there is not enough elements remaining in actual to contain
-    // subsequence
-    int lastIndexWhereEndOfSubsequenceCanBeFound = sizeOfActual - sizeOfSubsequence;
-
+    if (sizeOfActual < sizeOfSubsequence) {
+      throw failures.failure(info, actualDoesNotHaveEnoughElementsToContainSubsequence(actual, subsequence));
+    }
     int actualIndex = 0;
     int subsequenceIndex = 0;
-    while (actualIndex <= lastIndexWhereEndOfSubsequenceCanBeFound && subsequenceIndex < sizeOfSubsequence) {
+    while (actualIndex < sizeOfActual && subsequenceIndex < sizeOfSubsequence) {
       if (areEqual(Array.get(actual, actualIndex), Array.get(subsequence, subsequenceIndex))) {
         subsequenceIndex++;
-        lastIndexWhereEndOfSubsequenceCanBeFound++;
       }
       actualIndex++;
     }
-    if (subsequenceIndex < sizeOfSubsequence)
-      throw failures.failure(info, shouldContainSubsequence(actual, subsequence, comparisonStrategy));
+    if (subsequenceIndex < sizeOfSubsequence) { // only subsequenceIndex subsequence elements were found
+      throw failures.failure(info, shouldContainSubsequence(actual, subsequence, subsequenceIndex, comparisonStrategy));
+    }
   }
 
   void assertHasOnlyElementsOfTypes(AssertionInfo info, Failures failures, Object actual, Class<?>[] expectedTypes) {
@@ -771,11 +768,6 @@ public class Arrays {
     Objects.instance().assertNotNull(info, array);
   }
 
-  static int sizeOf(Object array) {
-    if (array instanceof Object[]) return ((Object[]) array).length;
-    return getLength(array);
-  }
-
   private static void failIfEmptySinceActualIsNotEmpty(Object values) {
     if (isArrayEmpty(values)) throw new AssertionError("actual is not empty while group of values to look for is.");
   }
diff --git a/src/main/java/org/assertj/core/internal/Arrays2D.java b/src/main/java/org/assertj/core/internal/Arrays2D.java
index 892f497f9..feca5382c 100644
--- a/src/main/java/org/assertj/core/internal/Arrays2D.java
+++ b/src/main/java/org/assertj/core/internal/Arrays2D.java
@@ -24,8 +24,8 @@ import static org.assertj.core.error.ShouldNotBeEmpty.shouldNotBeEmpty;
 import static org.assertj.core.error.ShouldNotContainAtIndex.shouldNotContainAtIndex;
 import static org.assertj.core.internal.Arrays.assertIsArray;
 import static org.assertj.core.internal.Arrays.assertNotNull;
-import static org.assertj.core.internal.Arrays.sizeOf;
 import static org.assertj.core.internal.CommonValidations.checkIndexValueIsValid;
+import static org.assertj.core.util.Arrays.sizeOf;
 
 import java.lang.reflect.Array;
 
diff --git a/src/main/java/org/assertj/core/internal/CommonValidations.java b/src/main/java/org/assertj/core/internal/CommonValidations.java
index bed6b72bb..851c34bbb 100644
--- a/src/main/java/org/assertj/core/internal/CommonValidations.java
+++ b/src/main/java/org/assertj/core/internal/CommonValidations.java
@@ -94,7 +94,7 @@ public final class CommonValidations {
   }
 
   public static void failIfEmptySinceActualIsNotEmpty(Object[] values) {
-    if (values.length == 0) throw new AssertionError("actual is not empty");
+    if (values.length == 0) throw new AssertionError("actual is not empty while group of values to look for is.");
   }
 
   public static void hasSameSizeAsCheck(AssertionInfo info, Object actual, Object other, int sizeOfActual) {
diff --git a/src/main/java/org/assertj/core/internal/Iterables.java b/src/main/java/org/assertj/core/internal/Iterables.java
index cf2c79bd4..3b7639e2f 100644
--- a/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/src/main/java/org/assertj/core/internal/Iterables.java
@@ -47,6 +47,7 @@ import static org.assertj.core.error.ShouldContainNull.shouldContainNull;
 import static org.assertj.core.error.ShouldContainOnly.shouldContainOnly;
 import static org.assertj.core.error.ShouldContainOnlyNulls.shouldContainOnlyNulls;
 import static org.assertj.core.error.ShouldContainSequence.shouldContainSequence;
+import static org.assertj.core.error.ShouldContainSubsequence.actualDoesNotHaveEnoughElementsToContainSubsequence;
 import static org.assertj.core.error.ShouldContainSubsequence.shouldContainSubsequence;
 import static org.assertj.core.error.ShouldContainsOnlyOnce.shouldContainsOnlyOnce;
 import static org.assertj.core.error.ShouldEndWith.shouldEndWith;
@@ -549,6 +550,9 @@ public class Iterables {
    */
   public void assertContainsSubsequence(AssertionInfo info, Iterable<?> actual, Object[] subsequence) {
     if (commonCheckThatIterableAssertionSucceeds(info, actual, subsequence)) return;
+    if (sizeOf(actual) < subsequence.length) {
+      throw failures.failure(info, actualDoesNotHaveEnoughElementsToContainSubsequence(actual, subsequence));
+    }
 
     Iterator<?> actualIterator = actual.iterator();
     int subsequenceIndex = 0;
@@ -558,12 +562,7 @@ public class Iterables {
       if (areEqual(actualNext, subsequenceNext)) subsequenceIndex++;
     }
 
-    if (subsequenceIndex < subsequence.length) throw actualDoesNotContainSubsequence(info, actual, subsequence);
-  }
-
-  public void assertContainsSubsequence(AssertionInfo info, Iterable<?> actual, List<?> subsequence) {
-    checkIsNotNull(subsequence);
-    assertContainsSubsequence(info, actual, subsequence.toArray());
+    if (subsequenceIndex < subsequence.length) throw actualDoesNotContainSubsequence(info, actual, subsequence, subsequenceIndex);
   }
 
   /**
@@ -644,13 +643,13 @@ public class Iterables {
     return failures.failure(info, shouldContainSequence(actual, sequence, comparisonStrategy));
   }
 
-  private AssertionError actualDoesContainSequence(AssertionInfo info, Iterable<?> actual, Object[] sequence,
-                                                   int index) {
+  private AssertionError actualDoesContainSequence(AssertionInfo info, Iterable<?> actual, Object[] sequence, int index) {
     return failures.failure(info, shouldNotContainSequence(actual, sequence, index, comparisonStrategy));
   }
 
-  private AssertionError actualDoesNotContainSubsequence(AssertionInfo info, Iterable<?> actual, Object[] subsequence) {
-    return failures.failure(info, shouldContainSubsequence(actual, subsequence, comparisonStrategy));
+  private AssertionError actualDoesNotContainSubsequence(AssertionInfo info, Iterable<?> actual, Object[] subsequence,
+                                                         int subsequenceIndex) {
+    return failures.failure(info, shouldContainSubsequence(actual, subsequence, subsequenceIndex, comparisonStrategy));
   }
 
   private AssertionError actualContainsSubsequence(AssertionInfo info, Iterable<?> actual, Object[] subsequence,
diff --git a/src/main/java/org/assertj/core/util/Arrays.java b/src/main/java/org/assertj/core/util/Arrays.java
index e3da9d035..e8418ca1f 100644
--- a/src/main/java/org/assertj/core/util/Arrays.java
+++ b/src/main/java/org/assertj/core/util/Arrays.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.core.util;
 
+import static java.lang.reflect.Array.getLength;
 import static java.util.Arrays.stream;
 import static java.util.Collections.emptyList;
 import static java.util.Objects.requireNonNull;
@@ -200,6 +201,10 @@ public class Arrays {
     return result;
   }
 
-  private Arrays() {}
+  public static int sizeOf(Object array) {
+    if (array instanceof Object[]) return ((Object[]) array).length;
+    return getLength(array);
+  }
 
+  private Arrays() {}
 }
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_containsSubsequence_List_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_containsSubsequence_List_Test.java
index 209de74fd..3095f9733 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_containsSubsequence_List_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_containsSubsequence_List_Test.java
@@ -46,9 +46,7 @@ class IterableAssert_containsSubsequence_List_Test extends IterableAssertBaseTes
 
   @Test
   void should_throw_error_if_subsequence_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> {
-      List<Object> nullList = null;
-      assertions.containsSubsequence(nullList);
-    }).withMessage(nullSubsequence());
+    List<Object> nullList = null;
+    assertThatNullPointerException().isThrownBy(() -> assertions.containsSubsequence(nullList)).withMessage(nullSubsequence());
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContainSubsequence_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainSubsequence_create_Test.java
index 0665e6460..4640a6ef9 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainSubsequence_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainSubsequence_create_Test.java
@@ -14,12 +14,15 @@ package org.assertj.core.error;
 
 import static java.lang.String.format;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainSubsequence.actualDoesNotHaveEnoughElementsToContainSubsequence;
 import static org.assertj.core.error.ShouldContainSubsequence.shouldContainSubsequence;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
 
 import org.assertj.core.description.TextDescription;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
-import org.assertj.core.presentation.StandardRepresentation;
+import org.assertj.core.internal.StandardComparisonStrategy;
 import org.assertj.core.util.CaseInsensitiveStringComparator;
 import org.junit.jupiter.api.Test;
 
@@ -31,24 +34,52 @@ import org.junit.jupiter.api.Test;
 class ShouldContainSubsequence_create_Test {
 
   @Test
-  void should_create_error_message() {
+  void should_create_error_message_when_actual_has_less_elements_then_subsequence() {
     // GIVEN
-    ErrorMessageFactory factory = shouldContainSubsequence(list("Yoda", "Luke"), list("Han", "Leia"));
+    ErrorMessageFactory factory = actualDoesNotHaveEnoughElementsToContainSubsequence(list("Yoda"), array("Yoda", "Leia"));
     // WHEN
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    String message = factory.create(new TextDescription("Test"), STANDARD_REPRESENTATION);
     // THEN
-    then(message).isEqualTo(format("[Test] %nExpecting actual:%n  [\"Yoda\", \"Luke\"]%nto contain subsequence:%n  [\"Han\", \"Leia\"]%n"));
+    then(message).isEqualTo(format("[Test] %nExpecting actual to contain the specified subsequence but actual does not have enough elements to contain it, actual size is 1 when subsequence size is 2%n"
+                                   + "actual:%n"
+                                   + "  [\"Yoda\"]%n"
+                                   + "subsequence:%n"
+                                   + "  [\"Yoda\", \"Leia\"]"));
+  }
+
+  @Test
+  void should_create_error_message_with_first_subsequence_element_not_found_and_its_index() {
+    // GIVEN
+    ErrorMessageFactory factory = shouldContainSubsequence(list("Yoda", "Luke"), array("Yoda", "Leia"), 1,
+                                                           StandardComparisonStrategy.instance());
+    // WHEN
+    String message = factory.create(new TextDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n"
+                                   + "Expecting actual to contain the specified subsequence but failed to find the element at subsequence index 1 in actual:%n"
+                                   + "subsequence element not found in actual:%n"
+                                   + "  \"Leia\"%n"
+                                   + "actual:%n"
+                                   + "  [\"Yoda\", \"Luke\"]%n"
+                                   + "subsequence:%n"
+                                   + "  [\"Yoda\", \"Leia\"]"));
   }
 
   @Test
   void should_create_error_message_with_custom_comparison_strategy() {
     // GIVEN
-    ErrorMessageFactory factory = shouldContainSubsequence(list("Yoda", "Luke"), list("Han", "Leia"),
+    ErrorMessageFactory factory = shouldContainSubsequence(list("Yoda", "Luke"), array("Yoda", "Leia"), 1,
                                                            new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     // WHEN
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    String message = factory.create(new TextDescription("Test"), STANDARD_REPRESENTATION);
     // THEN
-    then(message).isEqualTo(format("[Test] %nExpecting actual:%n  [\"Yoda\", \"Luke\"]%nto contain subsequence:%n  [\"Han\", \"Leia\"]%n"
-                                   + "when comparing values using CaseInsensitiveStringComparator"));
+    then(message).isEqualTo(format("[Test] %n"
+                                   + "Expecting actual to contain the specified subsequence but failed to find the element at subsequence index 1 in actual when comparing elements using CaseInsensitiveStringComparator:%n"
+                                   + "subsequence element not found in actual:%n"
+                                   + "  \"Leia\"%n"
+                                   + "actual:%n"
+                                   + "  [\"Yoda\", \"Luke\"]%n"
+                                   + "subsequence:%n"
+                                   + "  [\"Yoda\", \"Leia\"]"));
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/IterablesBaseTest.java b/src/test/java/org/assertj/core/internal/IterablesBaseTest.java
index e95855bba..c5dc16180 100644
--- a/src/test/java/org/assertj/core/internal/IterablesBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/IterablesBaseTest.java
@@ -33,6 +33,8 @@ import org.junit.jupiter.api.BeforeEach;
  */
 public class IterablesBaseTest {
 
+  protected static final AssertionInfo INFO = someInfo();
+
   protected List<String> actual;
   protected Failures failures;
   protected Iterables iterables;
diff --git a/src/test/java/org/assertj/core/internal/ObjectArraysBaseTest.java b/src/test/java/org/assertj/core/internal/ObjectArraysBaseTest.java
index c487afdbe..35bbf83c5 100644
--- a/src/test/java/org/assertj/core/internal/ObjectArraysBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/ObjectArraysBaseTest.java
@@ -12,11 +12,13 @@
  */
 package org.assertj.core.internal;
 
+import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
 import static org.mockito.Mockito.spy;
 
 import java.util.Comparator;
 
+import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.CaseInsensitiveStringComparator;
 import org.junit.jupiter.api.BeforeEach;
 
@@ -32,6 +34,8 @@ import org.junit.jupiter.api.BeforeEach;
  */
 public class ObjectArraysBaseTest {
 
+  protected static final AssertionInfo INFO = someInfo();
+
   /**
    * is initialized with {@link #initActualArray()}
    */
diff --git a/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsSubsequence_Test.java b/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsSubsequence_Test.java
index de468d959..edd3f465e 100644
--- a/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsSubsequence_Test.java
+++ b/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsSubsequence_Test.java
@@ -12,29 +12,27 @@
  */
 package org.assertj.core.internal.iterables;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainSubsequence.actualDoesNotHaveEnoughElementsToContainSubsequence;
 import static org.assertj.core.error.ShouldContainSubsequence.shouldContainSubsequence;
 import static org.assertj.core.internal.ErrorMessages.valuesToLookForIsNull;
-import static org.assertj.core.test.ObjectArrays.emptyArray;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Lists.list;
 import static org.mockito.Mockito.verify;
 
-import java.util.Collection;
-
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.IterablesBaseTest;
+import org.assertj.core.internal.StandardComparisonStrategy;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 /**
- * Tests for <code>{@link Iterables#assertContainsSubsequence(AssertionInfo, Collection, Object[])}</code>.
+ * Tests for <code>{@link Iterables#assertContainsSubsequence(AssertionInfo, Iterable, Object[])}</code>.
  * 
  * @author Marcin Mikosik
  */
@@ -44,15 +42,39 @@ class Iterables_assertContainsSubsequence_Test extends IterablesBaseTest {
   @BeforeEach
   public void setUp() {
     super.setUp();
-    actual = newArrayList("Yoda", "Luke", "Leia", "Obi-Wan");
+    actual = list("Yoda", "Luke", "Leia", "Obi-Wan");
   }
 
   @Test
-  void should_throw_error_if_subsequence_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> {
-      Object[] nullArray = null;
-      iterables.assertContainsSubsequence(someInfo(), actual, nullArray);
-    }).withMessage(valuesToLookForIsNull());
+  void should_pass_if_actual_contains_subsequence_without_elements_between() {
+    iterables.assertContainsSubsequence(someInfo(), actual, array("Luke", "Leia"));
+  }
+
+  @Test
+  void should_pass_if_actual_contains_subsequence_with_elements_between() {
+    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Leia"));
+  }
+
+  @Test
+  void should_pass_if_actual_with_duplicate_elements_contains_subsequence() {
+    actual = list("Yoda", "Luke", "Yoda", "Obi-Wan");
+    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Obi-Wan"));
+    iterables.assertContainsSubsequence(someInfo(), actual, array("Luke", "Obi-Wan"));
+    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Yoda"));
+  }
+
+  @Test
+  void should_pass_if_actual_and_subsequence_are_equal() {
+    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Luke", "Leia", "Obi-Wan"));
+  }
+
+  @Test
+  void should_pass_if_actual_contains_full_subsequence_even_if_partial_subsequence_is_found_before() {
+    // GIVEN
+    actual = list("Yoda", "Luke", "Leia", "Yoda", "Luke", "Obi-Wan");
+    // WHEN/THEN
+    // note that actual starts with {"Yoda", "Luke"} a partial sequence of {"Yoda", "Luke", "Obi-Wan"}
+    iterables.assertContainsSubsequence(INFO, actual, array("Yoda", "Luke", "Obi-Wan"));
   }
 
   @Test
@@ -61,118 +83,166 @@ class Iterables_assertContainsSubsequence_Test extends IterablesBaseTest {
     iterables.assertContainsSubsequence(someInfo(), actual, array());
   }
 
+  @Test
+  void should_throw_error_if_subsequence_is_null() {
+    // GIVEN
+    Object[] subsequence = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> iterables.assertContainsSubsequence(INFO, actual, subsequence),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage(valuesToLookForIsNull());
+  }
+
   @Test
   void should_fail_if_array_of_values_to_look_for_is_empty_and_actual_is_not() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> iterables.assertContainsSubsequence(someInfo(), actual, emptyArray()));
+    // GIVEN
+    Object[] subsequence = {};
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterables.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    then(assertionError).hasMessage("actual is not empty while group of values to look for is.");
   }
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> iterables.assertContainsSubsequence(someInfo(), null, array("Yoda")))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterables.assertContainsSubsequence(INFO, actual, array("Yoda")));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_fail_if_subsequence_is_bigger_than_actual() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     Object[] subsequence = { "Luke", "Leia", "Obi-Wan", "Han", "C-3PO", "R2-D2", "Anakin" };
-
-    Throwable error = catchThrowable(() -> iterables.assertContainsSubsequence(info, actual, subsequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence);
+    // WHEN
+    expectAssertionError(() -> iterables.assertContainsSubsequence(info, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, actualDoesNotHaveEnoughElementsToContainSubsequence(actual, subsequence));
   }
 
   @Test
   void should_fail_if_actual_does_not_contain_whole_subsequence() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     Object[] subsequence = { "Han", "C-3PO" };
-
-    Throwable error = catchThrowable(() -> iterables.assertContainsSubsequence(info, actual, subsequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence);
+    // WHEN
+    expectAssertionError(() -> iterables.assertContainsSubsequence(info, actual, subsequence));
+    // THEN
+    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence, 0);
   }
 
   @Test
   void should_fail_if_actual_contains_first_elements_of_subsequence_but_not_whole_subsequence() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     Object[] subsequence = { "Luke", "Leia", "Han" };
+    // WHEN
+    expectAssertionError(() -> iterables.assertContainsSubsequence(info, actual, subsequence));
+    // THEN
+    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence, 2);
+  }
 
-    Throwable error = catchThrowable(() -> iterables.assertContainsSubsequence(info, actual, subsequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence);
+  @Test
+  void should_fail_if_actual_does_not_have_enough_elements_left_to_contain_subsequence_elements_still_to_be_matched() {
+    // GIVEN
+    actual = list("Leia", "Luke", "Yoda", "Obi-Wan", "Anakin");
+    Object[] subsequence = { "Leia", "Obi-Wan", "Han" };
+    // WHEN
+    expectAssertionError(() -> iterables.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence, 2);
   }
 
-  private void verifyFailureThrownWhenSubsequenceNotFound(AssertionInfo info, Object[] subsequence) {
-    verify(failures).failure(info, shouldContainSubsequence(actual, subsequence));
+  private void verifyFailureThrownWhenSubsequenceNotFound(AssertionInfo info, Object[] subsequence, int subsequenceIndex) {
+    verify(failures).failure(info, shouldContainSubsequence(actual, subsequence, subsequenceIndex,
+                                                            StandardComparisonStrategy.instance()));
   }
 
+  // ------------------------------------------------------------------------------------------------------------------
+  // tests using a custom comparison strategy
+  // ------------------------------------------------------------------------------------------------------------------
+
   @Test
-  void should_pass_if_actual_contains_subsequence_without_elements_between() {
-    iterables.assertContainsSubsequence(someInfo(), actual, array("Luke", "Leia"));
+  void should_pass_if_actual_contains_subsequence_according_to_custom_comparison_strategy() {
+    iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(), actual, array("yODa", "leia"));
   }
 
   @Test
-  void should_pass_if_actual_contains_subsequence_with_elements_between() {
-    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Leia"));
+  void should_pass_if_actual_and_subsequence_are_equal_according_to_custom_comparison_strategy() {
+    iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(), actual,
+                                                                             array("YODA", "luke", "lEIA", "Obi-wan"));
   }
 
   @Test
-  void should_pass_if_actual_with_duplicate_elements_contains_subsequence() {
-    actual = newArrayList("Yoda", "Luke", "Yoda", "Obi-Wan");
-    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Obi-Wan"));
-    iterables.assertContainsSubsequence(someInfo(), actual, array("Luke", "Obi-Wan"));
-    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Yoda"));
+  void should_fail_if_actual_is_null_whatever_custom_comparison_strategy_is() {
+    // GIVEN
+    actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO,
+                                                                                                                                        actual,
+                                                                                                                                        array("Yoda")));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
-  void should_pass_if_actual_and_subsequence_are_equal() {
-    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Luke", "Leia", "Obi-Wan"));
+  void should_throw_error_if_subsequence_is_null_whatever_custom_comparison_strategy_is() {
+    // GIVEN
+    Object[] subsequence = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO,
+                                                                                                                                   actual,
+                                                                                                                                   subsequence),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage(valuesToLookForIsNull());
   }
 
   @Test
-  void should_pass_if_actual_contains_both_partial_and_complete_subsequence() {
-    actual = newArrayList("Yoda", "Luke", "Yoda", "Obi-Wan");
-    iterables.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Obi-Wan"));
+  void should_fail_if_array_of_values_to_look_for_is_empty_and_actual_is_not_whatever_custom_comparison_strategy_is() {
+    // GIVEN
+    Object[] subsequence = {};
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO,
+                                                                                                                                        actual,
+                                                                                                                                        subsequence));
+    // THEN
+    then(assertionError).hasMessage("actual is not empty while group of values to look for is.");
   }
 
-  // ------------------------------------------------------------------------------------------------------------------
-  // tests using a custom comparison strategy
-  // ------------------------------------------------------------------------------------------------------------------
+  @Test
+  void should_fail_if_subsequence_is_bigger_than_actual_according_to_custom_comparison_strategy() {
+    // GIVEN
+    Object[] subsequence = { "LUKE", "LeiA", "Obi-Wan", "Han", "C-3PO", "R2-D2", "Anakin" };
+    // WHEN
+    expectAssertionError(() -> iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, actual,
+                                                                                                        subsequence));
+    // THEN
+    verify(failures).failure(INFO, actualDoesNotHaveEnoughElementsToContainSubsequence(actual, subsequence));
+  }
 
   @Test
   void should_fail_if_actual_does_not_contain_whole_subsequence_according_to_custom_comparison_strategy() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     Object[] subsequence = { "Han", "C-3PO" };
-
-    Throwable error = catchThrowable(() -> iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(info, actual, subsequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldContainSubsequence(actual, subsequence, comparisonStrategy));
+    // WHEN
+    expectAssertionError(() -> iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(info, actual,
+                                                                                                        subsequence));
+    // THEN
+    verify(failures).failure(info, shouldContainSubsequence(actual, subsequence, 0, comparisonStrategy));
   }
 
   @Test
   void should_fail_if_actual_contains_first_elements_of_subsequence_but_not_whole_subsequence_according_to_custom_comparison_strategy() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     Object[] subsequence = { "Luke", "Leia", "Han" };
-
-    Throwable error = catchThrowable(() -> iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(info, actual, subsequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info, shouldContainSubsequence(actual, subsequence, comparisonStrategy));
-  }
-
-  @Test
-  void should_pass_if_actual_contains_subsequence_according_to_custom_comparison_strategy() {
-    iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(), actual, array("yODa", "leia"));
-  }
-
-  @Test
-  void should_pass_if_actual_and_subsequence_are_equal_according_to_custom_comparison_strategy() {
-    iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(someInfo(), actual,
-        array("YODA", "luke", "lEIA", "Obi-wan"));
+    // WHEN
+    expectAssertionError(() -> iterablesWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(info, actual,
+                                                                                                        subsequence));
+    // THEN
+    verify(failures).failure(info, shouldContainSubsequence(actual, subsequence, 2, comparisonStrategy));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsSubsequence_Test.java b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsSubsequence_Test.java
index 75b14fab5..67ed78908 100644
--- a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsSubsequence_Test.java
+++ b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsSubsequence_Test.java
@@ -12,21 +12,22 @@
  */
 package org.assertj.core.internal.objectarrays;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatNullPointerException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainSubsequence.actualDoesNotHaveEnoughElementsToContainSubsequence;
 import static org.assertj.core.error.ShouldContainSubsequence.shouldContainSubsequence;
 import static org.assertj.core.internal.ErrorMessages.valuesToLookForIsNull;
 import static org.assertj.core.test.ObjectArrays.emptyArray;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.mockito.Mockito.verify;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.ObjectArrays;
 import org.assertj.core.internal.ObjectArraysBaseTest;
+import org.assertj.core.internal.StandardComparisonStrategy;
 import org.junit.jupiter.api.Test;
 
 /**
@@ -42,145 +43,188 @@ class ObjectArrays_assertContainsSubsequence_Test extends ObjectArraysBaseTest {
   }
 
   @Test
-  void should_pass_if_actual_contains_sequence() {
-    arrays.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Leia"));
+  void should_pass_if_actual_contains_subsequence_with_elements_between() {
+    arrays.assertContainsSubsequence(INFO, actual, array("Yoda", "Leia"));
   }
 
   @Test
-  void should_pass_if_actual_and_sequence_are_equal() {
-    arrays.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Luke", "Leia", "Obi-Wan"));
+  void should_pass_if_actual_contains_subsequence_without_elements_between() {
+    arrays.assertContainsSubsequence(someInfo(), actual, array("Luke", "Leia"));
   }
 
   @Test
-  void should_pass_if_actual_contains_full_sequence_even_if_partial_sequence_is_found_before() {
+  void should_pass_if_actual_and_subsequence_are_equal() {
+    arrays.assertContainsSubsequence(INFO, actual, array("Yoda", "Luke", "Leia", "Obi-Wan"));
+  }
+
+  @Test
+  void should_pass_if_actual_contains_full_subsequence_even_if_partial_subsequence_is_found_before() {
+    // GIVEN
     actual = array("Yoda", "Luke", "Leia", "Yoda", "Luke", "Obi-Wan");
+    // WHEN/THEN
     // note that actual starts with {"Yoda", "Luke"} a partial sequence of {"Yoda", "Luke", "Obi-Wan"}
-    arrays.assertContainsSubsequence(someInfo(), actual, array("Yoda", "Luke", "Obi-Wan"));
+    arrays.assertContainsSubsequence(INFO, actual, array("Yoda", "Luke", "Obi-Wan"));
   }
 
   @Test
   void should_pass_if_actual_and_given_values_are_empty() {
+    // GIVEN
     actual = new String[0];
-    arrays.assertContainsSubsequence(someInfo(), actual, emptyArray());
+    // WHEN/THEN
+    arrays.assertContainsSubsequence(INFO, actual, emptyArray());
   }
 
   @Test
   void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> arrays.assertContainsSubsequence(someInfo(), null, array("Yoda")))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> arrays.assertContainsSubsequence(INFO, actual, array("Yoda")));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
-  void should_throw_error_if_sequence_is_null() {
-    assertThatNullPointerException().isThrownBy(() -> arrays.assertContainsSubsequence(someInfo(), actual, null))
-                                    .withMessage(valuesToLookForIsNull());
+  void should_throw_error_if_subsequence_is_null() {
+    // GIVEN
+    Object[] subsequence = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> arrays.assertContainsSubsequence(INFO, actual, subsequence),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage(valuesToLookForIsNull());
   }
 
   @Test
   void should_fail_if_array_of_values_to_look_for_is_empty_and_actual_is_not() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> arrays.assertContainsSubsequence(someInfo(), actual, emptyArray()));
+    // GIVEN
+    Object[] subsequence = {};
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> arrays.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    then(assertionError).hasMessage("actual is not empty while group of values to look for is.");
   }
 
   @Test
   void should_fail_if_subsequence_is_bigger_than_actual() {
-    AssertionInfo info = someInfo();
+    // GIVEN
     Object[] subsequence = { "Luke", "Leia", "Obi-Wan", "Han", "C-3PO", "R2-D2", "Anakin" };
+    // WHEN
+    expectAssertionError(() -> arrays.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, actualDoesNotHaveEnoughElementsToContainSubsequence(actual, subsequence));
+  }
 
-    Throwable error = catchThrowable(() -> arrays.assertContainsSubsequence(info, actual, subsequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence);
+  @Test
+  void should_fail_if_actual_contains_first_elements_of_subsequence_but_not_whole_subsequence() {
+    // GIVEN
+    Object[] subsequence = { "Luke", "Leia", "Han" };
+    // WHEN
+    expectAssertionError(() -> arrays.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, 2, StandardComparisonStrategy.instance()));
   }
 
   @Test
   void should_fail_if_actual_does_not_contain_whole_subsequence() {
-    AssertionInfo info = someInfo();
-    Object[] subsequence = { "Han", "C-3PO" };
-
-    Throwable error = catchThrowable(() -> arrays.assertContainsSubsequence(info, actual, subsequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence);
+    // GIVEN
+    Object[] subsequence = { "Luke", "C-3PO" };
+    // WHEN
+    expectAssertionError(() -> arrays.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, 1, StandardComparisonStrategy.instance()));
   }
 
   @Test
-  void should_fail_if_actual_contains_first_elements_of_subsequence() {
-    AssertionInfo info = someInfo();
+  void should_fail_if_actual_does_not_have_enough_elements_left_to_contain_subsequence_elements_still_to_be_matched() {
+    // GIVEN
+    actual = array("Leia", "Luke", "Yoda", "Obi-Wan", "Anakin");
     Object[] subsequence = { "Leia", "Obi-Wan", "Han" };
+    // WHEN
+    expectAssertionError(() -> arrays.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, 2, StandardComparisonStrategy.instance()));
+  }
 
-    Throwable error = catchThrowable(() -> arrays.assertContainsSubsequence(info, actual, subsequence));
+  // ------------------------------------------------------------------------------------------------------------------
+  // tests using a custom comparison strategy
+  // ------------------------------------------------------------------------------------------------------------------
 
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verifyFailureThrownWhenSubsequenceNotFound(info, subsequence);
+  @Test
+  void should_pass_if_actual_contains_subsequence_according_to_custom_comparison_strategy() {
+    arraysWithCustomComparisonStrategy.assertContainsSubsequence(INFO, actual, array("LUKE", "LeiA"));
   }
 
-  private void verifyFailureThrownWhenSubsequenceNotFound(AssertionInfo info, Object[] sequence) {
-    verify(failures).failure(info, shouldContainSubsequence(actual, sequence));
+  @Test
+  void should_pass_if_actual_and_subsequence_are_equal_according_to_custom_comparison_strategy() {
+    arraysWithCustomComparisonStrategy.assertContainsSubsequence(INFO, actual, array("YOda", "LUKE", "LeiA", "Obi-WAn"));
   }
 
   @Test
   void should_fail_if_actual_is_null_whatever_custom_comparison_strategy_is() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(someInfo(), null, array("YOda")))
-                                                   .withMessage(actualIsNull());
+    // GIVEN
+    actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(INFO,
+                                                                                                                            actual,
+                                                                                                                            array("Yoda")));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
   void should_throw_error_if_subsequence_is_null_whatever_custom_comparison_strategy_is() {
-    assertThatNullPointerException().isThrownBy(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(someInfo(),
-                                                                                                                   actual,
-                                                                                                                   null))
-                                    .withMessage(valuesToLookForIsNull());
+    // GIVEN
+    Object[] subsequence = null;
+    // WHEN
+    NullPointerException npe = catchThrowableOfType(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(INFO,
+                                                                                                                       actual,
+                                                                                                                       subsequence),
+                                                    NullPointerException.class);
+    // THEN
+    then(npe).hasMessage(valuesToLookForIsNull());
   }
 
   @Test
   void should_fail_if_array_of_values_to_look_for_is_empty_and_actual_is_not_whatever_custom_comparison_strategy_is() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(someInfo(), actual, emptyArray()));
+    // GIVEN
+    Object[] subsequence = {};
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(INFO,
+                                                                                                                            actual,
+                                                                                                                            subsequence));
+    // THEN
+    then(assertionError).hasMessage("actual is not empty while group of values to look for is.");
   }
 
   @Test
-  void should_fail_if_sequence_is_bigger_than_actual_according_to_custom_comparison_strategy() {
-    AssertionInfo info = someInfo();
+  void should_fail_if_subsequence_is_bigger_than_actual_according_to_custom_comparison_strategy() {
+    // GIVEN
     Object[] subsequence = { "LUKE", "LeiA", "Obi-Wan", "Han", "C-3PO", "R2-D2", "Anakin" };
-
-    Throwable error = catchThrowable(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(info, actual, subsequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info,
-        shouldContainSubsequence(actual, subsequence, caseInsensitiveStringComparisonStrategy));
+    // WHEN
+    expectAssertionError(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, actualDoesNotHaveEnoughElementsToContainSubsequence(actual, subsequence));
   }
 
   @Test
-  void should_fail_if_actual_does_not_contain_whole_subsequence_according_to_custom_comparison_strategy() {
-    AssertionInfo info = someInfo();
-    Object[] sequence = { "Han", "C-3PO" };
-
-    Throwable error = catchThrowable(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(info, actual, sequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info,
-        shouldContainSubsequence(actual, sequence, caseInsensitiveStringComparisonStrategy));
+  void should_fail_if_actual_does_not_contain_any_subsequence_elements_according_to_custom_comparison_strategy() {
+    // GIVEN
+    Object[] subsequence = { "Han", "C-3PO" };
+    // WHEN
+    expectAssertionError(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, 0, caseInsensitiveStringComparisonStrategy));
   }
 
   @Test
   void should_fail_if_actual_contains_first_elements_of_subsequence_according_to_custom_comparison_strategy() {
-    AssertionInfo info = someInfo();
-    Object[] sequence = { "LeiA", "Obi-Wan", "Han" };
-
-    Throwable error = catchThrowable(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(info, actual, sequence));
-
-    assertThat(error).isInstanceOf(AssertionError.class);
-    verify(failures).failure(info,
-        shouldContainSubsequence(actual, sequence, caseInsensitiveStringComparisonStrategy));
-  }
-
-  @Test
-  void should_pass_if_actual_contains_sequence_according_to_custom_comparison_strategy() {
-    arraysWithCustomComparisonStrategy.assertContainsSubsequence(someInfo(), actual, array("LUKE", "LeiA"));
-  }
-
-  @Test
-  void should_pass_if_actual_and_sequence_are_equal_according_to_custom_comparison_strategy() {
-    arraysWithCustomComparisonStrategy.assertContainsSubsequence(someInfo(), actual,
-        array("YOda", "LUKE", "LeiA", "Obi-WAn"));
+    // GIVEN
+    actual = array("Yoda", "Luke", "Leia", "Obi-Wan");
+    Object[] subsequence = { "LeiA", "Obi-Wan", "Han" };
+    // WHEN
+    expectAssertionError(() -> arraysWithCustomComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, 2, caseInsensitiveStringComparisonStrategy));
   }
 }
