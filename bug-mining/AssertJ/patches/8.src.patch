diff --git a/pom.xml b/pom.xml
index d82c0f273..e403e9be3 100644
--- a/pom.xml
+++ b/pom.xml
@@ -1,5 +1,6 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd ">
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd ">
 
   <modelVersion>4.0.0</modelVersion>
   <artifactId>assertj-core</artifactId>
diff --git a/src/main/java/org/assertj/core/api/AbstractAssert.java b/src/main/java/org/assertj/core/api/AbstractAssert.java
index 22c2ccc77..ffe4ad83d 100644
--- a/src/main/java/org/assertj/core/api/AbstractAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractAssert.java
@@ -297,7 +297,8 @@ public abstract class AbstractAssert<S extends AbstractAssert<S, A>, A> implemen
    * @throws exception see {@link String#format(String, Object...)} exception clause.
    */
   public S overridingErrorMessage(String newErrorMessage, Object... args) {
-    info.overridingErrorMessage(format(newErrorMessage, args));
+    String format = format(newErrorMessage, args);
+    info.overridingErrorMessage(format);
     return myself;
   }
 
diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 111bf0624..7771b6e1f 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -19,10 +19,11 @@ import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
 
-import org.assertj.core.groups.Properties;
+import org.assertj.core.groups.FieldsOrPropertiesExtractor;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.Iterables;
 import org.assertj.core.util.VisibleForTesting;
+import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
  * Base class for implementations of <code>{@link ObjectEnumerableAssert}</code> whose actual value type is
@@ -276,15 +277,17 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
   }
 
   /**
-   * Extract the values of given property from the Iterable under test into a new Iterable, this new Iterable is now the
-   * Iterable under test.
+   * Extract the values of given field or property from the Iterable's elements under test into a new Iterable, this new
+   * Iterable becoming the Iterable under test.
    * <p>
-   * It allows you to test a property of a collection instead of testing the collection elements.
+   * It allows you to test a field/property of the the Iterable's elements instead of testing the elements themselves,
+   * it can be sometimes much less work !
    * <p>
-   * Let's take an example to make things clearer.
+   * Let's take an example to make things clearer :
    * 
    * <pre>
-   * // Create a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
+   * // Build a list of TolkienCharacter, a TolkienCharacter has a name, and age and a Race (a specific class)
+   * // they can be public field or properties, both works when extracting their values.
    * List&lt;TolkienCharacter&gt; fellowshipOfTheRing = new ArrayList&lt;TolkienCharacter&gt;();
    * 
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT));
@@ -294,29 +297,37 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Pippin&quot;, 28, HOBBIT));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF));
    * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN);
-   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN));
+   * fellowshipOfTheRing.add(new TolkienCharacter(&quot;Boromir&quot;, 37, MAN));
    * 
-   * // let's verify the names of TolkienCharacter's name in fellowshipOfTheRing :
+   * // let's verify the names of TolkienCharacter in fellowshipOfTheRing :
    * 
    * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;)
    *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
    *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
    *         
-   * // you can extract nested property like the name of Race :
+   * // you can extract nested field/property like the name of Race :
    * 
    * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;)
    *           .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
    *           .doesNotContain(&quot;Orc&quot;);
    * </pre>
    * 
-   * Note that the order of extracted property values is consistent with the iteration order of the Iterable under test,
-   * for example if it's a {@link HashSet}, you can't make any assumptions of the extracted values order.
+   * A field with the given name is looked for first, if it is not accessible (ie. does not exist or is not public),
+   * then a property with the given name is looked for.
+   * <p>
+   * It only works if all objects have the field or all objects have the property with the given name, i.e. it won't
+   * work if half of the objects have the field and the other the property.
+   * <p>
+   * Note that the order of extracted field/property values is consistent with the iteration order of the Iterable under
+   * test, for example if it's a {@link HashSet}, you won't be able to make any assumptions of the extracted values
+   * order.
    * 
-   * @param property the property to extract from the Iterable under test
-   * @return a new assertion object whose object under test is the list of extracted property values.
+   * @param fieldOrProperty the field/property to extract from the Iterable under test
+   * @return a new assertion object whose object under test is the list of extracted field/property values.
+   * @throws IntrospectionError if no field or property exists with the given name (or field exists but is not public)
    */
-  public ListAssert<Object> extracting(String property) {
-    List<Object> values = Properties.extractProperty(property).from(actual);
+  public ListAssert<Object> extracting(String fieldOrProperty) {
+    List<Object> values = FieldsOrPropertiesExtractor.extract(fieldOrProperty, actual);
     return new ListAssert<Object>(values);
   }
 
diff --git a/src/main/java/org/assertj/core/api/ObjectArrayAssert.java b/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
index 3382656b5..624b5e1d6 100644
--- a/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/ObjectArrayAssert.java
@@ -1,14 +1,14 @@
 /*
  * Created on Jul 26, 2010
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2010-2011 the original author or authors.
  */
@@ -17,15 +17,18 @@ package org.assertj.core.api;
 import java.util.Comparator;
 
 import org.assertj.core.data.Index;
-import org.assertj.core.internal.*;
+import org.assertj.core.groups.FieldsOrPropertiesExtractor;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.ObjectArrays;
 import org.assertj.core.util.VisibleForTesting;
-
+import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
  * Assertion methods for arrays of objects.
  * <p>
  * To create an instance of this class, invoke <code>{@link Assertions#assertThat(T[])}</code>.
  * </p>
+ * 
  * @param <T> the type of elements of the "actual" value.
  * 
  * @author Yvonne Wang
@@ -274,4 +277,56 @@ public class ObjectArrayAssert<T> extends AbstractAssert<ObjectArrayAssert<T>, T
     return myself;
   }
 
+  /**
+   * Extract the values of given field or property from the array's elements under test into a new array, this new array
+   * becoming the array under test.
+   * <p>
+   * It allows you to test a field/property of the array's elements instead of testing the elements themselves, it can
+   * be sometimes much less work !
+   * <p>
+   * Let's take an example to make things clearer :
+   * 
+   * <pre>
+   * // Build a array of TolkienCharacter, a TolkienCharacter has a name (String) and a Race (a class)
+   * // they can be public field or properties, both works when extracting their values.
+   * TolkienCharacter[] fellowshipOfTheRing = new TolkienCharacter[] {
+   *   new TolkienCharacter(&quot;Frodo&quot;, 33, HOBBIT),
+   *   new TolkienCharacter(&quot;Sam&quot;, 38, HOBBIT),
+   *   new TolkienCharacter(&quot;Gandalf&quot;, 2020, MAIA),
+   *   new TolkienCharacter(&quot;Legolas&quot;, 1000, ELF),
+   *   new TolkienCharacter(&quot;Pippin&quot;, 28, HOBBIT),
+   *   new TolkienCharacter(&quot;Gimli&quot;, 139, DWARF),
+   *   new TolkienCharacter(&quot;Aragorn&quot;, 87, MAN,
+   *   new TolkienCharacter(&quot;Boromir&quot;, 37, MAN)
+   * };
+   * 
+   * // let's verify the names of TolkienCharacter in fellowshipOfTheRing :
+   * 
+   * assertThat(fellowshipOfTheRing).extracting(&quot;name&quot;)
+   *           .contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;)
+   *           .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
+   *         
+   * // you can also extract nested field/property like the name of Race :
+   * 
+   * assertThat(fellowshipOfTheRing).extracting(&quot;race.name&quot;)
+   *           .contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
+   *           .doesNotContain(&quot;Orc&quot;);
+   * </pre>
+   * 
+   * A field with the given name is looked for first, if it is not accessible (ie. does not exist or is not public)
+   * then a property with the given name is looked for.
+   * <p>
+   * It works only if all objects have the field or all objects have the property with the given name, i.e. it won't
+   * work if half of the objects have the field and the other the property.
+   * <p>
+   * Note that the order of extracted field/property values is consistent with the array order.
+   * 
+   * @param fieldOrProperty the field/property to extract from the array under test
+   * @return a new assertion object whose object under test is the array of extracted field/property values.
+   * @throws IntrospectionError if no field or property exists with the given name (or field exists but is not public)
+   */
+  public ObjectArrayAssert<Object> extracting(String fieldOrProperty) {
+    Object[] values = FieldsOrPropertiesExtractor.extract(fieldOrProperty, actual);
+    return new ObjectArrayAssert<Object>(values);
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/ObjectAssert.java b/src/main/java/org/assertj/core/api/ObjectAssert.java
index a6b1d6136..638aa53a8 100644
--- a/src/main/java/org/assertj/core/api/ObjectAssert.java
+++ b/src/main/java/org/assertj/core/api/ObjectAssert.java
@@ -14,7 +14,7 @@
  */
 package org.assertj.core.api;
 
-import org.assertj.core.util.IntrospectionError;
+import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
  * Assertion methods for {@code Object}s.
diff --git a/src/main/java/org/assertj/core/api/filter/Filters.java b/src/main/java/org/assertj/core/api/filter/Filters.java
index 96a7d2c18..9218acdae 100644
--- a/src/main/java/org/assertj/core/api/filter/Filters.java
+++ b/src/main/java/org/assertj/core/api/filter/Filters.java
@@ -22,8 +22,8 @@ import java.util.List;
 
 import org.assertj.core.api.Condition;
 import org.assertj.core.internal.PropertySupport;
-import org.assertj.core.util.IntrospectionError;
 import org.assertj.core.util.VisibleForTesting;
+import org.assertj.core.util.introspection.IntrospectionError;
 
 
 /**
diff --git a/src/main/java/org/assertj/core/groups/FieldsOrPropertiesExtractor.java b/src/main/java/org/assertj/core/groups/FieldsOrPropertiesExtractor.java
new file mode 100644
index 000000000..b4498669f
--- /dev/null
+++ b/src/main/java/org/assertj/core/groups/FieldsOrPropertiesExtractor.java
@@ -0,0 +1,65 @@
+package org.assertj.core.groups;
+
+import static java.lang.String.format;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.api.AbstractIterableAssert;
+import org.assertj.core.internal.PropertySupport;
+import org.assertj.core.util.Lists;
+import org.assertj.core.util.introspection.FieldSupport;
+import org.assertj.core.util.introspection.IntrospectionError;
+
+/**
+ * 
+ * Understands how to retrieve fields or properties values from a collection/array of objects.
+ * <p>
+ * You just have to give the field/property name, a collection/array of objects and it will extract the list of
+ * field/property values from the given objects.
+ * 
+ * @author Joel Costigliola
+ * 
+ */
+public class FieldsOrPropertiesExtractor {
+
+  /**
+   * Call {@link #extract(String, Iterable)} after converting objects to an iterable.
+   * <p>
+   * Behavior is described in javadoc {@link AbstractIterableAssert#extracting(String)}
+   */
+  public static Object[] extract(String fieldOrPropertyName, Object[] objects) {
+    ArrayList<Object> newArrayList = Lists.newArrayList(objects);
+    List<Object> extractedValues = extract(fieldOrPropertyName, newArrayList);
+    return extractedValues.toArray();
+  }
+  
+  /**
+   * Behavior is described in {@link AbstractIterableAssert#extracting(String)}
+   */
+  public static List<Object> extract(String fieldOrPropertyName, Iterable<?> objects) {
+    if (fieldOrPropertyName == null)
+      throw new IllegalArgumentException("The name of the field/property to read should not be null");
+    if (fieldOrPropertyName.length() == 0)
+      throw new IllegalArgumentException("The name of the field/property to read should not be empty");
+    if (objects == null)
+      throw new IllegalArgumentException("The objects to extract field/property from should not be null");
+
+    // first try to get given field values from objects, then try properties
+    try {
+      return FieldSupport.instance().fieldValues(fieldOrPropertyName, objects);
+    } catch (IntrospectionError fieldIntrospectionError) {
+      // no luck with fields, let's try properties
+      try {
+        return PropertySupport.instance().propertyValues(fieldOrPropertyName, objects);
+      } catch (IntrospectionError propertyIntrospectionError) {
+        // no field nor property found with given name, it is considered as an error
+        String message = format("\nCan't find any field or property with name '%s'.\nError when introspecting fields was :\n- %s \nError when introspecting properties was :\n- %s",
+                                fieldOrPropertyName, fieldIntrospectionError.getMessage(),
+                                propertyIntrospectionError.getMessage());
+        throw new IntrospectionError(message);
+      }
+    }
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/groups/Properties.java b/src/main/java/org/assertj/core/groups/Properties.java
index c30ecaf9e..a53d80a29 100644
--- a/src/main/java/org/assertj/core/groups/Properties.java
+++ b/src/main/java/org/assertj/core/groups/Properties.java
@@ -19,8 +19,8 @@ import static org.assertj.core.util.ArrayWrapperList.wrap;
 import java.util.List;
 
 import org.assertj.core.internal.PropertySupport;
-import org.assertj.core.util.IntrospectionError;
 import org.assertj.core.util.VisibleForTesting;
+import org.assertj.core.util.introspection.IntrospectionError;
 
 
 
diff --git a/src/main/java/org/assertj/core/internal/Objects.java b/src/main/java/org/assertj/core/internal/Objects.java
index 49025b6ae..029418787 100644
--- a/src/main/java/org/assertj/core/internal/Objects.java
+++ b/src/main/java/org/assertj/core/internal/Objects.java
@@ -45,8 +45,8 @@ import java.util.List;
 import java.util.Set;
 
 import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.util.IntrospectionError;
 import org.assertj.core.util.VisibleForTesting;
+import org.assertj.core.util.introspection.IntrospectionError;
 
 
 /**
diff --git a/src/main/java/org/assertj/core/internal/PropertySupport.java b/src/main/java/org/assertj/core/internal/PropertySupport.java
index 6755c3bbe..f75d1770a 100644
--- a/src/main/java/org/assertj/core/internal/PropertySupport.java
+++ b/src/main/java/org/assertj/core/internal/PropertySupport.java
@@ -16,16 +16,16 @@ package org.assertj.core.internal;
 
 import static java.lang.String.format;
 import static java.util.Collections.*;
-import static org.assertj.core.util.Introspection.getProperty;
 import static org.assertj.core.util.Iterables.isNullOrEmpty;
 import static org.assertj.core.util.Iterables.nonNullElementsIn;
+import static org.assertj.core.util.introspection.Introspection.getProperty;
 
 import java.beans.PropertyDescriptor;
 import java.util.ArrayList;
 import java.util.List;
 
-import org.assertj.core.util.IntrospectionError;
 import org.assertj.core.util.VisibleForTesting;
+import org.assertj.core.util.introspection.IntrospectionError;
 
 
 /**
@@ -182,4 +182,11 @@ public class PropertySupport {
     return propertyValue(propertyName, clazz, target);
   }
 
+  /**
+   * just delegates to {@link #propertyValues(String, Class, Iterable)} with Class being Object.class
+   */
+  public List<Object> propertyValues(String fieldOrPropertyName, Iterable<?> objects) {
+    return propertyValues(fieldOrPropertyName, Object.class, objects);
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/util/introspection/ClassUtils.java b/src/main/java/org/assertj/core/util/introspection/ClassUtils.java
new file mode 100644
index 000000000..0fc33ea4b
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/introspection/ClassUtils.java
@@ -0,0 +1,53 @@
+package org.assertj.core.util.introspection;
+
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.List;
+
+public class ClassUtils {
+
+  /**
+   * <p>
+   * Gets a {@code List} of all interfaces implemented by the given class and its superclasses.
+   * </p>
+   * 
+   * <p>
+   * The order is determined by looking through each interface in turn as declared in the source file and following its
+   * hierarchy up. Then each superclass is considered in the same way. Later duplicates are ignored, so the order is
+   * maintained.
+   * </p>
+   * 
+   * @param cls the class to look up, may be {@code null}
+   * @return the {@code List} of interfaces in order, {@code null} if null input
+   */
+  static List<Class<?>> getAllInterfaces(Class<?> cls) {
+    if (cls == null) return null;
+  
+    LinkedHashSet<Class<?>> interfacesFound = new LinkedHashSet<Class<?>>();
+    getAllInterfaces(cls, interfacesFound);
+  
+    return new ArrayList<Class<?>>(interfacesFound);
+  }
+
+  /**
+   * Get the interfaces for the specified class.
+   * 
+   * @param cls the class to look up, may be {@code null}
+   * @param interfacesFound the {@code Set} of interfaces for the class
+   */
+  static void getAllInterfaces(Class<?> cls, HashSet<Class<?>> interfacesFound) {
+    while (cls != null) {
+      Class<?>[] interfaces = cls.getInterfaces();
+  
+      for (Class<?> i : interfaces) {
+        if (interfacesFound.add(i)) {
+          getAllInterfaces(i, interfacesFound);
+        }
+      }
+  
+      cls = cls.getSuperclass();
+    }
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
new file mode 100644
index 000000000..e4f395a2e
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
@@ -0,0 +1,215 @@
+/*
+ * Created on Jun 26, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static java.lang.String.format;
+import static java.util.Collections.emptyList;
+import static java.util.Collections.unmodifiableList;
+
+import static org.assertj.core.util.ArrayWrapperList.wrap;
+import static org.assertj.core.util.Iterables.isNullOrEmpty;
+import static org.assertj.core.util.Iterables.nonNullElementsIn;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.util.VisibleForTesting;
+
+/**
+ * Utility methods for fields access.
+ * 
+ * @author Joel Costigliola
+ */
+public class FieldSupport {
+
+  private static final String SEPARATOR = ".";
+
+  private static final FieldSupport INSTANCE = new FieldSupport();
+
+  /**
+   * Returns the singleton instance of this class.
+   * 
+   * @return the singleton instance of this class.
+   */
+  public static FieldSupport instance() {
+    return INSTANCE;
+  }
+
+  @VisibleForTesting
+  FieldSupport() {
+  }
+
+  /**
+   * Returns a <code>{@link List}</code> containing the values of the given field name, from the elements of the given
+   * <code>{@link Iterable}</code>. If the given {@code Iterable} is empty or {@code null}, this method will return an
+   * empty {@code List}. This method supports nested fields (e.g. "address.street.number").
+   * 
+   * @param fieldName the name of the field. It may be a nested field. It is left to the clients to validate for
+   *          {@code null} or empty.
+   * @param fieldClass the expected type of the given field.
+   * @param target the given {@code Iterable}.
+   * @return an {@code Iterable} containing the values of the given field name, from the elements of the given
+   *         {@code Iterable}.
+   * @throws IntrospectionError if an element in the given {@code Iterable} does not have a field with a matching name.
+   */
+  public <T> List<T> fieldValues(String fieldName, Class<T> fieldClass, Iterable<?> target) {
+    // ignore null elements as we can't extract a field from a null object
+    Iterable<?> cleanedUp = nonNullElementsIn(target);
+    if (isNullOrEmpty(cleanedUp)) {
+      return emptyList();
+    }
+    if (isNestedField(fieldName)) {
+      String firstFieldName = popFieldNameFrom(fieldName);
+      Iterable<Object> fieldValues = fieldValues(firstFieldName, Object.class, cleanedUp);
+      // extract next sub-field values until reaching the last sub-field
+      return fieldValues(nextFieldNameFrom(fieldName), fieldClass, fieldValues);
+    }
+    return simpleFieldValues(fieldName, fieldClass, cleanedUp);
+  }
+
+  public List<Object> fieldValues(String fieldName, Iterable<?>  target) {
+    return fieldValues(fieldName, Object.class, target);
+  }
+  
+  /**
+   * Returns a <code>{@link List}</code> containing the values of the given field name, from the elements of the given
+   * <code>{@link Iterable}</code>. If the given {@code Iterable} is empty or {@code null}, this method will return an
+   * empty {@code List}. This method supports nested fields (e.g. "address.street.number").
+   * 
+   * @param fieldName the name of the field. It may be a nested field. It is left to the clients to validate for
+   *          {@code null} or empty.
+   * @param fieldClass the expected type of the given field.
+   * @param target the given {@code Iterable}.
+   * @return an {@code Iterable} containing the values of the given field name, from the elements of the given
+   *         {@code Iterable}.
+   * @throws IntrospectionError if an element in the given {@code Iterable} does not have a field with a matching name.
+   */
+  public <T> List<T> fieldValues(String fieldName, Class<T> fieldClass, Object[] target) {
+    return fieldValues(fieldName, fieldClass, wrap(target));
+  }
+  
+  public List<Object> fieldValues(String fieldName, Object[] target) {
+    return fieldValues(fieldName, Object.class, wrap(target));
+  }
+  
+  /**
+   * Static variant of {@link #fieldValue(String, Class, Object)} for syntactic sugar.
+   * <p>
+   * 
+   * @param fieldName the name of the field. It may be a nested field. It is left to the clients to validate for
+   *          {@code null} or empty.
+   * @param target the given object
+   * @return a the values of the given field name
+   * @throws IntrospectionError if the given target does not have a field with a matching name.
+   */
+  public static <T> T fieldValueOf(String fieldName, Object target, Class<T> clazz) {
+    return instance().fieldValue(fieldName, clazz, target);
+  }
+
+  private <T> List<T> simpleFieldValues(String fieldName, Class<T> clazz, Iterable<?> target) {
+    List<T> fieldValues = new ArrayList<T>();
+    for (Object e : target) {
+      fieldValues.add(fieldValue(fieldName, clazz, e));
+    }
+    return unmodifiableList(fieldValues);
+  }
+
+  private String popFieldNameFrom(String fieldNameChain) {
+    if (!isNestedField(fieldNameChain)) {
+      return fieldNameChain;
+    }
+    return fieldNameChain.substring(0, fieldNameChain.indexOf(SEPARATOR));
+  }
+
+  private String nextFieldNameFrom(String fieldNameChain) {
+    if (!isNestedField(fieldNameChain)) {
+      return "";
+    }
+    return fieldNameChain.substring(fieldNameChain.indexOf(SEPARATOR) + 1);
+  }
+
+  /**
+   * <pre>
+   * isNestedField(&quot;address.street&quot;); // true
+   * isNestedField(&quot;address.street.name&quot;); // true
+   * isNestedField(&quot;person&quot;); // false
+   * isNestedField(&quot;.name&quot;); // false
+   * isNestedField(&quot;person.&quot;); // false
+   * isNestedField(&quot;person.name.&quot;); // false
+   * isNestedField(&quot;.person.name&quot;); // false
+   * isNestedField(&quot;.&quot;); // false
+   * isNestedField(&quot;&quot;); // false
+   * </pre>
+   */
+  private boolean isNestedField(String fieldName) {
+    return fieldName.contains(SEPARATOR) && !fieldName.startsWith(SEPARATOR) && !fieldName.endsWith(SEPARATOR);
+  }
+
+  /**
+   * Return the value of field from a target object.
+   * 
+   * @param fieldName the name of the field. It may be a nested field. It is left to the clients to validate for
+   *          {@code null} or empty.
+   * @param target the given object
+   * @param clazz type of field
+   * @return a the values of the given field name
+   * @throws IntrospectionError if the given target does not have a field with a matching name.
+   */
+  public <T> T fieldValue(String fieldName, Class<T> clazz, Object target) {
+    try {
+      Object readField = FieldUtils.readField(target, fieldName);
+      return clazz.cast(readField);
+    } catch (ClassCastException e) {
+      String msg = format("Unable to obtain the value of the field <'%s'> from <%s> - wrong field type specified <%s>",
+                          fieldName, target, clazz);
+      throw new IntrospectionError(msg, e);
+    } catch (IllegalAccessException iae) {
+      String msg = format("Unable to obtain the value of the field <'%s'> from <%s>, check that field is public.",
+                          fieldName, target);
+      throw new IntrospectionError(msg, iae);
+    } catch (Throwable unexpected) {
+      String msg = format("Unable to obtain the value of the field <'%s'> from <%s>", fieldName, target);
+      throw new IntrospectionError(msg, unexpected);
+    }
+  }
+
+  /**
+   * Returns the value of the given field name given target. If the given object is {@code null}, this method will
+   * return null.<br>
+   * This method supports nested fields (e.g. "address.street.number").
+   * 
+   * @param fieldName the name of the field. It may be a nested field. It is left to the clients to validate for
+   *          {@code null} or empty.
+   * @param clazz the class of field.
+   * @param target the given Object to extract field from.
+   * @return the value of the given field name given target.
+   * @throws IntrospectionError if target object does not have a field with a matching name.
+   */
+  public <T> T fieldValueOf(String fieldName, Class<T> clazz, Object target) {
+    // returns null if target is null as we can't extract a field from a null object
+    if (target == null) {
+      return null;
+    }
+
+    if (isNestedField(fieldName)) {
+      String firstFieldName = popFieldNameFrom(fieldName);
+      Object fieldValue = fieldValue(firstFieldName, Object.class, target);
+      // extract next sub-field values until reaching the last sub-field
+      return fieldValueOf(nextFieldNameFrom(fieldName), clazz, fieldValue);
+    }
+    return fieldValue(fieldName, clazz, target);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/util/introspection/FieldUtils.java b/src/main/java/org/assertj/core/util/introspection/FieldUtils.java
new file mode 100644
index 000000000..7ca6017a0
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/introspection/FieldUtils.java
@@ -0,0 +1,256 @@
+package org.assertj.core.util.introspection;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE
+ * file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file
+ * to You under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ */
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+
+
+/**
+ * Shameless copy from Apache commons lang and then modified to keep only the interesting stuff for AssertJ.
+ * 
+ * Utilities for working with fields by reflection. Adapted and refactored from the dormant [reflect] Commons sandbox
+ * component.
+ * <p>
+ * The ability is provided to break the scoping restrictions coded by the programmer. This can allow fields to be
+ * changed that shouldn't be. This facility should be used with care.
+ * 
+ * @since 2.5
+ * @version $Id: FieldUtils.java 1144929 2011-07-10 18:26:16Z ggregory $
+ */
+public class FieldUtils {
+
+  /**
+   * FieldUtils instances should NOT be constructed in standard programming.
+   * <p>
+   * This constructor is public to permit tools that require a JavaBean instance to operate.
+   */
+  public FieldUtils() {
+    super();
+  }
+
+  /**
+   * Gets an accessible <code>Field</code> by name breaking scope if requested. Superclasses/interfaces will be
+   * considered.
+   * 
+   * @param cls the class to reflect, must not be null
+   * @param fieldName the field name to obtain
+   * @param forceAccess whether to break scope restrictions using the <code>setAccessible</code> method.
+   *          <code>False</code> will only match public fields.
+   * @return the Field object
+   * @throws IllegalArgumentException if the class or field name is null
+   * @throws IllegalAccessException if field exists but is not public
+   */
+  static Field getField(final Class<?> cls, String fieldName, boolean forceAccess) throws IllegalAccessException {
+    if (cls == null) {
+      throw new IllegalArgumentException("The class must not be null");
+    }
+    if (fieldName == null) {
+      throw new IllegalArgumentException("The field name must not be null");
+    }
+    // Sun Java 1.3 has a bugged implementation of getField hence we write the
+    // code ourselves
+
+    // getField() will return the Field object with the declaring class
+    // set correctly to the class that declares the field. Thus requesting the
+    // field on a subclass will return the field from the superclass.
+    //
+    // priority order for lookup:
+    // searchclass private/protected/package/public
+    // superclass protected/package/public
+    // private/different package blocks access to further superclasses
+    // implementedinterface public
+
+    // check up the superclass hierarchy
+    for (Class<?> acls = cls; acls != null; acls = acls.getSuperclass()) {
+      try {
+        Field field = acls.getDeclaredField(fieldName);
+        // getDeclaredField checks for non-public scopes as well
+        // and it returns accurate results
+        if (!Modifier.isPublic(field.getModifiers())) {
+          if (forceAccess) {
+            field.setAccessible(true);
+          } else {
+            throw new IllegalAccessException("can not access" + fieldName + " because it is not public");
+          }
+        }
+        return field;
+      } catch (NoSuchFieldException ex) { // NOPMD
+        // ignore
+      }
+    }
+    // check the public interface case. This must be manually searched for
+    // incase there is a public supersuperclass field hidden by a private/package
+    // superclass field.
+    Field match = null;
+    for (Class<?> class1 : ClassUtils.getAllInterfaces(cls)) {
+      try {
+        Field test = ((Class<?>) class1).getField(fieldName);
+        if (match != null) {
+          throw new IllegalArgumentException("Reference to field " + fieldName + " is ambiguous relative to " + cls
+              + "; a matching field exists on two or more implemented interfaces.");
+        }
+        match = test;
+      } catch (NoSuchFieldException ex) { // NOPMD
+        // ignore
+      }
+    }
+    return match;
+  }
+
+  /**
+   * Gets an accessible <code>Field</code> by name breaking scope if requested. Only the specified class will be
+   * considered.
+   * 
+   * @param cls the class to reflect, must not be null
+   * @param fieldName the field name to obtain
+   * @param forceAccess whether to break scope restrictions using the <code>setAccessible</code> method. False will only
+   *          match public fields.
+   * @return the Field object
+   * @throws IllegalArgumentException if the class or field name is null
+   */
+  static Field getDeclaredField(Class<?> cls, String fieldName, boolean forceAccess) {
+    if (cls == null) {
+      throw new IllegalArgumentException("The class must not be null");
+    }
+    if (fieldName == null) {
+      throw new IllegalArgumentException("The field name must not be null");
+    }
+    try {
+      // only consider the specified class by using getDeclaredField()
+      Field field = cls.getDeclaredField(fieldName);
+      if (!MemberUtils.isAccessible(field)) {
+        if (forceAccess) {
+          field.setAccessible(true);
+        } else {
+          return null;
+        }
+      }
+      return field;
+    } catch (NoSuchFieldException e) { // NOPMD
+      // ignore
+    }
+    return null;
+  }
+
+  /**
+   * Reads an accessible Field.
+   * 
+   * @param field the field to use
+   * @param target the object to call on, may be null for static fields
+   * @return the field value
+   * @throws IllegalArgumentException if the field is null
+   * @throws IllegalAccessException if the field is not accessible
+   */
+  private static Object readField(Field field, Object target) throws IllegalAccessException {
+    return readField(field, target, false);
+  }
+
+  /**
+   * Reads a Field.
+   * 
+   * @param field the field to use
+   * @param target the object to call on, may be null for static fields
+   * @param forceAccess whether to break scope restrictions using the <code>setAccessible</code> method.
+   * @return the field value
+   * @throws IllegalArgumentException if the field is null
+   * @throws IllegalAccessException if the field is not made accessible
+   */
+  private static Object readField(Field field, Object target, boolean forceAccess) throws IllegalAccessException {
+    if (field == null) {
+      throw new IllegalArgumentException("The field must not be null");
+    }
+    if (forceAccess && !field.isAccessible()) {
+      field.setAccessible(true);
+    } else {
+      MemberUtils.setAccessibleWorkaround(field);
+    }
+    return field.get(target);
+  }
+
+  /**
+   * Reads the named public field. Superclasses will be considered.
+   * 
+   * @param target the object to reflect, must not be null
+   * @param fieldName the field name to obtain
+   * @return the value of the field
+   * @throws IllegalArgumentException if the class or field name is null
+   * @throws IllegalAccessException if the named field is not public
+   */
+  static Object readField(Object target, String fieldName) throws IllegalAccessException {
+    return readField(target, fieldName, false);
+  }
+
+  /**
+   * Reads the named field. Superclasses will be considered.
+   * 
+   * @param target the object to reflect, must not be null
+   * @param fieldName the field name to obtain
+   * @param forceAccess whether to break scope restrictions using the <code>setAccessible</code> method.
+   *          <code>False</code> will only match public fields.
+   * @return the field value
+   * @throws IllegalArgumentException if the class or field name is null
+   * @throws IllegalAccessException if the named field is not made accessible
+   */
+  static Object readField(Object target, String fieldName, boolean forceAccess) throws IllegalAccessException {
+    if (target == null) {
+      throw new IllegalArgumentException("target object must not be null");
+    }
+    Class<?> cls = target.getClass();
+    Field field = getField(cls, fieldName, forceAccess);
+    if (field == null) {
+      throw new IllegalArgumentException("Cannot locate field " + fieldName + " on " + cls);
+    }
+    // already forced access above, don't repeat it here:
+    return readField(field, target);
+  }
+
+  /**
+   * Reads the named public field. Only the class of the specified object will be considered.
+   * 
+   * @param target the object to reflect, must not be null
+   * @param fieldName the field name to obtain
+   * @return the value of the field
+   * @throws IllegalArgumentException if the class or field name is null
+   * @throws IllegalAccessException if the named field is not public
+   */
+  static Object readDeclaredField(Object target, String fieldName) throws IllegalAccessException {
+    return readDeclaredField(target, fieldName, false);
+  }
+
+  /**
+   * <p<>Gets a Field value by name. Only the class of the specified object will be considered.
+   * 
+   * @param target the object to reflect, must not be null
+   * @param fieldName the field name to obtain
+   * @param forceAccess whether to break scope restrictions using the <code>setAccessible</code> method.
+   *          <code>False</code> will only match public fields.
+   * @return the Field object
+   * @throws IllegalArgumentException if <code>target</code> or <code>fieldName</code> is null
+   * @throws IllegalAccessException if the field is not made accessible
+   */
+  static Object readDeclaredField(Object target, String fieldName, boolean forceAccess)
+      throws IllegalAccessException {
+    if (target == null) {
+      throw new IllegalArgumentException("target object must not be null");
+    }
+    Class<?> cls = target.getClass();
+    Field field = getDeclaredField(cls, fieldName, forceAccess);
+    if (field == null) {
+      throw new IllegalArgumentException("Cannot locate declared field " + cls.getName() + "." + fieldName);
+    }
+    // already forced access above, don't repeat it here:
+    return readField(field, target);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/util/Introspection.java b/src/main/java/org/assertj/core/util/introspection/Introspection.java
similarity index 98%
rename from src/main/java/org/assertj/core/util/Introspection.java
rename to src/main/java/org/assertj/core/util/introspection/Introspection.java
index 66aad712a..016f60b8e 100644
--- a/src/main/java/org/assertj/core/util/Introspection.java
+++ b/src/main/java/org/assertj/core/util/introspection/Introspection.java
@@ -12,7 +12,7 @@
  * 
  * Copyright @2010-2012 the original author or authors.
  */
-package org.assertj.core.util;
+package org.assertj.core.util.introspection;
 
 import static java.lang.String.format;
 import static java.lang.reflect.Modifier.isPublic;
@@ -23,6 +23,7 @@ import static org.assertj.core.util.Strings.quote;
 import java.beans.*;
 import java.lang.reflect.Method;
 
+
 /**
  * Utility methods related to <a
  * href="http://java.sun.com/docs/books/tutorial/javabeans/introspection/index.html">JavaBeans Introspection</a>.
diff --git a/src/main/java/org/assertj/core/util/IntrospectionError.java b/src/main/java/org/assertj/core/util/introspection/IntrospectionError.java
similarity index 96%
rename from src/main/java/org/assertj/core/util/IntrospectionError.java
rename to src/main/java/org/assertj/core/util/introspection/IntrospectionError.java
index 9a48abb36..4878c06de 100644
--- a/src/main/java/org/assertj/core/util/IntrospectionError.java
+++ b/src/main/java/org/assertj/core/util/introspection/IntrospectionError.java
@@ -12,7 +12,7 @@
  * 
  * Copyright @2010-2011 the original author or authors.
  */
-package org.assertj.core.util;
+package org.assertj.core.util.introspection;
 
 /**
  * Error that occurred when using <a href="http://java.sun.com/docs/books/tutorial/javabeans/introspection/index.html">JavaBeans
diff --git a/src/main/java/org/assertj/core/util/introspection/MemberUtils.java b/src/main/java/org/assertj/core/util/introspection/MemberUtils.java
new file mode 100644
index 000000000..7383c0cfb
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/introspection/MemberUtils.java
@@ -0,0 +1,83 @@
+package org.assertj.core.util.introspection;
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+import java.lang.reflect.AccessibleObject;
+import java.lang.reflect.Member;
+import java.lang.reflect.Modifier;
+
+/**
+ * Shameless copy from Apache commons lang and then modified to keep only the interesting stuff for AssertJ.
+ * 
+ * Contains common code for working with Methods/Constructors, extracted and
+ * refactored from <code>MethodUtils</code> when it was imported from Commons
+ * BeanUtils.
+ *
+ * @since 2.5
+ * @version $Id: MemberUtils.java 1143537 2011-07-06 19:30:22Z joehni $
+ */
+abstract class MemberUtils {
+
+    private static final int ACCESS_TEST = Modifier.PUBLIC | Modifier.PROTECTED | Modifier.PRIVATE;
+
+    /**
+     * XXX Default access superclass workaround
+     *
+     * When a public class has a default access superclass with public members,
+     * these members are accessible. Calling them from compiled code works fine.
+     * Unfortunately, on some JVMs, using reflection to invoke these members
+     * seems to (wrongly) prevent access even when the modifier is public.
+     * Calling setAccessible(true) solves the problem but will only work from
+     * sufficiently privileged code. Better workarounds would be gratefully
+     * accepted.
+     * @param o the AccessibleObject to set as accessible
+     */
+    static void setAccessibleWorkaround(AccessibleObject o) {
+        if (o == null || o.isAccessible()) {
+            return;
+        }
+        Member m = (Member) o;
+        if (Modifier.isPublic(m.getModifiers())
+                && isPackageAccess(m.getDeclaringClass().getModifiers())) {
+            try {
+                o.setAccessible(true);
+            } catch (SecurityException e) { // NOPMD
+                // ignore in favor of subsequent IllegalAccessException
+            }
+        }
+    }
+
+    /**
+     * Returns whether a given set of modifiers implies package access.
+     * @param modifiers to test
+     * @return true unless package/protected/private modifier detected
+     */
+    static boolean isPackageAccess(int modifiers) {
+        return (modifiers & ACCESS_TEST) == 0;
+    }
+
+    /**
+     * Returns whether a Member is accessible.
+     * @param m Member to check
+     * @return true if <code>m</code> is accessible
+     */
+    static boolean isAccessible(Member m) {
+        return m != null && Modifier.isPublic(m.getModifiers()) && !m.isSynthetic();
+    }
+
+ }
diff --git a/src/test/java/org/assertj/core/api/filter/AbstractTest_equals_filter.java b/src/test/java/org/assertj/core/api/filter/AbstractTest_equals_filter.java
index bbd0d6436..c8c026f22 100644
--- a/src/test/java/org/assertj/core/api/filter/AbstractTest_equals_filter.java
+++ b/src/test/java/org/assertj/core/api/filter/AbstractTest_equals_filter.java
@@ -6,7 +6,8 @@ import static org.assertj.core.api.filter.Filters.filter;
 import static org.junit.Assert.fail;
 
 import org.assertj.core.test.Player;
-import org.assertj.core.util.IntrospectionError;
+import org.assertj.core.util.introspection.IntrospectionError;
+
 import org.junit.Test;
 
 
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_on_differents_properties_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_on_differents_properties_Test.java
index 09db24b53..c41ab1bff 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_on_differents_properties_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_on_differents_properties_Test.java
@@ -7,7 +7,8 @@ import static org.assertj.core.api.filter.Filters.filter;
 
 import static org.junit.Assert.fail;
 
-import org.assertj.core.util.IntrospectionError;
+import org.assertj.core.util.introspection.IntrospectionError;
+
 import org.junit.Test;
 
 
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_with_property_in_given_values_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_with_property_in_given_values_Test.java
index 8931f0f64..484fd4028 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_with_property_in_given_values_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_with_property_in_given_values_Test.java
@@ -8,7 +8,8 @@ import static org.assertj.core.api.filter.Filters.filter;
 import static org.junit.Assert.fail;
 
 import org.assertj.core.test.Player;
-import org.assertj.core.util.IntrospectionError;
+import org.assertj.core.util.introspection.IntrospectionError;
+
 import org.junit.Test;
 
 
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_equals_to_given_value_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_equals_to_given_value_Test.java
index 1d30caa68..93c7241e6 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_equals_to_given_value_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_equals_to_given_value_Test.java
@@ -8,7 +8,8 @@ import static org.assertj.core.api.filter.Filters.filter;
 import static org.junit.Assert.fail;
 
 import org.assertj.core.test.Player;
-import org.assertj.core.util.IntrospectionError;
+import org.assertj.core.util.introspection.IntrospectionError;
+
 import org.junit.Test;
 
 
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_in_given_values_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_in_given_values_Test.java
index 2408a6121..7d07f9107 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_in_given_values_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_in_given_values_Test.java
@@ -8,7 +8,8 @@ import static org.assertj.core.api.filter.Filters.filter;
 import static org.junit.Assert.fail;
 
 import org.assertj.core.test.Player;
-import org.assertj.core.util.IntrospectionError;
+import org.assertj.core.util.introspection.IntrospectionError;
+
 import org.junit.Test;
 
 
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
index 79c493b33..e0fa80541 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
@@ -26,6 +26,7 @@ import org.assertj.core.api.AbstractIterableAssert;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
+import org.assertj.core.util.introspection.IntrospectionError;
 
 
 /**
@@ -52,10 +53,13 @@ public class IterableAssert_extracting_Test {
 
   @Test
   public void should_allow_assertions_on_property_values_extracted_from_given_iterable() throws Exception {
-    // test various property types
+    assertThat(employees).extracting("age").containsOnly(800, 26);
+  }
+  
+  @Test
+  public void should_allow_assertions_on_field_values_extracted_from_given_iterable() throws Exception {
     // basic types
     assertThat(employees).extracting("id").containsOnly(1L, 2L);
-    assertThat(employees).extracting("age").containsOnly(800, 26);
     // object
     assertThat(employees).extracting("name").containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
     // nested property
@@ -63,8 +67,9 @@ public class IterableAssert_extracting_Test {
   }
   
   @Test
-  public void should_throw_IAE_if_property_can_not_be_extracted() throws Exception {
-    
+  public void should_throw_error_if_no_property_nor_field_with_given_name_can_be_extracted() throws Exception {
+    thrown.expect(IntrospectionError.class);
+    assertThat(employees).extracting("unknown");
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java
new file mode 100644
index 000000000..686ddfbdb
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_extracting_Test.java
@@ -0,0 +1,74 @@
+/*
+ * Created on Sep 30, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.api.objectarray;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Arrays.array;
+
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+
+import org.assertj.core.api.AbstractIterableAssert;
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.test.Name;
+import org.assertj.core.util.introspection.IntrospectionError;
+
+
+/**
+ * Tests for <code>{@link AbstractIterableAssert#extracting(String)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class ObjectArrayAssert_extracting_Test {
+
+  private static Employee yoda;
+  private static Employee luke;
+  private static Employee[] employees;
+
+  @Rule
+  public ExpectedException thrown = none();
+  
+  @BeforeClass
+  public static void setUpOnce() {
+    yoda = new Employee(1L, new Name("Yoda"), 800);
+    luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+    employees = array(yoda, luke);
+  }
+
+  @Test
+  public void should_allow_assertions_on_property_values_extracted_from_given_iterable() throws Exception {
+    assertThat(employees).extracting("age").containsOnly(800, 26);
+  }
+  
+  @Test
+  public void should_allow_assertions_on_field_values_extracted_from_given_iterable() throws Exception {
+    // basic types
+    assertThat(employees).extracting("id").containsOnly(1L, 2L);
+    // object
+    assertThat(employees).extracting("name").containsOnly(new Name("Yoda"), new Name("Luke", "Skywalker"));
+    // nested property
+    assertThat(employees).extracting("name.first").containsOnly("Yoda", "Luke");
+  }
+  
+  @Test
+  public void should_throw_error_if_no_property_nor_field_with_given_name_can_be_extracted() throws Exception {
+    thrown.expect(IntrospectionError.class);
+    assertThat(employees).extracting("unknown");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java
new file mode 100644
index 000000000..4bdd6c1af
--- /dev/null
+++ b/src/test/java/org/assertj/core/groups/FieldsOrPropertiesExtractor_extract_test.java
@@ -0,0 +1,79 @@
+/*
+ * Created on Jul 27, 2012
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2011 the original author or authors.
+ */
+package org.assertj.core.groups;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.groups.FieldsOrPropertiesExtractor.extract;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.List;
+
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.test.Name;
+import org.assertj.core.util.introspection.IntrospectionError;
+
+public class FieldsOrPropertiesExtractor_extract_test {
+  
+  @Rule
+  public ExpectedException thrown = none();
+  
+  private static Employee yoda;
+  private static Employee luke;
+  private static List<Employee> employees;
+
+  
+  @BeforeClass
+  public static void setUpOnce() {
+    yoda = new Employee(1L, new Name("Yoda"), 800);
+    luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+    employees = newArrayList(yoda, luke);
+  }
+
+  @Test
+  public void should_extract_field_values_even_if_property_exist() {
+    List<Object> extractedValues = extract("id", employees);
+    assertThat(extractedValues).containsOnly(1L, 2L);
+  }
+  
+  @Test
+  public void should_extract_property_values_when_no_public_field_match_given_name() {
+    List<Object> extractedValues = extract("age", employees);
+    assertThat(extractedValues).containsOnly(800, 26);
+  }
+  
+  @Test
+  public void should_throw_error_when_no_property_nor_public_field_match_given_name() {
+    thrown.expect(IntrospectionError.class);
+    extract("unknown", employees);
+  }
+  
+  @Test
+  public void should_throw_exception_when_given_name_is_null() {
+    thrown.expectIllegalArgumentException("The name of the field/property to read should not be null");
+    extract(null, employees);
+  }
+  
+  @Test
+  public void should_throw_exception_when_given_name_is_empty() {
+    thrown.expectIllegalArgumentException("The name of the field/property to read should not be empty");
+    extract("", employees);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
index 622c6a936..24a844af1 100644
--- a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
+++ b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_Test.java
@@ -17,22 +17,21 @@ package org.assertj.core.internal;
 import static java.util.Collections.emptyList;
 import static java.util.Collections.emptySet;
 import static junit.framework.Assert.assertEquals;
+
 import static org.assertj.core.test.ExpectedException.none;
 import static org.assertj.core.util.Lists.newArrayList;
 
-
 import java.util.Collection;
 import java.util.List;
 
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
 
-import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
-import org.assertj.core.util.IntrospectionError;
-import org.junit.BeforeClass;
-import org.junit.Rule;
-import org.junit.Test;
+import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
  * Tests for <code>{@link PropertySupport#propertyValues(String, Collection)}</code>.
@@ -91,6 +90,16 @@ public class PropertySupport_propertyValues_Test {
     assertEquals(newArrayList(6000L, 8000L), ids);
   }
 
+  @Test
+  public void should_return_values_of_simple_property_as_objects() {
+    Iterable<Long> ids = propertySupport.propertyValues("id", Long.class, employees);
+    Iterable<Object> idsAsObjects = propertySupport.propertyValues("id", employees);
+    assertEquals(idsAsObjects, ids);
+    Iterable<String> firstNames = propertySupport.propertyValues("name.first", String.class, employees);
+    Iterable<Object> firstNamesAsObjects = propertySupport.propertyValues("name.first", employees);
+    assertEquals(firstNamesAsObjects, firstNames);
+  }
+  
   @Test
   public void should_return_values_of_nested_property() {
     Iterable<String> firstNames = propertySupport.propertyValues("name.first", String.class, employees);
diff --git a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
index 2588b1d56..23096c641 100644
--- a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
+++ b/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
@@ -15,8 +15,9 @@
 package org.assertj.core.internal;
 
 import static junit.framework.Assert.*;
-import static org.assertj.core.util.Introspection.getProperty;
 import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.introspection.Introspection.getProperty;
+
 import static org.junit.Assert.fail;
 import static org.mockito.Mockito.*;
 
@@ -27,7 +28,8 @@ import java.util.*;
 import org.assertj.core.internal.JavaBeanDescriptor;
 import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.test.Name;
-import org.assertj.core.util.IntrospectionError;
+import org.assertj.core.util.introspection.IntrospectionError;
+
 import org.junit.*;
 
 /**
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByAcceptingFields_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByAcceptingFields_Test.java
index 3302e6a58..cea3ccf7c 100644
--- a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByAcceptingFields_Test.java
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsLenientEqualsToByAcceptingFields_Test.java
@@ -33,7 +33,8 @@ import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.ObjectsBaseTest;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Jedi;
-import org.assertj.core.util.IntrospectionError;
+import org.assertj.core.util.introspection.IntrospectionError;
+
 import org.junit.Test;
 
 
diff --git a/src/test/java/org/assertj/core/test/Employee.java b/src/test/java/org/assertj/core/test/Employee.java
index 21530323a..b660b40b5 100644
--- a/src/test/java/org/assertj/core/test/Employee.java
+++ b/src/test/java/org/assertj/core/test/Employee.java
@@ -18,11 +18,15 @@ import static java.lang.String.format;
 
 /**
  * @author Yvonne Wang
+ * @author Joel Costigliola
  */
 public class Employee {
 
-  private long id;
-  private Name name;
+  // intentionnaly public to test field retrieval
+  // getter have been created to test property retrieval
+  public long id;
+  public Name name;
+  // keep private to test we are able to read property but not field
   private int age;
 
   public Employee() {}
diff --git a/src/test/java/org/assertj/core/test/ExpectedException.java b/src/test/java/org/assertj/core/test/ExpectedException.java
index e069888b0..93f243c6d 100644
--- a/src/test/java/org/assertj/core/test/ExpectedException.java
+++ b/src/test/java/org/assertj/core/test/ExpectedException.java
@@ -57,7 +57,7 @@ public class ExpectedException implements TestRule {
     expect(UnsupportedOperationException.class, message);
   }
 
-  private void expect(Class<? extends Throwable> type, String message) {
+  public void expect(Class<? extends Throwable> type, String message) {
     expect(type);
     expectMessage(message);
   }
diff --git a/src/test/java/org/assertj/core/test/Name.java b/src/test/java/org/assertj/core/test/Name.java
index 483f8ae88..2e976e019 100644
--- a/src/test/java/org/assertj/core/test/Name.java
+++ b/src/test/java/org/assertj/core/test/Name.java
@@ -17,10 +17,14 @@ package org.assertj.core.test;
 
 /**
  * @author Yvonne Wang
+ * @author Joel Costigliola
  */
 public class Name {
 
-  private String first;
+  // intentionnaly public to test field retrieval
+  // getter have been created to test property retrieval
+  public String first;
+  // keep private to test we are able to read property but not field
   private String last;
 
   public Name() {}
diff --git a/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
new file mode 100644
index 000000000..46e762613
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/introspection/FieldSupport_fieldValues_Test.java
@@ -0,0 +1,122 @@
+/*
+ * Created on Feb 22, 2011
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2011 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static java.util.Collections.emptyList;
+import static java.util.Collections.emptySet;
+import static junit.framework.Assert.assertEquals;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.junit.BeforeClass;
+import org.junit.Rule;
+import org.junit.Test;
+
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.test.Name;
+
+/**
+ * Tests for <code>{@link FieldSupport#fieldValues(String, Collection)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class FieldSupport_fieldValues_Test {
+
+  private static Employee yoda;
+  private static Employee luke;
+  private static List<Employee> employees;
+  private static FieldSupport fieldSupport;
+
+  @BeforeClass
+  public static void setUpOnce() {
+    yoda = new Employee(1L, new Name("Yoda"), 800);
+    luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+    employees = newArrayList(yoda, luke);
+    fieldSupport = new FieldSupport();
+  }
+
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Test
+  public void should_return_empty_List_if_given_Iterable_is_null() {
+    Iterable<Long> ids = fieldSupport.fieldValues("ids", Long.class, (Iterable<Long>) null);
+    assertEquals(emptyList(), ids);
+  }
+
+  @Test
+  public void should_return_empty_List_if_given_Iterable_is_empty() {
+    Iterable<Long> ids = fieldSupport.fieldValues("ids", Long.class, emptySet());
+    assertEquals(emptyList(), ids);
+  }
+
+  @Test
+  public void should_return_empty_List_if_given_Iterable_contains_only_nulls() {
+    Iterable<Long> ids = fieldSupport.fieldValues("ids", Long.class, newArrayList(null, null));
+    assertEquals(emptyList(), ids);
+  }
+
+  @Test
+  public void should_remove_null_values_from_given_Iterable() {
+    List<Employee> anotherList = newArrayList(yoda, null, luke, null);
+    Iterable<Long> ids = fieldSupport.fieldValues("id", Long.class, anotherList);
+    assertEquals(newArrayList(1L, 2L), ids);
+  }
+
+  @Test
+  public void should_return_values_of_simple_field() {
+    Iterable<Long> ids = fieldSupport.fieldValues("id", Long.class, employees);
+    assertEquals(newArrayList(1L, 2L), ids);
+  }
+
+  @Test
+  public void should_return_values_of_nested_field() {
+    Iterable<String> firstNames = fieldSupport.fieldValues("name.first", String.class, employees);
+    assertEquals(newArrayList("Yoda", "Luke"), firstNames);
+  }
+
+  @Test
+  public void should_throw_error_if_field_not_found() {
+    thrown.expect(IntrospectionError.class,
+                  "Unable to obtain the value of the field <'id.'> from <Employee[id=1, name=Name[first='Yoda', last='null'], age=800]>");
+    fieldSupport.fieldValues("id.", Long.class, employees);
+  }
+
+  @Test
+  public void should_throw_error_if_field_not_public() {
+    thrown.expect(IntrospectionError.class,
+                  "Unable to obtain the value of the field <'age'> from <Employee[id=1, name=Name[first='Yoda', last='null'], age=800]>, check that field is public.");
+    fieldSupport.fieldValues("age", Integer.class, employees);
+  }
+
+  @Test
+  public void should_extract_field() {
+    Long id = fieldSupport.fieldValue("id", Long.class, yoda);
+    assertEquals(Long.valueOf(1L), id);
+  }
+
+  @Test
+  public void should_handle_array_as_iterable() {
+    List<Long> fieldValuesFromIterable = fieldSupport.fieldValues("id", Long.class, employees);
+    List<Long> fieldValuesFromArray = fieldSupport.fieldValues("id", Long.class, employees.toArray(new Employee[0]));
+    assertThat(fieldValuesFromArray).isEqualTo(fieldValuesFromIterable);
+  }
+}
