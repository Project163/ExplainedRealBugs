diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index f5a21c093..f0cea758a 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -83,6 +83,7 @@ import org.assertj.core.condition.AllOf;
 import org.assertj.core.condition.AnyOf;
 import org.assertj.core.condition.DoesNotHave;
 import org.assertj.core.condition.Not;
+import org.assertj.core.configuration.Configuration;
 import org.assertj.core.configuration.ConfigurationProvider;
 import org.assertj.core.data.Index;
 import org.assertj.core.data.MapEntry;
@@ -1387,20 +1388,18 @@ public class Assertions implements InstanceOfAssertFactories {
 
   /**
    * In error messages, sets the threshold when iterable/array formatting will be on one line (if their String description
-   * is less than this parameter) or it will be formatted with one element per line.
+   * lenght &lt;= this parameter) or it will be formatted with one element per line.
    * <p>
-   * The following array will be formatted on one line as its length &lt; 80:
+   * The default value for maxLengthForSingleLineDescription is {@value Configuration#MAX_LENGTH_FOR_SINGLE_LINE_DESCRIPTION}.
+   * <p>
+   * The following array will be formatted on one line as its length &lt;= 80:
    * <pre><code class='java'> String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice");
-   *
    * // formatted as:
-   *
    * ["A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice"]</code></pre>
    * whereas this array is formatted on multiple lines (one element per line)
    *
    * <pre><code class='java'> String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice", "Guards! Guards! (Discworld)");
-   *
    * // formatted as:
-   *
    * ["A Game of Thrones",
    *  "The Lord of the Rings",
    *  "Assassin's Apprentice",
@@ -1416,7 +1415,7 @@ public class Assertions implements InstanceOfAssertFactories {
    * In error messages, sets the threshold for how many elements from one iterable/array/map will be included in the
    * in the description.
    *
-   * E.q. When this method is called with a value of {@code 3}.
+   * Example with a value of {@code 3}.
    * <p>
    * The following array will be formatted entirely as it's length is &lt;= 3:
    * <pre><code class='java'> String[] greatBooks = array("A Game of Thrones", "The Lord of the Rings", "Assassin's Apprentice");
diff --git a/src/main/java/org/assertj/core/configuration/Configuration.java b/src/main/java/org/assertj/core/configuration/Configuration.java
index bcaee710a..325d264eb 100644
--- a/src/main/java/org/assertj/core/configuration/Configuration.java
+++ b/src/main/java/org/assertj/core/configuration/Configuration.java
@@ -266,9 +266,9 @@ public class Configuration {
   }
 
   /**
-   * Returns the maximum length for an iterable/array to be displayed on one line.
+   * Returns the maximum number of elements that will be displayed for a group of values (iterables and arrays).
    * <p>
-   * See {@link Assertions#setMaxLengthForSingleLineDescription(int)} for a detailed description.
+   * See {@link Assertions#setMaxElementsForPrinting(int)} for a detailed description.
    * <p>
    * Note that this change will only be effective once {@link #apply()} or {@link #applyAndDisplay()} is called.
    *
diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index e2b935013..4ff256f1f 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -13,19 +13,22 @@
 package org.assertj.core.presentation;
 
 import static java.lang.Integer.toHexString;
+import static java.lang.reflect.Array.get;
 import static java.lang.reflect.Array.getLength;
+import static java.util.stream.Collectors.toList;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Arrays.isArrayTypePrimitive;
 import static org.assertj.core.util.Arrays.isObjectArray;
 import static org.assertj.core.util.DateUtil.formatAsDatetime;
 import static org.assertj.core.util.DateUtil.formatAsDatetimeWithMs;
+import static org.assertj.core.util.IterableUtil.sizeOf;
 import static org.assertj.core.util.Preconditions.checkArgument;
+import static org.assertj.core.util.Streams.stream;
 import static org.assertj.core.util.Strings.concat;
 import static org.assertj.core.util.Strings.quote;
 import static org.assertj.core.util.Throwables.getStackTrace;
 
 import java.io.File;
-import java.lang.reflect.Array;
 import java.lang.reflect.Method;
 import java.text.SimpleDateFormat;
 import java.time.Duration;
@@ -59,6 +62,7 @@ import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.concurrent.atomic.AtomicStampedReference;
 import java.util.concurrent.atomic.LongAdder;
 import java.util.function.Function;
+import java.util.stream.Stream;
 
 import org.assertj.core.configuration.Configuration;
 import org.assertj.core.configuration.ConfigurationProvider;
@@ -78,11 +82,11 @@ import org.assertj.core.util.diff.InsertDelta;
  */
 public class StandardRepresentation implements Representation {
 
+  private static final String ALREADY_VISITED = "(element already visited)";
+
   // can share this as StandardRepresentation has no state
   public static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
 
-  private static final String NULL = "null";
-
   private static final String TUPLE_START = "(";
   private static final String TUPLE_END = ")";
 
@@ -106,6 +110,20 @@ public class StandardRepresentation implements Representation {
   private static final Class<?>[] TYPE_WITH_UNAMBIGUOUS_REPRESENTATION = { Date.class, LocalDateTime.class, ZonedDateTime.class,
       OffsetDateTime.class, Calendar.class };
 
+  protected enum GroupType {
+    ITERABLE("iterable"), ARRAY("array");
+
+    private String description;
+
+    GroupType(String value) {
+      this.description = value;
+    }
+
+    public String description() {
+      return description;
+    }
+  }
+
   /**
    * It resets the static defaults for the standard representation.
    * <p>
@@ -468,103 +486,100 @@ public class StandardRepresentation implements Representation {
     return isObjectArray(o) ? smartFormat((Object[]) o) : formatPrimitiveArray(o);
   }
 
-  protected String multiLineFormat(Object[] iterable, Set<Object[]> alreadyFormatted) {
-    return format(iterable, ELEMENT_SEPARATOR_WITH_NEWLINE, INDENTATION_AFTER_NEWLINE, alreadyFormatted);
+  protected String multiLineFormat(Object[] array, Set<Object> alreadyVisited) {
+    return format(array, ELEMENT_SEPARATOR_WITH_NEWLINE, INDENTATION_AFTER_NEWLINE, alreadyVisited);
   }
 
-  protected String singleLineFormat(Object[] iterable, Set<Object[]> alreadyFormatted) {
-    return format(iterable, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, alreadyFormatted);
+  protected String singleLineFormat(Object[] array, Set<Object> alreadyVisited) {
+    return format(array, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, alreadyVisited);
   }
 
-  protected String smartFormat(Object[] iterable) {
-    Set<Object[]> alreadyFormatted = new HashSet<>();
-    String singleLineDescription = singleLineFormat(iterable, alreadyFormatted);
-    return doesDescriptionFitOnSingleLine(singleLineDescription)
-        ? singleLineDescription
-        : multiLineFormat(iterable, alreadyFormatted);
+  protected String smartFormat(Object[] array) {
+    Set<Object> alreadyVisited = new HashSet<>();
+    String description = singleLineFormat(array, alreadyVisited);
+    return doesDescriptionFitOnSingleLine(description) ? description : multiLineFormat(array, alreadyVisited);
   }
 
-  protected String format(Object[] array, String elementSeparator,
-                          String indentation, Set<Object[]> alreadyFormatted) {
+  protected String format(Object[] array, String elementSeparator, String indentation, Set<Object> alreadyVisited) {
     if (array == null) return null;
     if (array.length == 0) return DEFAULT_START + DEFAULT_END;
-    // iterable has some elements
-    StringBuilder desc = new StringBuilder();
-    desc.append(DEFAULT_START);
-    alreadyFormatted.add(array); // used to avoid infinite recursion when array contains itself
-    int i = 0;
-    while (true) {
-      Object element = array[i];
-      // do not indent first element
-      if (i != 0) desc.append(indentation);
-      if (i == maxElementsForPrinting) {
-        desc.append(DEFAULT_MAX_ELEMENTS_EXCEEDED);
-        alreadyFormatted.remove(array);
-        return desc.append(DEFAULT_END).toString();
-      }
-      // add element representation
-      if (!isArray(element)) desc.append(element == null ? NULL : toStringOf(element));
-      else if (isArrayTypePrimitive(element)) desc.append(formatPrimitiveArray(element));
-      else if (alreadyFormatted.contains(element)) desc.append("(this array)");
-      else desc.append(format((Object[]) element, elementSeparator, indentation, alreadyFormatted));
-      // manage end description
-      if (i == array.length - 1) {
-        alreadyFormatted.remove(array);
-        return desc.append(DEFAULT_END).toString();
-      }
-      // there are still elements to describe
-      desc.append(elementSeparator);
-      i++;
-    }
+
+    // deal with auto references to avoid infinite recursion
+    alreadyVisited.add(array);
+    List<String> list = Stream.of(array)
+                              .map(element -> alreadyVisited.contains(element) ? ALREADY_VISITED : toStringOf(element))
+                              .collect(toList());
+    return extracted(list, DEFAULT_START, DEFAULT_END, elementSeparator, indentation, list);
+  }
+
+  private String toStringOf(Object element, Set<Object> alreadyVisited) {
+    alreadyVisited.add(element);
+    return toStringOf(element);
   }
 
   protected String formatPrimitiveArray(Object o) {
     if (!isArray(o)) return null;
     if (!isArrayTypePrimitive(o)) throw Arrays.notAnArrayOfPrimitives(o);
-    int size = getLength(o);
-    if (size == 0) return DEFAULT_START + DEFAULT_END;
-    StringBuilder buffer = new StringBuilder();
-    buffer.append(DEFAULT_START);
-    buffer.append(toStringOf(Array.get(o, 0)));
-    for (int i = 1; i < size; i++) {
-      buffer.append(ELEMENT_SEPARATOR)
-            .append(INDENTATION_FOR_SINGLE_LINE);
-      if (i == maxElementsForPrinting) {
-        buffer.append(DEFAULT_MAX_ELEMENTS_EXCEEDED);
-        break;
-      }
 
-      buffer.append(toStringOf(Array.get(o, i)));
+    int length = getLength(o);
+    Object[] array = new Object[length];
+    for (int i = 0; i < length; i++) {
+      array[i] = get(o, i);
     }
-    buffer.append(DEFAULT_END);
-    return buffer.toString();
+    return format(array, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, new HashSet<>());
   }
 
   public String format(Iterable<?> iterable, String start, String end, String elementSeparator, String indentation) {
     if (iterable == null) return null;
     Iterator<?> iterator = iterable.iterator();
     if (!iterator.hasNext()) return start + end;
-    // iterable has some elements
+
+    // deal with auto references to avoid infinite recursion
+    List<String> list = stream(iterable).map(element -> element == iterable ? "(this iterable)" : toStringOf(element))
+                                        .collect(toList());
+    return extracted(iterable, start, end, elementSeparator, indentation, list);
+  }
+
+  private String extracted(Iterable<?> iterable, String start, String end, String elementSeparator, String indentation,
+                           List<String> list) {
+    int size = sizeOf(iterable);
     StringBuilder desc = new StringBuilder(start);
-    boolean firstElement = true;
-    int printedElements = 0;
-    while (true) {
-      Object element = iterator.next();
-      // do not indent first element
-      if (firstElement) firstElement = false;
-      else desc.append(indentation);
-      // add element representation
-      if (printedElements == maxElementsForPrinting) {
-        desc.append(DEFAULT_MAX_ELEMENTS_EXCEEDED);
-        return desc.append(end).toString();
+    if (size <= maxElementsForPrinting) {
+      // display all elements
+      for (int i = 0; i < size; i++) {
+        if (i != 0) desc.append(indentation);
+        desc.append(list.get(i));
+        if (i != size - 1) desc.append(elementSeparator);
       }
-      desc.append(element == iterable ? "(this Collection)" : toStringOf(element));
-      printedElements++;
-      // manage end description
-      if (!iterator.hasNext()) return desc.append(end).toString();
-      // there are still elements to be describe
-      desc.append(elementSeparator);
+      return desc.append(end).toString();
+    }
+    // we can't display all elements, picks the first and last maxElementsForPrinting/2 elements
+    // if maxElementsForPrinting is odd, display one more first elements than last, ex: 9 => display 5 first elements and 4 last
+    int maxFirstElementsToPrint = (maxElementsForPrinting + 1) / 2;
+    for (int i = 0; i < maxFirstElementsToPrint; i++) {
+      desc.append(list.get(i)).append(elementSeparator).append(indentation);
+    }
+    desc.append(DEFAULT_MAX_ELEMENTS_EXCEEDED);
+    // we only append a new line if the separator had one ",\n"
+    if (elementSeparator.contains(System.lineSeparator())) {
+      // we just want a new line after DEFAULT_MAX_ELEMENTS_EXCEEDED but no char separator ','
+      // we want:
+      // first elements,
+      // ...
+      // last elements
+      // and not:
+      // first elements,
+      // ...,
+      // last elements
+      desc.append(System.lineSeparator());
+    }
+    // display last elements
+    int maxLastElementsToPrint = maxElementsForPrinting / 2;
+    for (int i = size - maxLastElementsToPrint; i < size; i++) {
+      if (i != size - maxLastElementsToPrint) desc.append(elementSeparator);
+      desc.append(indentation).append(list.get(i));
     }
+    return desc.append(end).toString();
   }
 
   protected String multiLineFormat(Iterable<?> iterable) {
@@ -591,7 +606,7 @@ public class StandardRepresentation implements Representation {
   }
 
   private static boolean doesDescriptionFitOnSingleLine(String singleLineDescription) {
-    return singleLineDescription == null || singleLineDescription.length() < maxLengthForSingleLineDescription;
+    return singleLineDescription == null || singleLineDescription.length() <= maxLengthForSingleLineDescription;
   }
 
   private static String identityHexCodeOf(Object obj) {
diff --git a/src/test/java/org/assertj/core/presentation/NumberGrouping_Test.java b/src/test/java/org/assertj/core/presentation/NumberGrouping_Test.java
index b5c258d03..bf6add658 100644
--- a/src/test/java/org/assertj/core/presentation/NumberGrouping_Test.java
+++ b/src/test/java/org/assertj/core/presentation/NumberGrouping_Test.java
@@ -12,10 +12,10 @@
  */
 package org.assertj.core.presentation;
 
-import org.junit.jupiter.api.Test;
-
 import static org.assertj.core.api.Assertions.assertThat;
 
+import org.junit.jupiter.api.Test;
+
 /**
  * @author Mariusz Smykula
  */
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
index e95cf6e29..934d30686 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_array_format_Test.java
@@ -13,10 +13,17 @@
 package org.assertj.core.presentation;
 
 import static java.lang.String.format;
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Strings.quote;
 
+import java.util.stream.Stream;
+
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests for <code>{@link StandardRepresentation#formatArray(Object)}</code>.
@@ -27,172 +34,245 @@ public class StandardRepresentation_array_format_Test extends AbstractBaseRepres
 
   @Test
   public void should_return_null_if_array_is_null() {
+    // GIVEN
     final Object array = null;
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isNull();
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isNull();
   }
 
   @Test
   public void should_return_empty_brackets_if_array_is_empty() {
+    // GIVEN
     final Object[] array = new Object[0];
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[]");
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo("[]");
   }
 
-  @Test
-  public void should_format_boolean_array() {
-    Object array = new boolean[] { true, false };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[true, false]");
+  @ParameterizedTest(name = "{1} should be formatted as {2}")
+  @MethodSource("should_format_primitive_array_source")
+  public void should_format_primitive_array(Object array, String expectedDescription) {
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo(expectedDescription);
   }
 
-  @Test
-  public void should_format_byte_array() {
-    Object array = new byte[] { (byte) 3, (byte) 8 };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[3, 8]");
+  private static Stream<Arguments> should_format_primitive_array_source() {
+    return Stream.of(Arguments.of(new boolean[] { true, false }, "[true, false]"),
+                     Arguments.of(new char[] { 'a', 'b' }, "['a', 'b']"),
+                     Arguments.of(new double[] { 6.8, 8.3 }, "[6.8, 8.3]"),
+                     Arguments.of(new float[] { 6.1f, 8.6f }, "[6.1f, 8.6f]"),
+                     Arguments.of(new int[] { 78, 66 }, "[78, 66]"),
+                     Arguments.of(new long[] { 160L, 98L }, "[160L, 98L]"),
+                     Arguments.of(new short[] { (short) 5, (short) 8 }, "[5, 8]"),
+                     Arguments.of(new int[] { 78, 66 }, "[78, 66]"),
+                     Arguments.of(new int[] { 78, 66 }, "[78, 66]"),
+                     Arguments.of(new int[] { 78, 66 }, "[78, 66]"),
+                     Arguments.of(new boolean[] { true, false }, "[true, false]"));
   }
 
   @Test
   public void should_format_byte_array_in_hex_representation() {
+    // GIVEN
     Object array = new byte[] { (byte) 3, (byte) 8 };
-    assertThat(new HexadecimalRepresentation().formatArray(array)).isEqualTo("[0x03, 0x08]");
-  }
-
-  @Test
-  public void should_format_char_array() {
-    Object array = new char[] { 'a', 'b' };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("['a', 'b']");
-  }
-
-  @Test
-  public void should_format_double_array() {
-    Object array = new double[] { 6.8, 8.3 };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[6.8, 8.3]");
-  }
-
-  @Test
-  public void should_format_float_array() {
-    Object array = new float[] { 6.1f, 8.6f };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[6.1f, 8.6f]");
-  }
-
-  @Test
-  public void should_format_int_array() {
-    Object array = new int[] { 78, 66 };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[78, 66]");
-  }
-
-  @Test
-  public void should_format_primitive_array_up_to_the_maximum_allowed_elements() {
-    Object array = new int[] { 1, 2, 3, 4 };
-    StandardRepresentation.setMaxElementsForPrinting(3);
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[1, 2, 3, ...]");
-  }
-
-  @Test
-  public void should_format_long_array() {
-    Object array = new long[] { 160L, 98L };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[160L, 98L]");
-  }
-
-  @Test
-  public void should_format_short_array() {
-    Object array = new short[] { (short) 5, (short) 8 };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[5, 8]");
+    // WHEN
+    String formatted = new HexadecimalRepresentation().formatArray(array);
+    // THEN
+    then(formatted).isEqualTo("[0x03, 0x08]");
   }
 
   @Test
   public void should_return_null_if_parameter_is_not_array() {
-    assertThat(STANDARD_REPRESENTATION.formatArray("Hello")).isNull();
-  }
-
-  @Test
-  public void should_format_longArray() {
-    assertThat(STANDARD_REPRESENTATION.formatArray(new long[] { 6L, 8L })).isEqualTo("[6L, 8L]");
+    // GIVEN
+    String string = "Hello";
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(string);
+    // THEN
+    then(formatted).isNull();
   }
 
   @Test
   public void should_format_String_array() {
-    assertThat(STANDARD_REPRESENTATION.formatArray(new Object[] { "Hello",
-        "World" })).isEqualTo("[\"Hello\", \"World\"]");
-  }
-
-  @Test
-  public void should_format_array_with_null_element() {
-    assertThat(STANDARD_REPRESENTATION.formatArray(new Object[] { "Hello", null })).isEqualTo("[\"Hello\", null]");
+    // GIVEN
+    Object[] array = { "Hello", "World" };
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo(format("[\"Hello\", \"World\"]"));
   }
 
   @Test
   public void should_format_Object_array() {
-    assertThat(STANDARD_REPRESENTATION.formatArray(new Object[] { "Hello",
-        new Person("Anakin") })).isEqualTo("[\"Hello\", 'Anakin']");
+    // GIVEN
+    Object[] array = { "Hello", new Person("Anakin") };
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo(format("[\"Hello\", 'Anakin']"));
   }
 
   @Test
   public void should_format_Object_array_on_new_line_smart() {
+    // GIVEN
     StandardRepresentation.setMaxLengthForSingleLineDescription(11);
-    assertThat(STANDARD_REPRESENTATION.formatArray(new Object[] { "Hello",
-      new Person("Anakin") })).isEqualTo(format("[\"Hello\",%n"
-                                                + "    'Anakin']"));
+    Object[] array = { "Hello", new Person("Anakin") };
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo(format("[\"Hello\",%n"
+                                     + "    'Anakin']"));
   }
 
   @Test
   public void should_format_Object_array_that_has_primitive_array_as_element() {
+    // GIVEN
     boolean[] booleans = { true, false };
     Object[] array = { "Hello", booleans };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[\"Hello\", [true, false]]");
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo("[\"Hello\", [true, false]]");
   }
 
+  @Disabled
   @Test
-  public void should_format_Object_array_having_itself_as_element() {
+  public void should_format_Object_array_with_itself_as_element() {
+    // GIVEN
     Object[] array1 = { "Hello", "World" };
     Object[] array2 = { array1 };
     array1[1] = array2;
-    assertThat(STANDARD_REPRESENTATION.formatArray(array2)).isEqualTo("[[\"Hello\", (this array)]]");
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array2);
+    // THEN
+    then(formatted).isEqualTo("[[\"Hello\", (this array)]]");
   }
 
   @Test
-  public void should_format_Object_array_having_empty_primitive_array() {
+  public void should_format_Object_array_having_with_primitive_array() {
+    // GIVEN
     Object[] array = { "Hello", new int[] {} };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[\"Hello\", []]");
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo("[\"Hello\", []]");
   }
 
   @Test
-  public void should_format_Object_array_having_null_element() {
+  public void should_format_Object_array_with_null_element() {
+    // GIVEN
     Object[] array = { "Hello", null };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[\"Hello\", null]");
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo("[\"Hello\", null]");
   }
 
   @Test
   public void should_format_array_up_to_the_maximum_allowed_elements() {
+    // GIVEN
     StandardRepresentation.setMaxElementsForPrinting(3);
-    Object[] array = { "First", "Second", "Third", "Fourth" };
-    assertThat(STANDARD_REPRESENTATION.formatArray(array)).isEqualTo("[\"First\", \"Second\", \"Third\", ...]");
+    Object[] array = { "First", "Second", "Third", "Fourth", "Fifth", "Sixth", "Seventh" };
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.formatArray(array);
+    // THEN
+    then(formatted).isEqualTo("[\"First\", \"Second\", ... \"Seventh\"]");
   }
 
   @Test
   public void should_format_array_with_one_element_per_line() {
+    // GIVEN
     StandardRepresentation.setMaxLengthForSingleLineDescription(25);
     Object[] array = { "1234567890", "1234567890", "1234567890", "1234567890" };
+    // WHEN
     String formatted = STANDARD_REPRESENTATION.formatArray(array);
-    String formattedAfterNewLine = System.lineSeparator() + "  <" + formatted + ">";
-    assertThat(formattedAfterNewLine).isEqualTo(format("%n" +
-                                                       "  <[\"1234567890\",%n" +
-                                                       "    \"1234567890\",%n" +
-                                                       "    \"1234567890\",%n" +
-                                                       "    \"1234567890\"]>"));
+    // THEN
+    String formattedAfterNewLine = "  <" + formatted + ">";
+    then(formattedAfterNewLine).isEqualTo(format("  <[\"1234567890\",%n" +
+                                                 "    \"1234567890\",%n" +
+                                                 "    \"1234567890\",%n" +
+                                                 "    \"1234567890\"]>"));
   }
 
-  @Test
-  public void should_format_array_up_to_the_maximum_allowed_elements_and_max_line_length() {
-    StandardRepresentation.setMaxElementsForPrinting(4);
-    StandardRepresentation.setMaxLengthForSingleLineDescription(25);
-    Object[] array = { "1234567890", "1234567890", "1234567890", "1234567890", "1234567890" };
+  @ParameterizedTest(name = "with printing {0} max, {1} should be formatted as {2}")
+  @MethodSource("should_format_array_source")
+  public void should_format_array_honoring_display_configuration(int maxElementsForPrinting, Object[] array,
+                                                                 String expectedDescription) {
+    // GIVEN
+    StandardRepresentation.setMaxElementsForPrinting(maxElementsForPrinting);
+    StandardRepresentation.setMaxLengthForSingleLineDescription(15);
+    // WHEN
     String formatted = STANDARD_REPRESENTATION.formatArray(array);
-    String formattedAfterNewLine = System.lineSeparator() + "  <" + formatted + ">";
-    assertThat(formattedAfterNewLine).isEqualTo(format("%n" +
-                                                       "  <[\"1234567890\",%n" +
-                                                       "    \"1234567890\",%n" +
-                                                       "    \"1234567890\",%n" +
-                                                       "    \"1234567890\",%n" +
-                                                       "    ...]>"));
+    // THEN
+    // formattedAfterNewLine is built to show we align values on the first element.
+    String formattedAfterNewLine = "  <" + formatted + ">";
+    then(formattedAfterNewLine).isEqualTo(format(expectedDescription));
+  }
+
+  private static Stream<Arguments> should_format_array_source() {
+    return Stream.of(Arguments.of(12, array(1, 2, 3, 4, 5), "  <[1, 2, 3, 4, 5]>"),
+                     Arguments.of(12, array("First", 3, "foo", "bar"), "  <[\"First\",%n" +
+                                                                       "    3,%n" +
+                                                                       "    \"foo\",%n" +
+                                                                       "    \"bar\"]>"),
+                     Arguments.of(12, array("First", 3, 4, "foo", "bar", 5, "another", 6), "  <[\"First\",%n" +
+                                                                                           "    3,%n" +
+                                                                                           "    4,%n" +
+                                                                                           "    \"foo\",%n" +
+                                                                                           "    \"bar\",%n" +
+                                                                                           "    5,%n" +
+                                                                                           "    \"another\",%n" +
+                                                                                           "    6]>"),
+                     Arguments.of(12, array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), "  <[1,%n" +
+                                                                            "    2,%n" +
+                                                                            "    3,%n" +
+                                                                            "    4,%n" +
+                                                                            "    5,%n" +
+                                                                            "    6,%n" +
+                                                                            "    7,%n" +
+                                                                            "    8,%n" +
+                                                                            "    9,%n" +
+                                                                            "    10]>"),
+                     Arguments.of(12, array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), "  <[1,%n" +
+                                                                                    "    2,%n" +
+                                                                                    "    3,%n" +
+                                                                                    "    4,%n" +
+                                                                                    "    5,%n" +
+                                                                                    "    6,%n" +
+                                                                                    "    7,%n" +
+                                                                                    "    8,%n" +
+                                                                                    "    9,%n" +
+                                                                                    "    10,%n" +
+                                                                                    "    11,%n" +
+                                                                                    "    12]>"),
+                     Arguments.of(11, array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19), "  <[1,%n" +
+                                                                                                                "    2,%n" +
+                                                                                                                "    3,%n" +
+                                                                                                                "    4,%n" +
+                                                                                                                "    5,%n" +
+                                                                                                                "    6,%n" +
+                                                                                                                "    ...%n" +
+                                                                                                                "    15,%n" +
+                                                                                                                "    16,%n" +
+                                                                                                                "    17,%n" +
+                                                                                                                "    18,%n" +
+                                                                                                                "    19]>"),
+                     Arguments.of(12, array(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20), "  <[1,%n" +
+                                                                                                                    "    2,%n" +
+                                                                                                                    "    3,%n" +
+                                                                                                                    "    4,%n" +
+                                                                                                                    "    5,%n" +
+                                                                                                                    "    6,%n" +
+                                                                                                                    "    ...%n" +
+                                                                                                                    "    15,%n" +
+                                                                                                                    "    16,%n" +
+                                                                                                                    "    17,%n" +
+                                                                                                                    "    18,%n" +
+                                                                                                                    "    19,%n" +
+                                                                                                                    "    20]>"));
   }
 
   private static class Person {
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
index 477ed05bf..0e7fb7937 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_iterable_format_Test.java
@@ -14,42 +14,64 @@ package org.assertj.core.presentation;
 
 import static java.lang.String.format;
 import static java.util.Arrays.asList;
+import static java.util.Collections.emptyList;
 import static java.util.stream.Collectors.joining;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.Lists.list;
 
-import java.util.ArrayList;
 import java.util.List;
 import java.util.stream.Stream;
 
+import org.junit.jupiter.api.Disabled;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
 public class StandardRepresentation_iterable_format_Test extends AbstractBaseRepresentationTest {
 
-  private static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
-
   @Test
   public void should_return_null_if_iterable_is_null() {
-    assertThat(STANDARD_REPRESENTATION.smartFormat((Iterable<?>) null)).isNull();
+    // GIVEN
+    List<Object> list = null;
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.smartFormat(list);
+    // THEN
+    then(formatted).isNull();
   }
 
   @Test
   public void should_return_empty_brackets_if_iterable_is_empty() {
-    assertThat(STANDARD_REPRESENTATION.smartFormat(asList())).isEqualTo("[]");
+    // GIVEN
+    List<Object> list = emptyList();
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.smartFormat(list);
+    // THEN
+    then(formatted).isEqualTo("[]");
   }
 
   @Test
   public void should_format_iterable_on_one_line_if_description_is_short_enough() {
-    String e1 = stringOfLength(StandardRepresentation.getMaxLengthForSingleLineDescription() / 10);
-    String e2 = stringOfLength(StandardRepresentation.getMaxLengthForSingleLineDescription() / 10);
-    assertThat(STANDARD_REPRESENTATION.smartFormat(asList(e1, e2))).isEqualTo("[\"" + e1 + "\", \"" + e2 + "\"]");
+    // GIVEN
+    String element1 = stringOfLength(StandardRepresentation.getMaxLengthForSingleLineDescription() / 10);
+    String element2 = stringOfLength(StandardRepresentation.getMaxLengthForSingleLineDescription() / 10);
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.smartFormat(list(element1, element2));
+    // THEN
+    then(formatted).isEqualTo("[\"" + element1 + "\", \"" + element2 + "\"]");
   }
 
   @Test
   public void should_format_iterable_with_one_element_per_line_when_single_line_description_is_too_long() {
-    String e1 = stringOfLength(StandardRepresentation.getMaxLengthForSingleLineDescription());
-    String e2 = stringOfLength(StandardRepresentation.getMaxLengthForSingleLineDescription());
-    assertThat(STANDARD_REPRESENTATION.smartFormat(asList(e1, e2))).isEqualTo(format("[\"" + e1 + "\",%n" +
-                                                                                     "    \"" + e2 + "\"]"));
+    String element1 = stringOfLength(StandardRepresentation.getMaxLengthForSingleLineDescription());
+    String element2 = stringOfLength(StandardRepresentation.getMaxLengthForSingleLineDescription());
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.smartFormat(list(element1, element2));
+    // THEN
+    then(formatted).isEqualTo(format("[\"" + element1 + "\",%n" +
+                                     "    \"" + element2 + "\"]"));
   }
 
   @Test
@@ -59,55 +81,126 @@ public class StandardRepresentation_iterable_format_Test extends AbstractBaseRep
     assertThat(STANDARD_REPRESENTATION.singleLineFormat(asList(), "{", "}")).isEqualTo("{}");
   }
 
-  @Test
-  public void should_format_iterable_with_one_element_per_line() {
-    String formatted = STANDARD_REPRESENTATION.multiLineFormat(asList("First", 3, "foo", "bar"));
-    String formattedAfterNewLine = System.lineSeparator() + "  <" + formatted + ">";
-    assertThat(formattedAfterNewLine).isEqualTo(format("%n" +
-                                                       "  <[\"First\",%n" +
-                                                       "    3,%n" +
-                                                       "    \"foo\",%n" +
-                                                       "    \"bar\"]>"));
+  @ParameterizedTest(name = "with printing {0} max, {1} should be formatted as {2}")
+  @MethodSource("should_format_iterable_source")
+  public void should_format_iterable(int maxElementsForPrinting, List<?> list, String expectedDescription) {
+    // GIVEN
+    StandardRepresentation.setMaxElementsForPrinting(maxElementsForPrinting);
+    StandardRepresentation.setMaxLengthForSingleLineDescription(15);
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.toStringOf(list);
+    // THEN
+    // formattedAfterNewLine is built to show we align values on the first element.
+    String formattedAfterNewLine = "  <" + formatted + ">";
+    then(formattedAfterNewLine).isEqualTo(format(expectedDescription));
   }
 
-  @Test
-  public void should_format_iterable_up_to_the_maximum_allowed_elements_multi_line() {
-    StandardRepresentation.setMaxElementsForPrinting(3);
-    StandardRepresentation.setMaxLengthForSingleLineDescription(10);
-    String formatted = STANDARD_REPRESENTATION.smartFormat(asList("First", 3, "foo", "bar"));
-    String formattedAfterNewLine = System.lineSeparator() + "  <" + formatted + ">";
-    assertThat(formattedAfterNewLine).isEqualTo(format("%n" +
-                                                       "  <[\"First\",%n" +
-                                                       "    3,%n" +
-                                                       "    \"foo\",%n" +
-                                                       "    ...]>"));
+  private static Stream<Arguments> should_format_iterable_source() {
+    return Stream.of(Arguments.of(12, list(1, 2, 3, 4, 5), "  <[1, 2, 3, 4, 5]>"),
+                     Arguments.of(12, list("First", 3, "foo", "bar"), "  <[\"First\",%n" +
+                                                                      "    3,%n" +
+                                                                      "    \"foo\",%n" +
+                                                                      "    \"bar\"]>"),
+                     Arguments.of(12, list("First", 3, 4, "foo", "bar", 5, "another", 6), "  <[\"First\",%n" +
+                                                                                          "    3,%n" +
+                                                                                          "    4,%n" +
+                                                                                          "    \"foo\",%n" +
+                                                                                          "    \"bar\",%n" +
+                                                                                          "    5,%n" +
+                                                                                          "    \"another\",%n" +
+                                                                                          "    6]>"),
+                     Arguments.of(12, list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10), "  <[1,%n" +
+                                                                           "    2,%n" +
+                                                                           "    3,%n" +
+                                                                           "    4,%n" +
+                                                                           "    5,%n" +
+                                                                           "    6,%n" +
+                                                                           "    7,%n" +
+                                                                           "    8,%n" +
+                                                                           "    9,%n" +
+                                                                           "    10]>"),
+                     Arguments.of(12, list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12), "  <[1,%n" +
+                                                                                   "    2,%n" +
+                                                                                   "    3,%n" +
+                                                                                   "    4,%n" +
+                                                                                   "    5,%n" +
+                                                                                   "    6,%n" +
+                                                                                   "    7,%n" +
+                                                                                   "    8,%n" +
+                                                                                   "    9,%n" +
+                                                                                   "    10,%n" +
+                                                                                   "    11,%n" +
+                                                                                   "    12]>"),
+                     Arguments.of(11, list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19), "  <[1,%n" +
+                                                                                                               "    2,%n" +
+                                                                                                               "    3,%n" +
+                                                                                                               "    4,%n" +
+                                                                                                               "    5,%n" +
+                                                                                                               "    6,%n" +
+                                                                                                               "    ...%n" +
+                                                                                                               "    15,%n" +
+                                                                                                               "    16,%n" +
+                                                                                                               "    17,%n" +
+                                                                                                               "    18,%n" +
+                                                                                                               "    19]>"),
+                     Arguments.of(12, list(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20), "  <[1,%n" +
+                                                                                                                   "    2,%n" +
+                                                                                                                   "    3,%n" +
+                                                                                                                   "    4,%n" +
+                                                                                                                   "    5,%n" +
+                                                                                                                   "    6,%n" +
+                                                                                                                   "    ...%n" +
+                                                                                                                   "    15,%n" +
+                                                                                                                   "    16,%n" +
+                                                                                                                   "    17,%n" +
+                                                                                                                   "    18,%n" +
+                                                                                                                   "    19,%n" +
+                                                                                                                   "    20]>"));
   }
 
   @Test
   public void should_format_iterable_up_to_the_maximum_allowed_elements_single_line() {
-    StandardRepresentation.setMaxElementsForPrinting(3);
-    String formatted = STANDARD_REPRESENTATION.smartFormat(asList("First", 3, "foo", "bar"));
-    assertThat(formatted).isEqualTo("[\"First\", 3, \"foo\", ...]");
+    // GIVEN
+    StandardRepresentation.setMaxElementsForPrinting(6);
+    // WHEN
+    String formatted = STANDARD_REPRESENTATION.smartFormat(list("First", 3, 4, "foo", "bar", 5, "another", 6));
+    // THEN
+    then(formatted).isEqualTo(format("[\"First\", 3, 4, ... 5, \"another\", 6]"));
   }
 
   @Test
   public void should_format_iterable_with_an_element_per_line_according_the_given_representation() {
-    String formatted = new HexadecimalRepresentation().multiLineFormat(asList(1, 2, 3));
-    String formattedAfterNewLine = System.lineSeparator() + "  <" + formatted + ">";
-    assertThat(formattedAfterNewLine).isEqualTo(format("%n" +
-                                                       "  <[0x0000_0001,%n" +
-                                                       "    0x0000_0002,%n" +
-                                                       "    0x0000_0003]>"));
+    // GIVEN
+    List<Integer> list = list(1, 2, 3);
+    // WHEN
+    String formatted = new HexadecimalRepresentation().multiLineFormat(list);
+    // THEN
+    String formattedAfterNewLine = "  <" + formatted + ">";
+    then(formattedAfterNewLine).isEqualTo(format("  <[0x0000_0001,%n" +
+                                                 "    0x0000_0002,%n" +
+                                                 "    0x0000_0003]>"));
   }
 
   @Test
   public void should_format_recursive_iterable() {
-    List<Object> list = new ArrayList<>();
+    // GIVEN
+    List<Object> list = list();
     list.add(list);
     list.add(list);
+    // WHEN
     String formatted = STANDARD_REPRESENTATION.multiLineFormat(list);
-    assertThat(formatted).isEqualTo(format("[(this Collection),%n" +
-                                           "    (this Collection)]"));
+    // THEN
+    then(formatted).isEqualTo(format("[(this iterable),%n" +
+                                     "    (this iterable)]"));
+  }
+
+  @Disabled //
+  @Test
+  public void should_format_iterable_having_itself_as_element() {
+    List<Object> list1 = list("Hello", "World");
+    List<Object> list2 = list(list1);
+    list1.set(1, list2);
+    assertThat(STANDARD_REPRESENTATION.toStringOf(list1)).isEqualTo("[[\"Hello\", (this iterable)]]");
   }
 
   private static String stringOfLength(int length) {
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
index 0817beecc..5663817fa 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
@@ -33,7 +33,7 @@ public class StandardRepresentation_map_format_Test extends AbstractBaseRepresen
 
   @Test
   public void should_return_null_if_Map_is_null() {
-    Map<?,?> map = null;
+    Map<?, ?> map = null;
     assertThat(STANDARD_REPRESENTATION.toStringOf(map)).isNull();
   }
 
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
index f7a14ea52..5a90f8215 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
@@ -102,8 +102,6 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
   @Test
   public void should_return_toString_of_Collection_of_String() {
     Collection<String> collection = list("s1", "s2");
-    // assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo(format("[\"s1\",%n" +
-    // " \"s2\"]"));
     assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo(format("[\"s1\", \"s2\"]"));
   }
 
@@ -115,9 +113,13 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void should_return_toString_of_Collection_of_arrays_up_to_the_maximum_allowed_elements() {
-    List<Boolean[]> collection = list(array(true, false), array(true, false, true), array(true, true));
-    StandardRepresentation.setMaxElementsForPrinting(2);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo("[[true, false], [true, false, ...], ...]");
+    List<Boolean[]> collection = list(array(true),
+                                      array(true, false, true, false, true),
+                                      array(true, true),
+                                      array(true),
+                                      array(true));
+    StandardRepresentation.setMaxElementsForPrinting(4);
+    assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo("[[true], [true, false, ... false, true], ... [true], [true]]");
   }
 
   @Test
@@ -128,10 +130,13 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void should_return_toString_of_Collection_of_Collections_up_to_the_maximum_allowed_elements() {
-    Collection<List<String>> collection = list(list("s1", "s2"), list("s3", "s4", "s5"), list("s6", "s7"));
-    StandardRepresentation.setMaxElementsForPrinting(2);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(collection))
-                                                              .isEqualTo("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ...], ...]");
+    Collection<List<String>> collection = list(list("s1"),
+                                               list("s2", "s3", "s4", "s5", "s6"),
+                                               list("s7", "s8"),
+                                               list("s9"),
+                                               list("s10"));
+    StandardRepresentation.setMaxElementsForPrinting(4);
+    assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo("[[\"s1\"], [\"s2\", \"s3\", ... \"s5\", \"s6\"], ... [\"s9\"], [\"s10\"]]");
   }
 
   @Test
@@ -155,9 +160,13 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void should_return_toString_of_array_of_arrays_up_to_the_maximum_allowed_elements() {
-    String[][] array = array(array("s1", "s2"), array("s3", "s4", "s5"), array("s6", "s7"));
-    StandardRepresentation.setMaxElementsForPrinting(2);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(array)).isEqualTo("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ...], ...]");
+    String[][] array = array(array("s1", "s2"),
+                             array("s3", "s4", "s5", "s6", "s7"),
+                             array("s8"),
+                             array("s9"),
+                             array("s10"));
+    StandardRepresentation.setMaxElementsForPrinting(4);
+    assertThat(STANDARD_REPRESENTATION.toStringOf(array)).isEqualTo("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ... \"s6\", \"s7\"], ... [\"s9\"], [\"s10\"]]");
   }
 
   @Test
@@ -336,8 +345,8 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void should_format_tuples_up_to_the_maximum_allowed_elements() {
-    StandardRepresentation.setMaxElementsForPrinting(2);
-    assertThat(toStringOf(tuple(1, 2, 3))).isEqualTo("(1, 2, ...)");
+    StandardRepresentation.setMaxElementsForPrinting(4);
+    assertThat(toStringOf(tuple(1, 2, 3, 4, 5))).isEqualTo("(1, 2, ... 4, 5)");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
index 156f2623e..a68c4565b 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
@@ -119,10 +119,12 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
   @Test
   public void should_return_toString_of_Collection_of_arrays_up_to_the_maximum_allowed_elements() {
     List<Boolean[]> collection = list(array(true, false),
-                                      array(true, false, true),
+                                      array(true),
+                                      array(true, false),
+                                      array(true, false, true, false, true),
                                       array(true, true));
-    StandardRepresentation.setMaxElementsForPrinting(2);
-    assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[[true, false], [true, false, ...], ...] (ArrayList@%s)",
+    StandardRepresentation.setMaxElementsForPrinting(4);
+    assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[[true, false], [true], ... [true, false, ... false, true], [true, true]] (ArrayList@%s)",
                                                                    toHexString(System.identityHashCode(collection))));
   }
 
@@ -138,10 +140,12 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
   @Test
   public void should_return_toString_of_Collection_of_Collections_up_to_the_maximum_allowed_elements() {
     Collection<List<String>> collection = list(list("s1", "s2"),
-                                               list("s3", "s4", "s5"),
-                                               list("s6", "s7"));
+                                               list("s3", "s4", "s5", "s6", "s7"),
+                                               list("s8", "s9"),
+                                               list("s10", "s11"),
+                                               list("s12"));
     StandardRepresentation.setMaxElementsForPrinting(2);
-    assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ...], ...] (ArrayList@%s)",
+    assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[[\"s1\", \"s2\"], ... [\"s12\"]] (ArrayList@%s)",
                                                                    toHexString(System.identityHashCode(collection))));
   }
 
@@ -172,10 +176,12 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
   @Test
   public void should_return_toString_of_array_of_arrays_up_to_the_maximum_allowed_elements() {
     String[][] array = array(array("s1", "s2"),
-                             array("s3", "s4", "s5"),
-                             array("s6", "s7"));
-    StandardRepresentation.setMaxElementsForPrinting(2);
-    assertThat(unambiguousToStringOf(array)).isEqualTo(format("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ...], ...] (String[][]@%s)",
+                             array("s3", "s4", "s5", "s6", "s7"),
+                             array("s8", "s9"),
+                             array("s10", "s11"),
+                             array("s12"));
+    StandardRepresentation.setMaxElementsForPrinting(4);
+    assertThat(unambiguousToStringOf(array)).isEqualTo(format("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ... \"s6\", \"s7\"], ... [\"s10\", \"s11\"], [\"s12\"]] (String[][]@%s)",
                                                               toHexString(System.identityHashCode(array))));
   }
 
@@ -357,8 +363,8 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
   @Test
   public void should_format_tuples_up_to_the_maximum_allowed_elements() {
     StandardRepresentation.setMaxElementsForPrinting(2);
-    Tuple tuple = tuple(1, 2, 3);
-    assertThat(unambiguousToStringOf(tuple)).isEqualTo(format("(1, 2, ...) (Tuple@%s)",
+    Tuple tuple = tuple(1, 2, 3, 4, 5);
+    assertThat(unambiguousToStringOf(tuple)).isEqualTo(format("(1, ... 5) (Tuple@%s)",
                                                               toHexString(System.identityHashCode(tuple))));
   }
 
