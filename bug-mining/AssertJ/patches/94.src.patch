diff --git a/src/main/java/org/assertj/core/api/AbstractLocalDateAssert.java b/src/main/java/org/assertj/core/api/AbstractLocalDateAssert.java
new file mode 100644
index 000000000..752b1fbd8
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/AbstractLocalDateAssert.java
@@ -0,0 +1,387 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.error.ShouldBeAfter.shouldBeAfter;
+import static org.assertj.core.error.ShouldBeAfterOrEqualsTo.shouldBeAfterOrEqualsTo;
+import static org.assertj.core.error.ShouldBeBefore.shouldBeBefore;
+import static org.assertj.core.error.ShouldBeBeforeOrEqualsTo.shouldBeBeforeOrEqualsTo;
+
+import java.time.LocalDate;
+
+import org.assertj.core.internal.Failures;
+import org.assertj.core.internal.Objects;
+
+/**
+ * Assertions for {@link LocalDate} type from new Date &amp; Time API introduced in Java 8.
+ */
+public abstract class AbstractLocalDateAssert<S extends AbstractLocalDateAssert<S>> extends
+    AbstractAssert<S, LocalDate> {
+
+  public static final String NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE = "The LocalDate to compare actual with should not be null";
+
+  /**
+   * Creates a new <code>{@link org.assertj.core.api.AbstractLocalDateAssert}</code>.
+   * 
+   * @param selfType the "self type"
+   * @param actual the actual value to verify
+   */
+  protected AbstractLocalDateAssert(LocalDate actual, Class<?> selfType) {
+	super(actual, selfType);
+  }
+
+  // visible for test
+  protected LocalDate getActual() {
+	return actual;
+  }
+
+  /**
+   * Verifies that the actual {@code LocalDate} is <b>strictly</b> before the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalDate.parse("2000-01-01")).isBefore(LocalDate.parse("2000-01-02"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDate} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDate} is not strictly before the given one.
+   */
+  public S isBefore(LocalDate other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateParameterIsNotNull(other);
+	if (!actual.isBefore(other)) throw Failures.instance().failure(info, shouldBeBefore(actual, other));
+	else return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isBefore(LocalDate)} but the {@link LocalDate} is built from given String, which
+   * must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"
+   * >ISO LocalDate format</a> to allow calling {@link LocalDate#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(LocalDate.parse("2000-01-01")).isBefore("2000-01-02");
+   * </code></pre>
+   * 
+   * @param localDateTimeAsString String representing a {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDate}.
+   * @throws AssertionError if the actual {@code LocalDate} is not strictly before the {@link LocalDate} built
+   *           from given String.
+   */
+  public S isBefore(String localDateTimeAsString) {
+	assertLocalDateAsStringParameterIsNotNull(localDateTimeAsString);
+	return isBefore(LocalDate.parse(localDateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalDate} is before or equals to the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalDate.parse("2000-01-01"))
+   *           .isBeforeOrEqualTo(LocalDate.parse("2000-01-01"))
+   *           .isBeforeOrEqualTo(LocalDate.parse("2000-01-02"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDate} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDate} is not before or equals to the given one.
+   */
+  public S isBeforeOrEqualTo(LocalDate other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateParameterIsNotNull(other);
+	if (actual.isAfter(other)) {
+	  throw Failures.instance().failure(info, shouldBeBeforeOrEqualsTo(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isBeforeOrEqualTo(LocalDate)} but the {@link LocalDate} is built from given
+   * String, which must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"
+   * >ISO LocalDate format</a> to allow calling {@link LocalDate#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(LocalDate.parse("2000-01-01"))
+   *            .isBeforeOrEqualTo("2000-01-01")
+   *            .isBeforeOrEqualTo("2000-01-02");
+   * </code></pre>
+   * 
+   * @param localDateTimeAsString String representing a {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDate}.
+   * @throws AssertionError if the actual {@code LocalDate} is not before or equals to the {@link LocalDate} built from
+   *           given String.
+   */
+  public S isBeforeOrEqualTo(String localDateTimeAsString) {
+	assertLocalDateAsStringParameterIsNotNull(localDateTimeAsString);
+	return isBeforeOrEqualTo(LocalDate.parse(localDateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalDate} is after or equals to the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalDate.parse("2000-01-01"))
+   *            .isAfterOrEqualTo(LocalDate.parse("2000-01-01"))
+   *            .isAfterOrEqualTo(LocalDate.parse("1999-12-31"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDate} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDate} is not after or equals to the given one.
+   */
+  public S isAfterOrEqualTo(LocalDate other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateParameterIsNotNull(other);
+	if (actual.isBefore(other)) {
+	  throw Failures.instance().failure(info, shouldBeAfterOrEqualsTo(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isAfterOrEqualTo(LocalDate)} but the {@link LocalDate} is built from given
+   * String, which must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"
+   * >ISO LocalDate format</a> to allow calling {@link LocalDate#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(LocalDate.parse("2000-01-01"))
+   *            .isAfterOrEqualTo("2000-01-01")
+   *            .isAfterOrEqualTo("1999-12-31");
+   * </code></pre>
+   * 
+   * @param localDateTimeAsString String representing a {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDate}.
+   * @throws AssertionError if the actual {@code LocalDate} is not after or equals to the {@link LocalDate} built from
+   *           given String.
+   */
+  public S isAfterOrEqualTo(String localDateTimeAsString) {
+	assertLocalDateAsStringParameterIsNotNull(localDateTimeAsString);
+	return isAfterOrEqualTo(LocalDate.parse(localDateTimeAsString));
+  }
+
+  /**
+   * Verifies that the actual {@code LocalDate} is <b>strictly</b> after the given one.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * assertThat(LocalDate.parse("2000-01-01")).isAfter(LocalDate.parse("1999-12-31"));
+   * </code></pre>
+   * 
+   * @param other the given {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if other {@code LocalDate} is {@code null}.
+   * @throws AssertionError if the actual {@code LocalDate} is not strictly after the given one.
+   */
+  public S isAfter(LocalDate other) {
+	Objects.instance().assertNotNull(info, actual);
+	assertLocalDateParameterIsNotNull(other);
+	if (!actual.isAfter(other)) {
+	  throw Failures.instance().failure(info, shouldBeAfter(actual, other));
+	}
+	return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isAfter(LocalDate)} but the {@link LocalDate} is built from given a String that
+   * must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"
+   * >ISO LocalDate format</a> to allow calling {@link LocalDate#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String in comparison to avoid conversion
+   * assertThat(LocalDate.parse("2000-01-01")).isAfter("1999-12-31");
+   * </code></pre>
+   * 
+   * @param localDateTimeAsString String representing a {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDate}.
+   * @throws AssertionError if the actual {@code LocalDate} is not strictly after the {@link LocalDate} built
+   *           from given String.
+   */
+  public S isAfter(String localDateTimeAsString) {
+	assertLocalDateAsStringParameterIsNotNull(localDateTimeAsString);
+	return isAfter(LocalDate.parse(localDateTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isEqualTo(Object)} (where Object is expected to be {@link LocalDate}) but here you
+   * pass {@link LocalDate} String representation that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"
+   * >ISO LocalDate format</a> to allow calling {@link LocalDate#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(LocalDate.parse("2000-01-01")).isEqualTo("2000-01-01");
+   * </code></pre>
+   * 
+   * @param dateTimeAsString String representing a {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDate}.
+   * @throws AssertionError if the actual {@code LocalDate} is not equal to the {@link LocalDate} built from
+   *           given String.
+   */
+  public S isEqualTo(String dateTimeAsString) {
+	assertLocalDateAsStringParameterIsNotNull(dateTimeAsString);
+	return isEqualTo(LocalDate.parse(dateTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isNotEqualTo(Object)} (where Object is expected to be {@link LocalDate}) but here you
+   * pass {@link LocalDate} String representation that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"
+   * >ISO LocalDate format</a> to allow calling {@link LocalDate#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use directly String in comparison to avoid writing the code to perform the conversion
+   * assertThat(LocalDate.parse("2000-01-01")).isNotEqualTo("2000-01-15");
+   * </code></pre>
+   * 
+   * @param dateTimeAsString String representing a {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDate}.
+   * @throws AssertionError if the actual {@code LocalDate} is equal to the {@link LocalDate} built from given
+   *           String.
+   */
+  public S isNotEqualTo(String dateTimeAsString) {
+	assertLocalDateAsStringParameterIsNotNull(dateTimeAsString);
+	return isNotEqualTo(LocalDate.parse(dateTimeAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isIn(Object...)} (where Objects are expected to be {@link LocalDate}) but here you
+   * pass {@link LocalDate} String representations that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"
+   * >ISO LocalDate format</a> to allow calling {@link LocalDate#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String based representation of LocalDate
+   * assertThat(LocalDate.parse("2000-01-01")).isIn("1999-12-31", "2000-01-01");
+   * </code></pre>
+   * 
+   * @param dateTimesAsString String array representing {@link LocalDate}s.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDate}.
+   * @throws AssertionError if the actual {@code LocalDate} is not in the {@link LocalDate}s built from given
+   *           Strings.
+   */
+  public S isIn(String... dateTimesAsString) {
+	checkIsNotNullAndNotEmpty(dateTimesAsString);
+	return isIn(convertToLocalDateArray(dateTimesAsString));
+  }
+
+  /**
+   * Same assertion as {@link #isNotIn(Object...)} (where Objects are expected to be {@link LocalDate}) but here you
+   * pass {@link LocalDate} String representations that must follow <a href=
+   * "http://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html#ISO_LOCAL_DATE"
+   * >ISO LocalDate format</a> to allow calling {@link LocalDate#parse(CharSequence)} method.
+   * <p>
+   * Example :
+   * 
+   * <pre><code class='java'>
+   * // use String based representation of LocalDate
+   * assertThat(LocalDate.parse("2000-01-01")).isNotIn("1999-12-31", "2000-01-02");
+   * </code></pre>
+   * 
+   * @param dateTimesAsString Array of String representing a {@link LocalDate}.
+   * @return this assertion object.
+   * @throws AssertionError if the actual {@code LocalDate} is {@code null}.
+   * @throws IllegalArgumentException if given String is null or can't be converted to a {@link LocalDate}.
+   * @throws AssertionError if the actual {@code LocalDate} is in the {@link LocalDate}s built from given
+   *           Strings.
+   */
+  public S isNotIn(String... dateTimesAsString) {
+	checkIsNotNullAndNotEmpty(dateTimesAsString);
+	return isNotIn(convertToLocalDateArray(dateTimesAsString));
+  }
+
+  private static Object[] convertToLocalDateArray(String... dateTimesAsString) {
+	LocalDate[] dates = new LocalDate[dateTimesAsString.length];
+	for (int i = 0; i < dateTimesAsString.length; i++) {
+	  dates[i] = LocalDate.parse(dateTimesAsString[i]);
+	}
+	return dates;
+  }
+
+  private void checkIsNotNullAndNotEmpty(Object[] values) {
+	if (values == null) throw new IllegalArgumentException("The given LocalDate array should not be null");
+	if (values.length == 0) throw new IllegalArgumentException("The given LocalDate array should not be empty");
+  }
+
+  /**
+   * Check that the {@link LocalDate} string representation to compare actual {@link LocalDate} to is not null,
+   * otherwise throws a {@link IllegalArgumentException} with an explicit message
+   * 
+   * @param localDateTimeAsString String representing the {@link LocalDate} to compare actual with
+   * @throws IllegalArgumentException with an explicit message if the given {@link String} is null
+   */
+  private static void assertLocalDateAsStringParameterIsNotNull(String localDateTimeAsString) {
+	// @format:off
+	if (localDateTimeAsString == null) throw new IllegalArgumentException("The String representing the LocalDate to compare actual with should not be null");
+	// @format:on
+  }
+
+  /**
+   * Check that the {@link LocalDate} to compare actual {@link LocalDate} to is not null, in that case throws a
+   * {@link IllegalArgumentException} with an explicit message
+   * 
+   * @param other the {@link LocalDate} to check
+   * @throws IllegalArgumentException with an explicit message if the given {@link LocalDate} is null
+   */
+  private static void assertLocalDateParameterIsNotNull(LocalDate other) {
+	if (other == null) throw new IllegalArgumentException("The LocalDate to compare actual with should not be null");
+  }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/AbstractLocalDateTimeAssert.java b/src/main/java/org/assertj/core/api/AbstractLocalDateTimeAssert.java
index 110d735f0..99dc80dce 100644
--- a/src/main/java/org/assertj/core/api/AbstractLocalDateTimeAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractLocalDateTimeAssert.java
@@ -33,7 +33,8 @@ import org.assertj.core.internal.Objects;
  * @author Joel Costigliola
  * @author Marcin Zajączkowski
  */
-public abstract class AbstractLocalDateTimeAssert<S extends AbstractLocalDateTimeAssert<S>> extends AbstractAssert<S, LocalDateTime> {
+public abstract class AbstractLocalDateTimeAssert<S extends AbstractLocalDateTimeAssert<S>> extends
+    AbstractAssert<S, LocalDateTime> {
 
   public static final String NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE = "The LocalDateTime to compare actual with should not be null";
 
@@ -46,7 +47,7 @@ public abstract class AbstractLocalDateTimeAssert<S extends AbstractLocalDateTim
   protected AbstractLocalDateTimeAssert(LocalDateTime actual, Class<?> selfType) {
 	super(actual, selfType);
   }
-  
+
   // visible for test
   protected LocalDateTime getActual() {
 	return actual;
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 7d6ce6845..526e8ad2d 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -17,6 +17,7 @@ import java.io.InputStream;
 import java.math.BigDecimal;
 import java.nio.charset.Charset;
 import java.text.DateFormat;
+import java.time.LocalDate;
 import java.time.LocalDateTime;
 import java.time.ZonedDateTime;
 import java.util.Date;
@@ -562,6 +563,16 @@ public class Assertions {
     return new LocalDateTimeAssert(localDateTime);
   }
   
+  /**
+   * Creates a new instance of <code>{@link LocalDateAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static AbstractLocalDateAssert<?> assertThat(LocalDate localDate) {
+	return new LocalDateAssert(localDate);
+  }
+  
   /**
    * Creates a new instance of <code>{@link ThrowableAssert}</code>.
    *
diff --git a/src/main/java/org/assertj/core/api/BDDAssertions.java b/src/main/java/org/assertj/core/api/BDDAssertions.java
index 98f665910..1abeae1e6 100644
--- a/src/main/java/org/assertj/core/api/BDDAssertions.java
+++ b/src/main/java/org/assertj/core/api/BDDAssertions.java
@@ -15,6 +15,7 @@ package org.assertj.core.api;
 import java.io.File;
 import java.io.InputStream;
 import java.math.BigDecimal;
+import java.time.LocalDate;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -441,6 +442,16 @@ public class BDDAssertions extends Assertions {
 	return assertThat(actual);
   }
 
+  /**
+   * Creates a new instance of <code>{@link org.assertj.core.api.DateAssert}</code>.
+   *
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static AbstractLocalDateAssert<?> then(LocalDate actual) {
+	return assertThat(actual);
+  }
+
   /**
    * Creates a new </code>{@link org.assertj.core.api.BDDAssertions}</code>.
    */
diff --git a/src/main/java/org/assertj/core/api/LocalDateAssert.java b/src/main/java/org/assertj/core/api/LocalDateAssert.java
new file mode 100644
index 000000000..d1e8177fe
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/LocalDateAssert.java
@@ -0,0 +1,28 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import java.time.LocalDate;
+
+public class LocalDateAssert extends AbstractLocalDateAssert<LocalDateAssert> {
+
+  /**
+   * Creates a new <code>{@link LocalDateAssert}</code>.
+   *
+   * @param selfType the "self type"
+   * @param actual the actual value to verify
+   */
+  protected LocalDateAssert(LocalDate actual) {
+    super(actual, LocalDateAssert.class);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/Assertions_assertThat_with_LocalDate_Test.java b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_LocalDate_Test.java
new file mode 100644
index 000000000..c5b57f0b4
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/Assertions_assertThat_with_LocalDate_Test.java
@@ -0,0 +1,39 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api;
+
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+
+/**
+ * Tests for <code>{@link Assertions#assertThat(LocalDate)}</code>.
+ */
+public class Assertions_assertThat_with_LocalDate_Test {
+
+  @Test
+  public void should_create_Assert() {
+    AbstractLocalDateAssert<?> assertions = Assertions.assertThat(LocalDate.now());
+    assertThat(assertions).isNotNull();
+  }
+
+  @Test
+  public void should_pass_actual() {
+    LocalDate localDate = LocalDate.now();
+    AbstractLocalDateAssert<?> assertions = Assertions.assertThat(localDate);
+    assertThat(assertions.getActual()).isSameAs(localDate);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssertBaseTest.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssertBaseTest.java
new file mode 100644
index 000000000..f26d34ec8
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssertBaseTest.java
@@ -0,0 +1,43 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static org.junit.Assume.assumeTrue;
+
+import java.time.LocalDate;
+
+import org.assertj.core.api.AbstractLocalDateAssert;
+import org.assertj.core.api.BaseTest;
+import org.junit.experimental.theories.DataPoint;
+
+
+/**
+ * 
+ * Base test class for {@link AbstractLocalDateAssert} tests.
+ * 
+ */
+public class LocalDateAssertBaseTest extends BaseTest {
+
+  @DataPoint
+  public static LocalDate localDate1 = LocalDate.of(2000, 12, 14);
+  @DataPoint
+  public static LocalDate localDate2 = LocalDate.of(2000, 12, 13);
+  @DataPoint
+  public static LocalDate localDate3 = LocalDate.of(2000, 12, 15);
+
+  protected static void testAssumptions(LocalDate reference, LocalDate dateBefore, LocalDate dateAfter) {
+    assumeTrue(dateBefore.isBefore(reference));
+    assumeTrue(dateAfter.isAfter(reference));
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isAfterOrEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isAfterOrEqualTo_Test.java
new file mode 100644
index 000000000..17bf39680
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isAfterOrEqualTo_Test.java
@@ -0,0 +1,97 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateAssert_isAfterOrEqualTo_Test extends LocalDateAssertBaseTest {
+
+  @Theory
+  public void test_isAfterOrEqual_assertion(LocalDate referenceDate, LocalDate dateBefore,
+	                                        LocalDate dateAfter) {
+	// GIVEN
+	testAssumptions(referenceDate, dateBefore, dateAfter);
+	// WHEN
+	assertThat(dateAfter).isAfterOrEqualTo(referenceDate);
+	assertThat(referenceDate).isAfterOrEqualTo(referenceDate);
+	// THEN
+	verify_that_isAfterOrEqual_assertion_fails_and_throws_AssertionError(dateBefore, referenceDate);
+  }
+
+  @Test
+  public void test_isAfterOrEqual_assertion_error_message() {
+	try {
+	  assertThat(LocalDate.of(2000, 1, 5)).isAfterOrEqualTo(LocalDate.of(2012, 1, 1));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <2000-01-05>\n" +
+		                       "to be after or equals to:\n" +
+		                       "  <2012-01-01>");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalDate actual = null;
+	assertThat(actual).isAfterOrEqualTo(LocalDate.now());
+  }
+
+  @Test
+  public void should_fail_if_date_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The LocalDate to compare actual with should not be null");
+	assertThat(LocalDate.now()).isAfterOrEqualTo((LocalDate) null);
+  }
+
+  @Test
+  public void should_fail_if_date_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the LocalDate to compare actual with should not be null");
+	assertThat(LocalDate.now()).isAfterOrEqualTo((String) null);
+  }
+
+  private static void verify_that_isAfterOrEqual_assertion_fails_and_throws_AssertionError(LocalDate dateToCheck,
+	                                                                                       LocalDate reference) {
+	try {
+	  assertThat(dateToCheck).isAfterOrEqualTo(reference);
+	} catch (AssertionError e) {
+	  // AssertionError was expected, test same assertion with String based parameter
+	  try {
+		assertThat(dateToCheck).isAfterOrEqualTo(reference.toString());
+	  } catch (AssertionError e2) {
+		// AssertionError was expected (again)
+		return;
+	  }
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isAfter_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isAfter_Test.java
new file mode 100644
index 000000000..2e65e1116
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isAfter_Test.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static java.time.LocalDate.parse;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+@RunWith(Theories.class)
+public class LocalDateAssert_isAfter_Test extends LocalDateAssertBaseTest {
+
+  @Theory
+  public void test_isAfter_assertion(LocalDate referenceDate, LocalDate dateBefore, LocalDate dateAfter) {
+	// GIVEN
+	testAssumptions(referenceDate, dateBefore, dateAfter);
+	// WHEN
+	assertThat(dateAfter).isAfter(referenceDate);
+	assertThat(dateAfter).isAfter(referenceDate.toString());
+	// THEN
+	verify_that_isAfter_assertion_fails_and_throws_AssertionError(referenceDate, referenceDate);
+	verify_that_isAfter_assertion_fails_and_throws_AssertionError(dateBefore, referenceDate);
+  }
+
+  @Test
+  public void test_isAfter_assertion_error_message() {
+	try {
+	  assertThat(parse("2000-01-01")).isAfter(parse("2000-01-01"));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\n" +
+		                       "Expecting:\n" +
+		                       "  <2000-01-01>\n" +
+		                       "to be strictly after:\n" +
+		                       "  <2000-01-01>");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+	expectException(AssertionError.class, actualIsNull());
+	LocalDate actual = null;
+	assertThat(actual).isAfter(LocalDate.now());
+  }
+
+  @Test
+  public void should_fail_if_date_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The LocalDate to compare actual with should not be null");
+	assertThat(LocalDate.now()).isAfter((LocalDate) null);
+  }
+
+  @Test
+  public void should_fail_if_date_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the LocalDate to compare actual with should not be null");
+	assertThat(LocalDate.now()).isAfter((String) null);
+  }
+
+  private static void verify_that_isAfter_assertion_fails_and_throws_AssertionError(LocalDate dateToCheck,
+	                                                                                LocalDate reference) {
+	try {
+	  assertThat(dateToCheck).isAfter(reference);
+	} catch (AssertionError e) {
+	  // AssertionError was expected, test same assertion with String based parameter
+	  try {
+		assertThat(dateToCheck).isAfter(reference.toString());
+	  } catch (AssertionError e2) {
+		// AssertionError was expected (again)
+		return;
+	  }
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isBeforeOrEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isBeforeOrEqualTo_Test.java
new file mode 100644
index 000000000..2907d0d93
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isBeforeOrEqualTo_Test.java
@@ -0,0 +1,93 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateAssert_isBeforeOrEqualTo_Test extends LocalDateAssertBaseTest {
+
+  @Theory
+  public void test_isBeforeOrEqual_assertion(LocalDate referenceDate, LocalDate dateBefore,
+      LocalDate dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateBefore).isBeforeOrEqualTo(referenceDate);
+    assertThat(referenceDate).isBeforeOrEqualTo(referenceDate);
+    // THEN
+    verify_that_isBeforeOrEqual_assertion_fails_and_throws_AssertionError(dateAfter, referenceDate);
+  }
+
+  @Test
+  public void test_isBeforeOrEqual_assertion_error_message() {
+    try {
+      assertThat(LocalDate.of(2000, 1, 5)).isBeforeOrEqualTo(LocalDate.of(1998, 1, 1));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05>\nto be before or equals to:\n  <1998-01-01>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDate actual = null;
+    assertThat(actual).isBeforeOrEqualTo(LocalDate.now());
+  }
+
+  @Test
+  public void should_fail_if_date_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The LocalDate to compare actual with should not be null");
+    assertThat(LocalDate.now()).isBeforeOrEqualTo((LocalDate) null);
+  }
+
+  @Test
+  public void should_fail_if_date_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the LocalDate to compare actual with should not be null");
+    assertThat(LocalDate.now()).isBeforeOrEqualTo((String) null);
+  }
+
+  private static void verify_that_isBeforeOrEqual_assertion_fails_and_throws_AssertionError(LocalDate dateToCheck,
+      LocalDate reference) {
+    try {
+      assertThat(dateToCheck).isBeforeOrEqualTo(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToCheck).isBeforeOrEqualTo(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isBefore_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isBefore_Test.java
new file mode 100644
index 000000000..9f724d31f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isBefore_Test.java
@@ -0,0 +1,92 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * @author Paweł Stawicki
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateAssert_isBefore_Test extends LocalDateAssertBaseTest {
+
+  @Theory
+  public void test_isBefore_assertion(LocalDate referenceDate, LocalDate dateBefore, LocalDate dateAfter) {
+    // GIVEN
+    testAssumptions(referenceDate, dateBefore, dateAfter);
+    // WHEN
+    assertThat(dateBefore).isBefore(referenceDate);
+    // THEN
+    verify_that_isBefore_assertion_fails_and_throws_AssertionError(referenceDate, referenceDate);
+    verify_that_isBefore_assertion_fails_and_throws_AssertionError(dateAfter, referenceDate);
+  }
+
+  @Test
+  public void test_isBefore_assertion_error_message() {
+    try {
+      assertThat(LocalDate.of(2000, 1, 5)).isBefore(LocalDate.of(1998, 1, 1));
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n  <2000-01-05>\nto be strictly before:\n  <1998-01-01>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    expectException(AssertionError.class, actualIsNull());
+    LocalDate actual = null;
+    assertThat(actual).isBefore(LocalDate.now());
+  }
+
+  @Test
+  public void should_fail_if_date_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The LocalDate to compare actual with should not be null");
+    assertThat(LocalDate.now()).isBefore((LocalDate) null);
+  }
+
+  @Test
+  public void should_fail_if_date_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the LocalDate to compare actual with should not be null");
+    assertThat(LocalDate.now()).isBefore((String) null);
+  }
+
+  private static void verify_that_isBefore_assertion_fails_and_throws_AssertionError(LocalDate dateToTest,
+      LocalDate reference) {
+    try {
+      assertThat(dateToTest).isBefore(reference);
+    } catch (AssertionError e) {
+      // AssertionError was expected, test same assertion with String based parameter
+      try {
+        assertThat(dateToTest).isBefore(reference.toString());
+      } catch (AssertionError e2) {
+        // AssertionError was expected (again)
+        return;
+      }
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isEqualTo_Test.java
new file mode 100644
index 000000000..7d699a62f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isEqualTo_Test.java
@@ -0,0 +1,70 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link java.time.LocalDate} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateAssert_isEqualTo_Test extends LocalDateAssertBaseTest {
+
+  @Theory
+  public void test_isEqualTo_assertion(LocalDate referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isEqualTo(referenceDate.toString());
+    // THEN
+    verify_that_isEqualTo_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isEqualTo_assertion_error_message() {
+    try {
+      assertThat(LocalDate.of(2000, 1, 5)).isEqualTo(LocalDate.of(2012, 1, 1).toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("expected:<20[12-01-01]> but was:<20[00-01-05]>");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_date_as_string_parameter_is_null() {
+    expectException(IllegalArgumentException.class,
+        "The String representing the LocalDate to compare actual with should not be null");
+    assertThat(LocalDate.now()).isEqualTo((String) null);
+  }
+
+  private static void verify_that_isEqualTo_assertion_fails_and_throws_AssertionError(LocalDate reference) {
+    try {
+      assertThat(reference).isEqualTo(reference.plusDays(1).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isIn_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isIn_Test.java
new file mode 100644
index 000000000..7a7971a3a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isIn_Test.java
@@ -0,0 +1,75 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalDate} are already defined in assertj-core)
+ * 
+ * @author Joel Costigliola
+ * @author Marcin Zajączkowski
+ */
+@RunWith(Theories.class)
+public class LocalDateAssert_isIn_Test extends LocalDateAssertBaseTest {
+
+  @Theory
+  public void test_isIn_assertion(LocalDate referenceDate) {
+    // WHEN
+    assertThat(referenceDate).isIn(referenceDate.toString(), referenceDate.plusDays(1).toString());
+    // THEN
+    verify_that_isIn_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isIn_assertion_error_message() {
+    try {
+      assertThat(LocalDate.of(2000, 1, 5)).isIn(LocalDate.of(2012, 1, 1).toString());
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage("\nExpecting:\n <2000-01-05>\nto be in:\n <[2012-01-01]>\n");
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dates_as_string_array_parameter_is_null() {
+    expectException(IllegalArgumentException.class, "The given LocalDate array should not be null");
+    assertThat(LocalDate.now()).isIn((String[]) null);
+  }
+
+  @Test
+  public void should_fail_if_dates_as_string_array_parameter_is_empty() {
+    expectException(IllegalArgumentException.class, "The given LocalDate array should not be empty");
+    assertThat(LocalDate.now()).isIn(new String[0]);
+  }
+
+  private static void verify_that_isIn_assertion_fails_and_throws_AssertionError(LocalDate reference) {
+    try {
+      assertThat(reference).isIn(reference.plusDays(1).toString(), reference.plusDays(2).toString());
+    } catch (AssertionError e) {
+      // AssertionError was expected
+      return;
+    }
+    fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isNotEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isNotEqualTo_Test.java
new file mode 100644
index 000000000..d9c901ee2
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isNotEqualTo_Test.java
@@ -0,0 +1,67 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalDate} are already defined in assertj-core)
+ */
+@RunWith(Theories.class)
+public class LocalDateAssert_isNotEqualTo_Test extends LocalDateAssertBaseTest {
+
+  @Theory
+  public void test_isNotEqualTo_assertion(LocalDate referenceDate) {
+	// WHEN
+	assertThat(referenceDate).isNotEqualTo(referenceDate.plusDays(1).toString());
+	// THEN
+	verify_that_isNotEqualTo_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isNotEqualTo_assertion_error_message() {
+	try {
+	  assertThat(LocalDate.of(2000, 1, 5)).isNotEqualTo(LocalDate.of(2000, 1, 5).toString());
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\nExpecting:\n <2000-01-05>\nnot to be equal to:\n <2000-01-05>\n");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_date_as_string_parameter_is_null() {
+	expectException(IllegalArgumentException.class,
+	                "The String representing the LocalDate to compare actual with should not be null");
+	assertThat(LocalDate.now()).isNotEqualTo((String) null);
+  }
+
+  private static void verify_that_isNotEqualTo_assertion_fails_and_throws_AssertionError(LocalDate reference) {
+	try {
+	  assertThat(reference).isNotEqualTo(reference.toString());
+	} catch (AssertionError e) {
+	  // AssertionError was expected
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isNotIn_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isNotIn_Test.java
new file mode 100644
index 000000000..ff5c5f5fa
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isNotIn_Test.java
@@ -0,0 +1,73 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2014 the original author or authors.
+ */
+package org.assertj.core.api.localdate;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
+
+import java.time.LocalDate;
+
+import org.junit.Test;
+import org.junit.experimental.theories.Theories;
+import org.junit.experimental.theories.Theory;
+import org.junit.runner.RunWith;
+
+/**
+ * Only test String based assertion (tests with {@link LocalDate} are already defined in assertj-core)
+ */
+@RunWith(Theories.class)
+public class LocalDateAssert_isNotIn_Test extends LocalDateAssertBaseTest {
+
+  @Theory
+  public void test_isNotIn_assertion(LocalDate referenceDate) {
+	// WHEN
+	assertThat(referenceDate).isNotIn(referenceDate.plusDays(1).toString(), referenceDate.plusDays(2).toString());
+	// THEN
+	verify_that_isNotIn_assertion_fails_and_throws_AssertionError(referenceDate);
+  }
+
+  @Test
+  public void test_isNotIn_assertion_error_message() {
+	try {
+	  assertThat(LocalDate.of(2000, 1, 5)).isNotIn(LocalDate.of(2000, 1, 5).toString(),
+		                                           LocalDate.of(2012, 1, 1).toString());
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\nExpecting:\n <2000-01-05>\nnot to be in:\n <[2000-01-05, 2012-01-01]>\n");
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+  @Test
+  public void should_fail_if_dates_as_string_array_parameter_is_null() {
+	expectException(IllegalArgumentException.class, "The given LocalDate array should not be null");
+	assertThat(LocalDate.now()).isNotIn((String[]) null);
+  }
+
+  @Test
+  public void should_fail_if_dates_as_string_array_parameter_is_empty() {
+	expectException(IllegalArgumentException.class, "The given LocalDate array should not be empty");
+	assertThat(LocalDate.now()).isNotIn(new String[0]);
+  }
+
+  private static void verify_that_isNotIn_assertion_fails_and_throws_AssertionError(LocalDate reference) {
+	try {
+	  assertThat(reference).isNotIn(reference.toString(), reference.plusDays(1).toString());
+	} catch (AssertionError e) {
+	  // AssertionError was expected
+	  return;
+	}
+	fail("Should have thrown AssertionError");
+  }
+
+}
