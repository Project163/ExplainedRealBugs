diff --git a/assertj-core/src/main/java/org/assertj/core/internal/ElementsSatisfyingConsumer.java b/assertj-core/src/main/java/org/assertj/core/internal/ElementsSatisfyingConsumer.java
index 5ddfc96fc..d84553edb 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/ElementsSatisfyingConsumer.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/ElementsSatisfyingConsumer.java
@@ -13,6 +13,7 @@
 package org.assertj.core.internal;
 
 import static java.util.stream.Collectors.toList;
+import static java.util.stream.IntStream.range;
 import static org.assertj.core.internal.Iterables.byPassingAssertions;
 import static org.assertj.core.util.Streams.stream;
 
@@ -28,12 +29,17 @@ import java.util.function.Consumer;
  * @param <E> element type
  */
 class ElementsSatisfyingConsumer<E> {
+
   private final List<E> elements;
 
   ElementsSatisfyingConsumer(Iterable<? extends E> actual, Consumer<? super E> assertions) {
     this(filterByPassingAssertions(actual, assertions));
   }
 
+  private static <E> List<E> filterByPassingAssertions(Iterable<? extends E> actual, Consumer<? super E> assertions) {
+    return stream(actual).filter(byPassingAssertions(assertions)).collect(toList());
+  }
+
   private ElementsSatisfyingConsumer(List<E> elements) {
     this.elements = elements;
   }
@@ -43,7 +49,7 @@ class ElementsSatisfyingConsumer<E> {
   }
 
   /**
-   * New <code>ElementsSatisfyingConsumer</code> containing all elements except the (first occurrence of the) given element.
+   * New <code>ElementsSatisfyingConsumer</code> containing all elements except the first occurrence of the given element.
    *
    * <p> This instance is not modified.
    *
@@ -52,11 +58,14 @@ class ElementsSatisfyingConsumer<E> {
    */
   ElementsSatisfyingConsumer<E> withoutElement(E element) {
     ArrayList<E> listWithoutElement = new ArrayList<>(elements);
-    listWithoutElement.remove(element);
+    removeFirstReference(element, listWithoutElement);
     return new ElementsSatisfyingConsumer<>(listWithoutElement);
   }
 
-  private static <E> List<E> filterByPassingAssertions(Iterable<? extends E> actual, Consumer<? super E> assertions) {
-    return stream(actual).filter(byPassingAssertions(assertions)).collect(toList());
+  private static void removeFirstReference(Object element, List<?> elements) {
+    range(0, elements.size()).filter(i -> elements.get(i) == element)
+                             .findFirst()
+                             .ifPresent(elements::remove);
   }
+
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/Iterables.java b/assertj-core/src/main/java/org/assertj/core/internal/Iterables.java
index 1230fbe98..3876ec33b 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/Iterables.java
@@ -461,7 +461,7 @@ public class Iterables {
     if (sizeOf(actual) == 0) throw failures.failure(info, shouldContainOnlyNulls(actual));
     // look for any non-null elements
     List<Object> nonNullElements = stream(actual).filter(java.util.Objects::nonNull).collect(toList());
-    if (nonNullElements.size() > 0) throw failures.failure(info, shouldContainOnlyNulls(actual, nonNullElements));
+    if (!nonNullElements.isEmpty()) throw failures.failure(info, shouldContainOnlyNulls(actual, nonNullElements));
   }
 
   /**
@@ -623,7 +623,7 @@ public class Iterables {
     checkIterableIsNotNull(values);
     List<Object> extra = stream(actual).filter(actualElement -> !iterableContains(values, actualElement))
                                        .collect(toList());
-    if (extra.size() > 0) throw failures.failure(info, shouldBeSubsetOf(actual, values, extra, comparisonStrategy));
+    if (!extra.isEmpty()) throw failures.failure(info, shouldBeSubsetOf(actual, values, extra, comparisonStrategy));
   }
 
   /**
@@ -1253,7 +1253,7 @@ public class Iterables {
     // recursively test whether we can find any specific matching permutation that can meet the requirements
     if (satisfiedElementsPerConsumer.isEmpty()) return true; // all consumers have been satisfied
 
-    // pop the head (i.e, elements satisfying the current consumer), process the tail (i.e., remaining consumers)...
+    // pop the head (i.e., elements satisfying the current consumer), process the tail (i.e., remaining consumers)...
     ElementsSatisfyingConsumer<E> head = satisfiedElementsPerConsumer.remove();
     List<E> elementsSatisfyingCurrentConsumer = head.getElements();
     if (elementsSatisfyingCurrentConsumer.isEmpty()) return false;   // no element satisfies current consumer
@@ -1335,7 +1335,7 @@ public class Iterables {
                                               .filter(Optional::isPresent)
                                               .map(Optional::get)
                                               .collect(toList());
-    if (erroneousElements.size() > 0) throw failures.failure(info, noElementsShouldSatisfy(actual, erroneousElements));
+    if (!erroneousElements.isEmpty()) throw failures.failure(info, noElementsShouldSatisfy(actual, erroneousElements));
   }
 
   private <E> Optional<E> failsRestrictions(E element, Consumer<? super E> restrictions) {
diff --git a/assertj-core/src/test/java/org/assertj/core/internal/iterables/Iterables_assertSatisfiesExactlyInAnyOrder_Test.java b/assertj-core/src/test/java/org/assertj/core/internal/iterables/Iterables_assertSatisfiesExactlyInAnyOrder_Test.java
index daa54e2ed..5cd37b4f8 100644
--- a/assertj-core/src/test/java/org/assertj/core/internal/iterables/Iterables_assertSatisfiesExactlyInAnyOrder_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/internal/iterables/Iterables_assertSatisfiesExactlyInAnyOrder_Test.java
@@ -25,18 +25,13 @@ import static org.assertj.core.util.Lists.newArrayList;
 import java.util.List;
 import java.util.function.Consumer;
 
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.IterablesBaseTest;
-import org.junit.jupiter.api.DisplayName;
+import org.assertj.core.test.Jedi;
 import org.junit.jupiter.api.Test;
 
 /**
- * Tests for <code>{@link Iterables#assertSatisfiesExactlyInAnyOrder(AssertionInfo, Iterable, Consumer[])}</code>.
- *
  * @author Ting Sun
  */
-@DisplayName("Iterables assertSatisfiesExactlyInAnyOrder")
 class Iterables_assertSatisfiesExactlyInAnyOrder_Test extends IterablesBaseTest {
 
   private List<String> actual = newArrayList("Luke", "Leia", "Yoda");
@@ -50,7 +45,6 @@ class Iterables_assertSatisfiesExactlyInAnyOrder_Test extends IterablesBaseTest
       assertThat(s).hasSize(4);
       assertThat(s).doesNotContain("L");
     }; // Matches "Yoda"
-
     // WHEN/THEN
     iterables.assertSatisfiesExactlyInAnyOrder(info, actual, array(consumer1, consumer2, consumer3));
   }
@@ -61,7 +55,6 @@ class Iterables_assertSatisfiesExactlyInAnyOrder_Test extends IterablesBaseTest
     Consumer<String> consumer1 = s -> assertThat(s).contains("Y"); // Matches "Yoda"
     Consumer<String> consumer2 = s -> assertThat(s).contains("L"); // Matches "Luke" and "Leia"
     Consumer<String> consumer3 = s -> assertThat(s).doesNotContain("a"); // Matches "Luke"
-
     // WHEN/THEN
     iterables.assertSatisfiesExactlyInAnyOrder(info, actual, array(consumer1, consumer2, consumer3));
     iterables.assertSatisfiesExactlyInAnyOrder(info, actual, array(consumer1, consumer3, consumer2));
@@ -82,7 +75,6 @@ class Iterables_assertSatisfiesExactlyInAnyOrder_Test extends IterablesBaseTest
                                                                                                           array(consumer1,
                                                                                                                 consumer2,
                                                                                                                 consumer3)));
-
     // THEN
     then(assertionError).hasMessage(shouldSatisfyExactlyInAnyOrder(actual).create());
   }
@@ -118,12 +110,12 @@ class Iterables_assertSatisfiesExactlyInAnyOrder_Test extends IterablesBaseTest
   }
 
   @Test
-  void should_pass_if_iterable_contains_multiple_equal_elements() {
+  void should_pass_if_iterable_contains_same_elements() {
     // GIVEN
-    List<String> names = newArrayList("Luke", "Luke");
+    String luke = "Luke";
+    List<String> names = newArrayList(luke, luke);
     Consumer<String> consumer1 = s -> assertThat(s).contains("L");
     Consumer<String> consumer2 = s -> assertThat(s).contains("u");
-
     // WHEN/THEN
     iterables.assertSatisfiesExactlyInAnyOrder(info, names, array(consumer1, consumer2));
   }
@@ -186,4 +178,38 @@ class Iterables_assertSatisfiesExactlyInAnyOrder_Test extends IterablesBaseTest
     then(assertionError).hasMessage(shouldHaveSize(actual, 3, 4).create());
   }
 
+  @Test
+  void should_pass_without_relying_on_elements_equality() {
+    // GIVEN
+    List<Jedi> actual = newArrayList(new JediOverridingEquals("Luke", "blue"),
+                                     new JediOverridingEquals("Luke", "green"),
+                                     new JediOverridingEquals("Luke", "green"));
+    Consumer<Jedi>[] consumers = array(jedi -> assertThat(jedi.lightSaberColor).isEqualTo("green"),
+                                       jedi -> assertThat(jedi.lightSaberColor).isEqualTo("blue"),
+                                       jedi -> assertThat(jedi.lightSaberColor).isEqualTo("green"));
+    // WHEN/THEN
+    iterables.assertSatisfiesExactlyInAnyOrder(info, actual, consumers);
+  }
+
+  private static class JediOverridingEquals extends Jedi {
+
+    private JediOverridingEquals(String name, String lightSaberColor) {
+      super(name, lightSaberColor);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      JediOverridingEquals jedi = (JediOverridingEquals) o;
+      return getName().equals(jedi.getName());
+    }
+
+    @Override
+    public int hashCode() {
+      return getName().hashCode();
+    }
+
+  }
+
 }
