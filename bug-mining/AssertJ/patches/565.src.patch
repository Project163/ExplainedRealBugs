diff --git a/assertj-core/argFile b/assertj-core/argFile
index c8e044e10..2eff8b334 100644
--- a/assertj-core/argFile
+++ b/assertj-core/argFile
@@ -55,6 +55,7 @@
 --add-opens org.assertj.core/org.assertj.core.api.float_=org.junit.platform.commons
 --add-opens org.assertj.core/org.assertj.core.api.floatarray=org.junit.platform.commons
 --add-opens org.assertj.core/org.assertj.core.api.future=org.junit.platform.commons
+--add-opens org.assertj.core/org.assertj.core.api.hashset=org.junit.platform.commons
 --add-opens org.assertj.core/org.assertj.core.api.instant=org.junit.platform.commons
 --add-opens org.assertj.core/org.assertj.core.api.int2darray=org.junit.platform.commons
 --add-opens org.assertj.core/org.assertj.core.api.intarray=org.junit.platform.commons
diff --git a/assertj-core/src/main/java/org/assertj/core/api/Assertions.java b/assertj-core/src/main/java/org/assertj/core/api/Assertions.java
index 452ea1d19..d0dcf4ac5 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/Assertions.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/Assertions.java
@@ -46,6 +46,7 @@ import java.time.temporal.TemporalUnit;
 import java.util.ArrayList;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -3278,6 +3279,17 @@ public class Assertions implements InstanceOfAssertFactories {
     return assertThat(actual);
   }
 
+  /**
+   * Creates a new instance of <code>{@link HashSetAssert}</code>.
+   *
+   * @param <ELEMENT> the type of elements.
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static <ELEMENT> HashSetAssert<ELEMENT> assertThat(HashSet<? extends ELEMENT> actual) {
+    return AssertionsForClassTypes.assertThat(actual);
+  }
+
   /**
    * Creates a new instance of <code>{@link ListAssert}</code>.
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/AssertionsForClassTypes.java b/assertj-core/src/main/java/org/assertj/core/api/AssertionsForClassTypes.java
index 9e99a9e03..86adaf983 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AssertionsForClassTypes.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AssertionsForClassTypes.java
@@ -34,6 +34,7 @@ import java.time.Period;
 import java.time.YearMonth;
 import java.time.ZonedDateTime;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Optional;
 import java.util.OptionalDouble;
@@ -601,6 +602,10 @@ public class AssertionsForClassTypes {
     return new StringAssert(actual);
   }
 
+  public static <ELEMENT> HashSetAssert<ELEMENT> assertThat(HashSet<? extends ELEMENT> actual) {
+    return new HashSetAssert<>(actual);
+  }
+
   /**
    * Creates a new instance of <code>{@link DateAssert}</code>.
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/Assumptions.java b/assertj-core/src/main/java/org/assertj/core/api/Assumptions.java
index e24857b8d..4e43cdbf0 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/Assumptions.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/Assumptions.java
@@ -43,6 +43,7 @@ import java.time.ZonedDateTime;
 import java.time.temporal.Temporal;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -1649,6 +1650,7 @@ public class Assumptions {
     if (assertion instanceof FloatArrayAssert) return asAssumption(FloatArrayAssert.class, float[].class, actual);
     if (assertion instanceof FutureAssert) return asAssumption(FutureAssert.class, Future.class, actual);
     if (assertion instanceof InputStreamAssert) return asAssumption(InputStreamAssert.class, InputStream.class, actual);
+    if (assertion instanceof HashSetAssert) return asAssumption(HashSetAssert.class, HashSet.class, actual);
     if (assertion instanceof InstantAssert) return asAssumption(InstantAssert.class, Instant.class, actual);
     if (assertion instanceof IntegerAssert) return asAssumption(IntegerAssert.class, Integer.class, actual);
     if (assertion instanceof Int2DArrayAssert) return asAssumption(Int2DArrayAssert.class, int[][].class, actual);
diff --git a/assertj-core/src/main/java/org/assertj/core/api/BDDAssertions.java b/assertj-core/src/main/java/org/assertj/core/api/BDDAssertions.java
index 89cf9b98a..151aa173d 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/BDDAssertions.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/BDDAssertions.java
@@ -37,6 +37,7 @@ import java.time.temporal.Temporal;
 import java.time.temporal.TemporalUnit;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -748,6 +749,17 @@ public class BDDAssertions extends Assertions {
     return then(actual);
   }
 
+  /**
+   * Creates a new instance of <code>{@link HashSetAssert}</code>.
+   *
+   * @param <ELEMENT> the type of elements.
+   * @param actual the actual value.
+   * @return the created assertion object.
+   */
+  public static <ELEMENT> HashSetAssert<ELEMENT> then(HashSet<? extends ELEMENT> actual) {
+    return assertThat(actual);
+  }
+
   /**
    * Creates a new instance of <code>{@link org.assertj.core.api.ListAssert}</code>.
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/BDDSoftAssertionsProvider.java b/assertj-core/src/main/java/org/assertj/core/api/BDDSoftAssertionsProvider.java
index 199791afe..70fe72486 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/BDDSoftAssertionsProvider.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/BDDSoftAssertionsProvider.java
@@ -35,6 +35,7 @@ import java.time.ZonedDateTime;
 import java.time.temporal.Temporal;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -1536,6 +1537,18 @@ public interface BDDSoftAssertionsProvider extends SoftAssertionsProvider {
     return proxy(SpliteratorAssert.class, Spliterator.class, actual);
   }
 
+  /**
+   * Creates a new instance of <code>{@link HashSetAssert}</code>.
+   *
+   * @param <ELEMENT> the type of elements.
+   * @param actual the actual value.
+   * @return the created assertion object.
+   * @since 4.0.0
+   */
+  default <ELEMENT> HashSetAssert<ELEMENT> then(HashSet<? extends ELEMENT> actual) {
+    return proxy(HashSetAssert.class, HashSet.class, actual);
+  }
+
   /**
    * Create assertion for {@link LongAdder}.
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/HashSetAssert.java b/assertj-core/src/main/java/org/assertj/core/api/HashSetAssert.java
new file mode 100644
index 000000000..5fa6a2abd
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/api/HashSetAssert.java
@@ -0,0 +1,121 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.util.stream.Collectors.toCollection;
+import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;
+import static org.assertj.core.util.Streams.stream;
+
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.LinkedHashSet;
+import java.util.Set;
+
+import org.assertj.core.api.comparisonstrategy.StandardComparisonStrategy;
+import org.assertj.core.internal.Iterables;
+
+/**
+ * Assertion methods for <code>{@link HashSet}</code>, honoring the hash code comparison.
+ * <p>
+ * The base goal is to follow <code>{@link HashSet#contains(Object)}</code> logic from Java
+ * - as soon as <code>hashCode</code> of the element changes, <code>{@link HashSet}</code> doesn't recognize it anymore.
+ * <p>
+ * Methods checking all the elements (like <code>{@link #areAtLeast(int, Condition)}</code>) or methods requiring further
+ * assertions on the elements anyway (like <code>{@link #isSubsetOf(Iterable)}</code>), behave as usual,
+ * but e.g. <code>{@link #contains(Object...)}</code>, <code>{@link #doesNotContainSubsequence(Iterable)}</code>, etc.
+ * honors the hash code comparison.
+ * <p>
+ * When more relaxed approach is needed, use <code>{@link #skippingHashCodeComparison()}</code> to start checking the actual
+ * <code>{@link Set}</code> elements one by one,  as for ordinary collections and iterables.
+ *
+ * @param <ELEMENT> the type of elements stored in <code>{@link HashSet}</code>.
+ * 
+ * @author Mateusz Chrzonstowski
+ */
+public class HashSetAssert<ELEMENT>
+    extends AbstractCollectionAssert<HashSetAssert<ELEMENT>, HashSet<? extends ELEMENT>, ELEMENT, ObjectAssert<ELEMENT>> {
+
+  private final Iterables originalIterables;
+
+  public HashSetAssert(HashSet<? extends ELEMENT> elements) {
+    super(elements, HashSetAssert.class);
+    originalIterables = iterables;
+    iterables = new Iterables(new InHashSetComparisonStrategy(actual));
+  }
+
+  /**
+   * Starts to check the actual <code>{@link Set}</code> elements one by one, skipping the hash code comparisons.
+   * Same as using <code>{@link AbstractCollectionAssert}</code>.
+   * 
+   * @return <code>{@link AbstractCollectionAssert}</code> which ignores hash code comparisons.
+   */
+  public AbstractCollectionAssert<?, Collection<? extends ELEMENT>, ELEMENT, ObjectAssert<ELEMENT>> skippingHashCodeComparison() {
+    return assertThat((Collection<? extends ELEMENT>) actual);
+  }
+
+  @Override
+  protected ObjectAssert<ELEMENT> toAssert(ELEMENT value, String description) {
+    return new ObjectAssert<>(value).as(description);
+  }
+
+  @Override
+  protected HashSetAssert<ELEMENT> newAbstractIterableAssert(Iterable<? extends ELEMENT> iterable) {
+    HashSet<ELEMENT> setPreservingTheOrder = stream(iterable).collect(toCollection(LinkedHashSet::new));
+    return new HashSetAssert<>(setPreservingTheOrder);
+  }
+
+  /**
+   * {@inheritDoc}
+   */
+  @Override
+  public HashSetAssert<ELEMENT> isSubsetOf(Iterable<? extends ELEMENT> values) {
+    originalIterables.assertIsSubsetOf(info, actual, values);
+    return myself;
+  }
+
+  @Override
+  protected HashSetAssert<ELEMENT> isSubsetOfForProxy(ELEMENT[] values) {
+    originalIterables.assertIsSubsetOf(info, actual, Arrays.asList(values));
+    return myself;
+  }
+
+  private static class InHashSetComparisonStrategy extends StandardComparisonStrategy {
+    private final HashSet<?> originalSet;
+
+    InHashSetComparisonStrategy(HashSet<?> originalSet) {
+      super();
+      this.originalSet = originalSet;
+    }
+
+    @Override
+    public boolean iterableContains(Iterable<?> iterable, Object value) {
+      return originalSet.contains(value) && super.iterableContains(iterable, value);
+    }
+
+    @Override
+    public boolean areEqual(Object actual, Object other) {
+      return originalSet.contains(actual) && super.areEqual(actual, other);
+    }
+
+    @Override
+    public String asText() {
+      return "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    }
+
+    @Override
+    public String toString() {
+      return asText();
+    }
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/api/InstanceOfAssertFactories.java b/assertj-core/src/main/java/org/assertj/core/api/InstanceOfAssertFactories.java
index ee11ae5dd..4c4b00539 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/InstanceOfAssertFactories.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/InstanceOfAssertFactories.java
@@ -33,6 +33,7 @@ import java.time.ZonedDateTime;
 import java.time.temporal.Temporal;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -925,6 +926,30 @@ public interface InstanceOfAssertFactories {
     return new InstanceOfAssertFactory<>(Set.class, new Class[] { elementType }, Assertions::<E> assertThat);
   }
 
+  /**
+   * {@link InstanceOfAssertFactory} for a {@link HashSet}, assuming {@code Object} as element type.
+   *
+   * @see #hashSet(Class)
+   * @since 4.0.0
+   */
+  @SuppressWarnings("rawtypes")
+  InstanceOfAssertFactory<HashSet, HashSetAssert<Object>> HASH_SET = hashSet(Object.class);
+
+  /**
+   * {@link InstanceOfAssertFactory} for a {@link HashSet}.
+   *
+   * @param <E>   the {@code HashSet} element type.
+   * @param elementType the element type instance.
+   * @return the factory instance.
+   *
+   * @see #HASH_SET
+   * @since 3.26.0
+   */
+  @SuppressWarnings("rawtypes")
+  static <E> InstanceOfAssertFactory<HashSet, HashSetAssert<E>> hashSet(Class<E> elementType) {
+    return new InstanceOfAssertFactory<>(HashSet.class, new Class[] { elementType }, Assertions::<E> assertThat);
+  }
+
   /**
    * {@link InstanceOfAssertFactory} for a {@link Stream}, assuming {@code Object} as element type.
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/StandardSoftAssertionsProvider.java b/assertj-core/src/main/java/org/assertj/core/api/StandardSoftAssertionsProvider.java
index 4d327df84..b57e1d2f7 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/StandardSoftAssertionsProvider.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/StandardSoftAssertionsProvider.java
@@ -35,6 +35,7 @@ import java.time.ZonedDateTime;
 import java.time.temporal.Temporal;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -1518,4 +1519,16 @@ public interface StandardSoftAssertionsProvider extends SoftAssertionsProvider {
     return proxy(TemporalAssert.class, Temporal.class, actual);
   }
 
+  /**
+   * Creates a new instance of <code>{@link HashSetAssert}</code>.
+   *
+   * @param <ELEMENT> the type of elements.
+   * @param actual the actual value.
+   * @return the created assertion object.
+   * @since 4.0.0
+   */
+  default <ELEMENT> HashSetAssert<ELEMENT> assertThat(HashSet<? extends ELEMENT> actual) {
+    return proxy(HashSetAssert.class, HashSet.class, actual);
+  }
+
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/WithAssertions.java b/assertj-core/src/main/java/org/assertj/core/api/WithAssertions.java
index b66901ed3..40aed38ac 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/WithAssertions.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/WithAssertions.java
@@ -37,6 +37,7 @@ import java.time.temporal.Temporal;
 import java.time.temporal.TemporalUnit;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -3271,6 +3272,10 @@ public interface WithAssertions extends InstanceOfAssertFactories {
     return Assertions.assertThat(component);
   }
 
+  default <ELEMENT> HashSetAssert<ELEMENT> assertThat(HashSet<? extends ELEMENT> actual) {
+    return Assertions.assertThat(actual);
+  }
+
   // --------------------------------------------------------------------------------------------------
   // Filter methods : not assertions but here to have a complete entry point to all AssertJ features.
   // --------------------------------------------------------------------------------------------------
diff --git a/assertj-core/src/main/java/org/assertj/core/api/comparisonstrategy/ComparatorBasedComparisonStrategy.java b/assertj-core/src/main/java/org/assertj/core/api/comparisonstrategy/ComparatorBasedComparisonStrategy.java
index ae8520ac8..0ff550e45 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/comparisonstrategy/ComparatorBasedComparisonStrategy.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/comparisonstrategy/ComparatorBasedComparisonStrategy.java
@@ -165,12 +165,12 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   @SuppressWarnings("unchecked")
   @Override
   protected Set<Object> newSetUsingComparisonStrategy() {
-    return new TreeSet<>(comparator);
+    return new TreeSet<Object>(comparator);
   }
 
   @Override
   public String asText() {
-    return "when comparing values using " + toString();
+    return "when comparing values using " + this;
   }
 
   @Override
@@ -218,9 +218,4 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   public boolean isGreaterThan(Object actual, Object other) {
     return comparator.compare(actual, other) > 0;
   }
-
-  @Override
-  public boolean isStandard() {
-    return false;
-  }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/Iterables.java b/assertj-core/src/main/java/org/assertj/core/internal/Iterables.java
index 20e5ba789..5a9db9d1c 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/Iterables.java
@@ -390,19 +390,19 @@ public class Iterables {
    *           {@code Iterable} contains values that are not in the given array.
    */
   public void assertContainsOnly(AssertionInfo info, Iterable<?> actual, Object[] expectedValues) {
-    final List<?> actualAsList = newArrayList(actual);
+    final Collection<?> actualAsCollection = ensureActualCanBeReadMultipleTimes(actual);
     // don't use commonCheckThatIterableAssertionSucceeds to get a better error message when actual is not empty and
     // expectedValues is
-    checkNotNullIterables(info, actualAsList, expectedValues);
+    checkNotNullIterables(info, actualAsCollection, expectedValues);
     // if both actual and values are empty, then assertion passes.
-    if (actualAsList.isEmpty() && expectedValues.length == 0) return;
+    if (actualAsCollection.isEmpty() && expectedValues.length == 0) return;
 
     // after the for loop, unexpected = expectedValues - actual
-    List<Object> unexpectedValues = newArrayList(actualAsList);
+    List<Object> unexpectedValues = newArrayList(actualAsCollection);
     // after the for loop, missing = actual - expectedValues
     List<Object> missingValues = newArrayList(expectedValues);
     for (Object expected : expectedValues) {
-      if (iterableContains(actualAsList, expected)) {
+      if (iterableContains(actualAsCollection, expected)) {
         // since expected was found in actual:
         // -- it does not belong to the missing elements
         iterablesRemove(missingValues, expected);
@@ -412,7 +412,7 @@ public class Iterables {
     }
 
     if (!unexpectedValues.isEmpty() || !missingValues.isEmpty()) {
-      throw failures.failure(info, shouldContainOnly(actualAsList, expectedValues,
+      throw failures.failure(info, shouldContainOnly(actualAsCollection, expectedValues,
                                                      missingValues, unexpectedValues,
                                                      comparisonStrategy));
     }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/HashSetAssertBaseTest.java b/assertj-core/src/test/java/org/assertj/core/api/HashSetAssertBaseTest.java
new file mode 100644
index 000000000..1f543d87d
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/HashSetAssertBaseTest.java
@@ -0,0 +1,37 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static org.assertj.core.util.Sets.newHashSet;
+import static org.mockito.Mockito.mock;
+
+import java.util.HashSet;
+
+import org.assertj.core.internal.Iterables;
+
+public abstract class HashSetAssertBaseTest extends BaseTestTemplate<HashSetAssert<Object>, HashSet<? extends Object>> {
+  protected final Object[] someValues = { "Yoda", "Luke" };
+  protected Iterables iterables;
+
+  @Override
+  protected void inject_internal_objects() {
+    super.inject_internal_objects();
+    iterables = mock(Iterables.class);
+    assertions.iterables = iterables;
+  }
+
+  @Override
+  protected HashSetAssert<Object> create_assertions() {
+    return new HashSetAssert<>(newHashSet());
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/InstanceOfAssertFactoriesTest.java b/assertj-core/src/test/java/org/assertj/core/api/InstanceOfAssertFactoriesTest.java
index d5260d492..b32aa3575 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/InstanceOfAssertFactoriesTest.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/InstanceOfAssertFactoriesTest.java
@@ -60,6 +60,7 @@ import static org.assertj.core.api.InstanceOfAssertFactories.FLOAT;
 import static org.assertj.core.api.InstanceOfAssertFactories.FLOAT_2D_ARRAY;
 import static org.assertj.core.api.InstanceOfAssertFactories.FLOAT_ARRAY;
 import static org.assertj.core.api.InstanceOfAssertFactories.FUTURE;
+import static org.assertj.core.api.InstanceOfAssertFactories.HASH_SET;
 import static org.assertj.core.api.InstanceOfAssertFactories.INPUT_STREAM;
 import static org.assertj.core.api.InstanceOfAssertFactories.INSTANT;
 import static org.assertj.core.api.InstanceOfAssertFactories.INTEGER;
@@ -119,6 +120,7 @@ import static org.assertj.core.api.InstanceOfAssertFactories.comparable;
 import static org.assertj.core.api.InstanceOfAssertFactories.completableFuture;
 import static org.assertj.core.api.InstanceOfAssertFactories.completionStage;
 import static org.assertj.core.api.InstanceOfAssertFactories.future;
+import static org.assertj.core.api.InstanceOfAssertFactories.hashSet;
 import static org.assertj.core.api.InstanceOfAssertFactories.iterable;
 import static org.assertj.core.api.InstanceOfAssertFactories.iterator;
 import static org.assertj.core.api.InstanceOfAssertFactories.list;
@@ -131,6 +133,7 @@ import static org.assertj.core.api.InstanceOfAssertFactories.stream;
 import static org.assertj.core.api.InstanceOfAssertFactories.throwable;
 import static org.assertj.core.api.InstanceOfAssertFactories.type;
 import static org.assertj.core.testkit.Maps.mapOf;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
 import static org.junit.jupiter.api.TestInstance.Lifecycle.PER_CLASS;
 import static org.mockito.AdditionalAnswers.delegatesTo;
 import static org.mockito.ArgumentMatchers.assertArg;
@@ -161,6 +164,7 @@ import java.time.ZonedDateTime;
 import java.time.temporal.Temporal;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -198,6 +202,7 @@ import java.util.stream.DoubleStream;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
 import java.util.stream.Stream;
+
 import org.assertj.core.api.AssertFactory.ValueProvider;
 import org.assertj.core.util.Lists;
 import org.assertj.core.util.Sets;
@@ -2940,6 +2945,72 @@ class InstanceOfAssertFactoriesTest {
 
   }
 
+  @Nested
+  @TestInstance(PER_CLASS)
+  class HashSet_Factory {
+
+    private final Object actual = newLinkedHashSet(123, 456, 789);
+
+    @Test
+    void createAssert() {
+      // WHEN
+      HashSetAssert<Object> result = HASH_SET.createAssert(actual);
+      // THEN
+      result.contains(456, 789);
+    }
+
+    @ParameterizedTest
+    @MethodSource("valueProviders")
+    void createAssert_with_ValueProvider(ValueProvider<?> delegate) {
+      // GIVEN
+      ValueProvider<?> valueProvider = mockThatDelegatesTo(delegate);
+      // WHEN
+      HashSetAssert<Object> result = HASH_SET.createAssert(valueProvider);
+      // THEN
+      result.contains(456, 789);
+      verify(valueProvider).apply(parameterizedType(HashSet.class, Object.class));
+    }
+
+    private Stream<ValueProvider<?>> valueProviders() {
+      return Stream.of(type -> actual,
+                       type -> convert(new int[] { 123, 456, 789 }, type));
+    }
+
+  }
+
+  @Nested
+  @TestInstance(PER_CLASS)
+  class HashSet_Typed_Factory {
+
+    private final Object actual = newLinkedHashSet(123, 456, 789);
+
+    @Test
+    void createAssert() {
+      // WHEN
+      HashSetAssert<Integer> result = hashSet(Integer.class).createAssert(actual);
+      // THEN
+      result.contains(456, 789);
+    }
+
+    @ParameterizedTest
+    @MethodSource("valueProviders")
+    void createAssert_with_ValueProvider(ValueProvider<?> delegate) {
+      // GIVEN
+      ValueProvider<?> valueProvider = mockThatDelegatesTo(delegate);
+      // WHEN
+      HashSetAssert<Integer> result = hashSet(Integer.class).createAssert(valueProvider);
+      // THEN
+      result.contains(456, 789);
+      verify(valueProvider).apply(parameterizedType(HashSet.class, Integer.class));
+    }
+
+    private Stream<ValueProvider<?>> valueProviders() {
+      return Stream.of(type -> actual,
+                       type -> convert(new String[] { "123", "456", "789" }, type));
+    }
+
+  }
+
   @Nested
   class Stream_Factory {
 
diff --git a/assertj-core/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_extracting_and_narrowing_value_Test.java b/assertj-core/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_extracting_and_narrowing_value_Test.java
index 480429303..82f4fb2c8 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_extracting_and_narrowing_value_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_extracting_and_narrowing_value_Test.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api.assumptions;
 
 import static com.google.common.collect.Maps.newHashMap;
+import static java.util.Collections.emptyIterator;
 import static java.util.Collections.emptyList;
 import static java.util.concurrent.CompletableFuture.completedFuture;
 import static org.assertj.core.api.Assumptions.assumeThat;
@@ -59,6 +60,7 @@ import static org.assertj.core.api.InstanceOfAssertFactories.FLOAT;
 import static org.assertj.core.api.InstanceOfAssertFactories.FLOAT_2D_ARRAY;
 import static org.assertj.core.api.InstanceOfAssertFactories.FLOAT_ARRAY;
 import static org.assertj.core.api.InstanceOfAssertFactories.FUTURE;
+import static org.assertj.core.api.InstanceOfAssertFactories.HASH_SET;
 import static org.assertj.core.api.InstanceOfAssertFactories.INPUT_STREAM;
 import static org.assertj.core.api.InstanceOfAssertFactories.INSTANT;
 import static org.assertj.core.api.InstanceOfAssertFactories.INTEGER;
@@ -100,9 +102,11 @@ import static org.assertj.core.api.InstanceOfAssertFactories.THROWABLE;
 import static org.assertj.core.api.InstanceOfAssertFactories.URI_TYPE;
 import static org.assertj.core.api.InstanceOfAssertFactories.URL_TYPE;
 import static org.assertj.core.api.InstanceOfAssertFactories.ZONED_DATE_TIME;
+import static org.assertj.core.api.InstanceOfAssertFactories.hashSet;
 import static org.assertj.core.api.InstanceOfAssertFactories.list;
 import static org.assertj.core.testkit.ClasspathResources.resourcePath;
 import static org.assertj.core.util.AssertionsUtil.expectAssumptionNotMetException;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
 
 import java.io.ByteArrayInputStream;
 import java.io.File;
@@ -125,6 +129,7 @@ import java.time.Period;
 import java.time.ZonedDateTime;
 import java.util.Collection;
 import java.util.Date;
+import java.util.HashSet;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
@@ -157,12 +162,12 @@ import java.util.stream.DoubleStream;
 import java.util.stream.IntStream;
 import java.util.stream.LongStream;
 import java.util.stream.Stream;
-import org.assertj.core.util.Lists;
+
 import org.junit.jupiter.api.Test;
 
 class Assumptions_assumeThat_with_extracting_and_narrowing_value_Test {
 
-  private TestData data = new TestData();
+  private final TestData data = new TestData();
 
   @Test
   void should_ignore_test_for_failing_assumption_extracting_and_narrowing_an_array() {
@@ -482,6 +487,17 @@ class Assumptions_assumeThat_with_extracting_and_narrowing_value_Test {
     expectAssumptionNotMetException(() -> assumeThat(data).extracting(TestData::stringList, as(list(String.class))).isEmpty());
   }
 
+  @Test
+  void should_ignore_test_for_failing_assumption_extracting_and_narrowing_a_hashSet() {
+    expectAssumptionNotMetException(() -> assumeThat(data).extracting(TestData::hashSet, as(HASH_SET)).isNotEmpty());
+  }
+
+  @Test
+  void should_ignore_test_for_failing_assumption_extracting_and_narrowing_a_hashSet_of_String() {
+    expectAssumptionNotMetException(() -> assumeThat(data).extracting(TestData::stringHashSet, as(hashSet(String.class)))
+                                                          .isEmpty());
+  }
+
   @Test
   void should_ignore_test_for_failing_assumption_extracting_and_narrowing_a_localDate() {
     expectAssumptionNotMetException(() -> assumeThat(data).extracting(TestData::localDate, as(LOCAL_DATE))
@@ -881,7 +897,7 @@ class Assumptions_assumeThat_with_extracting_and_narrowing_value_Test {
     }
 
     Iterator<?> iterator() {
-      return emptyList().iterator();
+      return emptyIterator();
     }
 
     List<?> list() {
@@ -889,7 +905,15 @@ class Assumptions_assumeThat_with_extracting_and_narrowing_value_Test {
     }
 
     List<String> stringList() {
-      return Lists.list("foo");
+      return List.of("foo");
+    }
+
+    HashSet<?> hashSet() {
+      return new HashSet<>();
+    }
+
+    HashSet<String> stringHashSet() {
+      return newLinkedHashSet("foo");
     }
 
     LocalDate localDate() {
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsAll_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsAll_Test.java
new file mode 100644
index 000000000..4ff088718
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsAll_Test.java
@@ -0,0 +1,64 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContain.shouldContain;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_containsAll_Test extends HashSetAssertBaseTest {
+
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.containsAll(List.of(someValues));
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertContainsAll(getInfo(assertions), getActual(assertions), List.of(someValues));
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hashSet = hashSetFactory.createWith("Yoda", "Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hashSet).containsAll(List.of("Yoda", "Luke", "Luke", "Han"));
+  }
+
+  @HashSetTest
+  void should_fail_for_not_listed_elements_and_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsAll(List.of(first, asOriginalFirst)));
+    // THEN
+    var message = shouldContain(dates, new Date[] { first, asOriginalFirst }, List.of(first, asOriginalFirst)).create()
+                  + "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    then(assertionError).hasMessage(message);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsAnyOf_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsAnyOf_Test.java
new file mode 100644
index 000000000..a94d856a0
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsAnyOf_Test.java
@@ -0,0 +1,62 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainAnyOf.shouldContainAnyOf;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_containsAnyOf_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.containsAnyOf(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertContainsAnyOf(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hasSet = hashSetFactory.createWith("Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hasSet).containsAnyOf("Han", "Qui-Gon");
+  }
+
+  @HashSetTest
+  void should_fail_for_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsAnyOf(first, asOriginalFirst));
+    // THEN
+    String message = shouldContainAnyOf(dates, new Date[] { first, asOriginalFirst }).create()
+                     + " (elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    then(assertionError).hasMessage(message);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsExactlyInAnyOrder_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsExactlyInAnyOrder_Test.java
new file mode 100644
index 000000000..0c2162744
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsExactlyInAnyOrder_Test.java
@@ -0,0 +1,71 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainExactlyInAnyOrder.shouldContainExactlyInAnyOrder;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+import org.assertj.core.api.comparisonstrategy.StandardComparisonStrategy;
+
+class HashSetAssert_containsExactlyInAnyOrder_Test extends HashSetAssertBaseTest {
+
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.containsExactlyInAnyOrder(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertContainsExactlyInAnyOrder(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hashSet = hashSetFactory.createWith("Yoda", "Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hashSet).containsExactlyInAnyOrder("Yoda", "Han", "Luke");
+  }
+
+  @HashSetTest
+  void should_fail_for_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    Date missing = Date.from(EPOCH.plusSeconds(4));
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsExactlyInAnyOrder(first, asOriginalFirst,
+                                                                                                second, missing));
+    // THEN
+    String message = shouldContainExactlyInAnyOrder(dates,
+                                                    new Date[] { first, asOriginalFirst, second, missing },
+                                                    List.of(first, asOriginalFirst, missing),
+                                                    List.of(first),
+                                                    StandardComparisonStrategy.instance()).create()
+                     + "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    then(assertionError).hasMessage(message);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsExactly_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsExactly_Test.java
new file mode 100644
index 000000000..91d486fa8
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsExactly_Test.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainExactly.shouldContainExactly;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_containsExactly_Test extends HashSetAssertBaseTest {
+
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.containsExactly(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertContainsExactly(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hashSet = hashSetFactory.createWith("Yoda", "Yoda", "Luke", "Han");
+    // WHEN
+    String[] exactElements = hashSetFactory.createWith("Yoda", "Luke", "Han").toArray(new String[0]);
+    // THEN
+    then(hashSet).containsExactly(exactElements);
+  }
+
+  @HashSetTest
+  void should_fail_finding_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsExactly(first, second));
+    // THEN
+    String message = shouldContainExactly(dates, List.of(first, second), List.of(first), List.of(first)).create()
+                     + "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    then(assertionError).hasMessage(message);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsOnlyOnce_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsOnlyOnce_Test.java
new file mode 100644
index 000000000..536227f17
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsOnlyOnce_Test.java
@@ -0,0 +1,69 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainsOnlyOnce.shouldContainsOnlyOnce;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_containsOnlyOnce_Test extends HashSetAssertBaseTest {
+
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.containsOnlyOnce(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertContainsOnlyOnce(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hashSet = hashSetFactory.createWith("Yoda", "Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hashSet).containsOnlyOnce("Yoda", "Luke", "Han");
+  }
+
+  @HashSetTest
+  void should_fail_for_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    // THEN
+    then(dates).containsOnlyOnce(first, second);
+    // WHEN
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsOnlyOnce(second, asOriginalFirst));
+    // THEN
+    String message = shouldContainsOnlyOnce(dates,
+                                            new Date[] { second, asOriginalFirst },
+                                            newLinkedHashSet(asOriginalFirst),
+                                            newLinkedHashSet(second)).create()
+                     + "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    then(assertionError).hasMessage(message);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsOnly_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsOnly_Test.java
new file mode 100644
index 000000000..edf65132c
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsOnly_Test.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContainOnly.shouldContainOnly;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_containsOnly_Test extends HashSetAssertBaseTest {
+
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.containsOnly(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertContainsOnly(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hashSet = hashSetFactory.createWith("Yoda", "Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hashSet).containsOnly("Yoda", "Luke", "Luke", "Han");
+  }
+
+  @HashSetTest
+  void should_fail_for_not_listed_elements_and_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsOnly(first, asOriginalFirst));
+    // THEN
+    String message = shouldContainOnly(dates,
+                                       new Date[] { first, asOriginalFirst },
+                                       List.of(first, asOriginalFirst),
+                                       hashSetFactory.createWith(first, second)).create()
+                     + "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    then(assertionError).hasMessage(message);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsSequence_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsSequence_Test.java
new file mode 100644
index 000000000..adf76dd48
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsSequence_Test.java
@@ -0,0 +1,87 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+import org.junit.jupiter.api.Test;
+
+class HashSetAssert_containsSequence_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.containsSequence(someValues).containsSequence(List.of(someValues));
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables, times(2)).assertContainsSequence(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second, third);
+    Date[] exactElements = dates.toArray(new Date[0]);
+    // WHEN/THEN
+    then(dates).containsSequence(exactElements[1], exactElements[2])
+               .containsSequence(dates);
+  }
+
+  @Test
+  void should_fail_after_hashCode_changed() {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    Date fourth = Date.from(EPOCH.plusSeconds(4));
+    HashSet<Date> dates = newLinkedHashSet(first, second, third, fourth);
+    third.setTime(5_000);
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsSequence(second, third));
+    // THEN
+    then(assertionError).hasMessageContainingAll(STANDARD_REPRESENTATION.toStringOf(third),
+                                                 "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)");
+  }
+
+  @Test
+  void should_fail_after_hashCode_changed_for_Iterable() {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    Date fourth = Date.from(EPOCH.plusSeconds(4));
+    HashSet<Date> dates = newLinkedHashSet(first, second, third, fourth);
+    third.setTime(5_000);
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsSequence(List.of(second, third)));
+    // THEN
+    then(assertionError).hasMessageContainingAll(STANDARD_REPRESENTATION.toStringOf(third),
+                                                 "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)");
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsSubsequence_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsSubsequence_Test.java
new file mode 100644
index 000000000..6cb65f590
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_containsSubsequence_Test.java
@@ -0,0 +1,72 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+import org.junit.jupiter.api.Test;
+
+class HashSetAssert_containsSubsequence_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.containsSubsequence(someValues).containsSubsequence(List.of(someValues));
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables, times(2)).assertContainsSubsequence(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second, third);
+    // WHEN
+    Date[] exactElements = hashSetFactory.createWith(first, third).toArray(new Date[0]);
+    // THEN
+    then(dates).containsSubsequence(exactElements)
+               .containsSubsequence(List.of(exactElements));
+  }
+
+  @Test
+  void should_fail_after_hashCode_changed() {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = newLinkedHashSet(first, second, third);
+    first.setTime(4_000);
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).containsSubsequence(first, third));
+    // THEN
+    then(assertionError).hasMessageContainingAll(STANDARD_REPRESENTATION.toStringOf(first),
+                                                 "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)");
+
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_contains_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_contains_Test.java
new file mode 100644
index 000000000..2cbc762c6
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_contains_Test.java
@@ -0,0 +1,76 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldContain.shouldContain;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_contains_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.contains(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertContains(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hashSet = hashSetFactory.createWith("Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hashSet).contains("Han", "Luke");
+  }
+
+  @HashSetTest
+  void should_fail_for_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).contains(first, asOriginalFirst));
+    // THEN
+    var message = shouldContain(dates, new Date[] { first, asOriginalFirst }, List.of(first, asOriginalFirst)).create()
+                  + "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    then(assertionError).hasMessage(message);
+  }
+
+  @HashSetTest
+  void should_pass_if_hashCode_has_changed_but_its_comparison_is_skipped(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    // WHEN
+    first.setTime(3_000);
+    // THEN
+    then(dates).skippingHashCodeComparison()
+               .contains(first, second);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainAnyElementsOf_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainAnyElementsOf_Test.java
new file mode 100644
index 000000000..1e933be5b
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainAnyElementsOf_Test.java
@@ -0,0 +1,56 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_doesNotContainAnyElementsOf_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.doesNotContainAnyElementsOf(List.of(someValues));
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertDoesNotContainAnyElementsOf(getInfo(assertions), getActual(assertions), List.of(someValues));
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hasSet = hashSetFactory.createWith("Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hasSet).doesNotContainAnyElementsOf(List.of("Qui-Gon", "Jar Jar"));
+  }
+
+  @HashSetTest
+  void should_pass_for_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    // WHEN/THEN
+    then(dates).doesNotContainAnyElementsOf(List.of(first, asOriginalFirst));
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainSequence_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainSequence_Test.java
new file mode 100644
index 000000000..24e5d9129
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainSequence_Test.java
@@ -0,0 +1,88 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldNotBeNull.shouldNotBeNull;
+import static org.assertj.core.error.ShouldNotContainSequence.shouldNotContainSequence;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.IterableUtil.toArray;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+import org.junit.jupiter.api.Test;
+
+class HashSetAssert_doesNotContainSequence_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.doesNotContainSequence(someValues).doesNotContainSequence(List.of(someValues));
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables, times(2)).assertDoesNotContainSequence(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second, third);
+    // WHEN
+    Date[] exactElements = hashSetFactory.createWith(third, first).toArray(new Date[0]);
+    // THEN
+    then(dates).doesNotContainSequence(exactElements)
+               .doesNotContainSequence(List.of(exactElements));
+  }
+
+  @HashSetTest
+  void should_fail_in_ordinary_scenario(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> toTest = hashSetFactory.createWith("Yoda", "Luke");
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(toTest).doesNotContainSequence(toTest));
+    // THEN
+    then(assertionError).hasMessageStartingWith(shouldNotContainSequence(toTest, toArray(toTest), 0).create());
+  }
+
+  @Test
+  void should_pass_after_hashCode_changed() {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = newLinkedHashSet(first, second, third);
+    first.setTime(4_000);
+    // WHEN/THEN
+    then(dates).doesNotContainSequence(first, second);
+  }
+
+  @Test
+  void should_fail_for_null() {
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat((HashSet<String>) null).doesNotContainSequence(""));
+    // THEN
+    then(assertionError).hasMessage(shouldNotBeNull().create());
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainSubsequence_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainSubsequence_Test.java
new file mode 100644
index 000000000..3c9f339b3
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContainSubsequence_Test.java
@@ -0,0 +1,88 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldNotBeNull.shouldNotBeNull;
+import static org.assertj.core.error.ShouldNotContainSubsequence.shouldNotContainSubsequence;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.IterableUtil.toArray;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+import org.junit.jupiter.api.Test;
+
+class HashSetAssert_doesNotContainSubsequence_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.doesNotContainSubsequence(someValues).doesNotContainSubsequence(List.of(someValues));
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables, times(2)).assertDoesNotContainSubsequence(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second, third);
+    // WHEN
+    Date[] exactElements = hashSetFactory.createWith(third, first).toArray(new Date[0]);
+    // THEN
+    then(dates).doesNotContainSubsequence(exactElements)
+               .doesNotContainSubsequence(List.of(exactElements));
+  }
+
+  @HashSetTest
+  void should_fail_in_ordinary_scenario(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> toTest = hashSetFactory.createWith("Yoda", "Luke");
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(toTest).doesNotContainSubsequence(toTest));
+    // THEN
+    then(assertionError).hasMessageStartingWith(shouldNotContainSubsequence(toTest, toArray(toTest), 0).create());
+  }
+
+  @Test
+  void should_pass_after_hashCode_changed() {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = newLinkedHashSet(first, second, third);
+    first.setTime(4_000);
+    // WHEN/THEN
+    then(dates).doesNotContainSubsequence(first, third);
+  }
+
+  @Test
+  void should_fail_for_null() {
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat((HashSet<String>) null).doesNotContainSubsequence(""));
+    // THEN
+    then(assertionError).hasMessage(shouldNotBeNull().create());
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContain_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContain_Test.java
new file mode 100644
index 000000000..a80803fb2
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotContain_Test.java
@@ -0,0 +1,55 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_doesNotContain_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.doesNotContain(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertDoesNotContain(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hasSet = hashSetFactory.createWith("Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hasSet).doesNotContain("Qui-Gon", "Jar Jar");
+  }
+
+  @HashSetTest
+  void should_pass_for_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    // WHEN/THEN
+    then(dates).doesNotContain(first, asOriginalFirst);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotHaveDuplicates_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotHaveDuplicates_Test.java
new file mode 100644
index 000000000..2afaa6032
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_doesNotHaveDuplicates_Test.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldNotHaveDuplicates.shouldNotHaveDuplicates;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_doesNotHaveDuplicates_Test extends HashSetAssertBaseTest {
+
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.doesNotHaveDuplicates();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertDoesNotHaveDuplicates(getInfo(assertions), getActual(assertions));
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hashSet = hashSetFactory.createWith("Yoda", "Yoda", "Luke", "Han");
+    // WHEN/THEN
+    then(hashSet).doesNotHaveDuplicates();
+  }
+
+  @HashSetTest
+  void should_fail_for_elements_with_changed_hashCode(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).doesNotHaveDuplicates());
+    // THEN
+    var message = shouldNotHaveDuplicates(dates, newLinkedHashSet(first)).create()
+                  + "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)";
+    then(assertionError).hasMessage(message);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_endsWith_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_endsWith_Test.java
new file mode 100644
index 000000000..9b58e2159
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_endsWith_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+import org.junit.jupiter.api.Test;
+
+class HashSetAssert_endsWith_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.endsWith(someValues).endsWith(someValues[0], someValues[1]);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertEndsWith(getInfo(assertions), getActual(assertions), someValues);
+    verify(iterables).assertEndsWith(getInfo(assertions), getActual(assertions), someValues[0], new Object[] { someValues[1] });
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second, third);
+    // WHEN
+    Date[] exactElements = dates.toArray(new Date[0]);
+    // THEN
+    then(dates).endsWith(exactElements)
+               .endsWith(exactElements[1], exactElements[2]);
+  }
+
+  @Test
+  void should_fail_after_hashCode_changed() {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = newLinkedHashSet(first, second, third);
+    second.setTime(4_000);
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).endsWith(second, third));
+    // THEN
+    then(assertionError).hasMessageContainingAll(STANDARD_REPRESENTATION.toStringOf(second),
+                                                 "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)");
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_isSubsetOf_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_isSubsetOf_Test.java
new file mode 100644
index 000000000..cac65e44f
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_isSubsetOf_Test.java
@@ -0,0 +1,79 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldBeSubsetOf.shouldBeSubsetOf;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+import java.util.List;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+
+class HashSetAssert_isSubsetOf_Test extends HashSetAssertBaseTest {
+
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.isSubsetOf(List.of(someValues)).isSubsetOf(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables, never()).assertIsSubsetOf(getInfo(assertions), getActual(assertions), List.of(someValues));
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    HashSet<String> hashSet = hashSetFactory.createWith("Yoda", "Luke", "Yoda", "Han");
+    // WHEN/THEN
+    then(hashSet).isSubsetOf("Obi", "Qui-Gon", "Yoda", "Luke", "Han")
+                 .isSubsetOf(List.of("Qui-Gon", "Luke", "Han", "Yoda"));
+  }
+
+  @HashSetTest
+  void should_fail_when_hashCode_changed_as_in_superset(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    // WHEN
+    first.setTime(3_000);
+    // THEN
+    then(dates).isSubsetOf(second, Date.from(EPOCH.plusSeconds(3)));
+  }
+
+  @HashSetTest
+  void should_fail_when_hashCode_changed_differently_than_in_superset(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second);
+    first.setTime(3_000);
+    Date asOriginalFirst = Date.from(EPOCH.plusSeconds(1));
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).isSubsetOf(List.of(asOriginalFirst, second)));
+    // THEN
+    String messageStart = shouldBeSubsetOf(dates, List.of(asOriginalFirst, second), singletonList(first)).create();
+    then(assertionError).hasMessageStartingWith(messageStart)
+                        .hasMessageNotContaining("hashCode");
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_startsWith_Test.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_startsWith_Test.java
new file mode 100644
index 000000000..e8039b0d4
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetAssert_startsWith_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static java.time.Instant.EPOCH;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+import java.util.HashSet;
+
+import org.assertj.core.api.HashSetAssert;
+import org.assertj.core.api.HashSetAssertBaseTest;
+import org.junit.jupiter.api.Test;
+
+class HashSetAssert_startsWith_Test extends HashSetAssertBaseTest {
+  @Override
+  protected HashSetAssert<Object> invoke_api_method() {
+    return assertions.startsWith(someValues);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(iterables).assertStartsWith(getInfo(assertions), getActual(assertions), someValues);
+  }
+
+  @HashSetTest
+  void should_pass(HashSetFactory hashSetFactory) {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = hashSetFactory.createWith(first, second, third);
+    // WHEN
+    Date[] exactElements = dates.toArray(new Date[0]);
+    // THEN
+    then(dates).startsWith(exactElements);
+  }
+
+  @Test
+  void should_fail_after_hashCode_changed() {
+    // GIVEN
+    Date first = Date.from(EPOCH.plusSeconds(1));
+    Date second = Date.from(EPOCH.plusSeconds(2));
+    Date third = Date.from(EPOCH.plusSeconds(3));
+    HashSet<Date> dates = newLinkedHashSet(first, second, third);
+    first.setTime(4_000);
+    second.setTime(5_000);
+    // WHEN
+    var assertionError = expectAssertionError(() -> assertThat(dates).startsWith(first, second));
+    // THEN
+    then(assertionError).hasMessageContainingAll(STANDARD_REPRESENTATION.toStringOf(first),
+                                                 STANDARD_REPRESENTATION.toStringOf(second),
+                                                 "(elements were checked as in HashSet, as soon as their hashCode change, the HashSet won't find them anymore - use skippingHashCodeComparison to get a collection like comparison)");
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetFactory.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetFactory.java
new file mode 100644
index 000000000..f11e53521
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetFactory.java
@@ -0,0 +1,41 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import static org.assertj.core.util.Sets.newHashSet;
+import static org.junit.jupiter.api.Named.named;
+
+import java.util.HashSet;
+import java.util.List;
+import java.util.stream.Stream;
+
+import org.assertj.core.util.Sets;
+import org.junit.jupiter.params.provider.Arguments;
+
+@FunctionalInterface
+interface HashSetFactory {
+  <T> HashSet<T> createWith(T... elements);
+
+  static Stream<Arguments> availableFactories() {
+    return Stream.of(Arguments.of(named("ordinary HashSet",
+                                        new HashSetFactory() {
+                                          @SafeVarargs
+                                          @Override
+                                          public final <T> HashSet<T> createWith(T... elements) {
+                                            return newHashSet(List.of(elements));
+                                          }
+                                        })),
+                     Arguments.of(named("LinkedHashSet", (HashSetFactory) Sets::newLinkedHashSet)));
+  }
+
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetTest.java b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetTest.java
new file mode 100644
index 000000000..a1549f69a
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/hashset/HashSetTest.java
@@ -0,0 +1,30 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.core.api.hashset;
+
+import java.lang.annotation.Documented;
+import java.lang.annotation.ElementType;
+import java.lang.annotation.Retention;
+import java.lang.annotation.RetentionPolicy;
+import java.lang.annotation.Target;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@ParameterizedTest(name = "{0}")
+@MethodSource("org.assertj.core.api.hashset.HashSetFactory#availableFactories")
+@Target({ ElementType.ANNOTATION_TYPE, ElementType.METHOD })
+@Retention(RetentionPolicy.RUNTIME)
+@Documented
+public @interface HashSetTest {
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_sync_with_InstanceOfAssertFactories_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_sync_with_InstanceOfAssertFactories_Test.java
index c42de4b71..85ef647cb 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_sync_with_InstanceOfAssertFactories_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/Assertions_sync_with_InstanceOfAssertFactories_Test.java
@@ -31,8 +31,8 @@ import java.time.temporal.Temporal;
 import java.util.Map;
 import java.util.Map.Entry;
 import java.util.Set;
-import java.util.function.Predicate;
 import java.util.stream.Stream;
+
 import org.assertj.core.api.AbstractComparableAssert;
 import org.assertj.core.api.Assertions;
 import org.assertj.core.api.InstanceOfAssertFactories;
