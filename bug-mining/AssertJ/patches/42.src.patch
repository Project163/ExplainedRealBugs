diff --git a/src/main/java/org/assertj/core/api/AbstractDateAssert.java b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
index c3c7cf474..b7e4da469 100644
--- a/src/main/java/org/assertj/core/api/AbstractDateAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
@@ -16,35 +16,30 @@ import org.assertj.core.util.VisibleForTesting;
 
 /**
  * Base class for all implementations of assertions for {@link Date}s.
- * <p>
+ * <p/>
  * Note that assertions with date parameter comes with two flavor, one is obviously a {@link Date} and the other is a
- * {@link String} representing a Date.<br>
- * For the latter, the default format follows ISO 8901 : "yyyy-MM-dd", user can override it with a custom format by
- * calling {@link #withDateFormat(DateFormat)}.<br>
- * The user custom format will then be used for all next Date assertions (i.e not limited to the current assertion) in
- * the test suite.<br>
- * To turn back to default format, simply call {@link #withIsoDateFormat()}.
- * 
+ * {@link String} representing a Date.<br> For the latter, the default format follows ISO 8901 : "yyyy-MM-dd", user can
+ * override it with a custom format by calling {@link #withDateFormat(DateFormat)}.<br> The user custom format will then
+ * be used for all next Date assertions (i.e not limited to the current assertion) in the test suite.<br> To turn back
+ * to default format, simply call {@link #withIsoDateFormat()}.
+ *
  * @param <S> the "self" type of this assertion class. Please read &quot;<a href="http://bit.ly/anMa4g"
- *          target="_blank">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;
- *          for more details.
- * 
+ *            target="_blank">Emulating 'self types' using Java Generics to simplify fluent API implementation</a>&quot;
+ *            for more details.
  * @author Tomasz Nurkiewicz (thanks for giving assertions idea)
  * @author Joel Costigliola
  * @author Mikhail Mazursky
  */
 public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extends AbstractAssert<S, Date> {
 
-  @VisibleForTesting
-  Dates dates = Dates.instance();
-
   /**
    * Used in String based Date assertions - like {@link #isAfter(String)} - to convert input date represented as string
-   * to Date.<br>
-   * The format used can be overridden by invoking {@link #withDateFormat(DateFormat)}
+   * to Date.<br> The format used can be overridden by invoking {@link #withDateFormat(DateFormat)}
    */
   @VisibleForTesting
   static DateFormat dateFormat = org.assertj.core.util.Dates.newIsoDateFormat();
+  @VisibleForTesting
+  Dates dates = Dates.instance();
 
   protected AbstractDateAssert(Date actual, Class<?> selfType) {
     super(actual, selfType);
@@ -52,22 +47,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link AbstractAssert#isEqualTo(Object) isEqualTo(Date date)} but given Date is represented as
-   * String either with ISO date format (yyyy-MM-dd) or user custom date format (set with method
-   * {@link #withDateFormat(DateFormat)}).
-   * 
-   * <p>
-   * Example:
-   * 
+   * String either with ISO date format (yyyy-MM-dd) or user custom date format (set with method {@link
+   * #withDateFormat(DateFormat)}). <p/> <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isEqualTo(&quot;2002-12-18&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isEqualTo(&quot;2002-12-19&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
    * @throws AssertionError if actual and given Date represented as String are not equal.
@@ -79,22 +69,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link AbstractAssert#isNotEqualTo(Object) isNotEqualTo(Date date)} but given Date is represented
-   * as String either with ISO date format (yyyy-MM-dd) or user custom date format (set with method
-   * {@link #withDateFormat(DateFormat)}).
-   * 
-   * <p>
-   * Example:
-   * 
+   * as String either with ISO date format (yyyy-MM-dd) or user custom date format (set with method {@link
+   * #withDateFormat(DateFormat)}). <p/> <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isNotEqualTo(&quot;2002-12-19&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isNotEqualTo(&quot;2002-12-18&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
    * @throws AssertionError if actual and given Date represented as String are equal.
@@ -106,20 +91,19 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link Assert#isIn(Object...)} but given Dates are represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}). <p> Example:
+   * <p/>
    * <pre>
    * // assertion will pass
-   * assertThat(theTwoTowers.getReleaseDate()).isIn(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;, &quot;2002-12-19&quot;);
-   * 
+   * assertThat(theTwoTowers.getReleaseDate()).isIn(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;,
+   * &quot;2002-12-19&quot;);
+   *
    * // assertion will fail
-   * assertThat(theTwoTowers.getReleaseDate()).isIn(&quot;2002-12-17&quot;, &quot;2002-12-19&quot;, &quot;2002-12-20&quot;);
+   * assertThat(theTwoTowers.getReleaseDate()).isIn(&quot;2002-12-17&quot;, &quot;2002-12-19&quot;,
+   * &quot;2002-12-20&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param datesAsString the given Dates represented as String in default or custom date format.
    * @return this assertion object.
    * @throws AssertionError if actual is not in given Dates represented as String.
@@ -135,24 +119,20 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link Assert#isIn(Iterable)} but given Dates are represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).<br>
-   * Method signature could not be <code>isIn(Collection&lt;String&gt;)</code> because it would be same signature as
-   * <code>isIn(Collection&lt;Date&gt;)</code> since java collection type are erased at runtime.
-   * <p>
-   * Example:
-   * 
+   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).<br> Method
+   * signature could not be <code>isIn(Collection&lt;String&gt;)</code> because it would be same signature as
+   * <code>isIn(Collection&lt;Date&gt;)</code> since java collection type are erased at runtime. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isInWithStringDateCollection(
    *     Arrays.asList(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;, &quot;2002-12-19&quot;));
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isInWithStringDateCollection(
    *     Arrays.asList(&quot;2002-12-17&quot;, &quot;2002-12-19&quot;, &quot;2002-12-20&quot;));
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param datesAsString the given Dates represented as String in default or custom date format.
    * @return this assertion object.
    * @throws AssertionError if actual is not in given Dates represented as String.
@@ -168,20 +148,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link Assert#isNotIn(Object...)} but given Dates are represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}). <p> Example:
+   * <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isNotIn(&quot;2002-12-17&quot;, &quot;2002-12-19&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isNotIn(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param datesAsString the given Dates represented as String in default or custom date format.
    * @return this assertion object.
    * @throws AssertionError if actual is in given Dates represented as String.
@@ -197,22 +174,20 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link Assert#isNotIn(Iterable)} but given Dates are represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).<br>
-   * Method signature could not be <code>isNotIn(Collection&lt;String&gt;)</code> because it would be same signature as
-   * <code>isNotIn(Collection&lt;Date&gt;)</code> since java collection type are erased at runtime.
-   * <p>
-   * Example:
-   * 
+   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).<br> Method
+   * signature could not be <code>isNotIn(Collection&lt;String&gt;)</code> because it would be same signature as
+   * <code>isNotIn(Collection&lt;Date&gt;)</code> since java collection type are erased at runtime. <p> Example: <p/>
    * <pre>
    * // assertion will pass
-   * assertThat(theTwoTowers.getReleaseDate()).isNotInWithStringDateCollection(Arrays.asList(&quot;2002-12-17&quot;, &quot;2002-12-19&quot;));
-   * 
+   * assertThat(theTwoTowers.getReleaseDate()).isNotInWithStringDateCollection(Arrays.asList(&quot;2002-12-17&quot;,
+   * &quot;2002-12-19&quot;));
+   *
    * // assertion will fail
-   * assertThat(theTwoTowers.getReleaseDate()).isNotInWithStringDateCollection(Arrays.asList(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;));
+   * assertThat(theTwoTowers.getReleaseDate()).isNotInWithStringDateCollection(Arrays.asList(&quot;2002-12-17&quot;,
+   * &quot;2002-12-18&quot;));
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param datesAsString the given Dates represented as String in default or custom date format.
    * @return this assertion object.
    * @throws AssertionError if actual is in given Dates represented as String.
@@ -227,25 +202,21 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} is <b>strictly</b> before the given one.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} is <b>strictly</b> before the given one. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isBefore(theReturnOfTheKing.getReleaseDate());
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBefore(theFellowshipOfTheRing.getReleaseDate());
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param other the given Date.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if other {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not strictly before the given one.
+   * @throws AssertionError       if the actual {@code Date} is not strictly before the given one.
    */
   public S isBefore(Date other) {
     dates.assertIsBefore(info, actual, other);
@@ -254,27 +225,24 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link #isBefore(Date)} but given Date is represented as String either with ISO date format
-   * (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}). <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isBefore(&quot;2002-12-19&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBefore(&quot;2002-12-17&quot;);
    * assertThat(theTwoTowers.getReleaseDate()).isBefore(&quot;2002-12-18&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if given date as String is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not strictly before the given Date represented as String.
-   * @throws AssertionError if the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is not strictly before the given Date represented as
+   *                              String.
+   * @throws AssertionError       if the given date as String could not be converted to a Date.
    */
   public S isBefore(String dateAsString) {
     return isBefore(parse(dateAsString));
@@ -285,9 +253,9 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
    *
    * @param other the given Date.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if other {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not before or equals to the given one.
+   * @throws AssertionError       if the actual {@code Date} is not before or equals to the given one.
    */
   public S isBeforeOrEqualsTo(Date other) {
     dates.assertIsBeforeOrEqualsTo(info, actual, other);
@@ -296,52 +264,46 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link #isBeforeOrEqualsTo(Date)} but given Date is represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}). <p> Example:
+   * <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isBeforeOrEqualsTo(&quot;2002-12-19&quot;);
    * assertThat(theTwoTowers.getReleaseDate()).isBeforeOrEqualsTo(&quot;2002-12-18&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBeforeOrEqualsTo(&quot;2002-12-17&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if given date as String is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not before or equals to the given Date represented as String.
-   * @throws AssertionError if the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is not before or equals to the given Date represented as
+   *                              String.
+   * @throws AssertionError       if the given date as String could not be converted to a Date.
    */
   public S isBeforeOrEqualsTo(String dateAsString) {
     return isBeforeOrEqualsTo(parse(dateAsString));
   }
 
   /**
-   * Verifies that the actual {@code Date} is <b>strictly</b> after the given one.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} is <b>strictly</b> after the given one. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isAfter(theFellowshipOfTheRing.getReleaseDate());
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isAfter(theReturnOfTheKing.getReleaseDate());
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param other the given Date.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if other {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not strictly after the given one.
+   * @throws AssertionError       if the actual {@code Date} is not strictly after the given one.
    */
   public S isAfter(Date other) {
     dates.assertIsAfter(info, actual, other);
@@ -350,27 +312,24 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link #isAfter(Date)} but given Date is represented as String either with ISO date format
-   * (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}). <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isAfter(&quot;2002-12-17&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isAfter(&quot;2002-12-18&quot;);
    * assertThat(theTwoTowers.getReleaseDate()).isAfter(&quot;2002-12-19&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if given date as String is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not strictly after the given Date represented as String.
-   * @throws AssertionError if the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is not strictly after the given Date represented as
+   *                              String.
+   * @throws AssertionError       if the given date as String could not be converted to a Date.
    */
   public S isAfter(String dateAsString) {
     return isAfter(parse(dateAsString));
@@ -378,12 +337,12 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Verifies that the actual {@code Date} is after or equals to the given one.
-   * 
+   *
    * @param other the given Date.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if other {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not after or equals to the given one.
+   * @throws AssertionError       if the actual {@code Date} is not after or equals to the given one.
    */
   public S isAfterOrEqualsTo(Date other) {
     dates.assertIsAfterOrEqualsTo(info, actual, other);
@@ -392,56 +351,50 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link #isAfterOrEqualsTo(Date)} but given Date is represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}). <p> Example:
+   * <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isAfterOrEqualsTo(&quot;2002-12-17&quot;);
    * assertThat(theTwoTowers.getReleaseDate()).isAfterOrEqualsTo(&quot;2002-12-18&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isAfterOrEqualsTo(&quot;2002-12-19&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if given date as String is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not after or equals to the given Date represented as String.
-   * @throws AssertionError if the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is not after or equals to the given Date represented as
+   *                              String.
+   * @throws AssertionError       if the given date as String could not be converted to a Date.
    */
   public S isAfterOrEqualsTo(String dateAsString) {
     return isAfterOrEqualsTo(parse(dateAsString));
   }
 
   /**
-   * Verifies that the actual {@code Date} is in [start, end[ period (start included, end excluded).
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} is in [start, end[ period (start included, end excluded). <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isBetween(theFellowshipOfTheRing.getReleaseDate(),
    *     theReturnOfTheKing.getReleaseDate());
-   * 
+   *
    * // assertion will fail
    * assertThat(theFellowshipOfTheRing.getReleaseDate()).isBetween(theTwoTowers.getReleaseDate(),
    *     theReturnOfTheKing.getReleaseDate());
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param start the period start (inclusive), expected not to be null.
-   * @param end the period end (exclusive), expected not to be null.
+   * @param end   the period end (exclusive), expected not to be null.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if start {@code Date} is {@code null}.
    * @throws NullPointerException if end {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not in [start, end[ period.
+   * @throws AssertionError       if the actual {@code Date} is not in [start, end[ period.
    */
   public S isBetween(Date start, Date end) {
     return isBetween(start, end, true, false);
@@ -449,47 +402,44 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link #isBetween(Date, Date)} but given Dates are represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}). <p> Example:
+   * <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isBetween(&quot;2002-12-17&quot;, &quot;2002-12-19&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBetween(&quot;2002-12-15&quot;, &quot;2002-12-17&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param start the period start (inclusive), expected not to be null.
-   * @param end the period end (exclusive), expected not to be null.
+   * @param end   the period end (exclusive), expected not to be null.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if start Date as String is {@code null}.
    * @throws NullPointerException if end Date as String is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not in [start, end[ period.
-   * @throws AssertionError if one of the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is not in [start, end[ period.
+   * @throws AssertionError       if one of the given date as String could not be converted to a Date.
    */
   public S isBetween(String start, String end) {
     return isBetween(parse(start), parse(end));
   }
 
   /**
-   * Verifies that the actual {@code Date} is in the given period defined by start and end dates.<br>
-   * To include start in the period set inclusiveStart parameter to <code>true</code>.<br>
-   * To include end in the period set inclusiveEnd parameter to <code>true</code>.<br>
-   * 
-   * @param start the period start, expected not to be null.
-   * @param end the period end, expected not to be null.
+   * Verifies that the actual {@code Date} is in the given period defined by start and end dates.<br> To include start
+   * in the period set inclusiveStart parameter to <code>true</code>.<br> To include end in the period set inclusiveEnd
+   * parameter to <code>true</code>.<br>
+   *
+   * @param start          the period start, expected not to be null.
+   * @param end            the period end, expected not to be null.
    * @param inclusiveStart whether to include start date in period.
-   * @param inclusiveEnd whether to include end date in period.
+   * @param inclusiveEnd   whether to include end date in period.
    * @return this assertion object.
-   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError       if {@code actual} is {@code null}.
    * @throws NullPointerException if start {@code Date} is {@code null}.
    * @throws NullPointerException if end {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not in (start, end) period.
+   * @throws AssertionError       if the actual {@code Date} is not in (start, end) period.
    */
   public S isBetween(Date start, Date end, boolean inclusiveStart, boolean inclusiveEnd) {
     dates.assertIsBetween(info, actual, start, end, inclusiveStart, inclusiveEnd);
@@ -499,30 +449,27 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   /**
    * Same assertion as {@link #isBetween(Date, Date, boolean, boolean)} but given Dates are represented as String either
    * with ISO date format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isBetween(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;, false, true);
    * assertThat(theTwoTowers.getReleaseDate()).isBetween(&quot;2002-12-18&quot;, &quot;2002-12-19&quot;, true, false);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBetween(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;, false, false);
    * </pre>
-   * 
-   * </p>
-   * 
-   * @param start the period start, expected not to be null.
-   * @param end the period end, expected not to be null.
+   * <p/> </p>
+   *
+   * @param start          the period start, expected not to be null.
+   * @param end            the period end, expected not to be null.
    * @param inclusiveStart whether to include start date in period.
-   * @param inclusiveEnd whether to include end date in period.
+   * @param inclusiveEnd   whether to include end date in period.
    * @return this assertion object.
-   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError       if {@code actual} is {@code null}.
    * @throws NullPointerException if start Date as String is {@code null}.
    * @throws NullPointerException if end Date as String is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not in (start, end) period.
-   * @throws AssertionError if one of the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is not in (start, end) period.
+   * @throws AssertionError       if one of the given date as String could not be converted to a Date.
    */
   public S isBetween(String start, String end, boolean inclusiveStart, boolean inclusiveEnd) {
     dates.assertIsBetween(info, actual, parse(start), parse(end), inclusiveStart, inclusiveEnd);
@@ -530,19 +477,19 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} is not in the given period defined by start and end dates.<br>
-   * To include start in the period set inclusiveStart parameter to <code>true</code>.<br>
-   * To include end in the period set inclusiveEnd parameter to <code>true</code>.<br>
-   * 
-   * @param start the period start (inclusive), expected not to be null.
-   * @param end the period end (exclusive), expected not to be null.
+   * Verifies that the actual {@code Date} is not in the given period defined by start and end dates.<br> To include
+   * start in the period set inclusiveStart parameter to <code>true</code>.<br> To include end in the period set
+   * inclusiveEnd parameter to <code>true</code>.<br>
+   *
+   * @param start          the period start (inclusive), expected not to be null.
+   * @param end            the period end (exclusive), expected not to be null.
    * @param inclusiveStart whether to include start date in period.
-   * @param inclusiveEnd whether to include end date in period.
+   * @param inclusiveEnd   whether to include end date in period.
    * @return this assertion object.
-   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError       if {@code actual} is {@code null}.
    * @throws NullPointerException if start {@code Date} is {@code null}.
    * @throws NullPointerException if end {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not in (start, end) period.
+   * @throws AssertionError       if the actual {@code Date} is not in (start, end) period.
    */
   public S isNotBetween(Date start, Date end, boolean inclusiveStart, boolean inclusiveEnd) {
     dates.assertIsNotBetween(info, actual, start, end, inclusiveStart, inclusiveEnd);
@@ -551,32 +498,31 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link #isNotBetween(Date, Date, boolean, boolean)} but given Dates are represented as String
-   * either with ISO date format (yyyy-MM-dd) or user custom date format (set with method
-   * {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * either with ISO date format (yyyy-MM-dd) or user custom date format (set with method {@link
+   * #withDateFormat(DateFormat)}). <p> Example: <p/>
    * <pre>
    * // assertion will pass
-   * assertThat(theTwoTowers.getReleaseDate()).isNotBetween(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;, false, false);
-   * 
+   * assertThat(theTwoTowers.getReleaseDate()).isNotBetween(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;, false,
+   * false);
+   *
    * // assertion will fail
-   * assertThat(theTwoTowers.getReleaseDate()).isNotBetween(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;, false, true);
-   * assertThat(theTwoTowers.getReleaseDate()).isNotBetween(&quot;2002-12-18&quot;, &quot;2002-12-19&quot;, true, false);
+   * assertThat(theTwoTowers.getReleaseDate()).isNotBetween(&quot;2002-12-17&quot;, &quot;2002-12-18&quot;, false,
+   * true);
+   * assertThat(theTwoTowers.getReleaseDate()).isNotBetween(&quot;2002-12-18&quot;, &quot;2002-12-19&quot;, true,
+   * false);
    * </pre>
-   * 
-   * </p>
-   * 
-   * @param start the period start (inclusive), expected not to be null.
-   * @param end the period end (exclusive), expected not to be null.
+   * <p/> </p>
+   *
+   * @param start          the period start (inclusive), expected not to be null.
+   * @param end            the period end (exclusive), expected not to be null.
    * @param inclusiveStart whether to include start date in period.
-   * @param inclusiveEnd whether to include end date in period.
+   * @param inclusiveEnd   whether to include end date in period.
    * @return this assertion object.
-   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError       if {@code actual} is {@code null}.
    * @throws NullPointerException if start Date as String is {@code null}.
    * @throws NullPointerException if end Date as String is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is not in (start, end) period.
-   * @throws AssertionError if one of the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is not in (start, end) period.
+   * @throws AssertionError       if one of the given date as String could not be converted to a Date.
    */
   public S isNotBetween(String start, String end, boolean inclusiveStart, boolean inclusiveEnd) {
     return isNotBetween(parse(start), parse(end), inclusiveStart, inclusiveEnd);
@@ -586,13 +532,13 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
    * Verifies that the actual {@code Date} is not in [start, end[ period
    *
    * @param start the period start (inclusive), expected not to be null.
-   * @param end the period end (exclusive), expected not to be null.
+   * @param end   the period end (exclusive), expected not to be null.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if start {@code Date} is {@code null}.
    * @throws NullPointerException if end {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is in [start, end[ period.
-   * @throws AssertionError if one of the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is in [start, end[ period.
+   * @throws AssertionError       if one of the given date as String could not be converted to a Date.
    */
   public S isNotBetween(Date start, Date end) {
     return isNotBetween(start, end, true, false);
@@ -600,45 +546,38 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Same assertion as {@link #isNotBetween(Date, Date)} but given Dates are represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
-   * Example:
-   * 
+   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}). <p> Example:
+   * <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theFellowshipOfTheRing.getReleaseDate()).isNotBetween(&quot;2002-12-01&quot;, &quot;2002-12-10&quot;);
-   * 
+   *
    * // assertion will fail
    * assertThat(theFellowshipOfTheRing.getReleaseDate()).isNotBetween(&quot;2002-12-01&quot;, &quot;2002-12-19&quot;);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param start the period start (inclusive), expected not to be null.
-   * @param end the period end (exclusive), expected not to be null.
+   * @param end   the period end (exclusive), expected not to be null.
    * @return this assertion object.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
    * @throws NullPointerException if start Date as String is {@code null}.
    * @throws NullPointerException if end Date as String is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is in [start, end[ period.
-   * @throws AssertionError if one of the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is in [start, end[ period.
+   * @throws AssertionError       if one of the given date as String could not be converted to a Date.
    */
   public S isNotBetween(String start, String end) {
     return isNotBetween(parse(start), parse(end), true, false);
   }
 
   /**
-   * Verifies that the actual {@code Date} is strictly in the past.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} is strictly in the past. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isInThePast();
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
    * @throws AssertionError if the actual {@code Date} is not in the past.
@@ -650,20 +589,16 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Verifies that the actual {@code Date} is today, that is matching current year, month and day (no check on hour,
-   * minute, second, milliseconds).
-   * <p>
-   * Example:
-   * 
+   * minute, second, milliseconds). <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(new Date()).isToday();
-   * 
+   *
    * // assertion will fail
    * assertThat(theFellowshipOfTheRing.getReleaseDate()).isToday();
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
    * @throws AssertionError if the actual {@code Date} is not today.
@@ -674,17 +609,13 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} is strictly in the future.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} is strictly in the future. <p> Example: <p/>
    * <pre>
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isInTheFuture();
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
    * @throws AssertionError if the actual {@code Date} is not in the future.
@@ -695,21 +626,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} is <b>strictly</b> before the given year.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} is <b>strictly</b> before the given year. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isBeforeYear(2004);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isBeforeYear(2002);
    * assertThat(theTwoTowers.getReleaseDate()).isBeforeYear(2000);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param year the year to compare actual year to
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -721,21 +648,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} is <b>strictly</b> after the given year.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} is <b>strictly</b> after the given year. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isAfterYear(2001);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isAfterYear(2002);
    * assertThat(theTwoTowers.getReleaseDate()).isAfterYear(2004);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param year the year to compare actual year to
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -747,22 +670,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} year is equal to the given year.
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} year is equal to the given year. <p> Note that using a custom comparator has
+   * no effect on this assertion (see {@link #usingComparator(Comparator)}. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isWithinYear(2002);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isWithinYear(2004);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param year the year to compare actual year to
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -775,22 +693,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Verifies that the actual {@code Date} month is equal to the given month, <b>month value starting at 1</b>
-   * (January=1, February=2, ...).
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   * 
+   * (January=1, February=2, ...). <p> Note that using a custom comparator has no effect on this assertion (see {@link
+   * #usingComparator(Comparator)}. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isWithinMonth(12);
-   * 
+   *
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isWithinMonth(10);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param month the month to compare actual month to, <b>month value starting at 1</b> (January=1, February=2, ...).
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -802,12 +715,8 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} day of month is equal to the given day of month.
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   *
+   * Verifies that the actual {@code Date} day of month is equal to the given day of month. <p> Note that using a custom
+   * comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(theTwoTowers.getReleaseDate()).isWithinDayOfMonth(18);
@@ -815,8 +724,8 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
    * // assertion will fail
    * assertThat(theTwoTowers.getReleaseDate()).isWithinDayOfMonth(20);
    * </pre>
+   * <p/> </p>
    *
-   * </p>
    * @param dayOfMonth the day of month to compare actual day of month to
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -828,25 +737,20 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} day of week is equal to the given day of week (see
-   * {@link Calendar#DAY_OF_WEEK} for valid values).
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} day of week is equal to the given day of week (see {@link
+   * Calendar#DAY_OF_WEEK} for valid values). <p> Note that using a custom comparator has no effect on this assertion
+   * (see {@link #usingComparator(Comparator)}. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime()).isWithinDayOfWeek(Calendar.SATURDAY);
-   * 
+   *
    * // assertion will fail
    * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime()).isWithinDayOfWeek(Calendar.MONDAY);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param dayOfWeek the day of week to compare actual day of week to, see {@link Calendar#DAY_OF_WEEK} for valid
-   *          values
+   *                  values
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
    * @throws AssertionError if the actual {@code Date} week is not equal to the given day of week.
@@ -857,22 +761,18 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} hour of day is equal to the given hour of day (24-hour clock).
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} hour of day is equal to the given hour of day (24-hour clock). <p> Note that
+   * using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}. <p> Example:
+   * <p/>
    * <pre>
    * // assertion will pass
    * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime()).isWithinHourOfDay(13);
-   * 
+   *
    * // assertion will fail
    * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime()).isWithinHourOfDay(22);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param hourOfDay the hour of day to compare actual hour of day to (24-hour clock)
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -884,22 +784,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} minute is equal to the given minute.
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} minute is equal to the given minute. <p> Note that using a custom comparator
+   * has no effect on this assertion (see {@link #usingComparator(Comparator)}. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime()).isWithinMinute(20);
-   * 
+   *
    * // assertion will fail
    * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime()).isWithinMinute(17);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param minute the minute to compare actual minute to
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -911,22 +806,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Verifies that the actual {@code Date} second is equal to the given second.
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   * 
+   * Verifies that the actual {@code Date} second is equal to the given second. <p> Note that using a custom comparator
+   * has no effect on this assertion (see {@link #usingComparator(Comparator)}. <p> Example: <p/>
    * <pre>
    * // assertion will pass
    * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime()).isWithinSecond(35);
-   * 
+   *
    * // assertion will fail
    * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime()).isWithinSecond(11);
    * </pre>
-   * 
-   * </p>
-   * 
+   * <p/> </p>
+   *
    * @param second the second to compare actual second to
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -939,21 +829,17 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Verifies that the actual {@code Date} millisecond is equal to the given millisecond.
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   * 
+   * <p/>
+   * Examples:
    * <pre>
    * // assertion will pass
-   * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime() + 17).isWithinMillisecond(17);
-   * 
+   * assertThat(parseDatetimeWithMs("2003-04-26T13:20:35.017")).isWithinMillisecond(17);
+   *
    * // assertion will fail
-   * assertThat(new Date(parseDatetime("2003-04-26T13:20:35").getTime() + 17).isWithinMillisecond(25);
+   * assertThat(parseDatetimeWithMs("2003-04-26T13:20:35.017")).isWithinMillisecond(25);
    * </pre>
-   * 
-   * </p>
-   * 
+   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
+   *
    * @param millisecond the millisecond to compare actual millisecond to
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -966,14 +852,21 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Verifies that actual and given {@code Date} are in the same year.
-   * <p>
+   * <p/>
+   * Example:
+   * <pre>
+   * Date date1 = parse("2003-04-26");
+   * Date date2 = parse("2003-05-27");
+   *
+   * assertThat(date1).isInSameYearAs(date2);
+   * </pre>
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * 
+   *
    * @param other the given {@code Date} to compare actual {@code Date} to.
    * @return this assertion object.
    * @throws NullPointerException if {@code Date} parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same year.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same year.
    */
   public S isInSameYearAs(Date other) {
     dates.assertIsInSameYearAs(info, actual, other);
@@ -983,44 +876,41 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   /**
    * Same assertion as {@link #isInSameYearAs(Date)} but given Date is represented as String either with ISO date format
    * (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
+   * <p/>
    * Example:
-   * 
    * <pre>
-   * // assertion will pass
-   * assertThat(theTwoTowers.getReleaseDate()).isInSameYearAs(&quot;2002-06-20&quot;);
-   * 
-   * // assertion will fail
-   * assertThat(theTwoTowers.getReleaseDate()).isInSameYearAs(&quot;2001-12-18&quot;);
+   * Date date1 = parse("2003-04-26");
+   * assertThat(date1).isInSameYearAs("2003-05-27");
    * </pre>
-   * 
-   * </p>
-   * 
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
    * @throws NullPointerException if dateAsString parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given Date represented as String are not in the same year.
-   * @throws AssertionError if the given date as String could not be converted to a Date.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given Date represented as String are not in the same year.
+   * @throws AssertionError       if the given date as String could not be converted to a Date.
    */
   public S isInSameYearAs(String dateAsString) {
     return isInSameYearAs(parse(dateAsString));
   }
 
   /**
-   * Verifies that actual and given {@code Date} are chronologically in the same month (and thus in the same year).
-   * <p>
-   * If you want to compare month only (without year), use :
-   * <code>assertThat(myDate).isWithinMonth(monthOf(otherDate))</code><br>
-   * See {@link org.assertj.core.util.Dates#monthOf(Date)} to get the month of a given Date.
-   * <p>
+   * Verifies that actual and given {@code Date} have same month and year fields.
+   * <p/>
+   * Example:
+   * <pre>
+   * Date date1 = parse("2003-04-26");
+   * Date date2 = parse("2003-04-27");
+   *
+   * assertThat(date1).isInSameMonthAs(date2);
+   * </pre>
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * 
+   *
    * @param other the given {@code Date} to compare actual {@code Date} to.
    * @return this assertion object.
    * @throws NullPointerException if {@code Date} parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same month.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same month.
    */
   public S isInSameMonthAs(Date other) {
     dates.assertIsInSameMonthAs(info, actual, other);
@@ -1030,44 +920,40 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   /**
    * Same assertion as {@link #isInSameMonthAs(Date)} but given Date is represented as String either with ISO date
    * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
+   * <p/>
    * Example:
-   * 
    * <pre>
-   * // assertion will pass
-   * assertThat(theTwoTowers.getReleaseDate()).isInSameMonthAs(&quot;2000-12-20&quot;);
-   * 
-   * // assertion will fail
-   * assertThat(theTwoTowers.getReleaseDate()).isInSameMonthAs(&quot;2002-06-18&quot;);
+   * Date date1 = parse("2003-04-26");
+   * assertThat(date1).isInSameMonthAs("2003-04-27");
    * </pre>
-   * 
-   * </p>
-   * 
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
    * @throws NullPointerException if dateAsString parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same month.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same month.
    */
   public S isInSameMonthAs(String dateAsString) {
     return isInSameMonthAs(parse(dateAsString));
   }
 
   /**
-   * Verifies that actual and given {@code Date} are chronologically in the same day of month (and thus in the same
-   * month and year).
-   * <p>
-   * If you want to compare day of month only (without month and year), you could write :
-   * <code>assertThat(myDate).isWithinDayOfMonth(dayOfMonthOf(otherDate))</code><br>
-   * see {@link org.assertj.core.util.Dates#dayOfMonthOf(Date)} to get the day of month of a given Date.
-   * <p>
+   * Verifies that actual and given {@code Date} have the same day of month, month and year fields values.
+   * <p/>
+   * Example:
+   * <pre>
+   * Date date1 = parseDatetime("2003-04-26T23:17:00");
+   * Date date2 = parseDatetime("2003-04-26T12:30:00");
+   *
+   * assertThat(date1).isInSameDayAs(date2);
+   * </pre>
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * 
+   *
    * @param other the given {@code Date} to compare actual {@code Date} to.
    * @return this assertion object.
    * @throws NullPointerException if {@code Date} parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same day of month.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same day of month.
    */
   public S isInSameDayAs(Date other) {
     dates.assertIsInSameDayAs(info, actual, other);
@@ -1077,44 +963,111 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   /**
    * Same assertion as {@link #isInSameDayAs(Date)} but given Date is represented as String either with ISO date format
    * (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * <p>
+   * <p/>
    * Example:
-   * 
    * <pre>
-   * // assertion will pass
-   * assertThat(theTwoTowers.getReleaseDate()).isInSameDayAs(&quot;2000-06-18&quot;);
-   * 
-   * // assertion will fail
-   * assertThat(theTwoTowers.getReleaseDate()).isInSameDayAs(&quot;2002-12-20&quot;);
+   * Date date1 = parseDatetime("2003-04-26T23:17:00");
+   * assertThat(date1).isInSameDayAs("2003-04-26");
    * </pre>
-   * 
-   * </p>
-   * 
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
    * @throws NullPointerException if dateAsString parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same day of month.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same day of month.
    */
   public S isInSameDayAs(String dateAsString) {
     return isInSameDayAs(parse(dateAsString));
   }
 
   /**
-   * Verifies that actual and given {@code Date} are chronologically in the same hour (and thus in the same day, month
-   * and year).
-   * <p>
+   * Verifies that actual and given {@code Date} are chronologically in the same hour (i.e. their time difference <= 1
+   * hour).
+   * <p/>
+   * This assertion succeeds as time difference is exactly = 1h:
+   * <pre>
+   * Date date1 = parseDatetime(&quot;2003-04-26T13:00:00&quot;);
+   * Date date2 = parseDatetime(&quot;2003-04-26T14:00:00&quot;);
+   * assertThat(date1).isInSameHourWindowAs(date2)
+   * </pre>
+   * Two dates can have different hour fields and yet be in the same chronological hour, example:
+   * <pre>
+   * Date date1 = parseDatetime(&quot;2003-04-26T13:00:00&quot;);
+   * Date date2 = parseDatetime(&quot;2003-04-26T12:59:59&quot;);
+   * // succeeds as time difference == 1s
+   * assertThat(date1).isInSameHourWindowAs(date2)
+   * </pre>
+   * This assertion fails as time difference is more than one hour:
+   * <pre>
+   * Date date1 = parseDatetime(&quot;2003-04-26T13:00:00&quot;);
+   * Date date2 = parseDatetime(&quot;2003-04-26T14:00:01&quot;);
+   * assertThat(date1).isInSameHourWindowAs(date2)
+   * </pre>
+   * To compare date's hour fields only (without day, month and year), you can write :
+   * <pre>
+   * assertThat(myDate).isWithinHour(hourOfDayOf(otherDate))
+   * </pre>
+   * see {@link org.assertj.core.util.Dates#hourOfDayOf(java.util.Date) hourOfDayOf} to get the hour of a given Date.
+   * <p/>
+   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}).
+   *
+   * @param other the given {@code Date} to compare actual {@code Date} to.
+   * @return this assertion object.
+   * @throws NullPointerException if {@code Date} parameter is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same hour.
+   */
+  public S isInSameHourWindowAs(Date other) {
+    dates.assertIsInSameHourWindowAs(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isInSameHourWindowAs(java.util.Date)} but given Date is represented as String.
+   *
+   * @param dateAsString the given Date represented as String in default or custom date format.
+   * @return this assertion object.
+   * @throws NullPointerException if dateAsString parameter is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same day of month.
+   */
+  public S isInSameHourWindowAs(String dateAsString) {
+    return isInSameHourWindowAs(parse(dateAsString));
+  }
+
+  /**
+   * Verifies that actual and given {@code Date} have same hour, day, month and year fields values.
+   * <p/>
+   * Example:
+   * <pre>
+   * Date date1 = parseDatetime(&quot;2003-01-01T12:00:00&quot;);
+   * Date date2 = parseDatetime(&quot;2003-01-01T12:30:00&quot;);
+   *
+   * // succeeds
+   * assertThat(date1).isInSameHourAs(date2);
+   * </pre>
+   * <b>This assertion does not make a true chronological comparison</b> since two dates can have different hour fields
+   * and yet be in the same chronological hour, e.g:
+   * <pre>
+   * // dates in the same hour time window but with different hour fields
+   * Date date1 = parseDatetime(&quot;2003-01-01T12:00:00&quot;);
+   * Date date2 = parseDatetime(&quot;2003-01-01T11:59:00&quot;);
+   * </pre>
+   * If you want to assert that two dates are chronologically in the same hour time window use {@link
+   * #isInSameHourWindowAs(java.util.Date) isInSameHourWindowAs} assertion (note that if <code>isInSameHourAs</code>
+   * succeeds then <code>isInSameHourWindowAs</code> will succeed too).
+   * <p/>
    * If you want to compare hour only (without day, month and year), you could write :
-   * <code>assertThat(myDate).isWithinHour(hourOfDayOf(otherDate))</code><br>
-   * see {@link org.assertj.core.util.Dates#hourOfDay(Date)} to get the hour of a given Date.
-   * <p>
+   * <code>assertThat(myDate).isWithinHour(hourOfDayOf(otherDate))</code><br> see {@link
+   * org.assertj.core.util.Dates#hourOfDayOf(Date)} to get the hour of a given Date.
+   * <p/>
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * 
+   *
    * @param other the given {@code Date} to compare actual {@code Date} to.
    * @return this assertion object.
    * @throws NullPointerException if {@code Date} parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same hour.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same hour.
    */
   public S isInSameHourAs(Date other) {
     dates.assertIsInSameHourAs(info, actual, other);
@@ -1122,34 +1075,110 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Same assertion as {@link #isInSameHourAs(Date)} but given Date is represented as String either with ISO date format
-   * (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * 
+   * Same assertion as {@link #isInSameHourAs(Date)} but given Date is represented as String. TODO give supported
+   * default date formats.
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
    * @throws NullPointerException if dateAsString parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same hour.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same hour.
    */
   public S isInSameHourAs(String dateAsString) {
     return isInSameHourAs(parse(dateAsString));
   }
 
   /**
-   * Verifies that actual and given {@code Date} are chronologically in the same minute (and thus in the same hour, day,
-   * month and year).
-   * <p>
-   * If you want to compare minute only (without hour, day, month and year), you could write :
-   * <code>assertThat(myDate).isWithinMinute(minuteOf(otherDate))</code><br>
-   * see {@link org.assertj.core.util.Dates#minuteOf(Date)} to get the minute of a given Date.
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * 
+   * Verifies that actual and given {@code Date} are chronologically in the same hour (i.e. their time difference <= 1
+   * hour).
+   * <p/>
+   * Example:
+   * <pre>
+   * Date date1 = parseDatetime("2003-01-01T12:01:00");
+   * Date date2 = parseDatetime("2003-01-01T12:01:30");
+   *
+   * // succeeds because date time difference < 1 min
+   * assertThat(date1).isInSameMinuteWindowAs(date2);
+   * </pre>
+   * Two dates can have different minute fields and yet be in the same chronological minute, example:
+   * <pre>
+   * Date date1 = parseDatetime("2003-01-01T12:01:00");
+   * Date date3 = parseDatetime("2003-01-01T12:00:59");
+   *
+   * // succeeds as time difference == 1s even though minutes fields differ
+   * assertThat(date1).isInSameMinuteWindowAs(date3)
+   * </pre>
+   * This assertion fails as time difference is >= one minute:
+   * <pre>
+   * Date date1 = parseDatetime("2003-01-01T12:01:00");
+   * Date date2 = parseDatetime("2003-01-01T12:02:00");
+   *
+   * // fails, time difference should hae been < 1 min
+   * assertThat(date1).isInSameMinuteWindowAs(date2); // ERROR
+   * </pre>
+   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}).
+   *
    * @param other the given {@code Date} to compare actual {@code Date} to.
    * @return this assertion object.
    * @throws NullPointerException if {@code Date} parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same minute.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same minute.
+   */
+  public S isInSameMinuteWindowAs(Date other) {
+    dates.assertIsInSameMinuteWindowAs(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isInSameMinuteWindowAs(Date)} but given Date is represented as String. TODO give
+   * supported default date formats.
+   *
+   * @param dateAsString the given Date represented as String in default or custom date format.
+   * @return this assertion object.
+   * @throws NullPointerException if dateAsString parameter is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same minute.
+   */
+  public S isInSameMinuteWindowAs(String dateAsString) {
+    return isInSameMinuteWindowAs(parse(dateAsString));
+  }
+
+  /**
+   * Verifies that actual and given {@code Date} have same minute, same hour, day, month and year fields values.
+   * <p/>
+   * Example:
+   * <pre>
+   * Date date1 = parseDatetime("2003-01-01T12:01:00");
+   * Date date2 = parseDatetime("2003-01-01T12:01:30");
+   *
+   * // succeeds because the all the fields up to minutes are the same
+   * assertThat(date1).isInSameMinuteAs(date2);
+   * </pre>
+   * <b>It does not make a true chronological comparison</b> since two dates can have different minute fields and yet be
+   * in the same chronological minute, e.g:
+   * <pre>
+   * // dates in the same minute time window but with different minute fields
+   * Date date1 = parseDatetime("2003-01-01T12:01:00");
+   * Date date3 = parseDatetime("2003-01-01T12:00:59");
+   *
+   * // fails because minutes fields differ even though time difference is only 1s !
+   * assertThat(date1).isInSameMinuteAs(date3); // ERROR
+   * </pre>
+   * If you want to assert that two dates are in the same minute time window use {@link
+   * #isInSameMinuteWindowAs(java.util.Date) isInSameMinuteWindowAs} assertion (note that if
+   * <code>isInSameMinuteAs</code> succeeds then <code>isInSameMinuteWindowAs</code> will succeed too).
+   * <p/>
+   * If you want to compare minute field only (without hour, day, month and year), you could write :
+   * <code>assertThat(myDate).isWithinMinute(minuteOf(otherDate))</code><br> using {@link
+   * org.assertj.core.util.Dates#minuteOf(Date)} to get the minute of a given Date.
+   * <p/>
+   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}).
+   *
+   * @param other the given {@code Date} to compare actual {@code Date} to.
+   * @return this assertion object.
+   * @throws NullPointerException if {@code Date} parameter is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same minute.
    */
   public S isInSameMinuteAs(Date other) {
     dates.assertIsInSameMinuteAs(info, actual, other);
@@ -1159,32 +1188,107 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   /**
    * Same assertion as {@link #isInSameMinuteAs(Date)} but given Date is represented as String either with ISO date
    * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * 
+   *
    * @param dateAsString the given Date represented as String in default or custom date format.
    * @return this assertion object.
    * @throws NullPointerException if dateAsString parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same minute.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same minute.
    */
   public S isInSameMinuteAs(String dateAsString) {
     return isInSameMinuteAs(parse(dateAsString));
   }
 
   /**
-   * Verifies that actual and given {@code Date} are chronologically in the same second (and thus in the same minute,
-   * hour, day, month and year).
-   * <p>
-   * If you want to compare second only (without minute, hour, day, month and year), you could write :
-   * <code>assertThat(myDate).isWithinSecond(secondOf(otherDate))</code><br>
-   * see {@link org.assertj.core.util.Dates#secondOf(Date)} to get the second of a given Date.
-   * <p>
+   * Verifies that actual and given {@code Date} are chronologically strictly in the same second (i.e. their time
+   * difference < 1 second).
+   * <p/>
+   * Example:
+   * <pre>
+   * Date date1 = parseDatetimeWithMs(&quot;2003-04-26T13:01:02.123&quot;);
+   * Date date2 = parseDatetimeWithMs(&quot;2003-04-26T13:01:02.456&quot;);
+   *
+   * // succeeds as time difference is < 1s
+   * assertThat(date1).isInSameSecondWindowAs(date2);
+   * </pre>
+   * Two dates can have different second fields and yet be in the same chronological second, example:
+   * <pre>
+   * Date date1 = parseDatetimeWithMs(&quot;2003-04-26T13:01:02.999&quot;);
+   * Date date2 = parseDatetimeWithMs(&quot;2003-04-26T13:01:03.000&quot;);
+   *
+   * // succeeds as time difference is 1ms < 1s
+   * assertThat(date1).isInSameSecondWindowAs(date2);
+   * </pre>
+   * Those assertions fail as time difference is greater or equal to one second:
+   * <pre>
+   * Date date1 = parseDatetimeWithMs(&quot;2003-04-26T13:01:01.000&quot;);
+   * Date date2 = parseDatetimeWithMs(&quot;2003-04-26T13:01:02.000&quot;);
+   *
+   * // fails as time difference = 1s
+   * assertThat(date1).isInSameSecondWindowAs(date2); // ERROR
+   *
+   * Date date3 = parseDatetimeWithMs(&quot;2003-04-26T13:01:02.001&quot;);
+   * // fails as time difference > 1s
+   * assertThat(date1).isInSameSecondWindowAs(date3); // ERROR
+   * </pre>
    * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * 
+   *
    * @param other the given {@code Date} to compare actual {@code Date} to.
    * @return this assertion object.
    * @throws NullPointerException if {@code Date} parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same second.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same second.
+   */
+  public S isInSameSecondWindowAs(Date other) {
+    dates.assertIsInSameSecondWindowAs(info, actual, other);
+    return myself;
+  }
+
+  /**
+   * Same assertion as {@link #isInSameSecondWindowAs(Date)} but given Date is represented as String. TODO give
+   * supported default date formats.
+   *
+   * @param dateAsString the given Date represented as String.
+   * @throws NullPointerException if dateAsString parameter is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same second.
+   */
+  public S isInSameSecondWindowAs(String dateAsString) {
+    return isInSameSecondWindowAs(parse(dateAsString));
+  }
+
+  /**
+   * Verifies that actual and given {@code Date} have same second, minute, hour, day, month and year fields values.
+   * <pre>
+   * Date date1 = parseDatetimeWithMs("2003-01-01T12:00:01.000");
+   * Date date2 = parseDatetimeWithMs("2003-01-01T12:00:01.250");
+   *
+   * // succeeds because the all the time fields up to seconds are the same
+   * assertThat(date1).isInSameSecondAs(date2);
+   * </pre>
+   * <b>It does not make a true chronological comparison</b> since two dates can have different second fields and yet be
+   * in the same chronological second, e.g:
+   * <pre>
+   * Date date1 = parseDatetimeWithMs("2003-01-01T12:00:01.000");
+   * Date date3 = parseDatetimeWithMs("2003-01-01T12:00:00.999");
+   *
+   * // fails because seconds fields differ even though time difference is only 1ms !
+   * assertThat(date1).isInSameSecondAs(date3); // ERROR
+   * </pre>
+   * If you want to assert that two dates are in the same second time window use {@link
+   * #isInSameSecondWindowAs(java.util.Date) isInSameSecondWindowAs} assertion.
+   * <p/>
+   * If you want to compare second fields only (without minute, hour, day, month and year), you could write :
+   * <code>assertThat(myDate).isWithinSecond(secondOf(otherDate))</code><br> using {@link
+   * org.assertj.core.util.Dates#secondOf(Date)} to get the second of a given Date.
+   * <p/>
+   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}).
+   *
+   * @param other the given {@code Date} to compare actual {@code Date} to.
+   * @return this assertion object.
+   * @throws NullPointerException if {@code Date} parameter is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if actual and given {@code Date} are not in the same second.
    */
   public S isInSameSecondAs(Date other) {
     dates.assertIsInSameSecondAs(info, actual, other);
@@ -1192,14 +1296,7 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Same assertion as {@link #isInSameSecondAs(Date)} but given Date is represented as String either with ISO date
-   * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * 
-   * @param dateAsString the given Date represented as String in default or custom date format.
-   * @return this assertion object.
-   * @throws NullPointerException if dateAsString parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if actual and given {@code Date} are not in the same second.
+   * Same assertion as {@link #isInSameSecondAs(Date)} but given Date is represented as String TODO date formats doc.
    */
   public S isInSameSecondAs(String dateAsString) {
     return isInSameSecondAs(parse(dateAsString));
@@ -1207,20 +1304,15 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Verifies that the actual {@code Date} is close to the other date by less than delta (expressed in milliseconds), if
-   * difference is equals to delta it's ok.
-   * <p>
-   * One can use handy {@link TimeUnit} to convert a duration in milliseconds, for example you can express a delta of 5
-   * seconds with <code>TimeUnit.SECONDS.toMillis(5)</code>.
-   * <p>
-   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}.
-   * <p>
-   * Example:
-   * 
+   * difference is equals to delta it's ok. <p> One can use handy {@link TimeUnit} to convert a duration in
+   * milliseconds, for example you can express a delta of 5 seconds with <code>TimeUnit.SECONDS.toMillis(5)</code>. <p>
+   * Note that using a custom comparator has no effect on this assertion (see {@link #usingComparator(Comparator)}. <p>
+   * Example: <p/>
    * <pre>
-   * 
+   *
    * Date date1 = new Date();
    * Date date2 = new Date(date1.getTime() + 100);
-   * 
+   *
    * // assertion will pass
    * assertThat(date1).isCloseTo(date2, 80);
    * assertThat(date1).isCloseTo(date2, 100);
@@ -1228,15 +1320,14 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
    * // assertion will fail
    * assertThat(date1).isCloseTo(date2, 101);
    * </pre>
-   * 
-   * </p>
-   * 
-   * @param other the date to compare actual to
+   * <p/> </p>
+   *
+   * @param other               the date to compare actual to
    * @param deltaInMilliseconds the delta used for date comparison, expressed in milliseconds
    * @return this assertion object.
    * @throws NullPointerException if {@code Date} parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} week is not close to the given date by less than delta.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} week is not close to the given date by less than delta.
    */
   public S isCloseTo(Date other, long deltaInMilliseconds) {
     dates.assertIsCloseTo(info, actual, other, deltaInMilliseconds);
@@ -1246,13 +1337,13 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   /**
    * Same assertion as {@link #isCloseTo(Date, long)} but given Date is represented as String either with ISO date
    * format (yyyy-MM-dd) or user custom date format (set with method {@link #withDateFormat(DateFormat)}).
-   * 
-   * @param dateAsString the given Date represented as String in default or custom date format.
+   *
+   * @param dateAsString        the given Date represented as String in default or custom date format.
    * @param deltaInMilliseconds the delta used for date comparison, expressed in milliseconds
    * @return this assertion object.
    * @throws NullPointerException if dateAsString parameter is {@code null}.
-   * @throws AssertionError if the actual {@code Date} is {@code null}.
-   * @throws AssertionError if the actual {@code Date} week is not close to the given date by less than delta.
+   * @throws AssertionError       if the actual {@code Date} is {@code null}.
+   * @throws AssertionError       if the actual {@code Date} week is not close to the given date by less than delta.
    */
   public S isCloseTo(String dateAsString, long deltaInMilliseconds) {
     return isCloseTo(parse(dateAsString), deltaInMilliseconds);
@@ -1260,9 +1351,9 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
 
   /**
    * Verifies that the actual {@code Date} has the same time as the given timestamp.
-   * <p>
+   * <p/>
    * Both time or timestamp express a number of milliseconds since January 1, 1970, 00:00:00 GMT.
-   * 
+   *
    * @param timestamp the timestamp to compare actual time to.
    * @return this assertion object.
    * @throws AssertionError if the actual {@code Date} is {@code null}.
@@ -1277,13 +1368,13 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   /**
    * For String based Date assertions like {@link #isBefore(String)}, given String is expected to follow the default
    * Date format, that is ISO 8601 format : "yyyy-MM-dd".
-   * <p>
+   * <p/>
    * With this method, user can specify its own date format, replacing the current date format for all future Date
    * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
    * field.
-   * <p>
+   * <p/>
    * To revert to default format simply call {@link #withIsoDateFormat()}.
-   * 
+   *
    * @param userCustomDateFormat the new Date format used for String based Date assertions.
    * @return this assertion object.
    */
@@ -1295,23 +1386,25 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   /**
    * For String based Date assertions like {@link #isBefore(String)}, given String is expected to follow the default
    * Date format, that is ISO 8601 format : "yyyy-MM-dd".
-   * <p>
+   * <p/>
    * With this method, user can specify its own date format, replacing the current date format for all future Date
    * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
    * field.
-   * <p>
-   * To revert to default format simply call {@link #useIsoDateFormat()} (static method) or {@link #withIsoDateFormat()}.
-   * 
+   * <p/>
+   * To revert to default format simply call {@link #useIsoDateFormat()} (static method) or {@link
+   * #withIsoDateFormat()}.
+   *
    * @param userCustomDateFormat the new Date format used for String based Date assertions.
    */
   public static void useDateFormat(DateFormat userCustomDateFormat) {
-    if (userCustomDateFormat == null) throw new NullPointerException("The given date format should not be null");
+    if (userCustomDateFormat == null)
+      throw new NullPointerException("The given date format should not be null");
     dateFormat = userCustomDateFormat;
   }
 
   /**
    * Use ISO 8601 date format ("yyyy-MM-dd") for String based Date assertions.
-   * 
+   *
    * @return this assertion object.
    */
   public S withIsoDateFormat() {
@@ -1327,15 +1420,15 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
   }
 
   /**
-   * Utility method to parse a Date with {@link #dateFormat}, note that it is thread safe.<br>
-   * Returns <code>null</code> if dateAsString parameter is <code>null</code>.
-   * 
+   * Utility method to parse a Date with {@link #dateFormat}, note that it is thread safe.<br> Returns <code>null</code>
+   * if dateAsString parameter is <code>null</code>.
+   *
    * @param dateAsString the string to parse as a Date with {@link #dateFormat}
    * @return the corresponding Date, null if dateAsString parameter is null.
    * @throws AssertionError if the string can't be parsed as a Date
    */
   private static Date parse(String dateAsString) {
-    if (dateAsString == null) { return null; }
+    if (dateAsString == null) return null;
     try {
       // synchronized is used because SimpleDateFormat which is not thread safe (sigh).
       synchronized (dateFormat) {
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 53122d6ad..6826bebda 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -18,6 +18,7 @@ import java.io.File;
 import java.io.InputStream;
 import java.math.BigDecimal;
 import java.nio.charset.Charset;
+import java.text.DateFormat;
 import java.util.Date;
 import java.util.Iterator;
 import java.util.List;
@@ -33,25 +34,22 @@ import org.assertj.core.data.MapEntry;
 import org.assertj.core.data.Offset;
 import org.assertj.core.groups.Properties;
 import org.assertj.core.groups.Tuple;
+import org.assertj.core.util.Dates;
 import org.assertj.core.util.Files;
 import org.assertj.core.util.FilesException;
 
 /**
  * Entry point for assertion methods for different data types. Each method in this class is a static factory for the
- * type-specific assertion objects. The purpose of this class is to make test code more readable.
- * <p>
- * For example:
- * 
+ * type-specific assertion objects. The purpose of this class is to make test code more readable. <p> For example: <p/>
  * <pre>
  * int removed = employees.removeFired();
  * {@link Assertions#assertThat(int) assertThat}(removed).{@link IntegerAssert#isZero isZero}();
- * 
+ *
  * List&lt;Employee&gt; newEmployees = employees.hired(TODAY);
  * {@link Assertions#assertThat(Iterable) assertThat}(newEmployees).{@link IterableAssert#hasSize(int) hasSize}(6);
  * </pre>
- * 
- * </p>
- * 
+ * <p/> </p>
+ *
  * @author Alex Ruiz
  * @author Yvonne Wang
  * @author David DIDIER
@@ -67,7 +65,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link BigDecimalAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -77,7 +75,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link BooleanAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -87,7 +85,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link BooleanAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -97,7 +95,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link BooleanArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -107,7 +105,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ByteAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -117,7 +115,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ByteAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -127,7 +125,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ByteArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -137,7 +135,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link CharacterAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -147,7 +145,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link CharArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -157,7 +155,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link CharacterAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -177,7 +175,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link IterableAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -188,7 +186,7 @@ public class Assertions {
   /**
    * Creates a new instance of <code>{@link IterableAssert}</code>. The <code>{@link Iterator}</code> is first converted
    * into an <code>{@link Iterable}</code>
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -198,7 +196,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link DoubleAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -208,7 +206,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link DoubleAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -218,7 +216,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link DoubleArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -228,7 +226,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link FileAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -238,7 +236,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link InputStreamAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -248,7 +246,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link FloatAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -258,7 +256,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link FloatAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -268,7 +266,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link FloatArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -278,7 +276,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link IntegerAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -288,7 +286,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link IntArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -298,7 +296,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link IntegerAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -308,7 +306,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ListAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -318,7 +316,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link LongAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -328,7 +326,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link LongAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -338,7 +336,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link LongArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -348,7 +346,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ObjectAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -358,7 +356,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ObjectArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -368,7 +366,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link MapAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -378,7 +376,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ShortAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -388,7 +386,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ShortAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -398,7 +396,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ShortArrayAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -408,7 +406,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link CharSequenceAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -418,7 +416,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link StringAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -428,7 +426,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link DateAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion object.
    */
@@ -438,7 +436,7 @@ public class Assertions {
 
   /**
    * Creates a new instance of <code>{@link ThrowableAssert}</code>.
-   * 
+   *
    * @param actual the actual value.
    * @return the created assertion Throwable.
    */
@@ -451,8 +449,8 @@ public class Assertions {
   // -------------------------------------------------------------------------------------------------
 
   /**
-   * Only delegate to {@link Fail#setRemoveAssertJRelatedElementsFromStackTrace(boolean)} so that Assertions offers a full
-   * feature entry point to all AssertJ Assert features (but you can use {@link Fail} if you prefer).
+   * Only delegate to {@link Fail#setRemoveAssertJRelatedElementsFromStackTrace(boolean)} so that Assertions offers a
+   * full feature entry point to all AssertJ Assert features (but you can use {@link Fail} if you prefer).
    */
   public static void setRemoveAssertJRelatedElementsFromStackTrace(boolean removeAssertJRelatedElementsFromStackTrace) {
     Fail.setRemoveAssertJRelatedElementsFromStackTrace(removeAssertJRelatedElementsFromStackTrace);
@@ -489,19 +487,22 @@ public class Assertions {
   /**
    * Only delegate to {@link Properties#extractProperty(String)} so that Assertions offers a full feature entry point to
    * all Fest Assert features (but you can use {@link Properties} if you prefer).
-   * <p>
+   * <p/>
    * Typical usage is to chain <code>extractProperty</code> with <code>from</code> method, see examples below :
-   * 
+   * <p/>
    * <pre>
    * // extract simple property values having a java standard type (here String)
-   * assertThat(extractProperty(&quot;name&quot;, String.class).from(fellowshipOfTheRing)).contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;,
+   * assertThat(extractProperty(&quot;name&quot;, String.class).from(fellowshipOfTheRing)).contains(&quot;
+   * Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;,
    *     &quot;Legolas&quot;).doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
-   * 
+   *
    * // extracting property works also with user's types (here Race)
-   * assertThat(extractProperty(&quot;race&quot;, String.class).from(fellowshipOfTheRing)).contains(HOBBIT, ELF).doesNotContain(ORC);
-   * 
+   * assertThat(extractProperty(&quot;race&quot;, String.class).from(fellowshipOfTheRing)).contains(HOBBIT,
+   * ELF).doesNotContain(ORC);
+   *
    * // extract nested property on Race
-   * assertThat(extractProperty(&quot;race.name&quot;, String.class).from(fellowshipOfTheRing)).contains(&quot;Hobbit&quot;, &quot;Elf&quot;)
+   * assertThat(extractProperty(&quot;race.name&quot;, String.class).from(fellowshipOfTheRing)).contains(&quot;
+   * Hobbit&quot;, &quot;Elf&quot;)
    *     .doesNotContain(&quot;Orc&quot;);
    * </pre>
    */
@@ -512,21 +513,23 @@ public class Assertions {
   /**
    * Only delegate to {@link Properties#extractProperty(String)} so that Assertions offers a full feature entry point to
    * all Fest Assert features (but you can use {@link Properties} if you prefer).
-   * <p>
+   * <p/>
    * Typical usage is to chain <code>extractProperty</code> with <code>from</code> method, see examples below :
-   * 
+   * <p/>
    * <pre>
    * // extract simple property values, as no type has been defined the extracted property will be considered as Object
    * // to define the real property type (here String) use extractProperty(&quot;name&quot;, String.class) instead.
-   * assertThat(extractProperty(&quot;name&quot;).from(fellowshipOfTheRing)).contains(&quot;Boromir&quot;, &quot;Gandalf&quot;, &quot;Frodo&quot;, &quot;Legolas&quot;)
+   * assertThat(extractProperty(&quot;name&quot;).from(fellowshipOfTheRing)).contains(&quot;Boromir&quot;,
+   * &quot;Gandalf&quot;, &quot;Frodo&quot;, &quot;Legolas&quot;)
    *     .doesNotContain(&quot;Sauron&quot;, &quot;Elrond&quot;);
-   * 
+   *
    * // extracting property works also with user's types (here Race), even though it will be considered as Object
    * // to define the real property type (here String) use extractProperty(&quot;name&quot;, Race.class) instead.
    * assertThat(extractProperty(&quot;race&quot;).from(fellowshipOfTheRing)).contains(HOBBIT, ELF).doesNotContain(ORC);
-   * 
+   *
    * // extract nested property on Race
-   * assertThat(extractProperty(&quot;race.name&quot;).from(fellowshipOfTheRing)).contains(&quot;Hobbit&quot;, &quot;Elf&quot;).doesNotContain(&quot;Orc&quot;);
+   * assertThat(extractProperty(&quot;race.name&quot;).from(fellowshipOfTheRing)).contains(&quot;Hobbit&quot;,
+   * &quot;Elf&quot;).doesNotContain(&quot;Orc&quot;);
    * </pre>
    */
   public static Properties<Object> extractProperty(String propertyName) {
@@ -536,7 +539,7 @@ public class Assertions {
   /**
    * Utility method to build nicely a {@link Tuple} when working with {@link IterableAssert#extracting(String...)} or
    * {@link ObjectArrayAssert#extracting(String...)}
-   * 
+   *
    * @param values the values stored in the {@link Tuple}
    * @return the built {@link Tuple}
    */
@@ -551,9 +554,9 @@ public class Assertions {
   /**
    * Only delegate to {@link MapEntry#entry(Object, Object)} so that Assertions offers a full feature entry point to all
    * Fest Assert features (but you can use {@link MapEntry} if you prefer).
-   * <p>
+   * <p/>
    * Typical usage is to call <code>entry</code> in MapAssert <code>contains</code> assertion, see examples below :
-   * 
+   * <p/>
    * <pre>
    * assertThat(ringBearers).contains(entry(oneRing, frodo), entry(nenya, galadriel));
    * </pre>
@@ -565,9 +568,9 @@ public class Assertions {
   /**
    * Only delegate to {@link Index#atIndex(int)} so that Assertions offers a full feature entry point to all Fest Assert
    * features (but you can use {@link Index} if you prefer).
-   * <p>
+   * <p/>
    * Typical usage :
-   * 
+   * <p/>
    * <pre>
    * List&lt;Ring&gt; elvesRings = newArrayList(vilya, nenya, narya);
    * assertThat(elvesRings).contains(vilya, atIndex(0)).contains(nenya, atIndex(1)).contains(narya, atIndex(2));
@@ -580,9 +583,9 @@ public class Assertions {
   /**
    * Only delegate to {@link Offset#offset(Double)} so that Assertions offers a full feature entry point to all Fest
    * Assert features (but you can use {@link Offset} if you prefer).
-   * <p>
+   * <p/>
    * Typical usage :
-   * 
+   * <p/>
    * <pre>
    * assertThat(8.1).isEqualTo(8.0, offset(0.1));
    * </pre>
@@ -594,9 +597,9 @@ public class Assertions {
   /**
    * Only delegate to {@link Offset#offset(Float)} so that Assertions offers a full feature entry point to all Fest
    * Assert features (but you can use {@link Offset} if you prefer).
-   * <p>
+   * <p/>
    * Typical usage :
-   * 
+   * <p/>
    * <pre>
    * assertThat(8.2f).isEqualTo(8.0f, offset(0.2f));
    * </pre>
@@ -611,8 +614,8 @@ public class Assertions {
 
   /**
    * Creates a new <code>{@link AllOf}</code>
-   * 
-   * @param <T> the type of object the given condition accept.
+   *
+   * @param <T>        the type of object the given condition accept.
    * @param conditions the conditions to evaluate.
    * @return the created {@code AnyOf}.
    * @throws NullPointerException if the given array is {@code null}.
@@ -624,8 +627,8 @@ public class Assertions {
 
   /**
    * Creates a new <code>{@link AllOf}</code>
-   * 
-   * @param <T> the type of object the given condition accept.
+   *
+   * @param <T>        the type of object the given condition accept.
    * @param conditions the conditions to evaluate.
    * @return the created {@code AnyOf}.
    * @throws NullPointerException if the given iterable is {@code null}.
@@ -638,9 +641,9 @@ public class Assertions {
   /**
    * Only delegate to {@link AnyOf#anyOf(Condition...)} so that Assertions offers a full feature entry point to all Fest
    * Assert features (but you can use {@link AnyOf} if you prefer).
-   * <p>
+   * <p/>
    * Typical usage (<code>jedi</code> and <code>sith</code> are {@link Condition}) :
-   * 
+   * <p/>
    * <pre>
    * assertThat(&quot;Vader&quot;).is(anyOf(jedi, sith));
    * </pre>
@@ -651,8 +654,8 @@ public class Assertions {
 
   /**
    * Creates a new <code>{@link AnyOf}</code>
-   * 
-   * @param <T> the type of object the given condition accept.
+   *
+   * @param <T>        the type of object the given condition accept.
    * @param conditions the conditions to evaluate.
    * @return the created {@code AnyOf}.
    * @throws NullPointerException if the given iterable is {@code null}.
@@ -664,7 +667,7 @@ public class Assertions {
 
   /**
    * Creates a new </code>{@link DoesNotHave}</code>.
-   * 
+   *
    * @param condition the condition to inverse.
    * @return The Not condition created.
    */
@@ -674,7 +677,7 @@ public class Assertions {
 
   /**
    * Creates a new </code>{@link Not}</code>.
-   * 
+   *
    * @param condition the condition to inverse.
    * @return The Not condition created.
    */
@@ -689,19 +692,20 @@ public class Assertions {
   /**
    * Only delegate to {@link Filters#filter(Object[])} so that Assertions offers a full feature entry point to all Fest
    * Assert features (but you can use {@link Filters} if you prefer).
-   * <p>
+   * <p/>
    * Note that the given array is not modified, the filters are performed on an {@link Iterable} copy of the array.
-   * <p>
+   * <p/>
    * Typical usage with {@link Condition} :
-   * 
+   * <p/>
    * <pre>
    * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose);
    * </pre>
-   * 
+   * <p/>
    * and with filter language based on java bean property :
-   * 
+   * <p/>
    * <pre>
-   * assertThat(filter(players).with(&quot;pointsPerGame&quot;).greaterThan(20).and(&quot;assistsPerGame&quot;).greaterThan(7).get())
+   * assertThat(filter(players).with(&quot;pointsPerGame&quot;).greaterThan(20).and(&quot;assistsPerGame&quot;)
+   * .greaterThan(7).get())
    *     .containsOnly(james, rose);
    * </pre>
    */
@@ -712,19 +716,20 @@ public class Assertions {
   /**
    * Only delegate to {@link Filters#filter(Object[])} so that Assertions offers a full feature entry point to all Fest
    * Assert features (but you can use {@link Filters} if you prefer).
-   * <p>
+   * <p/>
    * Note that the given {@link Iterable} is not modified, the filters are performed on a copy.
-   * <p>
+   * <p/>
    * Typical usage with {@link Condition} :
-   * 
+   * <p/>
    * <pre>
    * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose);
    * </pre>
-   * 
+   * <p/>
    * and with filter language based on java bean property :
-   * 
+   * <p/>
    * <pre>
-   * assertThat(filter(players).with(&quot;pointsPerGame&quot;).greaterThan(20).and(&quot;assistsPerGame&quot;).greaterThan(7).get())
+   * assertThat(filter(players).with(&quot;pointsPerGame&quot;).greaterThan(20).and(&quot;assistsPerGame&quot;)
+   * .greaterThan(7).get())
    *     .containsOnly(james, rose);
    * </pre>
    */
@@ -737,47 +742,40 @@ public class Assertions {
   // --------------------------------------------------------------------------------------------------
 
   /**
-   * Loads the text content of a file, so that it can be passed to {@link #assertThat(String)}.
-   * <p>
-   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
-   * with {@link #assertThat(File)}.
-   * </p>
-   * 
-   * @param file the file.
+   * Loads the text content of a file, so that it can be passed to {@link #assertThat(String)}. <p> Note that this will
+   * load the entire file in memory; for larger files, there might be a more efficient alternative with {@link
+   * #assertThat(File)}. </p>
+   *
+   * @param file    the file.
    * @param charset the character set to use.
    * @return the content of the file.
    * @throws NullPointerException if the given charset is {@code null}.
-   * @throws FilesException if an I/O exception occurs.
+   * @throws FilesException       if an I/O exception occurs.
    */
   public static String contentOf(File file, Charset charset) {
     return Files.contentOf(file, charset);
   }
 
   /**
-   * Loads the text content of a file, so that it can be passed to {@link #assertThat(String)}.
-   * <p>
-   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
-   * with {@link #assertThat(File)}.
-   * </p>
-   * 
-   * @param file the file.
+   * Loads the text content of a file, so that it can be passed to {@link #assertThat(String)}. <p> Note that this will
+   * load the entire file in memory; for larger files, there might be a more efficient alternative with {@link
+   * #assertThat(File)}. </p>
+   *
+   * @param file        the file.
    * @param charsetName the name of the character set to use.
    * @return the content of the file.
    * @throws IllegalArgumentException if the given character set is not supported on this platform.
-   * @throws FilesException if an I/O exception occurs.
+   * @throws FilesException           if an I/O exception occurs.
    */
   public static String contentOf(File file, String charsetName) {
     return Files.contentOf(file, charsetName);
   }
 
   /**
-   * Loads the text content of a file with the default character set, so that it can be passed to
-   * {@link #assertThat(String)}.
-   * <p>
-   * Note that this will load the entire file in memory; for larger files, there might be a more efficient alternative
-   * with {@link #assertThat(File)}.
-   * </p>
-   * 
+   * Loads the text content of a file with the default character set, so that it can be passed to {@link
+   * #assertThat(String)}. <p> Note that this will load the entire file in memory; for larger files, there might be a
+   * more efficient alternative with {@link #assertThat(File)}. </p>
+   *
    * @param file the file.
    * @return the content of the file.
    * @throws FilesException if an I/O exception occurs.
@@ -786,6 +784,38 @@ public class Assertions {
     return Files.contentOf(file, Charset.defaultCharset());
   }
 
+  /**
+   * For String based Date assertions like {@link AbstractDateAssert#isBefore(String)}, given String is expected to
+   * follow the default Date format, that is ISO 8601 format : "yyyy-MM-dd".
+   * <p/>
+   * With this method, user can specify its own date format, replacing the current date format for all future Date
+   * assertions in the test suite (i.e. not only the current assertions) since custom DateFormat is stored in a static
+   * field.
+   * <p/>
+   * To revert to default format simply call {@link #useIsoDateFormat()} (static method) or {@link
+   * AbstractDateAssert#withIsoDateFormat()}.
+   *
+   * @param userCustomDateFormat the new Date format used for String based Date assertions.
+   */
+  public static void useDateFormat(final DateFormat userCustomDateFormat) {
+    AbstractDateAssert.useDateFormat(userCustomDateFormat);
+  }
+
+  /** Use ISO 8601 date format ("yyyy-MM-dd") for String based Date assertions. */
+  public static void useIsoDateFormat() {
+    AbstractDateAssert.useIsoDateFormat();
+  }
+
+  /** Use ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code> */
+  public static void useIsoDateTimeFormat() {
+    AbstractDateAssert.useDateFormat(Dates.newIsoDateTimeFormat());
+  }
+
+  /** Use ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code> */
+  public static void useIsoDateTimeWithMsFormat() {
+    AbstractDateAssert.useDateFormat(Dates.newIsoDateTimeWithMsFormat());
+  }
+
   /** Creates a new </code>{@link Assertions}</code>. */
   protected Assertions() {
   }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeInSameHour.java b/src/main/java/org/assertj/core/error/ShouldBeInSameHour.java
index 9e884b76d..53aace513 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeInSameHour.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeInSameHour.java
@@ -35,6 +35,6 @@ public class ShouldBeInSameHour extends BasicErrorMessageFactory {
   }
 
   private ShouldBeInSameHour(Date actual, Date other) {
-    super("\nExpecting:\n <%s>\nto be on same year, month, day and hour as:\n <%s>", actual, other);
+    super("\nExpecting:\n <%s>\nto have same year, month, day and hour fields values as:\n <%s>", actual, other);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeInSameHourWindow.java b/src/main/java/org/assertj/core/error/ShouldBeInSameHourWindow.java
new file mode 100644
index 000000000..8e1af29d0
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeInSameHourWindow.java
@@ -0,0 +1,49 @@
+/*
+ * Created on Oct 18, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
+ * on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+ * language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.util.Dates.formatTimeDifference;
+
+import java.util.Date;
+
+import org.assertj.core.util.Dates;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a {@link Date} is in same hour window as
+ * another one failed.
+ *
+ * @author Joel Costigliola
+ */
+public class ShouldBeInSameHourWindow extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new </code>{@link ShouldBeInSameHourWindow}</code>.
+   *
+   * @param actual the actual value in the failed assertion.
+   * @param other  the value used in the failed assertion to compare the actual value to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeInSameHourWindow(Date actual, Date other) {
+    return new ShouldBeInSameHourWindow(actual, other);
+  }
+
+  private ShouldBeInSameHourWindow(Date actual, Date other) {
+    super("\nExpecting:\n  <%s>\nto be close to:\n  <%s>\nby less than one hour (strictly) but difference was: "
+            + formatTimeDifference(actual, other), actual, other);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeInSameMillisecond.java b/src/main/java/org/assertj/core/error/ShouldBeInSameMillisecond.java
deleted file mode 100644
index a9c689191..000000000
--- a/src/main/java/org/assertj/core/error/ShouldBeInSameMillisecond.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Created on Oct 18, 2010
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- * 
- * Copyright @2010-2011 the original author or authors.
- */
-package org.assertj.core.error;
-
-import static java.lang.String.format;
-
-import java.util.Date;
-
-import org.assertj.core.util.Dates;
-
-/**
- * Creates an error message indicating that an assertion that verifies that a {@link Date} is in same year, month, day
- * of month, hour, minute, second and millisecond as another one failed.
- * 
- * @author Joel Costigliola
- * @author Mikhail Mazursky
- */
-public class ShouldBeInSameMillisecond extends BasicErrorMessageFactory {
-
-  /**
-   * Creates a new </code>{@link ShouldBeInSameMillisecond}</code>.
-   * 
-   * @param actual the actual value in the failed assertion.
-   * @param other the value used in the failed assertion to compare the actual value to.
-   * @return the created {@code ErrorMessageFactory}.
-   */
-  public static ErrorMessageFactory shouldBeInSameMillisecond(Date actual, Date other) {
-    return new ShouldBeInSameMillisecond(actual, other);
-  }
-
-  private ShouldBeInSameMillisecond(Date actual, Date other) {
-
-    super(format(
-        "\nExpecting:\n <%s>\nto be on same year, month, day, hour, minute, second and millisecond as:\n <%s>",
-        Dates.formatAsDatetimeWithMs(actual), Dates.formatAsDatetimeWithMs(other)));
-  }
-}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeInSameMinute.java b/src/main/java/org/assertj/core/error/ShouldBeInSameMinute.java
index f42074d68..ebcacdcbe 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeInSameMinute.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeInSameMinute.java
@@ -35,6 +35,6 @@ public class ShouldBeInSameMinute extends BasicErrorMessageFactory {
   }
 
   private ShouldBeInSameMinute(Date actual, Date other) {
-    super("\nExpecting:\n <%s>\nto be on same year, month, day, hour and minute as:\n <%s>", actual, other);
+    super("\nExpecting:\n <%s>\nto have same year, month, day, hour and minute fields values as:\n <%s>", actual, other);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeInSameMinuteWindow.java b/src/main/java/org/assertj/core/error/ShouldBeInSameMinuteWindow.java
new file mode 100644
index 000000000..92b000011
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeInSameMinuteWindow.java
@@ -0,0 +1,47 @@
+/*
+ * Created on Oct 18, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
+ * on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+ * language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.util.Dates.formatTimeDifference;
+
+import java.util.Date;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a {@link Date} is in minute window as
+ * another one failed.
+ *
+ * @author Joel Costigliola
+ */
+public class ShouldBeInSameMinuteWindow extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new </code>{@link ShouldBeInSameMinuteWindow}</code>.
+   *
+   * @param actual the actual value in the failed assertion.
+   * @param other  the value used in the failed assertion to compare the actual value to.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldBeInSameMinuteWindow(Date actual, Date other) {
+    return new ShouldBeInSameMinuteWindow(actual, other);
+  }
+
+  private ShouldBeInSameMinuteWindow(Date actual, Date other) {
+    super("\nExpecting:\n  <%s>\nto be close to:\n  <%s>\nby less than one minute (strictly) but difference was: "
+            + formatTimeDifference(actual, other), actual, other);
+  }
+}
diff --git a/src/main/java/org/assertj/core/error/ShouldBeInSameSecond.java b/src/main/java/org/assertj/core/error/ShouldBeInSameSecond.java
index afd626204..f23a59950 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeInSameSecond.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeInSameSecond.java
@@ -36,6 +36,6 @@ public class ShouldBeInSameSecond extends BasicErrorMessageFactory {
   }
 
   private ShouldBeInSameSecond(Date actual, Date other) {
-    super("\nExpecting:\n <%s>\nto be on same year, month, day, hour, minute and second as:\n <%s>", actual, other);
+    super("\nExpecting:\n <%s>\nto have same year, month, day, hour, minute and second fields values as:\n <%s>", actual, other);
   }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeInSameSecondWindow.java b/src/main/java/org/assertj/core/error/ShouldBeInSameSecondWindow.java
new file mode 100644
index 000000000..9e7f960b0
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeInSameSecondWindow.java
@@ -0,0 +1,40 @@
+/*
+ * Created on Oct 18, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.util.Dates.formatTimeDifference;
+
+import java.util.Date;
+
+import org.assertj.core.util.Dates;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a {@link Date} is in second window as
+ * another one failed.
+ *
+ * @author Joel Costigliola
+ */
+public class ShouldBeInSameSecondWindow extends BasicErrorMessageFactory {
+
+  public static ErrorMessageFactory shouldBeInSameSecondWindow(Date actual, Date other) {
+    return new ShouldBeInSameSecondWindow(actual, other);
+  }
+
+  private ShouldBeInSameSecondWindow(Date actual, Date other) {
+    super("\nExpecting:\n  <%s>\nto be close to:\n  <%s>\nby less than one second (strictly) but difference was: "
+            + formatTimeDifference(actual, other), actual, other);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/internal/Dates.java b/src/main/java/org/assertj/core/internal/Dates.java
index 1cd7aa0f3..fa8ca6b6a 100644
--- a/src/main/java/org/assertj/core/internal/Dates.java
+++ b/src/main/java/org/assertj/core/internal/Dates.java
@@ -9,8 +9,11 @@ import static org.assertj.core.error.ShouldBeCloseTo.shouldBeCloseTo;
 import static org.assertj.core.error.ShouldBeInSameDay.shouldBeInSameDay;
 import static org.assertj.core.error.ShouldBeInSameHour.shouldBeInSameHour;
 import static org.assertj.core.error.ShouldBeInSameMinute.shouldBeInSameMinute;
+import static org.assertj.core.error.ShouldBeInSameHourWindow.shouldBeInSameHourWindow;
+import static org.assertj.core.error.ShouldBeInSameMinuteWindow.shouldBeInSameMinuteWindow;
 import static org.assertj.core.error.ShouldBeInSameMonth.shouldBeInSameMonth;
 import static org.assertj.core.error.ShouldBeInSameSecond.shouldBeInSameSecond;
+import static org.assertj.core.error.ShouldBeInSameSecondWindow.shouldBeInSameSecondWindow;
 import static org.assertj.core.error.ShouldBeInSameYear.shouldBeInSameYear;
 import static org.assertj.core.error.ShouldBeInTheFuture.shouldBeInTheFuture;
 import static org.assertj.core.error.ShouldBeInThePast.shouldBeInThePast;
@@ -20,11 +23,12 @@ import static org.assertj.core.error.ShouldHaveTime.shouldHaveTime;
 import static org.assertj.core.error.ShouldNotBeBetween.shouldNotBeBetween;
 import static org.assertj.core.util.Dates.dayOfMonthOf;
 import static org.assertj.core.util.Dates.dayOfWeekOf;
-import static org.assertj.core.util.Dates.hourOfDay;
+import static org.assertj.core.util.Dates.hourOfDayOf;
 import static org.assertj.core.util.Dates.millisecondOf;
 import static org.assertj.core.util.Dates.minuteOf;
 import static org.assertj.core.util.Dates.monthOf;
 import static org.assertj.core.util.Dates.secondOf;
+import static org.assertj.core.util.Dates.timeDifference;
 import static org.assertj.core.util.Dates.today;
 import static org.assertj.core.util.Dates.truncateTime;
 import static org.assertj.core.util.Dates.yearOf;
@@ -32,6 +36,7 @@ import static org.assertj.core.util.Dates.yearOf;
 import java.util.Calendar;
 import java.util.Comparator;
 import java.util.Date;
+import java.util.concurrent.TimeUnit;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.VisibleForTesting;
@@ -328,7 +333,7 @@ public class Dates {
    */
   public void assertIsWithinHourOfDay(AssertionInfo info, Date actual, int hourOfDay) {
     assertNotNull(info, actual);
-    if (hourOfDay(actual) == hourOfDay) return;
+    if (hourOfDayOf(actual) == hourOfDay) return;
     throw failures.failure(info, shouldBeWithin(actual, "hour", hourOfDay));
   }
 
@@ -454,7 +459,7 @@ public class Dates {
   }
 
   /**
-   * Verifies that actual and given {@code Date} are chronologically in the same hour (and thus in the same day of month, month
+   * Verifies that actual and given {@code Date} are in the same hour (and thus in the same day of month, month
    * and year).
    * @param info contains information about the assertion.
    * @param actual the "actual" {@code Date}.
@@ -470,6 +475,33 @@ public class Dates {
     throw failures.failure(info, shouldBeInSameHour(actual, other));
   }
 
+  /**
+   * Verifies that actual and given {@code Date} are chronologically in the same hour, day of month, month and year.
+   *
+   * @param info contains information about the assertion.
+   * @param actual the "actual" {@code Date}.
+   * @param other the given {@code Date} to compare actual {@code Date} to.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws NullPointerException if other {@code Date} is {@code null}.
+   * @throws AssertionError if actual and given {@code Date} are not chronologically speaking in the same hour.
+   */
+  public void assertIsInSameHourWindowAs(AssertionInfo info, Date actual, Date other) {
+    assertNotNull(info, actual);
+    dateParameterIsNotNull(other);
+    if (areInSameHourWindow(actual, other)) return;
+    throw failures.failure(info, shouldBeInSameHourWindow(actual, other));
+  }
+
+  /**
+   * Returns true if both date are in the same year, month and day of month, hour, minute and second, false otherwise.
+   * @param actual the actual date. expected not be null
+   * @param other the other date. expected not be null
+   * @return true if both date are in the same year, month and day of month, hour, minute and second, false otherwise.
+   */
+  private static boolean areInSameHourWindow(Date actual, Date other) {
+    return timeDifference(actual, other) < TimeUnit.HOURS.toMillis(1);
+  }
+
   /**
    * Returns true if both date are in the same year, month, day of month and hour, false otherwise.
    * @param actual the actual date. expected not be null
@@ -477,12 +509,11 @@ public class Dates {
    * @return true if both date are in the same year, month, day of month and hour, false otherwise.
    */
   private static boolean areInSameHour(Date actual, Date other) {
-    return areInSameDayOfMonth(actual, other) && hourOfDay(actual) == hourOfDay(other);
+    return areInSameDayOfMonth(actual, other) && hourOfDayOf(actual) == hourOfDayOf(other);
   }
 
   /**
-   * Verifies that actual and given {@code Date} are chronologically in the same minute (and thus in the same hour, day of month,
-   * month and year).
+   * Verifies that actual and given {@code Date} are in the same minute, hour, day of month, month and year.
    * @param info contains information about the assertion.
    * @param actual the "actual" {@code Date}.
    * @param other the given {@code Date} to compare actual {@code Date} to.
@@ -497,6 +528,22 @@ public class Dates {
     throw failures.failure(info, shouldBeInSameMinute(actual, other));
   }
 
+  /**
+   * Verifies that actual and given {@code Date} are chronologically in the same minute.
+   * @param info contains information about the assertion.
+   * @param actual the "actual" {@code Date}.
+   * @param other the given {@code Date} to compare actual {@code Date} to.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws NullPointerException if other {@code Date} is {@code null}.
+   * @throws AssertionError if actual and given {@code Date} are not chronologically speaking in the same minute.
+   */
+  public void assertIsInSameMinuteWindowAs(AssertionInfo info, Date actual, Date other) {
+    assertNotNull(info, actual);
+    dateParameterIsNotNull(other);
+    if (areInSameMinuteWindow(actual, other)) return;
+    throw failures.failure(info, shouldBeInSameMinuteWindow(actual, other));
+  }
+
   /**
    * Returns true if both date are in the same year, month, day of month, hour and minute, false otherwise.
    * @param actual the actual date. expected not be null
@@ -507,9 +554,12 @@ public class Dates {
     return areInSameHour(actual, other) && minuteOf(actual) == minuteOf(other);
   }
 
+  private static boolean areInSameMinuteWindow(Date actual, Date other) {
+    return timeDifference(actual, other) < TimeUnit.MINUTES.toMillis(1);
+  }
+
   /**
-   * Verifies that actual and given {@code Date} are chronologically in the same second (and thus in the same minute, hour, day of
-   * month, month and year).
+   * Verifies that actual and given {@code Date} are in the same second, minute, hour, day of month, month and year.
    * @param info contains information about the assertion.
    * @param actual the "actual" {@code Date}.
    * @param other the given {@code Date} to compare actual {@code Date} to.
@@ -524,6 +574,32 @@ public class Dates {
     throw failures.failure(info, shouldBeInSameSecond(actual, other));
   }
 
+  /**
+   * Verifies that actual and given {@code Date} are chronologically in the same second.
+   * @param info contains information about the assertion.
+   * @param actual the "actual" {@code Date}.
+   * @param other the given {@code Date} to compare actual {@code Date} to.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws NullPointerException if other {@code Date} is {@code null}.
+   * @throws AssertionError if actual and given {@code Date} are not chronologically speaking in the same second.
+   */
+  public void assertIsInSameSecondWindowAs(AssertionInfo info, Date actual, Date other) {
+    assertNotNull(info, actual);
+    dateParameterIsNotNull(other);
+    if (areInSameSecondWindow(actual, other)) return;
+    throw failures.failure(info, shouldBeInSameSecondWindow(actual, other));
+  }
+
+  /**
+   * Returns true if both date are in the same year, month and day of month, hour, minute and second, false otherwise.
+   * @param actual the actual date. expected not be null
+   * @param other the other date. expected not be null
+   * @return true if both date are in the same year, month and day of month, hour, minute and second, false otherwise.
+   */
+  private static boolean areInSameSecondWindow(Date actual, Date other) {
+    return timeDifference(actual, other) < TimeUnit.SECONDS.toMillis(1);
+  }
+
   /**
    * Returns true if both date are in the same year, month and day of month, hour, minute and second, false otherwise.
    * @param actual the actual date. expected not be null
diff --git a/src/main/java/org/assertj/core/util/Dates.java b/src/main/java/org/assertj/core/util/Dates.java
index 10ef4b7b3..21deb86eb 100644
--- a/src/main/java/org/assertj/core/util/Dates.java
+++ b/src/main/java/org/assertj/core/util/Dates.java
@@ -1,19 +1,25 @@
 /*
  * Created on Jan 22, 2011
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2011 the original author or authors.
  */
 package org.assertj.core.util;
 
+import static java.lang.String.format;
+import static java.util.concurrent.TimeUnit.DAYS;
+import static java.util.concurrent.TimeUnit.HOURS;
+import static java.util.concurrent.TimeUnit.MINUTES;
+import static java.util.concurrent.TimeUnit.SECONDS;
+
 import java.text.DateFormat;
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
@@ -22,39 +28,46 @@ import java.util.Date;
 
 /**
  * Utility methods related to dates.
- * 
+ *
  * @author Joel Costigliola
  * @author Mikhail Mazursky
  */
 public class Dates {
 
-  /**
-   * ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code>
-   */
+  /** ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code> */
   private static final DateFormat ISO_DATE_FORMAT = newIsoDateFormat();
-
+  /** ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code> */
+  private static final DateFormat ISO_DATE_TIME_FORMAT = newIsoDateTimeFormat();
   /**
-   * ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code>
+   * ISO 8601 date-time format with millisecond (yyyy-MM-dd'T'HH:mm:ss.SSS), example :
+   * <code>2003-04-26T03:01:02.999</code>
    */
-  private static final DateFormat ISO_DATE_TIME_FORMAT = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
+  private static final DateFormat ISO_DATE_TIME_FORMAT_WITH_MS = newIsoDateTimeWithMsFormat();
 
-  /**
-   * ISO 8601 date-time format with millisecond (yyyy-MM-dd'T'HH:mm:ss.SSS), example : <code>2003-04-26T03:01:02.999</code>
-   */
-  private static final DateFormat ISO_DATE_TIME_FORMAT_WITH_MS = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
+  /** ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code> */
+  public static DateFormat newIsoDateFormat() {
+    return new SimpleDateFormat("yyyy-MM-dd");
+  }
+
+  /** ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss), example : <code>2003-04-26T13:01:02</code> */
+  public static DateFormat newIsoDateTimeFormat() {
+    return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss");
+  }
 
   /**
-   * ISO 8601 date format (yyyy-MM-dd), example : <code>2003-04-23</code>
+   * ISO 8601 date-time format with millisecond (yyyy-MM-dd'T'HH:mm:ss.SSS), example :
+   * <code>2003-04-26T03:01:02.999</code>
    */
-  public static DateFormat newIsoDateFormat() {
-    return new SimpleDateFormat("yyyy-MM-dd");
+  public static DateFormat newIsoDateTimeWithMsFormat() {
+    return new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSS");
   }
 
   /**
-   * Formats the given date using the ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss).<br>
-   * Method in synchronized because SimpleDateFormat is not thread safe (sigh).
-   * <p>
+   * Formats the given date using the ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss).<br> Method in synchronized
+   * because SimpleDateFormat is not thread safe (sigh).
+   * <p/>
    * Returns null if given the date is null.
+   *
    * @param date the date to format.
    * @return the formatted date or null if given the date was null.
    */
@@ -63,10 +76,11 @@ public class Dates {
   }
 
   /**
-   * Formats the given date using the ISO 8601 date-time format with millisecond (yyyy-MM-dd'T'HH:mm:ss:SSS).<br>
-   * Method in synchronized because SimpleDateFormat is not thread safe (sigh).
-   * <p>
+   * Formats the given date using the ISO 8601 date-time format with millisecond (yyyy-MM-dd'T'HH:mm:ss:SSS).<br> Method
+   * in synchronized because SimpleDateFormat is not thread safe (sigh).
+   * <p/>
    * Returns null if given the date is null.
+   *
    * @param date the date to format.
    * @return the formatted date or null if given the date was null.
    */
@@ -75,10 +89,11 @@ public class Dates {
   }
 
   /**
-   * Formats the date of the given calendar using the ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss).<br>
-   * Method is thread safe.
-   * <p>
+   * Formats the date of the given calendar using the ISO 8601 date-time format (yyyy-MM-dd'T'HH:mm:ss).<br> Method is
+   * thread safe.
+   * <p/>
    * Returns null if the given calendar is null.
+   *
    * @param calendar the calendar to format.
    * @return the formatted calendar or null if the given calendar was null.
    */
@@ -88,6 +103,7 @@ public class Dates {
 
   /**
    * Utility method to parse a Date following {@link #ISO_DATE_FORMAT}, returns null if the given String is null.
+   *
    * @param dateAsString the string to parse as a Date following {@link #ISO_DATE_FORMAT}
    * @return the corresponding Date or null if the given String is null.
    * @throws RuntimeException encapsulating ParseException if the string can't be parsed as a Date
@@ -102,6 +118,12 @@ public class Dates {
 
   /**
    * Utility method to parse a Date following {@link #ISO_DATE_TIME_FORMAT}, returns null if the given String is null.
+   * <p> Example:
+   * <pre>
+   * Date date = parseDatetime("2003-04-26T03:01:02");
+   * </pre>
+   * </p>
+   *
    * @param dateAsString the string to parse as a Date following {@link #ISO_DATE_TIME_FORMAT}
    * @return the corresponding Date with time details or null if the given String is null.
    * @throws RuntimeException encapsulating ParseException if the string can't be parsed as a Date
@@ -115,7 +137,13 @@ public class Dates {
   }
 
   /**
-   * Utility method to parse a Date following {@link #ISO_DATE_TIME_FORMAT_WITH_MS}, returns null if the given String is null.
+   * Utility method to parse a Date following {@link #ISO_DATE_TIME_FORMAT_WITH_MS}, returns null if the given String is
+   * null. <p> Example:
+   * <pre>
+   * Date date = parseDatetimeWithMs("2003-04-26T03:01:02.999");
+   * </pre>
+   * </p>
+   *
    * @param dateAsString the string to parse as a Date following {@link #ISO_DATE_TIME_FORMAT_WITH_MS}
    * @return the corresponding Date with time details or null if the given String is null.
    * @throws RuntimeException encapsulating ParseException if the string can't be parsed as a Date
@@ -130,11 +158,14 @@ public class Dates {
 
   /**
    * Converts the given Date to Calendar, returns null if the given Date is null.
+   *
    * @param date the date to convert to a Calendar.
    * @return the Calendar corresponding to the given Date or null if the given Date is null.
    */
   public static Calendar toCalendar(Date date) {
-    if (date == null) { return null; }
+    if (date == null) {
+      return null;
+    }
     Calendar calendar = Calendar.getInstance();
     calendar.setTime(date);
     return calendar;
@@ -142,6 +173,7 @@ public class Dates {
 
   /**
    * Extracts the year of the given Date.
+   *
    * @param date the date to extract the year from - must not be null.
    * @return the year of the given Date
    * @throws NullPointerException if given Date is null
@@ -152,6 +184,7 @@ public class Dates {
 
   /**
    * Dates Extracts the month of the given Date <b>starting at 1</b> (January=1, February=2, ...).
+   *
    * @param date the date to extract the month from - must not be null.
    * @return the month of the given Date <b>starting at 1</b> (January=1, February=2, ...)
    * @throws NullPointerException if given Date is null
@@ -162,6 +195,7 @@ public class Dates {
 
   /**
    * Dates Extracts the day of month of the given Date.
+   *
    * @param date the date to extract the day of month from - must not be null.
    * @return the day of month of the given Date
    * @throws NullPointerException if given Date is null
@@ -172,6 +206,7 @@ public class Dates {
 
   /**
    * Extracts the day of week of the given Date, returned value follows {@link Calendar#DAY_OF_WEEK} .
+   *
    * @param date the date to extract the day of week from - must not be null.
    * @return the day of week of the given Date
    * @throws NullPointerException if given Date is null
@@ -182,16 +217,18 @@ public class Dates {
 
   /**
    * Extracts the hour of day if the given Date (24-hour clock).
+   *
    * @param date the date to extract the hour of day from - must not be null.
    * @return the hour of day of the given Date (24-hour clock)
    * @throws NullPointerException if given Date is null
    */
-  public static int hourOfDay(Date date) {
+  public static int hourOfDayOf(Date date) {
     return toCalendar(date).get(Calendar.HOUR_OF_DAY);
   }
 
   /**
    * Dates Extracts the minute of the given Date.
+   *
    * @param date the date to extract the minute from - must not be null.
    * @return the minute of the given Date
    * @throws NullPointerException if given Date is null
@@ -202,6 +239,7 @@ public class Dates {
 
   /**
    * Extracts the second of the given Date.
+   *
    * @param date the date to extract the second from - must not be null.
    * @return the second of the given Date
    * @throws NullPointerException if given Date is null
@@ -212,6 +250,7 @@ public class Dates {
 
   /**
    * Extracts the millisecond of the given Date.
+   *
    * @param date the date to extract the millisecond from - must not be null.
    * @return the millisecond of the given Date
    * @throws NullPointerException if given Date is null
@@ -220,16 +259,30 @@ public class Dates {
     return toCalendar(date).get(Calendar.MILLISECOND);
   }
 
+  /**
+   * Compute the time difference between the two given dates in milliseconds, it always gives a positive result.
+   *
+   * @param date1 the first date.
+   * @param date1 the second date.
+   * @return the difference between the two given dates in milliseconds
+   * @throws IllegalArgumentException if one a the given Date is null.
+   */
+  public static long timeDifference(Date date1, Date date2) {
+    if (date1 == null || date2 == null) throw new IllegalArgumentException("Expecting date parameter not to be null");
+    return Math.abs(date1.getTime() - date2.getTime());
+  }
+
   /**
    * Returns a copy of the given date without the time part (which is set to 00:00:00), for example :<br>
    * <code>truncateTime(2008-12-29T23:45:12)</code> will give <code>2008-12-29T00:00:00</code>.
-   * <p>
+   * <p/>
    * Returns null if the given Date is null.
+   *
    * @param date we want to get the day part (the parameter is read only).
    * @return the truncated date.
    */
   public static Date truncateTime(Date date) {
-    if (date == null) { return null; }
+    if (date == null) return null;
     Calendar cal = toCalendar(date);
     cal.set(Calendar.HOUR_OF_DAY, 0);
     cal.set(Calendar.MINUTE, 0);
@@ -253,4 +306,71 @@ public class Dates {
     cal.add(Calendar.DAY_OF_MONTH, 1);
     return cal.getTime();
   }
+
+  /**
+   * Utility method to display a human readable time difference.
+   *
+   * @param date1
+   * @param date2
+   * @return a human readable time difference.
+   */
+  public static String formatTimeDifference(final Date date1, final Date date2) {
+
+    // difference in ms, s, m, h, d
+    final long millisecondsDiff = timeDifference(date1, date2);
+    final long secondsDiff = millisecondsDiff / SECONDS.toMillis(1);
+    final long minutesDiff = millisecondsDiff / MINUTES.toMillis(1);
+    final long hoursDiff = millisecondsDiff / HOURS.toMillis(1);
+    final long daysDiff = millisecondsDiff / DAYS.toMillis(1);
+
+    // date field difference
+    final long hourFieldDiff = hoursDiff - DAYS.toHours(daysDiff);
+    final long minuteFieldDiff = minutesDiff - HOURS.toMinutes(hoursDiff);
+    final long secondFieldDiff = secondsDiff - MINUTES.toSeconds(minutesDiff);
+    final long millisecondsFieldDiff = millisecondsDiff % SECONDS.toMillis(1);
+
+    StringBuilder result = new StringBuilder();
+
+    if (daysDiff > 0) result.append(format("%dd", daysDiff));
+
+    if (hourFieldDiff > 0) {
+      if (daysDiff > 0 && minuteFieldDiff == 0 && secondFieldDiff == 0 && millisecondsFieldDiff == 0) {
+        // hour diff field is the last field that differs but not the only one
+        result.append(" and ");
+      } else if (daysDiff > 0) {
+        result.append(" ");
+      }
+      result.append(format("%dh", hourFieldDiff));
+    }
+
+    if (minuteFieldDiff > 0) {
+      final boolean notFirstDiff = daysDiff > 0 || hourFieldDiff > 0;
+      if (notFirstDiff && secondFieldDiff == 0 && millisecondsFieldDiff == 0) {
+        // min diff field is the last field that differs but not the only one
+        result.append(" and ");
+      } else if (notFirstDiff) {
+        result.append(" ");
+      }
+      result.append(format("%dm", minuteFieldDiff));
+    }
+
+    if (secondFieldDiff > 0) {
+      final boolean notFirstDiff = daysDiff > 0 || hourFieldDiff > 0 || minuteFieldDiff > 0;
+      if (notFirstDiff && millisecondsFieldDiff == 0) {
+        // seconds diff field is the last field that differs but not the only one
+        result.append(" and ");
+      } else if (notFirstDiff) {
+        result.append(" ");
+      }
+      result.append(format("%ds", secondFieldDiff));
+    }
+
+    if (millisecondsFieldDiff > 0) {
+      if (result.length() > 0) result.append(" and ");
+      result.append(format("%dms", millisecondsFieldDiff));
+    }
+
+    return result.toString();
+
+  }
 }
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourOfDayAs_Test.java b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourAs_Test.java
similarity index 86%
rename from src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourOfDayAs_Test.java
rename to src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourAs_Test.java
index d4cf78473..5c608efd2 100644
--- a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourOfDayAs_Test.java
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourAs_Test.java
@@ -22,11 +22,11 @@ import org.assertj.core.api.DateAssert;
 
 
 /**
- * Tests for <code>{@link DateAssert#isInSameHourAs(Date)}</code>.
- * 
+ * Tests for <code>{@link org.assertj.core.api.DateAssert#isInSameHourAs(java.util.Date)}</code>.
+ *
  * @author Joel Costigliola
  */
-public class DateAssert_isInSameHourOfDayAs_Test extends AbstractDateAssertWithDateArg_Test {
+public class DateAssert_isInSameHourAs_Test extends AbstractDateAssertWithDateArg_Test {
 
   @Override
   protected DateAssert assertionInvocationWithDateArg() {
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourWindowAs_Test.java b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourWindowAs_Test.java
new file mode 100644
index 000000000..c5c2690fe
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameHourWindowAs_Test.java
@@ -0,0 +1,46 @@
+/*
+ * Created on Dec 21, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.api.date;
+
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+
+import org.assertj.core.api.DateAssert;
+
+
+/**
+ * Tests for <code>{@link DateAssert#isInSameHourWindowAs(Date)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class DateAssert_isInSameHourWindowAs_Test extends AbstractDateAssertWithDateArg_Test {
+
+  @Override
+  protected DateAssert assertionInvocationWithDateArg() {
+    return assertions.isInSameHourWindowAs(otherDate);
+  }
+
+  @Override
+  protected DateAssert assertionInvocationWithStringArg(String date) {
+    return assertions.isInSameHourWindowAs(date);
+  }
+
+  @Override
+  protected void verifyAssertionInvocation(Date date) {
+    verify(dates).assertIsInSameHourWindowAs(getInfo(assertions), getActual(assertions), date);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameMinuteAs_Test.java b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameMinuteAs_Test.java
index 1a723d3d2..eda52606f 100644
--- a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameMinuteAs_Test.java
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameMinuteAs_Test.java
@@ -22,8 +22,8 @@ import org.assertj.core.api.DateAssert;
 
 
 /**
- * Tests for <code>{@link DateAssert#isInSameMinuteAs(Date)}</code>.
- * 
+ * Tests for <code>{@link org.assertj.core.api.DateAssert#isInSameMinuteAs(java.util.Date)}</code>.
+ *
  * @author Joel Costigliola
  */
 public class DateAssert_isInSameMinuteAs_Test extends AbstractDateAssertWithDateArg_Test {
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameMinuteWindowAs_Test.java b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameMinuteWindowAs_Test.java
new file mode 100644
index 000000000..424f99b7d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameMinuteWindowAs_Test.java
@@ -0,0 +1,46 @@
+/*
+ * Created on Dec 21, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.api.date;
+
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+
+import org.assertj.core.api.DateAssert;
+
+
+/**
+ * Tests for <code>{@link DateAssert#isInSameMinuteWindowAs(Date)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class DateAssert_isInSameMinuteWindowAs_Test extends AbstractDateAssertWithDateArg_Test {
+
+  @Override
+  protected DateAssert assertionInvocationWithDateArg() {
+    return assertions.isInSameMinuteWindowAs(otherDate);
+  }
+
+  @Override
+  protected DateAssert assertionInvocationWithStringArg(String date) {
+    return assertions.isInSameMinuteWindowAs(date);
+  }
+
+  @Override
+  protected void verifyAssertionInvocation(Date date) {
+    verify(dates).assertIsInSameMinuteWindowAs(getInfo(assertions), getActual(assertions), date);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameSecondAs_Test.java b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameSecondAs_Test.java
index 474cf0798..94194b621 100644
--- a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameSecondAs_Test.java
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameSecondAs_Test.java
@@ -22,8 +22,8 @@ import org.assertj.core.api.DateAssert;
 
 
 /**
- * Tests for <code>{@link DateAssert#isInSameSecondAs(Date)}</code>.
- * 
+ * Tests for <code>{@link org.assertj.core.api.DateAssert#isInSameSecondAs(java.util.Date)}</code>.
+ *
  * @author Joel Costigliola
  */
 public class DateAssert_isInSameSecondAs_Test extends AbstractDateAssertWithDateArg_Test {
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_isInSameSecondWindowAs_Test.java b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameSecondWindowAs_Test.java
new file mode 100644
index 000000000..84c7f2216
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_isInSameSecondWindowAs_Test.java
@@ -0,0 +1,46 @@
+/*
+ * Created on Dec 21, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.api.date;
+
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+
+import org.assertj.core.api.DateAssert;
+
+
+/**
+ * Tests for <code>{@link DateAssert#isInSameSecondWindowAs(Date)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class DateAssert_isInSameSecondWindowAs_Test extends AbstractDateAssertWithDateArg_Test {
+
+  @Override
+  protected DateAssert assertionInvocationWithDateArg() {
+    return assertions.isInSameSecondWindowAs(otherDate);
+  }
+
+  @Override
+  protected DateAssert assertionInvocationWithStringArg(String date) {
+    return assertions.isInSameSecondWindowAs(date);
+  }
+
+  @Override
+  protected void verifyAssertionInvocation(Date date) {
+    verify(dates).assertIsInSameSecondWindowAs(getInfo(assertions), getActual(assertions), date);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameHourWindow_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameHourWindow_create_Test.java
new file mode 100644
index 000000000..aa51df2df
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameHourWindow_create_Test.java
@@ -0,0 +1,34 @@
+package org.assertj.core.error;
+
+import static org.assertj.core.api.Assertions.*;
+import static org.assertj.core.error.ShouldBeInSameHourWindow.shouldBeInSameHourWindow;
+import static org.assertj.core.util.Dates.parseDatetimeWithMs;
+
+import java.text.ParseException;
+
+import org.junit.Test;
+
+import org.assertj.core.description.Description;
+import org.assertj.core.description.TextDescription;
+
+
+/**
+ * Tests for <code>{@link ShouldBeInSameHourWindow#create(Description)}</code>.
+ *
+ * @author Joel Costigliola
+ * @author Mikhail Mazursky
+ */
+public class ShouldBeInSameHourWindow_create_Test {
+
+  @Test
+  public void should_create_error_message() throws ParseException {
+    ErrorMessageFactory factory = shouldBeInSameHourWindow(parseDatetimeWithMs("2011-01-01T05:00:00.000"),
+                                                           parseDatetimeWithMs("2011-01-01T06:05:17.003"));
+
+    String message = factory.create(new TextDescription("Test"));
+    assertThat(message).isEqualTo("[Test] \nExpecting:\n  <2011-01-01T05:00:00>\nto be close to:\n  " +
+                                    "<2011-01-01T06:05:17>\n" +
+                                    "by less than one hour (strictly) but difference was: 1h 5m 17s and 3ms");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameHour_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameHour_create_Test.java
deleted file mode 100644
index 5c7c26f66..000000000
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameHour_create_Test.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Created on Sep 26, 2010
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
- * 
- * Copyright @2010-2011 the original author or authors.
- */
-package org.assertj.core.error;
-
-import static junit.framework.Assert.assertEquals;
-
-import static org.assertj.core.error.ShouldBeInSameHour.shouldBeInSameHour;
-
-import java.text.ParseException;
-
-import org.assertj.core.description.*;
-import org.assertj.core.error.ErrorMessageFactory;
-import org.assertj.core.error.ShouldBeInSameHour;
-import org.assertj.core.util.Dates;
-import org.junit.Test;
-
-
-/**
- * Tests for <code>{@link ShouldBeInSameHour#create(Description)}</code>.
- * 
- * @author Joel Costigliola
- * @author Mikhail Mazursky
- */
-public class ShouldBeInSameHour_create_Test {
-
-  @Test
-  public void should_create_error_message() throws ParseException {
-    ErrorMessageFactory factory = shouldBeInSameHour(Dates.parseDatetime("2011-01-01T05:00:00"),
-        Dates.parseDatetime("2011-01-01T06:00:00"));
-
-    String message = factory.create(new TextDescription("Test"));
-    assertEquals("[Test] \nExpecting:\n <2011-01-01T05:00:00>\nto be on same year, month, day and hour as:\n <2011-01-01T06:00:00>",
-        message);
-  }
-
-}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameMillisecond_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameMillisecond_create_Test.java
deleted file mode 100644
index 78cfbde08..000000000
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameMillisecond_create_Test.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Created on Sep 26, 2010
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
- * 
- * Copyright @2010-2011 the original author or authors.
- */
-package org.assertj.core.error;
-
-import static junit.framework.Assert.assertEquals;
-
-import static org.assertj.core.error.ShouldBeInSameMillisecond.shouldBeInSameMillisecond;
-
-import java.text.*;
-import java.util.Date;
-
-import org.assertj.core.description.*;
-import org.assertj.core.error.ShouldBeInSameMillisecond;
-import org.junit.Test;
-
-
-/**
- * Tests for <code>{@link ShouldBeInSameMillisecond#create(Description)}</code>.
- * 
- * @author Joel Costigliola
- */
-public class ShouldBeInSameMillisecond_create_Test {
-
-  @Test
-  public void should_create_error_message() throws ParseException {
-    SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'hh:mm:ss:SS");
-    Date date1 = dateFormat.parse("1994-08-26T22:35:17:29");
-    Date date2 = dateFormat.parse("1994-08-26T22:35:17:30");
-    String message = shouldBeInSameMillisecond(date1, date2).create(new TextDescription("Test"));
-    assertEquals(
-        "[Test] \nExpecting:\n <1994-08-26T22:35:17.029>\nto be on same year, month, day, hour, minute, second and millisecond as:\n <1994-08-26T22:35:17.030>",
-        message);
-  }
-
-}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameMinuteWindow_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameMinuteWindow_create_Test.java
new file mode 100644
index 000000000..503581be2
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameMinuteWindow_create_Test.java
@@ -0,0 +1,51 @@
+/*
+ * Created on Sep 26, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
+ * on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+ * language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.api.Assertions.*;
+import static org.assertj.core.error.ShouldBeInSameMinuteWindow.shouldBeInSameMinuteWindow;
+import static org.assertj.core.util.Dates.parseDatetime;
+
+import java.text.ParseException;
+
+import org.junit.Test;
+
+import org.assertj.core.description.Description;
+import org.assertj.core.description.TextDescription;
+
+
+/**
+ * Tests for <code>{@link ShouldBeInSameMinuteWindow#create(Description)}</code>.
+ *
+ * @author Joel Costigliola
+ * @author Mikhail Mazursky
+ */
+public class ShouldBeInSameMinuteWindow_create_Test {
+
+  @Test
+  public void should_create_error_message() throws ParseException {
+    ErrorMessageFactory factory = shouldBeInSameMinuteWindow(parseDatetime("2011-01-01T05:00:00"),
+                                                             parseDatetime("2011-01-01T05:02:01"));
+
+    String message = factory.create(new TextDescription("Test"));
+    assertThat(message).isEqualTo("[Test] \nExpecting:\n  <2011-01-01T05:00:00>\nto be close to:\n  " +
+                                    "<2011-01-01T05:02:01>\n" +
+                                    "by less than one minute (strictly) but difference was: 2m and 1s");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameMinute_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameMinute_create_Test.java
deleted file mode 100644
index 5d1466314..000000000
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameMinute_create_Test.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Created on Sep 26, 2010
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
- * 
- * Copyright @2010-2011 the original author or authors.
- */
-package org.assertj.core.error;
-
-import static junit.framework.Assert.assertEquals;
-
-import static org.assertj.core.error.ShouldBeInSameMinute.shouldBeInSameMinute;
-
-import java.text.ParseException;
-
-import org.assertj.core.description.*;
-import org.assertj.core.error.ErrorMessageFactory;
-import org.assertj.core.error.ShouldBeInSameMinute;
-import org.assertj.core.util.Dates;
-import org.junit.Test;
-
-
-/**
- * Tests for <code>{@link ShouldBeInSameMinute#create(Description)}</code>.
- * 
- * @author Joel Costigliola
- * @author Mikhail Mazursky
- */
-public class ShouldBeInSameMinute_create_Test {
-
-  @Test
-  public void should_create_error_message() throws ParseException {
-    ErrorMessageFactory factory = shouldBeInSameMinute(Dates.parseDatetime("2011-01-01T05:01:00"),
-        Dates.parseDatetime("2011-01-01T05:02:00"));
-
-    String message = factory.create(new TextDescription("Test"));
-    assertEquals(
-        "[Test] \nExpecting:\n <2011-01-01T05:01:00>\nto be on same year, month, day, hour and minute as:\n <2011-01-01T05:02:00>", message);
-  }
-
-}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameSecondWindow_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameSecondWindow_create_Test.java
new file mode 100644
index 000000000..d77c9f6e2
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameSecondWindow_create_Test.java
@@ -0,0 +1,33 @@
+package org.assertj.core.error;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldBeInSameSecondWindow.shouldBeInSameSecondWindow;
+import static org.assertj.core.util.Dates.parseDatetimeWithMs;
+
+import java.text.ParseException;
+
+import org.junit.Test;
+
+import org.assertj.core.description.Description;
+import org.assertj.core.description.TextDescription;
+
+
+/**
+ * Tests for <code>{@link ShouldBeInSameSecondWindow#create(Description)}</code>.
+ *
+ * @author Joel Costigliola
+ * @author Mikhail Mazursky
+ */
+public class ShouldBeInSameSecondWindow_create_Test {
+
+  @Test
+  public void should_create_error_message() throws ParseException {
+    ErrorMessageFactory factory = shouldBeInSameSecondWindow(parseDatetimeWithMs("2011-01-01T05:00:01.000"),
+                                                             parseDatetimeWithMs("2011-01-01T05:00:02.001"));
+    String message = factory.create(new TextDescription("Test"));
+    assertThat(message).isEqualTo("[Test] \nExpecting:\n  <2011-01-01T05:00:01>\nto be close to:\n  " +
+                                    "<2011-01-01T05:00:02>\nby less than one second (strictly) but difference was: 1s" +
+                                    " and 1ms");
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameSecond_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameSecond_create_Test.java
deleted file mode 100644
index 88546fa4b..000000000
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameSecond_create_Test.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Created on Sep 26, 2010
- * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
- * 
- * http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
- * 
- * Copyright @2010-2011 the original author or authors.
- */
-package org.assertj.core.error;
-
-import static junit.framework.Assert.assertEquals;
-
-import static org.assertj.core.error.ShouldBeInSameSecond.shouldBeInSameSecond;
-
-import java.text.ParseException;
-
-import org.assertj.core.description.*;
-import org.assertj.core.error.ErrorMessageFactory;
-import org.assertj.core.error.ShouldBeInSameSecond;
-import org.assertj.core.util.Dates;
-import org.junit.Test;
-
-
-/**
- * Tests for <code>{@link ShouldBeInSameSecond#create(Description)}</code>.
- * 
- * @author Joel Costigliola
- * @author Mikhail Mazursky
- */
-public class ShouldBeInSameSecond_create_Test {
-
-  @Test
-  public void should_create_error_message() throws ParseException {
-    ErrorMessageFactory factory = shouldBeInSameSecond(Dates.parseDatetime("2011-01-01T05:00:01"),
-        Dates.parseDatetime("2011-01-01T05:00:02"));
-
-    String message = factory.create(new TextDescription("Test"));
-    assertEquals(
-        "[Test] \nExpecting:\n <2011-01-01T05:00:01>\nto be on same year, month, day, hour, minute and second as:\n <2011-01-01T05:00:02>",
-        message);
-  }
-
-}
diff --git a/src/test/java/org/assertj/core/internal/DatesBaseTest.java b/src/test/java/org/assertj/core/internal/DatesBaseTest.java
index 2c79f89c6..0b37dafc2 100644
--- a/src/test/java/org/assertj/core/internal/DatesBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/DatesBaseTest.java
@@ -68,6 +68,10 @@ public abstract class DatesBaseTest {
     return org.assertj.core.util.Dates.parseDatetime(dateAsString);
   }
 
+  protected static Date parseDatetimeWithMs(String dateAsString) {
+    return org.assertj.core.util.Dates.parseDatetimeWithMs(dateAsString);
+  }
+
   protected Comparator<?> comparatorForCustomComparisonStrategy() {
     return yearAndMonthComparator;
   }
diff --git a/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameHourWindowAs_Test.java b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameHourWindowAs_Test.java
new file mode 100644
index 000000000..d1191cfb7
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameHourWindowAs_Test.java
@@ -0,0 +1,127 @@
+/*
+ * Created on Dec 24, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
+ * on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+ * language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.internal.dates;
+
+import static org.assertj.core.error.ShouldBeInSameHourWindow.shouldBeInSameHourWindow;
+import static org.assertj.core.test.ErrorMessages.dateToCompareActualWithIsNull;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Dates;
+import org.assertj.core.internal.DatesBaseTest;
+
+import org.junit.Test;
+
+
+/**
+ * Tests for <code>{@link Dates#assertIsInSameHourWindowAs(AssertionInfo, Date, Date)}</code>.
+ *
+ * @author Joel Costigliola
+ */
+public class Dates_assertIsInSameHourWindowAs_Test extends DatesBaseTest {
+
+  @Override
+  protected void initActualDate() {
+    actual = parseDatetime("2011-01-01T03:01:02");
+  }
+
+  @Test
+  public void should_pass_if_actual_is_in_same_hour_window_as_given_date() {
+    dates.assertIsInSameHourWindowAs(someInfo(), actual, parseDatetime("2011-01-01T03:59:02"));
+    dates.assertIsInSameHourWindowAs(someInfo(), actual, parseDatetime("2011-01-01T02:01:03"));
+  }
+
+  @Test
+  public void should_fail_if_time_difference_is_exactly_one_hour() {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T04:01:02");
+    try {
+      dates.assertIsInSameHourWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameHourWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_in_same_hour_window_as_given_date() {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T04:01:03");
+    try {
+      dates.assertIsInSameHourWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameHourWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    dates.assertIsInSameHourWindowAs(someInfo(), null, new Date());
+  }
+
+  @Test
+  public void should_throw_error_if_given_date_is_null() {
+    thrown.expectNullPointerException(dateToCompareActualWithIsNull());
+    dates.assertIsInSameHourWindowAs(someInfo(), actual, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_in_same_hour_window_as_given_date_whatever_custom_comparison_strategy_is() {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T04:01:03");
+    try {
+      datesWithCustomComparisonStrategy.assertIsInSameHourWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameHourWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null_whatever_custom_comparison_strategy_is() {
+    thrown.expectAssertionError(actualIsNull());
+    datesWithCustomComparisonStrategy.assertIsInSameHourWindowAs(someInfo(), null, new Date());
+  }
+
+  @Test
+  public void should_throw_error_if_given_date_is_null_whatever_custom_comparison_strategy_is() {
+    thrown.expectNullPointerException(dateToCompareActualWithIsNull());
+    datesWithCustomComparisonStrategy.assertIsInSameHourWindowAs(someInfo(), actual, null);
+  }
+
+  @Test
+  public void should_pass_if_actual_is_in_same_hour_window_as_given_date_whatever_custom_comparison_strategy_is() {
+    datesWithCustomComparisonStrategy.assertIsInSameHourWindowAs(someInfo(), actual,
+                                                                 parseDatetime("2011-01-01T03:59:02"));
+    datesWithCustomComparisonStrategy.assertIsInSameHourWindowAs(someInfo(), actual,
+                                                                 parseDatetime("2011-01-01T04:01:00"));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameMinuteWindowAs_Test.java b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameMinuteWindowAs_Test.java
new file mode 100644
index 000000000..ced427c17
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameMinuteWindowAs_Test.java
@@ -0,0 +1,124 @@
+/*
+ * Created on Dec 24, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+ * with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
+ * on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
+ * language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.internal.dates;
+
+import static org.assertj.core.error.ShouldBeInSameMinuteWindow.shouldBeInSameMinuteWindow;
+import static org.assertj.core.test.ErrorMessages.dateToCompareActualWithIsNull;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+
+import org.junit.Test;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Dates;
+import org.assertj.core.internal.DatesBaseTest;
+
+
+/**
+ * Tests for <code>{@link Dates#assertIsInSameMinuteWindowAs(AssertionInfo, Date, Date)}</code>.
+ *
+ * @author Joel Costigliola
+ */
+public class Dates_assertIsInSameMinuteWindowAs_Test extends DatesBaseTest {
+
+  @Override
+  protected void initActualDate() {
+    actual = parseDatetime("2011-01-01T03:15:00");
+  }
+
+  @Test
+  public void should_pass_if_actual_is_in_same_minute_window_as_given_date() {
+    dates.assertIsInSameMinuteWindowAs(someInfo(), actual, parseDatetime("2011-01-01T03:15:59"));
+    dates.assertIsInSameMinuteWindowAs(someInfo(), actual, parseDatetime("2011-01-01T03:14:01"));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_exactly_one_minute_away_from_given_date() {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T03:16:00");
+    try {
+      dates.assertIsInSameMinuteWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameMinuteWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_in_same_minute_window_as_given_date() {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T03:16:01");
+    try {
+      dates.assertIsInSameMinuteWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameMinuteWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    dates.assertIsInSameMinuteWindowAs(someInfo(), null, new Date());
+  }
+
+  @Test
+  public void should_throw_error_if_given_date_is_null() {
+    thrown.expectNullPointerException(dateToCompareActualWithIsNull());
+    dates.assertIsInSameMinuteWindowAs(someInfo(), actual, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_in_same_minute_window_as_given_date_whatever_custom_comparison_strategy_is
+    () {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T03:13:59");
+    try {
+      datesWithCustomComparisonStrategy.assertIsInSameMinuteWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameMinuteWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null_whatever_custom_comparison_strategy_is() {
+    thrown.expectAssertionError(actualIsNull());
+    datesWithCustomComparisonStrategy.assertIsInSameMinuteWindowAs(someInfo(), null, new Date());
+  }
+
+  @Test
+  public void should_throw_error_if_given_date_is_null_whatever_custom_comparison_strategy_is() {
+    thrown.expectNullPointerException(dateToCompareActualWithIsNull());
+    datesWithCustomComparisonStrategy.assertIsInSameMinuteWindowAs(someInfo(), actual, null);
+  }
+
+  @Test
+  public void should_pass_if_actual_is_in_same_minute_window_as_given_date_whatever_custom_comparison_strategy_is() {
+    datesWithCustomComparisonStrategy.assertIsInSameMinuteWindowAs(someInfo(), actual,
+                                                                   parseDatetime("2011-01-01T03:15:59"));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameSecondWindowAs_Test.java b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameSecondWindowAs_Test.java
new file mode 100644
index 000000000..77c3e67ac
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/dates/Dates_assertIsInSameSecondWindowAs_Test.java
@@ -0,0 +1,124 @@
+/*
+ * Created on Dec 24, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.internal.dates;
+
+import static org.assertj.core.error.ShouldBeInSameSecondWindow.shouldBeInSameSecondWindow;
+import static org.assertj.core.test.ErrorMessages.dateToCompareActualWithIsNull;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+
+import static org.mockito.Mockito.verify;
+
+import java.util.Date;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.Dates;
+import org.assertj.core.internal.DatesBaseTest;
+import org.junit.Test;
+
+
+/**
+ * Tests for <code>{@link Dates#assertIsInSameSecondWindowAs(AssertionInfo, Date, Date)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class Dates_assertIsInSameSecondWindowAs_Test extends DatesBaseTest {
+
+  @Override
+  protected void initActualDate() {
+    actual = parseDatetime("2011-01-01T03:15:05");
+  }
+
+  @Test
+  public void should_pass_if_actual_is_in_same_second_window_as_given_date() {
+    dates.assertIsInSameSecondWindowAs(someInfo(), actual, parseDatetimeWithMs("2011-01-01T03:15:05.999"));
+    dates.assertIsInSameSecondWindowAs(someInfo(), actual, parseDatetimeWithMs("2011-01-01T03:15:05.001"));
+    // in that test, the two dates have different seconds fields : 05 and 04 but their diff < 1s
+    dates.assertIsInSameSecondWindowAs(someInfo(), actual, new Date(actual.getTime() - 1));
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_in_same_second_as_given_date() {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T03:15:02");
+    try {
+      dates.assertIsInSameSecondWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameSecondWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_if_dates_time_difference_is_exactly_one_second() {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T03:15:06");
+    try {
+      dates.assertIsInSameSecondWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameSecondWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    dates.assertIsInSameSecondWindowAs(someInfo(), null, new Date());
+  }
+
+  @Test
+  public void should_throw_error_if_given_date_is_null() {
+    thrown.expectNullPointerException(dateToCompareActualWithIsNull());
+    dates.assertIsInSameSecondWindowAs(someInfo(), actual, null);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_not_in_same_second_as_given_date_whatever_custom_comparison_strategy_is() {
+    AssertionInfo info = someInfo();
+    Date other = parseDatetime("2011-01-01T03:15:02");
+    try {
+      datesWithCustomComparisonStrategy.assertIsInSameSecondWindowAs(info, actual, other);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeInSameSecondWindow(actual, other));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null_whatever_custom_comparison_strategy_is() {
+    thrown.expectAssertionError(actualIsNull());
+    datesWithCustomComparisonStrategy.assertIsInSameSecondWindowAs(someInfo(), null, new Date());
+  }
+
+  @Test
+  public void should_throw_error_if_given_date_is_null_whatever_custom_comparison_strategy_is() {
+    thrown.expectNullPointerException(dateToCompareActualWithIsNull());
+    datesWithCustomComparisonStrategy.assertIsInSameSecondWindowAs(someInfo(), actual, null);
+  }
+
+  @Test
+  public void should_pass_if_actual_is_in_same_second_as_given_date_whatever_custom_comparison_strategy_is() {
+    Date other = parseDatetime("2011-01-01T03:15:05");
+    datesWithCustomComparisonStrategy.assertIsInSameSecondWindowAs(someInfo(), actual, other);
+    datesWithCustomComparisonStrategy.assertIsInSameSecondWindowAs(someInfo(), actual, new Date(other.getTime() + 999));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/util/Dates_formatTimeDifference_Test.java b/src/test/java/org/assertj/core/util/Dates_formatTimeDifference_Test.java
new file mode 100644
index 000000000..8d5a7c2a5
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/Dates_formatTimeDifference_Test.java
@@ -0,0 +1,76 @@
+/*
+ * Created on Sep 23, 2006
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2006-2011 the original author or authors.
+ */
+package org.assertj.core.util;
+
+import static org.assertj.core.api.Assertions.*;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Dates.formatTimeDifference;
+import static org.assertj.core.util.Dates.parseDatetimeWithMs;
+
+import java.text.ParseException;
+import java.util.Date;
+
+import org.junit.Rule;
+import org.junit.Test;
+
+import org.assertj.core.test.ExpectedException;
+
+/**
+ * Tests for <code>{@link Dates#timeDifference(java.util.Date, java.util.Date)}</code>.
+ *
+ * @author Joel Costigliola
+ */
+public class Dates_formatTimeDifference_Test {
+
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Test
+  public void should_return_dates_time_difference() throws ParseException {
+    final Date date1 = parseDatetimeWithMs("2003-01-01T00:00:00.888");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-01T00:00:00.999"))).isEqualTo("111ms");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-01T00:00:01.999"))).isEqualTo("1s and 111ms");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-01T00:00:01.888"))).isEqualTo("1s");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-01T00:02:01.999"))).isEqualTo("2m 1s and 111ms");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-01T00:02:00.999"))).isEqualTo("2m and 111ms");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-01T03:02:01.999"))).isEqualTo("3h 2m 1s and 111ms");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-01T03:02:00.888"))).isEqualTo("3h and 2m");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-05T03:02:01.999"))).isEqualTo("4d 3h 2m 1s and 111ms");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-02-01T03:02:01.999"))).isEqualTo("31d 3h 2m 1s and 111ms");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-01-01T03:02:01.888"))).isEqualTo("3h 2m and 1s");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-02-01T00:02:00.999"))).isEqualTo("31d 2m and 111ms");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-02-01T00:02:00.888"))).isEqualTo("31d and 2m");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-02-01T01:00:00.888"))).isEqualTo("31d and 1h");
+    assertThat(formatTimeDifference(date1, parseDatetimeWithMs("2003-02-01T00:00:00.999"))).isEqualTo("31d and 111ms");
+
+    final Date date3 = parseDatetimeWithMs("2008-07-06T05:04:03.002");
+    assertThat(formatTimeDifference(date3, parseDatetimeWithMs("2008-07-06T05:04:03.002"))).isEmpty();
+    assertThat(formatTimeDifference(date3, parseDatetimeWithMs("2008-07-06T05:04:03.001"))).isEqualTo("1ms");
+    assertThat(formatTimeDifference(date3, parseDatetimeWithMs("2008-07-01T04:03:02.001"))).isEqualTo("5d 1h 1m 1s and 1ms");
+  }
+
+  @Test
+  public void should_throws_IllegalArgumentException_if_first_date_parameter_is_null() {
+    thrown.expectIllegalArgumentException("Expecting date parameter not to be null");
+    formatTimeDifference(new Date(), null);
+  }
+
+  @Test
+  public void should_throws_IllegalArgumentException_if_second_date_parameter_is_null() {
+    thrown.expectIllegalArgumentException("Expecting date parameter not to be null");
+    formatTimeDifference(null, new Date());
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/util/Dates_hourOfDayOf_Test.java b/src/test/java/org/assertj/core/util/Dates_hourOfDayOf_Test.java
index da6c7724c..74d7d3c65 100644
--- a/src/test/java/org/assertj/core/util/Dates_hourOfDayOf_Test.java
+++ b/src/test/java/org/assertj/core/util/Dates_hourOfDayOf_Test.java
@@ -14,7 +14,7 @@
  */
 package org.assertj.core.util;
 
-import static org.assertj.core.util.Dates.hourOfDay;
+import static org.assertj.core.util.Dates.hourOfDayOf;
 
 import static org.junit.Assert.assertEquals;
 import static org.junit.rules.ExpectedException.none;
@@ -26,7 +26,7 @@ import org.junit.*;
 import org.junit.rules.ExpectedException;
 
 /**
- * Tests for <code>{@link Dates#hourOfDay(Date)}</code>.
+ * Tests for <code>{@link Dates#hourOfDayOf(Date)}</code>.
  * 
  * @author Joel Costigliola
  */
@@ -39,13 +39,13 @@ public class Dates_hourOfDayOf_Test {
   public void should_return_hour_of_day_of_date() throws ParseException {
     String dateAsString = "26/08/1994T22:35:00";
     Date date = new SimpleDateFormat("dd/MM/yyyy'T'hh:mm:ss").parse(dateAsString);
-    assertEquals(22, hourOfDay(date));
+    assertEquals(22, hourOfDayOf(date));
   }
 
   @Test
   public void should_throws_NullPointerException_if_date_parameter_is_null() {
     thrown.expect(NullPointerException.class);
-    hourOfDay(null);
+    hourOfDayOf(null);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/util/Dates_timeDifference_Test.java b/src/test/java/org/assertj/core/util/Dates_timeDifference_Test.java
new file mode 100644
index 000000000..87ba73652
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/Dates_timeDifference_Test.java
@@ -0,0 +1,60 @@
+/*
+ * Created on Sep 23, 2006
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2006-2011 the original author or authors.
+ */
+package org.assertj.core.util;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Dates.parseDatetimeWithMs;
+import static org.assertj.core.util.Dates.timeDifference;
+
+import java.text.ParseException;
+import java.util.Date;
+
+import org.junit.Rule;
+import org.junit.Test;
+
+import org.assertj.core.test.ExpectedException;
+
+/**
+ * Tests for <code>{@link org.assertj.core.util.Dates#timeDifference(java.util.Date, java.util.Date)}</code>.
+ *
+ * @author Joel Costigliola
+ */
+public class Dates_timeDifference_Test {
+
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Test
+  public void should_return_dates_time_difference() throws ParseException {
+    final Date date1 = parseDatetimeWithMs("2003-04-26T03:01:02.999");
+    final Date date2 = parseDatetimeWithMs("2003-04-26T03:01:02.888");
+    assertThat(timeDifference(date1, date2)).isEqualTo(111);
+    assertThat(timeDifference(date2, date1)).isEqualTo(timeDifference(date1, date2));
+  }
+
+  @Test
+  public void should_throws_IllegalArgumentException_if_first_date_parameter_is_null() {
+    thrown.expectIllegalArgumentException("Expecting date parameter not to be null");
+    timeDifference(new Date(), null);
+  }
+
+  @Test
+  public void should_throws_IllegalArgumentException_if_second_date_parameter_is_null() {
+    thrown.expectIllegalArgumentException("Expecting date parameter not to be null");
+    timeDifference(null, new Date());
+  }
+
+}
