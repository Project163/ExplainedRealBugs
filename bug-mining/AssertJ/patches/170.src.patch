diff --git a/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java b/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
index 1a6048c3b..973f4734d 100644
--- a/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
@@ -336,13 +336,18 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
   /**
    * Verifies that the actual {@code CharSequence} contains all the given strings <b>in the given order</b>.
    * <p>
+   * Note that <b>unlike</b> {@link IterableAssert#containsSequence(Object...)}, the assertion will succeed when there are values between the expected sequence values.
+   * <p>
    * Example:
    * <pre><code class='java'> String book = &quot;{ 'title':'A Game of Thrones', 'author':'George Martin'}&quot;;
    * 
-   * // this assertion succeeds ...
-   * assertThat(book).containsSequence(&quot;{&quot;, &quot;title&quot;, &quot;A Game of Thrones&quot;, &quot;}&quot;);
+   * // this assertions succeed
+   * assertThat(book).containsSequence(&quot;'title'&quot;, &quot;:&quot;, &quot;'A Game of Thrones'&quot;);
+   * 
+   * // this one too even if there are values between the expected sequence (e.g &quot;'title':'&quot;) 
+   * assertThat(book).containsSequence(&quot;{&quot;, &quot;A Game of Thrones&quot;, &quot;George Martin&quot;, &quot;}&quot;);
    * 
-   * // ... but this one fails as &quot;author&quot; must come after &quot;A Game of Thrones&quot;
+   * // this one fails as &quot;author&quot; must come after &quot;A Game of Thrones&quot;
    * assertThat(book).containsSequence(&quot;{&quot;, &quot;author&quot;, &quot;A Game of Thrones&quot;, &quot;}&quot;);</code></pre>
    *
    * @param values the Strings to look for, in order.
@@ -362,14 +367,19 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * Verifies that the actual {@code CharSequence} contains all the strings of the given Iterable <b>in the Iterable
    * iteration order</b>.
    * <p>
+   * Note that <b>unlike</b> {@link IterableAssert#containsSequence(Object...)}, the assertion will succeed when there are values between the expected sequence values.
+   * <p>
    * Example:
    * <pre><code class='java'> String book = &quot;{ 'title':'A Game of Thrones', 'author':'George Martin'}&quot;;
    *
-   * // this assertion succeeds ...
-   * assertThat(book).containsSequence(Arrays.asList(&quot;{&quot;, &quot;title&quot;, &quot;A Game of Thrones&quot;, &quot;}&quot;));
+   * // this assertion succeeds
+   * assertThat(book).containsSequence(asList(&quot;{&quot;, &quot;title&quot;, &quot;A Game of Thrones&quot;, &quot;}&quot;));
+   * 
+   * // this one too even if there are values between the expected sequence (e.g &quot;'title':'&quot;) 
+   * assertThat(book).containsSequence(asList(&quot;{&quot;, &quot;A Game of Thrones&quot;, &quot;George Martin&quot;, &quot;}&quot;));
    *
-   * // ... but this one fails as &quot;author&quot; must come after &quot;A Game of Thrones&quot;
-   * assertThat(book).containsSequence(Arrays.asList(&quot;{&quot;, &quot;author&quot;, &quot;A Game of Thrones&quot;, &quot;}&quot;));</code></pre>
+   * // but this one fails as &quot;author&quot; must come after &quot;A Game of Thrones&quot;
+   * assertThat(book).containsSequence(asList(&quot;{&quot;, &quot;author&quot;, &quot;A Game of Thrones&quot;, &quot;}&quot;));</code></pre>
    *
    * @param values the Strings to look for, in order.
    * @return {@code this} assertion object.
@@ -774,7 +784,7 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
     strings.assertEqualsIgnoringWhitespace(info, actual, expected);
     return myself;
   }
-  
+
   /**
    * Verifies that the actual {@code CharSequence} is not equal to the given one, ignoring whitespace differences
    * (mostly).<br/>
diff --git a/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java b/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
index bfe368b16..0be0fc6f8 100644
--- a/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
+++ b/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
@@ -128,7 +128,9 @@ public interface ObjectEnumerableAssert<S extends ObjectEnumerableAssert<S, T>,
   S containsExactly(@SuppressWarnings("unchecked") T... values);
 
   /**
-   * Verifies that the actual group contains the given sequence, without any other values between them.
+   * Verifies that the actual group contains the given sequence in the correct order and <b>without extra value between the sequence values</b>.
+   * <p> 
+   * Use {@link #containsSubsequence(Object...)} to allow values between the expected sequence values.
    * <p>
    * Example:
    * <pre><code class='java'> // an Iterable is used in the example but it would also work with an array
@@ -136,9 +138,10 @@ public interface ObjectEnumerableAssert<S extends ObjectEnumerableAssert<S, T>,
    * 
    * // assertion will pass
    * assertThat(elvesRings).containsSequence(vilya, nenya);
+   * assertThat(elvesRings).containsSequence(nenya, narya);
    * 
-   * // assertions will fail
-   * assertThat(elvesRings).containsSequence(vilya, narya);
+   * // assertions will fail, the elements order is correct but there is a value between them (nenya) 
+   * assertThat(elvesRings).containsSequence(vilya, narya);  
    * assertThat(elvesRings).containsSequence(nenya, vilya);</code></pre>
    * 
    * @param sequence the sequence of objects to look for.
@@ -150,7 +153,7 @@ public interface ObjectEnumerableAssert<S extends ObjectEnumerableAssert<S, T>,
   S containsSequence(@SuppressWarnings("unchecked") T... sequence);
 
   /**
-   * Verifies that the actual group contains the given subsequence (possibly with other values between them).
+   * Verifies that the actual group contains the given subsequence in the correct order (possibly with other values between them).
    * <p>
    * Example:
    * <pre><code class='java'> // an Iterable is used in the example but it would also work with an array
diff --git a/src/main/java/org/assertj/core/error/ShouldContainCharSequenceSequence.java b/src/main/java/org/assertj/core/error/ShouldContainCharSequenceSequence.java
new file mode 100644
index 000000000..bfb88b996
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldContainCharSequenceSequence.java
@@ -0,0 +1,60 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import org.assertj.core.internal.ComparisonStrategy;
+import org.assertj.core.internal.StandardComparisonStrategy;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a {@code CharSequence} contains a sequence of
+ * several {@code CharSequence}s in order failed.
+ * 
+ * @author Joel Costigliola
+ * @author Mikhail Mazursky
+ */
+public class ShouldContainCharSequenceSequence extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new <code>{@link ShouldContainCharSequenceSequence}</code>.
+   * 
+   * @param actual the actual value in the failed assertion.
+   * @param strings the sequence of values expected to be in {@code actual}.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldContainSequence(CharSequence actual, CharSequence[] strings, int firstBadOrderIndex) {
+    return shouldContainSequence(actual, strings, firstBadOrderIndex, StandardComparisonStrategy.instance());
+  }
+
+  /**
+   * Creates a new <code>{@link ShouldContainCharSequenceSequence}</code>.
+   * 
+   * @param actual the actual value in the failed assertion.
+   * @param strings the sequence of values expected to be in {@code actual}.
+   * @param comparisonStrategy the {@link ComparisonStrategy} used to evaluate assertion.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldContainSequence(CharSequence actual, CharSequence[] strings, int badOrderIndex,
+      ComparisonStrategy comparisonStrategy) {
+
+    return new ShouldContainCharSequenceSequence(
+                                           "%nExpecting:%n <%s>%nto contain the following CharSequences in this order:%n <%s>%nbut <%s> was found before <%s>%n%s",
+                                           actual, strings, strings[badOrderIndex + 1], strings[badOrderIndex],
+                                           comparisonStrategy);
+  }
+
+  private ShouldContainCharSequenceSequence(String format, CharSequence actual, CharSequence[] strings, CharSequence foundButBadOrder,
+      CharSequence foundButBadOrder2, ComparisonStrategy comparisonStrategy) {
+    super(format, actual, strings, foundButBadOrder, foundButBadOrder2, comparisonStrategy);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/internal/Strings.java b/src/main/java/org/assertj/core/internal/Strings.java
index e967cc8fb..9ee7b0d13 100644
--- a/src/main/java/org/assertj/core/internal/Strings.java
+++ b/src/main/java/org/assertj/core/internal/Strings.java
@@ -24,9 +24,9 @@ import static org.assertj.core.error.ShouldBeSubstring.shouldBeSubstring;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContainIgnoringCase;
 import static org.assertj.core.error.ShouldContainCharSequenceOnlyOnce.shouldContainOnlyOnce;
+import static org.assertj.core.error.ShouldContainCharSequenceSequence.shouldContainSequence;
 import static org.assertj.core.error.ShouldContainOnlyDigits.shouldContainOnlyDigits;
 import static org.assertj.core.error.ShouldContainPattern.shouldContainPattern;
-import static org.assertj.core.error.ShouldContainSequence.shouldContainSequence;
 import static org.assertj.core.error.ShouldEndWith.shouldEndWith;
 import static org.assertj.core.error.ShouldMatchPattern.shouldMatch;
 import static org.assertj.core.error.ShouldNotBeEmpty.shouldNotBeEmpty;
@@ -51,10 +51,8 @@ import static org.assertj.core.util.xml.XmlStringPrettyFormatter.xmlPrettyFormat
 import java.io.IOException;
 import java.io.LineNumberReader;
 import java.io.StringReader;
-import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.LinkedHashSet;
-import java.util.List;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
@@ -613,45 +611,28 @@ public class Strings {
       throw failures.failure(info, shouldContain(actual, sequence, notFound, comparisonStrategy));
     }
 
-    // we have found all the given values but were they in the expected sequence ?
-    if (sequence.length == 1) return; // no order chekec needed for a one element sequence
+    // we have found all the given values but were they in the expected order ?
+    if (sequence.length == 1) return; // no order check needed for a one element sequence
 
     // convert all to one char CharSequence list to ease comparison
-    List<CharSequence> splitActual = split(actual);
-    List<CharSequence> splitSequence = flatSplit(sequence);
-    for (int i = 0; i < splitActual.size(); i++) {
-      // look for given sequence in actual starting from current index (i)
-      if (containsSequenceAtGivenIndex(splitActual, splitSequence, i)) return;
-    }
-    throw failures.failure(info, shouldContainSequence(actual, sequence, comparisonStrategy));
-  }
-
-  private List<CharSequence> flatSplit(CharSequence[] sequence) {
-    List<CharSequence> flatSplitCharSequence = new ArrayList<>();
-    for (int i = 0; i < sequence.length; i++) {
-      flatSplitCharSequence.addAll(split(sequence[i]));
-    }
-    return flatSplitCharSequence;
-  }
-
-  private List<CharSequence> split(CharSequence charSequence) {
-    checkNotNull(charSequence, "Expecting CharSequence not to be null");
-    int length = charSequence.length();
-    List<CharSequence> splitCharSequence = new ArrayList<>(length);
-    for (int i = 0; i < length; i++) {
-      splitCharSequence.add(String.valueOf(charSequence.charAt(i)));
+    String strActual = actual.toString();
+    for (int i = 1; i < sequence.length; i++) {
+      int indexOfCurrentSequenceValue = indexOf(strActual, sequence[i - 1].toString());
+      int indexOfNextSequenceValue = indexOf(strActual, sequence[i].toString());
+      if (indexOfCurrentSequenceValue > indexOfNextSequenceValue) {
+        throw failures.failure(info, shouldContainSequence(actual, sequence, i-1, comparisonStrategy));
+      }
+      // get rid of the start of String to properly handle duplicate sequence values
+      // ex: "a-b-c" and sequence "a", "-", "b", "-", "c" would fail as the second "-" would be found before "b"
+      strActual = strActual.substring(indexOfCurrentSequenceValue + 1);
     }
-    return splitCharSequence;
   }
 
-  private boolean containsSequenceAtGivenIndex(List<CharSequence> actualAsList, List<CharSequence> sequence,
-                                               int startingIndex) {
-    // check that, starting from given index, actualAsList has enough remaining elements to contain sequence
-    if (actualAsList.size() - startingIndex < sequence.size()) return false;
-    for (int i = 0; i < sequence.size(); i++) {
-      if (!comparisonStrategy.areEqual(actualAsList.get(startingIndex + i), sequence.get(i))) return false;
+  private int indexOf(String string, String toFind) {
+    for (int i = 0; i < string.length(); i++) {
+      if (comparisonStrategy.stringStartsWith(string.substring(i), toFind)) return i;
     }
-    return true;
+    return -1;
   }
 
   public void assertXmlEqualsTo(AssertionInfo info, CharSequence actualXml, CharSequence expectedXml) {
diff --git a/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java
new file mode 100644
index 000000000..0f44748b6
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java
@@ -0,0 +1,67 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import static org.assertj.core.error.ShouldContainCharSequenceSequence.shouldContainSequence;
+
+import org.assertj.core.presentation.StandardRepresentation;
+import org.junit.Test;
+
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.util.CaseInsensitiveStringComparator;
+
+/**
+ * Tests for <code>{@link ShouldContainCharSequenceSequence#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class ShouldContainSequenceString_create_Test {
+
+  private ErrorMessageFactory factory;
+
+  @Test
+  public void should_create_error_message() {
+    String[] sequenceValues = { "{", "author", "title", "}" };
+    String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
+
+    factory = shouldContainSequence(actual, sequenceValues, 1);
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(String.format(
+        "[Test] %nExpecting:%n <\"" + actual + "\">%n"
+        + "to contain the following CharSequences in this order:%n"
+        + " <[\"{\", \"author\", \"title\", \"}\"]>%n"
+        + "but <\"title\"> was found before <\"author\">%n"
+    ));
+  }
+
+  @Test
+  public void should_create_error_message_with_custom_comparison_strategy() {
+    String[] sequenceValues = { "{", "author", "title", "}" };
+    String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
+
+    factory = shouldContainSequence(actual, sequenceValues, 1,
+                                    new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(String.format(
+        "[Test] %nExpecting:%n <\"" + actual + "\">%n"
+        + "to contain the following CharSequences in this order:%n"
+        + " <[\"{\", \"author\", \"title\", \"}\"]>%n"
+        + "but <\"title\"> was found before <\"author\">%n"
+        + "when comparing values using 'CaseInsensitiveStringComparator'"
+    ));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSequence_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSequence_Test.java
index 831319354..49c65b73f 100644
--- a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSequence_Test.java
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSequence_Test.java
@@ -13,7 +13,7 @@
 package org.assertj.core.internal.strings;
 
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
-import static org.assertj.core.error.ShouldContainSequence.shouldContainSequence;
+import static org.assertj.core.error.ShouldContainCharSequenceSequence.shouldContainSequence;
 import static org.assertj.core.test.ErrorMessages.arrayOfValuesToLookForIsEmpty;
 import static org.assertj.core.test.ErrorMessages.arrayOfValuesToLookForIsNull;
 import static org.assertj.core.test.TestData.someInfo;
@@ -34,6 +34,13 @@ public class Strings_assertContainsSequence_Test extends StringsBaseTest {
     strings.assertContainsSequence(someInfo(), "Yoda", array("Yo", "da"));
   }
 
+  @Test
+  public void should_pass_if_actual_contains_sequence_with_values_between() {
+    String[] sequenceValues = { "{", "title", "A Game of Thrones", "}" };
+    String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
+    strings.assertContainsSequence(someInfo(), actual, sequenceValues);
+  }
+  
   @Test
   public void should_fail_if_actual_does_not_contain_all_given_strings() {
     AssertionInfo info = someInfo();
@@ -53,9 +60,8 @@ public class Strings_assertContainsSequence_Test extends StringsBaseTest {
     String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
     try {
       strings.assertContainsSequence(info, actual, sequenceValues);
-      strings.assertContainsSequence(info, actual, sequenceValues);
     } catch (AssertionError e) {
-      verify(failures).failure(info, shouldContainSequence(actual, sequenceValues));
+      verify(failures).failure(info, shouldContainSequence(actual, sequenceValues, 1));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
@@ -89,7 +95,6 @@ public class Strings_assertContainsSequence_Test extends StringsBaseTest {
     strings.assertContainsSequence(someInfo(), "a-b-c-", array("a", "-", "b", "-", "c"));
   }
   
-  
   // tests with custom comparison strategy
 
   @Test
@@ -121,7 +126,7 @@ public class Strings_assertContainsSequence_Test extends StringsBaseTest {
     try {
       stringsWithCaseInsensitiveComparisonStrategy.assertContainsSequence(info, actual, sequenceValues);
     } catch (AssertionError e) {
-      verify(failures).failure(info, shouldContainSequence(actual, sequenceValues, comparisonStrategy));
+      verify(failures).failure(info, shouldContainSequence(actual, sequenceValues, 1, comparisonStrategy));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
