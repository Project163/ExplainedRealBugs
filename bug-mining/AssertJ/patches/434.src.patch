diff --git a/src/main/java/org/assertj/core/error/ShouldContainEntries.java b/src/main/java/org/assertj/core/error/ShouldContainEntries.java
new file mode 100644
index 000000000..7f3cbff9e
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldContainEntries.java
@@ -0,0 +1,101 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.data.MapEntry.entry;
+import static org.assertj.core.util.Strings.escapePercent;
+
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import org.assertj.core.data.MapEntry;
+import org.assertj.core.presentation.Representation;
+
+public class ShouldContainEntries extends BasicErrorMessageFactory {
+
+  public static <K, V> ErrorMessageFactory shouldContainEntries(Map<? extends K, ? extends V> actual,
+                                                                Entry<? extends K, ? extends V>[] expectedEntries,
+                                                                Set<Entry<? extends K, ? extends V>> entriesWithWrongValue,
+                                                                Set<Entry<? extends K, ? extends V>> entriesWithKeyNotFound,
+                                                                Representation representation) {
+    if (entriesWithWrongValue.isEmpty()) return new ShouldContainEntries(actual, expectedEntries, entriesWithKeyNotFound);
+    if (entriesWithKeyNotFound.isEmpty())
+      return new ShouldContainEntries(actual, expectedEntries,
+                                      buildValueDifferences(actual, entriesWithWrongValue, representation));
+    // mix of missing keys and keys with different values
+    return new ShouldContainEntries(actual, expectedEntries, entriesWithKeyNotFound,
+                                    buildValueDifferences(actual, entriesWithWrongValue, representation));
+  }
+
+  private static <K, V> List<String> buildValueDifferences(Map<? extends K, ? extends V> actual,
+                                                           Set<Entry<? extends K, ? extends V>> entriesWithWrongValues,
+                                                           Representation representation) {
+    return entriesWithWrongValues.stream()
+                                 .map(entryWithWrongValue -> valueDifference(actual, entryWithWrongValue, representation))
+                                 .collect(toList());
+  }
+
+  private static <K, V> String valueDifference(Map<? extends K, ? extends V> actual,
+                                               Entry<? extends K, ? extends V> entryWithWrongValue,
+                                               Representation representation) {
+    K key = entryWithWrongValue.getKey();
+    MapEntry<K, ? extends V> actualEntry = entry(key, actual.get(key));
+    V expectedValue = entryWithWrongValue.getValue();
+    return escapePercent(format("%s (expected: %s)", representation.toStringOf(actualEntry),
+                                representation.toStringOf(expectedValue)));
+  }
+
+  private <K, V> ShouldContainEntries(Map<? extends K, ? extends V> actual,
+                                      Entry<? extends K, ? extends V>[] expectedEntries,
+                                      Set<Entry<? extends K, ? extends V>> notFound) {
+    super("%nExpecting map:%n" +
+          "  %s%n" +
+          "to contain entries:%n" +
+          "  %s%n" +
+          "but could not find the following map entries:%n" +
+          "  %s",
+          actual, expectedEntries, notFound);
+  }
+
+  private <K, V> ShouldContainEntries(Map<? extends K, ? extends V> actual,
+                                      Entry<? extends K, ? extends V>[] expectedEntries,
+                                      List<String> valueDifferences) {
+    super("%nExpecting map:%n" +
+          "  %s%n" +
+          "to contain entries:%n" +
+          "  %s%n" +
+          "but the following map entries had different values:%n" +
+          "  " + valueDifferences,
+          actual, expectedEntries, valueDifferences);
+  }
+
+  private <K, V> ShouldContainEntries(Map<? extends K, ? extends V> actual,
+                                      Entry<? extends K, ? extends V>[] expectedEntries,
+                                      Set<Entry<? extends K, ? extends V>> keysNotFound,
+                                      List<String> valueDifferences) {
+    super("%nExpecting map:%n" +
+          "  %s%n" +
+          "to contain entries:%n" +
+          "  %s%n" +
+          "but could not find the following map entries:%n" +
+          "  %s%n" +
+          "and the following map entries had different values:%n" +
+          "  " + valueDifferences,
+          actual, expectedEntries, keysNotFound);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/internal/Maps.java b/src/main/java/org/assertj/core/internal/Maps.java
index b2a25f705..76728f4b3 100644
--- a/src/main/java/org/assertj/core/internal/Maps.java
+++ b/src/main/java/org/assertj/core/internal/Maps.java
@@ -22,8 +22,8 @@ import static org.assertj.core.error.ElementsShouldSatisfy.elementsShouldSatisfy
 import static org.assertj.core.error.NoElementsShouldSatisfy.noElementsShouldSatisfy;
 import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
 import static org.assertj.core.error.ShouldBeNullOrEmpty.shouldBeNullOrEmpty;
-import static org.assertj.core.error.ShouldContain.shouldContain;
 import static org.assertj.core.error.ShouldContainAnyOf.shouldContainAnyOf;
+import static org.assertj.core.error.ShouldContainEntries.shouldContainEntries;
 import static org.assertj.core.error.ShouldContainEntry.shouldContainEntry;
 import static org.assertj.core.error.ShouldContainExactly.elementsDifferAtIndex;
 import static org.assertj.core.error.ShouldContainExactly.shouldContainExactly;
@@ -558,11 +558,16 @@ public class Maps {
 
   private <K, V> void failIfAnyEntryNotFoundInActualMap(AssertionInfo info, Map<K, V> actual,
                                                         Entry<? extends K, ? extends V>[] entries) {
-    Set<Entry<? extends K, ? extends V>> notFound = new LinkedHashSet<>();
+    Set<Entry<? extends K, ? extends V>> entriesWithKeyNotFound = new LinkedHashSet<>();
+    Set<Entry<? extends K, ? extends V>> entriesWithWrongValue = new LinkedHashSet<>();
     for (Entry<? extends K, ? extends V> entry : entries) {
-      if (!containsEntry(actual, entry)) notFound.add(entry);
+      requireNonNull(entry, ErrorMessages.entryToLookForIsNull());
+      if (!actual.containsKey(entry.getKey())) entriesWithKeyNotFound.add(entry);
+      else if (!containsEntry(actual, entry)) entriesWithWrongValue.add(entry); // can only be wrong value since key was found
     }
-    if (!notFound.isEmpty()) throw failures.failure(info, shouldContain(actual, entries, notFound));
+    if (!entriesWithWrongValue.isEmpty() || !entriesWithKeyNotFound.isEmpty())
+      throw failures.failure(info, shouldContainEntries(actual, entries, entriesWithWrongValue, entriesWithKeyNotFound,
+                                                        info.representation()));
   }
 
   private static <K, V> Map<K, V> entriesToMap(Entry<? extends K, ? extends V>[] entries) {
diff --git a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
index 1140c6f0a..5fb1a4c5f 100644
--- a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
@@ -177,10 +177,10 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errors).hasSize(2);
     assertThat(errors.get(0)).hasMessageContaining(format("Expecting map:%n"
                                                           + "  {\"54\"=\"55\"}%n"
-                                                          + "to contain:%n"
+                                                          + "to contain entries:%n"
                                                           + "  [\"1\"=\"2\"]%n"
                                                           + "but could not find the following map entries:%n"
-                                                          + "  [\"1\"=\"2\"]%n"));
+                                                          + "  [\"1\"=\"2\"]"));
     assertThat(errors.get(1)).hasMessageContaining(format("Expecting empty but was: {\"54\"=\"55\"}"));
 
   }
@@ -336,10 +336,10 @@ class BDDSoftAssertionsTest extends BaseAssertionsTest {
                                                + "  \"something was wrong\""));
     assertThat(errors.get(39)).contains(format("%nExpecting map:%n"
                                                + "  {\"54\"=\"55\"}%n"
-                                               + "to contain:%n"
+                                               + "to contain entries:%n"
                                                + "  [\"1\"=\"2\"]%n"
                                                + "but could not find the following map entries:%n"
-                                               + "  [\"1\"=\"2\"]%n"));
+                                               + "  [\"1\"=\"2\"]"));
     assertThat(errors.get(40)).contains(shouldBeEqualMessage("12:00", "13:00"));
     assertThat(errors.get(41)).contains(shouldBeEqualMessage("12:00Z", "13:00Z"));
     assertThat(errors.get(42)).contains(shouldBeEqualMessage("Optional[not empty]", "\"empty\""));
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index 6d3966626..1b4e7802c 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -178,10 +178,10 @@ class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errors).hasSize(2);
     assertThat(errors.get(0)).hasMessageStartingWith(format("%nExpecting map:%n"
                                                             + "  {\"54\"=\"55\"}%n"
-                                                            + "to contain:%n"
+                                                            + "to contain entries:%n"
                                                             + "  [\"1\"=\"2\"]%n"
                                                             + "but could not find the following map entries:%n"
-                                                            + "  [\"1\"=\"2\"]%n"));
+                                                            + "  [\"1\"=\"2\"]"));
     assertThat(errors.get(1)).hasMessageStartingWith(format("%nExpecting empty but was: {\"54\"=\"55\"}"));
   }
 
@@ -369,10 +369,10 @@ class SoftAssertionsTest extends BaseAssertionsTest {
                                                  + "  \"something was wrong\""));
       assertThat(errors.get(39)).contains(format("%nExpecting map:%n"
                                                  + "  {\"54\"=\"55\"}%n"
-                                                 + "to contain:%n"
+                                                 + "to contain entries:%n"
                                                  + "  [\"1\"=\"2\"]%n"
                                                  + "but could not find the following map entries:%n"
-                                                 + "  [\"1\"=\"2\"]%n"));
+                                                 + "  [\"1\"=\"2\"]"));
 
       assertThat(errors.get(40)).contains(shouldBeEqualMessage("12:00", "13:00"));
       assertThat(errors.get(41)).contains(shouldBeEqualMessage("12:00Z", "13:00Z"));
diff --git a/src/test/java/org/assertj/core/error/ShouldContainEntries_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainEntries_create_Test.java
new file mode 100644
index 000000000..68936bf94
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldContainEntries_create_Test.java
@@ -0,0 +1,119 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static java.util.Collections.emptySet;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.MapEntry.entry;
+import static org.assertj.core.error.ShouldContainEntries.shouldContainEntries;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.test.Maps.mapOf;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Sets.set;
+
+import java.util.Map;
+import java.util.Map.Entry;
+import java.util.Set;
+
+import org.assertj.core.description.TextDescription;
+import org.junit.jupiter.api.Test;
+
+class ShouldContainEntries_create_Test {
+
+  @Test
+  void should_create_error_message_when_all_keys_are_found_but_values_differ() {
+    // GIVEN
+    Map<?, ?> map = mapOf(entry("name", "yoda"), entry("color", "green"));
+    Entry<?, ?>[] expectedEntries = array(entry("name", "vador"), entry("color", "red"));
+    Set<Entry<?, ?>> keysWithWrongValues = set(entry("name", "vador"), entry("color", "red"));
+    Set<Entry<?, ?>> keysNotFound = emptySet();
+    ErrorMessageFactory factory = shouldContainEntries(map, expectedEntries, keysWithWrongValues, keysNotFound,
+                                                       STANDARD_REPRESENTATION);
+    // WHEN
+    String message = factory.create(new TextDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting map:%n" +
+                                   "  {\"color\"=\"green\", \"name\"=\"yoda\"}%n" +
+                                   "to contain entries:%n" +
+                                   "  [\"name\"=\"vador\", \"color\"=\"red\"]%n" +
+                                   "but the following map entries had different values:%n" +
+                                   "  [\"name\"=\"yoda\" (expected: \"vador\"), \"color\"=\"green\" (expected: \"red\")]"));
+  }
+
+  @Test
+  void should_create_error_message_when_keys_and_values_differ() {
+    // GIVEN
+    Map<?, ?> map = mapOf(entry("name", "yoda"), entry("color", "green"));
+    Entry<?, ?>[] expectedEntries = array(entry("NAME", "vador"), entry("COLOR", "red"));
+    Set<Entry<?, ?>> keysWithWrongValues = emptySet();
+    Set<Entry<?, ?>> keysNotFound = set(entry("NAME", "vador"), entry("COLOR", "red"));
+    ErrorMessageFactory factory = shouldContainEntries(map, expectedEntries, keysWithWrongValues, keysNotFound,
+                                                       STANDARD_REPRESENTATION);
+    // WHEN
+    String message = factory.create(new TextDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting map:%n" +
+                                   "  {\"color\"=\"green\", \"name\"=\"yoda\"}%n" +
+                                   "to contain entries:%n" +
+                                   "  [\"NAME\"=\"vador\", \"COLOR\"=\"red\"]%n" +
+                                   "but could not find the following map entries:%n" +
+                                   "  [\"NAME\"=\"vador\", \"COLOR\"=\"red\"]"));
+  }
+
+  @Test
+  void should_create_error_message_when_no_keys_are_found() {
+    // GIVEN
+    Map<?, ?> map = mapOf(entry("name", "yoda"), entry("color", "green"));
+    Entry<?, ?>[] expectedEntries = array(entry("NAME", "yoda"), entry("COLOR", "green"));
+    Set<Entry<?, ?>> keysWithWrongValues = emptySet();
+    Set<Entry<?, ?>> keysNotFound = set(entry("NAME", "yoda"), entry("COLOR", "green"));
+    ErrorMessageFactory factory = shouldContainEntries(map, expectedEntries, keysWithWrongValues, keysNotFound,
+                                                       STANDARD_REPRESENTATION);
+    // WHEN
+    String message = factory.create(new TextDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting map:%n" +
+                                   "  {\"color\"=\"green\", \"name\"=\"yoda\"}%n" +
+                                   "to contain entries:%n" +
+                                   "  [\"NAME\"=\"yoda\", \"COLOR\"=\"green\"]%n" +
+                                   "but could not find the following map entries:%n" +
+                                   "  [\"NAME\"=\"yoda\", \"COLOR\"=\"green\"]"));
+  }
+
+  @Test
+  void should_create_error_message_when_some_keys_are_found_but_values_differ() {
+    // GIVEN
+    Map<?, ?> map = mapOf(entry("name", "yoda"), entry("color", "%d"), entry("power", "99%"));
+    Entry<?, ?>[] expectedEntries = array(entry("NAME", "yoda"), entry("color", "red"), entry("power", "%s"));
+    Set<Entry<?, ?>> keysWithWrongValues = set(entry("color", "red"), entry("power", "%s"));
+    Set<Entry<?, ?>> keysNotFound = set(entry("NAME", "yoda"));
+    ErrorMessageFactory factory = shouldContainEntries(map, expectedEntries, keysWithWrongValues, keysNotFound,
+                                                       STANDARD_REPRESENTATION);
+    // WHEN
+    String message = factory.create(new TextDescription("Test"), STANDARD_REPRESENTATION);
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "Expecting map:%n" +
+                                   "  {\"color\"=\"%%d\", \"name\"=\"yoda\", \"power\"=\"99%%\"}%n" +
+                                   "to contain entries:%n" +
+                                   "  [\"NAME\"=\"yoda\", \"color\"=\"red\", \"power\"=\"%%s\"]%n" +
+                                   "but could not find the following map entries:%n" +
+                                   "  [\"NAME\"=\"yoda\"]%n" +
+                                   "and the following map entries had different values:%n" +
+                                   "  [\"color\"=\"%%d\" (expected: \"red\"), \"power\"=\"99%%\" (expected: \"%%s\")]"));
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/MapsBaseTest.java b/src/test/java/org/assertj/core/internal/MapsBaseTest.java
index 38f8e14bc..5c95b5e4d 100644
--- a/src/test/java/org/assertj/core/internal/MapsBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/MapsBaseTest.java
@@ -49,8 +49,8 @@ public class MapsBaseTest extends WithPlayerData {
     info = someInfo();
   }
 
-  @SuppressWarnings("rawtypes")
-  protected static MapEntry[] emptyEntries() {
+  @SuppressWarnings("unchecked")
+  protected static <K, V> MapEntry<K, V>[] emptyEntries() {
     return new MapEntry[0];
   }
 
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsAllEntriesOf_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsAllEntriesOf_Test.java
index b5be90115..ee333b4d8 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsAllEntriesOf_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContainsAllEntriesOf_Test.java
@@ -13,18 +13,19 @@
 package org.assertj.core.internal.maps;
 
 import static java.util.Collections.emptyMap;
+import static java.util.Collections.emptySet;
 import static org.assertj.core.api.Assertions.catchThrowableOfType;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.MapEntry.entry;
-import static org.assertj.core.error.ShouldContain.shouldContain;
+import static org.assertj.core.error.ShouldContainEntries.shouldContainEntries;
 import static org.assertj.core.internal.ErrorMessages.mapOfEntriesToLookForIsNull;
 import static org.assertj.core.test.Maps.mapOf;
-import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Sets.set;
 
-import java.util.LinkedHashMap;
 import java.util.Map;
+import java.util.Map.Entry;
 
 import org.assertj.core.internal.MapsBaseTest;
 import org.junit.jupiter.api.Test;
@@ -33,28 +34,28 @@ class Maps_assertContainsAllEntriesOf_Test extends MapsBaseTest {
 
   @Test
   void should_pass_if_actual_contains_given_map_entries() {
-    maps.assertContainsAllEntriesOf(someInfo(), actual, mapOf(entry("name", "Yoda")));
+    maps.assertContainsAllEntriesOf(info, actual, mapOf(entry("name", "Yoda")));
   }
 
   @Test
   void should_pass_if_actual_contains_given_map_entries_in_different_order() {
-    maps.assertContainsAllEntriesOf(someInfo(), actual, mapOf(entry("color", "green"), entry("name", "Yoda")));
+    maps.assertContainsAllEntriesOf(info, actual, mapOf(entry("color", "green"), entry("name", "Yoda")));
   }
 
   @Test
   void should_pass_if_actual_contains_all_given_map_entries() {
-    maps.assertContainsAllEntriesOf(someInfo(), actual, mapOf(entry("name", "Yoda"), entry("color", "green")));
+    maps.assertContainsAllEntriesOf(info, actual, mapOf(entry("name", "Yoda"), entry("color", "green")));
   }
 
   @Test
   void should_pass_if_actual_and_given_map_are_empty() {
     actual = emptyMap();
-    maps.assertContainsAllEntriesOf(someInfo(), actual, mapOf());
+    maps.assertContainsAllEntriesOf(info, actual, mapOf());
   }
 
   @Test
   void should_pass_if_actual_is_not_empty_and_given_map_is_empty() {
-    maps.assertContainsAllEntriesOf(someInfo(), actual, emptyMap());
+    maps.assertContainsAllEntriesOf(info, actual, emptyMap());
   }
 
   @Test
@@ -62,11 +63,10 @@ class Maps_assertContainsAllEntriesOf_Test extends MapsBaseTest {
     // GIVEN
     Map<String, String> other = null;
     // WHEN
-    NullPointerException npe = catchThrowableOfType(() -> maps.assertContainsAllEntriesOf(someInfo(), actual, other),
+    NullPointerException npe = catchThrowableOfType(() -> maps.assertContainsAllEntriesOf(info, actual, other),
                                                     NullPointerException.class);
     // THEN
-    then(npe).isNotNull()
-             .hasMessage(mapOfEntriesToLookForIsNull());
+    then(npe).hasMessage(mapOfEntriesToLookForIsNull());
   }
 
   @Test
@@ -74,7 +74,7 @@ class Maps_assertContainsAllEntriesOf_Test extends MapsBaseTest {
     // GIVEN
     Map<String, String> actual = null;
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsAllEntriesOf(someInfo(), actual,
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsAllEntriesOf(info, actual,
                                                                                                mapOf(entry("name", "Yoda"))));
     // THEN
     then(assertionError).hasMessage(actualIsNull());
@@ -83,10 +83,39 @@ class Maps_assertContainsAllEntriesOf_Test extends MapsBaseTest {
   @Test
   void should_fail_if_actual_does_not_contain_map_entries() {
     // GIVEN
-    LinkedHashMap<String, String> other = mapOf(entry("name", "Yoda"), entry("job", "Jedi"));
+    Map<String, String> expected = mapOf(entry("name", "Yoda"), entry("job", "Jedi"));
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsAllEntriesOf(info, actual, other));
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsAllEntriesOf(info, actual, expected));
     // THEN
-    then(assertionError).hasMessage(shouldContain(actual, other.entrySet(), mapOf(entry("job", "Jedi")).entrySet()).create());
+    then(assertionError).hasMessage(shouldContainEntries(actual, asEntriesArray(expected), emptySet(), set(entry("job", "Jedi")),
+                                                         info.representation()).create());
   }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_entries_because_values_differ_for_the_same_key() {
+    // GIVEN
+    Map<String, String> expected = mapOf(entry("name", "Yoda"), entry("color", "red"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsAllEntriesOf(info, actual, expected));
+    // THEN
+    then(assertionError).hasMessage(shouldContainEntries(actual, asEntriesArray(expected), set(entry("color", "red")), emptySet(),
+                                                         info.representation()).create());
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_entries_because_of_some_missing_keys_and_some_values_difference() {
+    // GIVEN
+    Map<String, String> expected = mapOf(entry("name", "Yoda"), entry("color", "red"), entry("job", "Jedi"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContainsAllEntriesOf(info, actual, expected));
+    // THEN
+    then(assertionError).hasMessage(shouldContainEntries(actual, asEntriesArray(expected), set(entry("color", "red")),
+                                                         set(entry("job", "Jedi")), info.representation()).create());
+  }
+
+  @SuppressWarnings("unchecked")
+  private static Entry<String, String>[] asEntriesArray(Map<String, String> expected) {
+    return expected.entrySet().toArray(new Entry[0]);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/internal/maps/Maps_assertContains_Test.java b/src/test/java/org/assertj/core/internal/maps/Maps_assertContains_Test.java
index 74be1bba4..c685cf8d6 100644
--- a/src/test/java/org/assertj/core/internal/maps/Maps_assertContains_Test.java
+++ b/src/test/java/org/assertj/core/internal/maps/Maps_assertContains_Test.java
@@ -12,25 +12,25 @@
  */
 package org.assertj.core.internal.maps;
 
+import static java.util.Collections.emptyMap;
+import static java.util.Collections.emptySet;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.data.MapEntry.entry;
 import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
-import static org.assertj.core.error.ShouldContain.shouldContain;
+import static org.assertj.core.error.ShouldContainEntries.shouldContainEntries;
 import static org.assertj.core.internal.ErrorMessages.entriesToLookForIsNull;
 import static org.assertj.core.internal.ErrorMessages.entryToLookForIsNull;
-import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
-import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.assertj.core.util.Sets.set;
 import static org.mockito.Mockito.verify;
 
-import java.util.HashMap;
 import java.util.Map;
+import java.util.Map.Entry;
 
 import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.data.MapEntry;
 import org.assertj.core.internal.Maps;
 import org.assertj.core.internal.MapsBaseTest;
 import org.junit.jupiter.api.Test;
@@ -45,31 +45,28 @@ class Maps_assertContains_Test extends MapsBaseTest {
 
   @Test
   void should_pass_if_actual_contains_given_entries() {
-    maps.assertContains(someInfo(), actual, array(entry("name", "Yoda")));
+    maps.assertContains(info, actual, array(entry("name", "Yoda")));
   }
 
   @Test
   void should_pass_if_actual_contains_given_entries_in_different_order() {
-    maps.assertContains(someInfo(), actual, array(entry("color", "green"), entry("name", "Yoda")));
+    maps.assertContains(info, actual, array(entry("color", "green"), entry("name", "Yoda")));
   }
 
   @Test
   void should_pass_if_actual_contains_all_given_entries() {
-    maps.assertContains(someInfo(), actual, array(entry("name", "Yoda"), entry("color", "green")));
+    maps.assertContains(info, actual, array(entry("name", "Yoda"), entry("color", "green")));
   }
 
-  @SuppressWarnings("unchecked")
   @Test
   void should_pass_if_actual_and_given_entries_are_empty() {
-    actual = new HashMap<>();
-    maps.assertContains(someInfo(), actual, emptyEntries());
+    maps.assertContains(info, emptyMap(), emptyEntries());
   }
 
   @Test
   void should_fail_if_array_of_entries_to_look_for_is_empty_and_the_map_under_test_is_not() {
     // GIVEN
-    AssertionInfo info = someInfo();
-    MapEntry<String, String>[] expected = emptyEntries();
+    Entry<String, String>[] expected = emptyEntries();
     // WHEN
     expectAssertionError(() -> maps.assertContains(info, actual, expected));
     // THEN
@@ -79,19 +76,19 @@ class Maps_assertContains_Test extends MapsBaseTest {
   @Test
   void should_throw_error_if_array_of_entries_to_look_for_is_null() {
     // GIVEN
-    MapEntry<String, String>[] entries = null;
+    Entry<String, String>[] entries = null;
     // WHEN/THEN
-    assertThatNullPointerException().isThrownBy(() -> maps.assertContains(someInfo(), actual, entries))
+    assertThatNullPointerException().isThrownBy(() -> maps.assertContains(info, actual, entries))
                                     .withMessage(entriesToLookForIsNull());
   }
 
   @Test
   void should_throw_error_if_entry_is_null() {
     // GIVEN
-    MapEntry<String, String> nullEntry = null;
-    MapEntry<String, String>[] entries = array(nullEntry);
+    Entry<String, String> nullEntry = null;
+    Entry<String, String>[] entries = array(nullEntry);
     // WHEN/THEN
-    assertThatNullPointerException().isThrownBy(() -> maps.assertContains(someInfo(), actual, entries))
+    assertThatNullPointerException().isThrownBy(() -> maps.assertContains(info, actual, entries))
                                     .withMessage(entryToLookForIsNull());
   }
 
@@ -99,21 +96,54 @@ class Maps_assertContains_Test extends MapsBaseTest {
   void should_fail_if_actual_is_null() {
     // GIVEN
     actual = null;
-    MapEntry<String, String>[] expected = array(entry("name", "Yoda"));
+    Entry<String, String>[] expected = array(entry("name", "Yoda"));
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> maps.assertContains(someInfo(), actual, expected));
+    AssertionError assertionError = expectAssertionError(() -> maps.assertContains(info, actual, expected));
     // THEN
     then(assertionError).hasMessage(actualIsNull());
   }
 
+  @Test
+  void should_fail_if_actual_is_empty_and_expected_entries_is_not() {
+    // GIVEN
+    Entry<String, String>[] expected = array(entry("a", "1"));
+    // WHEN
+    expectAssertionError(() -> maps.assertContains(info, emptyMap(), expected));
+    // THEN
+    verify(failures).failure(info,
+                             shouldContainEntries(emptyMap(), expected, emptySet(), set(entry("a", "1")), info.representation()));
+  }
+
   @Test
   void should_fail_if_actual_does_not_contain_entries() {
     // GIVEN
-    AssertionInfo info = someInfo();
-    MapEntry<String, String>[] expected = array(entry("name", "Yoda"), entry("job", "Jedi"));
+    Entry<String, String>[] expected = array(entry("name", "Yoda"), entry("job", "Jedi"));
+    // WHEN
+    expectAssertionError(() -> maps.assertContains(info, actual, expected));
+    // THEN
+    verify(failures).failure(info, shouldContainEntries(actual, expected, emptySet(), set(entry("job", "Jedi")),
+                                                        info.representation()));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_entries_because_values_differ_for_the_same_key() {
+    // GIVEN
+    Entry<String, String>[] expected = array(entry("name", "Yoda"), entry("color", "red"));
+    // WHEN
+    expectAssertionError(() -> maps.assertContains(info, actual, expected));
+    // THEN
+    verify(failures).failure(info, shouldContainEntries(actual, expected, set(entry("color", "red")), emptySet(),
+                                                        info.representation()));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_entries_because_of_some_missing_keys_and_some_values_difference() {
+    // GIVEN
+    Entry<String, String>[] expected = array(entry("name", "Yoda"), entry("color", "red"), entry("job", "Jedi"));
     // WHEN
     expectAssertionError(() -> maps.assertContains(info, actual, expected));
     // THEN
-    verify(failures).failure(info, shouldContain(actual, expected, newLinkedHashSet(entry("job", "Jedi"))));
+    verify(failures).failure(info, shouldContainEntries(actual, expected, set(entry("color", "red")), set(entry("job", "Jedi")),
+                                                        info.representation()));
   }
 }
