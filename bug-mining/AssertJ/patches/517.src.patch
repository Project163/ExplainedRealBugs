diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 9bb4cb18a..7656b103c 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -104,7 +104,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * <p>
    * <strong>Example</strong>
    * <p>
-   * Here is a basic example with a default {@link RecursiveComparisonConfiguration}, you can find other examples for each of the method changing the recursive comparison behavior
+   * Here is a basic example with a default {@link RecursiveComparisonConfiguration}, you can find other examples for each of the methods changing the recursive comparison behavior
    * like {@link #ignoringFields(String...)}.
    * <pre><code class='java'> class Person {
    *   String name;
@@ -140,20 +140,19 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * @return {@code this} assertion object.
    * @throws AssertionError if the actual object is {@code null}.
    * @throws AssertionError if the actual and the given objects are not deeply equal property/field by property/field.
-   * @throws IntrospectionError if one property/field to compare can not be found.
+   * @throws IntrospectionError if one property/field to compare cannot be found.
    */
   @Override
   public SELF isEqualTo(Object expected) {
     // deals with both actual and expected being null
     if (actual == expected) return myself;
     if (expected == null) {
-      // for the assertion to pass, actual must be null but this is not the case since actual != expected
-      // => we fail expecting actual to be null
+      // for the assertion to pass, actual must be null, but this is not the case since actual != expected
       objects.assertNull(info, actual);
     }
     // at this point expected is not null, which means actual must not be null for the assertion to pass
     objects.assertNotNull(info, actual);
-    // at this point both actual and expected are not null, we can compare them recursively!
+    // at this point, both actual and expected are not null, we can compare them recursively!
     List<ComparisonDifference> differences = determineDifferencesWith(expected);
     if (!differences.isEmpty()) throw objects.getFailures().failure(info, shouldBeEqualByComparingFieldByFieldRecursively(actual,
                                                                                                                           expected,
@@ -212,7 +211,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
                                                                                                    recursiveComparisonConfiguration,
                                                                                                    info.representation()));
     }
-    // either one of actual or other was null (but not both) or there were no differences
+    // either actual or other was null (but not both) or there were no differences
     return myself;
   }
 
@@ -375,7 +374,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Verifies that the actual value is not present in the given iterable, comparing values with the recursive comparison..
+   * Verifies that the actual value is not present in the given iterable, comparing values with the recursive comparison.
    * <p>
    * This assertion always succeeds if the given iterable is empty.
    * <p>
@@ -504,7 +503,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * the resulting compared fields = {specified compared fields of types} {@code -} {specified ignored fields}.<br>
    * For example, we specify the following compared types: {@code {String.class, Integer.class, Double.class}}, and the
    * object to compare has fields {@code String foo}, {@code Integer baz} and {@code Double bar},
-   * if we ignore the {"bar"} field with {@link RecursiveComparisonAssert#ignoringFields(String...)} the comparison will only report differences on {@code {foo, baz}} fields..
+   * if we ignore the {"bar"} field with {@link RecursiveComparisonAssert#ignoringFields(String...)} the comparison will only report differences on {@code {foo, baz}} fields.
    * <p>
    * Usage example:
    * <pre><code class='java'> class Person {
@@ -793,10 +792,14 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
 
   /**
    * Makes the recursive comparison to ignore the object under test fields of the given types.
-   * The fields are ignored if their types <b>exactly match one of the ignored types</b>, for example if a field is a subtype of an ignored type it is not ignored.
    * <p>
-   * If some object under test fields are null it is not possible to evaluate their types unless in {@link #withStrictTypeChecking() strictTypeChecking mode},
-   * in that case the corresponding expected field's type is evaluated instead but if strictTypeChecking mode is disabled then null fields are not ignored.
+   * The fields are ignored if their types <b>exactly match one of the ignored types</b>, for example,
+   * if a field is a subtype of an ignored type it is not ignored.
+   * <p>
+   * If {@code strictTypeChecking} mode is disabled then null fields are ignored since their types cannot be known.
+   * <p>
+   * If {@code strictTypeChecking} mode is enabled and a field of the object under test is null, the recursive
+   * comparison evaluates the corresponding expected field's type.
    * <p>
    * Example:
    * <pre><code class='java'> class Person {
@@ -839,6 +842,63 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Makes the recursive comparison to ignore the fields of the object under test having types matching one of the given regexes.
+   * The fields are ignored if their types <b>exactly match one of the regexes</b>, if a field is a subtype of a matched type it is not ignored.
+   * <p>
+   * One use case of this method is to ignore types that can't be introspected.
+   * <p>
+   * If {@code strictTypeChecking} mode is enabled and a field of the object under test is null, the recursive
+   * comparison evaluates the corresponding expected field's type (if not null), if it is disabled then the field is evaluated as
+   * usual (i.e. it is not ignored).
+   * <p>
+   * <b>Warning</b>: primitive types are not directly supported because under the hood they are converted to their
+   * corresponding wrapping types, for example {@code int} to {@code java.lang.Integer}. The preferred way to ignore
+   * primitive types is to use {@link #ignoringFieldsOfTypes(Class[])}.
+   * Another way is to ignore the wrapping type, for example ignoring {@code java.lang.Integer} ignores both
+   * {@code java.lang.Integer} and {@code int} fields.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class Person {
+   *   String name;
+   *   double height;
+   *   Home home = new Home();
+   * }
+   *
+   * class Home {
+   *   Address address = new Address();
+   * }
+   *
+   * class Address {
+   *   int number;
+   *   String street;
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", 1.80);
+   * sherlock.home.address.street = "Baker Street";
+   * sherlock.home.address.number = 221;
+   *
+   * Person cherlock = new Person("Cherlock", 1.80);
+   * cherlock.home.address.street = "Butcher Street";
+   * cherlock.home.address.number = 221;
+   *
+   * // assertion succeeds as we ignore Address and height
+   * assertThat(sherlock).usingRecursiveComparison()
+   *                     .ignoringFieldsOfTypes(".*Address", "java\\.util\\.String")
+   *                     .isEqualTo(cherlock);
+   *
+   * // now this assertion fails as expected since the home.address.street fields and name differ
+   * assertThat(sherlock).usingRecursiveComparison()
+   *                     .isEqualTo(cherlock);</code></pre>
+   *
+   * @param regexes regexes specifying the types to ignore.
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   */
+  public RecursiveComparisonAssert<?> ignoringFieldsOfTypesMatchingRegexes(String... regexes) {
+    recursiveComparisonConfiguration.ignoreFieldsOfTypesMatchingRegexes(regexes);
+    return myself;
+  }
+
   /**
    * This method instructs the recursive comparison to compare recursively all fields including the one whose type have overridden equals,
    * <b>except fields with java types</b> (at some point we need to compare something!).
@@ -957,7 +1017,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
 
   /**
    * In case you have instructed the recursive to use overridden {@code equals} with {@link #usingOverriddenEquals()},
-   * this method allows to ignore overridden {@code equals} for the given fields (it adds them to the already registered ones).
+   * this method allows ignoring overridden {@code equals} for the given fields (it adds them to the already registered ones).
    * <p>
    * Since 3.17.0 all overridden {@code equals} so this method is only relevant if you have called {@link #usingOverriddenEquals()} before.
    * <p>
@@ -1022,7 +1082,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
 
   /**
    * By default, the recursive comparison uses overridden {@code equals} methods to compare fields,
-   * this method allows to force a recursive comparison for all fields of the given types (it adds them to the already registered ones).
+   * this method allows forcing a recursive comparison for all fields of the given types (it adds them to the already registered ones).
    * <p>
    * Since 3.17.0 all overridden {@code equals} so this method is only relevant if you have called {@link #usingOverriddenEquals()} before.
    * <p>
@@ -1085,7 +1145,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
 
   /**
    * In case you have instructed the recursive comparison to use overridden {@code equals} with {@link #usingOverriddenEquals()},
-   * this method allows to force a recursive comparison for the fields matching the given regexes (it adds them to the already registered ones).
+   * this method allows forcing a recursive comparison for the fields matching the given regexes (it adds them to the already registered ones).
    * <p>
    * Since 3.17.0 all overridden {@code equals} so this method is only relevant if you have called {@link #usingOverriddenEquals()} before.
    * <p>
@@ -1149,7 +1209,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * Makes the recursive comparison to ignore collection order in all fields in the object under test.
    * <p>
    * <b>Important:</b> ignoring collection order has a high performance cost because each element of the actual collection must
-   * be compared to each element of the expected collection which is a O(n&sup2;) operation. For example with a collection of 100
+   * be compared to each element of the expected collection which is an O(n&sup2;) operation. For example with a collection of 100
    * elements, the number of comparisons is 100x100 = 10 000!
    * <p>
    * Example:
@@ -1339,7 +1399,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Allows to register a {@link BiPredicate} to compare fields with the given locations.
+   * Allows registering a {@link BiPredicate} to compare fields with the given locations.
    * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * BiPredicates specified with this method have precedence over the ones registered with {@link #withEqualsForType(BiPredicate, Class)}
@@ -1386,7 +1446,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Allows to register a {@link BiPredicate} to compare fields whose location matches the given regexes.
+   * Allows registering a {@link BiPredicate} to compare fields whose location matches the given regexes.
    * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * The fields are evaluated from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
@@ -1425,7 +1485,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    *                  .isEqualTo(hugeFrodo);</code></pre>
    *
    * @param equals the {@link BiPredicate} to use to compare the fields matching the given regexes
-   * @param regexes the regexes from the root object of the fields location the BiPredicate should be used for
+   * @param regexes the regexes from the root object of the field locations the BiPredicate should be used for
    *
    * @return this {@link RecursiveComparisonAssert} to chain other methods.
    * @throws NullPointerException if the given BiPredicate is null.
@@ -1437,7 +1497,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Allows to register a comparator to compare fields with the given locations.
+   * Allows registering a comparator to compare fields with the given locations.
    * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * Comparators registered with this method have precedence over comparators registered with {@link #withComparatorForType(Comparator, Class)}
@@ -1483,7 +1543,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Allows to register a comparator to compare the fields with the given type.
+   * Allows registering a comparator to compare the fields with the given type.
    * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * Comparators registered with this method have less precedence than comparators registered with {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)}
@@ -1527,7 +1587,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Allows to register a {@link BiPredicate} to compare the fields with the given type.
+   * Allows registering a {@link BiPredicate} to compare the fields with the given type.
    * A typical usage is to compare double/float fields with a given precision.
    * <p>
    * BiPredicates registered with this method have less precedence than the one registered  with {@link #withEqualsForFields(BiPredicate, String...) withEqualsForFields(BiPredicate, String...)}
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java
index 44ab11d1f..f010fdb5c 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/AbstractRecursiveOperationConfiguration.java
@@ -36,6 +36,7 @@ public abstract class AbstractRecursiveOperationConfiguration {
   private final Set<String> ignoredFields = new LinkedHashSet<>();
   private final List<Pattern> ignoredFieldsRegexes = new ArrayList<>();
   private final Set<Class<?>> ignoredTypes = new LinkedHashSet<>();
+  private final List<Pattern> ignoredTypesRegexes = new ArrayList<>();
 
   protected AbstractRecursiveOperationConfiguration(AbstractBuilder<?> builder) {
     ignoreFields(builder.ignoredFields);
@@ -76,9 +77,7 @@ public abstract class AbstractRecursiveOperationConfiguration {
    * @param regexes regexes used to ignore fields in the comparison.
    */
   public void ignoreFieldsMatchingRegexes(String... regexes) {
-    List<Pattern> patterns = Stream.of(regexes)
-                                   .map(Pattern::compile)
-                                   .collect(toList());
+    List<Pattern> patterns = toPatterns(regexes);
     ignoredFieldsRegexes.addAll(patterns);
   }
 
@@ -92,30 +91,7 @@ public abstract class AbstractRecursiveOperationConfiguration {
    * <p>
    * If some object under test fields are null it is not possible to evaluate their types and thus these fields are not ignored.
    * <p>
-   * Example:
-   * <pre><code class='java'> public class Person {
-   *   String name;
-   *   String occupation;
-   *   Address address = new Address();
-   * }
-   *
-   * public static class Address {
-   *   int number;
-   *   String street;
-   * }
-   *
-   * Person sherlock = new Person("Sherlock", "Detective");
-   * sherlock.address.street = "Baker Street";
-   * sherlock.address.number = 221;
-   *
-   * // assertion succeeds Person has only String fields except for address
-   * assertThat(sherlock).usingRecursiveAssertion()
-   *                     .ignoringFieldsOfTypes(Address.class)
-   *                     .allFieldsSatisfy(field -> field instanceof String);
-   *
-   * // assertion fails because of address and address.number
-   * assertThat(sherlock).usingRecursiveComparison()
-   *                     .allFieldsSatisfy(field -> field instanceof String);</code></pre>
+   * Example: see {@link RecursiveComparisonAssert#ignoringFieldsOfTypes(Class[])}.
    *
    * @param types the types of the object under test to ignore in the comparison.
    */
@@ -123,6 +99,31 @@ public abstract class AbstractRecursiveOperationConfiguration {
     stream(types).map(AbstractRecursiveOperationConfiguration::asWrapperIfPrimitiveType).forEach(ignoredTypes::add);
   }
 
+  /**
+   * Makes the recursive comparison to ignore the fields of the object under test having types matching one of the given regexes.
+   * The fields are ignored if their types <b>exactly match one of the regexes</b>, if a field is a subtype of a matched type it is not ignored.
+   * <p>
+   * One use case of this method is to ignore types that can't be introspected.
+   * <p>
+   * If {@code strictTypeChecking} mode is enabled and a field of the object under test is null, the recursive
+   * comparison evaluates the corresponding expected field's type (if not null), if it is disabled then the field is evaluated as
+   * usual (i.e. it is not ignored).
+   * <p>
+   * <b>Warning</b>: primitive types are not directly supported because under the hood they are converted to their
+   * corresponding wrapping types, for example {@code int} to {@code java.lang.Integer}. The preferred way to ignore
+   * primitive types is to use {@link #ignoreFieldsOfTypes(Class[])}.
+   * Another way is to ignore the wrapping type, for example ignoring {@code java.lang.Integer} ignores both
+   * {@code java.lang.Integer} and {@code int} fields.
+   * <p>
+   * Example: see {@link RecursiveComparisonAssert#ignoringFieldsOfTypesMatchingRegexes(String...)}.
+   *
+   * @param regexes regexes specifying the types to ignore.
+   */
+  public void ignoreFieldsOfTypesMatchingRegexes(String... regexes) {
+    List<Pattern> patterns = toPatterns(regexes);
+    ignoredTypesRegexes.addAll(patterns);
+  }
+
   protected static Class<?> asWrapperIfPrimitiveType(Class<?> type) {
     if (!type.isPrimitive()) return type;
     if (type.equals(boolean.class)) return Boolean.class;
@@ -145,6 +146,15 @@ public abstract class AbstractRecursiveOperationConfiguration {
     return ignoredTypes;
   }
 
+  /**
+   * Returns the regexes that will be used to ignore fields with types matching these regexes in the recursive comparison.
+   *
+   * @return the regexes that will be used to ignore fields with types matching these regexes in the recursive comparison.
+   */
+  public List<Pattern> getIgnoredTypesRegexes() {
+    return ignoredTypesRegexes;
+  }
+
   protected void describeIgnoredFields(StringBuilder description) {
     if (!getIgnoredFields().isEmpty())
       description.append(format("- the following fields were ignored in the comparison: %s%n", describeIgnoredFields()));
@@ -242,4 +252,11 @@ public abstract class AbstractRecursiveOperationConfiguration {
       return thisBuilder;
     }
   }
+
+  private static List<Pattern> toPatterns(String[] regexes) {
+    return Stream.of(regexes)
+                 .map(Pattern::compile)
+                 .collect(toList());
+  }
+
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index b06f688b1..9de354138 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -669,7 +669,8 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     describeComparedTypes(description);
     describeIgnoredFields(description);
     describeIgnoredFieldsRegexes(description);
-    describeIgnoredFieldsForTypes(description);
+    describeIgnoredTypes(description);
+    describeIgnoredTypesRegexes(description);
     describeOverriddenEqualsMethodsUsage(description, representation);
     describeIgnoreCollectionOrder(description);
     describeIgnoredCollectionOrderInFields(description);
@@ -819,11 +820,17 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
       description.append(format("- the comparison was performed on any fields with types: %s%n", describeComparedTypes()));
   }
 
-  private void describeIgnoredFieldsForTypes(StringBuilder description) {
+  private void describeIgnoredTypes(StringBuilder description) {
     if (!getIgnoredTypes().isEmpty())
       description.append(format("- the following types were ignored in the comparison: %s%n", describeIgnoredTypes()));
   }
 
+  private void describeIgnoredTypesRegexes(StringBuilder description) {
+    if (!getIgnoredTypesRegexes().isEmpty())
+      description.append(format("- the types matching the following regexes were ignored in the comparison: %s%n",
+                                describeRegexes(getIgnoredTypesRegexes())));
+  }
+
   protected void describeIgnoreAllActualNullFields(StringBuilder description) {
     if (ignoreAllActualNullFields) description.append(format("- all actual null fields were ignored in the comparison%n"));
   }
@@ -926,15 +933,21 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
 
   private boolean matchesAnIgnoredFieldType(DualValue dualValue) {
     Object actual = dualValue.actual;
-    if (actual != null) return getIgnoredTypes().contains(actual.getClass());
+    if (actual != null) return matchesAnIgnoredType(actual);
     Object expected = dualValue.expected;
     // actual is null => we can't evaluate its type, we can only reliably check dualValue.expected's type if
     // strictTypeChecking is enabled which guarantees expected is of the same type.
-    if (strictTypeChecking && expected != null) return getIgnoredTypes().contains(expected.getClass());
+    if (strictTypeChecking && expected != null) return matchesAnIgnoredType(expected);
     // if strictTypeChecking is disabled, we can't safely ignore the field (if we did, we would ignore all null fields!).
     return false;
   }
 
+  private boolean matchesAnIgnoredType(Object actual) {
+    Class<?> actualType = actual.getClass();
+    return getIgnoredTypes().contains(actualType)
+           || getIgnoredTypesRegexes().stream().anyMatch(regex -> regex.matcher(actualType.getName()).matches());
+  }
+
   private void registerFieldLocationOfFieldsOfTypesToCompare(DualValue dualValue) {
     if (comparedTypes.isEmpty()) return;
     // We check actual type against the types to compare or expected type in case actual was null assuming expected
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
index 72bcaa990..cc68061f5 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
@@ -144,6 +144,19 @@ class RecursiveComparisonAssert_fluent_API_Test {
     assertThat(configuration.getIgnoredTypes()).containsExactly(type1, type2);
   }
 
+  @Test
+  void should_allow_to_ignore_fields_whose_type_matched_the_given_regexes() {
+    // GIVEN
+    String regex1 = "foo.*";
+    String regex2 = ".*bar";
+    // WHEN
+    RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
+                                                                       .ignoringFieldsOfTypesMatchingRegexes(regex1, regex2)
+                                                                       .getRecursiveComparisonConfiguration();
+    // THEN
+    then(configuration.getIgnoredTypesRegexes()).extracting(Pattern::toString).containsExactly(regex1, regex2);
+  }
+
   @Test
   void should_allow_to_ignore_overridden_equals_for_fields() {
     // GIVEN
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFieldsOfTypesMatchingRegexes_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFieldsOfTypesMatchingRegexes_Test.java
new file mode 100644
index 000000000..c6845937c
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFieldsOfTypesMatchingRegexes_Test.java
@@ -0,0 +1,226 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2024 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.test.ObjectArrays.arrayOf;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Sets.newHashSet;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
+import org.assertj.core.internal.objects.data.Human;
+import org.assertj.core.internal.objects.data.Person;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@SuppressWarnings("unused")
+class RecursiveComparisonAssert_isEqualTo_ignoringFieldsOfTypesMatchingRegexes_Test
+    extends RecursiveComparisonAssert_isEqualTo_BaseTest {
+
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1} / ignored types={3}")
+  @MethodSource
+  void should_pass_when_fields_whose_types_match_given_regexes_are_ignored(Object actual,
+                                                                           Object expected,
+                                                                           List<String> regexes,
+                                                                           @SuppressWarnings("unused") String testDescription) {
+    assertThat(actual).usingRecursiveComparison()
+                      .ignoringFieldsOfTypesMatchingRegexes(arrayOf(regexes))
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_pass_when_fields_whose_types_match_given_regexes_are_ignored() {
+    Person person1 = new Person("John");
+    person1.home.address.number = 1;
+
+    Person person2 = new Person("Jack");
+    person2.home.address.number = 1;
+
+    Person person3 = new Person("John");
+    person3.dateOfBirth = new Date(123);
+
+    Human person4 = new Human();
+    person4.name = "Jack";
+    person4.dateOfBirth = new Date(456);
+
+    Person person5 = new Person();
+    person5.home.address.number = 1;
+
+    Person person6 = new Person();
+    person6.home.address.number = 2;
+
+    return Stream.of(arguments(person1, person2, list("java.*String"),
+                               "same data and type, except for String"),
+                     arguments(person3, person4, list(".*lang\\.String", "java\\.util\\.Date"),
+                               "same data, different type, except for String and Date"),
+                     arguments(person5, person6, list("org\\.assertj\\.core\\.internal\\.objects\\.data.*"),
+                               "same data except for one an assertj internal type"),
+                     arguments(person5, person6, list(".*Integer"),
+                               "primitive types can only be ignored if specifying their corresponding wrapper types"));
+  }
+
+  @Test
+  void should_fail_when_actual_differs_from_expected_even_when_some_fields_are_ignored_for_types() {
+    // GIVEN
+    Person actual = new Person("John");
+    actual.id = OptionalLong.of(123);
+    actual.age = OptionalInt.of(30);
+    actual.home.address.number = 1;
+    actual.neighbour = new Person("Jack");
+    actual.neighbour.home.address.number = 123;
+    actual.neighbour.neighbour = new Person("James");
+    actual.neighbour.neighbour.age = OptionalInt.of(40);
+
+    Person expected = new Person("Jack");
+    expected.id = OptionalLong.of(456);
+    expected.age = OptionalInt.of(50);
+    expected.home.address.number = 2;
+    expected.neighbour = new Person("Jim");
+    expected.neighbour.home.address.number = 456;
+    expected.neighbour.neighbour = new Person("James");
+    expected.neighbour.neighbour.age = OptionalInt.of(60);
+
+    recursiveComparisonConfiguration.ignoreFieldsOfTypesMatchingRegexes(".*lang\\.String",
+                                                                        "org\\.assertj.*data\\.Address",
+                                                                        "java\\.util\\.OptionalI.*");
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, diff("id", actual.id, expected.id));
+  }
+
+  static class NumberHolder {
+    private final Number number;
+
+    NumberHolder(final Number number) {
+      this.number = number;
+    }
+
+    public Number getNumber() {
+      return number;
+    }
+
+    @Override
+    public String toString() {
+      return number.toString();
+    }
+  }
+
+  @Test
+  void should_pass_when_fields_with_given_types_are_ignored_on_unordered_collections() {
+
+    class WithNumberHolderCollection {
+      private final Collection<NumberHolder> holders;
+
+      WithNumberHolderCollection(Collection<NumberHolder> holders) {
+        this.holders = holders;
+      }
+
+      Collection<NumberHolder> getNumberHolders() {
+        return holders;
+      }
+    }
+
+    // GIVEN
+    final Number intValue = 12;
+    final Double doubleValueA = 12.34;
+    final Double doubleValueB = 56.78;
+    final List<NumberHolder> holdersA = list(new NumberHolder(intValue), new NumberHolder(doubleValueA));
+    final List<NumberHolder> holdersB = list(new NumberHolder(intValue), new NumberHolder(doubleValueB));
+    WithNumberHolderCollection actual = new WithNumberHolderCollection(newHashSet(holdersA));
+
+    recursiveComparisonConfiguration.ignoreFieldsOfTypesMatchingRegexes(".*NumberHolder");
+
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .isEqualTo(new WithNumberHolderCollection(newHashSet(holdersB)));
+    // bonus check also ordered collection
+    actual = new WithNumberHolderCollection(new ArrayList<>(holdersA));
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .isEqualTo(new WithNumberHolderCollection(new ArrayList<>(holdersB)));
+  }
+
+  @Test
+  void should_pass_when_fields_with_given_types_are_ignored_on_unordered_maps() {
+    class WithNumberHolderMap {
+      private final Map<String, NumberHolder> holders;
+
+      WithNumberHolderMap(NumberHolder... holders) {
+        this.holders = new HashMap<>();
+        for (int i = 0; i < holders.length; i++) {
+          this.holders.put("key " + i, holders[i]);
+        }
+      }
+
+      Map<String, NumberHolder> getNumberHoldersMap() {
+        return holders;
+      }
+    }
+
+    // GIVEN
+    final Number intValue = 12;
+    final Double doubleValueA = 12.34;
+    final Double doubleValueB = 56.78;
+    final NumberHolder[] holdersA = array(new NumberHolder(intValue), new NumberHolder(doubleValueA));
+    final NumberHolder[] holdersB = array(new NumberHolder(intValue), new NumberHolder(doubleValueB));
+    recursiveComparisonConfiguration.ignoreFieldsOfTypesMatchingRegexes(".*NumberHolder");
+    // WHEN/THEN
+    then(new WithNumberHolderMap(holdersA)).usingRecursiveComparison(recursiveComparisonConfiguration)
+                                           .isEqualTo(new WithNumberHolderMap(holdersB));
+  }
+
+  @Test
+  void does_not_support_ignoring_primitive_types_but_only_their_wrapper_types() {
+    // GIVEN
+    Person actual = new Person("John");
+    actual.home.address.number = 1;
+    Person expected = new Person("John");
+    expected.home.address.number = 2;
+    recursiveComparisonConfiguration.ignoreFieldsOfTypesMatchingRegexes("int");
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected,
+                                                              diff("home.address.number",
+                                                                   actual.home.address.number,
+                                                                   expected.home.address.number));
+  }
+
+  @Test
+  void evaluates_expected_when_actual_field_is_null_and_strict_type_checking_is_enabled() {
+    // GIVEN
+    Person actual = new Person("John");
+    actual.home = null;
+    Person expected = new Person("John");
+    expected.home.address.number = 123;
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .ignoringFieldsOfTypesMatchingRegexes(".*Home")
+                .withStrictTypeChecking()
+                .isEqualTo(expected);
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
index a7ddbf989..26e38544d 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
@@ -137,10 +137,6 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
 
     Person person4 = new Person("John");
     person4.home.address.number = 1;
-    person4.phone = null;
-    person4.age = null;
-    person4.id = null;
-    person4.weight = null;
 
     return Stream.of(arguments(person1, person2, "same data and same type except for actual empty optional fields"),
                      arguments(person1, person3, "same data, same type, both actual and expected have empty optional fields"),
@@ -534,15 +530,13 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
     final List<NumberHolder> holdersA = list(new NumberHolder(intValue), new NumberHolder(doubleValueA));
     final List<NumberHolder> holdersB = list(new NumberHolder(intValue), new NumberHolder(doubleValueB));
     WithNumberHolderCollection actual = new WithNumberHolderCollection(newHashSet(holdersA));
-    final RecursiveComparisonConfiguration configurationIgnoringNumberHolder = RecursiveComparisonConfiguration.builder()
-                                                                                                               .withIgnoredFieldsOfTypes(NumberHolder.class)
-                                                                                                               .build();
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(NumberHolder.class);
     // WHEN/THEN
-    then(actual).usingRecursiveComparison(configurationIgnoringNumberHolder)
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
                 .isEqualTo(new WithNumberHolderCollection(newHashSet(holdersB)));
     // bonus check also ordered collection
     actual = new WithNumberHolderCollection(new ArrayList<>(holdersA));
-    then(actual).usingRecursiveComparison(configurationIgnoringNumberHolder)
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
                 .isEqualTo(new WithNumberHolderCollection(new ArrayList<>(holdersB)));
   }
 
@@ -569,11 +563,9 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
     final Double doubleValueB = 56.78;
     final NumberHolder[] holdersA = array(new NumberHolder(intValue), new NumberHolder(doubleValueA));
     final NumberHolder[] holdersB = array(new NumberHolder(intValue), new NumberHolder(doubleValueB));
-    final RecursiveComparisonConfiguration configurationIgnoringNumberHolder = RecursiveComparisonConfiguration.builder()
-                                                                                                               .withIgnoredFieldsOfTypes(NumberHolder.class)
-                                                                                                               .build();
+    recursiveComparisonConfiguration.ignoreFieldsOfTypes(NumberHolder.class);
     // WHEN/THEN
-    then(new WithNumberHolderMap(holdersA)).usingRecursiveComparison(configurationIgnoringNumberHolder)
+    then(new WithNumberHolderMap(holdersA)).usingRecursiveComparison(recursiveComparisonConfiguration)
                                            .isEqualTo(new WithNumberHolderMap(holdersB));
   }
 
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index 93752e735..7c9e608ad 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -101,6 +101,17 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     then(multiLineDescription).contains(format("- the following types were ignored in the comparison: java.util.UUID, java.time.ZonedDateTime%n"));
   }
 
+  @Test
+  void should_show_the_regexes_used_to_ignore_fields_of_types() {
+    // GIVEN
+    recursiveComparisonConfiguration.ignoreFieldsOfTypesMatchingRegexes("java\\.util\\.concurrent\\.locks\\.Reentrant.*Lock",
+                                                                        "java\\.util\\.function\\.ToLong.*");
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    then(multiLineDescription).contains(format("- the types matching the following regexes were ignored in the comparison: java\\.util\\.concurrent\\.locks\\.Reentrant.*Lock, java\\.util\\.function\\.ToLong.*%n"));
+  }
+
   @Test
   void should_show_the_ignored_all_overridden_equals_methods_flag() {
     // GIVEN
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
index 86b5544c9..9c81d4371 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static java.util.UUID.randomUUID;
+import static java.util.concurrent.CompletableFuture.completedFuture;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.recursive.comparison.DualValueUtil.dualValueWithPath;
 import static org.assertj.core.api.recursive.comparison.DualValueUtil.randomPath;
@@ -27,6 +28,8 @@ import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
 import java.util.UUID;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.concurrent.locks.ReentrantReadWriteLock;
 import java.util.stream.Stream;
 
 import org.junit.jupiter.api.BeforeEach;
@@ -282,6 +285,22 @@ class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
     then(ignored).isTrue();
   }
 
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1} / ignored types={3}")
+  @MethodSource
+  void should_be_able_to_ignore_concurrent_types_by_regex(Object value) {
+    // GIVEN
+    DualValue dualValue = new DualValue(randomPath(), value, null);
+    recursiveComparisonConfiguration.ignoreFieldsOfTypesMatchingRegexes("java\\.util\\.concurrent\\..*");
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldIgnore(dualValue);
+    // THEN
+    then(ignored).isTrue();
+  }
+
+  private static Stream<Object> should_be_able_to_ignore_concurrent_types_by_regex() {
+    return Stream.of(new ReentrantReadWriteLock(), new ReentrantLock(), completedFuture("done"));
+  }
+
   @Test
   void should_be_able_to_ignore_float() {
     // GIVEN
diff --git a/assertj-core/src/test/java/org/assertj/core/test/ObjectArrays.java b/assertj-core/src/test/java/org/assertj/core/test/ObjectArrays.java
index 46f6d1c64..07320d589 100644
--- a/assertj-core/src/test/java/org/assertj/core/test/ObjectArrays.java
+++ b/assertj-core/src/test/java/org/assertj/core/test/ObjectArrays.java
@@ -12,6 +12,8 @@
  */
 package org.assertj.core.test;
 
+import java.util.List;
+
 /**
  * @author Alex Ruiz
  */
@@ -22,6 +24,10 @@ public final class ObjectArrays {
     return values;
   }
 
+  public static String[] arrayOf(List<String> list) {
+    return list.toArray(new String[0]);
+  }
+
   public static Object[] emptyArray() {
     return EMPTY;
   }
