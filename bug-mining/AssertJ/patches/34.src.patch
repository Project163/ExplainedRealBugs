diff --git a/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java b/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
index 020f8d861..91f7435d6 100644
--- a/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractCharSequenceAssert.java
@@ -347,9 +347,9 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).doesNotMatch(&quot;..o.o&quot;);
    * </pre>
-   * 
+   *
    * </p>
-   * 
+   *
    * @param regex the regular expression to which the actual {@code CharSequence} is to be matched.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given pattern is {@code null}.
@@ -366,17 +366,17 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * Verifies that the actual {@code CharSequence} matches the given regular expression.
    * <p>
    * Example :
-   * 
+   *
    * <pre>
    * // assertion will pass
    * assertThat(&quot;Frodo&quot;).matches(Pattern.compile(&quot;..o.o&quot;));
-   * 
+   *
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).matches(Pattern.compile(&quot;.*d&quot;));
    * </pre>
-   * 
+   *
    * </p>
-   * 
+   *
    * @param pattern the regular expression to which the actual {@code CharSequence} is to be matched.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given pattern is {@code null}.
@@ -392,7 +392,7 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * Verifies that the actual {@code CharSequence} does not match the given regular expression.
    * <p>
    * Example :
-   * 
+   *
    * <pre>
    * // assertion will pass
    * assertThat(&quot;Frodo&quot;).doesNotMatch(Pattern.compile(&quot;.*d&quot;));
@@ -400,9 +400,9 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
    * // assertion will fail
    * assertThat(&quot;Frodo&quot;).doesNotMatch(Pattern.compile(&quot;..o.o&quot;));
    * </pre>
-   * 
+   *
    * </p>
-   * 
+   *
    * @param pattern the regular expression to which the actual {@code CharSequence} is to be matched.
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given pattern is {@code null}.
@@ -413,6 +413,57 @@ public abstract class AbstractCharSequenceAssert<S extends AbstractCharSequenceA
     return myself;
   }
 
+  /**
+   * Verifies that the actual {@code CharSequence} is equal to the given XML {@code CharSequence} after both have been formatted the same way.
+   * <p>
+   * Example :
+   * </p>
+   *
+   * <pre>
+   * String expectedXml =
+   *     &quot;&lt;rings&gt;\n&quot; +
+   *     &quot;  &lt;bearer&gt;\n&quot; +
+   *     &quot;    &lt;name&gt;Frodo&lt;/name&gt;\n&quot; +
+   *     &quot;    &lt;ring&gt;\n&quot; +
+   *     &quot;      &lt;name&gt;one ring&lt;/name&gt;\n&quot; +
+   *     &quot;      &lt;createdBy&gt;Sauron&lt;/createdBy&gt;\n&quot; +
+   *     &quot;    &lt;/ring&gt;\n&quot; +
+   *     &quot;  &lt;/bearer&gt;\n&quot; +
+   *     &quot;&lt;/rings&gt;&quot;;
+   *
+   * // Whatever how formatted your xml string is, isXmlEqualTo assertion is able to compare it with another xml String.
+   * String oneLineXml = &quot;&lt;rings&gt;&lt;bearer&gt;&lt;name&gt;Frodo&lt;/name&gt;&lt;ring&gt;&lt;name&gt;one ring&lt;/name&gt;&lt;createdBy&gt;Sauron&lt;/createdBy&gt;&lt;/ring&gt;&lt;/bearer&gt;&lt;/rings&gt;&quot;;
+   * assertThat(oneLineXml).isXmlEqualTo(expectedXml);
+   *
+   * String xmlWithNewLine =
+   *     &quot;&lt;rings&gt;\n&quot; +
+   *     &quot;&lt;bearer&gt;   \n&quot; +
+   *     &quot;  &lt;name&gt;Frodo&lt;/name&gt;\n&quot; +
+   *     &quot;  &lt;ring&gt;\n&quot; +
+   *     &quot;    &lt;name&gt;one ring&lt;/name&gt;\n&quot; +
+   *     &quot;    &lt;createdBy&gt;Sauron&lt;/createdBy&gt;\n&quot; +
+   *     &quot;  &lt;/ring&gt;\n&quot; +
+   *     &quot;&lt;/bearer&gt;\n&quot; +
+   *     &quot;&lt;/rings&gt;&quot;;
+   * assertThat(xmlWithNewLine).isXmlEqualTo(expectedXml);
+   *
+   * // You can compare it with oneLineXml
+   * assertThat(xmlWithNewLine).isXmlEqualTo(oneLineXml);
+   *
+   * // Tip : use Assertions.contentOf to compare your XML String with the content of an XML file.
+   * assertThat(oneLineXml).isXmlEqualTo(contentOf(new File(&quot;src/test/resources/formatted.xml&quot;)));
+   * </pre>
+   *
+   * @param expectedXml the XML {@code CharSequence} to which the actual {@code CharSequence} is to be compared to.
+   * @return {@code this} assertion object to chain other assertions.
+   * @throws NullPointerException if the given {@code CharSequence} is {@code null}.
+   * @throws AssertionError if the actual {@code CharSequence} is {@code null} or is not the same XML as the given XML {@code CharSequence}.
+   */
+  public S isXmlEqualTo(CharSequence expectedXml) {
+    strings.assertXmlEqualsTo(info, actual, expectedXml);
+    return myself;
+  }
+
   /**
    * Do not use this method.
    * 
diff --git a/src/main/java/org/assertj/core/internal/Strings.java b/src/main/java/org/assertj/core/internal/Strings.java
index ee7b1d803..8e21885cb 100644
--- a/src/main/java/org/assertj/core/internal/Strings.java
+++ b/src/main/java/org/assertj/core/internal/Strings.java
@@ -15,6 +15,7 @@
 package org.assertj.core.internal;
 
 import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
+import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
 import static org.assertj.core.error.ShouldBeEqualIgnoringCase.shouldBeEqual;
 import static org.assertj.core.error.ShouldBeNullOrEmpty.shouldBeNullOrEmpty;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
@@ -22,8 +23,6 @@ import static org.assertj.core.error.ShouldContainCharSequence.shouldContainIgno
 import static org.assertj.core.error.ShouldContainCharSequenceOnlyOnce.shouldContainOnlyOnce;
 import static org.assertj.core.error.ShouldContainCharSequenceSequence.shouldContainSequence;
 import static org.assertj.core.error.ShouldEndWith.shouldEndWith;
-import static org.assertj.core.error.ShouldHaveSameSizeAs.shouldHaveSameSizeAs;
-import static org.assertj.core.error.ShouldHaveSize.shouldHaveSize;
 import static org.assertj.core.error.ShouldMatchPattern.shouldMatch;
 import static org.assertj.core.error.ShouldNotBeEmpty.shouldNotBeEmpty;
 import static org.assertj.core.error.ShouldNotContainCharSequence.shouldNotContain;
@@ -33,7 +32,7 @@ import static org.assertj.core.internal.CommonErrors.arrayOfValuesToLookForIsEmp
 import static org.assertj.core.internal.CommonErrors.arrayOfValuesToLookForIsNull;
 import static org.assertj.core.internal.CommonValidations.checkSizes;
 import static org.assertj.core.internal.CommonValidations.hasSameSizeAsCheck;
-import static org.assertj.core.util.Iterables.sizeOf;
+import static org.assertj.core.util.xml.XmlStringPrettyFormatter.xmlPrettyFormat;
 
 import java.util.Comparator;
 import java.util.LinkedHashSet;
@@ -42,6 +41,7 @@ import java.util.regex.Pattern;
 import java.util.regex.PatternSyntaxException;
 
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.error.ShouldBeEqual;
 import org.assertj.core.util.VisibleForTesting;
 
 /**
@@ -55,6 +55,9 @@ import org.assertj.core.util.VisibleForTesting;
 public class Strings {
 
   private static final Strings INSTANCE = new Strings();
+  private final ComparisonStrategy comparisonStrategy;
+  @VisibleForTesting
+  Failures failures = Failures.instance();
 
   /**
    * Returns the singleton instance of this class based on {@link StandardComparisonStrategy}.
@@ -65,16 +68,11 @@ public class Strings {
     return INSTANCE;
   }
 
-  @VisibleForTesting
-  Failures failures = Failures.instance();
-
   @VisibleForTesting
   Strings() {
     this(StandardComparisonStrategy.instance());
   }
 
-  private final ComparisonStrategy comparisonStrategy;
-
   public Strings(ComparisonStrategy comparisonStrategy) {
     this.comparisonStrategy = comparisonStrategy;
   }
@@ -197,14 +195,15 @@ public class Strings {
     assertNotNull(info, actual);
     checkIsNotNull(values);
     checkIsNotEmpty(values);
-    checkSequenceIsNotNull(values[0]);
+    checkCharSequenceIsNotNull(values[0]);
     Set<CharSequence> notFound = new LinkedHashSet<CharSequence>();
     for (CharSequence value : values) {
       if (!stringContains(actual, value)) {
         notFound.add(value);
       }
     }
-    if (notFound.isEmpty()) return;
+    if (notFound.isEmpty())
+      return;
     if (notFound.size() == 1 && values.length == 1) {
       throw failures.failure(info, shouldContain(actual, values[0], comparisonStrategy));
     }
@@ -241,7 +240,7 @@ public class Strings {
    * @throws AssertionError if the actual {@code CharSequence} does not contain the given sequence.
    */
   public void assertContainsIgnoringCase(AssertionInfo info, CharSequence actual, CharSequence sequence) {
-    checkSequenceIsNotNull(sequence);
+    checkCharSequenceIsNotNull(sequence);
     assertNotNull(info, actual);
     if (actual.toString().toLowerCase().contains(sequence.toString().toLowerCase())) {
       return;
@@ -260,7 +259,7 @@ public class Strings {
    * @throws AssertionError if the actual {@code CharSequence} contains the given sequence.
    */
   public void assertDoesNotContain(AssertionInfo info, CharSequence actual, CharSequence sequence) {
-    checkSequenceIsNotNull(sequence);
+    checkCharSequenceIsNotNull(sequence);
     assertNotNull(info, actual);
     if (!stringContains(actual, sequence)) {
       return;
@@ -268,9 +267,9 @@ public class Strings {
     throw failures.failure(info, shouldNotContain(actual, sequence, comparisonStrategy));
   }
 
-  private void checkSequenceIsNotNull(CharSequence sequence) {
+  private void checkCharSequenceIsNotNull(CharSequence sequence) {
     if (sequence == null) {
-      throw new NullPointerException("The sequence to look for should not be null");
+      throw new NullPointerException("The char sequence to look for should not be null");
     }
   }
 
@@ -308,13 +307,13 @@ public class Strings {
    *           {@code CharSequence}.
    */
   public void assertContainsOnlyOnce(AssertionInfo info, CharSequence actual, CharSequence sequence) {
-    checkSequenceIsNotNull(sequence);
+    checkCharSequenceIsNotNull(sequence);
     assertNotNull(info, actual);
     int sequenceOccurencesInActual = countOccurences(sequence, actual);
     if (sequenceOccurencesInActual == 1)
       return;
     throw failures.failure(info,
-                           shouldContainOnlyOnce(actual, sequence, sequenceOccurencesInActual, comparisonStrategy));
+        shouldContainOnlyOnce(actual, sequence, sequenceOccurencesInActual, comparisonStrategy));
   }
 
   /**
@@ -478,10 +477,11 @@ public class Strings {
     assertNotNull(info, actual);
     checkIsNotNull(values);
     checkIsNotEmpty(values);
-    checkSequenceIsNotNull(values[0]);
+    checkCharSequenceIsNotNull(values[0]);
     Set<CharSequence> notFound = new LinkedHashSet<CharSequence>();
     for (CharSequence value : values) {
-      if (!stringContains(actual, value)) notFound.add(value);
+      if (!stringContains(actual, value))
+        notFound.add(value);
     }
     if (notFound.isEmpty()) {
       if (values.length == 1) {
@@ -503,4 +503,16 @@ public class Strings {
     }
     throw failures.failure(info, shouldContain(actual, values, notFound, comparisonStrategy));
   }
+
+  public void assertXmlEqualsTo(AssertionInfo info, CharSequence actualXml, CharSequence expectedXml) {
+    // check that actual and expected XML CharSequence are not null.
+    // we consider that null values don't make much sense when you want to compare XML document as String/CharSequence.
+    checkCharSequenceIsNotNull(expectedXml);
+    assertNotNull(info, actualXml);
+    // we only use default comparison strategy, it does not make sense to use a specific comparison strategy
+    final String formattedActualXml = xmlPrettyFormat(actualXml.toString());
+    final String formattedExpectedXml = xmlPrettyFormat(expectedXml.toString());
+    if (!comparisonStrategy.areEqual(formattedActualXml, formattedExpectedXml))
+      throw failures.failure(info, shouldBeEqual(formattedActualXml, formattedExpectedXml, comparisonStrategy));
+  }
 }
diff --git a/src/main/java/org/assertj/core/util/xml/XmlStringPrettyFormatter.java b/src/main/java/org/assertj/core/util/xml/XmlStringPrettyFormatter.java
new file mode 100644
index 000000000..d126a2052
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/xml/XmlStringPrettyFormatter.java
@@ -0,0 +1,67 @@
+package org.assertj.core.util.xml;
+
+import java.io.StringReader;
+import java.io.StringWriter;
+import java.io.Writer;
+
+import javax.xml.parsers.DocumentBuilder;
+import javax.xml.parsers.DocumentBuilderFactory;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.bootstrap.DOMImplementationRegistry;
+import org.w3c.dom.ls.DOMImplementationLS;
+import org.w3c.dom.ls.LSOutput;
+import org.w3c.dom.ls.LSSerializer;
+import org.xml.sax.InputSource;
+
+/**
+ * Format an XML String with indent = 2 space.
+ * <p>
+ * Very much inspired by http://stackoverflow.com/questions/139076/how-to-pretty-print-xml-from-java and
+ * http://pastebin.com/XL7932aC
+ * </p>
+ */
+public class XmlStringPrettyFormatter {
+
+  private static final String FORMAT_ERROR = "Unable to format XML string";
+
+  public static String xmlPrettyFormat(String xmlStringToFormat) {
+    if (xmlStringToFormat == null)
+      throw new IllegalArgumentException("Expecting XML String not to be null");
+    // convert String to an XML Document and then back to String but prettily formatted.
+    return prettyFormat(toXmlDocument(xmlStringToFormat), xmlStringToFormat.startsWith("<?xml"));
+  }
+
+  private static String prettyFormat(Document document, boolean keepXmlDeclaration) {
+
+    try {
+      DOMImplementationRegistry registry = DOMImplementationRegistry.newInstance();
+      DOMImplementationLS domImplementation = (DOMImplementationLS) registry.getDOMImplementation("LS");
+      Writer stringWriter = new StringWriter();
+      LSOutput formattedOutput = domImplementation.createLSOutput();
+      formattedOutput.setCharacterStream(stringWriter);
+      LSSerializer domSerializer = domImplementation.createLSSerializer();
+      domSerializer.getDomConfig().setParameter("format-pretty-print", true);
+      // Set this to true if the declaration is needed to be in the output.
+      domSerializer.getDomConfig().setParameter("xml-declaration", keepXmlDeclaration);
+      domSerializer.write(document, formattedOutput);
+      return stringWriter.toString();
+    } catch (Exception e) {
+      throw new RuntimeException(FORMAT_ERROR, e);
+    }
+  }
+
+  private static Document toXmlDocument(String xmlString) {
+    try {
+      InputSource xmlInputSource = new InputSource(new StringReader(xmlString));
+      DocumentBuilder xmlDocumentBuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();
+      return xmlDocumentBuilder.parse(xmlInputSource);
+    } catch (Exception e) {
+      throw new RuntimeException(FORMAT_ERROR, e);
+    }
+  }
+
+  private XmlStringPrettyFormatter() {
+    // utility class
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isXmlEqualTo_Test.java b/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isXmlEqualTo_Test.java
new file mode 100644
index 000000000..4613a22ea
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/charsequence/CharSequenceAssert_isXmlEqualTo_Test.java
@@ -0,0 +1,39 @@
+/*
+ * Created on Dec 24, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
+ * License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
+ * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
+ * governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.api.charsequence;
+
+import org.assertj.core.api.CharSequenceAssert;
+import org.assertj.core.api.CharSequenceAssertBaseTest;
+
+import static org.mockito.Mockito.verify;
+
+
+/**
+ * Tests for <code>{@link org.assertj.core.api.CharSequenceAssert#isXmlEqualTo(CharSequence)}</code>.
+ *
+ * @author Joel Costigliola
+ */
+public class CharSequenceAssert_isXmlEqualTo_Test extends CharSequenceAssertBaseTest {
+
+  @Override
+  protected CharSequenceAssert invoke_api_method() {
+    return assertions.isXmlEqualTo("<jedi>yoda</jedi>");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(strings).assertXmlEqualsTo(getInfo(assertions), getActual(assertions), "<jedi>yoda</jedi>");
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsIgnoringCase_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsIgnoringCase_Test.java
index cd9cfe8e8..011ba4d40 100644
--- a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsIgnoringCase_Test.java
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsIgnoringCase_Test.java
@@ -15,7 +15,7 @@
 package org.assertj.core.internal.strings;
 
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContainIgnoringCase;
-import static org.assertj.core.test.ErrorMessages.sequenceToLookForIsNull;
+import static org.assertj.core.test.ErrorMessages.charSequenceToLookForIsNull;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
@@ -51,7 +51,7 @@ public class Strings_assertContainsIgnoringCase_Test extends StringsBaseTest {
 
   @Test
   public void should_throw_error_if_sequence_is_null() {
-    thrown.expectNullPointerException(sequenceToLookForIsNull());
+    thrown.expectNullPointerException(charSequenceToLookForIsNull());
     strings.assertContainsIgnoringCase(someInfo(), "Yoda", null);
   }
 
@@ -85,7 +85,7 @@ public class Strings_assertContainsIgnoringCase_Test extends StringsBaseTest {
 
   @Test
   public void should_throw_error_if_sequence_is_null_whatever_custom_comparison_strategy_is() {
-    thrown.expectNullPointerException(sequenceToLookForIsNull());
+    thrown.expectNullPointerException(charSequenceToLookForIsNull());
     stringsWithCaseInsensitiveComparisonStrategy.assertContainsIgnoringCase(someInfo(), "Yoda", null);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsOnlyOnce_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsOnlyOnce_Test.java
index 643860a0d..7dd8d2024 100644
--- a/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsOnlyOnce_Test.java
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsOnlyOnce_Test.java
@@ -1,7 +1,7 @@
 package org.assertj.core.internal.strings;
 
 import static org.assertj.core.error.ShouldContainCharSequenceOnlyOnce.shouldContainOnlyOnce;
-import static org.assertj.core.test.ErrorMessages.sequenceToLookForIsNull;
+import static org.assertj.core.test.ErrorMessages.charSequenceToLookForIsNull;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
@@ -63,7 +63,7 @@ public class Strings_assertContainsOnlyOnce_Test extends StringsBaseTest {
 
   @Test
   public void should_throw_error_if_sequence_is_null() {
-    thrown.expectNullPointerException(sequenceToLookForIsNull());
+    thrown.expectNullPointerException(charSequenceToLookForIsNull());
     strings.assertContainsOnlyOnce(someInfo(), "Yoda", null);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertContains_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertContains_Test.java
index 4504027ae..c0783c09e 100644
--- a/src/test/java/org/assertj/core/internal/strings/Strings_assertContains_Test.java
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertContains_Test.java
@@ -15,7 +15,7 @@
 package org.assertj.core.internal.strings;
 
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
-import static org.assertj.core.test.ErrorMessages.sequenceToLookForIsNull;
+import static org.assertj.core.test.ErrorMessages.charSequenceToLookForIsNull;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.Arrays.array;
@@ -64,7 +64,7 @@ public class Strings_assertContains_Test extends StringsBaseTest {
 
   @Test
   public void should_throw_error_if_sequence_is_null() {
-    thrown.expectNullPointerException(sequenceToLookForIsNull());
+    thrown.expectNullPointerException(charSequenceToLookForIsNull());
     strings.assertContains(someInfo(), "Yoda", (String) null);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertDoesNotContain_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertDoesNotContain_Test.java
index eba204236..8a066422f 100644
--- a/src/test/java/org/assertj/core/internal/strings/Strings_assertDoesNotContain_Test.java
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertDoesNotContain_Test.java
@@ -15,7 +15,7 @@
 package org.assertj.core.internal.strings;
 
 import static org.assertj.core.error.ShouldNotContainCharSequence.shouldNotContain;
-import static org.assertj.core.test.ErrorMessages.sequenceToLookForIsNull;
+import static org.assertj.core.test.ErrorMessages.charSequenceToLookForIsNull;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
@@ -50,7 +50,7 @@ public class Strings_assertDoesNotContain_Test extends StringsBaseTest {
 
   @Test
   public void should_throw_error_if_sequence_is_null() {
-    thrown.expectNullPointerException(sequenceToLookForIsNull());
+    thrown.expectNullPointerException(charSequenceToLookForIsNull());
     strings.assertDoesNotContain(someInfo(), "Yoda", null);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/strings/Strings_assertIsXmlEqualCase_Test.java b/src/test/java/org/assertj/core/internal/strings/Strings_assertIsXmlEqualCase_Test.java
new file mode 100644
index 000000000..cbd24903a
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/strings/Strings_assertIsXmlEqualCase_Test.java
@@ -0,0 +1,92 @@
+/*
+ * Created on Dec 24, 2010
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2010-2011 the original author or authors.
+ */
+package org.assertj.core.internal.strings;
+
+import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.xml.XmlStringPrettyFormatter.xmlPrettyFormat;
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.StringsBaseTest;
+import org.junit.Test;
+
+/**
+ * Tests for
+ * <code>{@link org.assertj.core.internal.Strings#assertXmlEqualsTo(org.assertj.core.api.AssertionInfo, CharSequence, CharSequence)}</code>
+ * .
+ * 
+ * @author Joel Costigliola
+ */
+public class Strings_assertIsXmlEqualCase_Test extends StringsBaseTest {
+
+  @Test
+  public void should_pass_if_both_Strings_are_XML_equals() {
+    String actual = "<rss version=\"2.0\"><channel>  <title>Java Tutorials and Examples 1</title>  <language>en-us</language></channel></rss>";
+    String expected = "<rss version=\"2.0\">\n"
+        + "<channel><title>Java Tutorials and Examples 1</title><language>en-us</language></channel>\n" + "</rss>";
+    strings.assertXmlEqualsTo(someInfo(), actual, expected);
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    thrown.expectAssertionError(actualIsNull());
+    strings.assertXmlEqualsTo(someInfo(), null, "<jedi>yoda</jedi>");
+  }
+
+  @Test
+  public void should_fail_if_expected_is_null() {
+    thrown.expectNullPointerException("The char sequence to look for should not be null");
+    strings.assertXmlEqualsTo(someInfo(), "<jedi>yoda</jedi>", null);
+  }
+
+  @Test
+  public void should_fail_if_both_Strings_are_not_XML_equals() {
+    String actual = "<rss version=\"2.0\"><channel><title>Java Tutorials</title></channel></rss>";
+    String expected = "<rss version=\"2.0\"><channel><title>Java Tutorials and Examples</title></channel></rss>";
+    AssertionInfo info = someInfo();
+    try {
+      strings.assertXmlEqualsTo(info, actual, expected);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeEqual(xmlPrettyFormat(actual), xmlPrettyFormat(expected)));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_pass_if_both_Strings_are_XML_equals_case_insensitively() {
+    String actual = "<rss version=\"2.0\"><Channel><title>Java Tutorials</title></Channel></rss>";
+    String expected = "<rss version=\"2.0\"><channel><TITLE>JAVA Tutorials</TITLE></channel></rss>";
+    stringsWithCaseInsensitiveComparisonStrategy.assertXmlEqualsTo(someInfo(), actual, expected);
+  }
+
+  @Test
+  public void should_fail_if_both_Strings_are_not_XML_equal_regardless_of_case() {
+    AssertionInfo info = someInfo();
+    String actual = "<rss version=\"2.0\"><channel><title>Java Tutorials</title></channel></rss>";
+    String expected = "<rss version=\"2.0\"><channel><title>Java Tutorials and Examples</title></channel></rss>";
+    try {
+      stringsWithCaseInsensitiveComparisonStrategy.assertXmlEqualsTo(someInfo(), actual, expected);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, shouldBeEqual(xmlPrettyFormat(actual), xmlPrettyFormat(expected)));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/test/ErrorMessages.java b/src/test/java/org/assertj/core/test/ErrorMessages.java
index 2827ed95a..c3081ee78 100644
--- a/src/test/java/org/assertj/core/test/ErrorMessages.java
+++ b/src/test/java/org/assertj/core/test/ErrorMessages.java
@@ -72,8 +72,8 @@ public final class ErrorMessages {
     return "The regular expression pattern to match should not be null";
   }
 
-  public static String sequenceToLookForIsNull() {
-    return "The sequence to look for should not be null";
+  public static String charSequenceToLookForIsNull() {
+    return "The char sequence to look for should not be null";
   }
 
   public static String valuesToLookForIsEmpty() {
diff --git a/src/test/java/org/assertj/core/util/xml/XmlStringPrettyFormatter_prettyFormat_Test.java b/src/test/java/org/assertj/core/util/xml/XmlStringPrettyFormatter_prettyFormat_Test.java
new file mode 100644
index 000000000..19fd8b738
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/xml/XmlStringPrettyFormatter_prettyFormat_Test.java
@@ -0,0 +1,79 @@
+/*
+ * Created on Feb 22, 2011
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ * 
+ * http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ * 
+ * Copyright @2011 the original author or authors.
+ */
+package org.assertj.core.util.xml;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.util.xml.XmlStringPrettyFormatter.xmlPrettyFormat;
+
+import org.junit.Test;
+import org.xml.sax.SAXParseException;
+
+/**
+ * Tests for <code>{@link XmlStringPrettyFormatter#xmlPrettyFormat(String)}</code>.
+ * 
+ * @author Joel Costigliola
+ */
+public class XmlStringPrettyFormatter_prettyFormat_Test {
+
+  private static final String EXPECTED_FORMATTED_XML = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<rss version=\"2.0\">\n    <channel>\n"
+      + "        <title>Java Tutorials and Examples 1</title>\n"
+      + "        <language>en-us</language>\n"
+      + "    </channel>\n</rss>\n";
+
+  @Test
+  public void should_format_xml_string_prettily() {
+    String xmlString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><rss version=\"2.0\"><channel><title>Java Tutorials and Examples 1</title><language>en-us</language></channel></rss>";
+    assertThat(xmlPrettyFormat(xmlString)).isEqualTo(EXPECTED_FORMATTED_XML);
+  }
+
+  @Test
+  public void should_format_xml_string_without_xml_declaration_prettily() {
+    String xmlString = "<rss version=\"2.0\"><channel><title>Java Tutorials and Examples 1</title><language>en-us</language></channel></rss>";
+    assertThat(xmlPrettyFormat(xmlString)).isEqualTo(
+        EXPECTED_FORMATTED_XML.substring("<?xml version='1.0' encoding='UTF-8'?>\n".length()));
+  }
+
+  @Test
+  public void should_format_xml_string_with_space_and_newline_prettily() {
+    String xmlString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><rss version=\"2.0\"><channel>  <title>Java Tutorials and Examples 1</title>  \n\n<language>en-us</language>  </channel></rss>";
+    assertThat(xmlPrettyFormat(xmlString)).isEqualTo(EXPECTED_FORMATTED_XML);
+  }
+
+  @Test
+  public void should_throw_error_when_xml_string_is_null() {
+    try {
+      xmlPrettyFormat(null);
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (Exception e) {
+      assertThat(e).isInstanceOf(IllegalArgumentException.class).hasMessageStartingWith(
+          "Expecting XML String not to be null");
+    }
+  }
+
+  @Test
+  public void should_throw_error_when_xml_string_is_not_valid() {
+    String xmlString = "<?xml version=\"1.0\" encoding=\"UTF-8\"?><rss version=\"2.0\"><channel><title>Java Tutorials and Examples 1</title><language>en-us</language></chnel></rss>";
+    try {
+      xmlPrettyFormat(xmlString);
+    } catch (Exception e) {
+      assertThat(e).isInstanceOf(RuntimeException.class).hasMessageStartingWith("Unable to format XML string");
+      assertThat(e).hasRootCauseInstanceOf(SAXParseException.class);
+      assertThat(e.getCause()).hasMessageContaining(
+          "The element type \"channel\" must be terminated by the matching end-tag \"</channel>\"");
+    }
+  }
+
+}
