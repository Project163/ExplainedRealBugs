diff --git a/assertj-core/src/main/java/org/assertj/core/error/ShouldContainSubsequenceOfCharSequence.java b/assertj-core/src/main/java/org/assertj/core/error/ShouldContainSubsequenceOfCharSequence.java
index 859b67728..5205e79e9 100644
--- a/assertj-core/src/main/java/org/assertj/core/error/ShouldContainSubsequenceOfCharSequence.java
+++ b/assertj-core/src/main/java/org/assertj/core/error/ShouldContainSubsequenceOfCharSequence.java
@@ -12,13 +12,18 @@
  */
 package org.assertj.core.error;
 
+import static java.lang.String.format;
+import static java.util.stream.Collectors.joining;
+
+import java.util.Map;
+
 import org.assertj.core.internal.ComparisonStrategy;
 import org.assertj.core.internal.StandardComparisonStrategy;
 
 /**
  * Creates an error message indicating that an assertion that verifies that a {@code CharSequence} contains a Subsequence of
  * several {@code CharSequence}s in order failed.
- * 
+ *
  * @author Joel Costigliola
  * @author Mikhail Mazursky
  */
@@ -26,7 +31,7 @@ public class ShouldContainSubsequenceOfCharSequence extends BasicErrorMessageFac
 
   /**
    * Creates a new <code>{@link ShouldContainSubsequenceOfCharSequence}</code>.
-   * 
+   *
    * @param actual the actual value in the failed assertion.
    * @param strings the sequence of values expected to be in {@code actual}.
    * @param firstBadOrderIndex first index failing the subsequence.
@@ -39,7 +44,7 @@ public class ShouldContainSubsequenceOfCharSequence extends BasicErrorMessageFac
 
   /**
    * Creates a new <code>{@link ShouldContainSubsequenceOfCharSequence}</code>.
-   * 
+   *
    * @param actual the actual value in the failed assertion.
    * @param strings the sequence of values expected to be in {@code actual}.
    * @param badOrderIndex index failing the subsequence.
@@ -51,7 +56,8 @@ public class ShouldContainSubsequenceOfCharSequence extends BasicErrorMessageFac
 
     return new ShouldContainSubsequenceOfCharSequence("%nExpecting actual:%n" +
                                                       "  %s%n" +
-                                                      "to contain the following CharSequences in this order:%n" +
+                                                      "to contain the following CharSequences in this order (possibly with other values between them):%n"
+                                                      +
                                                       "  %s%n" +
                                                       "but %s was found before %s%n%s",
                                                       actual, strings, strings[badOrderIndex + 1],
@@ -59,6 +65,65 @@ public class ShouldContainSubsequenceOfCharSequence extends BasicErrorMessageFac
                                                       comparisonStrategy);
   }
 
+  /**
+   * Creates a new <code>{@link ShouldContainSubsequenceOfCharSequence}</code> with detailed error messages about missing subsequences.
+   *
+   * @param actual the actual value in the failed assertion.
+   * @param strings the sequence of values expected to be in {@code actual}.
+   * @param notFoundRepeatedSubsequence a map where each key is a subsequence of {@code strings}
+   *        that was expected to be found in {@code actual} and the corresponding value is
+   *        the number of times it was expected but not found.
+   * @param comparisonStrategy the {@link ComparisonStrategy} used to evaluate assertion.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldContainSubsequence(CharSequence actual, CharSequence[] strings,
+                                                             Map<CharSequence, Integer> notFoundRepeatedSubsequence,
+                                                             ComparisonStrategy comparisonStrategy) {
+
+    String detailedErrorMessage;
+    if (notFoundRepeatedSubsequence.size() == 1) {
+      Map.Entry<CharSequence, Integer> singleEntry = notFoundRepeatedSubsequence.entrySet().iterator().next();
+      detailedErrorMessage = format("But the %s occurrence of \"%s\" was not found", ordinal(singleEntry.getValue() + 1),
+                                    singleEntry.getKey());
+    } else {
+      detailedErrorMessage = notFoundRepeatedSubsequence.entrySet().stream()
+                                                        .map(entry -> format("- the %s occurrence of \"%s\" was not found",
+                                                                             ordinal(entry.getValue() + 1), entry.getKey()))
+                                                        .collect(joining("%n"));
+      detailedErrorMessage = "But:%n" + detailedErrorMessage;
+    }
+
+    return new ShouldContainSubsequenceOfCharSequence("%nExpecting actual:%n" +
+                                                      "  %s%n" +
+                                                      "to contain the following CharSequences in this order (possibly with other values between them):%n"
+                                                      +
+                                                      "  %s%n" +
+                                                      detailedErrorMessage + "%n%s",
+                                                      actual, strings, comparisonStrategy);
+  }
+
+  /**
+   * Returns the ordinal representation of a given integer.
+   * <p>
+   * This method converts integers to their ordinal form (e.g., 1 to "1st", 2 to "2nd", etc.).
+   * Special cases for numbers ending in 11, 12, and 13 are handled to return "th" instead of
+   * "st", "nd", or "rd".
+   * </p>
+   *
+   * @param i the integer to convert
+   * @return the ordinal representation of {@code i}
+   */
+  private static String ordinal(int i) {
+    int mod100 = i % 100;
+    int mod10 = i % 10;
+
+    if (mod10 == 1 && mod100 != 11) return i + "st";
+    if (mod10 == 2 && mod100 != 12) return i + "nd";
+    if (mod10 == 3 && mod100 != 13) return i + "rd";
+
+    return i + "th";
+  }
+
   private ShouldContainSubsequenceOfCharSequence(String format, CharSequence actual, CharSequence[] strings,
                                                  CharSequence foundButBadOrder,
                                                  CharSequence foundButBadOrder2,
@@ -66,4 +131,8 @@ public class ShouldContainSubsequenceOfCharSequence extends BasicErrorMessageFac
     super(format, actual, strings, foundButBadOrder, foundButBadOrder2, comparisonStrategy);
   }
 
+  private ShouldContainSubsequenceOfCharSequence(String format, CharSequence actual, CharSequence[] strings,
+                                                 ComparisonStrategy comparisonStrategy) {
+    super(format, actual, strings, comparisonStrategy);
+  }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/Strings.java b/assertj-core/src/main/java/org/assertj/core/internal/Strings.java
index e7e5f9527..65d21cd29 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/Strings.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/Strings.java
@@ -18,7 +18,11 @@ import static java.lang.String.format;
 import static java.util.Arrays.stream;
 import static java.util.Locale.ROOT;
 import static java.util.Objects.requireNonNull;
+import static java.util.function.Function.identity;
+import static java.util.stream.Collectors.counting;
+import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.toCollection;
+import static java.util.stream.Collectors.toMap;
 import static org.assertj.core.error.ShouldBeBase64.shouldBeBase64;
 import static org.assertj.core.error.ShouldBeEmpty.shouldBeEmpty;
 import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
@@ -81,10 +85,14 @@ import java.io.StringReader;
 import java.text.Normalizer;
 import java.util.Base64;
 import java.util.Comparator;
+import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.VisibleForTesting;
@@ -255,7 +263,8 @@ public class Strings {
   public void assertContainsIgnoringCase(AssertionInfo info, CharSequence actual, CharSequence sequence) {
     checkCharSequenceIsNotNull(sequence);
     assertNotNull(info, actual);
-    if (!containsIgnoreCase(actual, sequence)) throw failures.failure(info, shouldContainIgnoringCase(actual, sequence));
+    if (!containsIgnoreCase(actual, sequence))
+      throw failures.failure(info, shouldContainIgnoringCase(actual, sequence));
   }
 
   private boolean containsIgnoreCase(CharSequence actual, CharSequence sequence) {
@@ -299,11 +308,13 @@ public class Strings {
   }
 
   public void assertEqualsIgnoringCase(AssertionInfo info, CharSequence actual, CharSequence expected) {
-    if (!areEqualIgnoringCase(actual, expected)) throw failures.failure(info, shouldBeEqual(actual, expected), actual, expected);
+    if (!areEqualIgnoringCase(actual, expected))
+      throw failures.failure(info, shouldBeEqual(actual, expected), actual, expected);
   }
 
   public void assertNotEqualsIgnoringCase(AssertionInfo info, CharSequence actual, CharSequence expected) {
-    if (areEqualIgnoringCase(actual, expected)) throw failures.failure(info, shouldNotBeEqualIgnoringCase(actual, expected));
+    if (areEqualIgnoringCase(actual, expected))
+      throw failures.failure(info, shouldNotBeEqualIgnoringCase(actual, expected));
   }
 
   private static boolean areEqualIgnoringCase(CharSequence actual, CharSequence expected) {
@@ -582,16 +593,8 @@ public class Strings {
   public void assertContainsSubsequence(AssertionInfo info, CharSequence actual, CharSequence[] subsequence) {
     doCommonCheckForCharSequence(info, actual, subsequence);
 
-    Set<CharSequence> notFound = stream(subsequence).filter(value -> !stringContains(actual, value))
-                                                    .collect(toCollection(LinkedHashSet::new));
-
-    if (!notFound.isEmpty()) {
-      // don't bother looking for a subsequence, some of the subsequence elements were not found !
-      if (notFound.size() == 1 && subsequence.length == 1) {
-        throw failures.failure(info, shouldContain(actual, subsequence[0], comparisonStrategy));
-      }
-      throw failures.failure(info, shouldContain(actual, subsequence, notFound, comparisonStrategy));
-    }
+    Map<CharSequence, Integer> notFound = getNotFoundSubsequence(actual, subsequence);
+    handleNotFound(info, actual, subsequence, notFound);
 
     // we have found all the given values but were they in the expected order ?
     if (subsequence.length == 1) return; // no order check needed for a one element subsequence
@@ -610,6 +613,84 @@ public class Strings {
     }
   }
 
+  /**
+   * Handles the scenario where certain subsequences were not found in the actual CharSequence.
+   * Depending on the exact mismatch details, it throws appropriate assertion failures.
+   *
+   * @param info        Assertion metadata.
+   * @param actual      The actual CharSequence being checked.
+   * @param subsequence The expected subsequence to be found in the actual CharSequence.
+   * @param notFound    A map containing subsequences that were not found (or not found enough times) and their respective counts.
+   */
+  private void handleNotFound(AssertionInfo info, CharSequence actual,
+                              CharSequence[] subsequence, Map<CharSequence, Integer> notFound) {
+
+    // If there are no missing subsequences, there's nothing to handle, so return.
+    if (notFound.isEmpty()) return;
+
+    // Special case: If there's only one missing subsequence, and we were only looking for one,
+    // throw a specific failure for that.
+    if (notFound.size() == 1 && subsequence.length == 1) {
+      throw failures.failure(info, shouldContain(actual, subsequence[0], comparisonStrategy));
+    }
+
+    // Check if all the missing subsequences are due to not finding duplicates.
+    // If every value in 'notFound' map is greater than 0, this indicates that the corresponding
+    // subsequences were found, but not as many times as expected.
+    boolean anyDuplicateSubsequenceFound = notFound.values().stream().allMatch(count -> count > 0);
+
+    // If the above is true, throw a failure specifying the subsequence mismatch details.
+    if (anyDuplicateSubsequenceFound) {
+      throw failures.failure(info, shouldContainSubsequence(actual, subsequence, notFound, comparisonStrategy));
+    }
+
+    // Otherwise, filter the 'notFound' map to get the keys (subsequences) that were not found at all (value is 0).
+    Set<CharSequence> notFoundKeysWithZeroValue = notFound.entrySet().stream()
+                                                          .filter(entry -> entry.getValue() == 0)
+                                                          .map(Map.Entry::getKey)
+                                                          .collect(Collectors.toSet());
+    // Throw a failure specifying the completely missing subsequences.
+    throw failures.failure(info, shouldContain(actual, subsequence, notFoundKeysWithZeroValue, comparisonStrategy));
+  }
+
+  /**
+   * Computes and returns a map of subsequence elements that were not found (or not found enough times) in actual.
+   *
+   * @param actual      The actual CharSequence being checked.
+   * @param subsequence The expected subsequence to be found in the actual CharSequence.
+   * @return A map where the key represents the missing subsequence and the value represents the number of times it appears in 'actual'.
+   */
+  private Map<CharSequence, Integer> getNotFoundSubsequence(CharSequence actual, CharSequence[] subsequence) {
+    // Create a map to store how many times each element appears in the 'actual' sequence.
+    // We use a HashMap for efficient look-ups and modifications.
+    Map<CharSequence, Integer> actualCounts = new HashMap<>();
+
+    // Create a map to store how many times each element appears in the 'subsequence' array.
+    // We use the Java Streams API to group the elements by their identity and then count their occurrences.
+    Map<CharSequence, Long> subseqCounts = stream(subsequence).collect(groupingBy(identity(), counting()));
+
+    // For each element in the 'subsequence', compute its occurrences in the 'actual' sequence.
+    // If the element is not yet in the actualCounts map (v is null), then count its occurrences in 'actual'.
+    // If the element is already in the actualCounts map (v is not null), then keep its current count.
+    for (CharSequence value : subsequence) {
+      actualCounts.compute(value, (k, v) -> v == null ? countOccurrences(k, actual) : v);
+    }
+    // Return a map that contains only the elements from the 'subsequence' that appear more times in 'subsequence' than
+    // in 'actual'. The map's keys are the elements and the values are the number of times they appear in 'actual'.
+    return subseqCounts.entrySet().stream()
+                       .filter(entry -> entry.getValue() > actualCounts.getOrDefault(entry.getKey(), 0))
+                       .collect(toMap(// The key of the output map entry is the same as the subsequence entry key.
+                                      Map.Entry::getKey,
+                                      // The value of the output map entry is the number of times the key appears in
+                                      // 'actual'.
+                                      entry -> actualCounts.get(entry.getKey()),
+                                      // If there are duplicate keys when collecting (which shouldn't happen in this
+                                      // case), prefer the existing key.
+                                      (existing, replacement) -> existing,
+                                      // Use a LinkedHashMap to maintain the insertion order.
+                                      LinkedHashMap::new));
+  }
+
   private String removeUpTo(String string, CharSequence toRemove) {
     // we have already checked that toRemove was not null in doCommonCheckForCharSequence and this point string is not neither
     int index = indexOf(string, toRemove);
diff --git a/assertj-core/src/test/java/org/assertj/core/error/ShouldContainSubsequenceOfCharSequence_create_Test.java b/assertj-core/src/test/java/org/assertj/core/error/ShouldContainSubsequenceOfCharSequence_create_Test.java
index 48e7523e3..ca89b58e8 100644
--- a/assertj-core/src/test/java/org/assertj/core/error/ShouldContainSubsequenceOfCharSequence_create_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/error/ShouldContainSubsequenceOfCharSequence_create_Test.java
@@ -13,14 +13,22 @@
 package org.assertj.core.error;
 
 import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldContainSubsequenceOfCharSequence.shouldContainSubsequence;
+import static org.assertj.core.test.Maps.mapOf;
+import static org.assertj.core.util.Arrays.array;
+
+import java.util.stream.Stream;
 
 import org.assertj.core.description.TextDescription;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.presentation.StandardRepresentation;
 import org.assertj.core.test.CaseInsensitiveStringComparator;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests for <code>{@link ShouldContainSubsequenceOfCharSequence#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
@@ -40,7 +48,8 @@ class ShouldContainSubsequenceOfCharSequence_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %nExpecting actual:%n" +
                                    "  \"" + actual + "\"%n" +
-                                   "to contain the following CharSequences in this order:%n" +
+                                   "to contain the following CharSequences in this order (possibly with other values between them):%n"
+                                   +
                                    "  [\"{\", \"author\", \"title\", \"}\"]%n" +
                                    "but \"title\" was found before \"author\"%n"));
   }
@@ -57,10 +66,83 @@ class ShouldContainSubsequenceOfCharSequence_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %nExpecting actual:%n" +
                                    "  \"" + actual + "\"%n" +
-                                   "to contain the following CharSequences in this order:%n" +
+                                   "to contain the following CharSequences in this order (possibly with other values between them):%n"
+                                   +
                                    "  [\"{\", \"author\", \"title\", \"}\"]%n" +
                                    "but \"title\" was found before \"author\"%n" +
                                    "when comparing values using CaseInsensitiveStringComparator"));
   }
 
+  @ParameterizedTest(name = "Testing {0} occurrence of title")
+  @MethodSource
+  void should_create_error_message_indicating_duplicate_subsequence(int occurrence, String[] sequenceValues, String actual,
+                                                                    String expectedErrorMessage) {
+    ErrorMessageFactory factory = shouldContainSubsequence(actual, sequenceValues, mapOf(entry("title", occurrence - 1)),
+                                                           new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.INSTANCE));
+
+    // WHEN
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+
+    // THEN
+    then(message).isEqualTo(expectedErrorMessage);
+  }
+
+  private static Stream<Arguments> should_create_error_message_indicating_duplicate_subsequence() {
+    String actual2ndNotFound = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
+    String actual3rdNotFound = "{ 'title':'A Game of Thrones', 'author':'George Martin', 'title':'A Clash of Kings', 'author':'George Martin'}";
+    String actual4thNotFound = "{ 'title':'A Game of Thrones', 'author':'George Martin', 'title':'A Clash of Kings', 'author':'George Martin', 'title':'A Storm of Swords', 'author':'George Martin'}";
+    return Stream.of(Arguments.of(
+                                  2,
+                                  array("{", "title", "author", "title", "}"),
+                                  actual2ndNotFound,
+                                  format("[Test] %nExpecting actual:%n" +
+                                         "  \"" + actual2ndNotFound + "\"%n" +
+                                         "to contain the following CharSequences in this order (possibly with other values between them):%n"
+                                         +
+                                         "  [\"{\", \"title\", \"author\", \"title\", \"}\"]%n" +
+                                         "But the 2nd occurrence of \"title\" was not found%n" +
+                                         "when comparing values using CaseInsensitiveStringComparator")),
+                     Arguments.of(
+                                  3,
+                                  array("{", "title", "author", "title", "title", "}"),
+                                  actual3rdNotFound,
+                                  format("[Test] %nExpecting actual:%n" +
+                                         "  \"" + actual3rdNotFound + "\"%n" +
+                                         "to contain the following CharSequences in this order (possibly with other values between them):%n"
+                                         +
+                                         "  [\"{\", \"title\", \"author\", \"title\", \"title\", \"}\"]%n" +
+                                         "But the 3rd occurrence of \"title\" was not found%n" +
+                                         "when comparing values using CaseInsensitiveStringComparator")),
+                     Arguments.of(4,
+                                  array("{", "title", "author", "title", "title", "title", "}"),
+                                  actual4thNotFound,
+                                  format("[Test] %nExpecting actual:%n" +
+                                         "  \"" + actual4thNotFound + "\"%n" +
+                                         "to contain the following CharSequences in this order (possibly with other values between them):%n"
+                                         +
+                                         "  [\"{\", \"title\", \"author\", \"title\", \"title\", \"title\", \"}\"]%n" +
+                                         "But the 4th occurrence of \"title\" was not found%n" +
+                                         "when comparing values using CaseInsensitiveStringComparator")));
+  }
+
+  @Test
+  void should_create_error_message_indicating_multiple_duplicate_subsequence() {
+    // GIVEN
+    String[] sequenceValues = { "{", "title", "George", "title", "title", "George", "}" };
+    String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin', 'title':'The Kingkiller Chronicle', 'author':'Patrick Rothfuss'}";
+    ErrorMessageFactory factory = shouldContainSubsequence(actual, sequenceValues, mapOf(entry("title", 2), entry("George", 1)),
+                                                           new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.INSTANCE));
+    // WHEN
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    // THEN
+    then(message).isEqualTo(format("[Test] %nExpecting actual:%n" +
+                                   "  \"" + actual + "\"%n" +
+                                   "to contain the following CharSequences in this order (possibly with other values between them):%n"
+                                   +
+                                   "  [\"{\", \"title\", \"George\", \"title\", \"title\", \"George\", \"}\"]%n" +
+                                   "But:%n" +
+                                   "- the 3rd occurrence of \"title\" was not found%n" +
+                                   "- the 2nd occurrence of \"George\" was not found%n" +
+                                   "when comparing values using CaseInsensitiveStringComparator"));
+  }
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSubsequence_Test.java b/assertj-core/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSubsequence_Test.java
index 704b7e166..f7c55a3c0 100644
--- a/assertj-core/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSubsequence_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/internal/strings/Strings_assertContainsSubsequence_Test.java
@@ -14,11 +14,13 @@ package org.assertj.core.internal.strings;
 
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
 import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.ShouldContainCharSequence.shouldContain;
 import static org.assertj.core.error.ShouldContainSubsequenceOfCharSequence.shouldContainSubsequence;
 import static org.assertj.core.internal.ErrorMessages.arrayOfValuesToLookForIsEmpty;
 import static org.assertj.core.internal.ErrorMessages.arrayOfValuesToLookForIsNull;
+import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
@@ -140,4 +142,58 @@ class Strings_assertContainsSubsequence_Test extends StringsBaseTest {
     verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, 1, comparisonStrategy));
   }
 
+  @Test
+  void should_fail_if_actual_does_not_contain_all_occurrences_of_subsequence_values() {
+    // GIVEN
+    String actual = "v1 : v2 : v3";
+    String[] subsequence = { "v2", "v2", "v3" };
+    // WHEN
+    expectAssertionError(() -> stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, mapOf(entry("v2", 1)), comparisonStrategy));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_multiple_repeated_occurrences_of_subsequence_values() {
+    // GIVEN
+    String actual = "v1 : v2 : v2 : v3";
+    String[] subsequence = { "v2", "v2", "v2", "v3" };
+    // WHEN
+    expectAssertionError(() -> stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, mapOf(entry("v2", 2)), comparisonStrategy));
+  }
+
+  @Test
+  void should_fail_when_actual_does_not_contain_non_existing_elements_and_missing_subsequence_duplicates() {
+    // GIVEN
+    String actual = "v1 : v2 : v3 : v2";
+    String[] subsequence = { "v2", "v2", "v2", "v3", "v4", "v5" };
+    // WHEN
+    expectAssertionError(() -> strings.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContain(actual, subsequence, newLinkedHashSet("v4", "v5")));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_repeated_occurrences_of_subsequence_values() {
+    // GIVEN
+    String actual = "Yoda";
+    String[] subsequence = { "Yo", "da", "da" };
+    // WHEN
+    expectAssertionError(() -> stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, mapOf(entry("da", 1)), comparisonStrategy));
+  }
+
+  @Test
+  void should_fail_if_actual_does_not_contain_repeated_occurrences_of_subsequence_values_in_text_with_multiple_values() {
+    // GIVEN
+    String actual = "{ 'title':'A Game of Thrones', 'author':'George Martin'}";
+    String[] subsequence = new String[] { "George", "George" };
+    // WHEN
+    expectAssertionError(() -> stringsWithCaseInsensitiveComparisonStrategy.assertContainsSubsequence(INFO, actual, subsequence));
+    // THEN
+    verify(failures).failure(INFO, shouldContainSubsequence(actual, subsequence, mapOf(entry("George", 1)), comparisonStrategy));
+  }
 }
