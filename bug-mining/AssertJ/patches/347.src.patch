diff --git a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 7d4374152..27dfaac90 100644
--- a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -207,6 +207,51 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Makes the recursive comparison to ignore all <b>expected null fields</b>.
+   * <p>
+   * Example:
+   * <pre><code class='java'> public class Person {
+   *   String name;
+   *   double height;
+   *   Home home = new Home();
+   * }
+   *
+   * public class Home {
+   *   Address address = new Address();
+   * }
+   *
+   * public static class Address {
+   *   int number;
+   *   String street;
+   * }
+   *
+   * Person sherlock = new Person("Sherlock", 1.80);
+   * sherlock.home.address.street = "Baker Street";
+   * sherlock.home.address.number = 221;
+   *
+   * Person noName = new Person(null, 1.80);
+   * noName.home.address.street = null;
+   * noName.home.address.number = 221;
+   *
+   * // assertion succeeds as name and home.address.street fields are ignored in the comparison
+   * assertThat(sherlock).usingRecursiveComparison()
+   *                     .ignoringExpectedNullFields()
+   *                     .isEqualTo(noName);
+   *
+   * // assertion fails as name and home.address.street fields are populated for sherlock but not noName.
+   * assertThat(noName).usingRecursiveComparison()
+   *                   .ignoringExpectedNullFields()
+   *                   .isEqualTo(sherlock);</code></pre>
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   */
+  @CheckReturnValue
+  public SELF ignoringExpectedNullFields() {
+    recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
+    return myself;
+  }
+
   /**
    * Makes the recursive comparison to ignore the given object under test fields. Nested fields can be specified like this: {@code home.address.street}.
    * <p>
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 424563458..03aeb213e 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -45,6 +45,7 @@ public class RecursiveComparisonConfiguration {
 
   // fields to ignore section
   private boolean ignoreAllActualNullFields = false;
+  private boolean ignoreAllExpectedNullFields = false;
   private Set<FieldLocation> ignoredFields = new LinkedHashSet<>();
   private List<Pattern> ignoredFieldsRegexes = new ArrayList<>();
   private Set<Class<?>> ignoredTypes = new LinkedHashSet<>();
@@ -112,6 +113,17 @@ public class RecursiveComparisonConfiguration {
     this.ignoreAllActualNullFields = ignoreAllActualNullFields;
   }
 
+  /**
+   * Sets whether expected null fields are ignored in the recursive comparison.
+   * <p>
+   * See {@link RecursiveComparisonAssert#ignoringExpectedNullFields()} for code examples.
+   *
+   * @param ignoreAllExpectedNullFields whether to ignore expected null fields in the recursive comparison
+   */
+  public void setIgnoreAllExpectedNullFields(boolean ignoreAllExpectedNullFields) {
+    this.ignoreAllExpectedNullFields = ignoreAllExpectedNullFields;
+  }
+
   /**
    * Adds the given fields to the list of the object under test fields to ignore in the recursive comparison.
    * <p>
@@ -363,6 +375,7 @@ public class RecursiveComparisonConfiguration {
   public String multiLineDescription(Representation representation) {
     StringBuilder description = new StringBuilder();
     describeIgnoreAllActualNullFields(description);
+    describeIgnoreAllExpectedNullFields(description);
     describeIgnoredFields(description);
     describeIgnoredFieldsRegexes(description);
     describeIgnoredFieldsForTypes(description);
@@ -380,7 +393,7 @@ public class RecursiveComparisonConfiguration {
     String concatenatedPath = dualValue.concatenatedPath;
     return matchesAnIgnoredField(concatenatedPath)
            || matchesAnIgnoredFieldRegex(concatenatedPath)
-           || shouldIgnoreNotEvalutingFieldName(dualValue);
+           || shouldIgnoreNotEvaluatingFieldName(dualValue);
   }
 
   Set<String> getNonIgnoredActualFieldNames(DualValue dualValue) {
@@ -388,13 +401,13 @@ public class RecursiveComparisonConfiguration {
     // we are doing the same as shouldIgnore(DualValue dualKey) but in two steps for performance reasons:
     // - we filter first ignored field by names that don't need building DualValues
     // - then we filter field DualValues with the remaining criteria (shouldIgnoreNotEvalutingFieldName)
-    // DualValuea are built introspecting fields which is expensive.
+    // DualValues are built introspecting fields which is expensive.
     return actualFieldsNames.stream()
                             // evaluate field name ignoring criteria
                             .filter(fieldName -> !shouldIgnore(dualValue.path, fieldName))
                             .map(fieldName -> dualValueForField(dualValue, fieldName))
                             // evaluate field value ignoring criteria
-                            .filter(fieldDualValue -> !shouldIgnoreNotEvalutingFieldName(fieldDualValue))
+                            .filter(fieldDualValue -> !shouldIgnoreNotEvaluatingFieldName(fieldDualValue))
                             // back to field name
                             .map(DualValue::getFieldName)
                             .filter(fieldName -> !fieldName.isEmpty())
@@ -403,7 +416,7 @@ public class RecursiveComparisonConfiguration {
 
   // non public stuff
 
-  private boolean shouldIgnoreNotEvalutingFieldName(DualValue dualKey) {
+  private boolean shouldIgnoreNotEvaluatingFieldName(DualValue dualKey) {
     return matchesAnIgnoredNullField(dualKey) || matchesAnIgnoredFieldType(dualKey);
   }
 
@@ -477,6 +490,10 @@ public class RecursiveComparisonConfiguration {
     if (ignoreAllActualNullFields) description.append(format("- all actual null fields were ignored in the comparison%n"));
   }
 
+  private void describeIgnoreAllExpectedNullFields(StringBuilder description) {
+    if (ignoreAllExpectedNullFields) description.append(format("- all expected null fields were ignored in the comparison%n"));
+  }
+
   private void describeOverriddenEqualsMethodsUsage(StringBuilder description, Representation representation) {
     boolean isConfiguredToIgnoreSomeOverriddenEqualsMethods = isConfiguredToIgnoreSomeOverriddenEqualsMethods();
     String header = ignoreAllOverriddenEquals
@@ -550,7 +567,8 @@ public class RecursiveComparisonConfiguration {
   }
 
   private boolean matchesAnIgnoredNullField(DualValue dualValue) {
-    return ignoreAllActualNullFields && dualValue.actual == null;
+    return (ignoreAllActualNullFields && dualValue.actual == null)
+           || (ignoreAllExpectedNullFields && dualValue.expected == null);
   }
 
   private boolean matchesAnIgnoredFieldRegex(String fieldConcatenatedPath) {
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index d9aaf3621..a1497daf3 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -251,9 +251,7 @@ public class RecursiveComparisonDifferenceCalculator {
       Class<?> actualFieldValueClass = actualFieldValue.getClass();
       if (!recursiveComparisonConfiguration.shouldIgnoreOverriddenEqualsOf(dualValue)
           && hasOverriddenEquals(actualFieldValueClass)) {
-        if (!actualFieldValue.equals(expectedFieldValue)) {
-          comparisonState.addDifference(dualValue);
-        }
+        if (!actualFieldValue.equals(expectedFieldValue)) comparisonState.addDifference(dualValue);
         continue;
       }
 
@@ -326,7 +324,6 @@ public class RecursiveComparisonDifferenceCalculator {
       // at the moment we only allow comparing arrays with arrays but we might allow comparing to collections later on
       // but only if we are not in strict type mode.
       comparisonState.addDifference(dualValue, differentTypeErrorMessage(dualValue, "an array"));
-
       return;
     }
     // both values in dualValue are arrays
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualDequeTest.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualDequeTest.java
deleted file mode 100644
index f69391824..000000000
--- a/src/test/java/org/assertj/core/api/recursive/comparison/DualDequeTest.java
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- * Copyright 2012-2020 the original author or authors.
- */
-package org.assertj.core.api.recursive.comparison;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.util.Lists.list;
-
-import java.util.List;
-
-import org.apache.commons.lang3.RandomStringUtils;
-import org.apache.commons.lang3.RandomUtils;
-import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.Test;
-
-public class DualDequeTest {
-
-  private RecursiveComparisonConfiguration recursiveComparisonConfiguration;
-
-  @BeforeEach
-  public void beforeEachTest() {
-    recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
-  }
-
-  @Test
-  public void should_ignore_dual_keys_with_a_null_first_key() {
-    // GIVEN
-    recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
-    DualValueDeque dualKayDeque = new DualValueDeque(recursiveComparisonConfiguration);
-    DualValue dualKeyA = dualKey(null, "A");
-    DualValue dualKeyB = dualKey("B", "B");
-    DualValue dualKeyC = dualKey(null, "C");
-    DualValue dualKeyD = dualKey("D", "D");
-    DualValue dualKeyE = dualKey("E", "E");
-    // WHEN
-    dualKayDeque.add(dualKeyA);
-    dualKayDeque.add(dualKeyB);
-    dualKayDeque.addFirst(dualKeyC);
-    dualKayDeque.add(dualKeyD);
-    dualKayDeque.addLast(dualKeyE);
-    dualKayDeque.add(1, dualKeyA);
-    dualKayDeque.addAll(list(dualKeyA, dualKeyB, dualKeyC));
-    dualKayDeque.addAll(0, list(dualKeyA, dualKeyB, dualKeyC));
-    // THEN
-    assertThat(dualKayDeque).containsExactly(dualKeyB, dualKeyB, dualKeyD, dualKeyE, dualKeyB);
-  }
-
-  @Test
-  public void should_not_ignore_any_dual_keys() {
-    // GIVEN
-    DualValueDeque dualKayDeque = new DualValueDeque(recursiveComparisonConfiguration);
-    DualValue dualKeyA = dualKey(null, "A");
-    DualValue dualKeyB = dualKey("B", "B");
-    DualValue dualKeyC = dualKey(null, "C");
-    DualValue dualKeyD = dualKey("D", "D");
-    DualValue dualKeyE = dualKey("E", "E");
-    // WHEN
-    dualKayDeque.add(dualKeyA);
-    dualKayDeque.add(dualKeyB);
-    dualKayDeque.addFirst(dualKeyC);
-    dualKayDeque.add(dualKeyD);
-    dualKayDeque.addLast(dualKeyE);
-    dualKayDeque.add(1, dualKeyA);
-    dualKayDeque.addAll(list(dualKeyA, dualKeyB, dualKeyC));
-    dualKayDeque.addAll(0, list(dualKeyA, dualKeyB, dualKeyC));
-    // THEN
-    assertThat(dualKayDeque).containsExactly(dualKeyA, dualKeyB, dualKeyC, dualKeyC, dualKeyA, dualKeyA, dualKeyB, dualKeyD,
-                                             dualKeyE, dualKeyA, dualKeyB, dualKeyC);
-  }
-
-  private static DualValue dualKey(String key1, String key2) {
-    return new DualValue(randomPath(), key1, key2);
-  }
-
-  private static List<String> randomPath() {
-    return list(RandomStringUtils.random(RandomUtils.nextInt(0, 10)));
-  }
-
-}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/DualValueDequeTest.java b/src/test/java/org/assertj/core/api/recursive/comparison/DualValueDequeTest.java
new file mode 100644
index 000000000..6f740c32a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/DualValueDequeTest.java
@@ -0,0 +1,113 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.apache.commons.lang3.RandomStringUtils.random;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+
+import org.apache.commons.lang3.RandomUtils;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("DualValueDeque")
+public class DualValueDequeTest {
+
+  private RecursiveComparisonConfiguration recursiveComparisonConfiguration;
+
+  @BeforeEach
+  public void beforeEachTest() {
+    recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+  }
+
+  @Test
+  public void should_ignore_dual_values_with_a_null_first_value() {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
+    DualValueDeque dualKayDeque = new DualValueDeque(recursiveComparisonConfiguration);
+    DualValue dualValueA = dualValue(null, "A");
+    DualValue dualValueB = dualValue("B", "B");
+    DualValue dualValueC = dualValue(null, "C");
+    DualValue dualValueD = dualValue("D", "D");
+    DualValue dualValueE = dualValue("E", "E");
+    // WHEN
+    dualKayDeque.add(dualValueA);
+    dualKayDeque.add(dualValueB);
+    dualKayDeque.addFirst(dualValueC);
+    dualKayDeque.add(dualValueD);
+    dualKayDeque.addLast(dualValueE);
+    dualKayDeque.add(1, dualValueA);
+    dualKayDeque.addAll(list(dualValueA, dualValueB, dualValueC));
+    dualKayDeque.addAll(0, list(dualValueA, dualValueB, dualValueC));
+    // THEN
+    then(dualKayDeque).containsExactly(dualValueB, dualValueB, dualValueD, dualValueE, dualValueB);
+  }
+
+  @Test
+  public void should_ignore_dual_values_with_a_null_second_value() {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
+    DualValueDeque dualKayDeque = new DualValueDeque(recursiveComparisonConfiguration);
+    DualValue dualValueA = dualValue("A", null);
+    DualValue dualValueB = dualValue("B", "B");
+    DualValue dualValueC = dualValue("C", null);
+    DualValue dualValueD = dualValue("D", "D");
+    DualValue dualValueE = dualValue("E", "E");
+    // WHEN
+    dualKayDeque.add(dualValueA);
+    dualKayDeque.add(dualValueB);
+    dualKayDeque.addFirst(dualValueC);
+    dualKayDeque.add(dualValueD);
+    dualKayDeque.addLast(dualValueE);
+    dualKayDeque.add(1, dualValueA);
+    dualKayDeque.addAll(list(dualValueA, dualValueB, dualValueC));
+    dualKayDeque.addAll(0, list(dualValueA, dualValueB, dualValueC));
+    // THEN
+    then(dualKayDeque).containsExactly(dualValueB, dualValueB, dualValueD, dualValueE, dualValueB);
+  }
+
+  @Test
+  public void should_not_ignore_any_dual_values() {
+    // GIVEN
+    DualValueDeque dualKayDeque = new DualValueDeque(recursiveComparisonConfiguration);
+    DualValue dualValueA = dualValue(null, "A");
+    DualValue dualValueB = dualValue("B", "B");
+    DualValue dualValueC = dualValue(null, "C");
+    DualValue dualValueD = dualValue("D", "D");
+    DualValue dualValueE = dualValue("E", "E");
+    // WHEN
+    dualKayDeque.add(dualValueA);
+    dualKayDeque.add(dualValueB);
+    dualKayDeque.addFirst(dualValueC);
+    dualKayDeque.add(dualValueD);
+    dualKayDeque.addLast(dualValueE);
+    dualKayDeque.add(1, dualValueA);
+    dualKayDeque.addAll(list(dualValueA, dualValueB, dualValueC));
+    dualKayDeque.addAll(0, list(dualValueA, dualValueB, dualValueC));
+    // THEN
+    then(dualKayDeque).containsExactly(dualValueA, dualValueB, dualValueC, dualValueC, dualValueA, dualValueA, dualValueB,
+                                       dualValueD, dualValueE, dualValueA, dualValueB, dualValueC);
+  }
+
+  private static DualValue dualValue(String value1, String value2) {
+    return new DualValue(randomPath(), value1, value2);
+  }
+
+  private static List<String> randomPath() {
+    return list(random(RandomUtils.nextInt(0, 10)));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
index 569fc6a72..ae0e7f1bb 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
@@ -32,35 +32,16 @@ import org.junit.jupiter.params.provider.MethodSource;
 
 public class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveComparisonAssert_isEqualTo_BaseTest {
 
-  @SuppressWarnings("unused")
   @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
-  @MethodSource("recursivelyEqualObjectsIgnoringNullValues")
-  public void should_pass_for_objects_with_the_same_data_when_all_null_fields_are_ignored(Object actual,
-                                                                                          Object expected,
-                                                                                          String testDescription) {
+  @MethodSource("recursivelyEqualObjectsIgnoringActualNullValues")
+  public void should_pass_when_actual_null_fields_are_ignored(Object actual, Object expected,
+                                                              @SuppressWarnings("unused") String testDescription) {
     assertThat(actual).usingRecursiveComparison()
                       .ignoringActualNullFields()
                       .isEqualTo(expected);
   }
 
-  @Test
-  public void should_fail_when_actual_differs_from_expected_even_when_all_null_fields_are_ignored() {
-    // GIVEN
-    Person actual = new Person(null);
-    actual.home.address.number = 1;
-    actual.dateOfBirth = null;
-    actual.neighbour = null;
-    Person expected = new Person("John");
-    expected.home.address.number = 2;
-    recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
-    // WHEN
-    compareRecursivelyFailsAsExpected(actual, expected);
-    // THEN
-    ComparisonDifference comparisonDifference = new ComparisonDifference(list("home.address.number"), 1, 2);
-    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, comparisonDifference);
-  }
-
-  private static Stream<Arguments> recursivelyEqualObjectsIgnoringNullValues() {
+  private static Stream<Arguments> recursivelyEqualObjectsIgnoringActualNullValues() {
     Person person1 = new Person(null);
     person1.home.address.number = 1;
 
@@ -110,6 +91,42 @@ public class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends Rec
                      arguments(person7, person8, "same data, actual has null fields deep in its graph"));
   }
 
+  @Test
+  public void should_fail_when_actual_differs_from_expected_even_when_all_null_actual_fields_are_ignored() {
+    // GIVEN
+    Person actual = new Person(null);
+    actual.home.address.number = 1;
+    actual.dateOfBirth = null;
+    actual.neighbour = null;
+    Person expected = new Person("John");
+    expected.home.address.number = 2;
+    recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference comparisonDifference = new ComparisonDifference(list("home.address.number"), 1, 2);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, comparisonDifference);
+  }
+
+  @Test
+  public void should_fail_when_actual_differs_from_expected_even_when_all_null_expected_fields_are_ignored() {
+    // GIVEN
+    Person actual = new Person("John");
+    actual.home.address.number = 1;
+    actual.dateOfBirth = new Date();
+    actual.neighbour = new Person("Jack");
+    Person expected = new Person(null);
+    expected.home.address.number = 2;
+    expected.dateOfBirth = null;
+    expected.neighbour = null;
+    recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference comparisonDifference = new ComparisonDifference(list("home.address.number"), 1, 2);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, comparisonDifference);
+  }
+
   @SuppressWarnings("unused")
   @ParameterizedTest(name = "{2}: actual={0} / expected={1} / ignored fields={3}")
   @MethodSource("recursivelyEqualObjectsIgnoringGivenFields")
@@ -302,10 +319,10 @@ public class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends Rec
 
   @ParameterizedTest(name = "{2}: actual={0} / expected={1} / ignored types={3}")
   @MethodSource("recursivelyEqualObjectsIgnoringGivenTypes")
-  public void should_pass_when_fields_has_given_types_are_ignored(Object actual,
-                                                                  Object expected,
-                                                                  @SuppressWarnings("unused") String testDescription,
-                                                                  List<Class<?>> ignoredTypes) {
+  public void should_pass_when_fields_with_given_types_are_ignored(Object actual,
+                                                                   Object expected,
+                                                                   @SuppressWarnings("unused") String testDescription,
+                                                                   List<Class<?>> ignoredTypes) {
     assertThat(actual).usingRecursiveComparison()
                       .ignoringFieldsOfTypes(ignoredTypes.toArray(new Class<?>[0]))
                       .isEqualTo(expected);
@@ -379,6 +396,33 @@ public class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends Rec
                                                               addressDifference, neighbourDateOfBirthDifference);
   }
 
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
+  @MethodSource("recursivelyEqualObjectsIgnoringExpectedNullFields")
+  public void should_pass_when_expected_null_fields_are_ignored(Object actual, Object expected,
+                                                                @SuppressWarnings("unused") String testDescription) {
+
+    assertThat(actual).usingRecursiveComparison()
+                      .ignoringExpectedNullFields()
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> recursivelyEqualObjectsIgnoringExpectedNullFields() {
+    Person person1 = new Person("John");
+    person1.home.address.number = 1;
+
+    Person person2 = new Person(null);
+
+    Person person3 = new Person("John");
+    person3.home.address = null;
+
+    Person person4 = new Person(null);
+    person3.home.address = null;
+
+    return Stream.of(arguments(person1, person2, "first level expected null field"),
+                     arguments(person1, person3, "nested expected null field"),
+                     arguments(person1, person4, "multiple expected null fields"));
+  }
+
   private static String[] arrayOf(List<String> list) {
     return list.toArray(new String[0]);
   }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index 1ac6990c5..c9bb73b12 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -41,7 +41,7 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
   }
 
   @Test
-  public void should_show_that_null_fields_are_ignored() {
+  public void should_show_that_actual_null_fields_are_ignored() {
     // GIVEN
     recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
     // WHEN
@@ -50,6 +50,16 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
     assertThat(multiLineDescription).contains(format("- all actual null fields were ignored in the comparison%n"));
   }
 
+  @Test
+  public void should_show_that_expected_null_fields_are_ignored() {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    assertThat(multiLineDescription).contains(format("- all expected null fields were ignored in the comparison%n"));
+  }
+
   @Test
   public void should_show_that_some_given_fields_are_ignored() {
     // GIVEN
@@ -237,6 +247,7 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
   public void should_show_a_complete_multiline_description() {
     // GIVEN
     recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
+    recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
     recursiveComparisonConfiguration.ignoreFields("foo", "bar", "foo.bar");
     recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes("f.*", ".ba.", "..b%sr..");
     recursiveComparisonConfiguration.ignoreFieldsOfTypes(UUID.class, ZonedDateTime.class);
@@ -256,6 +267,7 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
     // @format:off
     assertThat(multiLineDescription).isEqualTo(format(
                "- all actual null fields were ignored in the comparison%n" +
+               "- all expected null fields were ignored in the comparison%n" +
                "- the following fields were ignored in the comparison: foo, bar, foo.bar%n" +
                "- the fields matching the following regexes were ignored in the comparison: f.*, .ba., ..b%%sr..%n"+
                "- the following types were ignored in the comparison: java.util.UUID, java.time.ZonedDateTime%n" +
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
index 3df89f53e..c04c20ac0 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_shouldIgnoreFields_Test.java
@@ -55,7 +55,7 @@ public class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
   }
 
   @ParameterizedTest(name = "{0} should be ignored")
-  @MethodSource("ignoringNullFieldsSource")
+  @MethodSource("ignoringNullActualFieldsSource")
   public void should_ignore_actual_null_fields(DualValue dualValue) {
     // GIVEN
     recursiveComparisonConfiguration.setIgnoreAllActualNullFields(true);
@@ -65,7 +65,7 @@ public class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
     assertThat(ignored).as("%s should be ignored", dualValue).isTrue();
   }
 
-  private static Stream<Arguments> ignoringNullFieldsSource() {
+  private static Stream<Arguments> ignoringNullActualFieldsSource() {
     return Stream.of(arguments(dualValue(null, "John")),
                      arguments(dualValue(null, 123)),
                      arguments(dualValue(null, (Object) null)),
@@ -73,6 +73,25 @@ public class RecursiveComparisonConfiguration_shouldIgnoreFields_Test {
 
   }
 
+  @ParameterizedTest(name = "{0} should be ignored")
+  @MethodSource("ignoringNullExpectedFieldsSource")
+  public void should_ignore_expected_null_fields(DualValue dualValue) {
+    // GIVEN
+    recursiveComparisonConfiguration.setIgnoreAllExpectedNullFields(true);
+    // WHEN
+    boolean ignored = recursiveComparisonConfiguration.shouldIgnore(dualValue);
+    // THEN
+    assertThat(ignored).as("%s should be ignored", dualValue).isTrue();
+  }
+
+  private static Stream<Arguments> ignoringNullExpectedFieldsSource() {
+    return Stream.of(arguments(dualValue("John", null)),
+                     arguments(dualValue(123, null)),
+                     arguments(dualValue(null, (Object) null)),
+                     arguments(dualValue(new Date(), null)));
+
+  }
+
   @ParameterizedTest(name = "{0} should be ignored with these ignored fields {1}")
   @MethodSource("ignoringSpecifiedFieldsSource")
   public void should_ignore_specified_fields(DualValue dualValue, List<String> ignoredFields) {
