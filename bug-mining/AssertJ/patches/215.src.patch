diff --git a/src/main/java/org/assertj/core/api/AbstractDoubleArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractDoubleArrayAssert.java
index d4a3d93b2..07ecbecf6 100755
--- a/src/main/java/org/assertj/core/api/AbstractDoubleArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractDoubleArrayAssert.java
@@ -21,11 +21,11 @@ import org.assertj.core.internal.DoubleArrays;
 import org.assertj.core.util.VisibleForTesting;
 
 public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAssert<S>>
-  extends AbstractArrayAssert<S, double[], Double> {
+    extends AbstractArrayAssert<S, double[], Double> {
 
   @VisibleForTesting
   protected DoubleArrays arrays = DoubleArrays.instance();
-  
+
   private final ComparatorFactory doubleComparator = ComparatorFactory.INSTANCE;
 
   public AbstractDoubleArrayAssert(double[] actual, Class<?> selfType) {
@@ -117,7 +117,7 @@ public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAss
     return myself;
   }
 
- /**
+  /**
    * Verifies that the actual array contains the given values, in any order, 
    * the comparison is done at the given precision/offset set with {@link Assertions#withPrecision(Double)}.
    * <p>
@@ -158,7 +158,7 @@ public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAss
    *                   .containsOnly(2.0, 3.0, 1.0)
    *                   .usingComparatorWithPrecision(0.5)
    *                   .containsOnly(1.1, 3.1, 2.1);
-
+  
    * // assertions will fail
    * assertThat(values).containsOnly(1.0, 4.0, 2.0, 3.0);
    * assertThat(values).containsOnly(4.0, 7.0);
@@ -244,28 +244,28 @@ public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAss
     return myself;
   }
 
-   /**
-   * Verifies that the actual array contains the given values only once.
-   * The comparison is done at the given precision/offset set with {@link Assertions#withPrecision(Double)}.
-   * <p>
-   * Examples :
-   * <pre><code class='java'> // assertion will pass
-   * assertThat(new double[] { 1.0, 2.0, 3.0 }).containsOnlyOnce(new double[] {1.1, 2.0}, withPrecision(0.2));
-   *
-   * // assertions will fail
-   * assertThat(new double[] { 1.0, 2.0, 1.0 }).containsOnlyOnce(new double[] {1.05}, withPrecision(0.1));
-   * assertThat(new double[] { 1.0, 2.0, 3.0 }).containsOnlyOnce(new double[] {4.0}, withPrecision(0.1));
-   * assertThat(new double[] { 1.0, 2.0, 3.0, 3.0 }).containsOnlyOnce(new double[] {0.1, 0.9, 2.0, 3.11, 4.0, 5.0}, withPrecision(0.2));</code></pre>
-   *
-   * @param values the given values.
-   * @param precision the precision under which the value may vary
-   * @return {@code this} assertion object.
-   * @throws NullPointerException if the given argument is {@code null}.
-   * @throws IllegalArgumentException if the given argument is an empty array.
-   * @throws AssertionError if the actual array is {@code null}.
-   * @throws AssertionError if the actual group does not contain the given values, i.e. the actual group contains some
-   *           or none of the given values, or the actual group contains more than once these values.
-   */
+  /**
+  * Verifies that the actual array contains the given values only once.
+  * The comparison is done at the given precision/offset set with {@link Assertions#withPrecision(Double)}.
+  * <p>
+  * Examples :
+  * <pre><code class='java'> // assertion will pass
+  * assertThat(new double[] { 1.0, 2.0, 3.0 }).containsOnlyOnce(new double[] {1.1, 2.0}, withPrecision(0.2));
+  *
+  * // assertions will fail
+  * assertThat(new double[] { 1.0, 2.0, 1.0 }).containsOnlyOnce(new double[] {1.05}, withPrecision(0.1));
+  * assertThat(new double[] { 1.0, 2.0, 3.0 }).containsOnlyOnce(new double[] {4.0}, withPrecision(0.1));
+  * assertThat(new double[] { 1.0, 2.0, 3.0, 3.0 }).containsOnlyOnce(new double[] {0.1, 0.9, 2.0, 3.11, 4.0, 5.0}, withPrecision(0.2));</code></pre>
+  *
+  * @param values the given values.
+  * @param precision the precision under which the value may vary
+  * @return {@code this} assertion object.
+  * @throws NullPointerException if the given argument is {@code null}.
+  * @throws IllegalArgumentException if the given argument is an empty array.
+  * @throws AssertionError if the actual array is {@code null}.
+  * @throws AssertionError if the actual group does not contain the given values, i.e. the actual group contains some
+  *           or none of the given values, or the actual group contains more than once these values.
+  */
   public S containsOnlyOnce(double[] values, Offset<Double> precision) {
     usingComparatorWithPrecision(precision.value);
     return containsOnlyOnce(values);
@@ -304,7 +304,6 @@ public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAss
     return myself;
   }
 
-
   /**
    * Verifies that the actual array contains the given sequence, without any other values between them.
    * The comparison is done at the given precision/offset set with {@link Assertions#withPrecision(Double)}.
@@ -490,7 +489,7 @@ public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAss
    * @throws AssertionError if the actual array contains any of the given values.
    */
   public S doesNotContain(double... values) {
-      arrays.assertDoesNotContain(info, actual, values);
+    arrays.assertDoesNotContain(info, actual, values);
     return myself;
   }
 
@@ -631,7 +630,7 @@ public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAss
     usingComparatorWithPrecision(precision.value);
     return doesNotHaveDuplicates();
   }
-  
+
   /**
    * Verifies that the actual array starts with the given sequence of values, without any other values between them.
    * Similar to <code>{@link #containsSequence(double...)}</code>, but it also verifies that the first element in the
@@ -695,7 +694,6 @@ public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAss
     return startsWith(values);
   }
 
-  
   /**
    * Verifies that the actual array ends with the given sequence of values, without any other values between them.
    * Similar to <code>{@link #containsSequence(double...)}</code>, but it also verifies that the last element in the
@@ -812,7 +810,7 @@ public abstract class AbstractDoubleArrayAssert<S extends AbstractDoubleArrayAss
    *           or values are the same but the order is not.
    */
   public S containsExactly(double... values) {
-	arrays.assertContainsExactly(info, actual, values);
+    arrays.assertContainsExactly(info, actual, values);
     return myself;
   }
 
diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index bb7ac6097..8faa4318e 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -1460,7 +1460,6 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null} or empty.
    * @throws IntrospectionError if the given propertyOrFieldName can't be found in one of the iterable elements.
    */
-  @SuppressWarnings("unchecked")
   public AbstractListAssert<?, List<? extends ELEMENT>, ELEMENT, ObjectAssert<ELEMENT>> filteredOn(String propertyOrFieldName,
                                                                                                    Object expectedValue) {
     Filters<? extends ELEMENT> filter = filter((Iterable<? extends ELEMENT>) actual);
@@ -1578,7 +1577,6 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * @return a new assertion object with the filtered iterable under test
    * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null} or empty.
    */
-  @SuppressWarnings("unchecked")
   public AbstractListAssert<?, List<? extends ELEMENT>, ELEMENT, ObjectAssert<ELEMENT>> filteredOn(String propertyOrFieldName,
                                                                                                    FilterOperator<?> filterOperator) {
     checkNotNull(filterOperator);
@@ -1619,7 +1617,6 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * @return a new assertion object with the filtered iterable under test
    * @throws IllegalArgumentException if the given condition is {@code null}.
    */
-  @SuppressWarnings("unchecked")
   public AbstractListAssert<?, List<? extends ELEMENT>, ELEMENT, ObjectAssert<ELEMENT>> filteredOn(Condition<? super ELEMENT> condition) {
     Filters<? extends ELEMENT> filter = filter((Iterable<? extends ELEMENT>) actual);
     Iterable<? extends ELEMENT> filteredIterable = filter.being(condition).get();
diff --git a/src/main/java/org/assertj/core/internal/Arrays.java b/src/main/java/org/assertj/core/internal/Arrays.java
index 994302c2b..3691e39ed 100644
--- a/src/main/java/org/assertj/core/internal/Arrays.java
+++ b/src/main/java/org/assertj/core/internal/Arrays.java
@@ -57,6 +57,7 @@ import static org.assertj.core.internal.CommonErrors.iterableToLookForIsNull;
 import static org.assertj.core.internal.CommonValidations.checkIndexValueIsValid;
 import static org.assertj.core.internal.CommonValidations.checkIterableIsNotNull;
 import static org.assertj.core.internal.CommonValidations.hasSameSizeAsCheck;
+import static org.assertj.core.internal.IterableDiff.diff;
 import static org.assertj.core.util.ArrayWrapperList.wrap;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.IterableUtil.isNullOrEmpty;
@@ -96,21 +97,21 @@ public class Arrays {
    * @return the singleton instance of this class based on {@link StandardComparisonStrategy}.
    */
   static Arrays instance() {
-	return INSTANCE;
+    return INSTANCE;
   }
 
   public Arrays() {
-	this(StandardComparisonStrategy.instance());
+    this(StandardComparisonStrategy.instance());
   }
 
   public Arrays(ComparisonStrategy comparisonStrategy) {
-	this.comparisonStrategy = comparisonStrategy;
+    this.comparisonStrategy = comparisonStrategy;
   }
 
   @VisibleForTesting
   public Comparator<?> getComparator() {
-	if (!(comparisonStrategy instanceof ComparatorBasedComparisonStrategy)) return null;
-	return ((ComparatorBasedComparisonStrategy) comparisonStrategy).getComparator();
+    if (!(comparisonStrategy instanceof ComparatorBasedComparisonStrategy)) return null;
+    return ((ComparatorBasedComparisonStrategy) comparisonStrategy).getComparator();
   }
 
   @VisibleForTesting
@@ -119,94 +120,94 @@ public class Arrays {
   }
 
   public static void assertIsArray(AssertionInfo info, Object array) {
-	if (!isArray(array)) throw Failures.instance().failure(info, shouldBeAnArray(array));
+    if (!isArray(array)) throw Failures.instance().failure(info, shouldBeAnArray(array));
   }
 
   void assertNullOrEmpty(AssertionInfo info, Failures failures, Object array) {
-	if (array != null && !isArrayEmpty(array)) throw failures.failure(info, shouldBeNullOrEmpty(array));
+    if (array != null && !isArrayEmpty(array)) throw failures.failure(info, shouldBeNullOrEmpty(array));
   }
 
   void assertEmpty(AssertionInfo info, Failures failures, Object array) {
-	assertNotNull(info, array);
-	if (!isArrayEmpty(array)) throw failures.failure(info, shouldBeEmpty(array));
+    assertNotNull(info, array);
+    if (!isArrayEmpty(array)) throw failures.failure(info, shouldBeEmpty(array));
   }
 
   void assertHasSize(AssertionInfo info, Failures failures, Object array, int expectedSize) {
-	assertNotNull(info, array);
-	int sizeOfActual = sizeOf(array);
-	if (sizeOfActual != expectedSize) throw failures.failure(info, shouldHaveSize(array, sizeOfActual, expectedSize));
+    assertNotNull(info, array);
+    int sizeOfActual = sizeOf(array);
+    if (sizeOfActual != expectedSize) throw failures.failure(info, shouldHaveSize(array, sizeOfActual, expectedSize));
   }
 
   void assertHasSameSizeAs(AssertionInfo info, Object array, Iterable<?> other) {
-	assertNotNull(info, array);
-	hasSameSizeAsCheck(info, array, other, sizeOf(array));
+    assertNotNull(info, array);
+    hasSameSizeAsCheck(info, array, other, sizeOf(array));
   }
 
   public void assertHasSameSizeAs(AssertionInfo info, Object array, Object other) {
-	assertNotNull(info, array);
-	assertIsArray(info, array);
-	assertIsArray(info, other);
-	hasSameSizeAsCheck(info, array, other, sizeOf(array));
+    assertNotNull(info, array);
+    assertIsArray(info, array);
+    assertIsArray(info, other);
+    hasSameSizeAsCheck(info, array, other, sizeOf(array));
   }
 
   void assertContains(AssertionInfo info, Failures failures, Object actual, Object values) {
-	if (commonChecks(info, actual, values)) return;
-	Set<Object> notFound = new LinkedHashSet<>();
-	int valueCount = sizeOf(values);
-	for (int i = 0; i < valueCount; i++) {
-	  Object value = Array.get(values, i);
-	  if (!arrayContains(actual, value)) notFound.add(value);
-	}
-	if (!notFound.isEmpty())
-	  throw failures.failure(info, shouldContain(actual, values, notFound, comparisonStrategy));
+    if (commonChecks(info, actual, values)) return;
+    Set<Object> notFound = new LinkedHashSet<>();
+    int valueCount = sizeOf(values);
+    for (int i = 0; i < valueCount; i++) {
+      Object value = Array.get(values, i);
+      if (!arrayContains(actual, value)) notFound.add(value);
+    }
+    if (!notFound.isEmpty())
+      throw failures.failure(info, shouldContain(actual, values, notFound, comparisonStrategy));
   }
 
   void assertcontainsAll(AssertionInfo info, Failures failures, Object array, Iterable<?> iterable) {
-	if (iterable == null) throw iterableToLookForIsNull();
-	assertNotNull(info, array);
-	Object[] values = newArrayList(iterable).toArray();
-	Set<Object> notFound = new LinkedHashSet<>();
-	for (Object value : values) {
-	  if (!arrayContains(array, value)) notFound.add(value);
-	}
-	if (!notFound.isEmpty())
-	  throw failures.failure(info, shouldContain(array, values, notFound, comparisonStrategy));
+    if (iterable == null) throw iterableToLookForIsNull();
+    assertNotNull(info, array);
+    Object[] values = newArrayList(iterable).toArray();
+    Set<Object> notFound = new LinkedHashSet<>();
+    for (Object value : values) {
+      if (!arrayContains(array, value)) notFound.add(value);
+    }
+    if (!notFound.isEmpty())
+      throw failures.failure(info, shouldContain(array, values, notFound, comparisonStrategy));
   }
 
   void assertContains(AssertionInfo info, Failures failures, Object array, Object value, Index index) {
-	assertNotNull(info, array);
-	assertNotEmpty(info, failures, array);
-	checkIndexValueIsValid(index, sizeOf(array) - 1);
-	Object actualElement = Array.get(array, index.value);
-	if (!areEqual(actualElement, value))
-	  throw failures.failure(info, shouldContainAtIndex(array, value, index, Array.get(array, index.value),
-	                                                    comparisonStrategy));
+    assertNotNull(info, array);
+    assertNotEmpty(info, failures, array);
+    checkIndexValueIsValid(index, sizeOf(array) - 1);
+    Object actualElement = Array.get(array, index.value);
+    if (!areEqual(actualElement, value))
+      throw failures.failure(info, shouldContainAtIndex(array, value, index, Array.get(array, index.value),
+                                                        comparisonStrategy));
   }
 
   void assertNotEmpty(AssertionInfo info, Failures failures, Object array) {
-	assertNotNull(info, array);
-	if (isArrayEmpty(array)) throw failures.failure(info, shouldNotBeEmpty());
+    assertNotNull(info, array);
+    if (isArrayEmpty(array)) throw failures.failure(info, shouldNotBeEmpty());
   }
 
   void assertDoesNotContain(AssertionInfo info, Failures failures, Object array, Object value, Index index) {
-	assertNotNull(info, array);
-	checkIndexValueIsValid(index, Integer.MAX_VALUE);
-	if (index.value >= sizeOf(array)) return;
-	if (areEqual(Array.get(array, index.value), value))
-	  throw failures.failure(info, shouldNotContainAtIndex(array, value, index, comparisonStrategy));
+    assertNotNull(info, array);
+    checkIndexValueIsValid(index, Integer.MAX_VALUE);
+    if (index.value >= sizeOf(array)) return;
+    if (areEqual(Array.get(array, index.value), value))
+      throw failures.failure(info, shouldNotContainAtIndex(array, value, index, comparisonStrategy));
   }
 
   void assertContainsOnly(AssertionInfo info, Failures failures, Object actual, Object values) {
-	if (commonChecks(info, actual, values)) return;
-    List<Object> notExpected = asListWithoutDuplicatesAccordingToComparisonStrategy(actual);
-    List<Object> notFound = containsOnly(notExpected, values);
-	if (notExpected.isEmpty() && notFound.isEmpty()) return;
-	throw failures.failure(info, shouldContainOnly(actual, values, notFound, notExpected, comparisonStrategy));
+    if (commonChecks(info, actual, values)) return;
+    IterableDiff diff = diff(asList(actual), asList(values), comparisonStrategy);
+    if (diff.differencesFound())
+      throw failures.failure(info, shouldContainOnly(actual, values,
+                                                     diff.missing, diff.unexpected,
+                                                     comparisonStrategy));
   }
 
   void assertContainsExactly(AssertionInfo info, Failures failures, Object actual, Object values) {
-	if (commonChecks(info, actual, values)) return;
-    assertNotNull(info, actual);
+    if (commonChecks(info, actual, values)) return;
     assertIsArray(info, actual);
     assertIsArray(info, values);
     int actualSize = sizeOf(actual);
@@ -214,102 +215,64 @@ public class Arrays {
     if (actualSize != expectedSize)
       throw failures.failure(info, shouldHaveSameSize(actual, values, actualSize, expectedSize, comparisonStrategy));
 
-    List<Object> actualWithoutDuplicates = asListWithoutDuplicatesAccordingToComparisonStrategy(actual);
-    List<Object> notFound = containsOnly(actualWithoutDuplicates, values);
-	if (actualWithoutDuplicates.isEmpty() && notFound.isEmpty()) {
-	  // actual and values have the same elements but are they in the same order ?
-	  int arrayLength = sizeOf(actual);
-	  for (int i = 0; i < arrayLength; i++) {
-		Object actualElement = Array.get(actual, i);
-		Object expectedElement = Array.get(values, i);
-		if (!areEqual(actualElement, expectedElement)) {
-		  throw failures.failure(info, elementsDifferAtIndex(actualElement, expectedElement, i, comparisonStrategy));
-		}
-	  }
-	  return;
-	}
-	throw failures.failure(info,
-	                       shouldContainExactly(actual, values, notFound, actualWithoutDuplicates, comparisonStrategy));
-  }
-
-	void assertContainsExactlyInAnyOrder(AssertionInfo info, Failures failures, Object actual, Object values) {
-		if (commonChecks(info, actual, values)) return;
-		List<Object> notExpected = asList(actual);
-		List<Object> notFound = asList(values);
+    List<Object> actualAsList = asList(actual);
+    IterableDiff diff = diff(actualAsList, asList(values), comparisonStrategy);
+    if (!diff.differencesFound()) {
+      // actual and values have the same elements but are they in the same order ?
+      int arrayLength = sizeOf(actual);
+      for (int i = 0; i < arrayLength; i++) {
+        Object actualElement = Array.get(actual, i);
+        Object expectedElement = Array.get(values, i);
+        if (!areEqual(actualElement, expectedElement))
+          throw failures.failure(info, elementsDifferAtIndex(actualElement, expectedElement, i, comparisonStrategy));
+      }
+      return;
+    }
+    throw failures.failure(info,
+                           shouldContainExactly(actual, values, diff.missing, diff.unexpected, comparisonStrategy));
+  }
+
+  void assertContainsExactlyInAnyOrder(AssertionInfo info, Failures failures, Object actual, Object values) {
+    if (commonChecks(info, actual, values)) return;
+    List<Object> notExpected = asList(actual);
+    List<Object> notFound = asList(values);
 
     for (Object value : asList(values)) {
-      if(iterableContains(notExpected, value)) {
-
+      if (iterableContains(notExpected, value)) {
         iterablesRemoveFirst(notExpected, value);
         iterablesRemoveFirst(notFound, value);
       }
     }
 
-    if(notExpected.isEmpty() && notFound.isEmpty()) {
-      return;
-    }
-
-    throw failures.failure(info, shouldContainExactlyInAnyOrder(actual, values, notFound, notExpected, comparisonStrategy));
-	}
+    if (notExpected.isEmpty() && notFound.isEmpty()) return;
 
-  void assertContainsOnlyOnce(AssertionInfo info, Failures failures, Object actual, Object values) {
-	if (commonChecks(info, actual, values))
-	  return;
-	Iterable<?> actualDuplicates = comparisonStrategy.duplicatesFrom(asList(actual));
-	Set<Object> notFound = new LinkedHashSet<>();
-	Set<Object> notOnlyOnce = new LinkedHashSet<>();
-	for (Object expectedElement : asList(values)) {
-	  if (!arrayContains(actual, expectedElement)) {
-		notFound.add(expectedElement);
-	  } else if (iterableContains(actualDuplicates, expectedElement)) {
-		notOnlyOnce.add(expectedElement);
-	  }
-	}
-	if (!notFound.isEmpty() || !notOnlyOnce.isEmpty())
-	  throw failures.failure(info, shouldContainsOnlyOnce(actual, values, notFound, notOnlyOnce, comparisonStrategy));
-	// assertion succeeded
-  }
-
-  private List<Object> containsOnly(Collection<Object> actual, Object values) {
-    List<Object> notFound = new ArrayList<>();
-	for (Object o : asListWithoutDuplicatesAccordingToComparisonStrategy(values)) {
-	  if (iterableContains(actual, o)) {
-		iterableRemoves(actual, o);
-	  } else {
-		notFound.add(o);
-	  }
-	}
-	return notFound;
+    throw failures.failure(info,
+                           shouldContainExactlyInAnyOrder(actual, values, notFound, notExpected, comparisonStrategy));
   }
 
-  /**
-   * build a Set with that avoid duplicates <b>according to given comparison strategy</b>
-   * 
-   * @param array to feed the Set we want to build
-   * @return a Set without duplicates <b>according to given comparison strategy</b>
-   */
-  private List<Object> asListWithoutDuplicatesAccordingToComparisonStrategy(Object array) {
-    List<Object> list = new ArrayList<>();
-	int size = sizeOf(array);
-	for (int i = 0; i < size; i++) {
-	  Object element = Array.get(array, i);
-	  if (!iterableContains(list, element)) list.add(element);
-	}
-	return list;
+  void assertContainsOnlyOnce(AssertionInfo info, Failures failures, Object actual, Object values) {
+    if (commonChecks(info, actual, values))
+      return;
+    Iterable<?> actualDuplicates = comparisonStrategy.duplicatesFrom(asList(actual));
+    Set<Object> notFound = new LinkedHashSet<>();
+    Set<Object> notOnlyOnce = new LinkedHashSet<>();
+    for (Object expectedElement : asList(values)) {
+      if (!arrayContains(actual, expectedElement)) {
+        notFound.add(expectedElement);
+      } else if (iterableContains(actualDuplicates, expectedElement)) {
+        notOnlyOnce.add(expectedElement);
+      }
+    }
+    if (!notFound.isEmpty() || !notOnlyOnce.isEmpty())
+      throw failures.failure(info, shouldContainsOnlyOnce(actual, values, notFound, notOnlyOnce, comparisonStrategy));
+    // assertion succeeded
   }
 
   /**
    * Delegates to {@link ComparisonStrategy#iterableContains(Iterable, Object)}
    */
   private boolean iterableContains(Iterable<?> actual, Object value) {
-	return comparisonStrategy.iterableContains(actual, value);
-  }
-
-  /**
-   * Delegates to {@link ComparisonStrategy#iterableRemoves(Iterable, Object)}
-   */
-  private void iterableRemoves(Collection<?> actual, Object value) {
-	comparisonStrategy.iterableRemoves(actual, value);
+    return comparisonStrategy.iterableContains(actual, value);
   }
 
   private void iterablesRemoveFirst(Collection<?> actual, Object value) {
@@ -317,13 +280,13 @@ public class Arrays {
   }
 
   void assertContainsSequence(AssertionInfo info, Failures failures, Object actual, Object sequence) {
-	if (commonChecks(info, actual, sequence)) return;
-	// look for given sequence, stop check when there is not enough elements remaining in actual to contain sequence
-	int lastIndexWhereSequeceCanBeFound = sizeOf(actual) - sizeOf(sequence);
-	for (int actualIndex = 0; actualIndex <= lastIndexWhereSequeceCanBeFound; actualIndex++) {
-	  if (containsSequenceAtGivenIndex(actualIndex, actual, sequence)) return;
-	}
-	throw failures.failure(info, shouldContainSequence(actual, sequence, comparisonStrategy));
+    if (commonChecks(info, actual, sequence)) return;
+    // look for given sequence, stop check when there is not enough elements remaining in actual to contain sequence
+    int lastIndexWhereSequeceCanBeFound = sizeOf(actual) - sizeOf(sequence);
+    for (int actualIndex = 0; actualIndex <= lastIndexWhereSequeceCanBeFound; actualIndex++) {
+      if (containsSequenceAtGivenIndex(actualIndex, actual, sequence)) return;
+    }
+    throw failures.failure(info, shouldContainSequence(actual, sequence, comparisonStrategy));
   }
 
   /**
@@ -336,346 +299,346 @@ public class Arrays {
    * @return true if actualArray contains exactly the given sequence at given starting index, false otherwise.
    */
   private boolean containsSequenceAtGivenIndex(int actualStartIndex, Object actualArray, Object sequence) {
-	int sequenceSize = sizeOf(sequence);
-	for (int i = 0; i < sequenceSize; i++) {
-	  if (areEqual(Array.get(sequence, i), Array.get(actualArray, i + actualStartIndex)))
-		continue;
-	  return false;
-	}
-	return true;
+    int sequenceSize = sizeOf(sequence);
+    for (int i = 0; i < sequenceSize; i++) {
+      if (areEqual(Array.get(sequence, i), Array.get(actualArray, i + actualStartIndex)))
+        continue;
+      return false;
+    }
+    return true;
   }
 
   void assertContainsSubsequence(AssertionInfo info, Failures failures, Object actual, Object subsequence) {
-	if (commonChecks(info, actual, subsequence)) return;
-
-	int sizeOfActual = sizeOf(actual);
-	int sizeOfSubsequence = sizeOf(subsequence);
-	// look for given subsequence, stop check when there is not enough elements remaining in actual to contain
-	// subsequence
-	int lastIndexWhereEndOfSubsequeceCanBeFound = sizeOfActual - sizeOfSubsequence;
-
-	int actualIndex = 0;
-	int subsequenceIndex = 0;
-	while (actualIndex <= lastIndexWhereEndOfSubsequeceCanBeFound && subsequenceIndex < sizeOfSubsequence) {
-	  if (areEqual(Array.get(actual, actualIndex), Array.get(subsequence, subsequenceIndex))) {
-		subsequenceIndex++;
-		lastIndexWhereEndOfSubsequeceCanBeFound++;
-	  }
-	  actualIndex++;
-	}
-	if (subsequenceIndex < sizeOfSubsequence)
-	  throw failures.failure(info, shouldContainSubsequence(actual, subsequence, comparisonStrategy));
+    if (commonChecks(info, actual, subsequence)) return;
+
+    int sizeOfActual = sizeOf(actual);
+    int sizeOfSubsequence = sizeOf(subsequence);
+    // look for given subsequence, stop check when there is not enough elements remaining in actual to contain
+    // subsequence
+    int lastIndexWhereEndOfSubsequeceCanBeFound = sizeOfActual - sizeOfSubsequence;
+
+    int actualIndex = 0;
+    int subsequenceIndex = 0;
+    while (actualIndex <= lastIndexWhereEndOfSubsequeceCanBeFound && subsequenceIndex < sizeOfSubsequence) {
+      if (areEqual(Array.get(actual, actualIndex), Array.get(subsequence, subsequenceIndex))) {
+        subsequenceIndex++;
+        lastIndexWhereEndOfSubsequeceCanBeFound++;
+      }
+      actualIndex++;
+    }
+    if (subsequenceIndex < sizeOfSubsequence)
+      throw failures.failure(info, shouldContainSubsequence(actual, subsequence, comparisonStrategy));
   }
 
   /**
    * Delegates to {@link ComparisonStrategy#areEqual(Object, Object)}
    */
   private boolean areEqual(Object actual, Object other) {
-	return comparisonStrategy.areEqual(actual, other);
+    return comparisonStrategy.areEqual(actual, other);
   }
 
   void assertDoesNotContain(AssertionInfo info, Failures failures, Object array, Object values) {
-	checkIsNotNullAndNotEmpty(values);
-	assertNotNull(info, array);
-	Set<Object> found = new LinkedHashSet<>();
-	int valuesSize = sizeOf(values);
-	for (int i = 0; i < valuesSize; i++) {
-	  Object value = Array.get(values, i);
-	  if (arrayContains(array, value)) found.add(value);
-	}
-	if (!found.isEmpty()) throw failures.failure(info, shouldNotContain(array, values, found, comparisonStrategy));
+    checkIsNotNullAndNotEmpty(values);
+    assertNotNull(info, array);
+    Set<Object> found = new LinkedHashSet<>();
+    int valuesSize = sizeOf(values);
+    for (int i = 0; i < valuesSize; i++) {
+      Object value = Array.get(values, i);
+      if (arrayContains(array, value)) found.add(value);
+    }
+    if (!found.isEmpty()) throw failures.failure(info, shouldNotContain(array, values, found, comparisonStrategy));
   }
 
   /**
    * Delegates to {@link ComparisonStrategy#arrayContains(Object, Object)}
    */
   private boolean arrayContains(Object array, Object value) {
-	return comparisonStrategy.arrayContains(array, value);
+    return comparisonStrategy.arrayContains(array, value);
   }
 
   void assertDoesNotHaveDuplicates(AssertionInfo info, Failures failures, Object array) {
-	assertNotNull(info, array);
-	ArrayWrapperList wrapped = wrap(array);
-	Iterable<?> duplicates = comparisonStrategy.duplicatesFrom(wrapped);
-	if (!isNullOrEmpty(duplicates))
-	  throw failures.failure(info, shouldNotHaveDuplicates(array, duplicates, comparisonStrategy));
+    assertNotNull(info, array);
+    ArrayWrapperList wrapped = wrap(array);
+    Iterable<?> duplicates = comparisonStrategy.duplicatesFrom(wrapped);
+    if (!isNullOrEmpty(duplicates))
+      throw failures.failure(info, shouldNotHaveDuplicates(array, duplicates, comparisonStrategy));
   }
 
   void assertStartsWith(AssertionInfo info, Failures failures, Object actual, Object sequence) {
-	if (commonChecks(info, actual, sequence))
-	  return;
-	int sequenceSize = sizeOf(sequence);
-	int arraySize = sizeOf(actual);
-	if (arraySize < sequenceSize) throw arrayDoesNotStartWithSequence(info, failures, actual, sequence);
-	for (int i = 0; i < sequenceSize; i++) {
-	  if (!areEqual(Array.get(sequence, i), Array.get(actual, i)))
-		throw arrayDoesNotStartWithSequence(info, failures, actual, sequence);
-	}
+    if (commonChecks(info, actual, sequence))
+      return;
+    int sequenceSize = sizeOf(sequence);
+    int arraySize = sizeOf(actual);
+    if (arraySize < sequenceSize) throw arrayDoesNotStartWithSequence(info, failures, actual, sequence);
+    for (int i = 0; i < sequenceSize; i++) {
+      if (!areEqual(Array.get(sequence, i), Array.get(actual, i)))
+        throw arrayDoesNotStartWithSequence(info, failures, actual, sequence);
+    }
   }
 
   private static boolean commonChecks(AssertionInfo info, Object actual, Object sequence) {
-	checkIsNotNull(sequence);
-	assertNotNull(info, actual);
-	// if both actual and values are empty arrays, then assertion passes.
-	if (isArrayEmpty(actual) && isArrayEmpty(sequence)) return true;
-	failIfEmptySinceActualIsNotEmpty(sequence);
-	return false;
+    checkIsNotNull(sequence);
+    assertNotNull(info, actual);
+    // if both actual and values are empty arrays, then assertion passes.
+    if (isArrayEmpty(actual) && isArrayEmpty(sequence)) return true;
+    failIfEmptySinceActualIsNotEmpty(sequence);
+    return false;
   }
 
   private AssertionError arrayDoesNotStartWithSequence(AssertionInfo info, Failures failures, Object array,
-	                                                   Object sequence) {
-	return failures.failure(info, shouldStartWith(array, sequence, comparisonStrategy));
+                                                       Object sequence) {
+    return failures.failure(info, shouldStartWith(array, sequence, comparisonStrategy));
   }
 
   void assertEndsWith(AssertionInfo info, Failures failures, Object actual, Object sequence) {
-	if (commonChecks(info, actual, sequence)) return;
-	int sequenceSize = sizeOf(sequence);
-	int arraySize = sizeOf(actual);
-	if (arraySize < sequenceSize) throw arrayDoesNotEndWithSequence(info, failures, actual, sequence);
-	for (int i = 0; i < sequenceSize; i++) {
-	  int sequenceIndex = sequenceSize - (i + 1);
-	  int arrayIndex = arraySize - (i + 1);
-	  if (!areEqual(Array.get(sequence, sequenceIndex), Array.get(actual, arrayIndex)))
-		throw arrayDoesNotEndWithSequence(info, failures, actual, sequence);
-	}
+    if (commonChecks(info, actual, sequence)) return;
+    int sequenceSize = sizeOf(sequence);
+    int arraySize = sizeOf(actual);
+    if (arraySize < sequenceSize) throw arrayDoesNotEndWithSequence(info, failures, actual, sequence);
+    for (int i = 0; i < sequenceSize; i++) {
+      int sequenceIndex = sequenceSize - (i + 1);
+      int arrayIndex = arraySize - (i + 1);
+      if (!areEqual(Array.get(sequence, sequenceIndex), Array.get(actual, arrayIndex)))
+        throw arrayDoesNotEndWithSequence(info, failures, actual, sequence);
+    }
   }
 
   public void assertIsSubsetOf(AssertionInfo info, Failures failures, Object actual, Iterable<?> values) {
-	assertNotNull(info, actual);
-	checkIterableIsNotNull(info, values);
-	List<Object> extra = newArrayList();
-	int sizeOfActual = sizeOf(actual);
-	for (int i = 0; i < sizeOfActual; i++) {
-	  Object actualElement = Array.get(actual, i);
-	  if (!iterableContains(values, actualElement)) {
-		extra.add(actualElement);
-	  }
-	}
-	if (extra.size() > 0) {
-	  throw failures.failure(info, shouldBeSubsetOf(actual, values, extra, comparisonStrategy));
-	}
+    assertNotNull(info, actual);
+    checkIterableIsNotNull(info, values);
+    List<Object> extra = newArrayList();
+    int sizeOfActual = sizeOf(actual);
+    for (int i = 0; i < sizeOfActual; i++) {
+      Object actualElement = Array.get(actual, i);
+      if (!iterableContains(values, actualElement)) {
+        extra.add(actualElement);
+      }
+    }
+    if (extra.size() > 0) {
+      throw failures.failure(info, shouldBeSubsetOf(actual, values, extra, comparisonStrategy));
+    }
   }
 
   void assertContainsNull(AssertionInfo info, Failures failures, Object array) {
-	assertNotNull(info, array);
-	if (!arrayContains(array, null)) throw failures.failure(info, shouldContainNull(array));
+    assertNotNull(info, array);
+    if (!arrayContains(array, null)) throw failures.failure(info, shouldContainNull(array));
   }
 
   void assertDoesNotContainNull(AssertionInfo info, Failures failures, Object array) {
-	assertNotNull(info, array);
-	if (arrayContains(array, null)) throw failures.failure(info, shouldNotContainNull(array));
+    assertNotNull(info, array);
+    if (arrayContains(array, null)) throw failures.failure(info, shouldNotContainNull(array));
   }
 
   public <E> void assertAre(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                        Condition<E> condition) {
-	List<E> notMatchingCondition = getElementsNotMatchingCondition(info, failures, conditions, array, condition);
-	if (!notMatchingCondition.isEmpty())
-	  throw failures.failure(info, elementsShouldBe(array, notMatchingCondition, condition));
+                            Condition<E> condition) {
+    List<E> notMatchingCondition = getElementsNotMatchingCondition(info, failures, conditions, array, condition);
+    if (!notMatchingCondition.isEmpty())
+      throw failures.failure(info, elementsShouldBe(array, notMatchingCondition, condition));
   }
 
   public <E> void assertAreNot(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                           Condition<E> condition) {
-	List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
-	if (!matchingElements.isEmpty())
-	  throw failures.failure(info, elementsShouldNotBe(array, matchingElements, condition));
+                               Condition<E> condition) {
+    List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
+    if (!matchingElements.isEmpty())
+      throw failures.failure(info, elementsShouldNotBe(array, matchingElements, condition));
   }
 
   public <E> void assertHave(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                         Condition<E> condition) {
-	List<E> notMatchingCondition = getElementsNotMatchingCondition(info, failures, conditions, array, condition);
-	if (!notMatchingCondition.isEmpty())
-	  throw failures.failure(info, elementsShouldHave(array, notMatchingCondition, condition));
+                             Condition<E> condition) {
+    List<E> notMatchingCondition = getElementsNotMatchingCondition(info, failures, conditions, array, condition);
+    if (!notMatchingCondition.isEmpty())
+      throw failures.failure(info, elementsShouldHave(array, notMatchingCondition, condition));
   }
 
   public <E> void assertHaveNot(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                            Condition<E> condition) {
-	List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
-	if (!matchingElements.isEmpty())
-	  throw failures.failure(info, elementsShouldNotHave(array, matchingElements, condition));
+                                Condition<E> condition) {
+    List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
+    if (!matchingElements.isEmpty())
+      throw failures.failure(info, elementsShouldNotHave(array, matchingElements, condition));
   }
 
   public <E> void assertAreAtLeast(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                               int times, Condition<E> condition) {
-	List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
-	if (matchingElements.size() < times)
-	  throw failures.failure(info, elementsShouldBeAtLeast(array, times, condition));
+                                   int times, Condition<E> condition) {
+    List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
+    if (matchingElements.size() < times)
+      throw failures.failure(info, elementsShouldBeAtLeast(array, times, condition));
   }
 
   public <E> void assertAreAtMost(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                              int times, Condition<E> condition) {
-	List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
-	if (matchingElements.size() > times) throw failures.failure(info, elementsShouldBeAtMost(array, times, condition));
+                                  int times, Condition<E> condition) {
+    List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
+    if (matchingElements.size() > times) throw failures.failure(info, elementsShouldBeAtMost(array, times, condition));
   }
 
   public <E> void assertAreExactly(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                               int times, Condition<E> condition) {
-	List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
-	if (matchingElements.size() != times)
-	  throw failures.failure(info, elementsShouldBeExactly(array, times, condition));
+                                   int times, Condition<E> condition) {
+    List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
+    if (matchingElements.size() != times)
+      throw failures.failure(info, elementsShouldBeExactly(array, times, condition));
   }
 
   public <E> void assertHaveAtLeast(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                                int times, Condition<E> condition) {
-	List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
-	if (matchingElements.size() < times)
-	  throw failures.failure(info, elementsShouldHaveAtLeast(array, times, condition));
+                                    int times, Condition<E> condition) {
+    List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
+    if (matchingElements.size() < times)
+      throw failures.failure(info, elementsShouldHaveAtLeast(array, times, condition));
 
   }
 
   public <E> void assertHaveAtMost(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                               int times, Condition<E> condition) {
-	List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
-	if (matchingElements.size() > times)
-	  throw failures.failure(info, elementsShouldHaveAtMost(array, times, condition));
+                                   int times, Condition<E> condition) {
+    List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
+    if (matchingElements.size() > times)
+      throw failures.failure(info, elementsShouldHaveAtMost(array, times, condition));
 
   }
 
   public <E> void assertHaveExactly(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                                int times, Condition<E> condition) {
-	List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
-	if (matchingElements.size() != times)
-	  throw failures.failure(info, elementsShouldHaveExactly(array, times, condition));
+                                    int times, Condition<E> condition) {
+    List<E> matchingElements = getElementsMatchingCondition(info, failures, conditions, array, condition);
+    if (matchingElements.size() != times)
+      throw failures.failure(info, elementsShouldHaveExactly(array, times, condition));
   }
 
   private <E> List<E> getElementsMatchingCondition(AssertionInfo info, Failures failures, Conditions conditions,
-	                                               Object array, Condition<E> condition) {
-	return filterElements(info, failures, conditions, array, condition, false);
+                                                   Object array, Condition<E> condition) {
+    return filterElements(info, failures, conditions, array, condition, false);
   }
 
   private <E> List<E> getElementsNotMatchingCondition(AssertionInfo info, Failures failures, Conditions conditions,
-	                                                  Object array, Condition<E> condition) {
-	return filterElements(info, failures, conditions, array, condition, true);
+                                                      Object array, Condition<E> condition) {
+    return filterElements(info, failures, conditions, array, condition, true);
   }
 
   @SuppressWarnings("unchecked")
   private <E> List<E> filterElements(AssertionInfo info, Failures failures, Conditions conditions, Object array,
-	                                 Condition<E> condition, boolean negateCondition) throws AssertionError {
-	assertNotNull(info, array);
-	conditions.assertIsNotNull(condition);
-	try {
-	  List<E> filteredElements = new LinkedList<>();
-	  int arraySize = sizeOf(array);
-	  for (int i = 0; i < arraySize; i++) {
-		E element = (E) Array.get(array, i);
-		if (negateCondition ? !condition.matches(element) : condition.matches(element)) filteredElements.add(element);
-	  }
-	  return filteredElements;
-	} catch (ClassCastException e) {
-	  throw failures.failure(info, shouldBeSameGenericBetweenIterableAndCondition(array, condition));
-	}
+                                     Condition<E> condition, boolean negateCondition) throws AssertionError {
+    assertNotNull(info, array);
+    conditions.assertIsNotNull(condition);
+    try {
+      List<E> filteredElements = new LinkedList<>();
+      int arraySize = sizeOf(array);
+      for (int i = 0; i < arraySize; i++) {
+        E element = (E) Array.get(array, i);
+        if (negateCondition ? !condition.matches(element) : condition.matches(element)) filteredElements.add(element);
+      }
+      return filteredElements;
+    } catch (ClassCastException e) {
+      throw failures.failure(info, shouldBeSameGenericBetweenIterableAndCondition(array, condition));
+    }
   }
 
   void assertIsSorted(AssertionInfo info, Failures failures, Object array) {
-	assertNotNull(info, array);
-	if (comparisonStrategy instanceof ComparatorBasedComparisonStrategy) {
-	  // instead of comparing array elements with their natural comparator, use the one set by client.
-	  Comparator<?> comparator = ((ComparatorBasedComparisonStrategy) comparisonStrategy).getComparator();
-	  assertIsSortedAccordingToComparator(info, failures, array, comparator);
-	  return;
-	}
-	// empty arrays are considered sorted even if component type is not sortable.
-	if (sizeOf(array) == 0) return;
-	assertThatArrayComponentTypeIsSortable(info, failures, array);
-	try {
-	  // sorted assertion is only relevant if array elements are Comparable
-	  // => we should be able to build a Comparable array
-	  Comparable<Object>[] comparableArray = arrayOfComparableItems(array);
-	  // array with 0 or 1 element are considered sorted.
-	  if (comparableArray.length <= 1) return;
-	  for (int i = 0; i < comparableArray.length - 1; i++) {
-		// array is sorted in ascending order iif element i is less or equal than element i+1
-		if (comparableArray[i].compareTo(comparableArray[i + 1]) > 0)
-		  throw failures.failure(info, shouldBeSorted(i, array));
-	  }
-	} catch (ClassCastException e) {
-	  // elements are either not Comparable or not mutually Comparable (e.g. array with String and Integer)
-	  throw failures.failure(info, shouldHaveMutuallyComparableElements(array));
-	}
+    assertNotNull(info, array);
+    if (comparisonStrategy instanceof ComparatorBasedComparisonStrategy) {
+      // instead of comparing array elements with their natural comparator, use the one set by client.
+      Comparator<?> comparator = ((ComparatorBasedComparisonStrategy) comparisonStrategy).getComparator();
+      assertIsSortedAccordingToComparator(info, failures, array, comparator);
+      return;
+    }
+    // empty arrays are considered sorted even if component type is not sortable.
+    if (sizeOf(array) == 0) return;
+    assertThatArrayComponentTypeIsSortable(info, failures, array);
+    try {
+      // sorted assertion is only relevant if array elements are Comparable
+      // => we should be able to build a Comparable array
+      Comparable<Object>[] comparableArray = arrayOfComparableItems(array);
+      // array with 0 or 1 element are considered sorted.
+      if (comparableArray.length <= 1) return;
+      for (int i = 0; i < comparableArray.length - 1; i++) {
+        // array is sorted in ascending order iif element i is less or equal than element i+1
+        if (comparableArray[i].compareTo(comparableArray[i + 1]) > 0)
+          throw failures.failure(info, shouldBeSorted(i, array));
+      }
+    } catch (ClassCastException e) {
+      // elements are either not Comparable or not mutually Comparable (e.g. array with String and Integer)
+      throw failures.failure(info, shouldHaveMutuallyComparableElements(array));
+    }
   }
 
   // is static to avoid "generify" Arrays
   static <T> void assertIsSortedAccordingToComparator(AssertionInfo info, Failures failures, Object array,
-	                                                  Comparator<T> comparator) {
-	assertNotNull(info, array);
-	checkNotNull(comparator, "The given comparator should not be null");
-	try {
-	  List<T> arrayAsList = asList(array);
-	  // empty arrays are considered sorted even if comparator can't be applied to <T>.
-	  if (arrayAsList.size() == 0) return;
-	  if (arrayAsList.size() == 1) {
-		// call compare to see if unique element is compatible with comparator.
-		comparator.compare(arrayAsList.get(0), arrayAsList.get(0));
-		return;
-	  }
-	  for (int i = 0; i < arrayAsList.size() - 1; i++) {
-		// array is sorted in comparator defined order iif element i is less or equal than element i+1
-		if (comparator.compare(arrayAsList.get(i), arrayAsList.get(i + 1)) > 0)
-		  throw failures.failure(info, shouldBeSortedAccordingToGivenComparator(i, array, comparator));
-	  }
-	} catch (ClassCastException e) {
-	  throw failures.failure(info, shouldHaveComparableElementsAccordingToGivenComparator(array, comparator));
-	}
+                                                      Comparator<T> comparator) {
+    assertNotNull(info, array);
+    checkNotNull(comparator, "The given comparator should not be null");
+    try {
+      List<T> arrayAsList = asList(array);
+      // empty arrays are considered sorted even if comparator can't be applied to <T>.
+      if (arrayAsList.size() == 0) return;
+      if (arrayAsList.size() == 1) {
+        // call compare to see if unique element is compatible with comparator.
+        comparator.compare(arrayAsList.get(0), arrayAsList.get(0));
+        return;
+      }
+      for (int i = 0; i < arrayAsList.size() - 1; i++) {
+        // array is sorted in comparator defined order iif element i is less or equal than element i+1
+        if (comparator.compare(arrayAsList.get(i), arrayAsList.get(i + 1)) > 0)
+          throw failures.failure(info, shouldBeSortedAccordingToGivenComparator(i, array, comparator));
+      }
+    } catch (ClassCastException e) {
+      throw failures.failure(info, shouldHaveComparableElementsAccordingToGivenComparator(array, comparator));
+    }
   }
 
   @SuppressWarnings("unchecked")
   private static <T> List<T> asList(Object array) {
-	if (array == null) return null;
-	if (!isArray(array)) throw new IllegalArgumentException("The object should be an array");
-	int length = getLength(array);
-	List<T> list = new ArrayList<>(length);
-	for (int i = 0; i < length; i++) {
-	  list.add((T) Array.get(array, i));
-	}
-	return list;
+    if (array == null) return null;
+    if (!isArray(array)) throw new IllegalArgumentException("The object should be an array");
+    int length = getLength(array);
+    List<T> list = new ArrayList<>(length);
+    for (int i = 0; i < length; i++) {
+      list.add((T) Array.get(array, i));
+    }
+    return list;
   }
 
   @SuppressWarnings("unchecked")
   private static Comparable<Object>[] arrayOfComparableItems(Object array) {
-	ArrayWrapperList arrayWrapperList = wrap(array);
-	Comparable<Object>[] arrayOfComparableItems = new Comparable[arrayWrapperList.size()];
-	for (int i = 0; i < arrayWrapperList.size(); i++) {
-	  arrayOfComparableItems[i] = (Comparable<Object>) arrayWrapperList.get(i);
-	}
-	return arrayOfComparableItems;
+    ArrayWrapperList arrayWrapperList = wrap(array);
+    Comparable<Object>[] arrayOfComparableItems = new Comparable[arrayWrapperList.size()];
+    for (int i = 0; i < arrayWrapperList.size(); i++) {
+      arrayOfComparableItems[i] = (Comparable<Object>) arrayWrapperList.get(i);
+    }
+    return arrayOfComparableItems;
   }
 
   private static void assertThatArrayComponentTypeIsSortable(AssertionInfo info, Failures failures, Object array) {
-	ArrayWrapperList arrayAsList = wrap(array);
-	Class<?> arrayComponentType = arrayAsList.getComponentType();
-	if (arrayComponentType.isPrimitive()) return;
-	if (!Comparable.class.isAssignableFrom(arrayComponentType))
-	  throw failures.failure(info, shouldHaveMutuallyComparableElements(array));
+    ArrayWrapperList arrayAsList = wrap(array);
+    Class<?> arrayComponentType = arrayAsList.getComponentType();
+    if (arrayComponentType.isPrimitive()) return;
+    if (!Comparable.class.isAssignableFrom(arrayComponentType))
+      throw failures.failure(info, shouldHaveMutuallyComparableElements(array));
   }
 
   private static void checkIsNotNullAndNotEmpty(Object values) {
-	checkIsNotNull(values);
-	if (isArrayEmpty(values)) throw arrayOfValuesToLookForIsEmpty();
+    checkIsNotNull(values);
+    if (isArrayEmpty(values)) throw arrayOfValuesToLookForIsEmpty();
   }
 
   private static void checkIsNotNull(Object values) {
-	if (values == null) throw arrayOfValuesToLookForIsNull();
+    if (values == null) throw arrayOfValuesToLookForIsNull();
   }
 
   private static boolean isArrayEmpty(Object array) {
-	return sizeOf(array) == 0;
+    return sizeOf(array) == 0;
   }
 
   private AssertionError arrayDoesNotEndWithSequence(AssertionInfo info, Failures failures, Object array,
-	                                                 Object sequence) {
-	return failures.failure(info, shouldEndWith(array, sequence, comparisonStrategy));
+                                                     Object sequence) {
+    return failures.failure(info, shouldEndWith(array, sequence, comparisonStrategy));
   }
 
   private static void assertNotNull(AssertionInfo info, Object array) {
-	Objects.instance().assertNotNull(info, array);
+    Objects.instance().assertNotNull(info, array);
   }
 
   private static int sizeOf(Object array) {
-	if (array instanceof Object[]) return ((Object[]) array).length;
-	return Array.getLength(array);
+    if (array instanceof Object[]) return ((Object[]) array).length;
+    return Array.getLength(array);
   }
 
   private static void failIfEmptySinceActualIsNotEmpty(Object values) {
-	if (isArrayEmpty(values)) throw new AssertionError("actual is not empty while group of values to look for is.");
+    if (isArrayEmpty(values)) throw new AssertionError("actual is not empty while group of values to look for is.");
   }
 
 }
diff --git a/src/main/java/org/assertj/core/internal/DoubleArrays.java b/src/main/java/org/assertj/core/internal/DoubleArrays.java
index 1ee37b736..9a3254a75 100644
--- a/src/main/java/org/assertj/core/internal/DoubleArrays.java
+++ b/src/main/java/org/assertj/core/internal/DoubleArrays.java
@@ -214,13 +214,13 @@ public class DoubleArrays {
   }
 
   public void assertContainsExactly(AssertionInfo info, double[] actual, double[] values) {
-	arrays.assertContainsExactly(info, failures, actual, values);
+    arrays.assertContainsExactly(info, failures, actual, values);
   }
 
   public void assertContainsExactlyInAnyOrder(AssertionInfo info, double[] actual, double[] values) {
     arrays.assertContainsExactlyInAnyOrder(info, failures, actual, values);
   }
-  
+
   /**
    * Verifies that the given array contains the given sequence of values, without any other values between them.
    * 
@@ -332,7 +332,7 @@ public class DoubleArrays {
    * @param comparator the {@link Comparator} used to compare array elements
    */
   public void assertIsSortedAccordingToComparator(AssertionInfo info, double[] actual,
-      Comparator<? super Double> comparator) {
+                                                  Comparator<? super Double> comparator) {
     Arrays.assertIsSortedAccordingToComparator(info, failures, actual, comparator);
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/IterableDiff.java b/src/main/java/org/assertj/core/internal/IterableDiff.java
new file mode 100644
index 000000000..cc2009a98
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/IterableDiff.java
@@ -0,0 +1,65 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2016 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.util.Collections.unmodifiableList;
+
+import java.util.ArrayList;
+import java.util.List;
+
+class IterableDiff {
+  
+  private final ComparisonStrategy comparisonStrategy;
+
+  List<Object> unexpected;
+  List<Object> missing;
+
+  static IterableDiff diff(Iterable<Object> actual, Iterable<Object> expected, ComparisonStrategy comparisonStrategy) {
+    return new IterableDiff(actual, expected, comparisonStrategy);
+  }
+  
+  IterableDiff(Iterable<Object> actual, Iterable<Object> expected, ComparisonStrategy comparisonStrategy) {
+    this.comparisonStrategy = comparisonStrategy;
+    this.unexpected = unmodifiableList(unexpectedElements(actual, expected));
+    this.missing = unmodifiableList(missingElements(actual, expected));
+  }
+  
+  boolean differencesFound() {
+    return !unexpected.isEmpty() || !missing.isEmpty();
+  }
+  
+  private List<Object> missingElements(Iterable<Object> actual, Iterable<Object> expected) {
+    List<Object> missing = new ArrayList<>();
+    for (Object element : expected) {
+      if (!iterableContains(actual, element)) {
+        missing.add(element);
+      }
+    }
+    return missing;
+  }
+
+  private List<Object> unexpectedElements(Iterable<Object> actual, Iterable<Object> expected) {
+    List<Object> unexpected = new ArrayList<>();
+    for (Object actualElement : actual) {
+      if (!iterableContains(expected, actualElement)) {
+        unexpected.add(actualElement);
+      }
+    }
+    return unexpected;
+  }
+
+  private boolean iterableContains(Iterable<?> actual, Object value) {
+    return comparisonStrategy.iterableContains(actual, value);
+  }
+  
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/internal/Iterables.java b/src/main/java/org/assertj/core/internal/Iterables.java
index b72f50dfd..469275562 100644
--- a/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/src/main/java/org/assertj/core/internal/Iterables.java
@@ -31,7 +31,7 @@ import static org.assertj.core.error.ShouldContain.shouldContain;
 import static org.assertj.core.error.ShouldContainExactly.elementsDifferAtIndex;
 import static org.assertj.core.error.ShouldContainExactly.shouldContainExactly;
 import static org.assertj.core.error.ShouldContainExactly.shouldHaveSameSize;
-import static org.assertj.core.error.ShouldContainExactlyInAnyOrder.*;
+import static org.assertj.core.error.ShouldContainExactlyInAnyOrder.shouldContainExactlyInAnyOrder;
 import static org.assertj.core.error.ShouldContainNull.shouldContainNull;
 import static org.assertj.core.error.ShouldContainOnly.shouldContainOnly;
 import static org.assertj.core.error.ShouldContainSequence.shouldContainSequence;
@@ -50,12 +50,11 @@ import static org.assertj.core.internal.CommonValidations.checkIterableIsNotNull
 import static org.assertj.core.internal.CommonValidations.checkSizes;
 import static org.assertj.core.internal.CommonValidations.failIfEmptySinceActualIsNotEmpty;
 import static org.assertj.core.internal.CommonValidations.hasSameSizeAsCheck;
+import static org.assertj.core.internal.IterableDiff.diff;
 import static org.assertj.core.util.IterableUtil.isNullOrEmpty;
 import static org.assertj.core.util.IterableUtil.sizeOf;
 import static org.assertj.core.util.Lists.newArrayList;
 
-import java.util.ArrayList;
-import java.util.Collection;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
@@ -235,13 +234,6 @@ public class Iterables {
     return comparisonStrategy.iterableContains(actual, value);
   }
 
-  /**
-   * Delegates to {@link ComparisonStrategy#iterableRemoves(Iterable, Object)}
-   */
-  private void iterableRemoves(Iterable<?> actual, Object value) {
-    comparisonStrategy.iterableRemoves(actual, value);
-  }
-
   /**
    * Delegates to {@link ComparisonStrategy#iterablesRemoveFirst(Iterable, Object)}
    */
@@ -262,47 +254,13 @@ public class Iterables {
    *           {@code Iterable} contains values that are not in the given array.
    */
   public void assertContainsOnly(AssertionInfo info, Iterable<?> actual, Object[] values) {
-    if (commonCheckThatIterableAssertionSucceeds(info, actual, values))
-      return;
-    // check for elements in values that are missing in actual.
-    List<Object> notExpected = asListWithoutDuplicatesAccordingToComparisonStrategy(actual);
-    List<Object> notFound = containsOnly(notExpected, values);
-    if (!notExpected.isEmpty() || !notFound.isEmpty())
-      throw failures.failure(info, shouldContainOnly(actual, values, notFound, notExpected, comparisonStrategy));
-  }
-
-  private List<Object> containsOnly(Collection<Object> actual, Object[] values) {
-    List<Object> list = new ArrayList<>();
-    for (Object o : listWithoutDuplicates(values)) {
-      if (iterableContains(actual, o)) {
-        iterableRemoves(actual, o);
-      } else {
-        list.add(o);
-      }
-    }
-    return list;
-  }
-
-  private List<Object> listWithoutDuplicates(Object... elements) {
-    return elements == null ? null : asListWithoutDuplicatesAccordingToComparisonStrategy(asList(elements));
-  }
+    if (commonCheckThatIterableAssertionSucceeds(info, actual, values)) return;
 
-  /**
-   * build a Set with that avoid duplicates <b>according to given comparison strategy</b>
-   * 
-   * @param iterable to feed the Set we want to build
-   * @return a Set without duplicates <b>according to given comparison strategy</b>
-   */
-  private List<Object> asListWithoutDuplicatesAccordingToComparisonStrategy(Iterable<?> iterable) {
-    if (iterable == null) return null;
-    List<Object> list = new ArrayList<>();
-    for (Object e : iterable) {
-      // only add is not already there
-      if (!iterableContains(list, e)) {
-        list.add(e);
-      }
-    }
-    return list;
+    IterableDiff diff = diff(newArrayList(actual), asList(values), comparisonStrategy);
+    if (diff.differencesFound())
+      throw failures.failure(info, shouldContainOnly(actual, values,
+                                                     diff.missing, diff.unexpected,
+                                                     comparisonStrategy));
   }
 
   /**
@@ -759,7 +717,8 @@ public class Iterables {
     }
   }
 
-  private <E> boolean conditionIsSatisfiedNTimes(Iterable<? extends E> actual, Condition<? super E> condition, int times) {
+  private <E> boolean conditionIsSatisfiedNTimes(Iterable<? extends E> actual, Condition<? super E> condition,
+                                                 int times) {
     List<E> satisfiesCondition = satisfiesCondition(actual, condition);
     return satisfiesCondition.size() == times;
   }
@@ -848,10 +807,11 @@ public class Iterables {
     if (values.length != actualSize)
       throw failures.failure(info, shouldHaveSameSize(actual, values, actualSize, values.length, comparisonStrategy));
     assertHasSameSizeAs(info, actual, values); // include check that actual is not null
-    List<Object> notExpected = asListWithoutDuplicatesAccordingToComparisonStrategy(actual);
-    List<Object> notFound = containsOnly(notExpected, values);
-    if (notExpected.isEmpty() && notFound.isEmpty()) {
-      // actual and values have the same elements but are they in the same order.
+
+    List<Object> actualAsList = newArrayList(actual);
+    IterableDiff diff = diff(actualAsList, asList(values), comparisonStrategy);
+    if (!diff.differencesFound()) {
+      // actual and values have the same elements but are they in the same order ?
       int i = 0;
       for (Object elementFromActual : actual) {
         if (!areEqual(elementFromActual, values[i])) {
@@ -861,7 +821,8 @@ public class Iterables {
       }
       return;
     }
-    throw failures.failure(info, shouldContainExactly(actual, values, notFound, notExpected, comparisonStrategy));
+    throw failures.failure(info,
+                           shouldContainExactly(actual, values, diff.missing, diff.unexpected, comparisonStrategy));
   }
 
   public void assertContainsExactlyInAnyOrder(AssertionInfo info, Iterable<?> actual, Object[] values) {
@@ -871,17 +832,18 @@ public class Iterables {
     List<Object> notFound = newArrayList(values);
 
     for (Object value : values) {
-      if(iterableContains(notExpected, value)) {
+      if (iterableContains(notExpected, value)) {
         iterablesRemoveFirst(notExpected, value);
         iterablesRemoveFirst(notFound, value);
       }
     }
 
-    if(notExpected.isEmpty() && notFound.isEmpty()) {
+    if (notExpected.isEmpty() && notFound.isEmpty()) {
       return;
     }
 
-    throw failures.failure(info, shouldContainExactlyInAnyOrder(actual, values, notFound, notExpected, comparisonStrategy));
+    throw failures.failure(info,
+                           shouldContainExactlyInAnyOrder(actual, values, notFound, notExpected, comparisonStrategy));
   }
 
   void assertNotNull(AssertionInfo info, Iterable<?> actual) {
diff --git a/src/test/java/org/assertj/core/api/doublearray/DoubleArrayAssert_containsExactly_Test.java b/src/test/java/org/assertj/core/api/doublearray/DoubleArrayAssert_containsExactly_Test.java
index 0622c5053..fd587eff9 100644
--- a/src/test/java/org/assertj/core/api/doublearray/DoubleArrayAssert_containsExactly_Test.java
+++ b/src/test/java/org/assertj/core/api/doublearray/DoubleArrayAssert_containsExactly_Test.java
@@ -14,6 +14,7 @@ package org.assertj.core.api.doublearray;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.withPrecision;
+import static org.assertj.core.api.Assertions.within;
 import static org.assertj.core.test.DoubleArrays.arrayOf;
 import static org.mockito.Mockito.verify;
 
@@ -44,15 +45,24 @@ public class DoubleArrayAssert_containsExactly_Test extends DoubleArrayAssertBas
     double[] actual = arrayOf(1.0, 2.0);
     // THEN
     assertThat(actual).containsExactly(arrayOf(1.01, 2.0), withPrecision(0.1));
+    assertThat(actual).containsExactly(arrayOf(1.01, 2.0), withPrecision(0.1));
   }
-
+  
+  @Test
+  public void should_pass_when_multiple_expected_values_are_the_same_according_to_the_given_precision() {
+    // GIVEN
+    double[] actual = arrayOf(-1.71, -1.51, -1.51);
+    // THEN
+    assertThat(actual).containsExactly(arrayOf(-1.7, -1.6, -1.4101), within(0.1));
+  }
+  
   @Test
   public void should_pass_with_precision_specified_in_comparator() {
     // GIVEN
-    double[] actual = arrayOf(1.0, 2.0);
+    double[] actual = arrayOf(1.0, 2.0, 2.0, 2.09);
     // THEN
     assertThat(actual).usingComparatorWithPrecision(0.1)
-                      .containsExactly(1.01, 2.0);
+                      .containsExactly(1.01, 2.0, 2.0, 2.0);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/doublearray/DoubleArrayAssert_containsOnly_Test.java b/src/test/java/org/assertj/core/api/doublearray/DoubleArrayAssert_containsOnly_Test.java
index 893eeb4a6..1db62aa1c 100644
--- a/src/test/java/org/assertj/core/api/doublearray/DoubleArrayAssert_containsOnly_Test.java
+++ b/src/test/java/org/assertj/core/api/doublearray/DoubleArrayAssert_containsOnly_Test.java
@@ -14,6 +14,7 @@ package org.assertj.core.api.doublearray;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.withPrecision;
+import static org.assertj.core.api.Assertions.within;
 import static org.assertj.core.test.DoubleArrays.arrayOf;
 
 import org.assertj.core.api.DoubleArrayAssert;
@@ -43,7 +44,7 @@ public class DoubleArrayAssert_containsOnly_Test extends DoubleArrayAssertBaseTe
   public void should_pass_with_precision_specified_as_last_argument() {
     // GIVEN
     double[] actual = arrayOf(1.0, 2.0);
-    // THEN 
+    // THEN
     assertThat(actual).containsOnly(arrayOf(1.01, 2.0), withPrecision(0.1));
   }
 
@@ -56,4 +57,29 @@ public class DoubleArrayAssert_containsOnly_Test extends DoubleArrayAssertBaseTe
                       .containsOnly(1.01, 2.0);
   }
 
+  @Test
+  public void should_pass_when_multiple_expected_values_are_the_same_according_to_the_given_precision() {
+    // GIVEN
+    double[] actual = arrayOf(-1.71, -1.51, -1.51);
+    // THEN
+    assertThat(actual).containsOnly(arrayOf(-1.7, -1.6), within(0.1));
+  }
+
+  @Test
+  public void should_pass_even_if_multiple_expected_values_are_the_same_according_to_the_given_precision() {
+    // GIVEN
+    double[] actual = arrayOf(-1.71, -1.51);
+    // THEN
+    assertThat(actual).containsOnly(arrayOf(-1.7, -1.6), within(0.1));
+  }
+
+  @Test
+  public void should_pass_when_multiple_expected_values_are_the_same() {
+    // GIVEN
+    double[] actual = arrayOf(-1.71, -1.71);
+    // THEN
+    assertThat(actual).containsOnly(arrayOf(-1.71, -1.71));
+    assertThat(actual).containsOnly(arrayOf(-1.71));
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/floatarray/FloatArrayAssert_containsExactly_Test.java b/src/test/java/org/assertj/core/api/floatarray/FloatArrayAssert_containsExactly_Test.java
index 9e2abf731..44940c3c0 100644
--- a/src/test/java/org/assertj/core/api/floatarray/FloatArrayAssert_containsExactly_Test.java
+++ b/src/test/java/org/assertj/core/api/floatarray/FloatArrayAssert_containsExactly_Test.java
@@ -14,6 +14,8 @@ package org.assertj.core.api.floatarray;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.withPrecision;
+import static org.assertj.core.api.Assertions.within;
+import static org.assertj.core.test.DoubleArrays.arrayOf;
 import static org.assertj.core.test.FloatArrays.arrayOf;
 import static org.mockito.Mockito.verify;
 
@@ -21,11 +23,6 @@ import org.assertj.core.api.FloatArrayAssert;
 import org.assertj.core.api.FloatArrayAssertBaseTest;
 import org.junit.Test;
 
-/**
- * Tests for <code>{@link org.assertj.core.api.FloatArrayAssert#containsExactly(float...)}</code>.
- * 
- * @author Jean-Christophe Gay
- */
 public class FloatArrayAssert_containsExactly_Test extends FloatArrayAssertBaseTest {
 
   @Override
@@ -37,7 +34,7 @@ public class FloatArrayAssert_containsExactly_Test extends FloatArrayAssertBaseT
   protected void verify_internal_effects() {
     verify(arrays).assertContainsExactly(getInfo(assertions), getActual(assertions), arrayOf(1.0f, 2.0f));
   }
-  
+
   @Test
   public void should_pass_with_precision_specified_as_last_argument() {
     // GIVEN
@@ -46,6 +43,14 @@ public class FloatArrayAssert_containsExactly_Test extends FloatArrayAssertBaseT
     assertThat(actual).containsExactly(arrayOf(1.01f, 2.0f), withPrecision(0.1f));
   }
 
+  @Test
+  public void should_pass_when_multiple_expected_values_are_the_same_according_to_the_given_precision() {
+    // GIVEN
+    float[] actual = arrayOf(-1.71f, -1.51f, -1.51f);
+    // THEN
+    assertThat(actual).containsExactly(arrayOf(-1.7f, -1.6f, -1.4101f), within(0.1f));
+  }
+
   @Test
   public void should_pass_with_precision_specified_in_comparator() {
     // GIVEN
diff --git a/src/test/java/org/assertj/core/api/floatarray/FloatArrayAssert_containsOnly_Test.java b/src/test/java/org/assertj/core/api/floatarray/FloatArrayAssert_containsOnly_Test.java
index 3e3b1f494..9f5364826 100644
--- a/src/test/java/org/assertj/core/api/floatarray/FloatArrayAssert_containsOnly_Test.java
+++ b/src/test/java/org/assertj/core/api/floatarray/FloatArrayAssert_containsOnly_Test.java
@@ -14,6 +14,7 @@ package org.assertj.core.api.floatarray;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.withPrecision;
+import static org.assertj.core.api.Assertions.within;
 import static org.assertj.core.test.FloatArrays.arrayOf;
 
 import org.assertj.core.api.FloatArrayAssert;
@@ -48,6 +49,14 @@ public class FloatArrayAssert_containsOnly_Test extends FloatArrayAssertBaseTest
     assertThat(actual).containsOnly(arrayOf(0.91f, 2.0f, 3.09f), withPrecision(0.1f));
   }
 
+  @Test
+  public void should_pass_when_multiple_expected_values_are_the_same_according_to_the_given_precision() {
+    // GIVEN
+    float[] actual = arrayOf(-1.71f, -1.51f, -1.51f);
+    // THEN
+    assertThat(actual).containsOnly(arrayOf(-1.7f, -1.6f), within(0.1f));
+  }
+  
   @Test
   public void should_pass_with_precision_specified_in_comparator() {
     // GIVEN
diff --git a/src/test/java/org/assertj/core/internal/doublearrays/DoubleArrays_assertContainsExactly_Test.java b/src/test/java/org/assertj/core/internal/doublearrays/DoubleArrays_assertContainsExactly_Test.java
index ff6dba531..51d37672d 100644
--- a/src/test/java/org/assertj/core/internal/doublearrays/DoubleArrays_assertContainsExactly_Test.java
+++ b/src/test/java/org/assertj/core/internal/doublearrays/DoubleArrays_assertContainsExactly_Test.java
@@ -40,6 +40,12 @@ public class DoubleArrays_assertContainsExactly_Test extends DoubleArraysBaseTes
     arrays.assertContainsExactly(someInfo(), actual, arrayOf(6d, 8d, 10d));
   }
 
+  @Test
+  public void should_pass_if_actual_contains_given_values_exactly_with_duplicates() {
+    actual = arrayOf(6d, 8d, 8d);
+    arrays.assertContainsExactly(someInfo(), actual, arrayOf(6d, 8d, 8d));
+  }
+  
   @Test
   public void should_pass_if_actual_and_given_values_are_empty() {
     arrays.assertContainsExactly(someInfo(), emptyArray(), emptyArray());
@@ -114,7 +120,8 @@ public class DoubleArrays_assertContainsExactly_Test extends DoubleArraysBaseTes
 
   @Test
   public void should_pass_if_actual_contains_given_values_exactly_according_to_custom_comparison_strategy() {
-    arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, arrayOf(6d, -8d, 10d));
+    actual = arrayOf(6, -8, 8);
+    arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, arrayOf(6d, -8d, 8d));
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/intarrays/IntArrays_assertContainsExactlyInAnyOrder_Test.java b/src/test/java/org/assertj/core/internal/intarrays/IntArrays_assertContainsExactlyInAnyOrder_Test.java
index 13a9be919..e14495904 100644
--- a/src/test/java/org/assertj/core/internal/intarrays/IntArrays_assertContainsExactlyInAnyOrder_Test.java
+++ b/src/test/java/org/assertj/core/internal/intarrays/IntArrays_assertContainsExactlyInAnyOrder_Test.java
@@ -35,6 +35,12 @@ public class IntArrays_assertContainsExactlyInAnyOrder_Test extends IntArraysBas
     arrays.assertContainsExactlyInAnyOrder(someInfo(), actual, arrayOf(6, 8, 10));
   }
 
+  @Test
+  public void should_pass_if_actual_contains_given_values_exactly_in_any_order_with_duplicates() {
+    actual = arrayOf(6, 8, 8, 10);
+    arrays.assertContainsExactlyInAnyOrder(someInfo(), actual, arrayOf(6, 8, 8,10));
+  }
+  
   @Test
   public void should_pass_if_actual_and_given_values_are_empty() {
     arrays.assertContainsExactlyInAnyOrder(someInfo(), emptyArray(), emptyArray());
diff --git a/src/test/java/org/assertj/core/internal/intarrays/IntArrays_assertContainsExactly_Test.java b/src/test/java/org/assertj/core/internal/intarrays/IntArrays_assertContainsExactly_Test.java
index 6736dcc4c..4c2f7d879 100644
--- a/src/test/java/org/assertj/core/internal/intarrays/IntArrays_assertContainsExactly_Test.java
+++ b/src/test/java/org/assertj/core/internal/intarrays/IntArrays_assertContainsExactly_Test.java
@@ -37,61 +37,67 @@ public class IntArrays_assertContainsExactly_Test extends IntArraysBaseTest {
 
   @Test
   public void should_pass_if_actual_contains_given_values_exactly() {
-	arrays.assertContainsExactly(someInfo(), actual, arrayOf(6, 8, 10));
+    arrays.assertContainsExactly(someInfo(), actual, arrayOf(6, 8, 10));
   }
 
+  @Test
+  public void should_pass_if_actual_contains_given_values_exactly_with_duplicate_elements() {
+    actual = arrayOf(6, 8, 8);
+    arrays.assertContainsExactly(someInfo(), actual, arrayOf(6, 8, 8));
+  }
+  
   @Test
   public void should_pass_if_actual_and_given_values_are_empty() {
-	arrays.assertContainsExactly(someInfo(), emptyArray(), emptyArray());
+    arrays.assertContainsExactly(someInfo(), emptyArray(), emptyArray());
   }
 
   @Test
   public void should_fail_if_actual_contains_given_values_exactly_but_in_different_order() {
-	AssertionInfo info = someInfo();
-	try {
-	  arrays.assertContainsExactly(info, actual, arrayOf(6, 10, 8));
-	} catch (AssertionError e) {
-	  verify(failures).failure(info, elementsDifferAtIndex(8, 10, 1));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+    AssertionInfo info = someInfo();
+    try {
+      arrays.assertContainsExactly(info, actual, arrayOf(6, 10, 8));
+    } catch (AssertionError e) {
+      verify(failures).failure(info, elementsDifferAtIndex(8, 10, 1));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
   public void should_fail_if_arrays_have_different_sizes() {
-	thrown.expect(AssertionError.class);
-	arrays.assertContainsExactly(someInfo(), actual, arrayOf(6, 8));
+    thrown.expect(AssertionError.class);
+    arrays.assertContainsExactly(someInfo(), actual, arrayOf(6, 8));
   }
 
   @Test
   public void should_fail_if_array_of_values_to_look_for_is_empty_and_actual_is_not() {
-	thrown.expect(AssertionError.class);
-	arrays.assertContainsExactly(someInfo(), actual, emptyArray());
+    thrown.expect(AssertionError.class);
+    arrays.assertContainsExactly(someInfo(), actual, emptyArray());
   }
 
   @Test
   public void should_throw_error_if_array_of_values_to_look_for_is_null() {
-	thrown.expectNullPointerException(valuesToLookForIsNull());
-	arrays.assertContainsExactly(someInfo(), actual, null);
+    thrown.expectNullPointerException(valuesToLookForIsNull());
+    arrays.assertContainsExactly(someInfo(), actual, null);
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-	thrown.expectAssertionError(actualIsNull());
-	arrays.assertContainsExactly(someInfo(), null, arrayOf(8));
+    thrown.expectAssertionError(actualIsNull());
+    arrays.assertContainsExactly(someInfo(), null, arrayOf(8));
   }
 
   @Test
   public void should_fail_if_actual_does_not_contain_given_values_exactly() {
-	AssertionInfo info = someInfo();
-	int[] expected = { 6, 8, 20 };
-	try {
-	  arrays.assertContainsExactly(info, actual, expected);
-	} catch (AssertionError e) {
+    AssertionInfo info = someInfo();
+    int[] expected = { 6, 8, 20 };
+    try {
+      arrays.assertContainsExactly(info, actual, expected);
+    } catch (AssertionError e) {
       verify(failures).failure(info, shouldContainExactly(actual, expected, newArrayList(20), newArrayList(10)));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
@@ -114,53 +120,53 @@ public class IntArrays_assertContainsExactly_Test extends IntArraysBaseTest {
 
   @Test
   public void should_pass_if_actual_contains_given_values_exactly_according_to_custom_comparison_strategy() {
-	arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, arrayOf(6, -8, 10));
+    arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, arrayOf(6, -8, 10));
   }
 
   @Test
   public void should_pass_if_actual_contains_given_values_exactly_in_different_order_according_to_custom_comparison_strategy() {
-	AssertionInfo info = someInfo();
-	int[] expected = { -6, 10, 8 };
-	try {
-	  arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, expected);
-	} catch (AssertionError e) {
-	  verify(failures).failure(info, elementsDifferAtIndex(8, 10, 1, absValueComparisonStrategy));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+    AssertionInfo info = someInfo();
+    int[] expected = { -6, 10, 8 };
+    try {
+      arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, expected);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, elementsDifferAtIndex(8, 10, 1, absValueComparisonStrategy));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
   public void should_fail_if_array_of_values_to_look_for_is_empty_and_actual_is_not_whatever_custom_comparison_strategy_is() {
-	thrown.expect(AssertionError.class);
-	arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, emptyArray());
+    thrown.expect(AssertionError.class);
+    arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, emptyArray());
   }
 
   @Test
   public void should_throw_error_if_array_of_values_to_look_for_is_null_whatever_custom_comparison_strategy_is() {
-	thrown.expectNullPointerException(valuesToLookForIsNull());
-	arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, null);
+    thrown.expectNullPointerException(valuesToLookForIsNull());
+    arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual, null);
   }
 
   @Test
   public void should_fail_if_actual_is_null_whatever_custom_comparison_strategy_is() {
-	thrown.expectAssertionError(actualIsNull());
-	arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), null, arrayOf(-8));
+    thrown.expectAssertionError(actualIsNull());
+    arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), null, arrayOf(-8));
   }
 
   @Test
   public void should_fail_if_actual_does_not_contain_given_values_exactly_according_to_custom_comparison_strategy() {
-	AssertionInfo info = someInfo();
-	int[] expected = { 6, -8, 20 };
-	try {
-	  arraysWithCustomComparisonStrategy.assertContainsExactly(info, actual, expected);
-	} catch (AssertionError e) {
+    AssertionInfo info = someInfo();
+    int[] expected = { 6, -8, 20 };
+    try {
+      arraysWithCustomComparisonStrategy.assertContainsExactly(info, actual, expected);
+    } catch (AssertionError e) {
       verify(failures).failure(info,
                                shouldContainExactly(actual, expected, newArrayList(20), newArrayList(10),
                                                     absValueComparisonStrategy));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsExactly_Test.java b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsExactly_Test.java
index 4d34352a4..dc1cdf98d 100644
--- a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsExactly_Test.java
+++ b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertContainsExactly_Test.java
@@ -38,83 +38,89 @@ public class ObjectArrays_assertContainsExactly_Test extends ObjectArraysBaseTes
 
   @Test
   public void should_pass_if_actual_contains_exactly_given_values() {
-	arrays.assertContainsExactly(someInfo(), actual, array("Luke", "Yoda", "Leia"));
+    arrays.assertContainsExactly(someInfo(), actual, array("Luke", "Yoda", "Leia"));
   }
 
   @Test
   public void should_pass_if_actual_contains_given_values_exactly_with_null_elements() {
-	actual = array("Luke", "Yoda", "Leia", null);
-	arrays.assertContainsExactly(someInfo(), actual, array("Luke", "Yoda", "Leia", null));
+    actual = array("Luke", "Yoda", "Leia", null);
+    arrays.assertContainsExactly(someInfo(), actual, array("Luke", "Yoda", "Leia", null));
   }
 
+  @Test
+  public void should_pass_if_actual_contains_given_values_exactly_with_duplicate_elements() {
+    actual = array("Luke", "Yoda", "Yoda");
+    arrays.assertContainsExactly(someInfo(), actual, array("Luke", "Yoda", "Yoda"));
+  }
+  
   @Test
   public void should_pass_if_actual_and_given_values_are_empty() {
-	arrays.assertContainsExactly(someInfo(), array(), array());
+    arrays.assertContainsExactly(someInfo(), array(), array());
   }
 
   @Test
   public void should_fail_if_array_of_values_to_look_for_is_empty_and_actual_is_not() {
-	thrown.expect(AssertionError.class);
-	arrays.assertContainsExactly(someInfo(), actual, array());
+    thrown.expect(AssertionError.class);
+    arrays.assertContainsExactly(someInfo(), actual, array());
   }
 
   @Test
   public void should_fail_if_arrays_have_different_sizes() {
-	thrown.expect(AssertionError.class);
-	arrays.assertContainsExactly(someInfo(), actual, array("Luke", "Yoda"));
+    thrown.expect(AssertionError.class);
+    arrays.assertContainsExactly(someInfo(), actual, array("Luke", "Yoda"));
   }
 
   @Test
   public void should_throw_error_if_array_of_values_to_look_for_is_null() {
-	thrown.expectNullPointerException(valuesToLookForIsNull());
-	arrays.assertContainsExactly(someInfo(), actual, null);
+    thrown.expectNullPointerException(valuesToLookForIsNull());
+    arrays.assertContainsExactly(someInfo(), actual, null);
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-	thrown.expectAssertionError(actualIsNull());
-	arrays.assertContainsExactly(someInfo(), null, array("Yoda"));
+    thrown.expectAssertionError(actualIsNull());
+    arrays.assertContainsExactly(someInfo(), null, array("Yoda"));
   }
 
   @Test
   public void should_fail_if_actual_does_not_contain_given_values_exactly() {
-	AssertionInfo info = someInfo();
-	Object[] expected = { "Luke", "Yoda", "Han" };
-	try {
-	  arrays.assertContainsExactly(info, actual, expected);
-	} catch (AssertionError e) {
+    AssertionInfo info = someInfo();
+    Object[] expected = { "Luke", "Yoda", "Han" };
+    try {
+      arrays.assertContainsExactly(info, actual, expected);
+    } catch (AssertionError e) {
       verify(failures).failure(info, shouldContainExactly(actual, expected, newArrayList("Han"), newArrayList("Leia")));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
   public void should_fail_if_actual_contains_all_given_values_but_in_different_order() {
-	AssertionInfo info = someInfo();
-	Object[] expected = { "Luke", "Leia", "Yoda" };
-	try {
-	  arrays.assertContainsExactly(info, actual, expected);
-	} catch (AssertionError e) {
-	  verify(failures).failure(info, elementsDifferAtIndex("Yoda", "Leia", 1));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+    AssertionInfo info = someInfo();
+    Object[] expected = { "Luke", "Leia", "Yoda" };
+    try {
+      arrays.assertContainsExactly(info, actual, expected);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, elementsDifferAtIndex("Yoda", "Leia", 1));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
   public void should_fail_if_actual_contains_all_given_values_but_size_differ() {
-	AssertionInfo info = someInfo();
-	actual = array("Luke", "Leia", "Luke");
-	Object[] expected = { "Luke", "Leia" };
-	try {
-	  arrays.assertContainsExactly(info, actual, expected);
-	} catch (AssertionError e) {
+    AssertionInfo info = someInfo();
+    actual = array("Luke", "Leia", "Luke");
+    Object[] expected = { "Luke", "Leia" };
+    try {
+      arrays.assertContainsExactly(info, actual, expected);
+    } catch (AssertionError e) {
       verify(failures).failure(info,
                                shouldHaveSameSize(actual, expected, 3, 2, StandardComparisonStrategy.instance()));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   // ------------------------------------------------------------------------------------------------------------------
@@ -123,35 +129,35 @@ public class ObjectArrays_assertContainsExactly_Test extends ObjectArraysBaseTes
 
   @Test
   public void should_pass_if_actual_contains_given_values_exactly_according_to_custom_comparison_strategy() {
-	arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual,
-	                                                         array("LUKE", "YODA", "Leia"));
+    arraysWithCustomComparisonStrategy.assertContainsExactly(someInfo(), actual,
+                                                             array("LUKE", "YODA", "Leia"));
   }
 
   @Test
   public void should_fail_if_actual_does_not_contain_given_values_exactly_according_to_custom_comparison_strategy() {
-	AssertionInfo info = someInfo();
-	Object[] expected = { "Luke", "Yoda", "Han" };
-	try {
-	  arraysWithCustomComparisonStrategy.assertContainsExactly(info, actual, expected);
-	} catch (AssertionError e) {
+    AssertionInfo info = someInfo();
+    Object[] expected = { "Luke", "Yoda", "Han" };
+    try {
+      arraysWithCustomComparisonStrategy.assertContainsExactly(info, actual, expected);
+    } catch (AssertionError e) {
       verify(failures).failure(info, shouldContainExactly(actual, expected, newArrayList("Han"), newArrayList("Leia"),
-		                                                  caseInsensitiveStringComparisonStrategy));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+                                                          caseInsensitiveStringComparisonStrategy));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
   public void should_fail_if_actual_contains_all_given_values_in_different_order_according_to_custom_comparison_strategy() {
-	AssertionInfo info = someInfo();
-	Object[] expected = { "Luke", "Leia", "Yoda" };
-	try {
-	  arraysWithCustomComparisonStrategy.assertContainsExactly(info, actual, expected);
-	} catch (AssertionError e) {
-	  verify(failures).failure(info, elementsDifferAtIndex("Yoda", "Leia", 1, caseInsensitiveStringComparisonStrategy));
-	  return;
-	}
-	failBecauseExpectedAssertionErrorWasNotThrown();
+    AssertionInfo info = someInfo();
+    Object[] expected = { "Luke", "Leia", "Yoda" };
+    try {
+      arraysWithCustomComparisonStrategy.assertContainsExactly(info, actual, expected);
+    } catch (AssertionError e) {
+      verify(failures).failure(info, elementsDifferAtIndex("Yoda", "Leia", 1, caseInsensitiveStringComparisonStrategy));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
   }
 
   @Test
