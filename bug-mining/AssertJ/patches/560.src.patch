diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index adb826648..c15289196 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -340,4 +340,11 @@ public final class DualValue {
     return !canonicalName.startsWith("java.lang");
   }
 
+  public boolean isActualAThrowable() {
+    return actual != null && actual instanceof Throwable;
+  }
+
+  public boolean isExpectedAThrowable() {
+    return expected != null && expected instanceof Throwable;
+  }
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 015337049..4272cca85 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -64,6 +64,7 @@ import org.assertj.core.internal.DeepDifference;
  */
 public class RecursiveComparisonDifferenceCalculator {
 
+  private static final String ACTUAL_FIELD_TYPE_DIFFERENT_FROM_EXPECTED_FIELD_TYPE = "actual field is a %s but expected field is not (%s)";
   private static final String DIFFERENT_ACTUAL_AND_EXPECTED_FIELD_TYPES = "expected field is %s but actual field is not (%s)";
   private static final String ACTUAL_IS_AN_ENUM_WHILE_EXPECTED_IS_NOT = "expected field is a %s but actual field is an enum";
   private static final String ACTUAL_NOT_ORDERED_COLLECTION = "expected field is an ordered collection but actual field is not (%s), ordered collections are: "
@@ -318,6 +319,11 @@ public class RecursiveComparisonDifferenceCalculator {
         compareAsEnums(dualValue, comparisonState, recursiveComparisonConfiguration);
         continue;
       }
+
+      if (dualValue.isActualAThrowable()) {
+        compareAsThrowables(dualValue, comparisonState);
+        continue;
+      }
       // TODO move hasFieldTypesDifference check into each compareXXX
 
       if (dualValue.isExpectedFieldAnArray()) {
@@ -485,6 +491,39 @@ public class RecursiveComparisonDifferenceCalculator {
     comparisonState.addDifference(dualValue, typeErrorMessage);
   }
 
+  @SuppressWarnings("DuplicateExpressions")
+  private static void compareAsThrowables(final DualValue dualValue, ComparisonState comparisonState) {
+    if (!dualValue.isExpectedAThrowable()) {
+      comparisonState.addDifference(dualValue, actualFieldTypeDifferentFromExpectedErrorMessage(dualValue));
+      return;
+    }
+    Throwable actual = (Throwable) dualValue.actual;
+    Throwable expected = (Throwable) dualValue.expected;
+    Class<? extends Throwable> actualClass = actual.getClass();
+    Class<? extends Throwable> expectedClass = expected.getClass();
+    if (comparisonState.recursiveComparisonConfiguration.isInStrictTypeCheckingMode()) {
+      if (!actualClass.equals(expectedClass)) {
+        comparisonState.addDifference(dualValue, differentTypeMessage(actualClass, expectedClass));
+        return;
+      }
+    }
+    if (!expectedClass.isAssignableFrom(actualClass)) {
+      comparisonState.addDifference(dualValue, differentTypeMessage(actualClass, expectedClass));
+      return;
+    }
+
+    comparisonState.registerForComparison(new DualValue(dualValue.fieldLocation.field("detailMessage"),
+                                                        actual.getMessage(), expected.getMessage()));
+    comparisonState.registerForComparison(new DualValue(dualValue.fieldLocation.field("cause"),
+                                                        actual.getCause(), expected.getCause()));
+    comparisonState.registerForComparison(new DualValue(dualValue.fieldLocation.field("suppressed"),
+                                                        actual.getSuppressed(), expected.getSuppressed()));
+  }
+
+  private static String differentTypeMessage(Class<? extends Throwable> actualClass, Class<? extends Throwable> expectedClass) {
+    return "actual is a %s but expected is not (%s)".formatted(actualClass.getName(), expectedClass.getName());
+  }
+
   private static boolean shouldHonorEquals(DualValue dualValue,
                                            RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     // since java 17 we can't introspect java types and get their fields so by default we compare them with equals
@@ -587,11 +626,17 @@ public class RecursiveComparisonDifferenceCalculator {
     }
   }
 
-  private static String differentTypeErrorMessage(DualValue dualValue, String actualTypeDescription) {
-    return DIFFERENT_ACTUAL_AND_EXPECTED_FIELD_TYPES.formatted(actualTypeDescription,
+  private static String differentTypeErrorMessage(DualValue dualValue, String expectedTypeDescription) {
+    return DIFFERENT_ACTUAL_AND_EXPECTED_FIELD_TYPES.formatted(expectedTypeDescription,
                                                                dualValue.actual.getClass().getCanonicalName());
   }
 
+  private static String actualFieldTypeDifferentFromExpectedErrorMessage(DualValue dualValue) {
+    String actualType = dualValue.actual == null ? "" : dualValue.actual.getClass().getCanonicalName();
+    String expectedType = dualValue.expected == null ? "" : dualValue.expected.getClass().getCanonicalName();
+    return ACTUAL_FIELD_TYPE_DIFFERENT_FROM_EXPECTED_FIELD_TYPE.formatted(actualType, expectedType);
+  }
+
   private static void compareUnorderedIterables(DualValue dualValue, ComparisonState comparisonState) {
     if (!dualValue.isActualFieldAnIterable()) {
       // at the moment we only compare iterable with iterables (but we might allow arrays too)
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/dualvalue/DualValue_isActualAThrowable_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/dualvalue/DualValue_isActualAThrowable_Test.java
new file mode 100644
index 000000000..5273d1d98
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/dualvalue/DualValue_isActualAThrowable_Test.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.dualvalue;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+import java.util.stream.Stream;
+
+import org.apache.commons.lang3.tuple.Pair;
+import org.assertj.core.api.recursive.comparison.DualValue;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class DualValue_isActualAThrowable_Test {
+
+  private static final List<String> PATH = list("foo", "bar");
+
+  @ParameterizedTest
+  @MethodSource
+  void isActualAThrowable_should_return_true_when_actual_is_a_throwable(Throwable actual) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, actual, "unused");
+    // WHEN
+    boolean isActualAThrowable = dualValue.isActualAThrowable();
+    // THEN
+    then(isActualAThrowable).isTrue();
+  }
+
+  static Stream<Throwable> isActualAThrowable_should_return_true_when_actual_is_a_throwable() throws Exception {
+    return Stream.of(new RuntimeException("boom"),
+                     new Throwable("bam"));
+  }
+
+  @Test
+  void isActualAThrowable_should_return_false_when_actual_is_not_a_throwable() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, Pair.of(1, "a"), "unused");
+    // WHEN
+    boolean isActualAThrowable = dualValue.isActualAThrowable();
+    // THEN
+    then(isActualAThrowable).isFalse();
+  }
+
+  @Test
+  void isActualAThrowable_should_return_false_when_actual_is_null() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, null, "unused");
+    // WHEN
+    boolean isActualAThrowable = dualValue.isActualAThrowable();
+    // THEN
+    then(isActualAThrowable).isFalse();
+  }
+
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/dualvalue/DualValue_isExpectedAThrowable_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/dualvalue/DualValue_isExpectedAThrowable_Test.java
new file mode 100644
index 000000000..56d39fc58
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/dualvalue/DualValue_isExpectedAThrowable_Test.java
@@ -0,0 +1,67 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.dualvalue;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.List;
+import java.util.stream.Stream;
+
+import org.apache.commons.lang3.tuple.Pair;
+import org.assertj.core.api.recursive.comparison.DualValue;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class DualValue_isExpectedAThrowable_Test {
+
+  private static final List<String> PATH = list("foo", "bar");
+
+  @ParameterizedTest
+  @MethodSource
+  void isExpectedAThrowable_should_return_true_when_expected_is_a_throwable(Throwable expected) {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "unused", expected);
+    // WHEN
+    boolean isExpectedAThrowable = dualValue.isExpectedAThrowable();
+    // THEN
+    then(isExpectedAThrowable).isTrue();
+  }
+
+  static Stream<Throwable> isExpectedAThrowable_should_return_true_when_expected_is_a_throwable() throws Exception {
+    return Stream.of(new RuntimeException("boom"),
+                     new Throwable("bam"));
+  }
+
+  @Test
+  void isExpectedAThrowable_should_return_false_when_expected_is_not_a_throwable() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "unused", Pair.of(1, "a"));
+    // WHEN
+    boolean isExpectedAThrowable = dualValue.isExpectedAThrowable();
+    // THEN
+    then(isExpectedAThrowable).isFalse();
+  }
+
+  @Test
+  void isExpectedAThrowable_should_return_false_when_expected_is_null() {
+    // GIVEN
+    DualValue dualValue = new DualValue(PATH, "unused", null);
+    // WHEN
+    boolean isExpectedAThrowable = dualValue.isExpectedAThrowable();
+    // THEN
+    then(isExpectedAThrowable).isFalse();
+  }
+
+}
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_with_throwable_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_with_throwable_Test.java
new file mode 100644
index 000000000..68ff09bb3
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_with_throwable_Test.java
@@ -0,0 +1,146 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2025 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison.fields;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.io.IOException;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.recursive.comparison.ComparisonDifference;
+import org.assertj.tests.core.api.recursive.data.Person;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class RecursiveComparisonAssert_isEqualTo_with_throwable_Test extends WithComparingFieldsIntrospectionStrategyBaseTest {
+
+  @ParameterizedTest
+  @MethodSource
+  void should_compare_throwable_recursively(Object actual, Object expected) {
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .isEqualTo(expected);
+  }
+
+  static Stream<Arguments> should_compare_throwable_recursively() {
+    Exception withSuppressedException1 = new Exception("boom");
+    withSuppressedException1.addSuppressed(new Throwable("bam"));
+    Exception withSuppressedException2 = new Exception("boom");
+    withSuppressedException2.addSuppressed(new Throwable("bam"));
+    return Stream.of(arguments(new RuntimeException("boom"),
+                               new RuntimeException("boom")),
+                     arguments(new RuntimeException("boom"),
+                               new Exception("boom")),
+                     arguments(withSuppressedException1, withSuppressedException2),
+                     arguments(new RuntimeException("boom", new Throwable("bam")),
+                               new RuntimeException("boom", new Throwable("bam"))),
+                     arguments(new RuntimeException("boom", new RuntimeException("bam")),
+                               new Throwable("boom", new Throwable("bam"))),
+                     arguments(new Throwable("bam"),
+                               new Throwable("bam")));
+  }
+
+  @Test
+  void should_fail_when_expected_is_not_a_throwable_in_strictTypeChecking_mode() {
+    // GIVEN
+    var actual = new Throwable("bam");
+    var expected = new Person("Tom");
+    recursiveComparisonConfiguration.strictTypeChecking(true);
+    // WHEN/THEN
+    ComparisonDifference difference = diff("", actual, expected,
+                                           "actual and expected are considered different since the comparison enforces strict type check and expected type org.assertj.tests.core.api.recursive.data.Person is not a subtype of actual type java.lang.Throwable");
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_expected_is_not_a_throwable() {
+    // GIVEN
+    var actual = new Throwable("bam");
+    var expected = new Person("Tom");
+    // WHEN/THEN
+    ComparisonDifference difference = diff("", actual, expected,
+                                           "actual field is a java.lang.Throwable but expected field is not (org.assertj.tests.core.api.recursive.data.Person)");
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_actual_and_expected_have_different_messages() {
+    // GIVEN
+    var actual = new Throwable("bam");
+    var expected = new Throwable("boom");
+    // WHEN/THEN
+    ComparisonDifference difference = javaTypeDiff("detailMessage", actual.getMessage(), expected.getMessage());
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_actual_and_expected_have_different_causes() {
+    // GIVEN
+    var actual = new Throwable("boom", new Throwable("bam"));
+    var expected = new Throwable("boom", new Throwable("bim"));
+    // WHEN/THEN
+    ComparisonDifference difference = javaTypeDiff("cause.detailMessage", actual.getCause().getMessage(),
+                                                   expected.getCause().getMessage());
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_actual_and_expected_have_different_suppressed_exceptions() {
+    // GIVEN
+    var actual = new Exception("boom");
+    actual.addSuppressed(new Throwable("bam"));
+    var expected = new Exception("boom");
+    expected.addSuppressed(new Throwable("bim"));
+    // WHEN/THEN
+    ComparisonDifference difference = javaTypeDiff("suppressed[0].detailMessage", "bam", "bim");
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_if_actual_type_inherits_from_expected_type_in_strictTypeChecking_mode() {
+    // GIVEN
+    var actual = new RuntimeException("boom");
+    var expected = new Exception("boom");
+    recursiveComparisonConfiguration.strictTypeChecking(true);
+    // WHEN/THEN
+    ComparisonDifference difference = diff("", actual, expected,
+                                           "actual and expected are considered different since the comparison enforces strict type check and expected type java.lang.Exception is not a subtype of actual type java.lang.RuntimeException");
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_actual_and_expected_have_unrelated_types() {
+    // GIVEN
+    var actual = new RuntimeException("boom");
+    var expected = new IOException("boom");
+    // WHEN/THEN
+    ComparisonDifference difference = diff("", actual, expected,
+                                           "actual is a java.lang.RuntimeException but expected is not (java.io.IOException)");
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  @Test
+  void should_fail_when_actual_and_expected_have_unrelated_types_type_in_strictTypeChecking_mode() {
+    // GIVEN
+    var actual = new RuntimeException("boom");
+    var expected = new IOException("boom");
+    recursiveComparisonConfiguration.strictTypeChecking(true);
+    // WHEN/THEN
+    ComparisonDifference difference = diff("", actual, expected,
+                                           "actual and expected are considered different since the comparison enforces strict type check and expected type java.io.IOException is not a subtype of actual type java.lang.RuntimeException");
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+}
