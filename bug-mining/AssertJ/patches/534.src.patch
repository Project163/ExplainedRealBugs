diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
index f84870670..eda10fe69 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
@@ -33,6 +33,7 @@ import java.util.regex.Pattern;
 // TODO rename to FieldPath?
 public final class FieldLocation implements Comparable<FieldLocation> {
 
+  public static final String FIELD_SEPARATOR = ".";
   private final String pathToUseInRules;
   private final List<String> decomposedPath;
   private final Set<String> pathsHierarchyToUseInRules;
@@ -84,7 +85,7 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     // rules for ignoring fields don't apply at the element level (ex: children.[2]) but at the group level (ex: children).
     return path.stream()
                .filter(subpath -> !subpath.startsWith("["))
-               .collect(joining("."));
+               .collect(joining(FIELD_SEPARATOR));
   }
 
   public boolean exactlyMatches(FieldLocation field) {
@@ -182,6 +183,10 @@ public final class FieldLocation implements Comparable<FieldLocation> {
     return pathToUseInRules;
   }
 
+  public String getPathToUseInRulesForChildField(String fieldName) {
+    return pathToUseInRules.isEmpty() ? fieldName : pathToUseInRules + FIELD_SEPARATOR + fieldName;
+  }
+
   public FieldLocation field(String field) {
     List<String> decomposedPathWithField = new ArrayList<>(decomposedPath);
     decomposedPathWithField.add(field);
@@ -189,7 +194,7 @@ public final class FieldLocation implements Comparable<FieldLocation> {
   }
 
   public String getPathToUseInErrorReport() {
-    return String.join(".", decomposedPath);
+    return String.join(FIELD_SEPARATOR, decomposedPath);
   }
 
   public String getFieldName() {
@@ -209,7 +214,7 @@ public final class FieldLocation implements Comparable<FieldLocation> {
   }
 
   public boolean isTopLevelField() {
-    return !isRoot() && !pathToUseInRules.contains(".");
+    return !isRoot() && !pathToUseInRules.contains(FIELD_SEPARATOR);
   }
 
   public static FieldLocation rootFieldLocation() {
@@ -237,8 +242,8 @@ public final class FieldLocation implements Comparable<FieldLocation> {
    * @return true if this has the given parent (direct or indirect), false otherwise.
    */
   public boolean hasParent(FieldLocation parent) {
-    // "." guarantees that we compare path elements, this avoids making "name" a parent of "names"
-    return pathToUseInRules.startsWith(parent.pathToUseInRules + ".");
+    // FIELD_SEPARATOR guarantees that we compare path elements, this avoids making "name" a parent of "names"
+    return pathToUseInRules.startsWith(parent.pathToUseInRules + FIELD_SEPARATOR);
   }
 
   /**
@@ -279,7 +284,7 @@ public final class FieldLocation implements Comparable<FieldLocation> {
   }
 
   private String parent(String currentPath) {
-    int lastDot = currentPath.lastIndexOf('.');
+    int lastDot = currentPath.lastIndexOf(FIELD_SEPARATOR);
     if (lastDot < 0) {
       return "";
     }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 250a2a58f..0802fb138 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -12,7 +12,19 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
-import org.assertj.core.internal.DeepDifference;
+import static java.lang.String.format;
+import static java.util.Objects.deepEquals;
+import static java.util.stream.Collectors.groupingBy;
+import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.Collectors.toMap;
+import static java.util.stream.StreamSupport.stream;
+import static org.assertj.core.api.recursive.comparison.ComparisonDifference.rootComparisonDifference;
+import static org.assertj.core.api.recursive.comparison.DualValue.DEFAULT_ORDERED_COLLECTION_TYPES;
+import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
+import static org.assertj.core.util.IterableUtil.sizeOf;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Sets.newHashSet;
 
 import java.lang.reflect.Array;
 import java.util.ArrayList;
@@ -34,20 +46,10 @@ import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicLongArray;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
-import static java.lang.String.format;
-import static java.util.Objects.deepEquals;
-import static java.util.stream.Collectors.groupingBy;
-import static java.util.stream.Collectors.joining;
-import static java.util.stream.Collectors.toList;
-import static java.util.stream.StreamSupport.stream;
-import static org.assertj.core.api.recursive.comparison.ComparisonDifference.rootComparisonDifference;
-import static org.assertj.core.api.recursive.comparison.DualValue.DEFAULT_ORDERED_COLLECTION_TYPES;
-import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
-import static org.assertj.core.util.IterableUtil.sizeOf;
-import static org.assertj.core.util.Lists.list;
-import static org.assertj.core.util.Sets.newHashSet;
+import org.assertj.core.internal.DeepDifference;
 
 /**
  * Based on {@link DeepDifference} but takes a {@link RecursiveComparisonConfiguration}, {@link DeepDifference}
@@ -620,9 +622,12 @@ public class RecursiveComparisonDifferenceCalculator {
       return;
     }
 
-    Map<?, ?> actualMap = (Map<?, ?>) dualValue.actual;
-    @SuppressWarnings("unchecked")
-    Map<K, V> expectedMap = (Map<K, V>) dualValue.expected;
+    Map<?, ?> actualMap = filterIgnoredFields((Map<?, ?>) dualValue.actual, dualValue.fieldLocation,
+                                              comparisonState.recursiveComparisonConfiguration);
+    Map<K, V> expectedMap = (Map<K, V>) filterIgnoredFields((Map<?, ?>) dualValue.expected,
+                                                            dualValue.fieldLocation,
+                                                            comparisonState.recursiveComparisonConfiguration);
+
     if (actualMap.size() != expectedMap.size()) {
       comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "sorted maps", actualMap.size(), expectedMap.size()));
       // no need to inspect entries, maps are not equal as they don't have the same size
@@ -649,8 +654,11 @@ public class RecursiveComparisonDifferenceCalculator {
       return;
     }
 
-    Map<?, ?> actualMap = (Map<?, ?>) dualValue.actual;
-    Map<?, ?> expectedMap = (Map<?, ?>) dualValue.expected;
+    Map<?, ?> actualMap = filterIgnoredFields((Map<?, ?>) dualValue.actual, dualValue.fieldLocation,
+                                              comparisonState.recursiveComparisonConfiguration);
+    Map<?, ?> expectedMap = filterIgnoredFields((Map<?, ?>) dualValue.expected, dualValue.fieldLocation,
+                                                comparisonState.recursiveComparisonConfiguration);
+
     if (actualMap.size() != expectedMap.size()) {
       comparisonState.addDifference(dualValue, format(DIFFERENT_SIZE_ERROR, "maps", actualMap.size(), expectedMap.size()));
       // no need to inspect entries, maps are not equal as they don't have the same size
@@ -671,6 +679,20 @@ public class RecursiveComparisonDifferenceCalculator {
     }
   }
 
+  private static Map<?, ?> filterIgnoredFields(Map<?, ?> map, FieldLocation fieldLocation,
+                                               RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
+    Set<String> ignoredFields = recursiveComparisonConfiguration.getIgnoredFields();
+    List<Pattern> ignoredFieldsRegexes = recursiveComparisonConfiguration.getIgnoredFieldsRegexes();
+    if (ignoredFields.isEmpty() && ignoredFieldsRegexes.isEmpty()) {
+      return map;
+    }
+    return map.entrySet().stream()
+              .filter(e -> !recursiveComparisonConfiguration.matchesAnIgnoredField(fieldLocation.field(e.getKey().toString())))
+              .filter(e -> !recursiveComparisonConfiguration.matchesAnIgnoredFieldRegex(fieldLocation.field(e.getKey()
+                                                                                                             .toString())))
+              .collect(toMap(Map.Entry::getKey, Map.Entry::getValue));
+  }
+
   private static FieldLocation keyFieldLocation(FieldLocation parentFieldLocation, Object key) {
     return key == null ? parentFieldLocation : parentFieldLocation.field(key.toString());
   }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
index 949240649..a22c2d4ab 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringFields_Test.java
@@ -12,16 +12,16 @@
  */
 package org.assertj.tests.core.api.recursive.comparison;
 
-import org.assertj.core.api.recursive.comparison.ComparisonDifference;
-import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
-import org.assertj.tests.core.api.recursive.data.Address;
-import org.assertj.tests.core.api.recursive.data.Giant;
-import org.assertj.tests.core.api.recursive.data.Human;
-import org.assertj.tests.core.api.recursive.data.Person;
-import org.junit.jupiter.api.Test;
-import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.Arguments;
-import org.junit.jupiter.params.provider.MethodSource;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.MapEntry.entry;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Sets.newHashSet;
+import static org.assertj.tests.core.api.recursive.comparison.WithMap.withMap;
+import static org.assertj.tests.core.testkit.Maps.mapOf;
+import static org.assertj.tests.core.testkit.Maps.treeMapOf;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.util.ArrayList;
 import java.util.Collection;
@@ -35,20 +35,24 @@ import java.util.OptionalInt;
 import java.util.OptionalLong;
 import java.util.stream.Stream;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.BDDAssertions.then;
-import static org.assertj.core.util.Arrays.array;
-import static org.assertj.core.util.Lists.list;
-import static org.assertj.core.util.Sets.newHashSet;
-import static org.junit.jupiter.params.provider.Arguments.arguments;
+import org.assertj.core.api.recursive.comparison.ComparisonDifference;
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
+import org.assertj.core.data.MapEntry;
+import org.assertj.tests.core.api.recursive.data.Address;
+import org.assertj.tests.core.api.recursive.data.Giant;
+import org.assertj.tests.core.api.recursive.data.Human;
+import org.assertj.tests.core.api.recursive.data.Person;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
 @SuppressWarnings("unused")
 class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveComparisonAssert_isEqualTo_BaseTest {
 
   @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
   @MethodSource("recursivelyEqualObjectsIgnoringActualNullValues")
-  void should_pass_when_actual_null_fields_are_ignored(Object actual, Object expected,
-                                                       @SuppressWarnings("unused") String testDescription) {
+  void should_pass_when_actual_null_fields_are_ignored(Object actual, Object expected, String testDescription) {
     assertThat(actual).usingRecursiveComparison()
                       .ignoringActualNullFields()
                       .isEqualTo(expected);
@@ -105,16 +109,16 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
   }
 
   @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
-  @MethodSource("recursivelyEqualObjectsIgnoringActualOptionalEmptyValues")
+  @MethodSource
   void should_pass_when_actual_empty_optional_fields_are_ignored(Object actual,
                                                                  Object expected,
-                                                                 @SuppressWarnings("unused") String testDescription) {
+                                                                 String testDescription) {
     assertThat(actual).usingRecursiveComparison()
                       .ignoringActualEmptyOptionalFields()
                       .isEqualTo(expected);
   }
 
-  private static Stream<Arguments> recursivelyEqualObjectsIgnoringActualOptionalEmptyValues() {
+  private static Stream<Arguments> should_pass_when_actual_empty_optional_fields_are_ignored() {
     Person person1 = new Person("John");
     person1.home.address.number = 1;
     person1.phone = Optional.empty();
@@ -202,7 +206,7 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
 
   @SuppressWarnings("unused")
   @ParameterizedTest(name = "{2}: actual={0} / expected={1} / ignored fields={3}")
-  @MethodSource("recursivelyEqualObjectsIgnoringGivenFields")
+  @MethodSource
   void should_pass_for_objects_with_the_same_data_when_given_fields_are_ignored(Object actual,
                                                                                 Object expected,
                                                                                 String testDescription,
@@ -212,13 +216,13 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
                       .isEqualTo(expected);
   }
 
-  private static Stream<Arguments> recursivelyEqualObjectsIgnoringGivenFields() {
+  private static Stream<Arguments> should_pass_for_objects_with_the_same_data_when_given_fields_are_ignored() {
     Person person1 = new Person("John");
     person1.home.address.number = 1;
 
-    Person giant1 = new Giant();
+    Giant giant1 = new Giant();
     giant1.name = "Giant John";
-    ((Giant) giant1).height = 3.1;
+    giant1.height = 3.1;
     giant1.home.address.number = 1;
 
     Person person2 = new Person("Jack");
@@ -278,6 +282,170 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
                                array("neighbour.neighbour.home.address.number", "neighbour.name")));
   }
 
+  @SuppressWarnings("unused")
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1} / ignored fields={3}")
+  @MethodSource
+  void should_pass_for_maps_when_given_fields_are_ignored(Object actual,
+                                                          Object expected,
+                                                          String testDescription,
+                                                          String[] ignoredFields) {
+    assertThat(actual).usingRecursiveComparison()
+                      .ignoringFields(ignoredFields)
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_pass_for_maps_when_given_fields_are_ignored() {
+    MapEntry<String, Person> tim = entry("spurs", new Person("Tim Duncan"));
+    MapEntry<String, Person> manu = entry("spurs", new Person("Manu Ginobili"));
+    MapEntry<String, Person> kobe = entry("lakers", new Person("Kobe Bryant"));
+    MapEntry<String, String> firstNameJohn = entry("firstName", "John");
+    MapEntry<String, String> lastNameDoe = entry("lastName", "Doe");
+    MapEntry<String, String> lastNameWick = entry("lastName", "Wick");
+    return Stream.of(arguments(mapOf(firstNameJohn, lastNameDoe),
+                               mapOf(firstNameJohn, lastNameWick),
+                               "maps with same size, one common root field ignored", array("lastName")),
+                     arguments(mapOf(firstNameJohn, lastNameDoe),
+                               mapOf(firstNameJohn, lastNameDoe, entry("age", "25")),
+                               "maps of different size, one ignored field: 'age'", array("age")),
+                     arguments(mapOf(firstNameJohn, lastNameDoe),
+                               mapOf(firstNameJohn, lastNameWick, entry("age", "25")),
+                               "maps of different size, two ignored fields: 'age', 'lastName'", array("age", "lastName")),
+                     arguments(mapOf(firstNameJohn, lastNameDoe),
+                               mapOf(firstNameJohn, lastNameWick, entry("age", "25")),
+                               "maps of different size, all fields ignored", array("age", "lastName", "firstName")),
+                     arguments(withMap(mapOf(firstNameJohn, lastNameDoe)),
+                               withMap(mapOf(firstNameJohn, lastNameWick)),
+                               "maps with same size, one common inner field ignored", array("map.lastName")),
+                     arguments(withMap(mapOf(tim, kobe)),
+                               withMap(mapOf(manu, kobe)),
+                               "maps with same keys but the one where Person values differs is ignored",
+                               array("map.spurs")),
+                     arguments(treeMapOf(firstNameJohn, lastNameDoe),
+                               treeMapOf(firstNameJohn, lastNameWick),
+                               "ordered maps with same size, one common root field ignored", array("lastName")),
+                     arguments(treeMapOf(firstNameJohn, lastNameDoe),
+                               treeMapOf(firstNameJohn, lastNameDoe, entry("age", "25")),
+                               "ordered maps of different size, one ignored field: 'age'", array("age")),
+                     arguments(treeMapOf(firstNameJohn, lastNameDoe),
+                               treeMapOf(firstNameJohn, lastNameWick, entry("age", "25")),
+                               "ordered maps of different size, two ignored fields: 'age', 'lastName'", array("age", "lastName")),
+                     arguments(treeMapOf(firstNameJohn, lastNameDoe),
+                               treeMapOf(firstNameJohn, lastNameWick, entry("age", "25")),
+                               "ordered maps of different size, all fields ignored", array("age", "lastName", "firstName")),
+                     arguments(withMap(treeMapOf(firstNameJohn, lastNameDoe)),
+                               withMap(treeMapOf(firstNameJohn, lastNameWick)),
+                               "ordered maps with same size, one common inner field ignored", array("map.lastName")),
+                     arguments(withMap(treeMapOf(tim, kobe)),
+                               withMap(treeMapOf(manu, kobe)),
+                               "ordered maps with same keys but the one where Person values differs is ignored",
+                               array("map.spurs")));
+  }
+
+  @ParameterizedTest(name = "{2}: actual={0} / expected={1} / ignored fields regex={3}")
+  @MethodSource
+  void should_pass_for_maps_with_the_various_sizes_when_given_fields_are_ignored_by_regex(Object actual,
+                                                                                          Object expected,
+                                                                                          String testDescription,
+                                                                                          String regex) {
+    assertThat(actual).usingRecursiveComparison()
+                      .ignoringFieldsMatchingRegexes(regex)
+                      .isEqualTo(expected);
+  }
+
+  private static Stream<Arguments> should_pass_for_maps_with_the_various_sizes_when_given_fields_are_ignored_by_regex() {
+    MapEntry<String, Person> tim = entry("spurs", new Person("Tim Duncan"));
+    MapEntry<String, Person> manu = entry("spurs", new Person("Manu Ginobili"));
+    MapEntry<String, Person> kobe = entry("lakers", new Person("Kobe Bryant"));
+    MapEntry<String, String> firstNameJohn = entry("firstName", "John");
+    MapEntry<String, String> lastNameDoe = entry("lastName", "Doe");
+    MapEntry<String, String> lastNameWick = entry("lastName", "Wick");
+    return Stream.of(arguments(mapOf(firstNameJohn, lastNameDoe),
+                               mapOf(firstNameJohn, lastNameWick),
+                               "maps with same size, one common root field ignored", ".astNa.."),
+                     arguments(mapOf(firstNameJohn, lastNameDoe),
+                               mapOf(firstNameJohn, lastNameDoe, entry("age", "25")),
+                               "maps of different size, one ignored field: 'age'", "ag."),
+                     arguments(mapOf(firstNameJohn, lastNameDoe),
+                               mapOf(firstNameJohn, lastNameWick, entry("age", "25")),
+                               "maps of different size, two ignored fields: 'age', 'lastName'", "age|lastName"),
+                     arguments(mapOf(firstNameJohn, lastNameDoe),
+                               mapOf(firstNameJohn, lastNameWick, entry("age", "25")),
+                               "maps of different size, all fields ignored", "age|lastName|firstName"),
+                     arguments(withMap(mapOf(firstNameJohn, lastNameDoe)),
+                               withMap(mapOf(firstNameJohn, lastNameWick)),
+                               "maps with same size, one common inner field ignored", "map\\.last.*"),
+                     arguments(withMap(mapOf(tim, kobe)),
+                               withMap(mapOf(manu, kobe)),
+                               "maps with same keys but the one where Person values differs is ignored", "map\\.sp.*s"),
+                     arguments(treeMapOf(firstNameJohn, lastNameDoe),
+                               treeMapOf(firstNameJohn, lastNameWick),
+                               "ordered maps with same size, one common root field ignored", "last.*"),
+                     arguments(treeMapOf(firstNameJohn, lastNameDoe),
+                               treeMapOf(firstNameJohn, lastNameDoe, entry("age", "25")),
+                               "ordered maps of different size, one ignored field: 'age'", "a.e"),
+                     arguments(treeMapOf(firstNameJohn, lastNameDoe),
+                               treeMapOf(firstNameJohn, lastNameWick, entry("age", "25")),
+                               "ordered maps of different size, two ignored fields: 'age', 'lastName'", "age|lastName"),
+                     arguments(treeMapOf(firstNameJohn, lastNameDoe),
+                               treeMapOf(firstNameJohn, lastNameWick, entry("age", "25")),
+                               "ordered maps of different size, all fields ignored", "age|lastName|firstName"),
+                     arguments(withMap(treeMapOf(firstNameJohn, lastNameDoe)),
+                               withMap(treeMapOf(firstNameJohn, lastNameWick)),
+                               "ordered maps with same size, one common inner field ignored", "map\\.la..Name"),
+                     arguments(withMap(treeMapOf(tim, kobe)),
+                               withMap(treeMapOf(manu, kobe)),
+                               "maps with same keys but the one where Person values differs is ignored", "map\\.sp.*s"));
+  }
+
+  @ParameterizedTest(name = "{4}: actual={0} / expected={1} / ignored fields={2} / ignored fields={3}")
+  @MethodSource
+  void should_fail_as_ignored_field_is_not_matched_in_map(Object actual, Object expected, String[] ignoredFields,
+                                                          ComparisonDifference difference, String testDescription) {
+    // WHEN
+    recursiveComparisonConfiguration.ignoreFields(ignoredFields);
+    // THEN
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  private static Stream<Arguments> should_fail_as_ignored_field_is_not_matched_in_map() {
+    Object actual1 = withMap(mapOf(entry("firstName", "John"), entry("lastName", "Doe")));
+    Object expected1 = withMap(mapOf(entry("firstName", "John"), entry("lastName", "Wick")));
+    ComparisonDifference difference1 = javaTypeDiff("map.lastName", "Doe", "Wick");
+
+    Object actual2 = withMap(treeMapOf(entry("firstName", "John"), entry("lastName", "Doe")));
+    Object expected2 = withMap(treeMapOf(entry("firstName", "John"), entry("lastName", "Wick")));
+    ComparisonDifference difference2 = javaTypeDiff("map.lastName", "Doe", "Wick");
+
+    return Stream.of(
+                     arguments(actual1, expected1, array("lastName"), difference1,
+                               "unordered maps, ignored field is not matched"),
+                     arguments(actual2, expected2, array("lastName"), difference2, "ordered maps, ignored field is not matched"));
+  }
+
+  @ParameterizedTest(name = "{4}: actual={0} / expected={1} / ignored fields regex={2} / ignored fields={3}")
+  @MethodSource
+  void should_fail_as_ignored_field_by_regex_is_not_matched_in_map(Object actual, Object expected, String regex,
+                                                                   ComparisonDifference difference, String testDescription) {
+    // WHEN
+    recursiveComparisonConfiguration.ignoreFieldsMatchingRegexes(regex);
+    // THEN
+    compareRecursivelyFailsWithDifferences(actual, expected, difference);
+  }
+
+  private static Stream<Arguments> should_fail_as_ignored_field_by_regex_is_not_matched_in_map() {
+    Object actual1 = withMap(mapOf(entry("firstName", "John"), entry("lastName", "Doe")));
+    Object expected1 = withMap(mapOf(entry("firstName", "John"), entry("lastName", "Wick")));
+    ComparisonDifference difference1 = javaTypeDiff("map.lastName", "Doe", "Wick");
+
+    Object actual2 = withMap(treeMapOf(entry("firstName", "John"), entry("lastName", "Doe")));
+    Object expected2 = withMap(treeMapOf(entry("firstName", "John"), entry("lastName", "Wick")));
+    ComparisonDifference difference2 = javaTypeDiff("map.lastName", "Doe", "Wick");
+
+    return Stream.of(
+                     arguments(actual1, expected1, ".ast.*", difference1, "unordered maps, ignored field is not matched"),
+                     arguments(actual2, expected2, ".ast.*", difference2, "ordered maps, ignored field is not matched"));
+  }
+
   @Test
   void should_fail_when_actual_differs_from_expected_even_when_some_fields_are_ignored() {
     // GIVEN
@@ -310,25 +478,24 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
     compareRecursivelyFailsWithDifferences(actual, expected, dateOfBirthDifference, neighbourNameDifference, numberDifference);
   }
 
-  @SuppressWarnings("unused")
   @ParameterizedTest(name = "{2}: actual={0} / expected={1} / ignored fields regex={3}")
-  @MethodSource("recursivelyEqualObjectsWhenFieldsMatchingGivenRegexesAreIgnored")
+  @MethodSource
   void should_pass_when_fields_matching_given_regexes_are_ignored(Object actual,
                                                                   Object expected,
                                                                   String testDescription,
-                                                                  List<String> ignoredFieldRegexes) {
+                                                                  String[] ignoredFieldRegexes) {
     assertThat(actual).usingRecursiveComparison()
-                      .ignoringFieldsMatchingRegexes(arrayOf(ignoredFieldRegexes))
+                      .ignoringFieldsMatchingRegexes(ignoredFieldRegexes)
                       .isEqualTo(expected);
   }
 
-  private static Stream<Arguments> recursivelyEqualObjectsWhenFieldsMatchingGivenRegexesAreIgnored() {
+  private static Stream<Arguments> should_pass_when_fields_matching_given_regexes_are_ignored() {
     Person person1 = new Person("John");
     person1.home.address.number = 1;
 
-    Person giant1 = new Giant();
+    Giant giant1 = new Giant();
     giant1.name = "Giant John";
-    ((Giant) giant1).height = 3.1;
+    giant1.height = 3.1;
     giant1.home.address.number = 1;
 
     Person person2 = new Person("Jack");
@@ -360,12 +527,12 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
     person8.neighbour.neighbour.home.address.number = 457;
 
     // @format:off
-    return Stream.of(arguments(person1, person2, "same data and type, except for one ignored field", list("nam.")),
-                     arguments(giant1, person1, "different type, same data except name and height which is not even a field from person1", list(".am.", "height")),
-                     arguments(person3, person4, "same data, different type, except for name and home.address.number", list(".*n.m.*")),
-                     arguments(person5, person6, "same data except for one subfield of an ignored field", list("home.*")),
-                     arguments(person7, person8, "same data except for one subfield of an ignored field", list("neighbour.*")),
-                     arguments(person7, person8, "should not stack overflow with regexes", list(".*neighbour[\\D]+", ".*update[\\D]+")));
+    return Stream.of(arguments(person1, person2, "same data and type, except for one ignored field", array("nam.")),
+                     arguments(giant1, person1, "different type, same data except name and height which is not even a field from person1", array(".am.", "height")),
+                     arguments(person3, person4, "same data, different type, except for name and home.address.number", array(".*n.m.*")),
+                     arguments(person5, person6, "same data except for one subfield of an ignored field", array("home.*")),
+                     arguments(person7, person8, "same data except for one subfield of an ignored field", array("neighbour.*")),
+                     arguments(person7, person8, "should not stack overflow with regexes", array(".*neighbour[\\D]+", ".*update[\\D]+")));
     // @format:on
   }
 
@@ -555,7 +722,7 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
   }
 
   @ParameterizedTest(name = "{2}: actual={0} / expected={1}")
-  @MethodSource("recursivelyEqualObjectsIgnoringExpectedNullFields")
+  @MethodSource
   void should_pass_when_expected_null_fields_are_ignored(Object actual, Object expected,
                                                          @SuppressWarnings("unused") String testDescription) {
 
@@ -564,7 +731,7 @@ class RecursiveComparisonAssert_isEqualTo_ignoringFields_Test extends RecursiveC
                 .isEqualTo(expected);
   }
 
-  private static Stream<Arguments> recursivelyEqualObjectsIgnoringExpectedNullFields() {
+  private static Stream<Arguments> should_pass_when_expected_null_fields_are_ignored() {
     Person person1 = new Person("John");
     person1.home.address.number = 1;
 
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
index 5951c107a..f8c7f8455 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_with_maps_Test.java
@@ -42,14 +42,14 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
   @Test
   void should_fail_when_comparing_actual_unsorted_with_expected_sorted_map() {
     WithMap<Long, Boolean> actual = new WithMap<>(new LinkedHashMap<>());
-    actual.group.put(1L, true);
-    actual.group.put(2L, false);
+    actual.map.put(1L, true);
+    actual.map.put(2L, false);
     WithMap<Long, Boolean> expected = new WithMap<>(new TreeMap<>());
-    expected.group.put(2L, false);
-    expected.group.put(1L, true);
+    expected.map.put(2L, false);
+    expected.map.put(1L, true);
 
     // WHEN/THEN
-    ComparisonDifference mapDifference = diff("group", actual.group, expected.group,
+    ComparisonDifference mapDifference = diff("map", actual.map, expected.map,
                                               "expected field is a sorted map but actual field is not (java.util.LinkedHashMap)");
     compareRecursivelyFailsWithDifferences(actual, expected, mapDifference);
   }
@@ -61,8 +61,8 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
     WithMap<String, Author> actual = new WithMap<>(authors1);
     WithMap<String, Author> expected = new WithMap<>(authors2);
     // THEN
-    assertThat(actual).usingRecursiveComparison()
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison()
+                .isEqualTo(expected);
   }
 
   static Stream<Arguments> sameMaps() {
@@ -110,35 +110,35 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
                                                             entry(georgeMartin.name, georgeMartin));
     Map<String, Author> singletonPratchettMap = singletonMap(pratchett.name, pratchett);
     Map<String, Author> singletonGeorgeMartinMap = singletonMap(georgeMartin.name, georgeMartin);
-    return Stream.of(Arguments.of(singletonPratchettMap, singletonGeorgeMartinMap, "group",
+    return Stream.of(Arguments.of(singletonPratchettMap, singletonGeorgeMartinMap, "map",
                                   singletonPratchettMap, singletonGeorgeMartinMap,
                                   format("The following keys were not found in the actual map value:%n  [George Martin]")),
-                     Arguments.of(nonSortedPratchettAndMartin, singletonPratchettMap, "group",
+                     Arguments.of(nonSortedPratchettAndMartin, singletonPratchettMap, "map",
                                   nonSortedPratchettAndMartin, singletonPratchettMap,
                                   "actual and expected values are maps of different size, actual size=2 when expected size=1"),
-                     Arguments.of(sortedMartinAndPratchett, sortedPratchettMap, "group",
+                     Arguments.of(sortedMartinAndPratchett, sortedPratchettMap, "map",
                                   sortedMartinAndPratchett, sortedPratchettMap,
                                   "actual and expected values are sorted maps of different size, actual size=2 when expected size=1"),
-                     Arguments.of(nonSortedPratchettAndMartin, sortedMartinAndPratchett, "group",
+                     Arguments.of(nonSortedPratchettAndMartin, sortedMartinAndPratchett, "map",
                                   nonSortedPratchettAndMartin, sortedMartinAndPratchett,
                                   "expected field is a sorted map but actual field is not (java.util.LinkedHashMap)"),
-                     Arguments.of(singletonMap(pratchett.name, none), singletonPratchettMap, "group.Terry Pratchett",
+                     Arguments.of(singletonMap(pratchett.name, none), singletonPratchettMap, "map.Terry Pratchett",
                                   none, pratchett, null),
-                     Arguments.of(singletonPratchettMap, singletonMap(georgeMartin.name, pratchett), "group",
+                     Arguments.of(singletonPratchettMap, singletonMap(georgeMartin.name, pratchett), "map",
                                   singletonPratchettMap, singletonMap(georgeMartin.name, pratchett),
                                   format("The following keys were not found in the actual map value:%n  [George Martin]")),
-                     Arguments.of(singletonPratchettMap, empty, "group",
+                     Arguments.of(singletonPratchettMap, empty, "map",
                                   singletonPratchettMap, empty,
                                   "actual and expected values are maps of different size, actual size=1 when expected size=0"));
   }
 
   @ParameterizedTest(name = "authors {0} / object {1} / path {2} / value 1 {3}/ value 2 {4}")
-  @MethodSource("mapWithNonMaps")
+  @MethodSource
   void should_fail_when_comparing_map_to_non_map(Object actualFieldValue, Map<String, Author> expectedFieldValue,
                                                  String path, Object value1, Object value2, String desc) {
     // GIVEN
     WithObject actual = new WithObject(actualFieldValue);
-    WithMap<String, Author> expected = new WithMap<>(expectedFieldValue);
+    WithObject expected = new WithObject(expectedFieldValue);
     // WHEN/THEN
     ComparisonDifference difference = desc == null ? diff(path, value1, value2) : diff(path, value1, value2, desc);
     compareRecursivelyFailsWithDifferences(actual, expected, difference);
@@ -155,7 +155,7 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
     then(assertionError).hasMessageContaining(format("The following keys were not found in the actual map value:%n  [c, d]"));
   }
 
-  static Stream<Arguments> mapWithNonMaps() {
+  static Stream<Arguments> should_fail_when_comparing_map_to_non_map() {
     Author pratchett = new Author("Terry Pratchett");
     Author georgeMartin = new Author("George Martin");
     Author none = null;
@@ -165,18 +165,4 @@ class RecursiveComparisonAssert_isEqualTo_with_maps_Test extends RecursiveCompar
                      Arguments.of(none, mapOfTwoAuthors, "group", none, mapOfTwoAuthors, null));
   }
 
-  public static class WithMap<K, V> {
-    public Map<K, V> group;
-
-    public WithMap(Map<K, V> map) {
-      this.group = map;
-    }
-
-    @Override
-    public String toString() {
-      return format("WithMap group=r%s", group);
-    }
-
-  }
-
 }
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/WithMap.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/WithMap.java
new file mode 100644
index 000000000..bf6d55da2
--- /dev/null
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/WithMap.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2024 the original author or authors.
+ */
+package org.assertj.tests.core.api.recursive.comparison;
+
+import static java.lang.String.format;
+
+import java.util.Map;
+
+public class WithMap<K, V> {
+  public Map<K, V> map;
+
+  public WithMap(Map<K, V> map) {
+    this.map = map;
+  }
+
+  public static <K, V> WithMap<K, V> withMap(Map<K, V> map) {
+    return new WithMap<>(map);
+  }
+
+  @Override
+  public String toString() {
+    return format("WithMap map=r%s", map);
+  }
+
+}
