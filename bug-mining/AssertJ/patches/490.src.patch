diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index c6782aec7..0544b6c8d 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -68,10 +68,22 @@ public final class DualValue {
   public boolean equals(Object other) {
     if (!(other instanceof DualValue)) return false;
     DualValue that = (DualValue) other;
-    // it is critical to compare by reference when tracking visited dual values.
-    // see should_fix_1854_minimal_test for an explanation
-    // TODO add field location check?
-    return actual == that.actual && expected == that.expected;
+    return actual == that.actual && expected == that.expected && fieldLocation.equals(that.fieldLocation);
+  }
+
+  /**
+   * If we want to detect potential cycles in the recursive comparison, we need to check if an object has already been visited.
+   * <p>
+   * We must ignore the {@link FieldLocation} otherwise we would not find cycles. Let's take for example a {@code Person} class
+   * with a neighbor field. We have a cycle between the person instance and its neighbor instance, ex: Jack has Tim as neighbor
+   * and vice versa, when we navigate to Tim we find that its neighbor is Jack, we have already visited it but the location is
+   * different, Jack is both the root object and root.neighbor.neighbor (Jack=root, Tim=root.neighbor and Tim.neighbor=Jack)
+   *
+   * @param dualValue the {@link DualValue} to compare
+   * @return true if dual values references the same values (ignoring the field location)
+   */
+  public boolean sameValues(DualValue dualValue) {
+    return actual == dualValue.actual && expected == dualValue.expected;
   }
 
   @Override
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
index 03a8de585..80b83cea2 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/FieldLocation.java
@@ -84,7 +84,7 @@ public final class FieldLocation implements Comparable<FieldLocation> {
 
   @Override
   public String toString() {
-    return String.format("FieldLocation [pathToUseInRules=%s, decomposedPath=%s]", pathToUseInRules, decomposedPath);
+    return String.format("<%s>", pathToUseInRules);
   }
 
   public String shortDescription() {
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 736788502..848f72743 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -49,7 +49,7 @@ import org.assertj.core.internal.DeepDifference;
 
 /**
  * Based on {@link DeepDifference} but takes a {@link RecursiveComparisonConfiguration}, {@link DeepDifference}
- * being itself based on the deep equals implementation of https://github.com/jdereg/java-util
+ * being itself based on the deep equals implementation of <a href="https://github.com/jdereg/java-util">https://github.com/jdereg/java-util</a>
  *
  * @author John DeRegnaucourt (john@cedarsoftware.com)
  * @author Pascal Schumacher
@@ -69,23 +69,28 @@ public class RecursiveComparisonDifferenceCalculator {
 
   private static class ComparisonState {
     // Not using a Set as we want to precisely track visited values, a set would remove duplicates
-    List<DualValue> visitedDualValues;
+    VisitedDualValues visitedDualValues;
     List<ComparisonDifference> differences = new ArrayList<>();
     DualValueDeque dualValuesToCompare;
     RecursiveComparisonConfiguration recursiveComparisonConfiguration;
 
-    public ComparisonState(List<DualValue> visited, RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
-      this.visitedDualValues = visited;
+    public ComparisonState(VisitedDualValues visitedDualValues,
+                           RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
+      this.visitedDualValues = visitedDualValues;
       this.dualValuesToCompare = new DualValueDeque(recursiveComparisonConfiguration);
       this.recursiveComparisonConfiguration = recursiveComparisonConfiguration;
     }
 
     void addDifference(DualValue dualValue) {
-      differences.add(new ComparisonDifference(dualValue, null, getCustomErrorMessage(dualValue)));
+      addDifference(dualValue, null);
     }
 
     void addDifference(DualValue dualValue, String description) {
-      differences.add(new ComparisonDifference(dualValue, description, getCustomErrorMessage(dualValue)));
+      String customErrorMessage = getCustomErrorMessage(dualValue);
+      ComparisonDifference comparisonDifference = new ComparisonDifference(dualValue, description, customErrorMessage);
+      differences.add(comparisonDifference);
+      // track the difference for the given dual values, in case we visit the same dual values again
+      visitedDualValues.registerComparisonDifference(dualValue, comparisonDifference);
     }
 
     void addKeyDifference(DualValue parentDualValue, Object actualKey, Object expectedKey) {
@@ -102,17 +107,11 @@ public class RecursiveComparisonDifferenceCalculator {
     }
 
     public DualValue pickDualValueToCompare() {
-      final DualValue dualValue = dualValuesToCompare.removeFirst();
-      if (dualValue.hasPotentialCyclingValues()) {
-        // visited dual values are here to avoid cycle, java types don't have cycle, there is no need to track them.
-        // moreover this would make should_fix_1854_minimal_test to fail (see the test for a detailed explanation)
-        visitedDualValues.add(dualValue);
-      }
-      return dualValue;
+      return dualValuesToCompare.removeFirst();
     }
 
     private void registerForComparison(DualValue dualValue) {
-      if (!visitedDualValues.contains(dualValue)) dualValuesToCompare.addFirst(dualValue);
+      dualValuesToCompare.addFirst(dualValue);
     }
 
     private void initDualValuesToCompare(Object actual, Object expected, FieldLocation nodeLocation) {
@@ -120,8 +119,7 @@ public class RecursiveComparisonDifferenceCalculator {
       boolean mustCompareNodesRecursively = mustCompareNodesRecursively(dualValue);
       if (dualValue.hasNoNullValues() && mustCompareNodesRecursively) {
         // disregard the equals method and start comparing fields
-        // TODO should fail if actual and expected don't have the same fields to compare (taking into account ignored/compared
-        // fields)
+        // TODO should fail if actual and expected don't have the same fields (taking into account ignored/compared fields)
         Set<String> actualChildrenNodeNamesToCompare = recursiveComparisonConfiguration.getActualChildrenNodeNamesToCompare(dualValue);
         if (!actualChildrenNodeNamesToCompare.isEmpty()) {
           // fields to ignore are evaluated when adding their corresponding dualValues to dualValuesToCompare which filters
@@ -134,30 +132,20 @@ public class RecursiveComparisonDifferenceCalculator {
               Object expectedChildNodeValue = recursiveComparisonConfiguration.getValue(actualChildNodeName, expected);
               DualValue childNodeDualValue = new DualValue(nodeLocation.field(actualChildNodeName), actualChildNodeValue,
                                                            expectedChildNodeValue);
-              dualValuesToCompare.addFirst(childNodeDualValue);
+              registerForComparison(childNodeDualValue);
             }
           } else {
-            dualValuesToCompare.addFirst(dualValue);
+            registerForComparison(dualValue);
           }
         } else {
-          dualValuesToCompare.addFirst(dualValue);
+          registerForComparison(dualValue);
         }
       } else {
-        dualValuesToCompare.addFirst(dualValue);
+        registerForComparison(dualValue);
       }
-      // We need to remove already visited nodes pair to avoid infinite recursion in case parent -> set{child} with child having
-      // a reference back to its parent but only for complex types can have cycle, this is not the case for primitive or enums.
-      // It occurs for unordered collection where we compare all possible combination of the collection elements recursively.
-      // --
-      // remove visited values one by one, DualValue.equals correctly compare respective actual and expected fields by reference
-      visitedDualValues.forEach(visitedDualValue -> dualValuesToCompare.stream()
-                                                                       .filter(dualValueToCompare -> dualValueToCompare.equals(visitedDualValue))
-                                                                       .findFirst()
-                                                                       .ifPresent(dualValuesToCompare::remove));
     }
 
     private boolean mustCompareNodesRecursively(DualValue dualValue) {
-
       return !recursiveComparisonConfiguration.hasCustomComparator(dualValue)
              && !shouldHonorEquals(dualValue, recursiveComparisonConfiguration)
              && dualValue.hasNoContainerValues();
@@ -203,20 +191,36 @@ public class RecursiveComparisonDifferenceCalculator {
     if (recursiveComparisonConfiguration.isInStrictTypeCheckingMode() && expectedTypeIsNotSubtypeOfActualType(actual, expected)) {
       return list(expectedAndActualTypeDifference(actual, expected));
     }
-    List<DualValue> visited = list();
-    return determineDifferences(actual, expected, rootFieldLocation(), visited, recursiveComparisonConfiguration);
+    return determineDifferences(actual, expected, rootFieldLocation(), new VisitedDualValues(), recursiveComparisonConfiguration);
   }
 
   // TODO keep track of ignored fields in an RecursiveComparisonExecution class ?
 
   private static List<ComparisonDifference> determineDifferences(Object actual, Object expected, FieldLocation fieldLocation,
-                                                                 List<DualValue> visited,
+                                                                 VisitedDualValues visitedDualValues,
                                                                  RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
-    ComparisonState comparisonState = new ComparisonState(visited, recursiveComparisonConfiguration);
+    ComparisonState comparisonState = new ComparisonState(visitedDualValues, recursiveComparisonConfiguration);
     comparisonState.initDualValuesToCompare(actual, expected, fieldLocation);
 
     while (comparisonState.hasDualValuesToCompare()) {
+
       final DualValue dualValue = comparisonState.pickDualValueToCompare();
+      // if we have already visited the dual value, no need to compute the comparison differences again, this also avoid cycles
+      Optional<List<ComparisonDifference>> comparisonDifferences = comparisonState.visitedDualValues.registeredComparisonDifferencesOf(dualValue);
+      if (comparisonDifferences.isPresent()) {
+        if (!comparisonDifferences.get().isEmpty()) {
+          comparisonState.addDifference(dualValue, "already visited node but now location is: " + dualValue.fieldLocation);
+        }
+        continue;
+      }
+
+      // first time we evaluate this dual value, perform the usual recursive comparison from there
+
+      if (dualValue.hasPotentialCyclingValues()) {
+        // visited dual values are tracked to avoid cycle, java types don't have cycle => no need to keep track of them.
+        // moreover this would make should_fix_1854_minimal_test to fail (see the test for a detailed explanation)
+        comparisonState.visitedDualValues.registerVisitedDualValue(dualValue);
+      }
 
       final Object actualFieldValue = dualValue.actual;
       final Object expectedFieldValue = dualValue.expected;
@@ -767,11 +771,11 @@ public class RecursiveComparisonDifferenceCalculator {
       // this occurs when comparing field of different types, Person.id is an int and PersonDto.id is a long
       // TODO maybe we should let the exception bubble up?
       // assertion will fail with the current behavior and report other diff so it might be better to keep things this way
-      System.out.println(format("WARNING: Comparator was not suited to compare '%s' field values:%n" +
-                                "- actual field value  : %s%n" +
-                                "- expected field value: %s%n" +
-                                "- comparator used     : %s",
-                                fieldName, actual, expected, comparator));
+      System.out.printf("WARNING: Comparator was not suited to compare '%s' field values:%n" +
+                        "- actual field value  : %s%n" +
+                        "- expected field value: %s%n" +
+                        "- comparator used     : %s%n",
+                        fieldName, actual, expected, comparator);
       return false;
     }
   }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/VisitedDualValues.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/VisitedDualValues.java
new file mode 100644
index 000000000..85d1670ec
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/VisitedDualValues.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+import static java.lang.String.format;
+
+class VisitedDualValues {
+
+  private List<VisitedDualValue> dualValues;
+
+  VisitedDualValues() {
+    this.dualValues = new ArrayList<>();
+  }
+
+  void registerVisitedDualValue(DualValue dualValue) {
+    this.dualValues.add(new VisitedDualValue(dualValue));
+  }
+
+  void registerComparisonDifference(DualValue dualValue, ComparisonDifference comparisonDifference) {
+    this.dualValues.stream()
+                   // register difference on dual values agnostic of location, to take care of values visited several times
+                   .filter(visitedDualValue -> visitedDualValue.dualValue.sameValues(dualValue))
+                   .findFirst()
+                   .ifPresent(visitedDualValue -> visitedDualValue.comparisonDifferences.add(comparisonDifference));
+  }
+
+  Optional<List<ComparisonDifference>> registeredComparisonDifferencesOf(DualValue dualValue) {
+    return this.dualValues.stream()
+                          // use sameValues to get already visited dual values with different location
+                          .filter(visitedDualValue -> visitedDualValue.dualValue.sameValues(dualValue))
+                          .findFirst()
+                          .map(visitedDualValue -> visitedDualValue.comparisonDifferences);
+  }
+
+  private static class VisitedDualValue {
+    DualValue dualValue;
+    List<ComparisonDifference> comparisonDifferences;
+
+    VisitedDualValue(DualValue dualValue) {
+      this.dualValue = dualValue;
+      this.comparisonDifferences = new ArrayList<>();
+    }
+
+    @Override
+    public String toString() {
+      return format("VisitedDualValue[dualValue=%s, comparisonDifferences=%s]", this.dualValue, this.comparisonDifferences);
+    }
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_Test.java
index edccff780..053d1065e 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/FieldLocation_Test.java
@@ -54,7 +54,7 @@ class FieldLocation_Test {
     // WHEN
     String result = underTest.toString();
     // THEN
-    then(result).isEqualTo("FieldLocation [pathToUseInRules=location, decomposedPath=[location]]");
+    then(result).isEqualTo("<location>");
   }
 
   @Test
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_sameValues_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_sameValues_Test.java
new file mode 100644
index 000000000..c4d4b7f0d
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/DualValue_sameValues_Test.java
@@ -0,0 +1,70 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
+import static org.assertj.core.util.Lists.list;
+import static org.junit.jupiter.params.provider.Arguments.arguments;
+
+import java.util.List;
+import java.util.stream.Stream;
+
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+class DualValue_sameValues_Test {
+
+  private static final List<String> PATH = list("foo", "bar");
+
+  @ParameterizedTest
+  @MethodSource
+  void sameValues_should_return_true_when_dual_values_refer_to_the_same_instances(DualValue dualValue1, DualValue dualValue2) {
+    assertThat(dualValue1.sameValues(dualValue2)).isTrue();
+  }
+
+  static Stream<Arguments> sameValues_should_return_true_when_dual_values_refer_to_the_same_instances() {
+    Object value1 = new Object();
+    Object value2 = new Object();
+    DualValue dualValue1 = new DualValue(rootFieldLocation(), value1, value2);
+    DualValue dualValue2 = new DualValue(rootFieldLocation(), value1, value2);
+    DualValue dualValue3 = new DualValue(rootFieldLocation().field("foo"), value1, value2);
+    return Stream.of(arguments(dualValue1, dualValue2),
+                     arguments(dualValue1, dualValue1),
+                     arguments(dualValue2, dualValue1),
+                     arguments(dualValue1, dualValue3),
+                     arguments(dualValue1, dualValue3));
+  }
+
+  @ParameterizedTest
+  @MethodSource
+  void sameValues_should_return_false_when_dual_values_refer_to_different_instances(DualValue dualValue1, DualValue dualValue2) {
+    assertThat(dualValue1.sameValues(dualValue2)).isFalse();
+  }
+
+  static Stream<Arguments> sameValues_should_return_false_when_dual_values_refer_to_different_instances() {
+    Object value1 = new Object();
+    Object value2 = new Object();
+    Object value3 = new Object();
+    DualValue dualValue1 = new DualValue(rootFieldLocation(), value1, value2);
+    DualValue dualValue2 = new DualValue(rootFieldLocation(), value1, value3);
+    DualValue dualValue3 = new DualValue(rootFieldLocation().field("foo"), value1, value3);
+    DualValue dualValue4 = new DualValue(rootFieldLocation(), new Object(), value2);
+    return Stream.of(arguments(dualValue1, dualValue2),
+                     arguments(dualValue2, dualValue1),
+                     arguments(dualValue1, dualValue3),
+                     arguments(dualValue1, dualValue4));
+  }
+
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
index ab98d75e2..de17c15ef 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -383,7 +383,7 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
 
   // issue #2434
   @Test
-  void should_treat_class_cast_expection_as_comparison_difference_when_comparing_lists() {
+  void should_treat_class_cast_exception_as_comparison_difference_when_comparing_lists() {
     // GIVEN
     Wrapper a = new Wrapper(Double.MAX_VALUE);
     Wrapper b = new Wrapper(Integer.MAX_VALUE);
@@ -396,7 +396,7 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
   }
 
   @Test
-  void should_report_class_cast_expection_as_comparison_difference() {
+  void should_report_class_cast_exception_as_comparison_difference() {
     // GIVEN
     Wrapper actual = new Wrapper(1.0);
     Wrapper expected = new Wrapper(5);
@@ -407,7 +407,7 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
   }
 
   @Test
-  void should_treat_class_cast_expection_as_comparison_difference_when_comparing_lists_with_specific_equals() {
+  void should_treat_class_cast_exception_as_comparison_difference_when_comparing_lists_with_specific_equals() {
     // GIVEN
     Wrapper a = new Wrapper(1.001);
     Wrapper b = new Wrapper(1);
@@ -421,7 +421,7 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
   }
 
   @Test
-  void should_treat_class_cast_expection_as_comparison_difference() {
+  void should_treat_class_cast_exception_as_comparison_difference() {
     // GIVEN
     Wrapper a = new Wrapper(Double.MAX_VALUE);
     Wrapper b = new Wrapper(Integer.MAX_VALUE);
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
index 3478d6f63..063023abf 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
@@ -21,6 +21,7 @@ import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
 import static org.junit.jupiter.params.provider.Arguments.arguments;
 
+import java.util.ArrayList;
 import java.util.List;
 import java.util.stream.Stream;
 
@@ -313,8 +314,9 @@ class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
    * - here are the pairs (1, 2), (1, 1), (2, 2), we add them to the visited ones<br>
    * <p>
    * We now try to find listB in list(listBReverse) - listAReverse must not be taken into account as it had already been matched<br>
-   * - we would like to try (1, 2), (1, 1), (2, 2) but they have already been visited so we skip them<br>
-   * at this point, we know listB won't be found because (1, 1), (2, 2) won't be considered.
+   * - we would like to try (1, 2), (1, 1), (2, 2) but they have already been visited, so we skip them.<br>
+   * at this point, we know listB won't be found because (1, 1), (2, 2) won't be considered.<br>
+   * We compare dual values but not the location since to track cycles we want to find the same objects at different locations
    * <p>
    * Comparing dualValues actual and expected with == does not solve the issue because Java does not always create different objects
    * for primitive wrapping the same basic value, i.e. {@code new Integer(1) == new Integer(1)}.
@@ -360,7 +362,8 @@ class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
 
   }
 
-  enum Type {
+  enum Type
+  {
     FIRST, SECOND,
   }
 
@@ -426,4 +429,49 @@ class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
                                        new PersonWithInt("name-1", 1)));
   }
 
+  // https://github.com/assertj/assertj/issues/2954
+
+  static class DataStore {
+    List<Data> field1 = new ArrayList<>();
+    List<Data> field2 = new ArrayList<>();
+
+    @Override
+    public String toString() {
+      return format("DataStore[field1=%s, field2=%s]", this.field1, this.field2);
+    }
+  }
+
+  static class Data {
+    final String text;
+
+    Data(String text) {
+      this.text = text;
+    }
+
+    @Override
+    public String toString() {
+      return super.toString().replace("org.assertj.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test$",
+                                      "");
+    }
+  }
+
+  @Test
+  void evaluating_visited_dual_values_should_check_location() {
+    Data d1 = new Data("111");
+    Data d2 = new Data("222");
+    DataStore dataStore1 = createDataStore(d1, d2);
+    DataStore dataStore2 = createDataStore(d2, d1);
+
+    assertThat(dataStore1).usingRecursiveComparison()
+                          .withEqualsForType((data1, data2) -> data1.text.equals(data2.text), Data.class)
+                          .ignoringCollectionOrder()
+                          .isEqualTo(dataStore2);
+  }
+
+  private static DataStore createDataStore(Data d1, Data d2) {
+    DataStore dataStore = new DataStore();
+    dataStore.field1.addAll(list(d1, d2));
+    dataStore.field2.addAll(list(d1, d2));
+    return dataStore;
+  }
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/VisitedDualValuesTest.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/VisitedDualValuesTest.java
new file mode 100644
index 000000000..d638baea8
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/VisitedDualValuesTest.java
@@ -0,0 +1,65 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2023 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import org.junit.jupiter.api.Test;
+
+import java.util.List;
+import java.util.Optional;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.Lists.list;
+
+class VisitedDualValuesTest {
+
+  @Test
+  void should_return_the_registered_differences() {
+    // GIVEN
+    VisitedDualValues visitedDualValues = new VisitedDualValues();
+    DualValue dualValue = new DualValue(list(""), "abc", "abc");
+    visitedDualValues.registerVisitedDualValue(dualValue);
+    ComparisonDifference comparisonDifference1 = new ComparisonDifference(dualValue);
+    visitedDualValues.registerComparisonDifference(dualValue, comparisonDifference1);
+    ComparisonDifference comparisonDifference2 = new ComparisonDifference(dualValue);
+    visitedDualValues.registerComparisonDifference(dualValue, comparisonDifference2);
+    // WHEN
+    Optional<List<ComparisonDifference>> optionalComparisonDifferences = visitedDualValues.registeredComparisonDifferencesOf(dualValue);
+    // THEN
+    then(optionalComparisonDifferences).isPresent();
+    then(optionalComparisonDifferences.get()).containsExactlyInAnyOrder(comparisonDifference1, comparisonDifference2);
+  }
+
+  @Test
+  void should_return_no_differences_when_none_have_been_registered() {
+    // GIVEN
+    VisitedDualValues visitedDualValues = new VisitedDualValues();
+    DualValue dualValue = new DualValue(list(""), "abc", "abc");
+    visitedDualValues.registerVisitedDualValue(dualValue);
+    // WHEN
+    Optional<List<ComparisonDifference>> optionalComparisonDifferences = visitedDualValues.registeredComparisonDifferencesOf(dualValue);
+    // THEN
+    then(optionalComparisonDifferences).isPresent();
+    then(optionalComparisonDifferences.get()).isEmpty();
+  }
+
+  @Test
+  void should_return_empty_optional_for_unknown_dual_values() {
+    // GIVEN
+    VisitedDualValues visitedDualValues = new VisitedDualValues();
+    DualValue dualValue = new DualValue(list(""), "abc", "abc");
+    // WHEN
+    Optional<List<ComparisonDifference>> optionalComparisonDifferences = visitedDualValues.registeredComparisonDifferencesOf(dualValue);
+    // THEN
+    then(optionalComparisonDifferences).isEmpty();
+  }
+}
