diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index f6d769b6e..913b275ca 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -1946,6 +1946,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * These features (and many more) are provided through {@link RecursiveComparisonConfiguration} with:
    * <ul>
    *   <li>{@link RecursiveComparisonConfiguration#registerComparatorForType(Comparator, Class) registerComparatorForType(Comparator, Class)} / {@link RecursiveComparisonConfiguration.Builder#withComparatorForType(Comparator, Class) withComparatorForType(Comparator, Class)} (using {@link RecursiveComparisonConfiguration.Builder})</li>
+   *   <li>{@link RecursiveComparisonConfiguration#registerEqualsForType(java.util.function.BiPredicate, Class) registerEqualsForType(BiPredicate, Class)} / {@link RecursiveComparisonConfiguration.Builder#withComparatorForType(Comparator, Class) withComparatorForType(Comparator, Class)} (using {@link RecursiveComparisonConfiguration.Builder})</li>
    *   <li>{@link RecursiveComparisonConfiguration#registerComparatorForFields(Comparator, String...) registerComparatorForFields(Comparator comparator, String... fields)} / {@link RecursiveComparisonConfiguration.Builder#withComparatorForFields(Comparator, String...) withComparatorForField(Comparator comparator, String... fields)} (using {@link RecursiveComparisonConfiguration.Builder})</li>
    * </ul>
    * <p>
@@ -2036,7 +2037,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * <p>
    * There are differences between this approach and {@link #usingRecursiveFieldByFieldElementComparator(RecursiveComparisonConfiguration)}:
    * <ul>
-   *   <li>you can only chain {@link RecursiveComparisonAssert} assertions (basically {@link RecursiveComparisonAssert#isEqualTo(Object) isEqualTo}), no iterable assertions.</li>
+   *   <li>you can only chain {@link RecursiveComparisonAssert} assertions (basically {@link RecursiveComparisonAssert#isEqualTo(Object) isEqualTo}) and (basically {@link RecursiveComparisonAssert#isNotEqualTo(Object) isNotEqualTo}), no iterable assertions.</li>
    *   <li>{@link RecursiveComparisonAssert#isEqualTo(Object) isEqualTo} assertion error will report all field differences (very detailed).</li>
    *   <li>no comparators registered with {@link AbstractIterableAssert#usingComparatorForType(Comparator, Class)} will be used, you need to register them in chained call like {@link RecursiveComparisonAssert#withComparatorForType(Comparator, Class)}.</li>
    * </ul>
diff --git a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index c5990a118..77c77593a 100644
--- a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -22,6 +22,7 @@ import java.util.Optional;
 import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
+import java.util.function.BiPredicate;
 
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
@@ -94,10 +95,12 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * <p>
    * By default {@code floats} are compared with a precision of 1.0E-6 and {@code doubles} with 1.0E-15.
    * <p>
-   * You can specify a custom comparator per (nested) fields or type with the methods below (but before calling {@code isEqualTo} otherwise this has no effect!):
+   * You can specify a custom comparator or equals BiPredicate per (nested) fields or type with the methods below (but before calling {@code isEqualTo} otherwise this has no effect!):
    * <ol>
-   * <li> {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)} for one or multiple fields</li>
+   * <li> {@link #withEqualsForType(BiPredicate, Class)} for a given type</li>
    * <li> {@link #withComparatorForType(Comparator, Class)} for a given type</li>
+   * <li> {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)} for one or multiple fields</li>
+   * <li> {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)} for one or multiple fields</li>
    * </ol>
    * <p>
    * Note that field comparators always take precedence over type comparators.
@@ -991,14 +994,64 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Allows to register a specific comparator to compare fields with the given locations.
+   * Allows to register a {@link BiPredicate} to compare fields with the given locations.
    * A typical usage is for comparing double/float fields with a given precision.
    * <p>
-   * Comparators specified by this method have precedence over comparators added with {@link #withComparatorForType(Comparator, Class)}.
+   * BiPredicates specified with this method have precedence over the ones registered with {@link #withEqualsForType(BiPredicate, Class)}
+   * or the comparators registered with {@link #withComparatorForType(Comparator, Class)}.
+   * <p>
+   * Note that registering a {@link BiPredicate} for a given field will override the previously registered Comparator (if any).
    * <p>
    * The field locations must be specified from the root object,
    * for example if {@code Foo} has a {@code Bar} field which has an {@code id}, one can register to a comparator for Bar's {@code id} by calling:
-   * <pre><code class='java'> withComparatorForField("bar.id", idComparator)</code></pre>
+   * <pre><code class='java'> withEqualsForFields(idBiPredicate, "foo.id", "foo.bar.id")</code></pre>
+   * <p>
+   * Complete example:
+   * <pre><code class='java'> public class TolkienCharacter {
+   *   String name;
+   *   double height;
+   * }
+   *
+   * TolkienCharacter frodo = new TolkienCharacter(&quot;Frodo&quot;, 1.2);
+   * TolkienCharacter tallerFrodo = new TolkienCharacter(&quot;Frodo&quot;, 1.3);
+   * TolkienCharacter reallyTallFrodo = new TolkienCharacter(&quot;Frodo&quot;, 1.9);
+   *
+   * BiPredicate&lt;Double, Double&gt; closeEnough = (d1, d2) -&gt; Math.abs(d1 - d2) &lt;= 0.5;
+   *
+   * // assertion succeeds
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .withEqualsForFields(closeEnough, &quot;height&quot;)
+   *                  .isEqualTo(tallerFrodo);
+   *
+   * // assertion fails
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .withEqualsForFields(closeEnough, &quot;height&quot;)
+   *                  .isEqualTo(reallyTallFrodo);</code></pre>
+   *
+   * @param equals the {@link BiPredicate} to use to compare the given fields
+   * @param fieldLocations the location from the root object of the fields the BiPredicate should be used for
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   * @throws NullPointerException if the given BiPredicate is null.
+   */
+  @CheckReturnValue
+  public SELF withEqualsForFields(BiPredicate<?, ?> equals, String... fieldLocations) {
+    recursiveComparisonConfiguration.registerEqualsForFields(equals, fieldLocations);
+    return myself;
+  }
+
+  /**
+   * Allows to register a comparator to compare fields with the given locations.
+   * A typical usage is for comparing double/float fields with a given precision.
+   * <p>
+   * Comparators registered with this method have precedence over comparators registered with {@link #withComparatorForType(Comparator, Class)}
+   * or {@link BiPredicate} registered with {@link #withEqualsForType(BiPredicate, Class)}.
+   * <p>
+   * The field locations must be specified from the root object,
+   * for example if {@code Foo} has a {@code Bar} field which has an {@code id}, one can register to a comparator for Bar's {@code id} by calling:
+   * <pre><code class='java'> withComparatorForFields(idComparator, "foo.id", "foo.bar.id")</code></pre>
+   * <p>
+   * Note that registering a {@link Comparator} for a given field will override the previously registered BiPredicate/Comparator (if any).
    * <p>
    * Complete example:
    * <pre><code class='java'> public class TolkienCharacter {
@@ -1012,7 +1065,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    *
    * Comparator&lt;Double&gt; closeEnough = (d1, d2) -&gt; Math.abs(d1 - d2) &lt;= 0.5 ? 0 : 1;
    *
-   * // assertions succeed
+   * // assertion succeeds
    * assertThat(frodo).usingRecursiveComparison()
    *                  .withComparatorForFields(closeEnough, &quot;height&quot;)
    *                  .isEqualTo(tallerFrodo);
@@ -1025,6 +1078,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given fields
    * @param fieldLocations the location from the root object of the fields the comparator should be used for
    * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   * @throws NullPointerException if the given comparator is null.
    */
   @CheckReturnValue
   public SELF withComparatorForFields(Comparator<?> comparator, String... fieldLocations) {
@@ -1033,10 +1087,13 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   }
 
   /**
-   * Allows to register a specific comparator to compare the fields with the given type.
+   * Allows to register a comparator to compare the fields with the given type.
    * A typical usage is for comparing double/float fields with a given precision.
    * <p>
-   * Comparators specified by this method have less precedence than comparators added with {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)}.
+   * Comparators registered with this method have less precedence than comparators registered with {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)}
+   * or BiPredicate registered with {@link #withEqualsForFields(BiPredicate, String...) withEqualsForFields(BiPredicate, String...)}.
+   * <p>
+   * Note that registering a {@link Comparator} for a given type will override the previously registered BiPredicate/Comparator (if any).
    * <p>
    * Example:
    * <pre><code class='java'> public class TolkienCharacter {
@@ -1050,7 +1107,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    *
    * Comparator&lt;Double&gt; closeEnough = (d1, d2) -&gt; Math.abs(d1 - d2) &lt;= 0.5 ? 0 : 1;
    *
-   * // assertions succeed
+   * // assertion succeeds
    * assertThat(frodo).usingRecursiveComparison()
    *                  .withComparatorForType(closeEnough, Double.class)
    *                  .isEqualTo(tallerFrodo);
@@ -1065,6 +1122,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    * @param type the type to be compared with the given comparator.
    *
    * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   * @throws NullPointerException if the given comparator is null.
    */
   @CheckReturnValue
   public <T> SELF withComparatorForType(Comparator<? super T> comparator, Class<T> type) {
@@ -1072,6 +1130,50 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Allows to register a {@link BiPredicate} to compare the fields with the given type.
+   * A typical usage is for comparing double/float fields with a given precision.
+   * <p>
+   * BiPredicates registered with this method have less precedence than the one registered  with {@link #withEqualsForFields(BiPredicate, String...) withEqualsForFields(BiPredicate, String...)}
+   * or comparators registered with {@link #withComparatorForFields(Comparator, String...) withComparatorForFields(Comparator, String...)}.
+   * <p>
+   * Note that registering a {@link BiPredicate} for a given type will override the previously registered BiPredicate/Comparator (if any).
+   * <p>
+   * Example:
+   * <pre><code class='java'> public class TolkienCharacter {
+   *   String name;
+   *   double height;
+   * }
+   *
+   * TolkienCharacter frodo = new TolkienCharacter(&quot;Frodo&quot;, 1.2);
+   * TolkienCharacter tallerFrodo = new TolkienCharacter(&quot;Frodo&quot;, 1.3);
+   * TolkienCharacter reallyTallFrodo = new TolkienCharacter(&quot;Frodo&quot;, 1.9);
+   *
+   * BiPredicate&lt;Double, Double&gt; closeEnough = (d1, d2) -&gt; Math.abs(d1 - d2) &lt;= 0.5;
+   *
+   * // assertion succeeds
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .withEqualsForType(closeEnough, Double.class)
+   *                  .isEqualTo(tallerFrodo);
+   *
+   * // assertion fails
+   * assertThat(frodo).usingRecursiveComparison()
+   *                  .withEqualsForType(closeEnough, Double.class)
+   *                  .isEqualTo(reallyTallFrodo);</code></pre>
+   *
+   * @param <T> the class type to register a BiPredicate for
+   * @param equals the {@link BiPredicate} to use to compare the given fields
+   * @param type the type to be compared with the given comparator.
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   * @throws NullPointerException if the given BiPredicate is null.
+   */
+  @CheckReturnValue
+  public <T> SELF withEqualsForType(BiPredicate<? super T, ? super T> equals, Class<T> type) {
+    recursiveComparisonConfiguration.registerEqualsForType(equals, type);
+    return myself;
+  }
+
   SELF withTypeComparators(TypeComparators typeComparators) {
     Optional.ofNullable(typeComparators)
             .map(TypeComparators::comparatorByTypes)
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index a9d0611e4..32ca0ffbd 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -14,6 +14,7 @@ package org.assertj.core.api.recursive.comparison;
 
 import static java.lang.String.format;
 import static java.util.Arrays.stream;
+import static java.util.Objects.requireNonNull;
 import static java.util.stream.Collectors.toList;
 import static java.util.stream.Collectors.toSet;
 import static org.assertj.core.configuration.ConfigurationProvider.CONFIGURATION_PROVIDER;
@@ -29,6 +30,7 @@ import java.util.LinkedHashSet;
 import java.util.List;
 import java.util.Map.Entry;
 import java.util.Set;
+import java.util.function.BiPredicate;
 import java.util.regex.Pattern;
 import java.util.stream.Stream;
 
@@ -358,18 +360,43 @@ public class RecursiveComparisonConfiguration {
   /**
    * Registers the given {@link Comparator} to compare the fields with the given type.
    * <p>
-   * Comparators specified by this method have less precedence than comparators added with {@link #registerComparatorForFields(Comparator, String...)}.
+   * Comparators registered with this method have less precedence than comparators registered with {@link #registerComparatorForFields(Comparator, String...)}.
+   * <p>
+   * Note that registering a {@link Comparator} for a given type will override the previously registered BiPredicate/Comparator (if any).
    * <p>
    * See {@link RecursiveComparisonAssert#withComparatorForType(Comparator, Class)} for examples.
    *
    * @param <T> the class type to register a comparator for
-   * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
+   * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given type
    * @param type the type to be compared with the given comparator.
+   * @throws NullPointerException if the given comparator is null.
    */
   public <T> void registerComparatorForType(Comparator<? super T> comparator, Class<T> type) {
+    requireNonNull(comparator, "Expecting a non null Comparator");
     typeComparators.put(type, comparator);
   }
 
+  /**
+   * Registers the given {@link BiPredicate} to compare the fields with the given type.
+   * <p>
+   * BiPredicates specified with this method have less precedence than the ones registered with {@link #registerEqualsForFields(BiPredicate, String...)}
+   * or comparators registered with {@link #registerComparatorForFields(Comparator, String...)}.
+   * <p>
+   * Note that registering a {@link BiPredicate} for a given type will override the previously registered BiPredicate/Comparator (if any).
+   * <p>
+   * See {@link RecursiveComparisonAssert#withEqualsForType(BiPredicate, Class)} for examples.
+   *
+   * @param <T> the class type to register a comparator for
+   * @param equals the equals implementation to compare the given type
+   * @param type the type to be compared with the given equals implementation .
+   * @throws NullPointerException if the given BiPredicate is null.
+   * @since 3.17.0
+   */
+  @SuppressWarnings("unchecked")
+  public <T> void registerEqualsForType(BiPredicate<? super T, ? super T> equals, Class<T> type) {
+    registerComparatorForType(toComparator(equals), type);
+  }
+
   /**
    * @deprecated Since 3.17.0 use {@link #registerComparatorForFields(Comparator, String...)} instead.
    * @param comparator comparator to use
@@ -381,25 +408,52 @@ public class RecursiveComparisonConfiguration {
   }
 
   /**
-   * Registers the given {@link Comparator} to compare the fields with the given locations.
+   * Registers the given {@link Comparator} to compare the fields at the given locations.
    * <p>
    * The fields must be specified from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
-   * one can register to a comparator for Foo and Bar's {@code id} by calling:
-   * <pre><code class='java'> registerComparatorForFields(idComparator, "foo.id", "bar.id")</code></pre>
+   * one can register a comparator for Foo and Bar's {@code id} by calling:
+   * <pre><code class='java'> registerComparatorForFields(idComparator, "foo.id", "foo.bar.id")</code></pre>
+   * <p>
+   * Comparators registered with this method have precedence over comparators registered with {@link #registerComparatorForType(Comparator, Class)}.
    * <p>
-   * Comparators specified by this method have precedence over comparators added with {@link #registerComparatorForType(Comparator, Class)}.
+   * Note that registering a {@link Comparator} for a given field will override the previously registered BiPredicate/Comparator (if any).
    * <p>
    * See {@link RecursiveComparisonAssert#withComparatorForFields(Comparator, String...) RecursiveComparisonAssert#withComparatorForFields(Comparator, String...)} for examples.
    *
    * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
    * @param fieldLocations the locations from the root object of the fields the comparator should be used for
+   * @throws NullPointerException if the given comparator is null.
    */
   public void registerComparatorForFields(Comparator<?> comparator, String... fieldLocations) {
+    requireNonNull(comparator, "Expecting a non null Comparator");
     Stream.of(fieldLocations)
           .map(FieldLocation::new)
           .forEach(fieldLocation -> fieldComparators.registerComparator(fieldLocation, comparator));
   }
 
+  /**
+   * Registers the given {@link BiPredicate} to compare the fields at the given locations.
+   * <p>
+   * The fields must be specified from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
+   * one can register a BiPredicate for Foo and Bar's {@code id} by calling:
+   * <pre><code class='java'> registerEqualsForFields(idBiPredicate, "foo.id", "foo.bar.id")</code></pre>
+   * <p>
+   * BiPredicates registered with this method have precedence over the ones registered with {@link #registerEqualsForType(BiPredicate, Class)}
+   * or the comparators registered with {@link #registerComparatorForType(Comparator, Class)}.
+   * <p>
+   * Note that registering a {@link BiPredicate} for a given field will override the previously registered BiPredicate/Comparator (if any).
+   * <p>
+   * See {@link RecursiveComparisonAssert#withEqualsForFields(BiPredicate, String...) RecursiveComparisonAssert#withEqualsForFields(BiPredicate, String...)} for examples.
+   *
+   * @param equals the equals implementation to compare the given fields.
+   * @param fieldLocations the locations from the root object of the fields the comparator should be used for
+   * @throws NullPointerException if the given BiPredicate is null.
+   * @since 3.17.0
+   */
+  public void registerEqualsForFields(BiPredicate<?, ?> equals, String... fieldLocations) {
+    registerComparatorForFields(toComparator(equals), fieldLocations);
+  }
+
   /**
    * Sets whether the recursive comparison will check that actual's type is compatible with expected's type (the same applies for each field).
    * Compatible means that the expected's type is the same or a subclass of actual's type.
@@ -1020,7 +1074,10 @@ public class RecursiveComparisonConfiguration {
     /**
      * Registers the given {@link Comparator} to compare the fields with the given type.
      * <p>
-     * Comparators specified by this method have less precedence than comparators added with {@link #withComparatorForFields(Comparator, String...)}.
+     * Comparators registered with this method have less precedence than comparators registered with {@link #withComparatorForFields(Comparator, String...)}
+     * or BiPredicate registered with  {@link #withEqualsForFields(BiPredicate, String...)}.
+     * <p>
+     * Note that registering a {@link Comparator} for a given type will override the previously registered BiPredicate/Comparator (if any).
      * <p>
      * See {@link RecursiveComparisonAssert#withComparatorForType(Comparator, Class)} for examples.
      *
@@ -1028,37 +1085,96 @@ public class RecursiveComparisonConfiguration {
      * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
      * @param type the type to be compared with the given comparator.
      * @return this builder.
+     * @throws NullPointerException if the given Comparator is null.
      */
     public <T> Builder withComparatorForType(Comparator<? super T> comparator, Class<T> type) {
+      requireNonNull(comparator, "Expecting a non null Comparator");
       this.typeComparators.put(type, comparator);
       return this;
     }
 
     /**
-     * Registers the given {@link Comparator} to compare the fields with the given locations.
+     * Registers the given {@link BiPredicate} to compare the fields with the given type.
+     * <p>
+     * BiPredicates registered with this method have less precedence than the ones registered with {@link #withEqualsForFields(BiPredicate, String...)}
+     * or the comparators registered with {@link #withComparatorForFields(Comparator, String...)}.
+     * <p>
+     * Note that registering a {@link BiPredicate} for a given type will override the previously registered BiPredicate/Comparator (if any).
+     * <p>
+     * See {@link RecursiveComparisonAssert#withEqualsForType(BiPredicate, Class)} for examples.
+     *
+     * @param <T> the class type to register a BiPredicate for
+     * @param equals the {@link BiPredicate} to use to compare the given field
+     * @param type the type to be compared with the given comparator.
+     * @return this builder.
+     * @since 3.17.0
+     * @throws NullPointerException if the given BiPredicate is null.
+     */
+    @SuppressWarnings("unchecked")
+    public <T> Builder withEqualsForType(BiPredicate<? super T, ? super T> equals, Class<T> type) {
+      return withComparatorForType(toComparator(equals), type);
+    }
+
+    /**
+     * Registers the given {@link Comparator} to compare the fields at the given locations.
      * <p>
      * The fields must be specified from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
-     * one can register to a comparator for Foo and Bar's {@code id} by calling:
-     * <pre><code class='java'> registerComparatorForFields(idComparator, "foo.id", "bar.id")</code></pre>
+     * one can register a comparator for Foo and Bar's {@code id} by calling:
+     * <pre><code class='java'> registerComparatorForFields(idComparator, "foo.id", "foo.bar.id")</code></pre>
+     * <p>
+     * Comparators registered with this method have precedence over comparators registered with {@link #withComparatorForType(Comparator, Class)}
+     * or BiPredicate registered with {@link #withEqualsForType(BiPredicate, Class)}.
      * <p>
-     * Comparators specified by this method have precedence over comparators added with {@link #withComparatorForType(Comparator, Class)}.
+     * Note that registering a {@link Comparator} for a given field will override the previously registered BiPredicate/Comparator (if any).
      * <p>
      * See {@link RecursiveComparisonAssert#withComparatorForFields(Comparator, String...) RecursiveComparisonAssert#withComparatorForFields(Comparator comparator, String...fields)} for examples.
      *
      * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
      * @param fields the fields the comparator should be used for
      * @return this builder.
+     * @throws NullPointerException if the given Comparator is null.
      */
     public Builder withComparatorForFields(Comparator<?> comparator, String... fields) {
+      requireNonNull(comparator, "Expecting a non null Comparator");
       Stream.of(fields)
             .map(FieldLocation::new)
             .forEach(fieldLocation -> fieldComparators.registerComparator(fieldLocation, comparator));
       return this;
     }
 
+    /**
+     * Registers the given {@link BiPredicate} to compare the fields at the given locations.
+     * <p>
+     * The fields must be specified from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
+     * one can register a BiPredicate for Foo and Bar's {@code id} by calling:
+     * <pre><code class='java'> withEqualsForFields(idBiPredicate, "foo.id", "foo.bar.id")</code></pre>
+     * <p>
+     * BiPredicates registered with this method have precedence over the ones registered with {@link #withEqualsForType(BiPredicate, Class)}
+     * or the comparators registered with {@link #withComparatorForType(Comparator, Class)}.
+     * <p>
+     * Note that registering a {@link BiPredicate} for a given field will override the previously registered BiPredicate/Comparator (if any).
+     * <p>
+     * See {@link RecursiveComparisonAssert#withEqualsForFields(BiPredicate, String...) RecursiveComparisonAssert#withEqualsForFields(BiPredicate equals, String...fields)} for examples.
+     *
+     * @param equals the {@link BiPredicate} to use to compare the given fields
+     * @param fields the fields the BiPredicate should be used for
+     * @return this builder.
+     * @since 3.17.0
+     * @throws NullPointerException if the given BiPredicate is null.
+     */
+    public Builder withEqualsForFields(BiPredicate<?, ?> equals, String... fields) {
+      return withComparatorForFields(toComparator(equals), fields);
+    }
+
     public RecursiveComparisonConfiguration build() {
       return new RecursiveComparisonConfiguration(this);
     }
   }
 
+  @SuppressWarnings({ "rawtypes", "unchecked" })
+  private static Comparator toComparator(BiPredicate equals) {
+    requireNonNull(equals, "Expecting a non null BiPredicate");
+    return (o1, o2) -> equals.test(o1, o2) ? 0 : 1;
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
index 71129991a..262cb6bcd 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
@@ -20,7 +20,6 @@ import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
 import static org.assertj.core.test.AlwaysDifferentComparator.alwaysDifferent;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TIMESTAMP;
-import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
 import static org.assertj.core.test.AlwaysEqualComparator.alwaysEqual;
 
 import java.sql.Timestamp;
@@ -163,11 +162,12 @@ class RecursiveComparisonAssert_fluent_API_Test {
     String regex2 = ".*foo.*";
     // WHEN
     RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
-                                                                       .ignoringOverriddenEqualsForFieldsMatchingRegexes(regex1, regex2)
+                                                                       .ignoringOverriddenEqualsForFieldsMatchingRegexes(regex1,
+                                                                                                                         regex2)
                                                                        .getRecursiveComparisonConfiguration();
     // THEN
     assertThat(configuration.getIgnoredOverriddenEqualsForFieldsMatchingRegexes()).extracting(Pattern::pattern)
-                                                                 .containsExactly(regex1, regex2);
+                                                                                  .containsExactly(regex1, regex2);
   }
 
   @Test
@@ -213,7 +213,8 @@ class RecursiveComparisonAssert_fluent_API_Test {
     String regex2 = ".*foo.*";
     // WHEN
     RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
-                                                                       .ignoringCollectionOrderInFieldsMatchingRegexes(regex1, regex2)
+                                                                       .ignoringCollectionOrderInFieldsMatchingRegexes(regex1,
+                                                                                                                       regex2)
                                                                        .getRecursiveComparisonConfiguration();
     // THEN
     assertThat(configuration.getIgnoredCollectionOrderInFieldsMatchingRegexes()).extracting(Pattern::pattern)
@@ -226,6 +227,7 @@ class RecursiveComparisonAssert_fluent_API_Test {
     String field1 = "foo";
     String field2 = "foo.bar";
     String field3 = "bar";
+    String field4 = "baz";
     AlwaysEqualComparator<?> alwaysEqualComparator = alwaysEqual();
     AlwaysDifferentComparator<?> alwaysDifferentComparator = alwaysDifferent();
     // WHEN
@@ -233,12 +235,16 @@ class RecursiveComparisonAssert_fluent_API_Test {
     RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
                                                                        .withComparatorForFields(alwaysEqualComparator, field1, field3)
                                                                        .withComparatorForFields(alwaysDifferentComparator, field2)
+                                                                       .withEqualsForFields((o1, o2) -> true, field4)
                                                                        .getRecursiveComparisonConfiguration();
     // @format:on
     // THEN
-    assertThat(configuration.comparatorByFields()).containsExactly(entry(fielLocation(field3), alwaysEqualComparator),
-                                                                   entry(fielLocation(field1), alwaysEqualComparator),
-                                                                   entry(fielLocation(field2), alwaysDifferentComparator));
+    assertThat(configuration.comparatorByFields()).hasSize(4)
+                                                  .contains(entry(fielLocation(field3), alwaysEqualComparator),
+                                                            entry(fielLocation(field1), alwaysEqualComparator),
+                                                            entry(fielLocation(field2), alwaysDifferentComparator));
+    assertThat(configuration.comparatorByFields()).anyMatch(entry -> entry.getKey().equals(fielLocation(field4))
+                                                                     && entry.getValue() != null);
   }
 
   @Test
@@ -248,47 +254,53 @@ class RecursiveComparisonAssert_fluent_API_Test {
     Class<Timestamp> type2 = Timestamp.class;
     Class<Tuple> type3 = Tuple.class;
     // WHEN
-    // @format:off
     RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
                                                                        .withComparatorForType(ALWAY_EQUALS_STRING, type1)
                                                                        .withComparatorForType(ALWAY_EQUALS_TIMESTAMP, type2)
-                                                                       .withComparatorForType(ALWAY_EQUALS_TUPLE, type3)
+                                                                       .withEqualsForType((o1, o2) -> true, type3)
                                                                        .getRecursiveComparisonConfiguration();
-    // @format:on
     // THEN
     assertThat(configuration.comparatorByTypes()).contains(entry(type1, ALWAY_EQUALS_STRING),
-                                                           entry(type2, ALWAY_EQUALS_TIMESTAMP),
-                                                           entry(type3, ALWAY_EQUALS_TUPLE));
+                                                           entry(type2, ALWAY_EQUALS_TIMESTAMP));
+    assertThat(configuration.comparatorByTypes()).anyMatch(entry -> entry.getKey().equals(type3) && entry.getValue() != null);
   }
 
   @Test
   void should_allow_to_override_field_comparator() {
     // GIVEN
-    String field = "foo.bar";
+    String field1 = "foo.bar";
+    String field2 = "foo.baz";
     AlwaysEqualComparator<?> alwaysEqualComparator = alwaysEqual();
     AlwaysDifferentComparator<?> alwaysDifferentComparator = alwaysDifferent();
     // WHEN
     RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
-                                                                       .withComparatorForFields(alwaysEqualComparator, field)
-                                                                       .withComparatorForFields(alwaysDifferentComparator, field)
+                                                                       .withComparatorForFields(alwaysEqualComparator, field1)
+                                                                       .withComparatorForFields(alwaysDifferentComparator, field1)
+                                                                       .withComparatorForFields(alwaysEqualComparator, field2)
+                                                                       .withEqualsForFields((o1, o2) -> false, field2)
                                                                        .getRecursiveComparisonConfiguration();
     // THEN
-    assertThat(configuration.getComparatorForField(field)).isSameAs(alwaysDifferentComparator);
+    assertThat(configuration.getComparatorForField(field1)).isSameAs(alwaysDifferentComparator);
+    assertThat(configuration.getComparatorForField(field2)).isNotSameAs(alwaysEqualComparator);
   }
 
   @Test
   void should_allow_to_override_type_comparator() {
     // GIVEN
-    Class<?> type = String.class;
+    Class<?> type1 = String.class;
+    Class<?> type2 = Tuple.class;
     AlwaysEqualComparator<Object> alwaysEqualComparator = alwaysEqual();
     AlwaysDifferentComparator<Object> alwaysDifferentComparator = alwaysDifferent();
     // WHEN
     RecursiveComparisonConfiguration configuration = assertThat(ACTUAL).usingRecursiveComparison()
-                                                                       .withComparatorForType(alwaysEqualComparator, type)
-                                                                       .withComparatorForType(alwaysDifferentComparator, type)
+                                                                       .withComparatorForType(alwaysEqualComparator, type1)
+                                                                       .withComparatorForType(alwaysDifferentComparator, type1)
+                                                                       .withComparatorForType(alwaysEqualComparator, type2)
+                                                                       .withEqualsForType((o1, o2) -> false, type2)
                                                                        .getRecursiveComparisonConfiguration();
     // THEN
-    assertThat(configuration.getComparatorForType(type)).isSameAs(alwaysDifferentComparator);
+    assertThat(configuration.getComparatorForType(type1)).isSameAs(alwaysDifferentComparator);
+    assertThat(configuration.getComparatorForType(type2)).isNotSameAs(alwaysEqualComparator);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test.java
index 1b2a36814..d4b06ba91 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test.java
@@ -25,6 +25,7 @@ import static org.junit.jupiter.params.provider.Arguments.arguments;
 import java.sql.Timestamp;
 import java.util.Comparator;
 import java.util.Date;
+import java.util.function.BiPredicate;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
@@ -55,6 +56,24 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
                       .isEqualTo(expected);
   }
 
+  @SuppressWarnings("unused")
+  @ParameterizedTest(name = "{4}: actual={0} / expected={1} - comparators {2} - fields {3}")
+  @MethodSource("recursivelyEqualObjectsWhenUsingFieldComparators")
+  void should_pass_for_objects_with_the_same_data_when_using_registered_BiPredicate_by_fields(Object actual,
+                                                                                              Object expected,
+                                                                                              Comparator<Object> comparator,
+                                                                                              String[] fields,
+                                                                                              String testDescription) {
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForFields(asBiPredicate(comparator), fields)
+                      .isEqualTo(expected);
+  }
+
+  @SuppressWarnings("unchecked")
+  private static BiPredicate<Object, Object> asBiPredicate(@SuppressWarnings("rawtypes") Comparator comparator) {
+    return (Object o1, Object o2) -> comparator.compare(o1, o2) == 0;
+  }
+
   private static Stream<Arguments> recursivelyEqualObjectsWhenUsingFieldComparators() {
     Person person1 = new Person("John");
     person1.home.address.number = 1;
@@ -115,6 +134,36 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
                                                               neighbourAddressDifference);
   }
 
+  @Test
+  void should_fail_when_actual_differs_from_expected_when_using_field_bipredicate_comparators() {
+    // GIVEN
+    Person actual = new Person("John");
+    actual.home.address.number = 1;
+    actual.dateOfBirth = new Date(123);
+    actual.neighbour = new Person("Jack");
+    actual.neighbour.home.address.number = 123;
+    // actually a clone of actual
+    Person expected = new Person("John");
+    expected.home.address.number = 1;
+    expected.dateOfBirth = new Date(123);
+    expected.neighbour = new Person("Jack");
+    expected.neighbour.home.address.number = 123;
+    // register some equals methods for some fields that will fail the comparison
+    recursiveComparisonConfiguration.registerEqualsForFields((Object o1, Object o2) -> false,
+                                                             "dateOfBirth", "neighbour.home.address");
+
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+
+    // THEN
+    ComparisonDifference dateOfBirthDifference = diff("dateOfBirth", actual.dateOfBirth, expected.dateOfBirth);
+    ComparisonDifference neighbourAddressDifference = diff("neighbour.home.address",
+                                                           actual.neighbour.home.address,
+                                                           expected.neighbour.home.address);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, dateOfBirthDifference,
+                                                              neighbourAddressDifference);
+  }
+
   @Test
   void should_be_able_to_compare_objects_recursively_using_some_precision_for_numerical_fields() {
     // GIVEN
@@ -130,6 +179,9 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
     assertThat(goliath).usingRecursiveComparison()
                        .withComparatorForFields(new AtPrecisionComparator<>(0.2), "height")
                        .isEqualTo(goliathTwin);
+    assertThat(goliath).usingRecursiveComparison()
+                       .withEqualsForFields((Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.2, "height")
+                       .isEqualTo(goliathTwin);
   }
 
   @Test
@@ -152,6 +204,26 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
                        .isEqualTo(goliathTwin);
   }
 
+  @Test
+  void should_be_able_to_compare_objects_recursively_using_given_BiPredicate_for_specified_nested_field() {
+    // GIVEN
+    Giant goliath = new Giant();
+    goliath.name = "Goliath";
+    goliath.height = 3.0;
+    goliath.home.address.number = 1;
+
+    Giant goliathTwin = new Giant();
+    goliathTwin.name = "Goliath";
+    goliathTwin.height = 3.1;
+    goliathTwin.home.address.number = 5;
+
+    // THEN
+    assertThat(goliath).usingRecursiveComparison()
+                       .withEqualsForFields((Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.2, "height")
+                       .withEqualsForFields((Integer i1, Integer i2) -> Math.abs(i1 - i2) <= 10, "home.address.number")
+                       .isEqualTo(goliathTwin);
+  }
+
   @Test
   void should_handle_null_field_with_field_comparator() {
     // GIVEN
@@ -161,6 +233,9 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
     assertThat(actual).usingRecursiveComparison()
                       .withComparatorForFields(ALWAY_EQUALS_TIMESTAMP, "dateOfBirth")
                       .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForFields((o1, o2) -> true, "dateOfBirth")
+                      .isEqualTo(expected);
   }
 
   @Test
@@ -173,6 +248,9 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
     assertThat(actual).usingRecursiveComparison()
                       .withComparatorForFields(NEVER_EQUALS, "dateOfBirth")
                       .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForFields((o1, o2) -> false, "dateOfBirth")
+                      .isEqualTo(expected);
   }
 
   @Test
@@ -187,7 +265,7 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
                       .withComparatorForFields(SYMMETRIC_DATE_COMPARATOR, "dateOfBirth")
                       .isEqualTo(other);
     assertThat(other).usingRecursiveComparison()
-                     .withComparatorForFields(SYMMETRIC_DATE_COMPARATOR, "dateOfBirth")
+                     .withEqualsForFields(asBiPredicate(SYMMETRIC_DATE_COMPARATOR), "dateOfBirth")
                      .isEqualTo(actual);
   }
 
@@ -205,6 +283,14 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
                       .withComparatorForFields(ALWAY_EQUALS_TIMESTAMP, "dateOfBirth")
                       .withComparatorForType(NEVER_EQUALS, Timestamp.class)
                       .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForType((o1, o2) -> false, Timestamp.class)
+                      .withEqualsForFields((o1, o2) -> true, "dateOfBirth")
+                      .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForFields((o1, o2) -> true, "dateOfBirth")
+                      .withEqualsForType((o1, o2) -> false, Timestamp.class)
+                      .isEqualTo(expected);
   }
 
   @Test
@@ -221,6 +307,10 @@ class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
                       .withComparatorForFields(ALWAY_EQUALS, "neighbour") // fails if commented
                       .ignoringOverriddenEqualsForFields("neighbour")
                       .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForFields((o1, o2) -> true, "neighbour") // fails if commented
+                      .ignoringOverriddenEqualsForFields("neighbour")
+                      .isEqualTo(expected);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
index 7bf843a81..d13c8ef38 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test.java
@@ -25,6 +25,7 @@ import java.sql.Timestamp;
 import java.util.Comparator;
 import java.util.Date;
 import java.util.Map;
+import java.util.function.BiPredicate;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
@@ -62,6 +63,26 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
                       .isEqualTo(expected);
   }
 
+  @SuppressWarnings("unused")
+  @ParameterizedTest(name = "{3}: actual={0} / expected={1} - comparatorsByType: {2}")
+  @MethodSource("recursivelyEqualObjectsWhenUsingTypeComparators")
+  void should_pass_for_objects_with_the_same_data_when_using_registered_equals_by_types(Object actual,
+                                                                                        Object expected,
+                                                                                        Map<Class<?>, Comparator<Object>> comparatorByTypes,
+                                                                                        String testDescription) {
+    // GIVEN
+    comparatorByTypes.entrySet().stream()
+                     .forEach(entry -> recursiveComparisonConfiguration.registerEqualsForType(asBiPredicate(entry.getValue()),
+                                                                                              entry.getKey()));
+    // THEN
+    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                      .isEqualTo(expected);
+  }
+
+  private static BiPredicate<Object, Object> asBiPredicate(Comparator<Object> comparator) {
+    return (Object o1, Object o2) -> comparator.compare(o1, o2) == 0;
+  }
+
   private static Stream<Arguments> recursivelyEqualObjectsWhenUsingTypeComparators() {
     Person person1 = new Person("John");
     person1.home.address.number = 1;
@@ -112,7 +133,7 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     // register comparators for some type that will fail the comparison
     recursiveComparisonConfiguration.registerComparatorForType(new AlwaysDifferentComparator<>(), Person.class);
     recursiveComparisonConfiguration.registerComparatorForType(new AlwaysDifferentComparator<>(), Date.class);
-    recursiveComparisonConfiguration.registerComparatorForType(new AlwaysDifferentComparator<>(), Address.class);
+    recursiveComparisonConfiguration.registerEqualsForType((Address a1, Address a2) -> false, Address.class);
 
     // WHEN
     compareRecursivelyFailsAsExpected(actual, expected);
@@ -140,6 +161,9 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     assertThat(goliath).usingRecursiveComparison()
                        .withComparatorForType(new AtPrecisionComparator<>(0.2), Double.class)
                        .isEqualTo(goliathTwin);
+    assertThat(goliath).usingRecursiveComparison()
+                       .withEqualsForType((d1, d2) -> Math.abs(d1 - d2) < 0.2, Double.class)
+                       .isEqualTo(goliathTwin);
   }
 
   @Test
@@ -151,6 +175,9 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     assertThat(actual).usingRecursiveComparison()
                       .withComparatorForType(ALWAY_EQUALS_TIMESTAMP, Timestamp.class)
                       .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForType((o1, o2) -> true, Timestamp.class)
+                      .isEqualTo(expected);
   }
 
   @Test
@@ -163,6 +190,9 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
     assertThat(actual).usingRecursiveComparison()
                       .withComparatorForType(NEVER_EQUALS, Timestamp.class)
                       .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForType((o1, o2) -> false, Timestamp.class)
+                      .isEqualTo(expected);
   }
 
   @Test
@@ -195,6 +225,10 @@ class RecursiveComparisonAssert_isEqualTo_withTypeComparators_Test
                       .withComparatorForType(ALWAY_EQUALS, AlwaysEqualPerson.class) // fails if commented
                       .ignoringOverriddenEqualsForFields("neighbour")
                       .isEqualTo(expected);
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForType((o1, o2) -> true, AlwaysEqualPerson.class) // fails if commented
+                      .ignoringOverriddenEqualsForFields("neighbour")
+                      .isEqualTo(expected);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isNotEqualTo_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isNotEqualTo_Test.java
index 96dd1d3fc..25319eab4 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isNotEqualTo_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isNotEqualTo_Test.java
@@ -128,6 +128,17 @@ class RecursiveComparisonAssert_isNotEqualTo_Test extends RecursiveComparisonAss
                       .isNotEqualTo(other);
   }
 
+  @Test
+  void should_be_able_to_use_a_BiPredicate_to_compare_specified_type() {
+    // GIVEN
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi(new String("Yoda"), "Green");
+    // THEN
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForType((o1, o2) -> false, String.class)
+                      .isNotEqualTo(other);
+  }
+
   @Test
   void should_pass_when_one_property_or_field_to_compare_can_not_be_found() {
     // GIVEN
@@ -150,4 +161,15 @@ class RecursiveComparisonAssert_isNotEqualTo_Test extends RecursiveComparisonAss
                       .isNotEqualTo(other);
   }
 
+  @Test
+  void should_be_able_to_use_a_BiPredicate_for_specified_fields() {
+    // GIVEN
+    Jedi actual = new Jedi("Yoda", "Green");
+    Jedi other = new Jedi("Yoda", new String("Green"));
+    // THEN
+    assertThat(actual).usingRecursiveComparison()
+                      .withEqualsForFields((o1, o2) -> false, "lightSaberColor")
+                      .isNotEqualTo(other);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
index db1a3d58e..f65eb3a90 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
@@ -12,9 +12,12 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
+import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.test.AlwaysEqualComparator.alwaysEqual;
 
+import java.util.Comparator;
+import java.util.function.BiPredicate;
 import java.util.regex.Pattern;
 
 import org.apache.commons.lang3.RandomUtils;
@@ -216,6 +219,73 @@ class RecursiveComparisonConfiguration_builder_Test {
     then(configuration.getComparatorForField(barLocation)).isSameAs(alwaysEqualComparator);
   }
 
+  @Test
+  void should_throw_NPE_if_given_comparator_for_fields_is_null() {
+    // GIVEN
+    Comparator<Integer> integerComparator = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> RecursiveComparisonConfiguration.builder()
+                                                                               .withComparatorForFields(integerComparator,
+                                                                                                        "age"));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null Comparator");
+  }
+
+  @Test
+  void should_throw_NPE_if_given_comparator_for_type_is_null() {
+    // GIVEN
+    Comparator<Integer> integerComparator = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> RecursiveComparisonConfiguration.builder()
+                                                                               .withComparatorForType(integerComparator,
+                                                                                                      Integer.class));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null Comparator");
+  }
+
+  @Test
+  void should_throw_NPE_if_given_BiPredicate_for_type_is_null() {
+    // GIVEN
+    BiPredicate<String, String> stringEquals = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> RecursiveComparisonConfiguration.builder().withEqualsForType(stringEquals,
+                                                                                                            String.class));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null BiPredicate");
+  }
+
+  @Test
+  void should_throw_NPE_if_given_BiPredicate_for_fields_is_null() {
+    // GIVEN
+    BiPredicate<String, String> stringEquals = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> RecursiveComparisonConfiguration.builder().withEqualsForFields(stringEquals,
+                                                                                                              "id"));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null BiPredicate");
+  }
+
+  @Test
+  void should_set_equalsForField() {
+    // GIVEN
+    String nameLocation = "name";
+    String titleLocation = "title";
+    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withEqualsForFields(stringEquals,
+                                                                                                          nameLocation,
+                                                                                                          titleLocation)
+                                                                                     .build();
+    // THEN
+    then(configuration.hasComparatorForField(nameLocation)).isTrue();
+    then(configuration.hasComparatorForField(titleLocation)).isTrue();
+  }
+
   @Test
   void should_set_comparatorForType() {
     // GIVEN
@@ -229,4 +299,18 @@ class RecursiveComparisonConfiguration_builder_Test {
     then(configuration.hasComparatorForType(String.class)).isTrue();
     then(configuration.getComparatorForType(String.class)).isSameAs(alwaysEqualComparator);
   }
+
+  @Test
+  void should_set_equalsForType() {
+    // GIVEN
+    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
+
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withEqualsForType(stringEquals,
+                                                                                                        String.class)
+                                                                                     .build();
+    // THEN
+    then(configuration.hasComparatorForType(String.class)).isTrue();
+  }
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_comparatorByType_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_comparatorByType_Test.java
index b41dc5e86..af7675882 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_comparatorByType_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_comparatorByType_Test.java
@@ -14,13 +14,15 @@ package org.assertj.core.api.recursive.comparison;
 
 import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.internal.TypeComparators.defaultTypeComparators;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS;
-import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
 
 import java.util.Comparator;
 import java.util.List;
 import java.util.Map.Entry;
+import java.util.function.BiPredicate;
 
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.TypeComparators;
@@ -51,12 +53,36 @@ class RecursiveComparisonConfiguration_comparatorByType_Test {
     // GIVEN
     AbsValueComparator<Integer> integerComparator = new AbsValueComparator<>();
     recursiveComparisonConfiguration.registerComparatorForType(integerComparator, Integer.class);
-    recursiveComparisonConfiguration.registerComparatorForType(ALWAY_EQUALS_TUPLE, Tuple.class);
+    recursiveComparisonConfiguration.registerEqualsForType((Tuple t1, Tuple t2) -> false, Tuple.class);
     recursiveComparisonConfiguration.registerComparatorForType(ALWAY_EQUALS, Double.class);
     // THEN
     assertThat(recursiveComparisonConfiguration.getComparatorForType(Integer.class)).isSameAs(integerComparator);
-    assertThat(recursiveComparisonConfiguration.getComparatorForType(Tuple.class)).isSameAs(ALWAY_EQUALS_TUPLE);
+    assertThat(recursiveComparisonConfiguration.getComparatorForType(Tuple.class)).isNotNull();
     assertThat(recursiveComparisonConfiguration.getComparatorForType(Double.class)).isSameAs(ALWAY_EQUALS);
   }
 
+  @Test
+  void should_throw_NPE_if_given_comparator_is_null() {
+    // GIVEN
+    Comparator<Integer> integerComparator = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> recursiveComparisonConfiguration.registerComparatorForType(integerComparator,
+                                                                                                          Integer.class));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null Comparator");
+  }
+
+  @Test
+  void should_throw_NPE_if_given_BiPredicate_is_null() {
+    // GIVEN
+    BiPredicate<Double, Double> doubleEquals = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> recursiveComparisonConfiguration.registerEqualsForType(doubleEquals,
+                                                                                                      Double.class));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null BiPredicate");
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
index a0bd43aa9..862322b2d 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
@@ -13,8 +13,13 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
 
+import java.util.Comparator;
+import java.util.function.BiPredicate;
+
 import org.assertj.core.util.AbsValueComparator;
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
@@ -32,20 +37,69 @@ class RecursiveComparisonConfiguration_fieldComparators_Test {
   void should_register_given_field_comparators() {
     // GIVEN
     AbsValueComparator<Integer> integerComparator = new AbsValueComparator<>();
+    BiPredicate<Double, Double> doubleEquals = (Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.01;
+    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
+    assertThat(recursiveComparisonConfiguration.getComparatorForField("temperature")).isNull();
+    assertThat(recursiveComparisonConfiguration.getComparatorForField("name")).isNull();
+    // WHEN
     recursiveComparisonConfiguration.registerComparatorForFields(integerComparator, "height");
     recursiveComparisonConfiguration.registerComparatorForFields(ALWAY_EQUALS_TUPLE, "weight");
+    recursiveComparisonConfiguration.registerEqualsForFields(doubleEquals, "temperature");
+    recursiveComparisonConfiguration.registerEqualsForFields(stringEquals, "name");
     // THEN
     assertThat(recursiveComparisonConfiguration.getComparatorForField("height")).isSameAs(integerComparator);
     assertThat(recursiveComparisonConfiguration.getComparatorForField("weight")).isSameAs(ALWAY_EQUALS_TUPLE);
+    assertThat(recursiveComparisonConfiguration.getComparatorForField("temperature")).isNotNull();
+    assertThat(recursiveComparisonConfiguration.getComparatorForField("name")).isNotNull();
   }
 
   @Test
   void should_replace_a_registered_field_comparator() {
     // GIVEN
     recursiveComparisonConfiguration.registerComparatorForFields(new AbsValueComparator<>(), "height");
+    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
+    recursiveComparisonConfiguration.registerEqualsForFields(stringEquals, "name");
+    Comparator<?> firstComparator = recursiveComparisonConfiguration.getComparatorForField("name");
+    // WHEN
     recursiveComparisonConfiguration.registerComparatorForFields(ALWAY_EQUALS_TUPLE, "height");
+    recursiveComparisonConfiguration.registerEqualsForFields(stringEquals, "name");
     // THEN
+    assertThat(recursiveComparisonConfiguration.getComparatorForField("name")).isNotSameAs(firstComparator);
     assertThat(recursiveComparisonConfiguration.getComparatorForField("height")).isSameAs(ALWAY_EQUALS_TUPLE);
   }
 
+  @Test
+  void bipredicate_should_replace_a_registered_field_comparator() {
+    // GIVEN
+    recursiveComparisonConfiguration.registerComparatorForFields(ALWAY_EQUALS_TUPLE, "weight");
+    Comparator<?> firstComparator = recursiveComparisonConfiguration.getComparatorForField("weight");
+    // WHEN
+    recursiveComparisonConfiguration.registerEqualsForFields((Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.01, "weight");
+    // THEN
+    assertThat(recursiveComparisonConfiguration.getComparatorForField("weight")).isNotSameAs(firstComparator);
+  }
+
+  @Test
+  void should_throw_NPE_if_given_comparator_is_null() {
+    // GIVEN
+    Comparator<Integer> integerComparator = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> recursiveComparisonConfiguration.registerComparatorForFields(integerComparator,
+                                                                                                            "age"));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null Comparator");
+  }
+
+  @Test
+  void should_throw_NPE_if_given_BiPredicate_is_null() {
+    // GIVEN
+    BiPredicate<Double, Double> doubleEquals = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> recursiveComparisonConfiguration.registerEqualsForFields(doubleEquals, "height"));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("Expecting a non null BiPredicate");
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_hasCustomComparators_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_hasCustomComparators_Test.java
index 4a2a0363e..0ae02157f 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_hasCustomComparators_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_hasCustomComparators_Test.java
@@ -15,6 +15,8 @@ package org.assertj.core.api.recursive.comparison;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS;
 
+import java.util.function.BiPredicate;
+
 import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
@@ -50,4 +52,15 @@ class RecursiveComparisonConfiguration_hasCustomComparators_Test {
     assertThat(recursiveComparisonConfiguration.hasCustomComparators()).isTrue();
   }
 
+  @Test
+  void has_custom_comparator_when_registering_a_field_bipredicate_equals_comparator() {
+    // GIVEN
+    recursiveComparisonConfiguration.getTypeComparators().clear();
+    BiPredicate<String, String> stringEquals = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
+    // WHEN
+    recursiveComparisonConfiguration.registerEqualsForFields(stringEquals, "foo");
+    // THEN
+    assertThat(recursiveComparisonConfiguration.hasCustomComparators()).isTrue();
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index 8fd52c620..dd2dff746 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -21,6 +21,7 @@ import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
 import java.time.ZonedDateTime;
 import java.util.Comparator;
 import java.util.UUID;
+import java.util.function.BiPredicate;
 
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.test.AlwaysEqualComparator;
@@ -34,6 +35,9 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
 
   private RecursiveComparisonConfiguration recursiveComparisonConfiguration;
 
+  private static final BiPredicate<String, String> STRING_EQUALS = (String s1, String s2) -> s1.equalsIgnoreCase(s2);
+  private static final BiPredicate<Double, Double> DOUBLE_EQUALS = (Double d1, Double d2) -> Math.abs(d1 - d2) <= 0.01;
+
   @BeforeEach
   void setup() {
     recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
@@ -225,17 +229,16 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     // GIVEN
     recursiveComparisonConfiguration.registerComparatorForType(new AbsValueComparator<>(), Integer.class);
     recursiveComparisonConfiguration.registerComparatorForType(AlwaysEqualComparator.ALWAY_EQUALS_TUPLE, Tuple.class);
+    recursiveComparisonConfiguration.registerEqualsForType(STRING_EQUALS, String.class);
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
-    // @format:off
-    assertThat(multiLineDescription).contains(format(
-               "- these types were compared with the following comparators:%n" +
-               "  - java.lang.Double -> DoubleComparator[precision=1.0E-15]%n" +
-               "  - java.lang.Float -> FloatComparator[precision=1.0E-6]%n" +
-               "  - java.lang.Integer -> AbsValueComparator%n" +
-               "  - org.assertj.core.groups.Tuple -> AlwaysEqualComparator%n"));
-    // @format:on
+    assertThat(multiLineDescription).contains(format("- these types were compared with the following comparators:%n" +
+                                                     "  - java.lang.Double -> DoubleComparator[precision=1.0E-15]%n" +
+                                                     "  - java.lang.Float -> FloatComparator[precision=1.0E-6]%n" +
+                                                     "  - java.lang.Integer -> AbsValueComparator%n"),
+                                              "  - java.lang.String -> ",
+                                              "  - org.assertj.core.groups.Tuple -> AlwaysEqualComparator");
   }
 
   @Test
@@ -247,12 +250,23 @@ class RecursiveComparisonConfiguration_multiLineDescription_Test {
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
-    // @format:off
     assertThat(multiLineDescription).contains(format("- these fields were compared with the following comparators:%n" +
                                                      "  - bar -> AlwaysDifferentComparator%n" +
                                                      "  - foo -> AlwaysEqualComparator%n" +
                                                      "  - height -> %%s %% %%%% %%d%n"));
-    // @format:on
+  }
+
+  @Test
+  void should_show_the_registered_bipredicate_comparator_for_specific_fields_alphabetically() {
+    // GIVEN
+    recursiveComparisonConfiguration.registerEqualsForFields(STRING_EQUALS, "foo");
+    recursiveComparisonConfiguration.registerEqualsForFields(DOUBLE_EQUALS, "bar");
+    // WHEN
+    String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
+    // THEN
+    assertThat(multiLineDescription).containsSubsequence(format("- these fields were compared with the following comparators:%n"),
+                                                         "  - bar -> ",
+                                                         "  - foo -> ");
   }
 
   @Test
