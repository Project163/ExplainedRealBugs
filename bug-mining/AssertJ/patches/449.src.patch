diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 371dcd7b4..8e61717e2 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -205,7 +205,7 @@ public class RecursiveComparisonDifferenceCalculator {
 
       // Custom comparators take precedence over all other types of comparison
       if (recursiveComparisonConfiguration.hasCustomComparator(dualValue)) {
-        if (!propertyOrFieldValuesAreEqual(dualValue, recursiveComparisonConfiguration)) comparisonState.addDifference(dualValue);
+        if (!areDualValueEqual(dualValue, recursiveComparisonConfiguration)) comparisonState.addDifference(dualValue);
         // since we used a custom comparator we don't need to inspect the nested fields any further
         continue;
       }
@@ -673,23 +673,32 @@ public class RecursiveComparisonDifferenceCalculator {
     return false;
   }
 
-  @SuppressWarnings({ "unchecked", "rawtypes" })
-  private static boolean propertyOrFieldValuesAreEqual(DualValue dualValue,
-                                                       RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
+  @SuppressWarnings({ "rawtypes", "unchecked" })
+  private static boolean areDualValueEqual(DualValue dualValue,
+                                           RecursiveComparisonConfiguration recursiveComparisonConfiguration) {
     final String fieldName = dualValue.getConcatenatedPath();
     final Object actualFieldValue = dualValue.actual;
     final Object expectedFieldValue = dualValue.expected;
     // check field comparators as they take precedence over type comparators
     Comparator fieldComparator = recursiveComparisonConfiguration.getComparatorForField(fieldName);
-    if (fieldComparator != null) return fieldComparator.compare(actualFieldValue, expectedFieldValue) == 0;
+    if (fieldComparator != null) return areEqualUsingComparator(actualFieldValue, expectedFieldValue, fieldComparator);
     // check if a type comparators exist for the field type
     Class fieldType = actualFieldValue != null ? actualFieldValue.getClass() : expectedFieldValue.getClass();
     Comparator typeComparator = recursiveComparisonConfiguration.getComparatorForType(fieldType);
-    if (typeComparator != null) return typeComparator.compare(actualFieldValue, expectedFieldValue) == 0;
+    if (typeComparator != null) return areEqualUsingComparator(actualFieldValue, expectedFieldValue, typeComparator);
     // default comparison using equals
     return deepEquals(actualFieldValue, expectedFieldValue);
   }
 
+  private static boolean areEqualUsingComparator(final Object actual, final Object expected, Comparator<Object> comparator) {
+    try {
+      return comparator.compare(actual, expected) == 0;
+    } catch (ClassCastException e) {
+      // this occurs when comparing field of different types, Person.id is an int and PersonDto.id is a long
+      return false;
+    }
+  }
+
   private static ComparisonDifference expectedAndActualTypeDifference(Object actual, Object expected) {
     String additionalInformation = format("actual and expected are considered different since the comparison enforces strict type check and expected type %s is not a subtype of actual type %s",
                                           expected.getClass().getName(), actual.getClass().getName());
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
index 170067260..14e041e94 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_Test.java
@@ -30,6 +30,7 @@ import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.sql.Timestamp;
 import java.util.Date;
+import java.util.List;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
@@ -38,6 +39,7 @@ import org.assertj.core.internal.objects.data.FriendlyPerson;
 import org.assertj.core.internal.objects.data.Giant;
 import org.assertj.core.internal.objects.data.Human;
 import org.assertj.core.internal.objects.data.Person;
+import org.assertj.core.util.DoubleComparator;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.params.ParameterizedTest;
@@ -367,6 +369,74 @@ class RecursiveComparisonAssert_isEqualTo_Test extends RecursiveComparisonAssert
                           .isEqualTo(container2);
   }
 
+  // issue #2434
+  @Test
+  void should_treat_class_cast_expection_as_comparison_difference_when_comparing_lists() {
+    // GIVEN
+    Wrapper a = new Wrapper(Double.MAX_VALUE);
+    Wrapper b = new Wrapper(Integer.MAX_VALUE);
+    Wrappers actual = new Wrappers(a, b);
+    Wrappers expected = new Wrappers(b, a);
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .ignoringCollectionOrderInFields("values")
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_report_class_cast_expection_as_comparison_difference() {
+    // GIVEN
+    Wrapper actual = new Wrapper(1.0);
+    Wrapper expected = new Wrapper(5);
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, diff("value", 1.0, 5));
+  }
+
+  @Test
+  void should_treat_class_cast_expection_as_comparison_difference_when_comparing_lists_with_specific_equals() {
+    // GIVEN
+    Wrapper a = new Wrapper(1.001);
+    Wrapper b = new Wrapper(1);
+    Wrappers actual = new Wrappers(a, b);
+    Wrappers expected = new Wrappers(b, a);
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .ignoringCollectionOrderInFields("values")
+                .withEqualsForType((x, y) -> Math.abs(x - y) <= 0.05, Double.class)
+                .isEqualTo(expected);
+  }
+
+  @Test
+  void should_treat_class_cast_expection_as_comparison_difference() {
+    // GIVEN
+    Wrapper a = new Wrapper(Double.MAX_VALUE);
+    Wrapper b = new Wrapper(Integer.MAX_VALUE);
+    Wrappers actual = new Wrappers(a, b);
+    Wrappers expected = new Wrappers(b, a);
+    // WHEN/THEN
+    then(actual).usingRecursiveComparison()
+                .withComparatorForFields(new DoubleComparator(0.01), "values.value")
+                .ignoringCollectionOrderInFields("values")
+                .isEqualTo(expected);
+  }
+
+  public static class Wrappers {
+    private List<Wrapper> values;
+
+    public Wrappers(Wrapper a, Wrapper b) {
+      this.values = list(a, b);
+    }
+  }
+
+  static class Wrapper {
+    Object value;
+
+    Wrapper(Object value) {
+      this.value = value;
+    }
+  }
   public static class Container {
     private Path path;
 
