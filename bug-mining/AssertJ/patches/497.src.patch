diff --git a/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index 59a28d15f..b9823f91b 100644
--- a/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/assertj-core/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -498,7 +498,14 @@ public class StandardRepresentation implements Representation {
         builder.append(DEFAULT_MAX_ELEMENTS_EXCEEDED);
         return builder.append("}").toString();
       }
-      builder.append(format(map, entry.getKey())).append('=').append(format(map, entry.getValue()));
+
+      // the entry shouldn't be null in a valid map, but if it is, print it out gracefully instead of throwing a NPE
+      if (entry == null) {
+        builder.append("null");
+      } else {
+        builder.append(format(map, entry.getKey())).append('=').append(format(map, entry.getValue()));
+      }
+
       printedElements++;
       if (!entriesIterator.hasNext()) return builder.append("}").toString();
       builder.append(", ");
diff --git a/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java b/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
index c9093f6f2..bfeab85b0 100644
--- a/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/presentation/StandardRepresentation_map_format_Test.java
@@ -13,11 +13,10 @@
 package org.assertj.core.presentation;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 
 import java.io.File;
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.Map;
+import java.util.*;
 
 import org.junit.jupiter.api.Test;
 
@@ -44,46 +43,82 @@ class StandardRepresentation_map_format_Test extends AbstractBaseRepresentationT
 
   @Test
   void should_format_Map() {
+    // GIVEN
     Map<String, Class<?>> map = new LinkedHashMap<>();
     map.put("One", String.class);
     map.put("Two", File.class);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(map)).isEqualTo("{\"One\"=java.lang.String, \"Two\"=java.io.File}");
+    // WHEN
+    String mapRepresentation = STANDARD_REPRESENTATION.toStringOf(map);
+    // THEN
+    then(mapRepresentation).isEqualTo("{\"One\"=java.lang.String, \"Two\"=java.io.File}");
   }
 
   @Test
   void should_format_Map_up_to_the_maximum_allowed_elements() {
+    // GIVEN
     Map<Character, Integer> map = new HashMap<>();
     map.put('C', 3);
     map.put('B', 2);
     map.put('A', 1);
     StandardRepresentation.setMaxElementsForPrinting(2);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(map)).isEqualTo("{'A'=1, 'B'=2, ...}");
+    // WHEN
+    String mapRepresentation = STANDARD_REPRESENTATION.toStringOf(map);
+    // THEN
+    then(mapRepresentation).isEqualTo("{'A'=1, 'B'=2, ...}");
   }
 
   @Test
   void should_format_Map_containing_itself() {
+    // GIVEN
     Map<String, Object> map = new HashMap<>();
     map.put("One", "First");
     map.put("Myself", map);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(map)).isEqualTo("{\"Myself\"=(this Map), \"One\"=\"First\"}");
+    // WHEN
+    String mapRepresentation = STANDARD_REPRESENTATION.toStringOf(map);
+    // THEN
+    then(mapRepresentation).isEqualTo("{\"Myself\"=(this Map), \"One\"=\"First\"}");
   }
 
   @Test
   void should_sort_Map_before_formatting() {
+    // GIVEN
     Map<Character, Integer> map = new HashMap<>();
     map.put('C', 3);
     map.put('B', 2);
     map.put('A', 1);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(map)).isEqualTo("{'A'=1, 'B'=2, 'C'=3}");
+    // WHEN
+    String mapRepresentation = STANDARD_REPRESENTATION.toStringOf(map);
+    // THEN
+    then(mapRepresentation).isEqualTo("{'A'=1, 'B'=2, 'C'=3}");
   }
 
   @Test
   void should_retain_initial_ordering_if_keys_are_not_comparable() {
+    // GIVEN
     Map<Object, Integer> map = new LinkedHashMap<>();
     map.put("foo", 3);
     map.put(false, 2);
     map.put('A', 1);
+    // WHEN
+    String mapRepresentation = STANDARD_REPRESENTATION.toStringOf(map);
+    // THEN
+    then(mapRepresentation).isEqualTo("{\"foo\"=3, false=2, 'A'=1}");
+  }
 
-    assertThat(STANDARD_REPRESENTATION.toStringOf(map)).isEqualTo("{\"foo\"=3, false=2, 'A'=1}");
+  @Test
+  void should_formal_null_in_the_entry_set() {
+    // GIVEN
+    Map<Integer, Integer> map = new AbstractMap<Integer, Integer>() {
+      @Override
+      public Set<Entry<Integer, Integer>> entrySet() {
+        Set <Entry<Integer, Integer>> entries = new HashSet<>();
+        entries.add(null);
+        return entries;
+      }
+    };
+    // WHEN
+    String mapRepresentation = STANDARD_REPRESENTATION.toStringOf(map);
+    // THEN
+    then(mapRepresentation).isEqualTo("{null}");
   }
 }
