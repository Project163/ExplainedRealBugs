diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
index 130e6a8fe..1e72ad2cc 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/DualValue.java
@@ -215,11 +215,13 @@ public final class DualValue {
 
   private static boolean isPotentialCyclingValue(Object object) {
     if (object == null) return false;
-    // java.lang are base types that can't cycle to themselves of other types
-    // we could check more type, but that's a good start
+    // java.lang are base types that can't cycle to themselves or other types
+    // we could check more types, but that's a good start
     String canonicalName = object.getClass().getCanonicalName();
     // canonicalName is null for anonymous and local classes, return true as they can cycle back to other objects.
     if (canonicalName == null) return true;
+    // enums can refer back to other object but since they are constants it is very unlikely that they generate cycles.
+    if (object.getClass().isEnum()) return false;
     return !canonicalName.startsWith("java.lang");
   }
 
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index a90dcd794..f21d07c95 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -140,9 +140,9 @@ public class RecursiveComparisonDifferenceCalculator {
       } else {
         dualValuesToCompare.addFirst(dualValue);
       }
-      // We need to remove already visited fields pair to avoid infinite recursion in case
-      // parent -> set{child} with child having a reference back to parent
-      // it occurs to unordered collection where we compare all possible combination of the collection elements recursively
+      // We need to remove already visited fields pair to avoid infinite recursion in case parent -> set{child} with child having
+      // a reference back to its parent but only for complex types can have cycle, this is not the case for primitive or enums.
+      // It occurs for unordered collection where we compare all possible combination of the collection elements recursively.
       // --
       // remove visited values one by one, DualValue.equals correctly compare respective actual and expected fields by reference
       visitedDualValues.forEach(visitedDualValue -> dualValuesToCompare.stream()
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
index 2ade10152..4d63779c8 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
@@ -14,6 +14,8 @@ package org.assertj.core.api.recursive.comparison;
 
 import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.Type.FIRST;
+import static org.assertj.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.Type.SECOND;
 import static org.assertj.core.internal.objects.data.FriendlyPerson.friend;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.list;
@@ -358,4 +360,70 @@ class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
 
   }
 
+  enum Type {
+    FIRST, SECOND,
+  }
+
+  static class PersonWithEnum {
+    String name;
+    Type type;
+
+    PersonWithEnum(String name, Type type) {
+      this.name = name;
+      this.type = type;
+    }
+
+    @Override
+    public String toString() {
+      return String.format("Person [name=%s, type=%s]", name, type);
+    }
+
+  }
+
+  @Test
+  public void should_not_remove_already_visited_enum_dual_values_as_they_cant_produce_cycles() {
+    // GIVEN
+    List<PersonWithEnum> persons = list(new PersonWithEnum("name-1", FIRST),
+                                        new PersonWithEnum("name-2", FIRST),
+                                        new PersonWithEnum("name-2", SECOND));
+
+    // WHEN/THEN
+    assertThat(persons).usingRecursiveComparison()
+                       .ignoringCollectionOrder()
+                       .isEqualTo(list(new PersonWithEnum("name-2", SECOND),
+                                       new PersonWithEnum("name-2", FIRST),
+                                       new PersonWithEnum("name-1", FIRST)));
+  }
+
+  static class PersonWithInt {
+    String name;
+    int type;
+
+    PersonWithInt(String name, int type) {
+      this.name = name;
+      this.type = type;
+    }
+
+    @Override
+    public String toString() {
+      return String.format("Person [name=%s, type=%s]", name, type);
+    }
+
+  }
+
+  @Test
+  public void should_not_remove_already_visited_int_dual_values_as_they_cant_produce_cycles() {
+    // GIVEN
+    List<PersonWithInt> persons = list(new PersonWithInt("name-1", 1),
+                                       new PersonWithInt("name-2", 1),
+                                       new PersonWithInt("name-2", 2));
+
+    // WHEN/THEN
+    assertThat(persons).usingRecursiveComparison()
+                       .ignoringCollectionOrder()
+                       .isEqualTo(list(new PersonWithInt("name-2", 2),
+                                       new PersonWithInt("name-2", 1),
+                                       new PersonWithInt("name-1", 1)));
+  }
+
 }
