diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
index 9f83029dd..5a651b5a0 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
@@ -661,4 +661,67 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
     return new WithThrowable(exception);
   }
 
+  /**
+   * Checks that the future completes exceptionally within the given time (by calling {@link Future#get(long, TimeUnit)})
+   * and returns the exception that caused the failure for further (exception) assertions.
+   * The exception can be {@link ExecutionException} or {@link CancellationException}.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> CompletableFuture&lt;Void&gt; completableFuture = futureThrowingExceptionAfterMs(100);
+   *
+   * // assertion fails as the future is not completed (neither successfully nor exceptionally) within 1 ms
+   * assertThat(completableFuture).completesExceptionallyWithin(1, MILLISECONDS);
+   *
+   * // assertion succeeds as after a longer wait the future is completed with the expected exception
+   * assertThat(completableFuture).completesExceptionallyWithin(200, MILLISECONDS)
+   *                              .withThrowableOfType(ExecutionException.class)
+   *                              .withMessageContaining("boom!");</code></pre>
+   *
+   * @param timeout the maximum duration to wait
+   * @return a new assertion instance on the future's exception.
+   * @throws AssertionError if the actual {@code CompletableFuture} is {@code null}.
+   * @throws AssertionError if the actual {@code CompletableFuture} succeeds or doesn't complete at all within the given timeout.
+   * @since 3.27.0
+   */
+  public WithThrowable completesExceptionallyWithin(Duration timeout) {
+    return internalCompletesExceptionallyWithin(timeout);
+  }
+
+  /**
+   * Checks that the future completes exceptionally within the given time (by calling {@link Future#get(long, TimeUnit)})
+   * and returns the exception that caused the failure for further (exception) assertions.
+   * The exception can be {@link ExecutionException} or {@link CancellationException}.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> CompletableFuture&lt;Void&gt; completableFuture = futureThrowingExceptionAfterMs(100);
+   *
+   * // assertion fails as the future is not completed (neither successfully nor exceptionally) within 1 ms
+   * assertThat(completableFuture).completesExceptionallyWithin(Duration.ofMillis(1));
+   *
+   * // assertion succeeds as after a longer wait the future is completed with the expected exception
+   * assertThat(completableFuture).completesExceptionallyWithin(Duration.ofMillis(200))
+   *                              .withThrowableOfType(ExecutionException.class)
+   *                              .withMessageContaining("boom!");</code></pre>
+   *
+   * @param timeout the maximum time to wait
+   * @param unit the timeout unit
+   * @return a new assertion instance on the future's exception.
+   * @throws AssertionError if the actual {@code CompletableFuture} is {@code null}.
+   * @throws AssertionError if the actual {@code CompletableFuture} succeeds or doesn't complete at all within the given timeout.
+   * @since 3.27.0
+   */
+  public WithThrowable completesExceptionallyWithin(long timeout, TimeUnit unit) {
+    return internalCompletesExceptionallyWithin(timeout, unit);
+  }
+
+  private WithThrowable internalCompletesExceptionallyWithin(Duration timeout) {
+    Exception exception = futures.assertCompletedExceptionallyWithin(info, actual, timeout);
+    return new WithThrowable(exception);
+  }
+
+  private WithThrowable internalCompletesExceptionallyWithin(long timeout, TimeUnit unit) {
+    Exception exception = futures.assertCompletedExceptionallyWithin(info, actual, timeout, unit);
+    return new WithThrowable(exception);
+  }
+
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/error/future/ShouldHaveCompletedExceptionallyWithin.java b/assertj-core/src/main/java/org/assertj/core/error/future/ShouldHaveCompletedExceptionallyWithin.java
new file mode 100644
index 000000000..93590a260
--- /dev/null
+++ b/assertj-core/src/main/java/org/assertj/core/error/future/ShouldHaveCompletedExceptionallyWithin.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2024 the original author or authors.
+ */
+package org.assertj.core.error.future;
+
+import java.time.Duration;
+import java.util.concurrent.Future;
+import java.util.concurrent.TimeUnit;
+import org.assertj.core.error.BasicErrorMessageFactory;
+import org.assertj.core.error.ErrorMessageFactory;
+
+public class ShouldHaveCompletedExceptionallyWithin extends BasicErrorMessageFactory {
+
+  private static final String SHOULD_HAVE_COMPLETED_EXCEPTIONALLY_WITHIN_DURATION = "%n" +
+                                                                                    "Expecting%n" +
+                                                                                    "  <%s>%n" +
+                                                                                    "to have completed exceptionally " +
+                                                                                    "within %s.%n" +
+                                                                                    Warning.WARNING;
+  private static final String SHOULD_HAVE_COMPLETED_EXCEPTIONALLY_WITHIN = "%n" +
+                                                                           "Expecting%n" +
+                                                                           "  <%s>%n" +
+                                                                           "to have completed exceptionally within %s %s.%n" +
+                                                                           Warning.WARNING;
+
+  public static ErrorMessageFactory shouldHaveCompletedExceptionallyWithin(Future<?> actual, Duration timeout) {
+    return new ShouldHaveCompletedExceptionallyWithin(actual, timeout);
+  }
+
+  public static ErrorMessageFactory shouldHaveCompletedExceptionallyWithin(Future<?> actual, long timeout, TimeUnit unit) {
+    return new ShouldHaveCompletedExceptionallyWithin(actual, timeout, unit);
+  }
+
+  private ShouldHaveCompletedExceptionallyWithin(Future<?> actual, Duration timeout) {
+    super(SHOULD_HAVE_COMPLETED_EXCEPTIONALLY_WITHIN_DURATION, actual, timeout);
+  }
+
+  private ShouldHaveCompletedExceptionallyWithin(Future<?> actual, long timeout, TimeUnit unit) {
+    super(SHOULD_HAVE_COMPLETED_EXCEPTIONALLY_WITHIN, actual, timeout, unit);
+  }
+}
diff --git a/assertj-core/src/main/java/org/assertj/core/internal/Futures.java b/assertj-core/src/main/java/org/assertj/core/internal/Futures.java
index d52a6316d..4821cc8a8 100644
--- a/assertj-core/src/main/java/org/assertj/core/internal/Futures.java
+++ b/assertj-core/src/main/java/org/assertj/core/internal/Futures.java
@@ -15,6 +15,7 @@ package org.assertj.core.internal;
 import static org.assertj.core.error.future.ShouldBeCancelled.shouldBeCancelled;
 import static org.assertj.core.error.future.ShouldBeCompletedWithin.shouldBeCompletedWithin;
 import static org.assertj.core.error.future.ShouldBeDone.shouldBeDone;
+import static org.assertj.core.error.future.ShouldHaveCompletedExceptionallyWithin.shouldHaveCompletedExceptionallyWithin;
 import static org.assertj.core.error.future.ShouldHaveFailedWithin.shouldHaveFailedWithin;
 import static org.assertj.core.error.future.ShouldNotBeCancelled.shouldNotBeCancelled;
 import static org.assertj.core.error.future.ShouldNotBeDone.shouldNotBeDone;
@@ -132,6 +133,30 @@ public class Futures {
     }
   }
 
+  public Exception assertCompletedExceptionallyWithin(AssertionInfo info, Future<?> actual, Duration timeout) {
+    assertNotNull(info, actual);
+    try {
+      actual.get(timeout.toNanos(), TimeUnit.NANOSECONDS);
+      throw failures.failure(info, shouldHaveCompletedExceptionallyWithin(actual, timeout));
+    } catch (ExecutionException | CancellationException e) {
+      return e;
+    } catch (InterruptedException | TimeoutException e) {
+      throw failures.failure(info, shouldHaveCompletedExceptionallyWithin(actual, timeout));
+    }
+  }
+
+  public Exception assertCompletedExceptionallyWithin(AssertionInfo info, Future<?> actual, long timeout, TimeUnit unit) {
+    assertNotNull(info, actual);
+    try {
+      actual.get(timeout, unit);
+      throw failures.failure(info, shouldHaveCompletedExceptionallyWithin(actual, timeout, unit));
+    } catch (ExecutionException | CancellationException e) {
+      return e;
+    } catch (TimeoutException | InterruptedException e) {
+      throw failures.failure(info, shouldHaveCompletedExceptionallyWithin(actual, timeout, unit));
+    }
+  }
+
   private void assertNotNull(AssertionInfo info, Future<?> actual) {
     Objects.instance().assertNotNull(info, actual);
   }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_completesExceptionallyWithin_Test.java b/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_completesExceptionallyWithin_Test.java
new file mode 100644
index 000000000..a25645b1f
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_completesExceptionallyWithin_Test.java
@@ -0,0 +1,120 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2024 the original author or authors.
+ */
+package org.assertj.core.api.future;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.future.FutureTestHelper.futureCompletingAfter;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+
+import org.junit.jupiter.api.Test;
+
+class CompletableFutureAssert_completesExceptionallyWithin_Test extends AbstractFutureTest {
+
+  private static final Duration ONE_SECOND = Duration.ofSeconds(1);
+
+  @Test
+  void should_fail_when_future_does_not_complete_within_timeout_Duration() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND, executorService);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).completesExceptionallyWithin(Duration.ofMillis(50)));
+    // THEN
+    then(assertionError).hasMessageContainingAll("Incomplete", "to have completed exceptionally within 0.05S.");
+  }
+
+  @Test
+  void should_fail_when_future_does_not_complete_within_timeout() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND, executorService);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).completesExceptionallyWithin(50, MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessageContainingAll("Incomplete", "to have completed exceptionally within 50L MILLISECONDS.");
+  }
+
+  @Test
+  void should_fail_if_future_completes_within_given_timeout() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(Duration.ofMillis(10), executorService);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).completesExceptionallyWithin(500,
+                                                                                                               MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessageContainingAll("Completed", "to have completed exceptionally within 500L MILLISECONDS.");
+  }
+
+  @Test
+  void should_fail_if_future_completes_within_given_timeout_Duration() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(Duration.ofMillis(10), executorService);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).completesExceptionallyWithin(Duration.ofMillis(500)));
+    // THEN
+    then(assertionError).hasMessageContainingAll("Completed", "to have completed exceptionally within 0.5S.");
+  }
+
+  @Test
+  void should_pass_if_future_is_cancelled() {
+    // GIVEN
+    CompletableFuture<Void> future = new CompletableFuture<>();
+    future.cancel(false);
+    // WHEN/THEN
+    then(future).completesExceptionallyWithin(1, MILLISECONDS);
+    then(future).completesExceptionallyWithin(Duration.ofMillis(1));
+  }
+
+  @Test
+  void should_pass_if_future_execution_fails() {
+    // GIVEN
+    CompletableFuture<Void> future = new CompletableFuture<>();
+    future.completeExceptionally(new RuntimeException("boom!"));
+    // WHEN/THEN
+    then(future).completesExceptionallyWithin(1, MILLISECONDS)
+                .withThrowableOfType(ExecutionException.class)
+                .withMessageContaining("boom!");
+    then(future).completesExceptionallyWithin(Duration.ofMillis(1))
+                .withThrowableThat()
+                .isInstanceOf(ExecutionException.class)
+                .withMessageContaining("boom!");
+  }
+
+  @Test
+  void should_fail_when_wait_is_interrupted() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND, executorService);
+    // WHEN
+    Thread.currentThread().interrupt();
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).completesExceptionallyWithin(2, SECONDS));
+    // THEN
+    then(assertionError).hasMessageContainingAll("Incomplete", "to have completed exceptionally within 2L SECONDS.");
+  }
+
+  @Test
+  void should_fail_when_future_is_null() {
+    // GIVEN
+    CompletableFuture<Void> future = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).completesExceptionallyWithin(1, MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_failsWithin_Test.java b/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_failsWithin_Test.java
index 865caaf50..c3a604333 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_failsWithin_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_failsWithin_Test.java
@@ -15,13 +15,13 @@ package org.assertj.core.api.future;
 import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.future.FutureTestHelper.futureCompletingAfter;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.Duration;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.ExecutionException;
-import java.util.concurrent.Executor;
 import java.util.concurrent.TimeoutException;
 
 import org.junit.jupiter.api.Test;
@@ -35,7 +35,7 @@ class CompletableFutureAssert_failsWithin_Test extends AbstractFutureTest {
     // GIVEN
     CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND, executorService);
     // WHEN/THEN
-    assertThat(future).failsWithin(Duration.ofMillis(50));
+    then(future).failsWithin(Duration.ofMillis(50));
   }
 
   @Test
@@ -43,7 +43,7 @@ class CompletableFutureAssert_failsWithin_Test extends AbstractFutureTest {
     // GIVEN
     CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND, executorService);
     // WHEN/THEN
-    assertThat(future).failsWithin(50, MILLISECONDS);
+    then(future).failsWithin(50, MILLISECONDS);
   }
 
   @Test
@@ -51,9 +51,9 @@ class CompletableFutureAssert_failsWithin_Test extends AbstractFutureTest {
     // GIVEN
     CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND, executorService);
     // WHEN/THEN
-    assertThat(future).failsWithin(Duration.ofMillis(50))
-                      .withThrowableOfType(TimeoutException.class)
-                      .withMessage(null);
+    then(future).failsWithin(Duration.ofMillis(50))
+                .withThrowableOfType(TimeoutException.class)
+                .withMessage(null);
   }
 
   @Test
@@ -61,10 +61,10 @@ class CompletableFutureAssert_failsWithin_Test extends AbstractFutureTest {
     // GIVEN
     CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND, executorService);
     // WHEN/THEN
-    assertThat(future).failsWithin(50, MILLISECONDS)
-                      .withThrowableThat()
-                      .isInstanceOf(TimeoutException.class)
-                      .withMessage(null);
+    then(future).failsWithin(50, MILLISECONDS)
+                .withThrowableThat()
+                .isInstanceOf(TimeoutException.class)
+                .withMessage(null);
   }
 
   @Test
@@ -72,7 +72,7 @@ class CompletableFutureAssert_failsWithin_Test extends AbstractFutureTest {
     // GIVEN
     CompletableFuture<Void> future = futureCompletingAfter(Duration.ofMillis(10), executorService);
     // WHEN
-    AssertionError assertionError = expectAssertionError(() -> assertThat(future).failsWithin(500, MILLISECONDS));
+    AssertionError assertionError = expectAssertionError(() -> then(future).failsWithin(500, MILLISECONDS));
     // THEN
     then(assertionError).hasMessageContainingAll("Completed", "to have failed within 500L MILLISECONDS.");
   }
@@ -100,16 +100,16 @@ class CompletableFutureAssert_failsWithin_Test extends AbstractFutureTest {
   @Test
   void should_pass_if_future_execution_fails() {
     // GIVEN
-    CompletableFuture<Void> completableFuture = new CompletableFuture<>();
-    completableFuture.completeExceptionally(new RuntimeException("boom!"));
+    CompletableFuture<Void> future = new CompletableFuture<>();
+    future.completeExceptionally(new RuntimeException("boom!"));
     // WHEN/THEN
-    then(completableFuture).failsWithin(1, MILLISECONDS)
-                           .withThrowableOfType(ExecutionException.class)
-                           .withMessageContaining("boom!");
-    then(completableFuture).failsWithin(Duration.ofMillis(1))
-                           .withThrowableThat()
-                           .isInstanceOf(ExecutionException.class)
-                           .withMessageContaining("boom!");
+    then(future).failsWithin(1, MILLISECONDS)
+                .withThrowableOfType(ExecutionException.class)
+                .withMessageContaining("boom!");
+    then(future).failsWithin(Duration.ofMillis(1))
+                .withThrowableThat()
+                .isInstanceOf(ExecutionException.class)
+                .withMessageContaining("boom!");
   }
 
   @Test
@@ -122,16 +122,4 @@ class CompletableFutureAssert_failsWithin_Test extends AbstractFutureTest {
     then(assertionError).hasMessage(actualIsNull());
   }
 
-  private static CompletableFuture<Void> futureCompletingAfter(Duration duration, Executor executor) {
-    return CompletableFuture.runAsync(() -> sleep(duration), executor);
-  }
-
-  private static void sleep(Duration duration) {
-    try {
-      Thread.sleep(duration.toMillis());
-    } catch (@SuppressWarnings("unused") InterruptedException e) {
-      // do nothing
-    }
-  }
-
 }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValueMatchingWithin_Test.java b/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValueMatchingWithin_Test.java
index d687adefc..3607c104f 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValueMatchingWithin_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValueMatchingWithin_Test.java
@@ -65,7 +65,7 @@ public class CompletableFutureAssert_isCompletedWithValueMatchingWithin_Test ext
   @Test
   void should_fail_on_pending_future_that_will_not_complete_in_provided_period() {
     // GIVEN
-    CompletableFuture<String> future = completedFutureAfter("string", Duration.ofSeconds(1), executorService);
+    CompletableFuture<String> future = completedFutureAfter("123456", Duration.ofSeconds(1), executorService);
     // WHEN/THEN
     expectAssertionError(() -> assertThat(future).isCompletedWithValueMatchingWithin(s -> s.length() == 6, TEN_MS));
   }
diff --git a/assertj-core/src/test/java/org/assertj/core/api/future/FutureTestHelper.java b/assertj-core/src/test/java/org/assertj/core/api/future/FutureTestHelper.java
new file mode 100644
index 000000000..e5f011147
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/api/future/FutureTestHelper.java
@@ -0,0 +1,32 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2024 the original author or authors.
+ */
+package org.assertj.core.api.future;
+
+import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executor;
+
+class FutureTestHelper {
+
+  static CompletableFuture<Void> futureCompletingAfter(Duration duration, Executor executor) {
+    return CompletableFuture.runAsync(() -> sleep(duration), executor);
+  }
+
+  static void sleep(Duration duration) {
+    try {
+      Thread.sleep(duration.toMillis());
+    } catch (@SuppressWarnings("unused") InterruptedException e) {
+      // do nothing
+    }
+  }
+}
diff --git a/assertj-core/src/test/java/org/assertj/core/error/future/ShouldHaveCompletedExceptionallyWithin_create_Test.java b/assertj-core/src/test/java/org/assertj/core/error/future/ShouldHaveCompletedExceptionallyWithin_create_Test.java
new file mode 100644
index 000000000..ef4ce5bce
--- /dev/null
+++ b/assertj-core/src/test/java/org/assertj/core/error/future/ShouldHaveCompletedExceptionallyWithin_create_Test.java
@@ -0,0 +1,54 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2024 the original author or authors.
+ */
+package org.assertj.core.error.future;
+
+import static java.lang.String.format;
+import static java.util.concurrent.TimeUnit.SECONDS;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.future.ShouldHaveCompletedExceptionallyWithin.shouldHaveCompletedExceptionallyWithin;
+import static org.assertj.core.error.future.Warning.WARNING;
+
+import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+
+import org.assertj.core.internal.TestDescription;
+import org.junit.jupiter.api.Test;
+
+class ShouldHaveCompletedExceptionallyWithin_create_Test {
+
+  private final CompletableFuture<Object> future = new CompletableFuture<>();
+  private final TestDescription description = new TestDescription("TEST");
+
+  @Test
+  void should_create_error_message() {
+    // WHEN
+    String error = shouldHaveCompletedExceptionallyWithin(future, 1, SECONDS).create(description);
+    // THEN
+    then(error).isEqualTo(format("[TEST] %n" +
+                                 "Expecting%n" +
+                                 "  <CompletableFuture[Incomplete]>%n" +
+                                 "to have completed exceptionally within 1L SECONDS.%n%s", WARNING));
+  }
+
+  @Test
+  void should_create_error_message_Duration() {
+    // WHEN
+    String error = shouldHaveCompletedExceptionallyWithin(future, Duration.ofSeconds(1)).create(description);
+    // THEN
+    then(error).isEqualTo(format("[TEST] %n" +
+                                 "Expecting%n" +
+                                 "  <CompletableFuture[Incomplete]>%n" +
+                                 "to have completed exceptionally within 1S.%n%s", WARNING));
+  }
+
+}
