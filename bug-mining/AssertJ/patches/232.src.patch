diff --git a/src/main/java/org/assertj/core/api/AbstractClassAssert.java b/src/main/java/org/assertj/core/api/AbstractClassAssert.java
index a20297928..6cd271081 100644
--- a/src/main/java/org/assertj/core/api/AbstractClassAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractClassAssert.java
@@ -26,7 +26,8 @@ import org.assertj.core.internal.Classes;
  * @author William Delanoue
  * @author Mikhail Mazursky
  */
-public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>> extends AbstractAssert<SELF, Class<?>> {
+public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>>
+    extends AbstractAssert<SELF, Class<?>> {
 
   Classes classes = Classes.instance();
 
@@ -40,10 +41,10 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
    * <pre><code class='java'> class Jedi {}
    * class HumanJedi extends Jedi {}
    * 
-   * // Should pass if :
+   * // Should pass if:
    * assertThat(Jedi.class).isAssignableFrom(HumanJedi.class);
    * 
-   * // Should fail if :
+   * // Should fail if:
    * assertThat(HumanJedi.class).isAssignableFrom(Jedi.class);</code></pre>
    * 
    * @see Class#isAssignableFrom(Class)
@@ -64,10 +65,10 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
    * <pre><code class='java'> interface Jedi {}
    * class HumanJedi implements Jedi {}
    * 
-   * // Should pass if :
+   * // Should pass if:
    * assertThat(HumanJedi.class).isNotInterface();
    * 
-   * // Should fail if :
+   * // Should fail if:
    * assertThat(Jedi.class).isNotInterface();</code></pre>
    * 
    * @throws AssertionError if {@code actual} is {@code null}.
@@ -84,10 +85,10 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
    * <pre><code class='java'> interface Jedi {}
    * class HumanJedi implements Jedi {}
    * 
-   * // Should pass if :
+   * // Should pass if:
    * assertThat(Jedi.class).isInterface();
    * 
-   * // Should fail if :
+   * // Should fail if:
    * assertThat(HumanJedi.class).isInterface();</code></pre>
    * 
    * @throws AssertionError if {@code actual} is {@code null}.
@@ -103,12 +104,12 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
    * 
    * <pre><code class='java'> public @interface Jedi {}
    * 
-   * // Should pass if :
+   * // Should pass if:
    * assertThat(Jedi.class).isAnnotation();
    * assertThat(Override.class).isAnnotation();
    * assertThat(Deprecated.class).isAnnotation();
    * 
-   * // Should fail if :
+   * // Should fail if:
    * assertThat(String.class).isAnnotation();</code></pre>
    * 
    * @throws AssertionError if {@code actual} is {@code null}.
@@ -124,10 +125,10 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
    * 
    * <pre><code class='java'> public @interface Jedi {}
    * 
-   * // Should pass if :
+   * // Should pass if:
    * assertThat(String.class).isNotAnnotation();
    * 
-   * // Should fail if :
+   * // Should fail if:
    * assertThat(Jedi.class).isNotAnnotation();
    * assertThat(Override.class).isNotAnnotation();
    * assertThat(Deprecated.class).isNotAnnotation();</code></pre>
@@ -222,7 +223,6 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
     return myself;
   }
 
-
   /**
    * Verifies that the actual {@code Class} has the given {@code Annotation}s.
    * 
@@ -265,10 +265,10 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
    * &#64;Force
    * class Jedi implements Jedi {}
    * 
-   * // Should pass if :
+   * // Should pass if:
    * assertThat(Jedi.class).containsAnnotation(Force.class);
    * 
-   * // Should fail if :
+   * // Should fail if:
    * assertThat(Jedi.class).containsAnnotation(DarkSide.class);</code></pre>
    * 
    * @param annotation annotations who must be attached to the class
@@ -282,24 +282,24 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
   }
 
   /**
-   * Verifies that the actual {@code Class} has the {@code fields}.
-   * 
+   * Verifies that the actual {@code Class} has the given accessible public fields (as in {@link Class#getFields()}).
+   * <p>
    * <pre><code class='java'> class MyClass {
    *     public String fieldOne;
    *     private String fieldTwo;
    * }
    * 
-   * // This one should pass :
+   * // this assertion succeeds:
    * assertThat(MyClass.class).hasFields("fieldOne");
    * 
-   * // This one should fail :
+   * // these assertions fail:
    * assertThat(MyClass.class).hasFields("fieldTwo");
-   * assertThat(MyClass.class).hasDeclaredFields("fieldThree");</code></pre>
+   * assertThat(MyClass.class).hasFields("fieldThree");</code></pre>
    * 
    * @see Class#getField(String)
    * @param fields the fields who must be in the class.
    * @throws AssertionError if {@code actual} is {@code null}.
-   * @throws AssertionError if the actual {@code Class} doesn't contains all of the field.
+   * @throws AssertionError if the actual {@code Class} doesn't contain all of the fields.
    */
   public SELF hasFields(String... fields) {
     classes.assertHasFields(info, actual, fields);
@@ -307,17 +307,46 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
   }
 
   /**
-   * Verifies that the actual {@code Class} has the declared {@code fields}.
+   * Verifies that the actual {@code Class} <b>only</b> has the given accessible public 
+   * fields (as in {@link Class#getFields()}) and nothing more <b>in any order</b>.
+   *
+   * <pre><code class='java'> class MyClass {
+   *     public String fieldOne;
+   *     public String fieldTwo;
+   *     private String fieldThree;
+   * }
+   *
+   * // these assertions succeed:
+   * assertThat(MyClass.class).hasOnlyFields("fieldOne", "fieldTwo");
+   * assertThat(MyClass.class).hasOnlyFields("fieldTwo", "fieldOne");
+   *
+   * // this assertion fails:
+   * assertThat(MyClass.class).hasOnlyFields("fieldOne");</code></pre>
+   *
+   * @see Class#getField(String)
+   * @param fields all the fields that are expected to be in the class.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if fields are not all the actual {@code Class}'s accessible public fields.
+   *
+   * @since 2.7.0 / 3.7.0
+   */
+  public SELF hasOnlyFields(String... fields) {
+    classes.assertHasOnlyFields(info, actual, fields);
+    return myself;
+  }
+
+  /**
+   * Verifies that the actual {@code Class} has the given declared fields (as in {@link Class#getDeclaredFields()}).
    * 
    * <pre><code class='java'> class MyClass {
    *     public String fieldOne;
    *     private String fieldTwo;
    * }
    * 
-   * // This one should pass :
+   * // this assertion succeeds:
    * assertThat(MyClass.class).hasDeclaredFields("fieldOne", "fieldTwo");
    * 
-   * // This one should fail :
+   * // this assertion fails:
    * assertThat(MyClass.class).hasDeclaredFields("fieldThree");</code></pre>
    * 
    * @see Class#getDeclaredField(String)
@@ -330,6 +359,35 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
     return myself;
   }
 
+  /**
+   * Verifies that the actual {@code Class} <b>only</b> has the given declared {@code fields} and nothing more <b>in any order</b> 
+   * (as in {@link Class#getDeclaredFields()}).
+   *
+   * <pre><code class='java'> class MyClass {
+   *     public String fieldOne;
+   *     public String fieldTwo;
+   *     private String fieldThree;
+   *     private String fieldFour;
+   * }
+   *
+   * // this assertion succeeds:
+   * assertThat(MyClass.class).hasOnlyDeclaredFields("fieldOne", "fieldTwo", "fieldThree", "fieldFour");
+   *
+   * // this assertion fails:
+   * assertThat(MyClass.class).hasOnlyDeclaredFields("fieldOne", "fieldThree");</code></pre>
+   *
+   * @see Class#getField(String)
+   * @param fields all the fields that are expected to be in the class.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if fields are not all the declared fields of the actual {@code Class}.
+   *
+   * @since 2.7.0 / 3.7.0
+   */
+  public SELF hasOnlyDeclaredFields(String... fields) {
+    classes.assertHasOnlyDeclaredFields(info, actual, fields);
+    return myself;
+  }
+
   /**
    * Verifies that the actual {@code Class} has the given methods.
    *
@@ -338,10 +396,10 @@ public abstract class AbstractClassAssert<SELF extends AbstractClassAssert<SELF>
    *     private void methodTwo() {}
    * }
    *
-   * // This assertion succeeds:
+   * // this assertion succeeds:
    * assertThat(MyClass.class).hasMethods("methodOne");
    *
-   * // These assertions fail:
+   * // these assertions fail:
    * assertThat(MyClass.class).hasMethods("methodTwo");
    * assertThat(MyClass.class).hasMethods("methodThree");</code></pre>
    *
diff --git a/src/main/java/org/assertj/core/error/ShouldOnlyHaveFields.java b/src/main/java/org/assertj/core/error/ShouldOnlyHaveFields.java
new file mode 100644
index 000000000..3aea55214
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldOnlyHaveFields.java
@@ -0,0 +1,103 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2017 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.error.ShouldOnlyHaveFields.ErrorType.NOT_EXPECTED_ONLY;
+import static org.assertj.core.error.ShouldOnlyHaveFields.ErrorType.NOT_FOUND_ONLY;
+import static org.assertj.core.util.IterableUtil.isNullOrEmpty;
+
+import java.util.Collection;
+
+/**
+ * Creates an error message indicating that an assertion that verifies that a class has only the fields.
+ *
+ * @author Filip Hrisafov
+ */
+public class ShouldOnlyHaveFields extends BasicErrorMessageFactory {
+
+  /**
+   * Creates a new </code>{@link ShouldOnlyHaveFields}</code>.
+   *
+   * @param actual the actual value in the failed assertion.
+   * @param expected expected fields for this class
+   * @param notFound fields in {@code expected} not found in the {@code actual}.
+   * @param notExpected fields in the {@code actual} that were not in {@code expected}.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldOnlyHaveFields(Class<?> actual, Collection<String> expected,
+                                                            Collection<String> notFound,
+                                                            Collection<String> notExpected) {
+    return create(actual, expected, notFound, notExpected, false);
+  }
+
+  /**
+   * Creates a new </code>{@link ShouldOnlyHaveFields}</code>.
+   *
+   * @param actual the actual value in the failed assertion.
+   * @param expected expected fields for this class
+   * @param notFound fields in {@code expected} not found in the {@code actual}.
+   * @param notExpected fields in the {@code actual} that were not in {@code expected}.
+   * @return the created {@code ErrorMessageFactory}.
+   */
+  public static ErrorMessageFactory shouldOnlyHaveDeclaredFields(Class<?> actual, Collection<String> expected,
+                                                                    Collection<String> notFound,
+                                                                    Collection<String> notExpected) {
+    return create(actual, expected, notFound, notExpected, true);
+  }
+
+  private static ErrorMessageFactory create(Class<?> actual, Collection<String> expected, Collection<String> notFound,
+                                            Collection<String> notExpected, boolean declared) {
+    if (isNullOrEmpty(notExpected)) {
+      return new ShouldOnlyHaveFields(actual, expected, notFound, NOT_FOUND_ONLY, declared);
+    }
+
+    if (isNullOrEmpty(notFound)) {
+      return new ShouldOnlyHaveFields(actual, expected, notExpected, NOT_EXPECTED_ONLY, declared);
+    }
+
+    return new ShouldOnlyHaveFields(actual, expected, notFound, notExpected, declared);
+  }
+
+  private ShouldOnlyHaveFields(Class<?> actual, Collection<String> expected, Collection<String> notFound,
+                                  Collection<String> notExpected,
+                                  boolean declared) {
+    super("%n" +
+          "Expecting%n" +
+          "  <%s>%n" +
+          "to only have the following " + (declared ? "declared" : "public accessible") + " fields:%n" +
+          "  <%s>%n" +
+          "fields not found:%n" +
+          "  <%s>%n" +
+          "and fields not expected:%n" +
+          "  <%s>", actual, expected, notFound, notExpected);
+  }
+
+  private ShouldOnlyHaveFields(Class<?> actual, Collection<String> expected,
+                                  Collection<String> notFoundOrNotExpected,
+                                  ErrorType errorType, boolean declared) {
+    super("%n" +
+          "Expecting%n" +
+          "  <%s>%n" +
+          "to only have the following " + (declared ? "declared" : "public accessible") + " fields:%n" +
+          "  <%s>%n" +
+          (errorType == NOT_FOUND_ONLY ? "but could not find the following fields:%n"
+              : "but the following fields were unexpected:%n")
+          +
+          "  <%s>",
+          actual, expected, notFoundOrNotExpected);
+  }
+
+  enum ErrorType {
+    NOT_FOUND_ONLY, NOT_EXPECTED_ONLY
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Classes.java b/src/main/java/org/assertj/core/internal/Classes.java
index e8fe8398c..54ff7fabe 100644
--- a/src/main/java/org/assertj/core/internal/Classes.java
+++ b/src/main/java/org/assertj/core/internal/Classes.java
@@ -12,7 +12,10 @@
  */
 package org.assertj.core.internal;
 
-import static org.assertj.core.error.ClassModifierShouldBe.*;
+import static org.assertj.core.error.ClassModifierShouldBe.shouldBeFinal;
+import static org.assertj.core.error.ClassModifierShouldBe.shouldBeProtected;
+import static org.assertj.core.error.ClassModifierShouldBe.shouldBePublic;
+import static org.assertj.core.error.ClassModifierShouldBe.shouldNotBeFinal;
 import static org.assertj.core.error.ShouldBeAnnotation.shouldBeAnnotation;
 import static org.assertj.core.error.ShouldBeAnnotation.shouldNotBeAnnotation;
 import static org.assertj.core.error.ShouldBeAssignableFrom.shouldBeAssignableFrom;
@@ -23,21 +26,25 @@ import static org.assertj.core.error.ShouldHaveFields.shouldHaveDeclaredFields;
 import static org.assertj.core.error.ShouldHaveFields.shouldHaveFields;
 import static org.assertj.core.error.ShouldHaveMethods.shouldHaveMethods;
 import static org.assertj.core.error.ShouldHaveMethods.shouldNotHaveMethods;
-import static org.assertj.core.util.Sets.newLinkedHashSet;
+import static org.assertj.core.error.ShouldOnlyHaveFields.shouldOnlyHaveDeclaredFields;
+import static org.assertj.core.error.ShouldOnlyHaveFields.shouldOnlyHaveFields;
+import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.Preconditions.checkArgument;
 import static org.assertj.core.util.Preconditions.checkNotNull;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
 import static org.assertj.core.util.Sets.newTreeSet;
 
 import java.lang.annotation.Annotation;
 import java.lang.reflect.Field;
+import java.lang.reflect.Member;
 import java.lang.reflect.Method;
 import java.lang.reflect.Modifier;
+import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Map;
 import java.util.Set;
 import java.util.SortedSet;
-import java.util.LinkedHashMap;
-
 
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.Arrays;
@@ -61,6 +68,7 @@ public class Classes {
   }
 
   private Failures failures = Failures.instance();
+  private ComparisonStrategy comparisonStrategy = StandardComparisonStrategy.instance();
 
   /**
    * Verifies that the actual {@code Class} is assignable from all the {@code others} classes.
@@ -161,10 +169,11 @@ public class Classes {
    */
   public void assertIsPublic(AssertionInfo info, Class<?> actual) {
     assertNotNull(info, actual);
-    if(!Modifier.isPublic(actual.getModifiers())) {
+    if (!Modifier.isPublic(actual.getModifiers())) {
       throw failures.failure(info, shouldBePublic(actual));
     }
   }
+
   /**
    * Verifies that the actual {@code Class} is protected.
    *
@@ -175,7 +184,7 @@ public class Classes {
    */
   public void assertIsProtected(AssertionInfo info, Class<?> actual) {
     assertNotNull(info, actual);
-    if(!Modifier.isProtected(actual.getModifiers())) {
+    if (!Modifier.isProtected(actual.getModifiers())) {
       throw failures.failure(info, shouldBeProtected(actual));
     }
   }
@@ -228,11 +237,47 @@ public class Classes {
     assertNotNull(info, actual);
     Set<String> expectedFieldNames = newLinkedHashSet(fields);
     Set<String> missingFieldNames = newLinkedHashSet();
-    Set<String> actualFieldNames = fieldsToName(actual.getFields());
+    Set<String> actualFieldNames = fieldsToName(filterSyntheticMembers(actual.getFields()));
     if (noMissingElement(actualFieldNames, expectedFieldNames, missingFieldNames)) return;
     throw failures.failure(info, shouldHaveFields(actual, expectedFieldNames, missingFieldNames));
   }
 
+  /**
+   * Verifies that the actual {@code Class} has the exactly the {@code fields} and nothing more. <b>in any order</b>.
+   *
+   * @param info contains information about the assertion.
+   * @param actual the "actual" {@code Class}.
+   * @param expectedFields all the fields that are expected to be in the class.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if fields are not all the fields of the actual {@code Class}.
+   */
+  public void assertHasOnlyFields(AssertionInfo info, Class<?> actual, String... expectedFields) {
+    assertNotNull(info, actual);
+    Set<String> actualFieldNames = fieldsToName(filterSyntheticMembers(actual.getFields()));
+    List<String> notExpected = newArrayList(actualFieldNames);
+    List<String> notFound = newArrayList(expectedFields);
+
+    for (String field : expectedFields) {
+      if (comparisonStrategy.iterableContains(notExpected, field)) {
+        comparisonStrategy.iterablesRemoveFirst(notExpected, field);
+        comparisonStrategy.iterablesRemoveFirst(notFound, field);
+      }
+    }
+
+    if (notExpected.isEmpty() && notFound.isEmpty()) return;
+    throw failures.failure(info, shouldOnlyHaveFields(actual, newArrayList(expectedFields), notFound, notExpected));
+  }
+
+  /**
+   * Checks that the {@code expectedNames} are part of the {@code actualNames}. If an {@code expectedName} is not
+   * contained in the {@code actualNames}, the this method will return {@code true}. THe {@code missingNames} will
+   * contain all the {@code expectedNames} that are not part of the {@code actualNames}.
+   *
+   * @param actualNames the names that should be used to check
+   * @param expectedNames the names that should be contained in {@code actualNames}
+   * @param missingNames the names that were not part of {@code expectedNames}
+   * @return {@code true} if all {@code expectedNames} are part of the {@code actualNames}, {@code false} otherwise
+   */
   private static boolean noMissingElement(Set<String> actualNames, Set<String> expectedNames,
                                           Set<String> missingNames) {
     for (String field : expectedNames) {
@@ -254,12 +299,39 @@ public class Classes {
     assertNotNull(info, actual);
     Set<String> expectedFieldNames = newLinkedHashSet(fields);
     Set<String> missingFieldNames = newLinkedHashSet();
-    Set<String> actualFieldNames = fieldsToName(actual.getDeclaredFields());
+    Set<String> actualFieldNames = fieldsToName(filterSyntheticMembers(actual.getDeclaredFields()));
     if (noMissingElement(actualFieldNames, expectedFieldNames, missingFieldNames)) return;
     throw failures.failure(info, shouldHaveDeclaredFields(actual, expectedFieldNames, missingFieldNames));
   }
 
-  private static Set<String> fieldsToName(Field[] fields) {
+  /**
+   * Verifies that the actual {@code Class} has the exactly the {@code fields} and nothing more. <b>in any order</b>.
+   *
+   * @param info contains information about the assertion.
+   * @param actual the "actual" {@code Class}.
+   * @param expectedFields all the fields that are expected to be in the class.
+   * @throws AssertionError if {@code actual} is {@code null}.
+   * @throws AssertionError if fields are not all the fields of the actual {@code Class}.
+   */
+  public void assertHasOnlyDeclaredFields(AssertionInfo info, Class<?> actual, String... expectedFields) {
+    assertNotNull(info, actual);
+    Set<String> actualFieldNames = fieldsToName(filterSyntheticMembers(actual.getDeclaredFields()));
+    List<String> notExpected = newArrayList(actualFieldNames);
+    List<String> notFound = newArrayList(expectedFields);
+
+    for (String field : expectedFields) {
+      if (comparisonStrategy.iterableContains(notExpected, field)) {
+        comparisonStrategy.iterablesRemoveFirst(notExpected, field);
+        comparisonStrategy.iterablesRemoveFirst(notFound, field);
+      }
+    }
+
+    if (notExpected.isEmpty() && notFound.isEmpty()) return;
+    throw failures.failure(info,
+                           shouldOnlyHaveDeclaredFields(actual, newArrayList(expectedFields), notFound, notExpected));
+  }
+
+  private static Set<String> fieldsToName(Set<Field> fields) {
     Set<String> fieldsName = new LinkedHashSet<>();
     for (Field field : fields) {
       fieldsName.add(field.getName());
@@ -278,7 +350,7 @@ public class Classes {
    */
   public void assertHasMethods(AssertionInfo info, Class<?> actual, String... methods) {
     assertNotNull(info, actual);
-    doAssertHasMethods(info,actual, filterSyntheticMethods(getAllMethods(actual)), false, methods);
+    doAssertHasMethods(info, actual, filterSyntheticMembers(getAllMethods(actual)), false, methods);
   }
 
   /**
@@ -292,16 +364,18 @@ public class Classes {
    */
   public void assertHasDeclaredMethods(AssertionInfo info, Class<?> actual, String... methods) {
     assertNotNull(info, actual);
-    doAssertHasMethods(info, actual, filterSyntheticMethods(actual.getDeclaredMethods()), true, methods);
+    doAssertHasMethods(info, actual, filterSyntheticMembers(actual.getDeclaredMethods()), true, methods);
   }
 
-  private void doAssertHasMethods(AssertionInfo info, Class<?> actual, Method[] methods, boolean declared, String... expectedMethods) {
+  private void doAssertHasMethods(AssertionInfo info, Class<?> actual, Set<Method> methods, boolean declared,
+                                  String... expectedMethods) {
     SortedSet<String> expectedMethodNames = newTreeSet(expectedMethods);
     SortedSet<String> missingMethodNames = newTreeSet();
     SortedSet<String> actualMethodNames = methodsToName(methods);
 
-    if(isEmptyAndHasNoMethods(methods, expectedMethods)) {
-      throw failures.failure(info, shouldNotHaveMethods(actual, declared, getMethodsWithModifier(methods, Modifier.methodModifiers())));
+    if (isEmptyAndHasNoMethods(methods, expectedMethods)) {
+      throw failures.failure(info, shouldNotHaveMethods(actual, declared,
+                                                        getMethodsWithModifier(methods, Modifier.methodModifiers())));
     }
 
     if (!noMissingElement(actualMethodNames, expectedMethodNames, missingMethodNames)) {
@@ -337,25 +411,29 @@ public class Classes {
     doAssertHasPublicMethods(info, actual, actual.getDeclaredMethods(), true, methods);
   }
 
-  private void doAssertHasPublicMethods(AssertionInfo info, Class<?> actual, Method[] methods, boolean declared, String... expectedMethods) {
+  private void doAssertHasPublicMethods(AssertionInfo info, Class<?> actual, Method[] methods, boolean declared,
+                                        String... expectedMethods) {
     SortedSet<String> expectedMethodNames = newTreeSet(expectedMethods);
     SortedSet<String> missingMethodNames = newTreeSet();
-    Map<String,Integer> actualMethods = methodsToNameAndModifier(methods);
+    Map<String, Integer> actualMethods = methodsToNameAndModifier(methods);
 
-    if(isEmptyAndHasNoMethodsWithModifier(Modifier.PUBLIC, methods, expectedMethods)) {
-      throw failures.failure(info, shouldNotHaveMethods(actual, Modifier.toString(Modifier.PUBLIC), declared, getMethodsWithModifier(methods, Modifier.PUBLIC)));
+    if (isEmptyAndHasNoMethodsWithModifier(Modifier.PUBLIC, methods, expectedMethods)) {
+      throw failures.failure(info,
+                             shouldNotHaveMethods(actual, Modifier.toString(Modifier.PUBLIC), declared,
+                                                  getMethodsWithModifier(newLinkedHashSet(methods), Modifier.PUBLIC)));
     }
 
     if (!noMissingElement(actualMethods.keySet(), expectedMethodNames, missingMethodNames)) {
       throw failures.failure(info, shouldHaveMethods(actual, declared, expectedMethodNames, missingMethodNames));
     }
-    Map<String,String> nonMatchingModifiers = new LinkedHashMap<>();
-    if(!noNonMatchingModifier(expectedMethodNames, actualMethods, nonMatchingModifiers, Modifier.PUBLIC)) {
-      throw failures.failure(info, shouldHaveMethods(actual, declared, expectedMethodNames, Modifier.toString(Modifier.PUBLIC), nonMatchingModifiers));
+    Map<String, String> nonMatchingModifiers = new LinkedHashMap<>();
+    if (!noNonMatchingModifier(expectedMethodNames, actualMethods, nonMatchingModifiers, Modifier.PUBLIC)) {
+      throw failures.failure(info, shouldHaveMethods(actual, declared, expectedMethodNames,
+                                                     Modifier.toString(Modifier.PUBLIC), nonMatchingModifiers));
     }
   }
 
-  private static SortedSet<String> getMethodsWithModifier(Method[] methods, int modifier) {
+  private static SortedSet<String> getMethodsWithModifier(Set<Method> methods, int modifier) {
     SortedSet<String> methodsWithModifier = newTreeSet();
     for (Method method : methods) {
       if ((method.getModifiers() & modifier) != 0) {
@@ -365,20 +443,22 @@ public class Classes {
     return methodsWithModifier;
   }
 
-  private static boolean noNonMatchingModifier(Set<String> expectedMethodNames, Map<String, Integer> methodsModifier, Map<String, String> nonMatchingModifiers, int modifier) {
+  private static boolean noNonMatchingModifier(Set<String> expectedMethodNames, Map<String, Integer> methodsModifier,
+                                               Map<String, String> nonMatchingModifiers, int modifier) {
     for (String method : methodsModifier.keySet()) {
-      if(expectedMethodNames.contains(method) && (methodsModifier.get(method) & modifier) == 0) {
+      if (expectedMethodNames.contains(method) && (methodsModifier.get(method) & modifier) == 0) {
         nonMatchingModifiers.put(method, Modifier.toString(methodsModifier.get(method)));
       }
     }
     return nonMatchingModifiers.isEmpty();
   }
 
-  private static boolean isEmptyAndHasNoMethods(Method[] methods, String... expectedMethods) {
-    return expectedMethods.length == 0 && methods.length > 0;
+  private static boolean isEmptyAndHasNoMethods(Set<Method> methods, String... expectedMethods) {
+    return expectedMethods.length == 0 && !methods.isEmpty();
   }
 
-  private static boolean isEmptyAndHasNoMethodsWithModifier(int expectedModifier, Method[] methods, String... expectedMethods) {
+  private static boolean isEmptyAndHasNoMethodsWithModifier(int expectedModifier, Method[] methods,
+                                                            String... expectedMethods) {
     if (expectedMethods.length == 0) {
       for (Method method : methods) {
         if ((method.getModifiers() & expectedModifier) != 0) {
@@ -389,7 +469,7 @@ public class Classes {
     return false;
   }
 
-  private static SortedSet<String> methodsToName(Method[] methods) {
+  private static SortedSet<String> methodsToName(Set<Method> methods) {
     SortedSet<String> methodsName = newTreeSet();
     for (Method method : methods) {
       methodsName.add(method.getName());
@@ -397,8 +477,8 @@ public class Classes {
     return methodsName;
   }
 
-  private static Map<String,Integer> methodsToNameAndModifier(Method[] methods) {
-    Map<String,Integer> methodMap = new LinkedHashMap<>(methods.length);
+  private static Map<String, Integer> methodsToNameAndModifier(Method[] methods) {
+    Map<String, Integer> methodMap = new LinkedHashMap<>(methods.length);
     for (Method method : methods) {
       methodMap.put(method.getName(), method.getModifiers());
     }
@@ -416,14 +496,14 @@ public class Classes {
     return allMethods.toArray(new Method[allMethods.size()]);
   }
 
-  private static Method[] filterSyntheticMethods(Method[] methods) {
-    Set<Method> filteredMethods = newLinkedHashSet();
-    for (Method method : methods) {
-      if (!method.isSynthetic()) {
-        filteredMethods.add(method);
+  private static <M extends Member> Set<M> filterSyntheticMembers(M[] members) {
+    Set<M> filteredMembers = newLinkedHashSet();
+    for (M member : members) {
+      if (!member.isSynthetic()) {
+        filteredMembers.add(member);
       }
     }
-    return filteredMethods.toArray(new Method[filteredMethods.size()]);
+    return filteredMembers;
   }
 
   private static void assertNotNull(AssertionInfo info, Class<?> actual) {
diff --git a/src/test/java/org/assertj/core/api/classes/ClassAssert_hasExactlyDeclaredFields_Test.java b/src/test/java/org/assertj/core/api/classes/ClassAssert_hasExactlyDeclaredFields_Test.java
new file mode 100644
index 000000000..3d7f494ed
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/classes/ClassAssert_hasExactlyDeclaredFields_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2017 the original author or authors.
+ */
+package org.assertj.core.api.classes;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ClassAssert;
+import org.assertj.core.api.ClassAssertBaseTest;
+
+/**
+ * Tests for <code>{@link ClassAssert#hasOnlyDeclaredFields(String...)}</code>.
+ *
+ * @author Filip Hrisafov
+ */
+public class ClassAssert_hasExactlyDeclaredFields_Test extends ClassAssertBaseTest {
+
+  @Override
+  protected ClassAssert invoke_api_method() {
+    return assertions.hasOnlyDeclaredFields("field");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(classes).assertHasOnlyDeclaredFields(getInfo(assertions), getActual(assertions), "field");
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/classes/ClassAssert_hasExactlyFields_Test.java b/src/test/java/org/assertj/core/api/classes/ClassAssert_hasExactlyFields_Test.java
new file mode 100644
index 000000000..180e85ce1
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/classes/ClassAssert_hasExactlyFields_Test.java
@@ -0,0 +1,36 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2017 the original author or authors.
+ */
+package org.assertj.core.api.classes;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ClassAssert;
+import org.assertj.core.api.ClassAssertBaseTest;
+
+/**
+ * Tests for <code>{@link ClassAssert#hasFields(String...)}</code>.
+ *
+ * @author Filip Hrisafoc
+ */
+public class ClassAssert_hasExactlyFields_Test extends ClassAssertBaseTest {
+
+  @Override
+  protected ClassAssert invoke_api_method() {
+    return assertions.hasOnlyFields("field");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(classes).assertHasOnlyFields(getInfo(assertions), getActual(assertions), "field");
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldOnlyHaveFields_create_Test.java b/src/test/java/org/assertj/core/error/ShouldOnlyHaveFields_create_Test.java
new file mode 100644
index 000000000..0e3ce7598
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldOnlyHaveFields_create_Test.java
@@ -0,0 +1,140 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2017 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.ShouldOnlyHaveFields.shouldOnlyHaveDeclaredFields;
+import static org.assertj.core.error.ShouldOnlyHaveFields.shouldOnlyHaveFields;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+
+import java.util.LinkedHashSet;
+
+import org.assertj.core.description.Description;
+import org.assertj.core.description.TextDescription;
+import org.assertj.core.presentation.Representation;
+import org.assertj.core.presentation.StandardRepresentation;
+import org.assertj.core.test.Player;
+import org.assertj.core.util.Sets;
+import org.junit.Test;
+
+/**
+ * Tests for
+ * <code>{@link ShouldOnlyHaveFields#create(Description, Representation)}</code>
+ *
+ * @author Filip Hrisafov
+ */
+public class ShouldOnlyHaveFields_create_Test {
+
+  private static final LinkedHashSet<String> EMPTY_STRING_SET = Sets.<String> newLinkedHashSet();
+
+  @Test
+  public void should_create_error_message_for_fields() {
+    ErrorMessageFactory factory = shouldOnlyHaveFields(Player.class,
+                                                          newLinkedHashSet("name", "team"),
+                                                          newLinkedHashSet("nickname"),
+                                                          newLinkedHashSet("address"));
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(format("[Test] %n" +
+                                         "Expecting%n" +
+                                         "  <org.assertj.core.test.Player>%n" +
+                                         "to only have the following public accessible fields:%n" +
+                                         "  <[\"name\", \"team\"]>%n" +
+                                         "fields not found:%n" +
+                                         "  <[\"nickname\"]>%n" +
+                                         "and fields not expected:%n" +
+                                         "  <[\"address\"]>"));
+  }
+
+  @Test
+  public void should_not_display_unexpected_fields_when_there_are_none_for_fields() {
+    ErrorMessageFactory factory = shouldOnlyHaveFields(Player.class,
+                                                          newLinkedHashSet("name", "team"),
+                                                          newLinkedHashSet("nickname"),
+                                                          EMPTY_STRING_SET);
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(format("[Test] %n" +
+                                         "Expecting%n" +
+                                         "  <org.assertj.core.test.Player>%n" +
+                                         "to only have the following public accessible fields:%n" +
+                                         "  <[\"name\", \"team\"]>%n" +
+                                         "but could not find the following fields:%n" +
+                                         "  <[\"nickname\"]>"));
+  }
+
+  @Test
+  public void should_not_display_fields_not_found_when_there_are_none_for_fields() {
+    ErrorMessageFactory factory = shouldOnlyHaveFields(Player.class,
+                                                          newLinkedHashSet("name", "team"),
+                                                          EMPTY_STRING_SET,
+                                                          newLinkedHashSet("address"));
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(format("[Test] %n" +
+                                         "Expecting%n" +
+                                         "  <org.assertj.core.test.Player>%n" +
+                                         "to only have the following public accessible fields:%n" +
+                                         "  <[\"name\", \"team\"]>%n" +
+                                         "but the following fields were unexpected:%n" +
+                                         "  <[\"address\"]>"));
+  }
+
+  @Test
+  public void should_create_error_message_for_declared_fields() {
+    ErrorMessageFactory factory = shouldOnlyHaveDeclaredFields(Player.class,
+                                                                  newLinkedHashSet("name", "team"),
+                                                                  newLinkedHashSet("nickname"),
+                                                                  newLinkedHashSet("address"));
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(format("[Test] %n" +
+                                         "Expecting%n" +
+                                         "  <org.assertj.core.test.Player>%n" +
+                                         "to only have the following declared fields:%n" +
+                                         "  <[\"name\", \"team\"]>%n" +
+                                         "fields not found:%n" +
+                                         "  <[\"nickname\"]>%n" +
+                                         "and fields not expected:%n" +
+                                         "  <[\"address\"]>"));
+  }
+
+  @Test
+  public void should_not_display_unexpected_fields_when_there_are_none_for_declared_fields() {
+    ErrorMessageFactory factory = shouldOnlyHaveDeclaredFields(Player.class,
+                                                                  newLinkedHashSet("name", "team"),
+                                                                  newLinkedHashSet("nickname"),
+                                                                  EMPTY_STRING_SET);
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(format("[Test] %n" +
+                                         "Expecting%n" +
+                                         "  <org.assertj.core.test.Player>%n" +
+                                         "to only have the following declared fields:%n" +
+                                         "  <[\"name\", \"team\"]>%n" +
+                                         "but could not find the following fields:%n" +
+                                         "  <[\"nickname\"]>"));
+  }
+
+  @Test
+  public void should_not_display_fields_not_found_when_there_are_none_for_declared_fields() {
+    ErrorMessageFactory factory = shouldOnlyHaveDeclaredFields(Player.class,
+                                                                  newLinkedHashSet("name", "team"),
+                                                                  EMPTY_STRING_SET,
+                                                                  newLinkedHashSet("address"));
+    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+    assertThat(message).isEqualTo(String.format("[Test] %n" +
+                                                "Expecting%n" +
+                                                "  <org.assertj.core.test.Player>%n" +
+                                                "to only have the following declared fields:%n" +
+                                                "  <[\"name\", \"team\"]>%n" +
+                                                "but the following fields were unexpected:%n" +
+                                                "  <[\"address\"]>"));
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/ClassesBaseTest.java b/src/test/java/org/assertj/core/internal/ClassesBaseTest.java
index 5feedad80..8b7031cb6 100644
--- a/src/test/java/org/assertj/core/internal/ClassesBaseTest.java
+++ b/src/test/java/org/assertj/core/internal/ClassesBaseTest.java
@@ -48,6 +48,7 @@ public abstract class ClassesBaseTest {
   @MyAnnotation
   protected static class AnnotatedClass {
     public String publicField;
+    public String public2Field;
     protected String protectedField;
     @SuppressWarnings("unused")
     private String privateField;
diff --git a/src/test/java/org/assertj/core/internal/classes/Classes_assertHasOnlyDeclaredFields_Test.java b/src/test/java/org/assertj/core/internal/classes/Classes_assertHasOnlyDeclaredFields_Test.java
new file mode 100644
index 000000000..d5637f732
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/classes/Classes_assertHasOnlyDeclaredFields_Test.java
@@ -0,0 +1,103 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2017 the original author or authors.
+ */
+package org.assertj.core.internal.classes;
+
+import static org.assertj.core.error.ShouldOnlyHaveFields.shouldOnlyHaveDeclaredFields;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+
+import java.util.LinkedHashSet;
+
+import org.assertj.core.internal.ClassesBaseTest;
+import org.assertj.core.util.Sets;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests for
+ * <code
+ * >{@link org.assertj.core.internal.Classes#assertHasOnlyDeclaredFields(org.assertj.core.api.AssertionInfo, Class, String...)}</code>
+ * .
+ *
+ * @author Filip Hrisafov
+ */
+public class Classes_assertHasOnlyDeclaredFields_Test extends ClassesBaseTest {
+
+  private static final LinkedHashSet<String> EMPTY_STRING_SET = Sets.<String> newLinkedHashSet();
+
+  @Before
+  public void setupActual() {
+    actual = AnnotatedClass.class;
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    actual = null;
+    thrown.expectAssertionError(actualIsNull());
+    classes.assertHasOnlyDeclaredFields(someInfo(), actual);
+  }
+
+  @Test
+  public void should_fail_if_no_fields_are_expected() {
+    thrown.expectAssertionError(shouldOnlyHaveDeclaredFields(actual,
+                                                                EMPTY_STRING_SET,
+                                                                EMPTY_STRING_SET,
+                                                                newLinkedHashSet("publicField", "public2Field",
+                                                                                 "protectedField", "privateField")));
+    classes.assertHasOnlyDeclaredFields(someInfo(), actual);
+  }
+
+  @Test
+  public void should_fail_if_not_all_fields_are_expected() {
+    thrown.expectAssertionError(shouldOnlyHaveDeclaredFields(actual,
+                                                                newLinkedHashSet("publicField", "protectedField",
+                                                                                 "privateField"),
+                                                                EMPTY_STRING_SET,
+                                                                newLinkedHashSet("public2Field")));
+    classes.assertHasOnlyDeclaredFields(someInfo(), actual, "publicField", "protectedField", "privateField");
+  }
+
+  @Test
+  public void should_fail_if_fields_are_missing() {
+    String[] expected = array("missingField", "publicField", "public2Field", "protectedField", "privateField");
+    thrown.expectAssertionError(shouldOnlyHaveDeclaredFields(actual,
+                                                                newLinkedHashSet(expected),
+                                                                newLinkedHashSet("missingField"),
+                                                                EMPTY_STRING_SET));
+    classes.assertHasOnlyDeclaredFields(someInfo(), actual, expected);
+  }
+
+  @Test
+  public void should_pass_if_all_fields_are_expected() {
+    classes.assertHasOnlyDeclaredFields(someInfo(), actual, "publicField", "public2Field", "protectedField",
+                                           "privateField");
+  }
+
+  @Test
+  public void should_pass_if_public_all_fields_are_expected_whatever_the_order_is() {
+    classes.assertHasOnlyDeclaredFields(someInfo(), actual, "protectedField", "privateField", "public2Field",
+                                           "publicField");
+  }
+
+  @Test()
+  public void should_fail_if_fields_are_not_expected_and_not_found() {
+    String[] expected = array("publicField", "public2Field", "missing", "privateField");
+    thrown.expectAssertionError(shouldOnlyHaveDeclaredFields(actual,
+                                                                newLinkedHashSet(expected),
+                                                                newLinkedHashSet("missing"),
+                                                                newLinkedHashSet("protectedField")));
+    classes.assertHasOnlyDeclaredFields(someInfo(), actual, expected);
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/classes/Classes_assertHasOnlyFields_Test.java b/src/test/java/org/assertj/core/internal/classes/Classes_assertHasOnlyFields_Test.java
new file mode 100644
index 000000000..c79c390cb
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/classes/Classes_assertHasOnlyFields_Test.java
@@ -0,0 +1,108 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2017 the original author or authors.
+ */
+package org.assertj.core.internal.classes;
+
+import static org.assertj.core.error.ShouldOnlyHaveFields.shouldOnlyHaveFields;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+
+import java.util.LinkedHashSet;
+
+import org.assertj.core.internal.ClassesBaseTest;
+import org.assertj.core.util.Sets;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Tests for
+ * <code
+ * >{@link org.assertj.core.internal.Classes#assertHasOnlyFields(org.assertj.core.api.AssertionInfo, Class, String...)}</code>
+ * .
+ *
+ * @author Filip Hrisafov
+ */
+public class Classes_assertHasOnlyFields_Test extends ClassesBaseTest {
+
+  private static final LinkedHashSet<String> EMPTY_STRING_SET = Sets.<String> newLinkedHashSet();
+
+  @Before
+  public void setupActual() {
+    actual = AnnotatedClass.class;
+  }
+
+  @Test
+  public void should_pass_if_public_all_fields_are_expected() {
+    classes.assertHasOnlyFields(someInfo(), actual, "publicField", "public2Field");
+  }
+
+  @Test
+  public void should_pass_if_public_all_fields_are_reversed_expected() {
+    classes.assertHasOnlyFields(someInfo(), actual, "public2Field", "publicField");
+  }
+
+  @Test
+  public void should_fail_if_actual_is_null() {
+    actual = null;
+    thrown.expectAssertionError(actualIsNull());
+    classes.assertHasOnlyFields(someInfo(), actual);
+  }
+
+  @Test
+  public void should_fail_if_no_fields_are_expected() {
+    thrown.expectAssertionError(shouldOnlyHaveFields(actual,
+                                                        EMPTY_STRING_SET,
+                                                        EMPTY_STRING_SET,
+                                                        newLinkedHashSet("publicField", "public2Field")));
+    classes.assertHasOnlyFields(someInfo(), actual);
+  }
+
+  @Test
+  public void should_fail_if_some_public_fields_are_not_present_in_the_expected_fields() {
+    thrown.expectAssertionError(shouldOnlyHaveFields(actual,
+                                                        newLinkedHashSet("publicField"),
+                                                        EMPTY_STRING_SET,
+                                                        newLinkedHashSet("public2Field")));
+    classes.assertHasOnlyFields(someInfo(), actual, "publicField");
+  }
+
+  @Test
+  public void should_fail_if_some_public_fields_are_missing() {
+    String[] expected = new String[] { "missingField", "publicField", "public2Field" };
+    thrown.expectAssertionError(shouldOnlyHaveFields(actual,
+                                                        newLinkedHashSet(expected),
+                                                        newLinkedHashSet("missingField"),
+                                                        EMPTY_STRING_SET));
+    classes.assertHasOnlyFields(someInfo(), actual, expected);
+  }
+
+  @Test
+  public void should_fail_if_fields_are_protected_or_private() {
+    String[] expected = new String[] { "publicField", "public2Field", "protectedField", "privateField" };
+    thrown.expectAssertionError(shouldOnlyHaveFields(actual,
+                                                        newLinkedHashSet(expected),
+                                                        newLinkedHashSet("protectedField", "privateField"),
+                                                        EMPTY_STRING_SET));
+    classes.assertHasOnlyFields(someInfo(), actual, expected);
+  }
+
+  @Test
+  public void should_fail_if_fields_are_not_found_and_not_expected() {
+    String[] expected = new String[] { "publicField", "protectedField", "privateField" };
+    thrown.expectAssertionError(shouldOnlyHaveFields(actual,
+                                                        newLinkedHashSet(expected),
+                                                        newLinkedHashSet("protectedField", "privateField"),
+                                                        newLinkedHashSet("public2Field")));
+    classes.assertHasOnlyFields(someInfo(), actual, expected);
+  }
+}
