diff --git a/src/main/java/org/assertj/core/api/InstanceOfAssertFactory.java b/src/main/java/org/assertj/core/api/InstanceOfAssertFactory.java
index dcbda954f..83dec553c 100644
--- a/src/main/java/org/assertj/core/api/InstanceOfAssertFactory.java
+++ b/src/main/java/org/assertj/core/api/InstanceOfAssertFactory.java
@@ -50,4 +50,8 @@ public class InstanceOfAssertFactory<T, ASSERT extends AbstractAssert<?, ?>> imp
     return assertFactory.createAssert(type.cast(value));
   }
 
+  @Override
+  public String toString() {
+    return type.getSimpleName() + " InstanceOfAssertFactory";
+  }
 }
diff --git a/src/main/java/org/assertj/core/api/ProxifyMethodChangingTheObjectUnderTest.java b/src/main/java/org/assertj/core/api/ProxifyMethodChangingTheObjectUnderTest.java
index 187e2ceb7..1351818a6 100644
--- a/src/main/java/org/assertj/core/api/ProxifyMethodChangingTheObjectUnderTest.java
+++ b/src/main/java/org/assertj/core/api/ProxifyMethodChangingTheObjectUnderTest.java
@@ -14,13 +14,44 @@ package org.assertj.core.api;
 
 import static org.assertj.core.util.Preconditions.checkState;
 
+import java.io.File;
+import java.io.InputStream;
 import java.lang.reflect.Array;
 import java.lang.reflect.ParameterizedType;
 import java.lang.reflect.Type;
 import java.lang.reflect.TypeVariable;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.net.URI;
+import java.net.URL;
+import java.nio.file.Path;
+import java.time.Instant;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.OffsetDateTime;
+import java.time.OffsetTime;
+import java.time.ZonedDateTime;
+import java.util.Date;
+import java.util.Iterator;
 import java.util.Map;
 import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
 import java.util.concurrent.Callable;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.concurrent.atomic.AtomicLongFieldUpdater;
+import java.util.concurrent.atomic.AtomicMarkableReference;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
+import java.util.concurrent.atomic.AtomicStampedReference;
+import java.util.function.DoublePredicate;
+import java.util.function.IntPredicate;
+import java.util.function.LongPredicate;
+import java.util.function.Predicate;
 
 import net.bytebuddy.implementation.bind.annotation.FieldValue;
 import net.bytebuddy.implementation.bind.annotation.RuntimeType;
@@ -41,45 +72,95 @@ public class ProxifyMethodChangingTheObjectUnderTest {
   public static AbstractAssert<?, ?> intercept(@FieldValue(FIELD_NAME) ProxifyMethodChangingTheObjectUnderTest dispatcher,
                                                @SuperCall Callable<AbstractAssert<?, ?>> assertionMethod,
                                                @This AbstractAssert<?, ?> currentAssertInstance) throws Exception {
-    Object result = assertionMethod.call();
+    AbstractAssert<?, ?> result = assertionMethod.call();
     return dispatcher.createAssertProxy(result).withAssertionState(currentAssertInstance);
   }
 
-  // can't return AbstractAssert<?, ?> otherwise withAssertionState(currentAssertInstance) does not compile.
   @SuppressWarnings({ "unchecked", "rawtypes" })
-  private AbstractAssert createAssertProxy(Object currentActual) {
-    if (currentActual instanceof IterableSizeAssert) return createIterableSizeAssertProxy(currentActual);
-    if (currentActual instanceof MapSizeAssert) return createMapSizeAssertProxy(currentActual);
-    if (currentActual instanceof RecursiveComparisonAssert)
-      return createRecursiveComparisonAssertProxy((RecursiveComparisonAssert) currentActual);
-    return (AbstractAssert) proxies.createSoftAssertionProxy(currentActual.getClass(), actualClass(currentActual),
-                                                             actual(currentActual));
+  private AbstractAssert<?, ?> createAssertProxy(AbstractAssert<?, ?> currentAssert) {
+    if (currentAssert instanceof IterableSizeAssert) return createIterableSizeAssertProxy(currentAssert);
+    if (currentAssert instanceof MapSizeAssert) return createMapSizeAssertProxy(currentAssert);
+    if (currentAssert instanceof RecursiveComparisonAssert)
+      return createRecursiveComparisonAssertProxy((RecursiveComparisonAssert) currentAssert);
+    return (AbstractAssert) proxies.createSoftAssertionProxy(currentAssert.getClass(), actualClass(currentAssert),
+                                                             actual(currentAssert));
   }
 
   private RecursiveComparisonAssert<?> createRecursiveComparisonAssertProxy(RecursiveComparisonAssert<?> currentAssert) {
     return proxies.createRecursiveComparisonAssertProxy(currentAssert);
   }
 
-  private MapSizeAssert<?, ?> createMapSizeAssertProxy(Object currentActual) {
-    MapSizeAssert<?, ?> mapSizeAssert = (MapSizeAssert<?, ?>) currentActual;
+  private MapSizeAssert<?, ?> createMapSizeAssertProxy(Object currentAssert) {
+    MapSizeAssert<?, ?> mapSizeAssert = (MapSizeAssert<?, ?>) currentAssert;
     // can't use the usual way of building soft proxy since MapSizeAssert takes 2 parameters
     return proxies.createMapSizeAssertProxy(mapSizeAssert);
   }
 
-  private IterableSizeAssert<?> createIterableSizeAssertProxy(Object currentActual) {
-    IterableSizeAssert<?> iterableSizeAssert = (IterableSizeAssert<?>) currentActual;
+  private IterableSizeAssert<?> createIterableSizeAssertProxy(Object currentAssert) {
+    IterableSizeAssert<?> iterableSizeAssert = (IterableSizeAssert<?>) currentAssert;
     // can't use the usual way of building soft proxy since IterableSizeAssert takes 2 parameters
     return proxies.createIterableSizeAssertProxy(iterableSizeAssert);
   }
 
   @SuppressWarnings("rawtypes")
-  private static Class actualClass(Object result) {
-    if (result instanceof AbstractObjectArrayAssert) return Array.newInstance(Object.class, 0).getClass();
-    if (result instanceof OptionalAssert) return Optional.class;
-    if (result instanceof ObjectAssert || result instanceof ProxyableObjectAssert) return Object.class;
-    if (result instanceof MapAssert) return Map.class;
-    if (result instanceof StringAssert) return String.class;
-    if (result instanceof RecursiveComparisonAssert) return Object.class;
+  private static Class actualClass(Object currentAssert) {
+    if (currentAssert instanceof AbstractObjectArrayAssert) return Array.newInstance(Object.class, 0).getClass();
+    if (currentAssert instanceof StringAssert) return String.class;
+    if (currentAssert instanceof RecursiveComparisonAssert) return Object.class;
+    if (currentAssert instanceof AtomicIntegerFieldUpdaterAssert) return AtomicIntegerFieldUpdater.class;
+    if (currentAssert instanceof AtomicLongFieldUpdaterAssert) return AtomicLongFieldUpdater.class;
+    if (currentAssert instanceof AtomicMarkableReferenceAssert) return AtomicMarkableReference.class;
+    if (currentAssert instanceof AtomicReferenceAssert) return AtomicReference.class;
+    if (currentAssert instanceof AtomicReferenceArrayAssert) return AtomicReferenceArray.class;
+    if (currentAssert instanceof AtomicReferenceFieldUpdaterAssert) return AtomicReferenceFieldUpdater.class;
+    if (currentAssert instanceof AtomicStampedReferenceAssert) return AtomicStampedReference.class;
+    if (currentAssert instanceof BigDecimalAssert) return BigDecimal.class;
+    if (currentAssert instanceof BigIntegerAssert) return BigInteger.class;
+    if (currentAssert instanceof BooleanAssert) return Boolean.class;
+    if (currentAssert instanceof BooleanArrayAssert) return boolean[].class;
+    if (currentAssert instanceof ByteAssert) return Byte.class;
+    if (currentAssert instanceof ByteArrayAssert) return byte[].class;
+    if (currentAssert instanceof CharArrayAssert) return char[].class;
+    if (currentAssert instanceof CharSequenceAssert) return CharSequence.class;
+    if (currentAssert instanceof CharacterAssert) return Character.class;
+    if (currentAssert instanceof ClassAssert) return Class.class;
+    if (currentAssert instanceof CompletableFutureAssert) return CompletionStage.class;
+    if (currentAssert instanceof DateAssert) return Date.class;
+    if (currentAssert instanceof DoubleAssert) return Double.class;
+    if (currentAssert instanceof DoubleArrayAssert) return double[].class;
+    if (currentAssert instanceof DoublePredicateAssert) return DoublePredicate.class;
+    if (currentAssert instanceof FileAssert) return File.class;
+    if (currentAssert instanceof FloatAssert) return Float.class;
+    if (currentAssert instanceof FloatArrayAssert) return float[].class;
+    if (currentAssert instanceof FutureAssert) return Future.class; // must be after CompletionStage / CompletableFuture
+    if (currentAssert instanceof InputStreamAssert) return InputStream.class;
+    if (currentAssert instanceof InstantAssert) return Instant.class;
+    if (currentAssert instanceof IntArrayAssert) return int[].class;
+    if (currentAssert instanceof IntPredicateAssert) return IntPredicate.class;
+    if (currentAssert instanceof IntegerAssert) return Integer.class;
+    if (currentAssert instanceof IteratorAssert) return Iterator.class;
+    if (currentAssert instanceof LocalDateAssert) return LocalDate.class;
+    if (currentAssert instanceof LocalDateTimeAssert) return LocalDateTime.class;
+    if (currentAssert instanceof LongAssert) return Long.class;
+    if (currentAssert instanceof LongArrayAssert) return long[].class;
+    if (currentAssert instanceof LongPredicateAssert) return LongPredicate.class;
+    if (currentAssert instanceof MapAssert) return Map.class;
+    if (currentAssert instanceof ObjectAssert || currentAssert instanceof ProxyableObjectAssert) return Object.class;
+    if (currentAssert instanceof OffsetDateTimeAssert) return OffsetDateTime.class;
+    if (currentAssert instanceof OffsetTimeAssert) return OffsetTime.class;
+    if (currentAssert instanceof OptionalAssert) return Optional.class;
+    if (currentAssert instanceof OptionalDoubleAssert) return OptionalDouble.class;
+    if (currentAssert instanceof OptionalIntAssert) return OptionalInt.class;
+    if (currentAssert instanceof OptionalLongAssert) return OptionalLong.class;
+    if (currentAssert instanceof PathAssert) return Path.class;
+    if (currentAssert instanceof PredicateAssert) return Predicate.class;
+    if (currentAssert instanceof ShortAssert) return Short.class;
+    if (currentAssert instanceof ShortArrayAssert) return short[].class;
+    if (currentAssert instanceof ThrowableAssert) return Throwable.class;
+    if (currentAssert instanceof ThrowableAssertAlternative) return Throwable.class;
+    if (currentAssert instanceof UriAssert) return URI.class;
+    if (currentAssert instanceof UrlAssert) return URL.class;
+    if (currentAssert instanceof ZonedDateTimeAssert) return ZonedDateTime.class;
     // Trying to create a proxy will only match exact constructor argument types.
     // To initialize one for ListAssert for example we can't use an ArrayList, we have to use a List.
     // So we can't just return actual.getClass() as we could read a concrete class whereas
@@ -87,7 +168,7 @@ public class ProxifyMethodChangingTheObjectUnderTest {
     // Instead we can read generic types from *Assert definition.
     // Inspecting: class ListAssert<T> extends AbstractListAssert<ListAssert<T>, List<? extends T>, T>
     // will return the generic defined by the super class AbstractListAssert at index 1, which is a List<? extends T>
-    Type actualType = ((ParameterizedType) result.getClass().getGenericSuperclass()).getActualTypeArguments()[1];
+    Type actualType = ((ParameterizedType) currentAssert.getClass().getGenericSuperclass()).getActualTypeArguments()[1];
     if (actualType instanceof ParameterizedType) return (Class<?>) ((ParameterizedType) actualType).getRawType();
     if (actualType instanceof TypeVariable) return (Class<?>) ((TypeVariable) actualType).getGenericDeclaration();
     return (Class<?>) actualType;
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index 2d13033c4..e8125a64b 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -1988,21 +1988,6 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
                                       .hasMessageContaining("MAN");
   }
 
-  @Test
-  public void soft_assertions_should_work_with_asInstanceOf() {
-    // GIVEN
-    Object value = "abc";
-    // WHEN
-    softly.assertThat(value)
-          .as("startsWith")
-          .asInstanceOf(STRING)
-          .startsWith("b");
-    // THEN
-    List<Throwable> errorsCollected = softly.errorsCollected();
-    assertThat(errorsCollected).hasSize(1);
-    assertThat(errorsCollected.get(0)).hasMessageContaining("[startsWith]");
-  }
-
   @Nested
   class ExtractingFromEntries {
 
diff --git a/src/test/java/org/assertj/core/api/SoftAssertions_combined_with_asInstanceOf_Test.java b/src/test/java/org/assertj/core/api/SoftAssertions_combined_with_asInstanceOf_Test.java
new file mode 100644
index 000000000..4b1db9df8
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/SoftAssertions_combined_with_asInstanceOf_Test.java
@@ -0,0 +1,252 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.InstanceOfAssertFactories.ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_BOOLEAN;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_INTEGER;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_INTEGER_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_INTEGER_FIELD_UPDATER;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_LONG_FIELD_UPDATER;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_MARKABLE_REFERENCE;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_REFERENCE;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_REFERENCE_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_REFERENCE_FIELD_UPDATER;
+import static org.assertj.core.api.InstanceOfAssertFactories.ATOMIC_STAMPED_REFERENCE;
+import static org.assertj.core.api.InstanceOfAssertFactories.BIG_DECIMAL;
+import static org.assertj.core.api.InstanceOfAssertFactories.BIG_INTEGER;
+import static org.assertj.core.api.InstanceOfAssertFactories.BOOLEAN;
+import static org.assertj.core.api.InstanceOfAssertFactories.BOOLEAN_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.BYTE;
+import static org.assertj.core.api.InstanceOfAssertFactories.BYTE_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.CHARACTER;
+import static org.assertj.core.api.InstanceOfAssertFactories.CHAR_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.CHAR_SEQUENCE;
+import static org.assertj.core.api.InstanceOfAssertFactories.CLASS;
+import static org.assertj.core.api.InstanceOfAssertFactories.COMPLETABLE_FUTURE;
+import static org.assertj.core.api.InstanceOfAssertFactories.COMPLETION_STAGE;
+import static org.assertj.core.api.InstanceOfAssertFactories.DATE;
+import static org.assertj.core.api.InstanceOfAssertFactories.DOUBLE;
+import static org.assertj.core.api.InstanceOfAssertFactories.DOUBLE_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.DOUBLE_PREDICATE;
+import static org.assertj.core.api.InstanceOfAssertFactories.DOUBLE_STREAM;
+import static org.assertj.core.api.InstanceOfAssertFactories.FILE;
+import static org.assertj.core.api.InstanceOfAssertFactories.FLOAT;
+import static org.assertj.core.api.InstanceOfAssertFactories.FLOAT_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.FUTURE;
+import static org.assertj.core.api.InstanceOfAssertFactories.INPUT_STREAM;
+import static org.assertj.core.api.InstanceOfAssertFactories.INSTANT;
+import static org.assertj.core.api.InstanceOfAssertFactories.INTEGER;
+import static org.assertj.core.api.InstanceOfAssertFactories.INT_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.INT_PREDICATE;
+import static org.assertj.core.api.InstanceOfAssertFactories.INT_STREAM;
+import static org.assertj.core.api.InstanceOfAssertFactories.ITERABLE;
+import static org.assertj.core.api.InstanceOfAssertFactories.ITERATOR;
+import static org.assertj.core.api.InstanceOfAssertFactories.LIST;
+import static org.assertj.core.api.InstanceOfAssertFactories.LOCAL_DATE;
+import static org.assertj.core.api.InstanceOfAssertFactories.LOCAL_DATE_TIME;
+import static org.assertj.core.api.InstanceOfAssertFactories.LONG;
+import static org.assertj.core.api.InstanceOfAssertFactories.LONG_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.LONG_PREDICATE;
+import static org.assertj.core.api.InstanceOfAssertFactories.LONG_STREAM;
+import static org.assertj.core.api.InstanceOfAssertFactories.MAP;
+import static org.assertj.core.api.InstanceOfAssertFactories.OFFSET_DATE_TIME;
+import static org.assertj.core.api.InstanceOfAssertFactories.OFFSET_TIME;
+import static org.assertj.core.api.InstanceOfAssertFactories.OPTIONAL;
+import static org.assertj.core.api.InstanceOfAssertFactories.OPTIONAL_DOUBLE;
+import static org.assertj.core.api.InstanceOfAssertFactories.OPTIONAL_INT;
+import static org.assertj.core.api.InstanceOfAssertFactories.OPTIONAL_LONG;
+import static org.assertj.core.api.InstanceOfAssertFactories.PATH;
+import static org.assertj.core.api.InstanceOfAssertFactories.PREDICATE;
+import static org.assertj.core.api.InstanceOfAssertFactories.SHORT;
+import static org.assertj.core.api.InstanceOfAssertFactories.SHORT_ARRAY;
+import static org.assertj.core.api.InstanceOfAssertFactories.STREAM;
+import static org.assertj.core.api.InstanceOfAssertFactories.STRING;
+import static org.assertj.core.api.InstanceOfAssertFactories.STRING_BUFFER;
+import static org.assertj.core.api.InstanceOfAssertFactories.STRING_BUILDER;
+import static org.assertj.core.api.InstanceOfAssertFactories.THROWABLE;
+import static org.assertj.core.api.InstanceOfAssertFactories.URI_TYPE;
+import static org.assertj.core.api.InstanceOfAssertFactories.URL_TYPE;
+import static org.assertj.core.util.Lists.list;
+import static org.assertj.core.util.Maps.newHashMap;
+import static org.assertj.core.util.Sets.newHashSet;
+
+import java.io.ByteArrayInputStream;
+import java.io.File;
+import java.math.BigDecimal;
+import java.math.BigInteger;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.nio.file.Paths;
+import java.time.Instant;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.OffsetDateTime;
+import java.time.OffsetTime;
+import java.time.ZonedDateTime;
+import java.util.Date;
+import java.util.List;
+import java.util.Optional;
+import java.util.OptionalDouble;
+import java.util.OptionalInt;
+import java.util.OptionalLong;
+import java.util.concurrent.CompletionStage;
+import java.util.concurrent.Future;
+import java.util.concurrent.atomic.AtomicBoolean;
+import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.atomic.AtomicIntegerArray;
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+import java.util.concurrent.atomic.AtomicLong;
+import java.util.concurrent.atomic.AtomicLongArray;
+import java.util.concurrent.atomic.AtomicLongFieldUpdater;
+import java.util.concurrent.atomic.AtomicMarkableReference;
+import java.util.concurrent.atomic.AtomicReference;
+import java.util.concurrent.atomic.AtomicReferenceArray;
+import java.util.concurrent.atomic.AtomicStampedReference;
+import java.util.function.DoublePredicate;
+import java.util.function.IntPredicate;
+import java.util.function.LongPredicate;
+import java.util.function.Predicate;
+import java.util.stream.DoubleStream;
+import java.util.stream.IntStream;
+import java.util.stream.LongStream;
+import java.util.stream.Stream;
+
+import org.assertj.core.data.TolkienCharacter;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayNameGeneration;
+import org.junit.jupiter.api.DisplayNameGenerator;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
+
+@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
+public class SoftAssertions_combined_with_asInstanceOf_Test extends BaseAssertionsTest {
+
+  private SoftAssertions softly;
+
+  @BeforeEach
+  public void setup() {
+    Assertions.setRemoveAssertJRelatedElementsFromStackTrace(false);
+    softly = new SoftAssertions();
+  }
+
+  @Test
+  public void soft_assertions_should_work() {
+    // GIVEN
+    Object value = "abc";
+    // WHEN
+    softly.assertThat(value)
+          .as("startsWith")
+          .asInstanceOf(STRING)
+          .startsWith("b");
+    // THEN
+    List<Throwable> errorsCollected = softly.errorsCollected();
+    assertThat(errorsCollected).hasSize(1);
+    assertThat(errorsCollected.get(0)).hasMessageContaining("[startsWith]");
+  }
+
+  @ParameterizedTest(name = "with {1}")
+  @MethodSource("should_work_with_any_InstanceOfFactory_source")
+  public void should_work_with_any_InstanceOfFactory(Object actual, InstanceOfAssertFactory<?, ?> instanceOfAssertFactory) {
+    softly.assertThat(actual).asInstanceOf(instanceOfAssertFactory);
+  }
+
+  public static Stream<Arguments> should_work_with_any_InstanceOfFactory_source() throws MalformedURLException {
+    Future<String> future = completedFuture("foo");
+    CompletionStage<String> completionStage = completedFuture("foo");
+    CharSequence charSequence = new StringBuilder();
+    return Stream.of(Arguments.of(new Object[0], ARRAY),
+                     Arguments.of(new AtomicBoolean(true), ATOMIC_BOOLEAN),
+                     Arguments.of(new AtomicInteger(1), ATOMIC_INTEGER),
+                     Arguments.of(new AtomicIntegerArray(5), ATOMIC_INTEGER_ARRAY),
+                     Arguments.of(AtomicIntegerFieldUpdater.newUpdater(Data.class, "intField"), ATOMIC_INTEGER_FIELD_UPDATER),
+                     Arguments.of(new AtomicLong(5l), InstanceOfAssertFactories.ATOMIC_LONG),
+                     Arguments.of(new AtomicLongArray(5), InstanceOfAssertFactories.ATOMIC_LONG_ARRAY),
+                     Arguments.of(AtomicLongFieldUpdater.newUpdater(Data.class, "longField"), ATOMIC_LONG_FIELD_UPDATER),
+                     Arguments.of(new AtomicMarkableReference<>("", false), ATOMIC_MARKABLE_REFERENCE),
+                     Arguments.of(new AtomicReference<>("abc"), ATOMIC_REFERENCE),
+                     Arguments.of(new AtomicReferenceArray<>(3), ATOMIC_REFERENCE_ARRAY),
+                     Arguments.of(newUpdater(Data.class, String.class, "stringField"), ATOMIC_REFERENCE_FIELD_UPDATER),
+                     Arguments.of(new AtomicStampedReference<>(0, 0), ATOMIC_STAMPED_REFERENCE),
+                     Arguments.of(BigDecimal.ONE, BIG_DECIMAL),
+                     Arguments.of(BigInteger.ONE, BIG_INTEGER),
+                     Arguments.of(true, BOOLEAN),
+                     Arguments.of(new boolean[0], BOOLEAN_ARRAY),
+                     Arguments.of((byte) 1, BYTE),
+                     Arguments.of(Byte.valueOf("1"), BYTE),
+                     Arguments.of(new byte[0], BYTE_ARRAY),
+                     Arguments.of(new char[0], CHAR_ARRAY),
+                     Arguments.of(charSequence, CHAR_SEQUENCE),
+                     Arguments.of('a', CHARACTER),
+                     Arguments.of(Character.valueOf('a'), CHARACTER),
+                     Arguments.of(TolkienCharacter.class, CLASS),
+                     Arguments.of(completedFuture("foo"), COMPLETABLE_FUTURE),
+                     Arguments.of(completionStage, COMPLETION_STAGE),
+                     Arguments.of(new Date(), DATE),
+                     Arguments.of(0d, DOUBLE),
+                     Arguments.of(Double.valueOf(0d), DOUBLE),
+                     Arguments.of(new double[0], DOUBLE_ARRAY),
+                     Arguments.of((DoublePredicate) d -> d == 0.0, DOUBLE_PREDICATE),
+                     Arguments.of(DoubleStream.empty(), DOUBLE_STREAM),
+                     Arguments.of(new File("foo"), FILE),
+                     Arguments.of(Float.valueOf("0.0"), FLOAT),
+                     Arguments.of(new float[0], FLOAT_ARRAY),
+                     Arguments.of(future, FUTURE),
+                     Arguments.of(new ByteArrayInputStream("stream".getBytes()), INPUT_STREAM),
+                     Arguments.of(Instant.now(), INSTANT),
+                     Arguments.of(new int[0], INT_ARRAY),
+                     Arguments.of((IntPredicate) i -> i == 0, INT_PREDICATE),
+                     Arguments.of(IntStream.empty(), INT_STREAM),
+                     Arguments.of(1, INTEGER),
+                     Arguments.of(newHashSet(), ITERABLE),
+                     Arguments.of(list("foo").iterator(), ITERATOR),
+                     Arguments.of(list("foo"), LIST),
+                     Arguments.of(LocalDate.now(), LOCAL_DATE),
+                     Arguments.of(LocalDateTime.now(), LOCAL_DATE_TIME),
+                     Arguments.of(5l, LONG),
+                     Arguments.of(new long[0], LONG_ARRAY),
+                     Arguments.of((LongPredicate) l -> l == 0, LONG_PREDICATE),
+                     Arguments.of(LongStream.empty(), LONG_STREAM),
+                     Arguments.of(newHashMap("k", "v"), MAP),
+                     Arguments.of(OffsetDateTime.now(), OFFSET_DATE_TIME),
+                     Arguments.of(OffsetTime.now(), OFFSET_TIME),
+                     Arguments.of(Optional.empty(), OPTIONAL),
+                     Arguments.of(OptionalDouble.empty(), OPTIONAL_DOUBLE),
+                     Arguments.of(OptionalInt.empty(), OPTIONAL_INT),
+                     Arguments.of(OptionalLong.empty(), OPTIONAL_LONG),
+                     Arguments.of(Paths.get("."), PATH),
+                     Arguments.of((Predicate<String>) s -> s.isEmpty(), PREDICATE),
+                     Arguments.of(Short.MIN_VALUE, SHORT),
+                     Arguments.of(new short[0], SHORT_ARRAY),
+                     Arguments.of(Stream.empty(), STREAM),
+                     Arguments.of("foo", STRING),
+                     Arguments.of(new StringBuffer(), STRING_BUFFER),
+                     Arguments.of(new StringBuilder(), STRING_BUILDER),
+                     Arguments.of(new Exception(), THROWABLE),
+                     Arguments.of(URI.create("http://localhost"), URI_TYPE),
+                     Arguments.of(URI.create("http://localhost").toURL(), URL_TYPE),
+                     Arguments.of(ZonedDateTime.now(), InstanceOfAssertFactories.ZONED_DATE_TIME));
+  }
+
+  static class Data {
+    volatile int intField;
+    volatile long longField;
+    volatile String stringField;
+  }
+
+}
