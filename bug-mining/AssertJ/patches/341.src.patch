diff --git a/src/main/java/org/assertj/core/api/AbstractAssert.java b/src/main/java/org/assertj/core/api/AbstractAssert.java
index 946f9ce6a..e1e09ae65 100644
--- a/src/main/java/org/assertj/core/api/AbstractAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractAssert.java
@@ -152,9 +152,14 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
    * @throws AssertionError with a message corresponding to the given {@link BasicErrorMessageFactory}.
    */
   protected void throwAssertionError(ErrorMessageFactory errorMessageFactory) {
+    AssertionError failure = assertionError(errorMessageFactory);
+    throw failure;
+  }
+
+  protected AssertionError assertionError(ErrorMessageFactory errorMessageFactory) {
     AssertionError failure = Failures.instance().failure(info, errorMessageFactory);
     removeCustomAssertRelatedElementsFromStackTraceIfNeeded(failure);
-    throw failure;
+    return failure;
   }
 
   private void removeCustomAssertRelatedElementsFromStackTraceIfNeeded(AssertionError assertionError) {
diff --git a/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java b/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
index 155a4f34f..0f61292bb 100644
--- a/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
@@ -18,6 +18,7 @@ import static org.assertj.core.error.ShouldMatch.shouldMatch;
 import static org.assertj.core.error.future.ShouldBeCancelled.shouldBeCancelled;
 import static org.assertj.core.error.future.ShouldBeCompleted.shouldBeCompleted;
 import static org.assertj.core.error.future.ShouldBeCompletedExceptionally.shouldHaveCompletedExceptionally;
+import static org.assertj.core.error.future.ShouldBeCompletedWithin.shouldBeCompletedWithin;
 import static org.assertj.core.error.future.ShouldBeDone.shouldBeDone;
 import static org.assertj.core.error.future.ShouldHaveFailed.shouldHaveFailed;
 import static org.assertj.core.error.future.ShouldNotBeCancelled.shouldNotBeCancelled;
@@ -26,9 +27,14 @@ import static org.assertj.core.error.future.ShouldNotBeCompletedExceptionally.sh
 import static org.assertj.core.error.future.ShouldNotBeDone.shouldNotBeDone;
 import static org.assertj.core.error.future.ShouldNotHaveFailed.shouldNotHaveFailed;
 
+import java.time.Duration;
 import java.util.Objects;
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.function.Predicate;
 
 import org.assertj.core.internal.Failures;
@@ -39,6 +45,7 @@ import org.assertj.core.presentation.PredicateDescription;
  *
  * @param <RESULT> type of the value contained in the {@link CompletableFuture}.
  */
+// TODO deprecate completed for succeeds?
 public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompletableFutureAssert<SELF, RESULT>, RESULT> extends
     AbstractAssert<SELF, CompletableFuture<RESULT>> {
 
@@ -85,7 +92,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
-   * Verifies that the {@link CompletableFuture} is completed exceptionally. 
+   * Verifies that the {@link CompletableFuture} is completed exceptionally.
    * Possible causes include cancellation, explicit invocation of completeExceptionally, and abrupt termination of a CompletionStage action.
    * <p>
    * If you only want to check that actual future is completed exceptionally but not cancelled, use {@link #hasFailed()} or {@link #hasFailedWithThrowableThat()}.
@@ -172,8 +179,8 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
-   * Verifies that the {@link CompletableFuture} is completed normally (i.e.{@link CompletableFuture#isDone() done} 
-   * but not {@link CompletableFuture#isCompletedExceptionally() completed exceptionally}).
+   * Verifies that the {@link CompletableFuture} is completed normally (i.e.{@link CompletableFuture#isDone() done} but not
+   * {@link CompletableFuture#isCompletedExceptionally() completed exceptionally}) or {@link CompletableFuture#isCancelled() cancelled}).
    * <p>
    * Assertion will pass :
    * <pre><code class='java'> assertThat(CompletableFuture.completedFuture("something")).isCompleted();</code></pre>
@@ -185,7 +192,8 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
    */
   public SELF isCompleted() {
     isNotNull();
-    if (!actual.isDone() || actual.isCompletedExceptionally()) throwAssertionError(shouldBeCompleted(actual));
+    // cancelled is included in completed exceptionally
+    if (actual.isCompletedExceptionally() || !actual.isDone()) throwAssertionError(shouldBeCompleted(actual));
     return myself;
   }
 
@@ -249,7 +257,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
-   * Verifies that the {@link CompletableFuture} is completed normally with a result matching the {@code predicate}, 
+   * Verifies that the {@link CompletableFuture} is completed normally with a result matching the {@code predicate},
    * the String parameter is used in the error message.
    * <p>
    * Assertion will pass :
@@ -259,7 +267,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
    * Assertion will fail :
    * <pre><code class='java'> assertThat(CompletableFuture.completedFuture("something"))
    *           .isCompletedWithValueMatching(result -&gt; result == null, "expected null");</code></pre>
-   * Error message is:            
+   * Error message is:
    * <pre><code class='java'> Expecting:
    *   &lt;"something"&gt;
    * to match 'expected null' predicate.</code></pre>
@@ -283,8 +291,8 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
-   * Verifies that the {@link CompletableFuture} has completed exceptionally but has not been cancelled, 
-   * this assertion is equivalent to: 
+   * Verifies that the {@link CompletableFuture} has completed exceptionally but has not been cancelled,
+   * this assertion is equivalent to:
    * <pre><code class='java'> assertThat(future).isCompletedExceptionally()
    *                   .isNotCancelled();</code></pre>
    * <p>
@@ -329,7 +337,159 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
-   * Verifies that the {@link CompletableFuture} has completed exceptionally and 
+   * Waits if necessary for at most the given time for this future to complete, and then returns its result for futher assertions.
+   * <p>
+   * If the future's result is not available for any reason an assertion error is thrown.
+   * <p>
+   * To get assertions for the future result's type use {@link #succeedsWithin(Duration, InstanceOfAssertFactory)} instead.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture("ook!");
+   * Duration timeout = Duration.ofMillis(100);
+   *
+   * // assertions succeeds
+   * assertThat(future).succeedsWithin(timeout)
+   *                   .isEqualTo("ook!");
+   *
+   * // fails assuming the future is not done after the given timeout
+   * CompletableFuture&lt;String&gt; future = ... ; // future too long to complete
+   * assertThat(future).succeedsWithin(timeout);
+   *
+   * // fails as the future is cancelled
+   * CompletableFuture future = new CompletableFuture();
+   * future.cancel(false);
+   * assertThat(future).succeedsWithin(timeout);</code></pre>
+   *
+   * @param timeout the maximum time to wait
+   * @return a new assertion object on the the future's result.
+   * @throws AssertionError if the actual {@code CompletableFuture} is {@code null}.
+   * @throws AssertionError if the actual {@code CompletableFuture} does not succeed within the given timeout.
+   */
+  public ObjectAssert<RESULT> succeedsWithin(Duration timeout) {
+    isNotNull();
+    try {
+      RESULT result = actual.get(timeout.toNanos(), TimeUnit.NANOSECONDS);
+      return assertThat(result);
+    } catch (InterruptedException | ExecutionException | TimeoutException | CancellationException e) {
+      throw assertionError(shouldBeCompletedWithin(actual, timeout, e));
+    }
+  }
+
+  /**
+   * Waits if necessary for at most the given time for this future to complete, and then returns its result for futher assertions.
+   * <p>
+   * If the future's result is not available for any reason an assertion error is thrown.
+   * <p>
+   * To get assertions for the future result's type use {@link #succeedsWithin(long, TimeUnit, InstanceOfAssertFactory)} instead.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture("ook!");
+   *
+   * // assertions succeeds
+   * assertThat(future).succeedsWithin(100, TimeUnit.MILLISECONDS)
+   *                   .isEqualTo("ook!");
+   *
+   * // fails assuming the future is not done after the given timeout
+   * CompletableFuture&lt;String&gt; future = ... ; // future too long to complete
+   * assertThat(future).succeedsWithin(100, TimeUnit.MILLISECONDS);
+   *
+   * // fails as the future is cancelled
+   * CompletableFuture future = new CompletableFuture();
+   * future.cancel(false);
+   * assertThat(future).succeedsWithin(100, TimeUnit.MILLISECONDS);</code></pre>
+   *
+   * @param timeout the maximum time to wait
+   * @param unit the time unit of the timeout argument
+   * @return a new assertion object on the the future's result.
+   * @throws AssertionError if the actual {@code CompletableFuture} is {@code null}.
+   * @throws AssertionError if the actual {@code CompletableFuture} does not succeed within the given timeout.
+   */
+  public ObjectAssert<RESULT> succeedsWithin(long timeout, TimeUnit unit) {
+    isNotNull();
+    try {
+      RESULT result = actual.get(timeout, unit);
+      return assertThat(result);
+    } catch (InterruptedException | ExecutionException | TimeoutException | CancellationException e) {
+      throw assertionError(shouldBeCompletedWithin(actual, timeout, unit, e));
+    }
+  }
+
+  /**
+   * Waits if necessary for at most the given time for this future to complete, the {@link InstanceOfAssertFactory}
+   * parameter is used to return assertions specific to the the future's result type.
+   * <p>
+   * If the future's result is not available for any reason an assertion error is thrown.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture("ook!");
+   * Duration timeout = Duration.ofMillis(100);
+   *
+   * // assertions succeeds
+   * // using asInstanceOf is recommanded to get assertions for the future result's type
+   * assertThat(future).succeedsWithin(timeout, InstanceOfAssertFactories.STRING)
+   *                   .contains("ok");
+   *
+   * // assertion fails if the narrowed type for assertions is incompatible with the future's result type.
+   * assertThat(future).succeedsWithin(timeout, InstanceOfAssertFactories.DATE)
+   *                   .isToday();</code></pre>
+   *
+   * @param <ASSERT> the type of the resulting {@code Assert}
+   * @param timeout the maximum time to wait
+   * @param assertFactory the factory which verifies the type and creates the new {@code Assert}
+   * @return a new narrowed {@link Assert} instance for assertions chaining on the value of the {@link CompletableFuture}
+   * @throws AssertionError if the actual {@code CompletableFuture} is {@code null}.
+   * @throws IllegalStateException if the actual {@code CompletableFuture} does not succeed within the given timeout.
+   */
+  public <ASSERT extends AbstractAssert<?, ?>> ASSERT succeedsWithin(Duration timeout,
+                                                                     InstanceOfAssertFactory<RESULT, ASSERT> assertFactory) {
+    isNotNull();
+    try {
+      RESULT result = actual.get(timeout.toNanos(), TimeUnit.NANOSECONDS);
+      return assertThat(result).asInstanceOf(assertFactory);
+    } catch (InterruptedException | ExecutionException | TimeoutException | CancellationException e) {
+      throw assertionError(shouldBeCompletedWithin(actual, timeout, e));
+    }
+  }
+
+  /**
+   * Waits if necessary for at most the given time for this future to complete, the {@link InstanceOfAssertFactory}
+   * parameter is used to return assertions specific to the the future's result type.
+   * <p>
+   * If the future's result is not available for any reason an assertion error is thrown.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture("ook!");
+   *
+   * // assertions succeeds
+   * // using asInstanceOf is recommanded to get assertions for the future result's type
+   * assertThat(future).succeedsWithin(100, TimeUnit.MILLISECONDS, InstanceOfAssertFactories.STRING)
+   *                   .contains("ok");
+   *
+   * // assertion  fails if the narrowed type for assertions is incompatible with the future's result type.
+   * assertThat(future).succeedsWithin(100, TimeUnit.MILLISECONDS, InstanceOfAssertFactories.DATE)
+   *                   .isToday();</code></pre>
+   *
+   * @param <ASSERT> the type of the resulting {@code Assert}
+   * @param timeout the maximum time to wait
+   * @param unit the time unit of the timeout argument
+   * @param assertFactory the factory which verifies the type and creates the new {@code Assert}
+   * @return a new narrowed {@link Assert} instance for assertions chaining on the value of the {@link CompletableFuture}
+   * @throws AssertionError if the actual {@code CompletableFuture} is {@code null}.
+   * @throws AssertionError if the actual {@code CompletableFuture} does not succeed within the given timeout.
+   */
+  public <ASSERT extends AbstractAssert<?, ?>> ASSERT succeedsWithin(long timeout, TimeUnit unit,
+                                                                     InstanceOfAssertFactory<RESULT, ASSERT> assertFactory) {
+    isNotNull();
+    try {
+      RESULT result = actual.get(timeout, unit);
+      return assertThat(result).asInstanceOf(assertFactory);
+    } catch (InterruptedException | ExecutionException | TimeoutException | CancellationException e) {
+      throw assertionError(shouldBeCompletedWithin(actual, timeout, unit, e));
+    }
+  }
+
+  /**
+   * Verifies that the {@link CompletableFuture} has completed exceptionally and
    * returns a Throwable assertion object allowing to check the Throwable that has caused the future to fail.
    * <p>
    * Assertion will pass :
@@ -337,8 +497,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
    * future.completeExceptionally(new RuntimeException("boom!"));
    *
    * assertThat(future).hasFailedWithThrowableThat().isInstanceOf(RuntimeException.class);
-   *                                                .hasMessage("boom!");
-   * </code></pre>
+   *                                                .hasMessage("boom!"); </code></pre>
    *
    * Assertion will fail :
    * <pre><code class='java'> CompletableFuture future = new CompletableFuture();
diff --git a/src/main/java/org/assertj/core/api/SoftProxies.java b/src/main/java/org/assertj/core/api/SoftProxies.java
index 9cc2cecf4..134b2e18e 100644
--- a/src/main/java/org/assertj/core/api/SoftProxies.java
+++ b/src/main/java/org/assertj/core/api/SoftProxies.java
@@ -55,7 +55,8 @@ class SoftProxies {
                                                                                                                       .or(named("extractingByKeys"))
                                                                                                                       .or(named("extractingFromEntries"))
                                                                                                                       .or(named("get"))
-                                                                                                                      .or(named("asInstanceOf"));
+                                                                                                                      .or(named("asInstanceOf"))
+                                                                                                                      .or(named("succeedsWithin"));
 
   private static final Junction<MethodDescription> METHODS_NOT_TO_PROXY = methodsNamed("as").or(named("clone"))
                                                                                             .or(named("describedAs"))
@@ -78,7 +79,8 @@ class SoftProxies {
                                                                                             .or(named("withAssertionState"))
                                                                                             .or(named("withRepresentation"))
                                                                                             .or(named("withTypeComparators"))
-                                                                                            .or(named("withThreadDumpOnError"));
+                                                                                            .or(named("withThreadDumpOnError"))
+                                                                                            .or(named("succeedsWithin"));
 
   private static final ByteBuddy BYTE_BUDDY = new ByteBuddy().with(new AuxiliaryType.NamingStrategy.SuffixingRandom("AssertJ$SoftProxies"))
                                                              .with(TypeValidation.DISABLED);
diff --git a/src/main/java/org/assertj/core/error/future/ShouldBeCompletedWithin.java b/src/main/java/org/assertj/core/error/future/ShouldBeCompletedWithin.java
new file mode 100644
index 000000000..4ab561c4f
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/future/ShouldBeCompletedWithin.java
@@ -0,0 +1,82 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.error.future;
+
+import static org.assertj.core.util.Strings.escapePercent;
+import static org.assertj.core.util.Throwables.getStackTrace;
+
+import java.time.Duration;
+import java.time.temporal.ChronoUnit;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.assertj.core.error.BasicErrorMessageFactory;
+import org.assertj.core.error.ErrorMessageFactory;
+
+public class ShouldBeCompletedWithin extends BasicErrorMessageFactory {
+
+  private static final String SHOULD_BE_COMPLETED_WITHIN_DURATION = "%n"
+                                                                    + "Expecting%n"
+                                                                    + "  <%s>%n"
+                                                                    + "to be completed within %s.%n%n"
+                                                                    + "exception caught while trying to get the future result: ";
+
+  private static final String SHOULD_BE_COMPLETED_WITHIN = "%n"
+                                                           + "Expecting%n"
+                                                           + "  <%s>%n"
+                                                           + "to be completed within %s %s.%n%n"
+                                                           + "exception caught while trying to get the future result: ";
+
+  public static ErrorMessageFactory shouldBeCompletedWithin(CompletableFuture<?> actual, Duration duration, Exception exception) {
+    return new ShouldBeCompletedWithin(actual, duration, exception);
+  }
+
+  public static ErrorMessageFactory shouldBeCompletedWithin(CompletableFuture<?> actual, long timeout, TimeUnit timeUnit,
+                                                            Exception exception) {
+    return new ShouldBeCompletedWithin(actual, timeout, timeUnit, exception);
+  }
+
+  private ShouldBeCompletedWithin(CompletableFuture<?> actual, Duration duration, Exception exception) {
+    // don't put the stack trace as a parameter to avoid AssertJ default String formatting
+    super(SHOULD_BE_COMPLETED_WITHIN_DURATION + escapePercent(getStackTrace(exception)), actual, duration);
+  }
+
+  private ShouldBeCompletedWithin(CompletableFuture<?> actual, long timeout, TimeUnit timeUnit, Exception exception) {
+    // don't put the stack trace as a parameter to avoid AssertJ default String formatting
+    // ChronoUnit toString looks better than TimeUnit
+    super(SHOULD_BE_COMPLETED_WITHIN + escapePercent(getStackTrace(exception)), actual, timeout, toChronoUnit(timeUnit));
+  }
+
+  // copied from java 9 code
+  private static ChronoUnit toChronoUnit(TimeUnit timeUnit) {
+    switch (timeUnit) {
+    case NANOSECONDS:
+      return ChronoUnit.NANOS;
+    case MICROSECONDS:
+      return ChronoUnit.MICROS;
+    case MILLISECONDS:
+      return ChronoUnit.MILLIS;
+    case SECONDS:
+      return ChronoUnit.SECONDS;
+    case MINUTES:
+      return ChronoUnit.MINUTES;
+    case HOURS:
+      return ChronoUnit.HOURS;
+    case DAYS:
+      return ChronoUnit.DAYS;
+    default:
+      throw new AssertionError();
+    }
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index db30e9a3d..ef13ee7cb 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -26,6 +26,7 @@ import java.io.File;
 import java.lang.reflect.Array;
 import java.lang.reflect.Method;
 import java.text.SimpleDateFormat;
+import java.time.Duration;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Comparator;
@@ -166,6 +167,7 @@ public class StandardRepresentation implements Representation {
     if (object instanceof Calendar) return toStringOf((Calendar) object);
     if (object instanceof Class<?>) return toStringOf((Class<?>) object);
     if (object instanceof Date) return toStringOf((Date) object);
+    if (object instanceof Duration) return toStringOf((Duration) object);
     if (object instanceof AtomicBoolean) return toStringOf((AtomicBoolean) object);
     if (object instanceof AtomicInteger) return toStringOf((AtomicInteger) object);
     if (object instanceof AtomicLong) return toStringOf((AtomicLong) object);
@@ -389,6 +391,10 @@ public class StandardRepresentation implements Representation {
                          formatLines(insertDelta.getRevised().getLines()));
   }
 
+  private String toStringOf(Duration duration) {
+    return duration.toString().substring(2);
+  }
+
   private String formatLines(List<?> lines) {
     return format(lines, DEFAULT_START, DEFAULT_END, ELEMENT_SEPARATOR_WITH_NEWLINE, "   ");
   }
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index f9e05cff1..ca9267bbf 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -16,6 +16,7 @@ import static java.lang.String.format;
 import static java.util.Arrays.asList;
 import static java.util.Collections.emptyList;
 import static java.util.concurrent.CompletableFuture.completedFuture;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
 import static java.util.stream.Collectors.toList;
 import static org.assertj.core.api.Assertions.as;
 import static org.assertj.core.api.Assertions.assertThat;
@@ -37,6 +38,7 @@ import static org.assertj.core.test.Maps.mapOf;
 import static org.assertj.core.test.Name.lastNameComparator;
 import static org.assertj.core.test.Name.name;
 import static org.assertj.core.util.Arrays.array;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.DateUtil.parseDatetime;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
@@ -64,6 +66,7 @@ import java.util.OptionalLong;
 import java.util.Spliterator;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionStage;
+import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicIntegerArray;
@@ -423,7 +426,7 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
                                                  + "not to have a port but had:%n"
                                                  + "  <80>"));
       assertThat(errors.get(53)).contains(format("%nExpecting Duration:%n"
-                                                 + " <PT10H>%n"
+                                                 + " <10H>%n"
                                                  + "to have 5L hours but had 10L"));
     }
   }
@@ -824,6 +827,33 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
     assertThat(softly.errorsCollected().get(0)).hasMessageContaining("cancelled");
   }
 
+  @Test
+  public void should_not_collect_AssertionError_from_CompletableFuture_succeedsWithin() {
+    // GIVEN
+    CompletableFuture<String> future = new CompletableFuture<>();
+    future.cancel(false);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> softly.assertThat(future).succeedsWithin(10, MILLISECONDS));
+    // THEN
+    assertThat(softly.errorsCollected()).isEmpty();
+    assertThat(assertionError).hasMessageContaining("Cancelled");
+  }
+
+  @Test
+  public void should_only_collect_error_from_chained_assertions_performed_after_succeedsWithin() {
+    // GIVEN
+    CompletableFuture<String> completableFuture = completedFuture("done");
+    // WHEN
+    softly.assertThat(completableFuture)
+          .succeedsWithin(10, TimeUnit.MILLISECONDS)
+          .isEqualTo("not done")
+          .isEqualTo("not ok");
+    // THEN
+    assertThat(softly.errorsCollected()).hasSize(2);
+    assertThat(softly.errorsCollected().get(0)).hasMessageContaining("not done");
+    assertThat(softly.errorsCollected().get(1)).hasMessageContaining("not ok");
+  }
+
   @Test
   public void should_work_with_predicate() {
     // GIVEN
diff --git a/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_succeedsWithin_Test.java b/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_succeedsWithin_Test.java
new file mode 100644
index 000000000..a2f854863
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/assumptions/Assumptions_assumeThat_with_succeedsWithin_Test.java
@@ -0,0 +1,51 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.assumptions;
+
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.assertj.core.api.Assertions.assertThatCode;
+import static org.assertj.core.api.Assumptions.assumeThat;
+import static org.assertj.core.util.AssertionsUtil.expectAssumptionViolatedException;
+
+import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("assumeThat after succeedsWithin")
+public class Assumptions_assumeThat_with_succeedsWithin_Test {
+
+  @Test
+  public void should_run_test_when_assumption_after_succeedsWithin_passes() {
+    // GIVEN
+    String value = "ook!";
+    CompletableFuture<String> future = completedFuture(value);
+    // WHEN
+    ThrowingCallable code = () -> assumeThat(future).succeedsWithin(Duration.ofMillis(1))
+                                                    .isEqualTo(value);
+    // THEN
+    assertThatCode(code).doesNotThrowAnyException();
+  }
+
+  @Test
+  public void should_ignore_test_when_assumption_after_succeedsWithin_fails() {
+    // GIVEN
+    String value = "ook!";
+    CompletableFuture<String> future = completedFuture(value);
+    // WHEN
+    expectAssumptionViolatedException(() -> assumeThat(future).succeedsWithin(Duration.ofMillis(1))
+                                                              .isEqualTo("eeek!"));
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasNotFailed_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasNotFailed_Test.java
index 0443cc023..92e364828 100644
--- a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasNotFailed_Test.java
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasNotFailed_Test.java
@@ -72,8 +72,7 @@ public class CompletableFutureAssert_hasNotFailed_Test extends BaseTest {
     // WHEN
     ThrowingCallable code = () -> assertThat(future).hasNotFailed();
     // THEN
-    assertThatAssertionErrorIsThrownBy(code).withMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed: java.lang.RuntimeException]%n"))
-                                            .withMessageContaining("Caused by: java.lang.RuntimeException")
+    assertThatAssertionErrorIsThrownBy(code).withMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed with the following stack trace:%njava.lang.RuntimeException"))
                                             .withMessageEndingWith("to not have failed.%n%s", WARNING);
 
   }
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValueMatching_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValueMatching_Test.java
index 09145105c..da6c37fd1 100644
--- a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValueMatching_Test.java
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValueMatching_Test.java
@@ -87,8 +87,7 @@ public class CompletableFutureAssert_isCompletedWithValueMatching_Test extends B
     // WHEN
     AssertionError assertionError = expectAssertionError(() -> assertThat(future).isCompletedWithValueMatching(result -> result.equals("done")));
     // THEN
-    assertThat(assertionError).hasMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed: java.lang.RuntimeException]%n"))
-                              .hasMessageContaining("Caused by: java.lang.RuntimeException")
+    assertThat(assertionError).hasMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed with the following stack trace:%njava.lang.RuntimeException"))
                               .hasMessageEndingWith("to be completed.%n%s", WARNING);
 
   }
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValue_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValue_Test.java
index a99bf7045..923bf762b 100644
--- a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValue_Test.java
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompletedWithValue_Test.java
@@ -73,8 +73,7 @@ public class CompletableFutureAssert_isCompletedWithValue_Test extends BaseTest
     // WHEN
     AssertionError assertionError = expectAssertionError(() -> assertThat(future).isCompletedWithValue("done"));
     // THEN
-    assertThat(assertionError).hasMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed: java.lang.RuntimeException]%n"))
-                              .hasMessageContaining("Caused by: java.lang.RuntimeException")
+    assertThat(assertionError).hasMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed with the following stack trace:%njava.lang.RuntimeException"))
                               .hasMessageEndingWith("to be completed.%n%s", WARNING);
 
   }
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isNotCompletedExceptionally_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isNotCompletedExceptionally_Test.java
index ccc02be87..5e78246e8 100644
--- a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isNotCompletedExceptionally_Test.java
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isNotCompletedExceptionally_Test.java
@@ -53,8 +53,7 @@ public class CompletableFutureAssert_isNotCompletedExceptionally_Test extends Ba
     // WHEN
     ThrowingCallable code = () -> assertThat(future).isNotCompletedExceptionally();
     // THEN
-    assertThatAssertionErrorIsThrownBy(code).withMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed: java.lang.RuntimeException]%n"))
-                                            .withMessageContaining("Caused by: java.lang.RuntimeException")
+    assertThatAssertionErrorIsThrownBy(code).withMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed with the following stack trace:%njava.lang.RuntimeException"))
                                             .withMessageEndingWith("to not be completed exceptionally.%n%s", WARNING);
   }
 }
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_succeedsWithin_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_succeedsWithin_Test.java
new file mode 100644
index 000000000..0409399f2
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_succeedsWithin_Test.java
@@ -0,0 +1,131 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.future;
+
+import static java.lang.String.format;
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.assertj.core.api.Assertions.as;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.InstanceOfAssertFactories.STRING;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executors;
+
+import org.assertj.core.api.AbstractCompletableFutureAssert;
+import org.assertj.core.api.BaseTest;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+/**
+ * tests {@link AbstractCompletableFutureAssert#succeedsWithin(long, java.util.concurrent.TimeUnit)}
+ */
+@DisplayName("CompletableFutureAssert succeedsWithin")
+public class CompletableFutureAssert_succeedsWithin_Test extends BaseTest {
+
+  @Test
+  public void should_allow_assertion_on_future_result_when_completed_normally() {
+    // GIVEN
+    String value = "done";
+    CompletableFuture<String> future = completedFuture(value);
+    // WHEN/THEN
+    assertThat(future).succeedsWithin(1, MILLISECONDS)
+                      .isEqualTo(value);
+  }
+
+  @Test
+  public void should_allow_assertion_on_future_result_when_completed_normally_within_timeout() {
+    // GIVEN
+    String value = "done";
+    int sleepDuration = 10;
+    CompletableFuture<String> future = completedFutureAfter(value, sleepDuration);
+    // WHEN/THEN
+    // using the same duration would fail depending on when the thread executing the future is started
+    assertThat(future).succeedsWithin(sleepDuration + 100, MILLISECONDS)
+                      .isEqualTo(value);
+  }
+
+  @Test
+  public void should_allow_narrowed_assertion_on_future_result() {
+    // GIVEN
+    String value = "done";
+    CompletableFuture<String> future = completedFuture(value);
+    // WHEN/THEN
+    assertThat(future).succeedsWithin(1, MILLISECONDS, as(STRING))
+                      .startsWith("don");
+  }
+
+  @Test
+  public void should_fail_if_completable_future_does_not_succeed_within_given_timeout() {
+    // GIVEN
+    int sleepDuration = 100000;
+    CompletableFuture<String> future = completedFutureAfter("ook!", sleepDuration);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).succeedsWithin(10, MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessageStartingWith(format("%nExpecting%n" +
+                                                       "  <CompletableFuture[Incomplete]>%n" +
+                                                       "to be completed within 10L Millis.%n"));
+  }
+
+  @Test
+  public void should_fail_if_completable_future_is_cancelled() {
+    // GIVEN
+    CompletableFuture<String> future = new CompletableFuture<>();
+    future.cancel(false);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).succeedsWithin(1, MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessageStartingWith(format("%nExpecting%n" +
+                                                       "  <CompletableFuture[Cancelled]>%n" +
+                                                       "to be completed within 1L Millis.%n" +
+                                                       "%n" +
+                                                       "exception caught while trying to get the future result: java.util.concurrent.CancellationException"));
+  }
+
+  @Test
+  public void should_fail_when_completable_future_is_null() {
+    // GIVEN
+    CompletableFuture<String> future = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).succeedsWithin(1, MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  @Test
+  public void should_fail_if_completable_future_is_completed_exceptionally() {
+    // GIVEN
+    CompletableFuture<String> future = new CompletableFuture<>();
+    future.completeExceptionally(new RuntimeException("boom%s%n"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).succeedsWithin(1, MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed with the following stack trace:%njava.lang.RuntimeException: boom%%s%%n"))
+                        .hasMessageContaining("to be completed within 1L Millis.");
+  }
+
+  private static <U> CompletableFuture<U> completedFutureAfter(U value, long sleepDuration) {
+    CompletableFuture<U> completableFuture = new CompletableFuture<>();
+    Executors.newSingleThreadExecutor().submit(() -> {
+      Thread.sleep(sleepDuration);
+      completableFuture.complete(value);
+      return null;
+    });
+    return completableFuture;
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_succeedsWithin_duration_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_succeedsWithin_duration_Test.java
new file mode 100644
index 000000000..413bd6df2
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_succeedsWithin_duration_Test.java
@@ -0,0 +1,134 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.api.future;
+
+import static java.lang.String.format;
+import static java.time.temporal.ChronoUnit.MILLIS;
+import static java.util.concurrent.CompletableFuture.completedFuture;
+import static org.assertj.core.api.Assertions.as;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.InstanceOfAssertFactories.STRING;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Executors;
+
+import org.assertj.core.api.AbstractCompletableFutureAssert;
+import org.assertj.core.api.BaseTest;
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+/**
+ * tests both {@link AbstractCompletableFutureAssert#succeedsWithin(Duration)} and
+ * {@link AbstractCompletableFutureAssert#succeedsWithin(long, java.util.concurrent.TimeUnit)}
+ * since the former call the latter.
+ */
+@DisplayName("CompletableFutureAssert succeedsWithin(Duration)")
+public class CompletableFutureAssert_succeedsWithin_duration_Test extends BaseTest {
+
+  @Test
+  public void should_allow_assertion_on_future_result_when_completed_normally() {
+    // GIVEN
+    String value = "done";
+    CompletableFuture<String> future = completedFuture(value);
+    // WHEN/THEN
+    assertThat(future).succeedsWithin(Duration.ofMillis(1))
+                      .isEqualTo(value);
+  }
+
+  @Test
+  public void should_allow_assertion_on_future_result_when_completed_normally_within_timeout() {
+    // GIVEN
+    String value = "done";
+    int sleepDuration = 10;
+    CompletableFuture<String> future = completedFutureAfter(value, sleepDuration);
+    // WHEN/THEN
+    // using the same duration would fail depending on when the thread executing the future is started
+    assertThat(future).succeedsWithin(Duration.ofMillis(sleepDuration + 100))
+                      .isEqualTo(value);
+  }
+
+  @Test
+  public void should_allow_narrowed_assertion_on_future_result() {
+    // GIVEN
+    String value = "done";
+    CompletableFuture<String> future = completedFuture(value);
+    // WHEN/THEN
+    assertThat(future).succeedsWithin(Duration.ofMillis(1), as(STRING))
+                      .startsWith("don");
+  }
+
+  @Test
+  public void should_fail_if_completable_future_does_not_succeed_within_given_timeout() {
+    // GIVEN
+    int sleepDuration = 100000;
+    CompletableFuture<String> future = completedFutureAfter("ook!", sleepDuration);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).succeedsWithin(Duration.ofMillis(10)));
+    // THEN
+    then(assertionError).hasMessageStartingWith(format("%nExpecting%n" +
+                                                       "  <CompletableFuture[Incomplete]>%n" +
+                                                       "to be completed within 0.01S.%n"));
+  }
+
+  @Test
+  public void should_fail_if_completable_future_is_cancelled() {
+    // GIVEN
+    CompletableFuture<String> future = new CompletableFuture<>();
+    future.cancel(false);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).succeedsWithin(Duration.ofMillis(1)));
+    // THEN
+    then(assertionError).hasMessageStartingWith(format("%nExpecting%n" +
+                                                       "  <CompletableFuture[Cancelled]>%n" +
+                                                       "to be completed within 0.001S.%n" +
+                                                       "%n" +
+                                                       "exception caught while trying to get the future result: java.util.concurrent.CancellationException"));
+  }
+
+  @Test
+  public void should_fail_when_completable_future_is_null() {
+    // GIVEN
+    CompletableFuture<String> future = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).succeedsWithin(Duration.of(1L, MILLIS)));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  @Test
+  public void should_fail_if_completable_future_is_completed_exceptionally() {
+    // GIVEN
+    CompletableFuture<String> future = new CompletableFuture<>();
+    future.completeExceptionally(new RuntimeException("boom%s%n"));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).succeedsWithin(Duration.of(1L, MILLIS)));
+    // THEN
+    then(assertionError).hasMessageStartingWith(format("%nExpecting%n  <CompletableFuture[Failed with the following stack trace:%njava.lang.RuntimeException: boom%%s%%n"))
+                        .hasMessageContaining("to be completed within 0.001S.");
+  }
+
+  private static <U> CompletableFuture<U> completedFutureAfter(U value, long sleepDuration) {
+    CompletableFuture<U> completableFuture = new CompletableFuture<>();
+    Executors.newSingleThreadExecutor().submit(() -> {
+      Thread.sleep(sleepDuration);
+      completableFuture.complete(value);
+      return null;
+    });
+    return completableFuture;
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/future/ShouldBeCompletedWithin_create_Test.java b/src/test/java/org/assertj/core/error/future/ShouldBeCompletedWithin_create_Test.java
new file mode 100644
index 000000000..03d706c58
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/future/ShouldBeCompletedWithin_create_Test.java
@@ -0,0 +1,63 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.error.future;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.error.future.ShouldBeCompletedWithin.shouldBeCompletedWithin;
+import static org.assertj.core.util.Throwables.getStackTrace;
+
+import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.TimeUnit;
+
+import org.assertj.core.internal.TestDescription;
+import org.junit.jupiter.api.Test;
+
+public class ShouldBeCompletedWithin_create_Test {
+
+  @Test
+  public void should_create_error_message_with_duration() {
+    // GIVEN
+    CompletableFuture<Object> actual = new CompletableFuture<>();
+    Duration duration = Duration.ofMillis(70_001);
+    Exception exception = new Exception("boom");
+    // WHEN
+    String error = shouldBeCompletedWithin(actual, duration, exception).create(new TestDescription("TEST"));
+    // THEN
+    assertThat(error).isEqualTo("[TEST] %n" +
+                                "Expecting%n" +
+                                "  <CompletableFuture[Incomplete]>%n" +
+                                "to be completed within 1M10.001S.%n" +
+                                "%n" +
+                                "exception caught while trying to get the future result: %s",
+                                getStackTrace(exception));
+  }
+
+  @Test
+  public void should_create_error_message() {
+    // GIVEN
+    CompletableFuture<Object> actual = new CompletableFuture<>();
+    Exception exception = new Exception("boom");
+    // WHEN
+    String error = shouldBeCompletedWithin(actual, 100, TimeUnit.MILLISECONDS, exception).create(new TestDescription("TEST"));
+    // THEN
+    assertThat(error).isEqualTo("[TEST] %n" +
+                                "Expecting%n" +
+                                "  <CompletableFuture[Incomplete]>%n" +
+                                "to be completed within 100L Millis.%n" +
+                                "%n" +
+                                "exception caught while trying to get the future result: %s",
+                                getStackTrace(exception));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/error/future/ShouldNotHaveFailed_create_Test.java b/src/test/java/org/assertj/core/error/future/ShouldNotHaveFailed_create_Test.java
index 953d594a6..6f4c8a84a 100644
--- a/src/test/java/org/assertj/core/error/future/ShouldNotHaveFailed_create_Test.java
+++ b/src/test/java/org/assertj/core/error/future/ShouldNotHaveFailed_create_Test.java
@@ -32,8 +32,7 @@ public class ShouldNotHaveFailed_create_Test {
     // WHEN
     String error = shouldNotHaveFailed(future).create(new TestDescription("TEST"));
     // THEN
-    assertThat(error).startsWith(format("[TEST] %nExpecting%n  <CompletableFuture[Failed: java.lang.RuntimeException]%n"))
-                     .contains("Caused by: java.lang.RuntimeException")
+    assertThat(error).startsWith(format("[TEST] %nExpecting%n  <CompletableFuture[Failed with the following stack trace:%njava.lang.RuntimeException"))
                      .endsWith(format("to not have failed.%n%s", WARNING));
   }
 }
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_format_CompletableFuture_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_format_CompletableFuture_Test.java
index b27a58b9a..1cb064dd9 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_format_CompletableFuture_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_format_CompletableFuture_Test.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.core.presentation;
 
+import static java.lang.String.format;
 import static java.util.concurrent.CompletableFuture.completedFuture;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
@@ -38,8 +39,7 @@ public class StandardRepresentation_format_CompletableFuture_Test {
   public void should_format_failed_future() {
     CompletableFuture<Object> future = new CompletableFuture<>();
     future.completeExceptionally(new RuntimeException("some random error"));
-    assertThat(STANDARD_REPRESENTATION.toStringOf(future)).startsWith(String.format("CompletableFuture[Failed: java.lang.RuntimeException: some random error]%n"))
-                                                          .contains("Caused by: java.lang.RuntimeException: some random error");
+    assertThat(STANDARD_REPRESENTATION.toStringOf(future)).startsWith(format("CompletableFuture[Failed with the following stack trace:%njava.lang.RuntimeException: some random error"));
   }
 
   @Test
@@ -55,7 +55,7 @@ public class StandardRepresentation_format_CompletableFuture_Test {
     future.complete(future);
     assertThat(STANDARD_REPRESENTATION.toStringOf(future)).isEqualTo("CompletableFuture[Completed: " + future + "]");
   }
-  
+
   @Test
   public void should_not_stack_overflow_when_formatting_future_with_reference_cycle() {
     CompletableFuture<CompletableFuture<?>> future1 = new CompletableFuture<>();
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
index e08a4bc8c..7f4079728 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
@@ -13,16 +13,19 @@
 package org.assertj.core.presentation;
 
 import static java.lang.String.format;
+import static java.time.temporal.ChronoUnit.MILLIS;
 import static java.util.concurrent.atomic.AtomicReferenceFieldUpdater.newUpdater;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.newArrayList;
 
 import java.io.File;
 import java.lang.reflect.Method;
 import java.text.SimpleDateFormat;
+import java.time.Duration;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collection;
@@ -38,12 +41,16 @@ import java.util.concurrent.atomic.AtomicMarkableReference;
 import java.util.concurrent.atomic.AtomicReference;
 import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.concurrent.atomic.AtomicStampedReference;
+import java.util.stream.Stream;
 
 import org.assertj.core.data.MapEntry;
 import org.assertj.core.util.OtherStringTestComparator;
 import org.assertj.core.util.OtherStringTestComparatorWithAt;
 import org.assertj.core.util.StringTestComparator;
 import org.junit.jupiter.api.Test;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.MethodSource;
 
 /**
  * Tests for {@link org.assertj.core.presentation.StandardRepresentation#toStringOf(Object)}.
@@ -116,7 +123,8 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void should_return_toString_of_Collection_of_Collections_up_to_the_maximum_allowed_elements() {
-    Collection<List<String>> collection = newArrayList(newArrayList("s1", "s2"), newArrayList("s3", "s4", "s5"), newArrayList("s6", "s7"));
+    Collection<List<String>> collection = newArrayList(newArrayList("s1", "s2"), newArrayList("s3", "s4", "s5"),
+                                                       newArrayList("s6", "s7"));
     StandardRepresentation.setMaxElementsForPrinting(2);
     assertThat(STANDARD_REPRESENTATION.toStringOf(collection))
                                                               .isEqualTo("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ...], ...]");
@@ -296,6 +304,21 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
     assertThat(STANDARD_REPRESENTATION.toStringOf(method)).isEqualTo(method.toGenericString());
   }
 
+  @ParameterizedTest
+  @MethodSource("durations")
+  public void should_return_toString_of_duration(Duration duration, String expectedDurationRepresentation) {
+    // WHEN
+    String durationRepresentation = STANDARD_REPRESENTATION.toStringOf(duration);
+    // THEN
+    then(durationRepresentation).isEqualTo(expectedDurationRepresentation);
+  }
+
+  private static Stream<Arguments> durations() {
+    return Stream.of(Arguments.of(Duration.of(1L, MILLIS), "0.001S"),
+                     Arguments.of(Duration.of(1234L, MILLIS), "1.234S"),
+                     Arguments.of(Duration.of(3_661_001L, MILLIS), "1H1M1.001S"));
+  }
+
   private String toStringOf(Object o) {
     return STANDARD_REPRESENTATION.toStringOf(o);
   }
