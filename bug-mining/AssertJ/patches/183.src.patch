diff --git a/src/main/java/org/assertj/core/api/AbstractObjectAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
index c75e03394..81fce19bb 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
@@ -430,4 +430,57 @@ public abstract class AbstractObjectAssert<S extends AbstractObjectAssert<S, A>,
     Tuple values = byName(propertiesOrFields).extract(actual);
     return new ObjectArrayAssert<Object>(values.toArray());
   }
+
+  /**
+   * Assert that actual object is equal to the given object based on recursive a property/field by property/field comparison (including
+   * inherited ones). This can be handy if actual's <code>equals</code> implementation does not suit you.
+   * <p/>
+   * Note that the recursive property/field comparison is stopped for fields with a custom <code>equals</code> implementation, i.e. 
+   * the overriden <code>equals</code> method will be used instead of a field by field comparison.
+   * <p/>
+   * If an object has a field and a property with the same name, the property value will be used over the field.
+   * <p/>
+   * The objects to compare can be of different types but must have the same properties/fields.
+   * For example if actual object has a name String field, it is expected the other object to also have one.
+   * <p/>
+   * The recursive comparison handles cycle.
+   * <p/>
+   * 
+   * Example:
+   * <pre><code class='java'> public class Person {
+   *   public String name;
+   *   public Home home = new Home();
+   * }
+   *
+   * public class Home {
+   *   public Address address = new Address();
+   * }
+   *
+   * public static class Address {
+   *   public int number = 1;
+   * }
+   * 
+   * Person jack = new Person();
+   * jack.name = "Jack";
+   * jack.home.address.number = 1;
+   * 
+   * Person jackClone = new Person();
+   * jackClone.name = "Jack";
+   * jackClone.home.address.number = 1;
+   * 
+   * // will fail as equals compares object references
+   * assertThat(jack).isEqualsTo(jackClone);
+   * 
+   * // jack and jackClone are equals when doing a recursive field by field comparison
+   * assertThat(jack).isEqualToComparingFieldByFieldRecursively(jackClone);</code></pre>
+   * 
+   * @param other the object to compare {@code actual} to.
+   * @throws AssertionError if the actual object is {@code null}.
+   * @throws AssertionError if the actual and the given objects are not deeply equal property/field by property/field.
+   * @throws IntrospectionError if one property/field to compare can not be found.
+   */
+  public S isEqualToComparingFieldByFieldRecursively(Object other) {
+    objects.assertIsEqualToComparingFieldByFieldRecursively(info, actual, other);
+    return myself;
+  }
 }
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursive.java b/src/main/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursive.java
new file mode 100644
index 000000000..123c9693d
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqualByComparingFieldByFieldRecursive.java
@@ -0,0 +1,41 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.util.Strings.join;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.internal.DeepDifference.Difference;
+
+public class ShouldBeEqualByComparingFieldByFieldRecursive extends BasicErrorMessageFactory {
+
+  public static ErrorMessageFactory shouldBeEqualByComparingFieldByFieldRecursive(Object actual, Object other,
+                                                                                  List<Difference> differences) {
+    List<String> descriptionOfDifferences = new ArrayList<>(differences.size());
+    for (Difference difference : differences) {
+      descriptionOfDifferences.add(format("%nPath to difference:  <%s>%nexpected:  <%s>%nbut was:  <%s>",
+                                          join(difference.getPath()).with("."), difference.getOther(),
+                                          difference.getActual()));
+    }
+    return new ShouldBeEqualByComparingFieldByFieldRecursive("Expecting:  <%s>%nto be equal to:  <%s>%nwhen recursively comparing field by field, but found the following difference(s):%n"
+                                                             + join(descriptionOfDifferences).with(format("%n")),
+                                                             actual, other);
+  }
+
+  private ShouldBeEqualByComparingFieldByFieldRecursive(String message, Object actual, Object other) {
+    super(message, actual, other);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/DeepDifference.java b/src/main/java/org/assertj/core/internal/DeepDifference.java
new file mode 100644
index 000000000..55c0b1ded
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/DeepDifference.java
@@ -0,0 +1,679 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static org.assertj.core.internal.Objects.getDeclaredFieldsIncludingInherited;
+import static org.assertj.core.util.introspection.PropertyOrFieldSupport.EXTRACTION;
+
+import java.lang.reflect.Array;
+import java.lang.reflect.Field;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Deque;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.SortedSet;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Tests two objects for differences by doing a 'deep' comparison.
+ *
+ * Based on the deep equals implementation of https://github.com/jdereg/java-util
+ *
+ * @author John DeRegnaucourt (john@cedarsoftware.com)
+ * @author Pascal Schumacher
+ */
+public class DeepDifference {
+
+  private static final Map<Class<?>, Boolean> customEquals = new ConcurrentHashMap<>();
+  private static final Map<Class<?>, Boolean> customHash = new ConcurrentHashMap<>();
+  private static final double doubleEplison = 1e-15;
+  private static final double floatEplison = 1e-6;
+
+  private final static class DualKey {
+
+    private final List<String> path;
+    private final Object key1;
+    private final Object key2;
+
+    private DualKey(List<String> path, Object key1, Object key2) {
+      this.path = path;
+      this.key1 = key1;
+      this.key2 = key2;
+    }
+
+    private DualKey(Object key1, Object key2) {
+      this(new ArrayList<String>(), key1, key2);
+    }
+    
+    @Override
+    public boolean equals(Object other) {
+      if (!(other instanceof DualKey)) {
+        return false;
+      }
+
+      DualKey that = (DualKey) other;
+      return key1 == that.key1 && key2 == that.key2;
+    }
+
+    @Override
+    public int hashCode() {
+      int h1 = key1 != null ? key1.hashCode() : 0;
+      int h2 = key2 != null ? key2.hashCode() : 0;
+      return h1 + h2;
+    }
+
+    @Override
+    public String toString() {
+      return "DualKey [key1=" + key1 + ", key2=" + key2 + "]";
+    }
+
+    public List<String> getPath() {
+      return path;
+    }
+  }
+
+  public static class Difference {
+
+    List<String> path;
+    Object actual;
+    Object other;
+
+    public Difference(List<String> path, Object actual, Object other) {
+      this.path = path;
+      this.actual = actual;
+      this.other = other;
+    }
+
+    public List<String> getPath() {
+      return path;
+    }
+
+    public Object getActual() {
+      return actual;
+    }
+
+    public Object getOther() {
+      return other;
+    }
+
+    @Override
+    public String toString() {
+      return "Difference [path=" + path + ", actual=" + actual + ", other=" + other + "]";
+    }
+  }
+
+  /**
+   * Compare two objects for differences by doing a 'deep' comparison. This will traverse the
+   * Object graph and perform either a field-by-field comparison on each
+   * object (if not .equals() method has been overridden from Object), or it
+   * will call the customized .equals() method if it exists.
+   * </p>
+   *
+   * This method handles cycles correctly, for example A-&gt;B-&gt;C-&gt;A.
+   * Suppose a and a' are two separate instances of the A with the same values
+   * for all fields on A, B, and C. Then a.deepEquals(a') will return an empty list. It
+   * uses cycle detection storing visited objects in a Set to prevent endless
+   * loops.
+   * 
+   * @param a Object one to compare
+   * @param b Object two to compare
+   * @return the list of differences found or an empty list if objects are equivalent.
+   *         Equivalent means that all field values of both subgraphs are the same,
+   *         either at the field level or via the respectively encountered overridden
+   *         .equals() methods during traversal.
+   */
+  public static List<Difference> determineDifferences(Object a, Object b) {
+    final Set<DualKey> visited = new HashSet<>();
+    final Deque<DualKey> toCompare = initStack(a, b, visited);
+    final List<Difference> differences = new ArrayList<>();
+
+    while (!toCompare.isEmpty()) {
+      final DualKey dualKey = toCompare.removeFirst();
+      visited.add(dualKey);
+
+      final List<String> currentPath = dualKey.getPath();
+      final Object key1 = dualKey.key1;
+      final Object key2 = dualKey.key2;
+
+      if (key1 == key2) {
+        continue;
+      }
+
+      if (key1 == null || key2 == null) {
+        differences.add(new Difference(currentPath, key1, key2));
+        continue;
+      }
+
+      if (key1 instanceof Collection) {
+        if (!(key2 instanceof Collection)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+      } else if (key2 instanceof Collection) {
+        differences.add(new Difference(currentPath, key1, key2));
+        continue;
+      }
+
+      if (key1 instanceof SortedSet) {
+        if (!(key2 instanceof SortedSet)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+      } else if (key2 instanceof SortedSet) {
+        differences.add(new Difference(currentPath, key1, key2));
+        continue;
+      }
+
+      if (key1 instanceof SortedMap) {
+        if (!(key2 instanceof SortedMap)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+      } else if (key2 instanceof SortedMap) {
+        differences.add(new Difference(currentPath, key1, key2));
+        continue;
+      }
+
+      if (key1 instanceof Map) {
+        if (!(key2 instanceof Map)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+      } else if (key2 instanceof Map) {
+        differences.add(new Difference(currentPath, key1, key2));
+        continue;
+      }
+
+      if (key1 instanceof Double) {
+        if (compareFloatingPointNumbers(key1, key2, doubleEplison))
+          continue;
+      }
+
+      if (key1 instanceof Float) {
+        if (compareFloatingPointNumbers(key1, key2, floatEplison))
+          continue;
+      }
+
+      // Handle all [] types. In order to be equal, the arrays must be the
+      // same length, be of the same type, be in the same order, and all
+      // elements within the array must be deeply equivalent.
+      if (key1.getClass().isArray()) {
+        if (!compareArrays(key1, key2, currentPath, toCompare, visited)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+        continue;
+      }
+
+      // Special handle SortedSets because they are fast to compare
+      // because their elements must be in the same order to be equivalent Sets.
+      if (key1 instanceof SortedSet) {
+        if (!compareOrderedCollection((Collection<?>) key1, (Collection<?>) key2, currentPath, toCompare, visited)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+        continue;
+      }
+
+      // Handled unordered Sets. This is a slightly more expensive comparison because order cannot
+      // be assumed, a temporary Map must be created, however the comparison still runs in O(N) time.
+      if (key1 instanceof Set) {
+        if (!compareUnorderedCollection((Collection<?>) key1, (Collection<?>) key2, currentPath, toCompare,
+                                        visited)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+        continue;
+      }
+
+      // Check any Collection that is not a Set. In these cases, element
+      // order matters, therefore this comparison is faster than using unordered comparison.
+      if (key1 instanceof Collection) {
+        if (!compareOrderedCollection((Collection<?>) key1, (Collection<?>) key2, currentPath, toCompare, visited)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+        continue;
+      }
+
+      // Compare two SortedMaps. This takes advantage of the fact that these
+      // Maps can be compared in O(N) time due to their ordering.
+      if (key1 instanceof SortedMap) {
+        if (!compareSortedMap((SortedMap<?, ?>) key1, (SortedMap<?, ?>) key2, currentPath, toCompare, visited)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+        continue;
+      }
+
+      // Compare two Unordered Maps. This is a slightly more expensive comparison because
+      // order cannot be assumed, therefore a temporary Map must be created, however the
+      // comparison still runs in O(N) time.
+      if (key1 instanceof Map) {
+        if (!compareUnorderedMap((Map<?, ?>) key1, (Map<?, ?>) key2, currentPath, toCompare, visited)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+        continue;
+      }
+
+      if (hasCustomEquals(key1.getClass())) {
+        if (!key1.equals(key2)) {
+          differences.add(new Difference(currentPath, key1, key2));
+          continue;
+        }
+        continue;
+      }
+
+      for (Field field : getDeclaredFieldsIncludingInherited(key1.getClass())) {
+        List<String> path = new ArrayList<String>(currentPath);
+        String fieldName = field.getName();
+        path.add(fieldName);
+        DualKey dk = new DualKey(path,
+                                 EXTRACTION.getSimpleValue(fieldName, key1),
+                                 EXTRACTION.getSimpleValue(fieldName, key2));
+        if (!visited.contains(dk)) {
+          toCompare.addFirst(dk);
+        }
+      }
+    }
+
+    return differences;
+  }
+
+  private static Deque<DualKey> initStack(Object a, Object b, Set<DualKey> visited) {
+    Deque<DualKey> stack = new LinkedList<>();
+    if (a != null && !isContainerType(a)) {
+      // disregard the equals method and start comparing fields
+      Collection<Field> fieldsOfRootObject = getDeclaredFieldsIncludingInherited(a.getClass());
+      if (!fieldsOfRootObject.isEmpty()) {
+        for (Field field : fieldsOfRootObject) {
+          String fieldName = field.getName();
+          DualKey dk = new DualKey(Arrays.asList(fieldName),
+                                   EXTRACTION.getSimpleValue(fieldName, a),
+                                   EXTRACTION.getSimpleValue(fieldName, b));
+          if (!visited.contains(dk)) {
+            stack.addFirst(dk);
+          }
+        }
+      } else {
+        stack.addFirst(new DualKey(a, b));
+      }
+    } else {
+      stack.addFirst(new DualKey(a, b));
+    }
+    return stack;
+  }
+
+  private static boolean isContainerType(Object o) {
+    return o instanceof Collection || o instanceof Map;
+  }
+
+  /**
+   * Deeply compare to Arrays []. Both arrays must be of the same type, same
+   * length, and all elements within the arrays must be deeply equal in order
+   * to return true.
+   * 
+   * @param array1 [] type (Object[], String[], etc.)
+   * @param array2 [] type (Object[], String[], etc.)
+   * @param path the path to the arrays to compare
+   * @param toCompare add items to compare to the Stack (Stack versus recursion)
+   * @param visited Set of objects already compared (prevents cycles)
+   * @return true if the two arrays are the same length and contain deeply
+   *         equivalent items.
+   */
+  private static boolean compareArrays(Object array1, Object array2, List<String> path, Deque<DualKey> toCompare,
+                                       Set<DualKey> visited) {
+    int len = Array.getLength(array1);
+    if (len != Array.getLength(array2)) {
+      return false;
+    }
+
+    for (int i = 0; i < len; i++) {
+      DualKey dk = new DualKey(path, Array.get(array1, i), Array.get(array2, i));
+      if (!visited.contains(dk)) {
+        toCompare.addFirst(dk);
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Deeply compare two Collections that must be same length and in same
+   * order.
+   * 
+   * @param col1 First collection of items to compare
+   * @param col2 Second collection of items to compare
+   * @param path The path to the collections
+   * @param toCompare add items to compare to the Stack (Stack versus recursion)
+   * @param visited
+   *          Set of objects already compared (prevents cycles) value of
+   *          'true' indicates that the Collections may be equal, and the
+   *          sets items will be added to the Stack for further comparison.
+   */
+  private static <K, V> boolean compareOrderedCollection(Collection<K> col1, Collection<V> col2,
+                                                         List<String> path, Deque<DualKey> toCompare,
+                                                         Set<DualKey> visited) {
+    if (col1.size() != col2.size()) {
+      return false;
+    }
+
+    Iterator<V> i2 = col2.iterator();
+    for (K k : col1) {
+      DualKey dk = new DualKey(path, k, i2.next());
+      if (!visited.contains(dk)) {
+        toCompare.addFirst(dk);
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Deeply compare the two sets referenced by dualKey. This method attempts
+   * to quickly determine inequality by length, then if lengths match, it
+   * places one collection into a temporary Map by deepHashCode(), so that it
+   * can walk the other collection and look for each item in the map, which
+   * runs in O(N) time, rather than an O(N^2) lookup that would occur if each
+   * item from collection one was scanned for in collection two.
+   * 
+   * @param col1 First collection of items to compare
+   * @param col2 Second collection of items to compare
+   * @param path the path to the collections to compare
+   * @param toCompare add items to compare to the Stack (Stack versus recursion)
+   * @param visited Set containing items that have already been compared, so as to
+   *          prevent cycles.
+   * @return boolean false if the Collections are for certain not equals. A
+   *         value of 'true' indicates that the Collections may be equal, and
+   *         the sets items will be added to the Stack for further comparison.
+   */
+  private static <K, V> boolean compareUnorderedCollection(Collection<K> col1, Collection<V> col2,
+                                                           List<String> path, Deque<DualKey> toCompare,
+                                                           Set<DualKey> visited) {
+    if (col1.size() != col2.size()) {
+      return false;
+    }
+
+    Map<Integer, Object> fastLookup = new HashMap<>();
+    for (Object o : col2) {
+      fastLookup.put(deepHashCode(o), o);
+    }
+
+    for (Object o : col1) {
+      Object other = fastLookup.get(deepHashCode(o));
+      if (other == null) {
+        // Item not even found in other Collection, no need to continue.
+        return false;
+      }
+
+      DualKey dk = new DualKey(path, o, other);
+      if (!visited.contains(dk)) {
+        toCompare.addFirst(dk);
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Deeply compare two SortedMap instances. This method walks the Maps in
+   * order, taking advantage of the fact that the Maps are SortedMaps.
+   * 
+   * @param map1 SortedMap one
+   * @param map2 SortedMap two
+   * @param path the path to the maps to compare
+   * @param toCompare add items to compare to the Stack (Stack versus recursion)
+   * @param visited Set containing items that have already been compared, to
+   *          prevent cycles.
+   * @return false if the Maps are for certain not equals. 'true' indicates
+   *         that 'on the surface' the maps are equal, however, it will place
+   *         the contents of the Maps on the stack for further comparisons.
+   */
+  private static <K1, V1, K2, V2> boolean compareSortedMap(SortedMap<K1, V1> map1, SortedMap<K2, V2> map2,
+                                                           List<String> path, Deque<DualKey> toCompare,
+                                                           Set<DualKey> visited) {
+    if (map1.size() != map2.size()) {
+      return false;
+    }
+
+    Iterator<Map.Entry<K2, V2>> i2 = map2.entrySet().iterator();
+    for (Map.Entry<K1, V1> entry1 : map1.entrySet()) {
+      Map.Entry<K2, V2> entry2 = i2.next();
+
+      // Must split the Key and Value so that Map.Entry's equals() method is not used.
+      DualKey dk = new DualKey(path, entry1.getKey(), entry2.getKey());
+      if (!visited.contains(dk)) {
+        toCompare.addFirst(dk);
+      }
+
+      dk = new DualKey(path, entry1.getValue(), entry2.getValue());
+      if (!visited.contains(dk)) {
+        toCompare.addFirst(dk);
+      }
+    }
+    return true;
+  }
+
+  /**
+   * Deeply compare two Map instances. After quick short-circuit tests, this
+   * method uses a temporary Map so that this method can run in O(N) time.
+   * 
+   * @param map1 Map one
+   * @param map2 Map two
+   * @param path the path to the maps to compare
+   * @param toCompare add items to compare to the Stack (Stack versus recursion)
+   * @param visited Set containing items that have already been compared, to
+   *          prevent cycles.
+   * @return false if the Maps are for certain not equals. 'true' indicates
+   *         that 'on the surface' the maps are equal, however, it will place
+   *         the contents of the Maps on the stack for further comparisons.
+   */
+  private static <K1, V1, K2, V2> boolean compareUnorderedMap(Map<K1, V1> map1, Map<K2, V2> map2,
+                                                              List<String> path, Deque<DualKey> toCompare,
+                                                              Set<DualKey> visited) {
+    if (map1.size() != map2.size()) {
+      return false;
+    }
+
+    Map<Integer, Map.Entry<K2, V2>> fastLookup = new HashMap<>();
+
+    for (Map.Entry<K2, V2> entry : map2.entrySet()) {
+      fastLookup.put(deepHashCode(entry.getKey()), entry);
+    }
+
+    for (Map.Entry<K1, V1> entry : map1.entrySet()) {
+      Map.Entry<K2, V2> other = fastLookup.get(deepHashCode(entry.getKey()));
+      if (other == null) {
+        return false;
+      }
+
+      DualKey dk = new DualKey(path, entry.getKey(), other.getKey());
+      if (!visited.contains(dk)) {
+        toCompare.addFirst(dk);
+      }
+
+      dk = new DualKey(path, entry.getValue(), other.getValue());
+      if (!visited.contains(dk)) {
+        toCompare.addFirst(dk);
+      }
+    }
+
+    return true;
+  }
+
+  /**
+   * Compare if two floating point numbers are within a given range
+   */
+  private static boolean compareFloatingPointNumbers(Object a, Object b, double epsilon) {
+    double a1 = a instanceof Double ? (Double) a : (Float) a;
+    double b1 = b instanceof Double ? (Double) b : (Float) b;
+    return nearlyEqual(a1, b1, epsilon);
+  }
+
+  /**
+   * Correctly handles floating point comparison. (source: http://floating-point-gui.de/errors/comparison/)
+   *
+   * @param a first number
+   * @param b second number
+   * @param epsilon double tolerance value
+   * @return true if a and b are close enough
+   */
+  private static boolean nearlyEqual(double a, double b, double epsilon) {
+    final double absA = Math.abs(a);
+    final double absB = Math.abs(b);
+    final double diff = Math.abs(a - b);
+
+    if (a == b) {
+      // shortcut, handles infinities
+      return true;
+    } else if (a == 0 || b == 0 || diff < Double.MIN_NORMAL) {
+      // a or b is zero or both are extremely close to it
+      // relative error is less meaningful here
+      return diff < (epsilon * Double.MIN_NORMAL);
+    } else { // use relative error
+      return diff / (absA + absB) < epsilon;
+    }
+  }
+
+  /**
+   * Determine if the passed in class has a non-Object.equals() method. This
+   * method caches its results in static ConcurrentHashMap to benefit
+   * execution performance.
+   * 
+   * @param c Class to check.
+   * @return true, if the passed in Class has a .equals() method somewhere
+   *         between itself and just below Object in it's inheritance.
+   */
+  static boolean hasCustomEquals(Class<?> c) {
+    if (customEquals.containsKey(c)) {
+      return customEquals.get(c);
+    }
+
+    Class<?> origClass = c;
+    while (!Object.class.equals(c)) {
+      try {
+        c.getDeclaredMethod("equals", Object.class);
+        customEquals.put(origClass, true);
+        return true;
+      } catch (Exception ignored) {}
+      c = c.getSuperclass();
+    }
+    customEquals.put(origClass, false);
+    return false;
+  }
+
+  /**
+   * Get a deterministic hashCode (int) value for an Object, regardless of
+   * when it was created or where it was loaded into memory. The problem with
+   * java.lang.Object.hashCode() is that it essentially relies on memory
+   * location of an object (what identity it was assigned), whereas this
+   * method will produce the same hashCode for any object graph, regardless of
+   * how many times it is created.<br>
+   * <br>
+   *
+   * This method will handle cycles correctly (A-&gt;B-&gt;C-&gt;A). In this
+   * case, Starting with object A, B, or C would yield the same hashCode. If
+   * an object encountered (root, subobject, etc.) has a hashCode() method on
+   * it (that is not Object.hashCode()), that hashCode() method will be called
+   * and it will stop traversal on that branch.
+   * 
+   * @param obj Object who hashCode is desired.
+   * @return the 'deep' hashCode value for the passed in object.
+   */
+  static int deepHashCode(Object obj) {
+    Set<Object> visited = new HashSet<>();
+    LinkedList<Object> stack = new LinkedList<>();
+    stack.addFirst(obj);
+    int hash = 0;
+
+    while (!stack.isEmpty()) {
+      obj = stack.removeFirst();
+      if (obj == null || visited.contains(obj)) {
+        continue;
+      }
+
+      visited.add(obj);
+
+      if (obj.getClass().isArray()) {
+        int len = Array.getLength(obj);
+        for (int i = 0; i < len; i++) {
+          stack.addFirst(Array.get(obj, i));
+        }
+        continue;
+      }
+
+      if (obj instanceof Collection) {
+        stack.addAll(0, (Collection<?>) obj);
+        continue;
+      }
+
+      if (obj instanceof Map) {
+        stack.addAll(0, ((Map<?, ?>) obj).keySet());
+        stack.addAll(0, ((Map<?, ?>) obj).values());
+        continue;
+      }
+
+      if (obj instanceof Double || obj instanceof Float) {
+        // just take the integral value for hashcode
+        // equality tests things more comprehensively
+        stack.add(Math.round(((Number) obj).doubleValue()));
+        continue;
+      }
+
+      if (hasCustomHashCode(obj.getClass())) {
+        // A real hashCode() method exists, call it.
+        hash += obj.hashCode();
+        continue;
+      }
+
+      Collection<Field> fields = getDeclaredFieldsIncludingInherited(obj.getClass());
+      for (Field field : fields) {
+        stack.addFirst(EXTRACTION.getSimpleValue(field.getName(), obj));
+      }
+    }
+    return hash;
+  }
+
+  /**
+   * Determine if the passed in class has a non-Object.hashCode() method. This
+   * method caches its results in static ConcurrentHashMap to benefit
+   * execution performance.
+   * 
+   * @param c Class to check.
+   * @return true, if the passed in Class has a .hashCode() method somewhere
+   *         between itself and just below Object in it's inheritance.
+   */
+  static boolean hasCustomHashCode(Class<?> c) {
+    Class<?> origClass = c;
+    if (customHash.containsKey(c)) {
+      return customHash.get(c);
+    }
+
+    while (!Object.class.equals(c)) {
+      try {
+        c.getDeclaredMethod("hashCode");
+        customHash.put(origClass, true);
+        return true;
+      } catch (Exception ignored) {}
+      c = c.getSuperclass();
+    }
+    customHash.put(origClass, false);
+    return false;
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Objects.java b/src/main/java/org/assertj/core/internal/Objects.java
index c06f39a55..98c803d58 100644
--- a/src/main/java/org/assertj/core/internal/Objects.java
+++ b/src/main/java/org/assertj/core/internal/Objects.java
@@ -15,6 +15,7 @@ package org.assertj.core.internal;
 import static java.lang.String.format;
 import static java.util.Arrays.asList;
 import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
+import static org.assertj.core.error.ShouldBeEqualByComparingFieldByFieldRecursive.shouldBeEqualByComparingFieldByFieldRecursive;
 import static org.assertj.core.error.ShouldBeEqualByComparingOnlyGivenFields.shouldBeEqualComparingOnlyGivenFields;
 import static org.assertj.core.error.ShouldBeEqualToIgnoringFields.shouldBeEqualToIgnoringGivenFields;
 import static org.assertj.core.error.ShouldBeExactlyInstanceOf.shouldBeExactlyInstance;
@@ -37,6 +38,7 @@ import static org.assertj.core.error.ShouldNotBeOfClassIn.shouldNotBeOfClassIn;
 import static org.assertj.core.error.ShouldNotBeSame.shouldNotBeSame;
 import static org.assertj.core.error.ShouldNotHaveSameClass.shouldNotHaveSameClass;
 import static org.assertj.core.internal.CommonValidations.checkTypeIsNotNull;
+import static org.assertj.core.internal.DeepDifference.determineDifferences;
 import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.Preconditions.checkNotNull;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
@@ -51,6 +53,7 @@ import java.util.Map;
 import java.util.Set;
 
 import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DeepDifference.Difference;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.introspection.FieldSupport;
 import org.assertj.core.util.introspection.IntrospectionError;
@@ -664,6 +667,23 @@ public class Objects {
     return fieldSupport.isAllowedToRead(field) || propertySupport.publicGetterExistsFor(field.getName(), actual);
   }
 
+  /**
+   * Assert that the given object is "deeply" equals to other by comparing all fields recursively.
+   *
+   * @param info contains information about the assertion.
+   * @param actual the given object.
+   * @param other the object to compare {@code actual} to.
+   * @throws AssertionError if actual is {@code null}.
+   * @throws AssertionError if the actual and the given object are not "deeply" equal.
+   */
+  public <A> void assertIsEqualToComparingFieldByFieldRecursively(AssertionInfo info, A actual, A other) {
+    assertNotNull(info, actual);
+    List<Difference> differences = determineDifferences(actual, other);
+    if (!differences.isEmpty()) {
+      throw failures.failure(info, shouldBeEqualByComparingFieldByFieldRecursive(actual, other, differences));
+    }
+  }
+
   /**
    * Get property value first and in case of error try field value.
    * <p>
@@ -685,7 +705,7 @@ public class Objects {
    * @param clazz the class we want the declared fields.
    * @return the declared fields of given class and its superclasses.
    */
-  private static Set<Field> getDeclaredFieldsIncludingInherited(Class<?> clazz) {
+  public static Set<Field> getDeclaredFieldsIncludingInherited(Class<?> clazz) {
     checkNotNull(clazz, "expecting Class parameter not to be null");
     Set<Field> declaredFields = getDeclaredFieldsIgnoringSynthetic(clazz);
     // get fields declared in superclass
diff --git a/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java b/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java
index cf420f92d..c6acee9ff 100644
--- a/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java
@@ -59,7 +59,7 @@ public class PropertyOrFieldSupport {
     return getSimpleValue(propertyOrFieldName, input);
   }
 
-  private Object getSimpleValue(String propertyOrFieldName, Object input) {
+  public Object getSimpleValue(String propertyOrFieldName, Object input) {
     // first try to get given property values from objects, then try fields
     try {
       return propertySupport.propertyValueOf(propertyOrFieldName, Object.class, input);
diff --git a/src/test/java/org/assertj/core/internal/DeepDifference_Test.java b/src/test/java/org/assertj/core/internal/DeepDifference_Test.java
new file mode 100644
index 000000000..5973ddf78
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/DeepDifference_Test.java
@@ -0,0 +1,378 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.lang.Math.E;
+import static java.lang.Math.PI;
+import static java.lang.Math.atan;
+import static java.lang.Math.cos;
+import static java.lang.Math.log;
+import static java.lang.Math.pow;
+import static java.lang.Math.sin;
+import static java.lang.Math.tan;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.LinkedHashMap;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.SortedMap;
+import java.util.SortedSet;
+import java.util.TreeMap;
+import java.util.TreeSet;
+import java.util.concurrent.ConcurrentSkipListMap;
+
+import org.assertj.core.internal.DeepDifference;
+import org.junit.Test;
+
+/**
+ * Based on the deep equals tests of https://github.com/jdereg/java-util
+ * 
+ * @author John DeRegnaucourt
+ * @author sapradhan8
+ * @author Pascal Schumacher
+ */
+public class DeepDifference_Test {
+
+  @Test
+  public void testSameObject() {
+    Date date1 = new Date();
+    Date date2 = date1;
+    assertHaveNoDifferences(date1, date2);
+  }
+
+  @Test
+  public void testEqualsWithNull() {
+    Date date1 = new Date();
+    assertHaveDifferences(null, date1);
+    assertHaveDifferences(date1, null);
+  }
+
+  @Test
+  public void testPOJOequals() {
+    Class1 x = new Class1(true, tan(PI / 4), 1);
+    Class1 y = new Class1(true, 1.0, 1);
+    assertHaveNoDifferences(x, y);
+    assertHaveDifferences(x, new Class1());
+
+    Class2 a = new Class2((float) atan(1.0), "hello", (short) 2, new Class1(false, sin(0.75), 5));
+    Class2 b = new Class2((float) PI / 4, "hello", (short) 2, new Class1(false, 2 * cos(0.75 / 2) * sin(0.75 / 2), 5));
+
+    assertHaveNoDifferences(a, b);
+    assertHaveDifferences(a, new Class2());
+  }
+
+  @Test
+  public void testPrimitiveArrays() {
+    int array1[] = { 2, 4, 5, 6, 3, 1, 3, 3, 5, 22 };
+    int array2[] = { 2, 4, 5, 6, 3, 1, 3, 3, 5, 22 };
+
+    assertHaveNoDifferences(array1, array2);
+
+    int array3[] = { 3, 4, 7 };
+
+    assertHaveDifferences(array1, array3);
+
+    float array4[] = { 3.4f, 5.5f };
+    assertHaveDifferences(array1, array4);
+  }
+
+  @Test
+  public void testOrderedCollection() {
+    List<String> a = newArrayList("one", "two", "three", "four", "five");
+    List<String> b = new LinkedList<String>();
+    b.addAll(a);
+    assertHaveNoDifferences(a, b);
+
+    List<Integer> c = newArrayList(1, 2, 3, 4, 5);
+    assertHaveDifferences(a, c);
+
+    List<Integer> d = newArrayList(4, 6);
+    assertHaveDifferences(c, d);
+
+    List<Class1> x1 = newArrayList(new Class1(true, log(pow(E, 2)), 6), new Class1(true, tan(PI / 4), 1));
+    List<Class1> x2 = newArrayList(new Class1(true, 2, 6), new Class1(true, 1, 1));
+    assertHaveNoDifferences(x1, x2);
+  }
+
+  @Test
+  public void testUnorderedCollection() {
+    Set<String> a = newLinkedHashSet("one", "two", "three", "four", "five");
+    Set<String> b = newLinkedHashSet("three", "five", "one", "four", "two");
+    assertHaveNoDifferences(a, b);
+
+    Set<Integer> c = newLinkedHashSet(1, 2, 3, 4, 5);
+    assertHaveDifferences(a, c);
+
+    Set<Integer> d = newLinkedHashSet(4, 2, 6);
+    assertHaveDifferences(c, d);
+
+    Set<Class1> x1 = newLinkedHashSet(new Class1(true, log(pow(E, 2)), 6), new Class1(true, tan(PI / 4), 1));
+    Set<Class1> x2 = newLinkedHashSet(new Class1(true, 1, 1), new Class1(true, 2, 6));
+    assertHaveNoDifferences(x1, x2);
+  }
+
+  @Test
+  public void testEquivalentMaps() {
+    Map<String, Integer> map1 = new LinkedHashMap<>();
+    fillMap(map1);
+    Map<String, Integer> map2 = new HashMap<>();
+    fillMap(map2);
+    assertHaveNoDifferences(map1, map2);
+    assertThat(DeepDifference.deepHashCode(map1)).isEqualTo(DeepDifference.deepHashCode(map2));
+
+    map1 = new TreeMap<>();
+    fillMap(map1);
+    map2 = new TreeMap<>();
+    map2 = Collections.synchronizedSortedMap((SortedMap<String, Integer>) map2);
+    fillMap(map2);
+    assertHaveNoDifferences(map1, map2);
+    assertThat(DeepDifference.deepHashCode(map1)).isEqualTo(DeepDifference.deepHashCode(map2));
+  }
+
+  @Test
+  public void testInequivalentMaps() {
+    Map<String, Integer> map1 = new TreeMap<>();
+    fillMap(map1);
+    Map<String, Integer> map2 = new HashMap<>();
+    fillMap(map2);
+    // Sorted versus non-sorted Map
+    assertHaveDifferences(map1, map2);
+
+    // Hashcodes are equals because the Maps have same elements
+    assertThat(DeepDifference.deepHashCode(map1)).isEqualTo(DeepDifference.deepHashCode(map2));
+
+    map2 = new TreeMap<>();
+    fillMap(map2);
+    map2.remove("kilo");
+    assertHaveDifferences(map1, map2);
+
+    // Hashcodes are different because contents of maps are different
+    assertThat(DeepDifference.deepHashCode(map1)).isNotEqualTo(DeepDifference.deepHashCode(map2));
+
+    // Inequality because ConcurrentSkipListMap is a SortedMap
+    map1 = new HashMap<>();
+    fillMap(map1);
+    map2 = new ConcurrentSkipListMap<>();
+    fillMap(map2);
+    assertHaveDifferences(map1, map2);
+
+    map1 = new TreeMap<>();
+    fillMap(map1);
+    map2 = new ConcurrentSkipListMap<>();
+    fillMap(map2);
+    assertHaveNoDifferences(map1, map2);
+    map2.remove("papa");
+    assertHaveDifferences(map1, map2);
+  }
+
+  @Test
+  public void testEquivalentCollections() {
+    // ordered Collection
+    Collection<String> col1 = new ArrayList<>();
+    fillCollection(col1);
+    Collection<String> col2 = new LinkedList<>();
+    fillCollection(col2);
+    assertHaveNoDifferences(col1, col2);
+    assertThat(DeepDifference.deepHashCode(col1)).isEqualTo(DeepDifference.deepHashCode(col2));
+
+    // unordered Collections (Set)
+    col1 = new LinkedHashSet<>();
+    fillCollection(col1);
+    col2 = new HashSet<>();
+    fillCollection(col2);
+    assertHaveNoDifferences(col1, col2);
+    assertThat(DeepDifference.deepHashCode(col1)).isEqualTo(DeepDifference.deepHashCode(col2));
+
+    col1 = new TreeSet<>();
+    fillCollection(col1);
+    col2 = new TreeSet<>();
+    Collections.synchronizedSortedSet((SortedSet<String>) col2);
+    fillCollection(col2);
+    assertHaveNoDifferences(col1, col2);
+    assertThat(DeepDifference.deepHashCode(col1)).isEqualTo(DeepDifference.deepHashCode(col2));
+  }
+
+  @Test
+  public void testInequivalentCollections() {
+    Collection<String> col1 = new TreeSet<>();
+    fillCollection(col1);
+    Collection<String> col2 = new HashSet<>();
+    fillCollection(col2);
+    assertHaveDifferences(col1, col2);
+    assertThat(DeepDifference.deepHashCode(col1)).isEqualTo(DeepDifference.deepHashCode(col2));
+
+    col2 = new TreeSet<>();
+    fillCollection(col2);
+    col2.remove("lima");
+    assertHaveDifferences(col1, col2);
+    assertThat(DeepDifference.deepHashCode(col1)).isNotEqualTo(DeepDifference.deepHashCode(col2));
+
+    assertHaveDifferences(new HashMap<>(), new ArrayList<>());
+    assertHaveDifferences(new ArrayList<>(), new HashMap<>());
+  }
+
+  @Test
+  public void testArray() {
+    Object[] a1 = new Object[] { "alpha", "bravo", "charlie", "delta" };
+    Object[] a2 = new Object[] { "alpha", "bravo", "charlie", "delta" };
+
+    assertHaveNoDifferences(a1, a2);
+    assertThat(DeepDifference.deepHashCode(a1)).isEqualTo(DeepDifference.deepHashCode(a2));
+    a2[3] = "echo";
+    assertHaveDifferences(a1, a2);
+    assertThat(DeepDifference.deepHashCode(a1)).isNotEqualTo(DeepDifference.deepHashCode(a2));
+  }
+
+  @Test
+  public void testHasCustomMethod() {
+    assertThat(DeepDifference.hasCustomEquals(EmptyClass.class)).isFalse();
+    assertThat(DeepDifference.hasCustomHashCode(Class1.class)).isFalse();
+
+    assertThat(DeepDifference.hasCustomEquals(EmptyClassWithEquals.class)).isTrue();
+    assertThat(DeepDifference.hasCustomHashCode(EmptyClassWithEquals.class)).isTrue();
+  }
+
+  private void assertHaveNoDifferences(Object x, Object y) {
+    assertThat(DeepDifference.determineDifferences(x, y)).isEmpty();
+  }
+
+  private void assertHaveDifferences(Object x, Object y) {
+    assertThat(DeepDifference.determineDifferences(x, y)).isNotEmpty();
+  }
+
+  private static class EmptyClass {
+  }
+
+  private static class EmptyClassWithEquals {
+
+    public boolean equals(Object obj) {
+      return obj instanceof EmptyClassWithEquals;
+    }
+
+    public int hashCode() {
+      return 0;
+    }
+  }
+
+  private static class Class1 {
+
+    @SuppressWarnings("unused")
+    private boolean b;
+    @SuppressWarnings("unused")
+    private double d;
+    @SuppressWarnings("unused")
+    int i;
+
+    public Class1() {
+    }
+
+    public Class1(boolean b, double d, int i) {
+      super();
+      this.b = b;
+      this.d = d;
+      this.i = i;
+    }
+  }
+
+  private static class Class2 {
+
+    @SuppressWarnings("unused")
+    private Float f;
+    @SuppressWarnings("unused")
+    String s;
+    @SuppressWarnings("unused")
+    short ss;
+    @SuppressWarnings("unused")
+    Class1 c;
+
+    public Class2(float f, String s, short ss, Class1 c) {
+      super();
+      this.f = f;
+      this.s = s;
+      this.ss = ss;
+      this.c = c;
+    }
+
+    public Class2() {
+    }
+  }
+
+  private void fillMap(Map<String, Integer> map) {
+    map.put("zulu", 26);
+    map.put("alpha", 1);
+    map.put("bravo", 2);
+    map.put("charlie", 3);
+    map.put("delta", 4);
+    map.put("echo", 5);
+    map.put("foxtrot", 6);
+    map.put("golf", 7);
+    map.put("hotel", 8);
+    map.put("india", 9);
+    map.put("juliet", 10);
+    map.put("kilo", 11);
+    map.put("lima", 12);
+    map.put("mike", 13);
+    map.put("november", 14);
+    map.put("oscar", 15);
+    map.put("papa", 16);
+    map.put("quebec", 17);
+    map.put("romeo", 18);
+    map.put("sierra", 19);
+    map.put("tango", 20);
+    map.put("uniform", 21);
+    map.put("victor", 22);
+    map.put("whiskey", 23);
+    map.put("xray", 24);
+    map.put("yankee", 25);
+  }
+
+  private void fillCollection(Collection<String> col) {
+    col.add("zulu");
+    col.add("alpha");
+    col.add("bravo");
+    col.add("charlie");
+    col.add("delta");
+    col.add("echo");
+    col.add("foxtrot");
+    col.add("golf");
+    col.add("hotel");
+    col.add("india");
+    col.add("juliet");
+    col.add("kilo");
+    col.add("lima");
+    col.add("mike");
+    col.add("november");
+    col.add("oscar");
+    col.add("papa");
+    col.add("quebec");
+    col.add("romeo");
+    col.add("sierra");
+    col.add("tango");
+    col.add("uniform");
+    col.add("victor");
+    col.add("whiskey");
+    col.add("xray");
+    col.add("yankee");
+  }
+}
diff --git a/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingFieldByFieldRecursive_Test.java b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingFieldByFieldRecursive_Test.java
new file mode 100644
index 000000000..410a6747d
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/objects/Objects_assertIsEqualToComparingFieldByFieldRecursive_Test.java
@@ -0,0 +1,238 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.internal.objects;
+
+import static java.lang.String.format;
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Fail.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.error.ShouldBeEqualByComparingFieldByFieldRecursive.shouldBeEqualByComparingFieldByFieldRecursive;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.mockito.Mockito.verify;
+
+import java.util.Arrays;
+import java.util.List;
+
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.internal.DeepDifference.Difference;
+import org.assertj.core.internal.ObjectsBaseTest;
+import org.junit.Test;
+
+public class Objects_assertIsEqualToComparingFieldByFieldRecursive_Test extends ObjectsBaseTest {
+
+  @Test
+  public void should_be_able_to_compare_objects_recursively() {
+    Person actual = new Person();
+    actual.name = "John";
+    actual.home.address.number = 1;
+
+    Person other = new Person();
+    other.name = "John";
+    other.home.address.number = 1;
+
+    objects.assertIsEqualToComparingFieldByFieldRecursively(someInfo(), actual, other);
+  }
+
+  @Test
+  public void should_be_able_to_compare_objects_of_different_types_recursively() {
+    Person actual = new Person();
+    actual.name = "John";
+    actual.home.address.number = 1;
+
+    Human other = new Human();
+    other.name = "John";
+    other.home.address.number = 1;
+
+    objects.assertIsEqualToComparingFieldByFieldRecursively(someInfo(), actual, other);
+  }
+
+  @Test
+  public void should_be_able_to_compare_objects_with_cyclces_recursively() {
+    Person actual = new Person();
+    actual.name = "John";
+    actual.home.address.number = 1;
+
+    Person other = new Person();
+    other.name = "John";
+    other.home.address.number = 1;
+    other.neighbour = actual;
+
+    actual.neighbour = other;
+
+    objects.assertIsEqualToComparingFieldByFieldRecursively(someInfo(), actual, other);
+  }
+
+  @Test
+  public void should_fail_when_fields_differ() {
+    AssertionInfo info = someInfo();
+
+    Person actual = new Person();
+    actual.name = "John";
+
+    Person other = new Person();
+    other.name = "Jack";
+
+    try {
+      objects.assertIsEqualToComparingFieldByFieldRecursively(info, actual, other);
+    } catch (AssertionError err) {
+      verify(failures).failure(info, shouldBeEqualByComparingFieldByFieldRecursive(actual, other,
+                                                                                   asList(new Difference(asList("name"),
+                                                                                                         "John",
+                                                                                                         "Jack"))));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_when_fields_of_childobjects_differ() {
+    AssertionInfo info = someInfo();
+
+    Person actual = new Person();
+    actual.name = "John";
+    actual.home.address.number = 1;
+
+    Person other = new Person();
+    other.name = "John";
+    other.home.address.number = 2;
+
+    try {
+      objects.assertIsEqualToComparingFieldByFieldRecursively(info, actual, other);
+    } catch (AssertionError err) {
+      verify(failures).failure(info,
+                               shouldBeEqualByComparingFieldByFieldRecursive(actual, other,
+                                                                             asList(new Difference(asList("home.address.number"),
+                                                                                                   "1",
+                                                                                                   "2"))));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_have_error_message_with_differences_and_path_to_differences() {
+    Person actual = new Person();
+    actual.name = "Jack";
+    actual.home.address.number = 1;
+
+    Person other = new Person();
+    other.name = "John";
+    other.home.address.number = 2;
+
+    try {
+      assertThat(actual).isEqualToComparingFieldByFieldRecursively(other);
+      failBecauseExceptionWasNotThrown(AssertionError.class);
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage(format("Expecting:  <%s>%nto be equal to:  <%s>%n", actual, other) +
+                               format("when recursively comparing field by field, but found the following difference(s):%n%n")
+                               +
+                               format("Path to difference:  <home.address.number>%n") +
+                               format("expected:  <2>%n") +
+                               format("but was:  <1>%n%n") +
+                               format("Path to difference:  <name>%n") +
+                               format("expected:  <John>%n") +
+                               format("but was:  <Jack>"));
+    }
+  }
+
+  @Test
+  public void should_have_error_message_with_path_to_difference_when_difference_is_in_collection() {
+    FriendlyPerson actual = new FriendlyPerson();
+    FriendlyPerson friendOfActual = new FriendlyPerson();
+    friendOfActual.home.address.number = 99;
+    actual.friends = Arrays.asList(friendOfActual);
+
+    FriendlyPerson other = new FriendlyPerson();
+    FriendlyPerson friendOfOther = new FriendlyPerson();
+    friendOfOther.home.address.number = 10;
+    other.friends = Arrays.asList(friendOfOther);
+
+    try {
+      assertThat(actual).isEqualToComparingFieldByFieldRecursively(other);
+      failBecauseExceptionWasNotThrown(AssertionError.class);
+    } catch (AssertionError e) {
+      assertThat(e).hasMessage(format("Expecting:  <%s>%nto be equal to:  <%s>%n", actual, other) +
+                               format("when recursively comparing field by field, but found the following difference(s):%n%n")
+                               +
+                               format("Path to difference:  <friends.home.address.number>%n") +
+                               format("expected:  <10>%n") +
+                               format("but was:  <99>"));
+    }
+  }
+
+  @Test
+  public void should_not_use_equal_implemention_of_objects_to_compare() {
+    AssertionInfo info = someInfo();
+
+    EqualPerson actual = new EqualPerson();
+    actual.name = "John";
+    actual.home.address.number = 1;
+
+    EqualPerson other = new EqualPerson();
+    other.name = "John";
+    other.home.address.number = 2;
+
+    try {
+      objects.assertIsEqualToComparingFieldByFieldRecursively(info, actual, other);
+    } catch (AssertionError err) {
+      verify(failures).failure(info,
+                               shouldBeEqualByComparingFieldByFieldRecursive(actual, other,
+                                                                             asList(new Difference(asList("home.address.number"),
+                                                                                                   "1",
+                                                                                                   "2"))));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  public static class Person {
+    public String name;
+    public Home home = new Home();
+    public Person neighbour;
+
+    public String toString() {
+      return "Person [name=" + name + ", home=" + home + "]";
+    }
+  }
+
+  public static class Home {
+    public Address address = new Address();
+
+    public String toString() {
+      return "Home [address=" + address + "]";
+    }
+  }
+
+  public static class Address {
+    public int number = 1;
+
+    public String toString() {
+      return "Address [number=" + number + "]";
+    }
+  }
+
+  public static class Human extends Person {
+  }
+
+  public static class EqualPerson extends Person {
+
+    public boolean equals(Object o) {
+      return true;
+    }
+  }
+
+  public static class FriendlyPerson extends Person {
+    public List<FriendlyPerson> friends;
+  }
+}
