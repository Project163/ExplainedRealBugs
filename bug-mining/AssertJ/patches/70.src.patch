diff --git a/pom.xml b/pom.xml
index f86307f8a..0c1838eec 100644
--- a/pom.xml
+++ b/pom.xml
@@ -11,7 +11,7 @@
   <parent>
     <groupId>org.assertj</groupId>
     <artifactId>assertj-parent-pom</artifactId>
-    <version>1.2.5</version>
+    <version>1.2.6-SNAPSHOT</version>
   </parent>
   <mailingLists>
     <mailingList>
diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index a1227851b..174acadc1 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -29,11 +29,13 @@ import org.assertj.core.groups.FieldsOrPropertiesExtractor;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.ComparisonStrategy;
-import org.assertj.core.internal.FieldByFieldComparisonStrategy;
-import org.assertj.core.internal.IgnoringFieldsComparisonStrategy;
+import org.assertj.core.internal.FieldByFieldComparator;
+import org.assertj.core.internal.IgnoringFieldsComparator;
+import org.assertj.core.internal.IterableElementComparisonStrategy;
 import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.ObjectArrays;
-import org.assertj.core.internal.OnFieldsComparisonStrategy;
+import org.assertj.core.internal.Objects;
+import org.assertj.core.internal.OnFieldsComparator;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.introspection.IntrospectionError;
 
@@ -436,8 +438,11 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * {@inheritDoc}
    */
   @Override
-  public S usingElementComparator(Comparator<? super T> customComparator) {
-	this.iterables = new Iterables(new ComparatorBasedComparisonStrategy(customComparator));
+  public S usingElementComparator(Comparator<? super T> elementComparator) {
+	this.iterables = new Iterables(new ComparatorBasedComparisonStrategy(elementComparator));
+	// to have the same semantics on base assertions like isEqualTo, we need to use an iterable comparator comparing
+	// elements with elementComparator parameter
+	objects = new Objects(new IterableElementComparisonStrategy<T>(elementComparator));
 	return myself;
   }
 
@@ -446,6 +451,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    */
   @Override
   public S usingDefaultElementComparator() {
+	usingDefaultComparator();
 	this.iterables = Iterables.instance();
 	return myself;
   }
@@ -903,13 +909,13 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
   }
 
   /**
-   * Use field by field comparison (including inherited fields) instead of relying on actual type A <code>equals</code>
-   * method to compare group elements for incoming assertion checks.
-   *
+   * Use field/property by field/property comparison (including inherited fields/properties) instead of relying on
+   * actual type A <code>equals</code> method to compare group elements for incoming assertion checks.
+   * </p>
    * This can be handy if <code>equals</code> implementation of objects to compare does not suit you. </p>
    * <p>
-   * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
-   * (e.g. public) or fields with an accessible getter.
+   * Note that only <b>public</b> fields/properties values are compared and the comparison is <b>not</b> recursive, if
+   * one the field is an Object, it will be compared to the other field using its <code>equals</code> method.
    * </p>
    *
    * <pre>
@@ -929,17 +935,18 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return {@code this} assertion object.
    */
   public S usingFieldByFieldElementComparator() {
-	return usingComparisonStrategy(new FieldByFieldComparisonStrategy());
+	return usingElementComparator(new FieldByFieldComparator());
   }
 
   /**
-   * Use field by field comparison on the given fields only (fields can be inherited fields) instead of relying on
-   * actual type A <code>equals</code> method to compare group elements for incoming assertion checks.
-   *
+   * Use field/property by field/property comparison on the given fields/properties only (fields/properties can be
+   * inherited fields) instead of relying on actual type A <code>equals</code> method to compare group elements for
+   * incoming assertion checks.
+   * </p>
    * This can be handy if <code>equals</code> implementation of objects to compare does not suit you. </p>
    * <p>
-   * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
-   * (e.g. public) or fields with an accessible getter.
+   * Note that only <b>public</b> fields/properties values are compared and the comparison is <b>not</b> recursive, if
+   * one the field is an Object, it will be compared to the other field using its <code>equals</code> method.
    * </p>
    *
    * <pre>
@@ -959,7 +966,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return {@code this} assertion object.
    */
   public S usingElementComparatorOnFields(String... fields) {
-	return usingComparisonStrategy(new OnFieldsComparisonStrategy(fields));
+	return usingElementComparator(new OnFieldsComparator(fields));
   }
 
   protected S usingComparisonStrategy(ComparisonStrategy comparisonStrategy) {
@@ -968,14 +975,14 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
   }
 
   /**
-   * Use field by field comparison on all fields except for the given ones (inherited fields are taken into account)
-   * instead of relying on actual type A <code>equals</code> method to compare group elements for incoming assertion
-   * checks.
-   *
+   * Use field/property by field/property comparison on all fields/properties except the given ones (fields/properties can be
+   * inherited fields) instead of relying on actual type A <code>equals</code> method to compare group elements for
+   * incoming assertion checks.
+   * </p>
    * This can be handy if <code>equals</code> implementation of objects to compare does not suit you. </p>
    * <p>
-   * Note that only <b>accessible </b>fields values are compared, accessible fields include directly accessible fields
-   * (e.g. public) or fields with an accessible getter.
+   * Note that only <b>public</b> fields/properties values are compared and the comparison is <b>not</b> recursive, if
+   * one the field is an Object, it will be compared to the other field using its <code>equals</code> method.
    * </p>
    *
    * <pre>
@@ -995,7 +1002,7 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
    * @return {@code this} assertion object.
    */
   public S usingElementComparatorIgnoringFields(String... fields) {
-	return usingComparisonStrategy(new IgnoringFieldsComparisonStrategy(fields));
+	return usingElementComparator(new IgnoringFieldsComparator(fields));
   }
 
   /**
diff --git a/src/main/java/org/assertj/core/api/AbstractListAssert.java b/src/main/java/org/assertj/core/api/AbstractListAssert.java
index e40dc8f58..48423a2c7 100644
--- a/src/main/java/org/assertj/core/api/AbstractListAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractListAssert.java
@@ -152,6 +152,7 @@ public abstract class AbstractListAssert<S extends AbstractListAssert<S, A, T>,
 		return myself;
 	}
 
+    // can't really honor basic assertion consistently with this comparisonStrategy
     @Override
     protected S usingComparisonStrategy(ComparisonStrategy comparisonStrategy) {
         super.usingComparisonStrategy(comparisonStrategy);
diff --git a/src/main/java/org/assertj/core/error/ShouldBeEqual.java b/src/main/java/org/assertj/core/error/ShouldBeEqual.java
index e20d5a7a9..873c445e4 100644
--- a/src/main/java/org/assertj/core/error/ShouldBeEqual.java
+++ b/src/main/java/org/assertj/core/error/ShouldBeEqual.java
@@ -1,17 +1,14 @@
 /*
  * Created on Aug 5, 2010
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
- * with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
- * on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
- * language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2010-2011 the original author or authors.
  */
@@ -29,7 +26,6 @@ import static java.lang.Integer.toHexString;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Objects.*;
 
-
 /**
  * Creates an <code>{@link AssertionError}</code> indicating that an assertion that verifies that two objects are equal
  * failed.
@@ -46,8 +42,8 @@ public class ShouldBeEqual implements AssertionErrorFactory {
 
   private static final String EXPECTED_BUT_WAS_MESSAGE = "\nExpecting:\n <%s>\nto be equal to:\n <%s>\nbut was not.";
   private static final String EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR = "\nExpecting:\n <%s>\nto be equal to:\n " +
-                                                                            "<%s>\n%s but was not.";
-  private static final Class<?>[] MSG_ARG_TYPES = new Class<?>[]{String.class, String.class, String.class};
+	                                                                      "<%s>\n%s but was not.";
+  private static final Class<?>[] MSG_ARG_TYPES = new Class<?>[] { String.class, String.class, String.class };
   protected final Object actual;
   protected final Object expected;
   @VisibleForTesting
@@ -62,44 +58,47 @@ public class ShouldBeEqual implements AssertionErrorFactory {
   /**
    * Creates a new <code>{@link ShouldBeEqual}</code>.
    *
-   * @param actual   the actual value in the failed assertion.
+   * @param actual the actual value in the failed assertion.
    * @param expected the expected value in the failed assertion.
    * @return the created {@code AssertionErrorFactory}.
    */
   public static AssertionErrorFactory shouldBeEqual(Object actual, Object expected, Representation representation) {
-    return new ShouldBeEqual(actual, expected, StandardComparisonStrategy.instance(), representation);
+	return new ShouldBeEqual(actual, expected, StandardComparisonStrategy.instance(), representation);
   }
 
   /**
    * Creates a new <code>{@link ShouldBeEqual}</code>.
    *
-   * @param actual             the actual value in the failed assertion.
-   * @param expected           the expected value in the failed assertion.
+   * @param actual the actual value in the failed assertion.
+   * @param expected the expected value in the failed assertion.
    * @param comparisonStrategy the {@link ComparisonStrategy} used to compare actual with expected.
    * @return the created {@code AssertionErrorFactory}.
    */
   public static AssertionErrorFactory shouldBeEqual(Object actual, Object expected,
-                                                     ComparisonStrategy comparisonStrategy, Representation representation) {
-    return new ShouldBeEqual(actual, expected, comparisonStrategy, representation);
+	                                                ComparisonStrategy comparisonStrategy, Representation representation) {
+	return new ShouldBeEqual(actual, expected, comparisonStrategy, representation);
   }
 
   @VisibleForTesting
   ShouldBeEqual(Object actual, Object expected, ComparisonStrategy comparisonStrategy, Representation representation) {
-    this.actual = actual;
-    this.expected = expected;
-    this.comparisonStrategy = comparisonStrategy;
-    this.representation = representation;
+	this.actual = actual;
+	this.expected = expected;
+	this.comparisonStrategy = comparisonStrategy;
+	this.representation = representation;
   }
 
   /**
    * Creates an <code>{@link AssertionError}</code> indicating that an assertion that verifies that two objects are
-   * equal failed.<br> The <code>{@link AssertionError}</code> message is built so that it differentiates {@link
-   * #actual} and {@link #expected} description in case their string representation are the same (like 42 float and 42
-   * double). <p> If JUnit 4 is in the classpath and the description is standard (no comparator was used and {@link
-   * #actual} and {@link #expected} string representation were differents), this method will instead create a
-   * org.junit.ComparisonFailure that highlights the difference(s) between the expected and actual objects. </p> {@link
-   * AssertionError} stack trace won't show AssertJ related elements if {@link Failures} is configured to filter them
-   * (see {@link Failures#setRemoveAssertJRelatedElementsFromStackTrace(boolean)}).
+   * equal failed.<br>
+   * The <code>{@link AssertionError}</code> message is built so that it differentiates {@link #actual} and
+   * {@link #expected} description in case their string representation are the same (like 42 float and 42 double).
+   * <p>
+   * If JUnit 4 is in the classpath and the description is standard (no comparator was used and {@link #actual} and
+   * {@link #expected} string representation were differents), this method will instead create a
+   * org.junit.ComparisonFailure that highlights the difference(s) between the expected and actual objects.
+   * </p>
+   * {@link AssertionError} stack trace won't show AssertJ related elements if {@link Failures} is configured to filter
+   * them (see {@link Failures#setRemoveAssertJRelatedElementsFromStackTrace(boolean)}).
    *
    * @param description the description of the failed assertion.
    * @param representation
@@ -107,41 +106,29 @@ public class ShouldBeEqual implements AssertionErrorFactory {
    */
   @Override
   public AssertionError newAssertionError(Description description, Representation representation) {
-    if (actualAndExpectedHaveSameStringRepresentation()) {
-      // Example : actual = 42f and expected = 42d gives actual : "42" and expected : "42" and
-      // JUnit 4 manages this case even worst, it will output something like :
-      // "java.lang.String expected:java.lang.String<42.0> but was: java.lang.String<42.0>"
-      // which does not solve the problem and makes things even more confusing since we lost the fact that 42 was a
-      // float or a double, it is then better to built our own description, with the drawback of not using a
-      // ComparisonFailure (which looks nice in eclipse)
-      return Failures.instance().failure(defaultDetailedErrorMessage(description, representation));
-    }
-    // if comparison strategy was based on a custom comparator, we build the assertion error message, the result is
-    // better than the JUnit ComparisonFailure we could build (that would not mention the comparator).
-    if (isJUnitComparisonFailureRelevant()) {
-      // try to build a JUnit ComparisonFailure that offers a nice IDE integration.
-      AssertionError error = comparisonFailure(description);
-      if (error != null) { return error; }
-    }
-    // No JUnit in the classpath => fall back to default error message.
-    return Failures.instance().failure(defaultErrorMessage(description, representation));
-  }
-
-  /**
-   * Tells {@link AssertionErrorFactory#newAssertionError(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)} if it should try a build a {@link org.junit.ComparisonFailure}.<br>
-   * Returns <code>true</code> as we try in this class (may not be the case in subclasses).
-   *
-   * @return <code>true</code>
-   */
-  private boolean isJUnitComparisonFailureRelevant() {
-    // to add comparator description, we can't rely on JUnit ComparisonFailure since it will ignore it.
-    if (comparisonStrategy instanceof ComparatorBasedComparisonStrategy) return false;
-    // we don't care to mention the strategy used => trying to build a JUnit comparison failure is relevant.
-    return true;
+	if (actualAndExpectedHaveSameStringRepresentation()) {
+	  // Example : actual = 42f and expected = 42d gives actual : "42" and expected : "42" and
+	  // JUnit 4 manages this case even worst, it will output something like :
+	  // "java.lang.String expected:java.lang.String<42.0> but was: java.lang.String<42.0>"
+	  // which does not solve the problem and makes things even more confusing since we lost the fact that 42 was a
+	  // float or a double, it is then better to built our own description, with the drawback of not using a
+	  // ComparisonFailure (which looks nice in eclipse)
+	  return Failures.instance().failure(defaultDetailedErrorMessage(description, representation));
+	}
+	// only use JUnit error message if comparison strategy was standard, otherwise we need to mention it in the
+	// assertion error message to make it clear to the user it was used.
+	if (comparisonStrategy.isStandard()) {
+	  // comparison strategy is standard -> try to build a JUnit ComparisonFailure that is nicely dispayed in IDE.
+	  AssertionError error = comparisonFailure(description);
+	  // error ==null means that JUnit was not in the classpath
+	  if (error != null) return error;
+	}
+	// No JUnit in the classpath => fall back to default error message
+	return Failures.instance().failure(defaultErrorMessage(description, representation));
   }
 
   private boolean actualAndExpectedHaveSameStringRepresentation() {
-    return areEqual(representation.toStringOf(actual), representation.toStringOf(expected));
+	return areEqual(representation.toStringOf(actual), representation.toStringOf(expected));
   }
 
   /**
@@ -149,79 +136,84 @@ public class ShouldBeEqual implements AssertionErrorFactory {
    * representation.
    *
    * @param description the {@link Description} used to build the returned error message
-   * @param representation the {@link org.assertj.core.presentation.Representation} used to build String representation of object
+   * @param representation the {@link org.assertj.core.presentation.Representation} used to build String representation
+   *          of object
    * @return the error message from description using {@link #expected} and {@link #actual} basic representation.
    */
   private String defaultErrorMessage(Description description, Representation representation) {
-    if (comparisonStrategy instanceof ComparatorBasedComparisonStrategy)
-      return messageFormatter
-               .format(description, representation, EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR, actual, expected, comparisonStrategy);
-    return messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE, actual, expected);
+	return comparisonStrategy.isStandard() ?
+	    messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE, actual, expected) :
+	    messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR,
+	                            actual, expected, comparisonStrategy);
   }
 
   /**
-   * Builds and returns an error message from description using {@link #detailedExpected()} and {@link
-   * #detailedActual()} detailed representation.
+   * Builds and returns an error message from description using {@link #detailedExpected()} and
+   * {@link #detailedActual()} detailed representation.
    *
    * @param description the {@link Description} used to build the returned error message
-   * @param representation the {@link org.assertj.core.presentation.Representation} used to build String representation of object
+   * @param representation the {@link org.assertj.core.presentation.Representation} used to build String representation
+   *          of object
    * @return the error message from description using {@link #detailedExpected()} and {@link #detailedActual()}
    *         <b>detailed</b> representation.
    */
   private String defaultDetailedErrorMessage(Description description, Representation representation) {
-    if (comparisonStrategy instanceof ComparatorBasedComparisonStrategy)
-      return messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR, detailedActual(),
-                                     detailedExpected(), comparisonStrategy);
-    return messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE, detailedActual(), detailedExpected());
+	if (comparisonStrategy instanceof ComparatorBasedComparisonStrategy)
+	  return messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE_USING_COMPARATOR,
+	                                 detailedActual(),
+	                                 detailedExpected(), comparisonStrategy);
+	return messageFormatter.format(description, representation, EXPECTED_BUT_WAS_MESSAGE, detailedActual(),
+	                               detailedExpected());
   }
 
   private AssertionError comparisonFailure(Description description) {
-    try {
-      AssertionError comparisonFailure = newComparisonFailure(descriptionFormatter.format(description).trim());
-      Failures.instance().removeAssertJRelatedElementsFromStackTraceIfNeeded(comparisonFailure);
-      return comparisonFailure;
-    } catch (Throwable e) {
-      return null;
-    }
+	try {
+	  AssertionError comparisonFailure = newComparisonFailure(descriptionFormatter.format(description).trim());
+	  Failures.instance().removeAssertJRelatedElementsFromStackTraceIfNeeded(comparisonFailure);
+	  return comparisonFailure;
+	} catch (Throwable e) {
+	  return null;
+	}
   }
 
   private AssertionError newComparisonFailure(String description) throws Exception {
-    Object o = constructorInvoker.newInstance("org.junit.ComparisonFailure", MSG_ARG_TYPES, msgArgs(description));
-    if (o instanceof AssertionError) return (AssertionError) o;
-    return null;
+	Object o = constructorInvoker.newInstance("org.junit.ComparisonFailure", MSG_ARG_TYPES, msgArgs(description));
+	if (o instanceof AssertionError) return (AssertionError) o;
+	return null;
   }
 
   private Object[] msgArgs(String description) {
-    return array(description, representation.toStringOf(expected), representation.toStringOf(actual));
+	return array(description, representation.toStringOf(expected), representation.toStringOf(actual));
   }
 
   private String detailedToStringOf(Object obj) {
-    return representation.toStringOf(obj) + " (" + obj.getClass().getSimpleName() + "@" + toHexString(obj.hashCode()) + ")";
+	return representation.toStringOf(obj) + " (" + obj.getClass().getSimpleName() + "@" + toHexString(obj.hashCode())
+	       + ")";
   }
 
   private String detailedActual() {
-    return detailedToStringOf(actual);
+	return detailedToStringOf(actual);
   }
 
   private String detailedExpected() {
-    return detailedToStringOf(expected);
+	return detailedToStringOf(expected);
   }
 
   @Override
   public boolean equals(Object o) {
-    if (this == o) return true;
-    if (o == null) return false;
-    if (getClass() != o.getClass()) return false;
-    ShouldBeEqual other = (ShouldBeEqual) o;
-    if (!areEqual(actual, other.actual)) return false;
-    return areEqual(expected, other.expected);
+	if (this == o) return true;
+	if (o == null) return false;
+	if (getClass() != o.getClass()) return false;
+	ShouldBeEqual other = (ShouldBeEqual) o;
+	if (!areEqual(actual, other.actual)) return false;
+	return areEqual(expected, other.expected);
   }
 
   @Override
   public int hashCode() {
-    int result = 1;
-    result = HASH_CODE_PRIME * result + hashCodeFor(actual);
-    result = HASH_CODE_PRIME * result + hashCodeFor(expected);
-    return result;
+	int result = 1;
+	result = HASH_CODE_PRIME * result + hashCodeFor(actual);
+	result = HASH_CODE_PRIME * result + hashCodeFor(expected);
+	return result;
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java b/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
index f92514570..492d59cf9 100644
--- a/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/AbstractComparisonStrategy.java
@@ -16,7 +16,6 @@ package org.assertj.core.internal;
 
 import static java.lang.reflect.Array.getLength;
 import static java.util.Collections.EMPTY_SET;
-
 import static org.assertj.core.util.Iterables.isNullOrEmpty;
 
 import java.lang.reflect.Array;
@@ -31,60 +30,67 @@ public abstract class AbstractComparisonStrategy implements ComparisonStrategy {
 
   @Override
   public Iterable<?> duplicatesFrom(Iterable<?> iterable) {
-    if (isNullOrEmpty(iterable)) return EMPTY_SET;
+	if (isNullOrEmpty(iterable)) return EMPTY_SET;
 
-    Set<Object> duplicates = newSetUsingComparisonStrategy();
-    Set<Object> noDuplicates = newSetUsingComparisonStrategy();
-    for (Object element : iterable) {
-      if (noDuplicates.contains(element)) {
-        duplicates.add(element);
-      } else {
-        noDuplicates.add(element);
-      }
-    }
-    return duplicates;
+	Set<Object> duplicates = newSetUsingComparisonStrategy();
+	Set<Object> noDuplicates = newSetUsingComparisonStrategy();
+	for (Object element : iterable) {
+	  if (noDuplicates.contains(element)) {
+		duplicates.add(element);
+	  } else {
+		noDuplicates.add(element);
+	  }
+	}
+	return duplicates;
   }
-  
+
   /**
    * Returns a {@link Set} honoring the comparison strategy used.
+   * 
    * @return a {@link Set} honoring the comparison strategy used.
    */
   protected abstract Set<Object> newSetUsingComparisonStrategy();
 
   @Override
   public boolean arrayContains(Object array, Object value) {
-    for (int i = 0; i < getLength(array); i++) {
-      Object element = Array.get(array, i);
-      if (areEqual(element, value)) {
-        return true;
-      }
-    }
-    return false;
+	for (int i = 0; i < getLength(array); i++) {
+	  Object element = Array.get(array, i);
+	  if (areEqual(element, value)) {
+		return true;
+	  }
+	}
+	return false;
   }
 
   @Override
   public boolean isLessThan(Object actual, Object other) {
-    if (areEqual(actual, other)) {
-      return false;
-    }
-    return !isGreaterThan(actual, other);
+	if (areEqual(actual, other)) {
+	  return false;
+	}
+	return !isGreaterThan(actual, other);
   }
 
   @Override
   public boolean isLessThanOrEqualTo(Object actual, Object other) {
-    if (areEqual(actual, other)) {
-      return true;
-    }
-    return isLessThan(actual, other);
+	if (areEqual(actual, other)) {
+	  return true;
+	}
+	return isLessThan(actual, other);
   }
 
   @Override
   public boolean isGreaterThanOrEqualTo(Object actual, Object other) {
-    if (areEqual(actual, other)) {
-      return true;
-    }
-    return isGreaterThan(actual, other);
+	if (areEqual(actual, other)) {
+	  return true;
+	}
+	return isGreaterThan(actual, other);
   }
 
-    public abstract String asText();
+  public abstract String asText();
+  
+  @Override
+  public boolean isStandard() {
+    return false;
+  }
+  
 }
diff --git a/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java b/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
index 8c9710095..5b640d0eb 100644
--- a/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/ComparatorBasedComparisonStrategy.java
@@ -1,27 +1,28 @@
 /*
  * Created on Sep 17, 2010
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2010-2011 the original author or authors.
  */
 package org.assertj.core.internal;
 
 import static org.assertj.core.util.Iterables.isNullOrEmpty;
-import static org.assertj.core.util.Strings.quote;
 
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.Set;
 import java.util.TreeSet;
 
+import org.assertj.core.presentation.StandardRepresentation;
+
 /**
  * Implements {@link ComparisonStrategy} contract with a comparison strategy based on a {@link Comparator}.
  * 
@@ -29,6 +30,9 @@ import java.util.TreeSet;
  */
 public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrategy {
 
+  // stateless => can be shared
+  private static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
+
   // A raw type is necessary because we can't make assumptions on object to be compared.
   @SuppressWarnings("rawtypes")
   private final Comparator comparator;
@@ -36,10 +40,11 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   /**
    * Creates a new </code>{@link ComparatorBasedComparisonStrategy}</code> specifying the comparison strategy with given
    * comparator.
+   * 
    * @param comparator the comparison strategy to use.
    */
   public ComparatorBasedComparisonStrategy(@SuppressWarnings("rawtypes") Comparator comparator) {
-    this.comparator = comparator;
+	this.comparator = comparator;
   }
 
   /**
@@ -53,33 +58,35 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   @Override
   @SuppressWarnings("unchecked")
   public boolean iterableContains(Iterable<?> iterable, Object value) {
-    if (isNullOrEmpty(iterable)) return false;
-    for (Object element : iterable) {
-      // avoid comparison when objects are the same or both null
-      if (element == value) return true;
-      // both objects are not null => if one is then the other is not => compare next element with value
-      if (value == null || element == null) continue;
-      if (comparator.compare(element, value) == 0) return true;
-    }
-    return false;
+	if (isNullOrEmpty(iterable)) return false;
+	for (Object element : iterable) {
+	  // avoid comparison when objects are the same or both null
+	  if (element == value) return true;
+	  // both objects are not null => if one is then the other is not => compare next element with value
+	  if (value == null || element == null) continue;
+	  if (comparator.compare(element, value) == 0) return true;
+	}
+	return false;
   }
 
   /**
-   * Look for given value in given {@link Iterable} according to the {@link Comparator}, if value is found it is removed from it.<br>
+   * Look for given value in given {@link Iterable} according to the {@link Comparator}, if value is found it is removed
+   * from it.<br>
    * Does nothing if given {@link Iterable} is null (meaning no exception thrown).
+   * 
    * @param iterable the {@link Iterable} we want remove value from
    * @param value object to remove from given {@link Iterable}
    */
   @Override
   @SuppressWarnings("unchecked")
   public void iterableRemoves(Iterable<?> iterable, Object value) {
-    if (iterable == null) return;
-    Iterator<?> iterator = iterable.iterator();
-    while (iterator.hasNext()) {
-      if (comparator.compare(iterator.next(), value) == 0) {
-        iterator.remove();
-      }
-    }
+	if (iterable == null) return;
+	Iterator<?> iterator = iterable.iterator();
+	while (iterator.hasNext()) {
+	  if (comparator.compare(iterator.next(), value) == 0) {
+		iterator.remove();
+	  }
+	}
   }
 
   /**
@@ -93,78 +100,82 @@ public class ComparatorBasedComparisonStrategy extends AbstractComparisonStrateg
   @Override
   @SuppressWarnings("unchecked")
   public boolean areEqual(Object actual, Object other) {
-    if (actual == null) return other == null;
-    // actual is not null
-    if (other == null) return false;
-    // neither actual nor other are null
-    return comparator.compare(actual, other) == 0;
+	if (actual == null) return other == null;
+	// actual is not null
+	if (other == null) return false;
+	// neither actual nor other are null
+	return comparator.compare(actual, other) == 0;
   }
 
   /**
    * Returns any duplicate elements from the given {@link Iterable} according to {@link #comparator}.
    * 
    * @param iterable the given {@link Iterable} we want to extract duplicate elements.
-   * @return an {@link Iterable} containing the duplicate elements of the given one. If no duplicates are found, an empty
-   *         {@link Iterable} is returned.
+   * @return an {@link Iterable} containing the duplicate elements of the given one. If no duplicates are found, an
+   *         empty {@link Iterable} is returned.
    */
   // overridden to write javadoc.
   @Override
   public Iterable<?> duplicatesFrom(Iterable<?> iterable) {
-    return super.duplicatesFrom(iterable);
+	return super.duplicatesFrom(iterable);
   }
-  
+
   @SuppressWarnings("unchecked")
   @Override
   protected Set<Object> newSetUsingComparisonStrategy() {
-    return new TreeSet<Object>(comparator);
+	return new TreeSet<Object>(comparator);
   }
 
   @Override
   public String asText() {
-      return "according to " + this + " comparator";
+	return "when comparing values using " + STANDARD_REPRESENTATION.toStringOf(comparator);
+	// return "according to " + this;
   }
 
-    @Override
+  @Override
   public String toString() {
-    String comparatorSimpleClassName = comparator.getClass().getSimpleName();
-    return quote(comparatorSimpleClassName.length() > 0 ? comparatorSimpleClassName : "anonymous comparator class");
+	return STANDARD_REPRESENTATION.toStringOf(comparator);
   }
 
   public Comparator<?> getComparator() {
-    return comparator;
+	return comparator;
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public boolean stringStartsWith(String string, String prefix) {
-    if (string.length() < prefix.length()) return false;
-    String stringPrefix = string.substring(0, prefix.length());
-    return comparator.compare(stringPrefix, prefix) == 0;
+	if (string.length() < prefix.length()) return false;
+	String stringPrefix = string.substring(0, prefix.length());
+	return comparator.compare(stringPrefix, prefix) == 0;
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public boolean stringEndsWith(String string, String suffix) {
-    if (string.length() < suffix.length()) return false;
-    String stringSuffix = string.substring(string.length() - suffix.length());
-    return comparator.compare(stringSuffix, suffix) == 0;
+	if (string.length() < suffix.length()) return false;
+	String stringSuffix = string.substring(string.length() - suffix.length());
+	return comparator.compare(stringSuffix, suffix) == 0;
   }
 
   @Override
   public boolean stringContains(String string, String sequence) {
-    int sequenceLength = sequence.length();
-    for (int i = 0; i < string.length(); i++) {
-      String subString = string.substring(i);
-      if (subString.length() < sequenceLength) return false;
-      if (stringStartsWith(subString, sequence)) return true;
-    }
-    return false;
+	int sequenceLength = sequence.length();
+	for (int i = 0; i < string.length(); i++) {
+	  String subString = string.substring(i);
+	  if (subString.length() < sequenceLength) return false;
+	  if (stringStartsWith(subString, sequence)) return true;
+	}
+	return false;
   }
 
   @Override
   @SuppressWarnings("unchecked")
   public boolean isGreaterThan(Object actual, Object other) {
-    return comparator.compare(actual, other) > 0;
+	return comparator.compare(actual, other) > 0;
   }
 
+  @Override
+  public boolean isStandard() {
+	return false;
+  }
 }
diff --git a/src/main/java/org/assertj/core/internal/ComparisonStrategy.java b/src/main/java/org/assertj/core/internal/ComparisonStrategy.java
index 7e6ff75a2..7b9bdeacf 100644
--- a/src/main/java/org/assertj/core/internal/ComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/ComparisonStrategy.java
@@ -138,5 +138,11 @@ public interface ComparisonStrategy {
    * @return true if string ends with suffix according to the implemented comparison strategy, false otherwise.
    */
   boolean stringEndsWith(String string, String suffix);
+  
+  /**
+   * Return true if comparison strategy is default/standard, false otherwise
+   * @return true if comparison strategy is default/standard, false otherwise
+   */
+  boolean isStandard();
 
 }
diff --git a/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java b/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java
new file mode 100644
index 000000000..79ecf464c
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/FieldByFieldComparator.java
@@ -0,0 +1,33 @@
+package org.assertj.core.internal;
+
+import java.util.Comparator;
+
+/**
+ * Compare Object field by field
+ */
+public class FieldByFieldComparator implements Comparator<Object> {
+
+  private static final int NOT_EQUAL = -1;
+
+  @Override
+  public int compare(Object actual, Object other) {
+	if (actual == null && other == null) return 0;
+	if (actual == null || other == null) return NOT_EQUAL;
+	if (actual == null || other == null) return NOT_EQUAL;
+	// expecting actual and other to be arrays or iterable, compare their elements field by field
+	// sizeOf(actual);
+	if (areEqual(actual, other)) return 0;
+	// value returned is not relevant for ordering but only means that actual and expected are not equal
+	return NOT_EQUAL;
+  }
+
+  protected boolean areEqual(Object actual, Object other) {
+	return Objects.instance().areEqualToIgnoringGivenFields(actual, other);
+  }
+  
+  @Override
+  public String toString() {
+    return "field by field comparator on all fields";
+  }
+
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/internal/FieldByFieldComparisonStrategy.java b/src/main/java/org/assertj/core/internal/FieldByFieldComparisonStrategy.java
index 0ee82702d..eeeb664c1 100644
--- a/src/main/java/org/assertj/core/internal/FieldByFieldComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/FieldByFieldComparisonStrategy.java
@@ -1,15 +1,15 @@
 package org.assertj.core.internal;
 
-public class FieldByFieldComparisonStrategy extends FieldComparisonStrategy {
 
-    @Override
-    protected boolean areFieldsEqual(Object actual, Object other) {
-        return Objects.instance().areEqualToIgnoringGivenFields(actual,other);
-    }
+public class FieldByFieldComparisonStrategy extends ComparatorBasedComparisonStrategy {
 
-    @Override
-    public String asText() {
-        return "when comparing elements field by field (on all field)\n";
-    }
+  public FieldByFieldComparisonStrategy() {
+	super(new FieldByFieldComparator());
+  }
+
+  @Override
+  public String asText() {
+	return "when comparing elements field by field (on all field)\n";
+  }
 
 }
diff --git a/src/main/java/org/assertj/core/internal/FieldByFieldElementComparisonStrategy.java b/src/main/java/org/assertj/core/internal/FieldByFieldElementComparisonStrategy.java
new file mode 100644
index 000000000..63c036233
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/FieldByFieldElementComparisonStrategy.java
@@ -0,0 +1,14 @@
+package org.assertj.core.internal;
+
+
+public class FieldByFieldElementComparisonStrategy extends ComparatorBasedComparisonStrategy {
+
+  public FieldByFieldElementComparisonStrategy() {
+	super(new FieldByFieldComparator());
+  }
+
+  @Override
+  public String toString() {
+	return "'field by field elements'";
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/FieldComparisonStrategy.java b/src/main/java/org/assertj/core/internal/FieldComparisonStrategy.java
deleted file mode 100644
index cb0b184cc..000000000
--- a/src/main/java/org/assertj/core/internal/FieldComparisonStrategy.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package org.assertj.core.internal;
-
-public abstract class FieldComparisonStrategy extends StandardComparisonStrategy {
-
-    @Override
-    public boolean areEqual(Object actual, Object other) {
-        if(actual == null && other == null)
-            return true;
-        if(actual == null || other == null)
-            return false;
-        return actual.getClass().isInstance(other) && areFieldsEqual(actual, other);
-    }
-
-    protected abstract boolean areFieldsEqual(Object actual, Object other);
-}
diff --git a/src/main/java/org/assertj/core/internal/IgnoringFieldsComparator.java b/src/main/java/org/assertj/core/internal/IgnoringFieldsComparator.java
new file mode 100644
index 000000000..7cd464ece
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/IgnoringFieldsComparator.java
@@ -0,0 +1,29 @@
+package org.assertj.core.internal;
+
+import org.assertj.core.presentation.StandardRepresentation;
+import org.assertj.core.util.VisibleForTesting;
+
+public class IgnoringFieldsComparator extends FieldByFieldComparator {
+
+  private String[] fields;
+  private final static StandardRepresentation REPRESENTATION = new StandardRepresentation();
+
+  public IgnoringFieldsComparator(String... fields) {
+      this.fields = fields;
+  }
+  
+  @VisibleForTesting
+  public String[] getFields() {
+	return fields;
+  }
+  
+  @Override
+  protected boolean areEqual(Object actualElement, Object otherElement) {
+    return Objects.instance().areEqualToIgnoringGivenFields(actualElement, otherElement, fields);
+  }
+  
+  @Override
+  public String toString() {
+	return "field by field comparator on all fields but " + REPRESENTATION.toStringOf(fields);
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/IgnoringFieldsComparisonStrategy.java b/src/main/java/org/assertj/core/internal/IgnoringFieldsComparisonStrategy.java
index af0e32abd..5e69521c0 100644
--- a/src/main/java/org/assertj/core/internal/IgnoringFieldsComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/IgnoringFieldsComparisonStrategy.java
@@ -2,31 +2,27 @@ package org.assertj.core.internal;
 
 import org.assertj.core.util.VisibleForTesting;
 
-public class IgnoringFieldsComparisonStrategy extends FieldComparisonStrategy {
+public class IgnoringFieldsComparisonStrategy extends ComparatorBasedComparisonStrategy {
 
-    private String[] fields;
+  private String[] fields;
 
-    public IgnoringFieldsComparisonStrategy(String... fields) {
-        this.fields = fields;
-    }
+  public IgnoringFieldsComparisonStrategy(String... fields) {
+	super(new IgnoringFieldsComparator(fields));
+	this.fields = fields;
+  }
 
-    @Override
-    protected boolean areFieldsEqual(Object actual, Object other) {
-        return Objects.instance().areEqualToIgnoringGivenFields(actual, other, fields);
-    }
+  @VisibleForTesting
+  public String[] getFields() {
+	return fields;
+  }
 
-    @VisibleForTesting
-    public String[] getFields() {
-        return fields;
-    }
+  @Override
+  public String asText() {
+	return "when comparing elements field by field except the following fields : " + fieldsAsText() + "\n";
+  }
 
-    @Override
-    public String asText() {
-        return "when comparing elements field by field except the following fields : " + fieldsAsText() + "\n";
-    }
-
-    private String fieldsAsText() {
-        return org.assertj.core.util.Strings.join(fields).with(", ");
-    }
+  private String fieldsAsText() {
+	return org.assertj.core.util.Strings.join(fields).with(", ");
+  }
 
 }
diff --git a/src/main/java/org/assertj/core/internal/IterableElementComparisonStrategy.java b/src/main/java/org/assertj/core/internal/IterableElementComparisonStrategy.java
new file mode 100644
index 000000000..b52b63354
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/IterableElementComparisonStrategy.java
@@ -0,0 +1,56 @@
+package org.assertj.core.internal;
+
+import static org.assertj.core.util.Iterables.sizeOf;
+
+import java.util.Comparator;
+import java.util.Iterator;
+
+import org.assertj.core.presentation.StandardRepresentation;
+
+public class IterableElementComparisonStrategy<T> extends StandardComparisonStrategy {
+
+  // stateless => can be shared
+  private static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
+
+  private Comparator<? super T> elementComparator;
+
+  public IterableElementComparisonStrategy(Comparator<? super T> elementComparator) {
+	this.elementComparator = elementComparator;
+  }
+
+  @SuppressWarnings("unchecked")
+  @Override
+  public boolean areEqual(Object actual, Object other) {
+	if (actual == null && other == null) return true;
+	if (actual == null || other == null) return false;
+	// expecting actual and other to be iterable<T>
+	return actual instanceof Iterable && other instanceof Iterable
+	       && compareElementsOf((Iterable<T>) actual, (Iterable<T>) other);
+  }
+
+  private boolean compareElementsOf(Iterable<T> actual, Iterable<T> other) {
+	if (sizeOf(actual) != sizeOf(other)) return false;
+	// compare their elements with elementComparator
+	Iterator<T> iterator = other.iterator();
+	for (T actualElement : actual) {
+	  T otherElement = iterator.next();
+	  if (elementComparator.compare(actualElement, otherElement) != 0) return false;
+	}
+	return true;
+  }
+
+  @Override
+  public String toString() {
+	return "IterableElementComparisonStrategy using " + STANDARD_REPRESENTATION.toStringOf(elementComparator);
+  }
+  
+  @Override
+  public String asText() {
+    return "when comparing elements using " + STANDARD_REPRESENTATION.toStringOf(elementComparator);
+  }
+  
+  @Override
+  public boolean isStandard() {
+    return false;
+  }
+}
diff --git a/src/main/java/org/assertj/core/internal/Iterables.java b/src/main/java/org/assertj/core/internal/Iterables.java
index 6ab87d2e0..a574a245c 100644
--- a/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/src/main/java/org/assertj/core/internal/Iterables.java
@@ -519,7 +519,7 @@ public class Iterables {
    * @throws AssertionError if the given {@code Iterable} contains any of given values.
    */
   public <T> void assertDoesNotContainAnyElementsOf(AssertionInfo info, Iterable<T> actual,
-      Iterable<? extends T> iterable) {
+                                                    Iterable<? extends T> iterable) {
     checkIsNotNullAndNotEmpty(iterable);
     List<T> values = newArrayList(iterable);
     assertDoesNotContain(info, actual, values.toArray());
@@ -758,7 +758,7 @@ public class Iterables {
    * @throws AssertionError if the number of elements satisfying the given condition is &lt; n.
    */
   public <E> void assertAreAtLeast(AssertionInfo info, Iterable<? extends E> actual, int times,
-      Condition<? super E> condition) {
+                                   Condition<? super E> condition) {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
@@ -771,7 +771,7 @@ public class Iterables {
   }
 
   private <E> boolean conditionIsSatisfiedAtLeastNTimes(Iterable<? extends E> actual, int n,
-      Condition<? super E> condition) {
+                                                        Condition<? super E> condition) {
     List<E> satisfiesCondition = satisfiesCondition(actual, condition);
     return satisfiesCondition.size() >= n;
   }
@@ -789,7 +789,7 @@ public class Iterables {
    * @throws AssertionError if the number of elements satisfying the given condition is &gt; n.
    */
   public <E> void assertAreAtMost(AssertionInfo info, Iterable<? extends E> actual, int n,
-      Condition<? super E> condition) {
+                                  Condition<? super E> condition) {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
@@ -802,7 +802,7 @@ public class Iterables {
   }
 
   private <E> boolean conditionIsSatisfiedAtMostNTimes(Iterable<? extends E> actual, Condition<? super E> condition,
-      int n) {
+                                                       int n) {
     List<E> satisfiesCondition = satisfiesCondition(actual, condition);
     return satisfiesCondition.size() <= n;
   }
@@ -820,7 +820,7 @@ public class Iterables {
    * @throws AssertionError if the number of elements satisfying the given condition is &ne; n.
    */
   public <E> void assertAreExactly(AssertionInfo info, Iterable<? extends E> actual, int times,
-      Condition<? super E> condition) {
+                                   Condition<? super E> condition) {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
@@ -842,7 +842,7 @@ public class Iterables {
    * api (same logic, only error message differs).
    */
   public <E> void assertHaveAtLeast(AssertionInfo info, Iterable<? extends E> actual, int times,
-      Condition<? super E> condition) {
+                                    Condition<? super E> condition) {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
@@ -859,7 +859,7 @@ public class Iterables {
    * (same logic, only error message differs).
    */
   public <E> void assertHaveAtMost(AssertionInfo info, Iterable<? extends E> actual, int times,
-      Condition<? super E> condition) {
+                                   Condition<? super E> condition) {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
@@ -876,7 +876,7 @@ public class Iterables {
    * api (same logic, only error message differs).
    */
   public <E> void assertHaveExactly(AssertionInfo info, Iterable<? extends E> actual, int times,
-      Condition<? super E> condition) {
+                                    Condition<? super E> condition) {
     assertNotNull(info, actual);
     conditions.assertIsNotNull(condition);
     try {
@@ -974,8 +974,8 @@ public class Iterables {
     return new IllegalArgumentException("The iterable to look for should not be empty");
   }
 
-    @VisibleForTesting
-    public ComparisonStrategy getComparisonStrategy() {
-        return comparisonStrategy;
-    }
+  @VisibleForTesting
+  public ComparisonStrategy getComparisonStrategy() {
+    return comparisonStrategy;
+  }
 }
diff --git a/src/main/java/org/assertj/core/internal/Objects.java b/src/main/java/org/assertj/core/internal/Objects.java
index 376bc162e..f6bb87016 100644
--- a/src/main/java/org/assertj/core/internal/Objects.java
+++ b/src/main/java/org/assertj/core/internal/Objects.java
@@ -16,13 +16,13 @@ package org.assertj.core.internal;
 
 import static java.lang.String.format;
 import static org.assertj.core.error.ShouldBeEqual.shouldBeEqual;
+import static org.assertj.core.error.ShouldBeEqualByComparingOnlyGivenFields.shouldBeEqualComparingOnlyGivenFields;
+import static org.assertj.core.error.ShouldBeEqualToIgnoringFields.shouldBeEqualToIgnoringGivenFields;
 import static org.assertj.core.error.ShouldBeExactlyInstanceOf.shouldBeExactlyInstance;
 import static org.assertj.core.error.ShouldBeIn.shouldBeIn;
 import static org.assertj.core.error.ShouldBeInstance.shouldBeInstance;
 import static org.assertj.core.error.ShouldBeInstance.shouldBeInstanceButWasNull;
 import static org.assertj.core.error.ShouldBeInstanceOfAny.shouldBeInstanceOfAny;
-import static org.assertj.core.error.ShouldBeEqualByComparingOnlyGivenFields.shouldBeEqualComparingOnlyGivenFields;
-import static org.assertj.core.error.ShouldBeEqualToIgnoringFields.shouldBeEqualToIgnoringGivenFields;
 import static org.assertj.core.error.ShouldBeOfClassIn.shouldBeOfClassIn;
 import static org.assertj.core.error.ShouldBeSame.shouldBeSame;
 import static org.assertj.core.error.ShouldHaveSameClass.shouldHaveSameClass;
@@ -36,10 +36,11 @@ import static org.assertj.core.error.ShouldNotBeOfClassIn.shouldNotBeOfClassIn;
 import static org.assertj.core.error.ShouldNotBeSame.shouldNotBeSame;
 import static org.assertj.core.error.ShouldNotHaveSameClass.shouldNotHaveSameClass;
 import static org.assertj.core.internal.CommonValidations.checkTypeIsNotNull;
-import static org.assertj.core.util.Lists.*;
-import static org.assertj.core.util.Sets.*;
+import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
 
 import java.lang.reflect.Field;
+import java.util.ArrayList;
 import java.util.Comparator;
 import java.util.LinkedList;
 import java.util.List;
@@ -72,22 +73,27 @@ public class Objects {
    * @return the singleton instance of this class based on {@link StandardComparisonStrategy}.
    */
   public static Objects instance() {
-    return INSTANCE;
+	return INSTANCE;
   }
 
   @VisibleForTesting
   Objects() {
-    this(StandardComparisonStrategy.instance());
+	this(StandardComparisonStrategy.instance());
   }
 
   public Objects(ComparisonStrategy comparisonStrategy) {
-    this.comparisonStrategy = comparisonStrategy;
+	this.comparisonStrategy = comparisonStrategy;
   }
 
   @VisibleForTesting
   public Comparator<?> getComparator() {
-    return comparisonStrategy instanceof ComparatorBasedComparisonStrategy ?
-      ((ComparatorBasedComparisonStrategy) comparisonStrategy).getComparator() : null;
+	return comparisonStrategy instanceof ComparatorBasedComparisonStrategy ?
+	    ((ComparatorBasedComparisonStrategy) comparisonStrategy).getComparator() : null;
+  }
+
+  @VisibleForTesting
+  public ComparisonStrategy getComparisonStrategy() {
+	return comparisonStrategy;
   }
 
   /**
@@ -101,7 +107,7 @@ public class Objects {
    * @throws AssertionError if the given object is not an instance of the given type.
    */
   public void assertIsInstanceOf(AssertionInfo info, Object actual, Class<?> type) {
-    if (!isInstanceOfClass(actual, type, info)) throw failures.failure(info, shouldBeInstance(actual, type));
+	if (!isInstanceOfClass(actual, type, info)) throw failures.failure(info, shouldBeInstance(actual, type));
   }
 
   /**
@@ -117,23 +123,23 @@ public class Objects {
    * @throws AssertionError if the given object is not an instance of any of the given types.
    */
   public void assertIsInstanceOfAny(AssertionInfo info, Object actual, Class<?>[] types) {
-    if (objectIsInstanceOfOneOfGivenClasses(actual, types, info)) return;
-    throw failures.failure(info, shouldBeInstanceOfAny(actual, types));
+	if (objectIsInstanceOfOneOfGivenClasses(actual, types, info)) return;
+	throw failures.failure(info, shouldBeInstanceOfAny(actual, types));
   }
 
   private boolean objectIsInstanceOfOneOfGivenClasses(Object actual, Class<?>[] types, AssertionInfo info) {
-    checkIsNotNullAndIsNotEmpty(types);
-    assertNotNull(info, actual);
-    for (Class<?> type : types) {
-      if (type == null) {
-        String format = "The given array of types:<%s> should not have null elements";
-        throw new NullPointerException(format(format, info.representation().toStringOf(types)));
-      }
-      if (type.isInstance(actual)) {
-        return true;
-      }
-    }
-    return false;
+	checkIsNotNullAndIsNotEmpty(types);
+	assertNotNull(info, actual);
+	for (Class<?> type : types) {
+	  if (type == null) {
+		String format = "The given array of types:<%s> should not have null elements";
+		throw new NullPointerException(format(format, info.representation().toStringOf(types)));
+	  }
+	  if (type.isInstance(actual)) {
+		return true;
+	  }
+	}
+	return false;
   }
 
   /**
@@ -147,13 +153,13 @@ public class Objects {
    * @throws AssertionError if the given object is an instance of the given type.
    */
   public void assertIsNotInstanceOf(AssertionInfo info, Object actual, Class<?> type) {
-    if (isInstanceOfClass(actual, type, info)) throw failures.failure(info, shouldNotBeInstance(actual, type));
+	if (isInstanceOfClass(actual, type, info)) throw failures.failure(info, shouldNotBeInstance(actual, type));
   }
 
   private boolean isInstanceOfClass(Object actual, Class<?> clazz, AssertionInfo info) {
-    assertNotNull(info, actual);
-    checkTypeIsNotNull(clazz);
-    return clazz.isInstance(actual);
+	assertNotNull(info, actual);
+	checkTypeIsNotNull(clazz);
+	return clazz.isInstance(actual);
   }
 
   /**
@@ -169,8 +175,8 @@ public class Objects {
    * @throws AssertionError if the given object is an instance of any of the given types.
    */
   public void assertIsNotInstanceOfAny(AssertionInfo info, Object actual, Class<?>[] types) {
-    if (!objectIsInstanceOfOneOfGivenClasses(actual, types, info)) return;
-    throw failures.failure(info, shouldNotBeInstanceOfAny(actual, types));
+	if (!objectIsInstanceOfOneOfGivenClasses(actual, types, info)) return;
+	throw failures.failure(info, shouldNotBeInstanceOfAny(actual, types));
   }
 
   /**
@@ -183,17 +189,17 @@ public class Objects {
    * @throws NullPointerException if the given object is null.
    */
   public void assertHasSameClassAs(AssertionInfo info, Object actual, Object other) {
-    if (!haveSameClass(actual, other, info)) throw failures.failure(info, shouldHaveSameClass(actual, other));
+	if (!haveSameClass(actual, other, info)) throw failures.failure(info, shouldHaveSameClass(actual, other));
   }
 
   private boolean haveSameClass(Object actual, Object other, AssertionInfo info) {
-    assertNotNull(info, actual);
-    if (other == null) {
-      throw new NullPointerException("The given object should not be null");
-    }
-    Class<?> actualClass = actual.getClass();
-    Class<?> otherClass = other.getClass();
-    return actualClass.equals(otherClass);
+	assertNotNull(info, actual);
+	if (other == null) {
+	  throw new NullPointerException("The given object should not be null");
+	}
+	Class<?> actualClass = actual.getClass();
+	Class<?> otherClass = other.getClass();
+	return actualClass.equals(otherClass);
   }
 
   /**
@@ -207,7 +213,7 @@ public class Objects {
    * @throws NullPointerException if the given object is null.
    */
   public void assertDoesNotHaveSameClassAs(AssertionInfo info, Object actual, Object other) {
-    if (haveSameClass(actual, other, info)) throw failures.failure(info, shouldNotHaveSameClass(actual, other));
+	if (haveSameClass(actual, other, info)) throw failures.failure(info, shouldNotHaveSameClass(actual, other));
   }
 
   /**
@@ -221,14 +227,14 @@ public class Objects {
    * @throws NullPointerException if the given object is null.
    */
   public void assertIsExactlyInstanceOf(AssertionInfo info, Object actual, Class<?> type) {
-    if (!actualIsExactlyInstanceOfType(actual, type, info))
-      throw failures.failure(info, shouldBeExactlyInstance(actual, type));
+	if (!actualIsExactlyInstanceOfType(actual, type, info))
+	  throw failures.failure(info, shouldBeExactlyInstance(actual, type));
   }
 
   private boolean actualIsExactlyInstanceOfType(Object actual, Class<?> expectedType, AssertionInfo info) {
-    assertNotNull(info, actual);
-    checkTypeIsNotNull(expectedType);
-    return expectedType.equals(actual.getClass());
+	assertNotNull(info, actual);
+	checkTypeIsNotNull(expectedType);
+	return expectedType.equals(actual.getClass());
   }
 
   /**
@@ -242,8 +248,8 @@ public class Objects {
    * @throws NullPointerException if the given object is null.
    */
   public void assertIsNotExactlyInstanceOf(AssertionInfo info, Object actual, Class<?> type) {
-    if (actualIsExactlyInstanceOfType(actual, type, info))
-      throw failures.failure(info, shouldNotBeExactlyInstance(actual, type));
+	if (actualIsExactlyInstanceOfType(actual, type, info))
+	  throw failures.failure(info, shouldNotBeExactlyInstance(actual, type));
   }
 
   /**
@@ -257,14 +263,14 @@ public class Objects {
    * @throws NullPointerException if the given types is null.
    */
   public void assertIsOfAnyClassIn(AssertionInfo info, Object actual, Class<?>[] types) {
-    boolean itemInArray = isOfOneOfGivenTypes(actual, types, info);
-    if (!itemInArray) throw failures.failure(info, shouldBeOfClassIn(actual, types));
+	boolean itemInArray = isOfOneOfGivenTypes(actual, types, info);
+	if (!itemInArray) throw failures.failure(info, shouldBeOfClassIn(actual, types));
   }
 
   private boolean isOfOneOfGivenTypes(Object actual, Class<?>[] types, AssertionInfo info) {
-    assertNotNull(info, actual);
-    if (types == null) throw new NullPointerException("The given types should not be null");
-    return isItemInArray(actual.getClass(), types);
+	assertNotNull(info, actual);
+	if (types == null) throw new NullPointerException("The given types should not be null");
+	return isItemInArray(actual.getClass(), types);
   }
 
   /**
@@ -278,17 +284,17 @@ public class Objects {
    * @throws NullPointerException if the given types is null.
    */
   public void assertIsNotOfAnyClassIn(AssertionInfo info, Object actual, Class<?>[] types) {
-    boolean itemInArray = isOfOneOfGivenTypes(actual, types, info);
-    if (itemInArray) throw failures.failure(info, shouldNotBeOfClassIn(actual, types));
+	boolean itemInArray = isOfOneOfGivenTypes(actual, types, info);
+	if (itemInArray) throw failures.failure(info, shouldNotBeOfClassIn(actual, types));
   }
 
   private void checkIsNotNullAndIsNotEmpty(Class<?>[] types) {
-    if (types == null) {
-      throw new NullPointerException("The given array of types should not be null");
-    }
-    if (types.length == 0) {
-      throw new IllegalArgumentException("The given array of types should not be empty");
-    }
+	if (types == null) {
+	  throw new NullPointerException("The given array of types should not be null");
+	}
+	if (types.length == 0) {
+	  throw new IllegalArgumentException("The given array of types should not be empty");
+	}
   }
 
   /**
@@ -302,10 +308,10 @@ public class Objects {
    *           equal.
    */
   public void assertEqual(AssertionInfo info, Object actual, Object expected) {
-    if (areEqual(actual, expected)) {
-      return;
-    }
-    throw failures.failure(info, shouldBeEqual(actual, expected, comparisonStrategy, info.representation()));
+	if (areEqual(actual, expected)) {
+	  return;
+	}
+	throw failures.failure(info, shouldBeEqual(actual, expected, comparisonStrategy, info.representation()));
   }
 
   /**
@@ -317,10 +323,10 @@ public class Objects {
    * @throws AssertionError if {@code actual} is equal to {@code other}.
    */
   public void assertNotEqual(AssertionInfo info, Object actual, Object other) {
-    if (!areEqual(actual, other)) {
-      return;
-    }
-    throw failures.failure(info, shouldNotBeEqual(actual, other, comparisonStrategy));
+	if (!areEqual(actual, other)) {
+	  return;
+	}
+	throw failures.failure(info, shouldNotBeEqual(actual, other, comparisonStrategy));
   }
 
   /**
@@ -331,7 +337,7 @@ public class Objects {
    * @return true if actual and other are equal (null safe equals check), false otherwise.
    */
   private boolean areEqual(Object actual, Object other) {
-    return comparisonStrategy.areEqual(actual, other);
+	return comparisonStrategy.areEqual(actual, other);
   }
 
   /**
@@ -342,10 +348,10 @@ public class Objects {
    * @throws AssertionError if the given object is not {@code null}.
    */
   public void assertNull(AssertionInfo info, Object actual) {
-    if (actual == null) {
-      return;
-    }
-    throw failures.failure(info, shouldBeEqual(actual, null, comparisonStrategy, info.representation()));
+	if (actual == null) {
+	  return;
+	}
+	throw failures.failure(info, shouldBeEqual(actual, null, comparisonStrategy, info.representation()));
   }
 
   /**
@@ -356,10 +362,10 @@ public class Objects {
    * @throws AssertionError if the given object is {@code null}.
    */
   public void assertNotNull(AssertionInfo info, Object actual) {
-    if (actual != null) {
-      return;
-    }
-    throw failures.failure(info, shouldNotBeNull());
+	if (actual != null) {
+	  return;
+	}
+	throw failures.failure(info, shouldNotBeNull());
   }
 
   /**
@@ -371,10 +377,10 @@ public class Objects {
    * @throws AssertionError if the given objects do not refer to the same object.
    */
   public void assertSame(AssertionInfo info, Object actual, Object expected) {
-    if (actual == expected) {
-      return;
-    }
-    throw failures.failure(info, shouldBeSame(actual, expected));
+	if (actual == expected) {
+	  return;
+	}
+	throw failures.failure(info, shouldBeSame(actual, expected));
   }
 
   /**
@@ -386,10 +392,10 @@ public class Objects {
    * @throws AssertionError if the given objects refer to the same object.
    */
   public void assertNotSame(AssertionInfo info, Object actual, Object other) {
-    if (actual != other) {
-      return;
-    }
-    throw failures.failure(info, shouldNotBeSame(actual));
+	if (actual != other) {
+	  return;
+	}
+	throw failures.failure(info, shouldNotBeSame(actual));
   }
 
   /**
@@ -403,12 +409,12 @@ public class Objects {
    * @throws AssertionError if the given object is not present in the given array.
    */
   public void assertIsIn(AssertionInfo info, Object actual, Object[] values) {
-    checkIsNotNullAndNotEmpty(values);
-    assertNotNull(info, actual);
-    if (isItemInArray(actual, values)) {
-      return;
-    }
-    throw failures.failure(info, shouldBeIn(actual, values, comparisonStrategy));
+	checkIsNotNullAndNotEmpty(values);
+	assertNotNull(info, actual);
+	if (isItemInArray(actual, values)) {
+	  return;
+	}
+	throw failures.failure(info, shouldBeIn(actual, values, comparisonStrategy));
   }
 
   /**
@@ -422,21 +428,21 @@ public class Objects {
    * @throws AssertionError if the given object is present in the given array.
    */
   public void assertIsNotIn(AssertionInfo info, Object actual, Object[] values) {
-    checkIsNotNullAndNotEmpty(values);
-    assertNotNull(info, actual);
-    if (!isItemInArray(actual, values)) {
-      return;
-    }
-    throw failures.failure(info, shouldNotBeIn(actual, values, comparisonStrategy));
+	checkIsNotNullAndNotEmpty(values);
+	assertNotNull(info, actual);
+	if (!isItemInArray(actual, values)) {
+	  return;
+	}
+	throw failures.failure(info, shouldNotBeIn(actual, values, comparisonStrategy));
   }
 
   private void checkIsNotNullAndNotEmpty(Object[] values) {
-    if (values == null) {
-      throw new NullPointerException("The given array should not be null");
-    }
-    if (values.length == 0) {
-      throw new IllegalArgumentException("The given array should not be empty");
-    }
+	if (values == null) {
+	  throw new NullPointerException("The given array should not be null");
+	}
+	if (values.length == 0) {
+	  throw new IllegalArgumentException("The given array should not be empty");
+	}
   }
 
   /**
@@ -447,10 +453,10 @@ public class Objects {
    * @return <code>true</code> if given item is in given array, <code>false</code> otherwise.
    */
   private boolean isItemInArray(Object item, Object[] arrayOfValues) {
-    for (Object value : arrayOfValues) {
-      if (areEqual(value, item)) return true;
-    }
-    return false;
+	for (Object value : arrayOfValues) {
+	  if (areEqual(value, item)) return true;
+	}
+	return false;
   }
 
   /**
@@ -464,12 +470,12 @@ public class Objects {
    * @throws AssertionError if the given object is not present in the given collection.
    */
   public void assertIsIn(AssertionInfo info, Object actual, Iterable<?> values) {
-    checkIsNotNullAndNotEmpty(values);
-    assertNotNull(info, actual);
-    if (isActualIn(actual, values)) {
-      return;
-    }
-    throw failures.failure(info, shouldBeIn(actual, values, comparisonStrategy));
+	checkIsNotNullAndNotEmpty(values);
+	assertNotNull(info, actual);
+	if (isActualIn(actual, values)) {
+	  return;
+	}
+	throw failures.failure(info, shouldBeIn(actual, values, comparisonStrategy));
   }
 
   /**
@@ -483,30 +489,30 @@ public class Objects {
    * @throws AssertionError if the given object is present in the given collection.
    */
   public void assertIsNotIn(AssertionInfo info, Object actual, Iterable<?> values) {
-    checkIsNotNullAndNotEmpty(values);
-    assertNotNull(info, actual);
-    if (!isActualIn(actual, values)) {
-      return;
-    }
-    throw failures.failure(info, shouldNotBeIn(actual, values, comparisonStrategy));
+	checkIsNotNullAndNotEmpty(values);
+	assertNotNull(info, actual);
+	if (!isActualIn(actual, values)) {
+	  return;
+	}
+	throw failures.failure(info, shouldNotBeIn(actual, values, comparisonStrategy));
   }
 
   private void checkIsNotNullAndNotEmpty(Iterable<?> values) {
-    if (values == null) {
-      throw new NullPointerException("The given iterable should not be null");
-    }
-    if (!values.iterator().hasNext()) {
-      throw new IllegalArgumentException("The given iterable should not be empty");
-    }
+	if (values == null) {
+	  throw new NullPointerException("The given iterable should not be null");
+	}
+	if (!values.iterator().hasNext()) {
+	  throw new IllegalArgumentException("The given iterable should not be empty");
+	}
   }
 
   private boolean isActualIn(Object actual, Iterable<?> values) {
-    for (Object value : values) {
-      if (areEqual(value, actual)) {
-        return true;
-      }
-    }
-    return false;
+	for (Object value : values) {
+	  if (areEqual(value, actual)) {
+		return true;
+	  }
+	}
+	return false;
   }
 
   /**
@@ -522,31 +528,33 @@ public class Objects {
    * @throws AssertionError if the other object is not an instance of the actual type.
    */
   public <A> void assertIsLenientEqualsToIgnoringNullFields(AssertionInfo info, A actual, A other) {
-    assertNotNull(info, actual);
-    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
-    List<String> fieldsNames = new LinkedList<String>();
-    List<Object> rejectedValues = new LinkedList<Object>();
-    List<Object> expectedValues = new LinkedList<Object>();
-    List<String> nullFields = new LinkedList<String>();
-    for (Field field : getDeclaredFieldsIncludingInherited(actual.getClass())) {
-      try {
-        Object otherFieldValue = getFieldOrPropertyValue(other, field);
-        if (otherFieldValue == null) {
-          nullFields.add(field.getName());
-        } else {
-          Object actualFieldValue = getFieldOrPropertyValue(actual, field);
-          if (!otherFieldValue.equals(actualFieldValue)) {
-            fieldsNames.add(field.getName());
-            rejectedValues.add(actualFieldValue);
-            expectedValues.add(otherFieldValue);
-          }
-        }
-      } catch (IntrospectionError e) {
-        // Not readable field, skip.
-      }
-    }
-    if (!fieldsNames.isEmpty())
-      throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, fieldsNames, rejectedValues, expectedValues, nullFields));
+	assertNotNull(info, actual);
+	assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
+	List<String> fieldsNames = new LinkedList<String>();
+	List<Object> rejectedValues = new LinkedList<Object>();
+	List<Object> expectedValues = new LinkedList<Object>();
+	List<String> nullFields = new LinkedList<String>();
+	for (Field field : getDeclaredFieldsIncludingInherited(actual.getClass())) {
+	  try {
+		Object otherFieldValue = getFieldOrPropertyValue(other, field);
+		if (otherFieldValue == null) {
+		  nullFields.add(field.getName());
+		} else {
+		  Object actualFieldValue = getFieldOrPropertyValue(actual, field);
+		  if (!otherFieldValue.equals(actualFieldValue)) {
+			fieldsNames.add(field.getName());
+			rejectedValues.add(actualFieldValue);
+			expectedValues.add(otherFieldValue);
+		  }
+		}
+	  } catch (IntrospectionError e) {
+		// Not readable field, skip.
+	  }
+	}
+	if (!fieldsNames.isEmpty())
+	  throw failures.failure(info,
+	                         shouldBeEqualToIgnoringGivenFields(actual, fieldsNames, rejectedValues, expectedValues,
+	                                                            nullFields));
   }
 
   /**
@@ -563,38 +571,39 @@ public class Objects {
    * @throws IntrospectionError if a field does not exist in actual.
    */
   public <A> void assertIsEqualToComparingOnlyGivenFields(AssertionInfo info, A actual, A other, String... fields) {
-    assertNotNull(info, actual);
-    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
-    ByFieldsComparison byFieldsComparison = isEqualToComparingOnlyGivenFields(actual, other, fields);
-    if (byFieldsComparison.isFieldsNamesNotEmpty())
-      throw failures.failure(info, shouldBeEqualComparingOnlyGivenFields(actual, byFieldsComparison.fieldsNames,
-                                                                         byFieldsComparison.rejectedValues,
-                                                                         byFieldsComparison.expectedValues,
-                                                                         newArrayList(fields)));
+	assertNotNull(info, actual);
+	assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
+	ByFieldsComparison byFieldsComparison = isEqualToComparingOnlyGivenFields(actual, other, fields);
+	if (byFieldsComparison.isFieldsNamesNotEmpty())
+	  throw failures.failure(info, shouldBeEqualComparingOnlyGivenFields(actual, byFieldsComparison.fieldsNames,
+	                                                                     byFieldsComparison.rejectedValues,
+	                                                                     byFieldsComparison.expectedValues,
+	                                                                     newArrayList(fields)));
   }
 
   private <A> ByFieldsComparison isEqualToComparingOnlyGivenFields(A actual, A other, String[] fields) {
-    List<String> rejectedFieldsNames = new LinkedList<String>();
-    List<Object> expectedValues = new LinkedList<Object>();
-    List<Object> rejectedValues = new LinkedList<Object>();
-    final Set<Field> declaredFieldsIncludingInherited = getDeclaredFieldsIncludingInherited(actual.getClass());
-    for (String fieldName : fields) {
-      Object actualFieldValue = getFieldOrPropertyValue(actual, findField(fieldName,
-                                                                          declaredFieldsIncludingInherited,
-                                                                          actual.getClass()));
-      Object otherFieldValue = getFieldOrPropertyValue(other, findField(fieldName, declaredFieldsIncludingInherited,
-                                                                        other.getClass()));
-      if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
-        rejectedFieldsNames.add(fieldName);
-        expectedValues.add(otherFieldValue);
-        rejectedValues.add(actualFieldValue);
-      }
-    }
-    return new ByFieldsComparison(rejectedFieldsNames, expectedValues, rejectedValues);
+	List<String> rejectedFieldsNames = new LinkedList<String>();
+	List<Object> expectedValues = new LinkedList<Object>();
+	List<Object> rejectedValues = new LinkedList<Object>();
+	final Set<Field> declaredFieldsIncludingInherited = getDeclaredFieldsIncludingInherited(actual.getClass());
+	for (String fieldName : fields) {
+	  Object actualFieldValue = getFieldOrPropertyValue(actual, findField(fieldName,
+		                                                                  declaredFieldsIncludingInherited,
+		                                                                  actual.getClass()));
+	  Object otherFieldValue = getFieldOrPropertyValue(other, findField(fieldName, declaredFieldsIncludingInherited,
+		                                                                other.getClass()));
+	  if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
+		rejectedFieldsNames.add(fieldName);
+		expectedValues.add(otherFieldValue);
+		rejectedValues.add(actualFieldValue);
+	  }
+	}
+	return new ByFieldsComparison(rejectedFieldsNames, expectedValues, rejectedValues);
   }
 
   /**
    * Find field with given fieldName in fields of Class clazz.
+   * 
    * @param fieldName the field name used to find field in fields
    * @param fields Fields to look into
    * @param clazz use for the exception to indicate to whihc class fields belonged.
@@ -602,11 +611,11 @@ public class Objects {
    * @throws IntrospectionError if no field with given fieldName can be found.
    */
   private Field findField(String fieldName, Set<Field> fields, Class<?> clazz) {
-    if (fieldName == null) return null;
-    for (Field field : fields) {
-      if (fieldName.equals(field.getName())) return field;
-    }
-    throw new IntrospectionError(format("No field '%s' in %s", fieldName, clazz));
+	if (fieldName == null) return null;
+	for (Field field : fields) {
+	  if (fieldName.equals(field.getName())) return field;
+	}
+	throw new IntrospectionError(format("No field '%s' in %s", fieldName, clazz));
   }
 
   /**
@@ -623,56 +632,60 @@ public class Objects {
    * @throws AssertionError if the other object is not an instance of the actual type.
    */
   public <A> void assertIsEqualToIgnoringGivenFields(AssertionInfo info, A actual, A other, String... fields) {
-    assertNotNull(info, actual);
-    assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
-    ByFieldsComparison byFieldsComparison = isEqualToIgnoringGivenFields(actual, other, fields);
-    if (byFieldsComparison.isFieldsNamesNotEmpty())
-      throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, byFieldsComparison.fieldsNames,
-                                                                      byFieldsComparison.rejectedValues,
-                                                                      byFieldsComparison.expectedValues,
-                                                                      newArrayList(fields)));
+	assertNotNull(info, actual);
+	assertOtherTypeIsCompatibleWithActualClass(info, other, actual.getClass());
+	ByFieldsComparison byFieldsComparison = isEqualToIgnoringGivenFields(actual, other, fields);
+	if (byFieldsComparison.isFieldsNamesNotEmpty())
+	  throw failures.failure(info, shouldBeEqualToIgnoringGivenFields(actual, byFieldsComparison.fieldsNames,
+	                                                                  byFieldsComparison.rejectedValues,
+	                                                                  byFieldsComparison.expectedValues,
+	                                                                  newArrayList(fields)));
   }
 
+  // public <A> ByFieldsComparison compareFieldByField(A actual, A other) {
+  // return isEqualToIgnoringGivenFields(actual, other, new String[0]);
+  // }
+
   private <A> ByFieldsComparison isEqualToIgnoringGivenFields(A actual, A other, String[] fields) {
-    List<String> fieldsNames = new LinkedList<String>();
-    List<Object> expectedValues = new LinkedList<Object>();
-    List<Object> rejectedValues = new LinkedList<Object>();
-    Set<String> ignoredFields = newLinkedHashSet(fields);
-    for (Field field : getDeclaredFieldsIncludingInherited(actual.getClass())) {
-      try {
-        if (!ignoredFields.contains(field.getName())) {
-          Object actualFieldValue = getFieldOrPropertyValue(actual, field);
-          Object otherFieldValue = getFieldOrPropertyValue(other, field);
-          if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
-            fieldsNames.add(field.getName());
-            rejectedValues.add(actualFieldValue);
-            expectedValues.add(otherFieldValue);
-          }
-        }
-      } catch (IntrospectionError e) {
-        // Not readable field, skip.
-      }
-    }
-    return new ByFieldsComparison(fieldsNames, expectedValues, rejectedValues);
+	List<String> fieldsNames = new LinkedList<String>();
+	List<Object> expectedValues = new LinkedList<Object>();
+	List<Object> rejectedValues = new LinkedList<Object>();
+	Set<String> ignoredFields = newLinkedHashSet(fields);
+	for (Field field : getDeclaredFieldsIncludingInherited(actual.getClass())) {
+	  try {
+		if (!ignoredFields.contains(field.getName())) {
+		  Object actualFieldValue = getFieldOrPropertyValue(actual, field);
+		  Object otherFieldValue = getFieldOrPropertyValue(other, field);
+		  if (!org.assertj.core.util.Objects.areEqual(actualFieldValue, otherFieldValue)) {
+			fieldsNames.add(field.getName());
+			rejectedValues.add(actualFieldValue);
+			expectedValues.add(otherFieldValue);
+		  }
+		}
+	  } catch (IntrospectionError e) {
+		// Not readable field, skip.
+	  }
+	}
+	return new ByFieldsComparison(fieldsNames, expectedValues, rejectedValues);
   }
 
   /**
    * Get field value first and in case of error try its value from property getter (property name being field name)
    *
-   * @param a     the object to get field value from
+   * @param a the object to get field value from
    * @param field Field to read
-   * @param <A>   the type of object a
+   * @param <A> the type of object a
    * @return field value or property value if field was not accessible.
    * @throws IntrospectionError is field value can't get retrieved.
    */
-  private <A> Object getFieldOrPropertyValue(A a, Field field)  {
-    try {
-      // read field value
-      return field.get(a);
-    } catch (IllegalAccessException e) {
-      // field is not accessible, let's try to get its value from its getter if any.
-      return propertySupport.propertyValue(field.getName(), Object.class, a);
-    }
+  private <A> Object getFieldOrPropertyValue(A a, Field field) {
+	try {
+	  // read field value
+	  return field.get(a);
+	} catch (IllegalAccessException e) {
+	  // field is not accessible, let's try to get its value from its getter if any.
+	  return propertySupport.propertyValue(field.getName(), Object.class, a);
+	}
   }
 
   /**
@@ -683,15 +696,15 @@ public class Objects {
    * @return the declared fields of given class and its superclasses.
    */
   private static Set<Field> getDeclaredFieldsIncludingInherited(Class<?> clazz) {
-    if (clazz == null) throw new NullPointerException("expecting Class parameter not to be null");
-    Set<Field> declaredFields = newLinkedHashSet(clazz.getDeclaredFields());
-    // get fields declared in superclass
-    Class<?> superclazz = clazz.getSuperclass();
-    while (superclazz != null && !superclazz.getName().startsWith("java.lang")) {
-      declaredFields.addAll(newLinkedHashSet(superclazz.getDeclaredFields()));
-      superclazz = superclazz.getSuperclass();
-    }
-    return declaredFields;
+	if (clazz == null) throw new NullPointerException("expecting Class parameter not to be null");
+	Set<Field> declaredFields = newLinkedHashSet(clazz.getDeclaredFields());
+	// get fields declared in superclass
+	Class<?> superclazz = clazz.getSuperclass();
+	while (superclazz != null && !superclazz.getName().startsWith("java.lang")) {
+	  declaredFields.addAll(newLinkedHashSet(superclazz.getDeclaredFields()));
+	  superclazz = superclazz.getSuperclass();
+	}
+	return declaredFields;
   }
 
   /**
@@ -705,41 +718,45 @@ public class Objects {
    * @throws AssertionError if other is not an instance of the given type.
    */
   private void assertOtherTypeIsCompatibleWithActualClass(AssertionInfo info, Object other, Class<?> clazz) {
-    if (other == null) throw failures.failure(info, shouldBeInstanceButWasNull("other", clazz));
-    isInstanceOf(other, clazz, info);
+	if (other == null) throw failures.failure(info, shouldBeInstanceButWasNull("other", clazz));
+	isInstanceOf(other, clazz, info);
   }
 
   private void isInstanceOf(Object object, Class<?> clazz, AssertionInfo info) {
-    if (!clazz.isInstance(object)) throw failures.failure(info, shouldBeInstance(object, clazz));
+	if (!clazz.isInstance(object)) throw failures.failure(info, shouldBeInstance(object, clazz));
   }
 
   public boolean areEqualToIgnoringGivenFields(Object actual, Object other, String... fields) {
-    return isEqualToIgnoringGivenFields(actual, other, fields).isFieldsNamesEmpty();
+	return isEqualToIgnoringGivenFields(actual, other, fields).isFieldsNamesEmpty();
   }
 
   public boolean areEqualToComparingOnlyGivenFields(Object actual, Object other, String... fields) {
-    return isEqualToComparingOnlyGivenFields(actual, other, fields).isFieldsNamesEmpty();
+	return isEqualToComparingOnlyGivenFields(actual, other, fields).isFieldsNamesEmpty();
   }
 
-  private class ByFieldsComparison {
+  public static class ByFieldsComparison {
+
+	private final List<String> fieldsNames;
+	private final List<Object> expectedValues;
+	private final List<Object> rejectedValues;
 
-    private final List<String> fieldsNames;
-    private final List<Object> expectedValues;
-    private final List<Object> rejectedValues;
+	public ByFieldsComparison(final List<String> fieldsNames, final List<Object> expectedValues,
+	                          final List<Object> rejectedValues) {
+	  this.fieldsNames = fieldsNames;
+	  this.expectedValues = expectedValues;
+	  this.rejectedValues = rejectedValues;
+	}
 
-    public ByFieldsComparison(final List<String> fieldsNames, final List<Object> expectedValues,
-                              final List<Object> rejectedValues) {
-      this.fieldsNames = fieldsNames;
-      this.expectedValues = expectedValues;
-      this.rejectedValues = rejectedValues;
-    }
+	public ByFieldsComparison() {
+	  this(new ArrayList<String>(), new ArrayList<Object>(), new ArrayList<Object>());
+	}
 
-    public boolean isFieldsNamesEmpty() {
-      return fieldsNames.isEmpty();
-    }
+	public boolean isFieldsNamesEmpty() {
+	  return fieldsNames.isEmpty();
+	}
 
-    public boolean isFieldsNamesNotEmpty() {
-      return !isFieldsNamesEmpty();
-    }
+	public boolean isFieldsNamesNotEmpty() {
+	  return !isFieldsNamesEmpty();
+	}
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/OnFieldsComparator.java b/src/main/java/org/assertj/core/internal/OnFieldsComparator.java
new file mode 100644
index 000000000..e9797377c
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/OnFieldsComparator.java
@@ -0,0 +1,32 @@
+package org.assertj.core.internal;
+
+import org.assertj.core.presentation.StandardRepresentation;
+import org.assertj.core.util.VisibleForTesting;
+
+public class OnFieldsComparator extends FieldByFieldComparator {
+
+  private final static StandardRepresentation REPRESENTATION = new StandardRepresentation();
+  
+  private String[] fields;
+
+  public OnFieldsComparator(String... fields) {
+      this.fields = fields;
+  }
+  
+  @VisibleForTesting
+  public String[] getFields() {
+	return fields;
+  }
+  
+  @Override
+  protected boolean areEqual(Object actualElement, Object otherElement) {
+    return Objects.instance().areEqualToComparingOnlyGivenFields(actualElement, otherElement, fields);
+  }
+  
+  @Override
+  public String toString() {
+	if (fields != null && fields.length == 1) return "field " + REPRESENTATION.toStringOf(fields);
+	return "field by field comparator on fields " + REPRESENTATION.toStringOf(fields);
+  }
+  
+}
diff --git a/src/main/java/org/assertj/core/internal/OnFieldsComparisonStrategy.java b/src/main/java/org/assertj/core/internal/OnFieldsComparisonStrategy.java
index f3a8d4de7..d5053cf80 100644
--- a/src/main/java/org/assertj/core/internal/OnFieldsComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/OnFieldsComparisonStrategy.java
@@ -2,30 +2,26 @@ package org.assertj.core.internal;
 
 import org.assertj.core.util.VisibleForTesting;
 
-public class OnFieldsComparisonStrategy extends FieldComparisonStrategy {
+public class OnFieldsComparisonStrategy extends ComparatorBasedComparisonStrategy {
 
-    private String[] fields;
+  private String[] fields;
 
-    public OnFieldsComparisonStrategy(String... fields) {
-        this.fields = fields;
-    }
+  public OnFieldsComparisonStrategy(String... fields) {
+	super(new IgnoringFieldsComparator(fields));
+	this.fields = fields;
+  }
 
-    @Override
-    protected boolean areFieldsEqual(Object actual, Object other) {
-        return Objects.instance().areEqualToComparingOnlyGivenFields(actual, other, fields);
-    }
+  @VisibleForTesting
+  public String[] getFields() {
+	return fields;
+  }
 
-    @VisibleForTesting
-    public String[] getFields() {
-        return fields;
-    }
+  @Override
+  public String asText() {
+	return "when comparing elements field by field on the following fields only : " + fieldsAsText() + "\n";
+  }
 
-    @Override
-    public String asText() {
-        return "when comparing elements field by field on the following fields only : " + fieldsAsText() + "\n";
-    }
-
-    private String fieldsAsText() {
-        return org.assertj.core.util.Strings.join(fields).with(", ");
-    }
+  private String fieldsAsText() {
+	return org.assertj.core.util.Strings.join(fields).with(", ");
+  }
 }
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java b/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
index e96f209ad..58d095fd3 100644
--- a/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
+++ b/src/main/java/org/assertj/core/internal/StandardComparisonStrategy.java
@@ -168,5 +168,10 @@ public class StandardComparisonStrategy extends AbstractComparisonStrategy {
 	}
 	return Comparable.class.cast(actual).compareTo(other) < 0;
   }
-  
+
+  @Override
+  public boolean isStandard() {
+    return true;
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index 273adaf83..c06ffd286 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -14,9 +14,8 @@
  */
 package org.assertj.core.presentation;
 
-import org.assertj.core.groups.Tuple;
-import org.assertj.core.util.Collections;
-import org.assertj.core.util.Dates;
+import static org.assertj.core.util.Strings.concat;
+import static org.assertj.core.util.Strings.quote;
 
 import java.io.File;
 import java.text.SimpleDateFormat;
@@ -25,8 +24,10 @@ import java.util.Calendar;
 import java.util.Comparator;
 import java.util.Date;
 
-import static org.assertj.core.util.Strings.concat;
-import static org.assertj.core.util.Strings.quote;
+import org.assertj.core.groups.Tuple;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.util.Collections;
+import org.assertj.core.util.Dates;
 
 /**
  * Standard java object representation.
@@ -60,6 +61,8 @@ public class StandardRepresentation implements Representation {
       return toStringOf((Character) object);
     } else if (object instanceof Comparator) {
       return toStringOf((Comparator<?>) object);
+    } else if (object instanceof ComparatorBasedComparisonStrategy) {
+      return toStringOf((Comparator<?>) object);
     } else if (object instanceof SimpleDateFormat) {
       return toStringOf((SimpleDateFormat) object);
     } else if (object instanceof Tuple) {
@@ -78,9 +81,12 @@ public class StandardRepresentation implements Representation {
     return defaultToString(number, representation);
   }
 
-  private static String toStringOf(Comparator<?> comparator) {
-    String comparatorSimpleClassName = comparator.getClass().getSimpleName();
-    return quote(!comparatorSimpleClassName.isEmpty() ? comparatorSimpleClassName : "Anonymous Comparator class");
+  private static String toStringOf(Comparator<?> comparator) {	
+	String comparatorSimpleClassName = comparator.getClass().getSimpleName();
+	if (comparatorSimpleClassName.length() == 0) return quote("anonymous comparator class");
+	// if toString has not been redefined, let's use comparator simple class name.
+	if (comparator.toString().contains(comparatorSimpleClassName + "@") ) return quote(comparatorSimpleClassName);
+	return quote(comparator.toString());
   }
 
   private static String toStringOf(Calendar c) {
diff --git a/src/main/java/org/assertj/core/util/Objects.java b/src/main/java/org/assertj/core/util/Objects.java
index 59555f7fd..9a468160f 100644
--- a/src/main/java/org/assertj/core/util/Objects.java
+++ b/src/main/java/org/assertj/core/util/Objects.java
@@ -46,7 +46,7 @@ public final class Objects {
     return areEqualArrays(o1, o2);
   }
 
-  private static boolean areEqualArrays(Object o1, Object o2) {
+  public static boolean areEqualArrays(Object o1, Object o2) {
     if (!isArray(o1) || !isArray(o2)) {
       return false;
     }
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingElementComparatorIgnoringFields_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingElementComparatorIgnoringFields_Test.java
index aeda25fcd..1df9bb48f 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingElementComparatorIgnoringFields_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingElementComparatorIgnoringFields_Test.java
@@ -1,32 +1,36 @@
 package org.assertj.core.api.iterable;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.assertj.core.api.ConcreteIterableAssert;
 import org.assertj.core.api.IterableAssertBaseTest;
-import org.assertj.core.internal.IgnoringFieldsComparisonStrategy;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.IgnoringFieldsComparator;
 import org.assertj.core.internal.Iterables;
 import org.junit.Before;
 
-import static org.junit.Assert.*;
-
 public class IterableAssert_usingElementComparatorIgnoringFields_Test extends IterableAssertBaseTest {
 
-    private Iterables iterablesBefore;
-
-    @Before
-    public void before() {
-        iterablesBefore = getIterables(assertions);
-    }
-
-    @Override
-    protected ConcreteIterableAssert<Object> invoke_api_method() {
-        return assertions.usingElementComparatorIgnoringFields("field");
-    }
-
-    @Override
-    protected void verify_internal_effects() {
-        assertNotSame(getIterables(assertions), iterablesBefore);
-        assertTrue(getIterables(assertions).getComparisonStrategy() instanceof IgnoringFieldsComparisonStrategy);
-        assertArrayEquals(new String[]{"field"}, ((IgnoringFieldsComparisonStrategy) getIterables(assertions).getComparisonStrategy()).getFields());
-    }
+  private Iterables iterablesBefore;
+
+  @Before
+  public void before() {
+	iterablesBefore = getIterables(assertions);
+  }
+
+  @Override
+  protected ConcreteIterableAssert<Object> invoke_api_method() {
+	return assertions.usingElementComparatorIgnoringFields("field");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	Iterables iterables = getIterables(assertions);
+	assertThat(iterables).isNotSameAs(iterablesBefore);
+	assertThat(iterables.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+	ComparatorBasedComparisonStrategy strategy = (ComparatorBasedComparisonStrategy) iterables.getComparisonStrategy();
+	assertThat(strategy.getComparator()).isInstanceOf(IgnoringFieldsComparator.class);
+	assertThat(((IgnoringFieldsComparator) strategy.getComparator()).getFields()).containsOnly("field");
+  }
 
 }
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingElementComparatorOnFields_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingElementComparatorOnFields_Test.java
index 00ef7e524..8cd2402ed 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingElementComparatorOnFields_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingElementComparatorOnFields_Test.java
@@ -1,32 +1,36 @@
 package org.assertj.core.api.iterable;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
 import org.assertj.core.api.ConcreteIterableAssert;
 import org.assertj.core.api.IterableAssertBaseTest;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.Iterables;
-import org.assertj.core.internal.OnFieldsComparisonStrategy;
+import org.assertj.core.internal.OnFieldsComparator;
 import org.junit.Before;
 
-import static org.junit.Assert.*;
-
 public class IterableAssert_usingElementComparatorOnFields_Test extends IterableAssertBaseTest {
 
-    private Iterables iterablesBefore;
-
-    @Before
-    public void before() {
-        iterablesBefore = getIterables(assertions);
-    }
-
-    @Override
-    protected ConcreteIterableAssert<Object> invoke_api_method() {
-        return assertions.usingElementComparatorOnFields("field");
-    }
-
-    @Override
-    protected void verify_internal_effects() {
-        assertNotSame(getIterables(assertions), iterablesBefore);
-        assertTrue(getIterables(assertions).getComparisonStrategy() instanceof OnFieldsComparisonStrategy);
-        assertArrayEquals(new String[]{"field"}, ((OnFieldsComparisonStrategy) getIterables(assertions).getComparisonStrategy()).getFields());
-    }
+  private Iterables iterablesBefore;
+
+  @Before
+  public void before() {
+	iterablesBefore = getIterables(assertions);
+  }
+
+  @Override
+  protected ConcreteIterableAssert<Object> invoke_api_method() {
+	return assertions.usingElementComparatorOnFields("field");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	Iterables iterables = getIterables(assertions);
+	assertThat(iterables).isNotSameAs(iterablesBefore);
+	assertThat(iterables.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+	ComparatorBasedComparisonStrategy strategy = (ComparatorBasedComparisonStrategy) iterables.getComparisonStrategy();
+	assertThat(strategy.getComparator()).isInstanceOf(OnFieldsComparator.class);
+	assertThat(((OnFieldsComparator)strategy.getComparator()).getFields()).containsOnly("field");
+  }
 
 }
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingFieldByFieldElementComparator_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingFieldByFieldElementComparator_Test.java
index c8163b8a3..36b7b36df 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingFieldByFieldElementComparator_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingFieldByFieldElementComparator_Test.java
@@ -1,32 +1,105 @@
 package org.assertj.core.api.iterable;
 
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
+import static org.junit.Assert.assertNotSame;
+import static org.junit.Assert.assertTrue;
+
+import java.util.List;
+
 import org.assertj.core.api.ConcreteIterableAssert;
 import org.assertj.core.api.IterableAssertBaseTest;
-import org.assertj.core.internal.FieldByFieldComparisonStrategy;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.FieldByFieldComparator;
+import org.assertj.core.internal.IterableElementComparisonStrategy;
 import org.assertj.core.internal.Iterables;
 import org.junit.Before;
-
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertTrue;
+import org.junit.Test;
 
 public class IterableAssert_usingFieldByFieldElementComparator_Test extends IterableAssertBaseTest {
 
-    private Iterables iterablesBefore;
+  private Iterables iterablesBefore;
+
+  @Before
+  public void before() {
+	iterablesBefore = getIterables(assertions);
+  }
+
+  @Override
+  protected ConcreteIterableAssert<Object> invoke_api_method() {
+	return assertions.usingFieldByFieldElementComparator();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	assertNotSame(getIterables(assertions), iterablesBefore);
+	assertTrue(getIterables(assertions).getComparisonStrategy() instanceof ComparatorBasedComparisonStrategy);
+	assertTrue(getObjects(assertions).getComparisonStrategy() instanceof IterableElementComparisonStrategy);
+  }
+
+  @Test
+  public void succesful_isEqualTo_assertion_using_field_by_field_element_comparator() {
+	List<Foo> list1 = singletonList(new Foo("id", 1));
+	List<Foo> list2 = singletonList(new Foo("id", 1));
+	assertThat(list1).usingFieldByFieldElementComparator().isEqualTo(list2);
+  }
+
+  @Test
+  public void succesful_isIn_assertion_using_field_by_field_element_comparator() {
+	List<Foo> list1 = singletonList(new Foo("id", 1));
+	List<Foo> list2 = singletonList(new Foo("id", 1));
+	System.out.println(new FieldByFieldComparator());
+	assertThat(list1).usingFieldByFieldElementComparator().isIn(singletonList(list2));
+  }
+
+  @Test
+  public void failed_isEqualTo_assertion_using_field_by_field_element_comparator() {
+	List<Foo> list1 = singletonList(new Foo("id", 1));
+	List<Foo> list2 = singletonList(new Foo("id", 2));
+	try {
+	  assertThat(list1).usingFieldByFieldElementComparator().isEqualTo(list2);
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\nExpecting:\n" +
+		                       " <[Foo(id=id, bar=1)]>\n" +
+		                       "to be equal to:\n" +
+		                       " <[Foo(id=id, bar=2)]>\n" +
+		                       "when comparing elements using 'field by field comparator on all fields' but was not.");
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void failed_isIn_assertion_using_field_by_field_element_comparator() {
+	List<Foo> list1 = singletonList(new Foo("id", 1));
+	List<Foo> list2 = singletonList(new Foo("id", 2));
+	try {
+	  assertThat(list1).usingFieldByFieldElementComparator().isIn(singletonList(list2));
+	} catch (AssertionError e) {
+	  assertThat(e).hasMessage("\nExpecting:\n" +
+		                       " <[Foo(id=id, bar=1)]>\n" +
+		                       "to be in:\n" +
+		                       " <[[Foo(id=id, bar=2)]]>\n" +
+		                       "when comparing elements using 'field by field comparator on all fields'");
+	  return;
+	}
+	failBecauseExpectedAssertionErrorWasNotThrown();
+  }
 
-    @Before
-    public void before() {
-        iterablesBefore = getIterables(assertions);
-    }
+  public static class Foo {
+	public final String id;
+	public final int bar;
 
-    @Override
-    protected ConcreteIterableAssert<Object> invoke_api_method() {
-        return assertions.usingFieldByFieldElementComparator();
-    }
+	public Foo(final String id, final int bar) {
+	  this.id = id;
+	  this.bar = bar;
+	}
 
-    @Override
-    protected void verify_internal_effects() {
-        assertNotSame(getIterables(assertions), iterablesBefore);
-        assertTrue(getIterables(assertions).getComparisonStrategy() instanceof FieldByFieldComparisonStrategy);
-    }
+	@Override
+	public String toString() {
+	  return "Foo(id=" + id + ", bar=" + bar + ")";
+	}
 
+  }
 }
diff --git a/src/test/java/org/assertj/core/api/list/ListAssert_usingElementComparatorIgnoringFields_Test.java b/src/test/java/org/assertj/core/api/list/ListAssert_usingElementComparatorIgnoringFields_Test.java
index b730d2a00..0239137ff 100644
--- a/src/test/java/org/assertj/core/api/list/ListAssert_usingElementComparatorIgnoringFields_Test.java
+++ b/src/test/java/org/assertj/core/api/list/ListAssert_usingElementComparatorIgnoringFields_Test.java
@@ -1,38 +1,47 @@
 package org.assertj.core.api.list;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.Comparator;
+
 import org.assertj.core.api.ListAssert;
 import org.assertj.core.api.ListAssertBaseTest;
-import org.assertj.core.internal.IgnoringFieldsComparisonStrategy;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.IgnoringFieldsComparator;
 import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.Lists;
 import org.junit.Before;
 
-import static org.junit.Assert.*;
-
 public class ListAssert_usingElementComparatorIgnoringFields_Test extends ListAssertBaseTest {
 
-    private Lists listsBefore;
-    private Iterables iterablesBefore;
-
-    @Before
-    public void before() {
-        listsBefore = getLists(assertions);
-        iterablesBefore = getIterables(assertions);
-    }
-
-    @Override
-    protected ListAssert<String> invoke_api_method() {
-        return assertions.usingElementComparatorIgnoringFields("field");
-    }
-
-    @Override
-    protected void verify_internal_effects() {
-        assertNotSame(getLists(assertions), listsBefore);
-        assertNotSame(getIterables(assertions), iterablesBefore);
-        assertTrue(getLists(assertions).getComparisonStrategy() instanceof IgnoringFieldsComparisonStrategy);
-        assertArrayEquals(new String[]{"field"}, ((IgnoringFieldsComparisonStrategy) getLists(assertions).getComparisonStrategy()).getFields());
-        assertTrue(getIterables(assertions).getComparisonStrategy() instanceof IgnoringFieldsComparisonStrategy);
-        assertArrayEquals(new String[]{"field"}, ((IgnoringFieldsComparisonStrategy) getIterables(assertions).getComparisonStrategy()).getFields());
-    }
+  private Lists listsBefore;
+  private Iterables iterablesBefore;
+
+  @Before
+  public void before() {
+	listsBefore = getLists(assertions);
+	iterablesBefore = getIterables(assertions);
+  }
+
+  @Override
+  protected ListAssert<String> invoke_api_method() {
+	return assertions.usingElementComparatorIgnoringFields("field");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	Lists lists = getLists(assertions);
+	Iterables iterables = getIterables(assertions);
+	assertThat(lists).isNotSameAs(listsBefore);
+	assertThat(iterables).isNotSameAs(iterablesBefore);
+	assertThat(iterables.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+	assertThat(lists.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+	Comparator<?> listsElementComparator = ((ComparatorBasedComparisonStrategy) lists.getComparisonStrategy()).getComparator();
+	assertThat(listsElementComparator).isInstanceOf(IgnoringFieldsComparator.class);
+	assertThat(((IgnoringFieldsComparator) listsElementComparator).getFields()).containsOnly("field");
+	Comparator<?> iterablesElementComparator = ((ComparatorBasedComparisonStrategy) iterables.getComparisonStrategy()).getComparator();
+	assertThat(iterablesElementComparator).isInstanceOf(IgnoringFieldsComparator.class);
+	assertThat(((IgnoringFieldsComparator) iterablesElementComparator).getFields()).containsOnly("field");
+  }
 
 }
diff --git a/src/test/java/org/assertj/core/api/list/ListAssert_usingElementComparatorOnFields_Test.java b/src/test/java/org/assertj/core/api/list/ListAssert_usingElementComparatorOnFields_Test.java
index 20d8683f6..03cb5d9d6 100644
--- a/src/test/java/org/assertj/core/api/list/ListAssert_usingElementComparatorOnFields_Test.java
+++ b/src/test/java/org/assertj/core/api/list/ListAssert_usingElementComparatorOnFields_Test.java
@@ -1,38 +1,47 @@
 package org.assertj.core.api.list;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.Comparator;
+
 import org.assertj.core.api.ListAssert;
 import org.assertj.core.api.ListAssertBaseTest;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.Lists;
-import org.assertj.core.internal.OnFieldsComparisonStrategy;
+import org.assertj.core.internal.OnFieldsComparator;
 import org.junit.Before;
 
-import static org.junit.Assert.*;
-
 public class ListAssert_usingElementComparatorOnFields_Test extends ListAssertBaseTest {
 
-    private Lists listsBefore;
-    private Iterables iterablesBefore;
-
-    @Before
-    public void before() {
-        listsBefore = getLists(assertions);
-        iterablesBefore = getIterables(assertions);
-    }
-
-    @Override
-    protected ListAssert<String> invoke_api_method() {
-        return assertions.usingElementComparatorOnFields("field");
-    }
-
-    @Override
-    protected void verify_internal_effects() {
-        assertNotSame(getLists(assertions), listsBefore);
-        assertNotSame(getIterables(assertions), iterablesBefore);
-        assertTrue(getLists(assertions).getComparisonStrategy() instanceof OnFieldsComparisonStrategy);
-        assertArrayEquals(new String[]{"field"}, ((OnFieldsComparisonStrategy) getLists(assertions).getComparisonStrategy()).getFields());
-        assertTrue(getIterables(assertions).getComparisonStrategy() instanceof OnFieldsComparisonStrategy);
-        assertArrayEquals(new String[]{"field"}, ((OnFieldsComparisonStrategy) getIterables(assertions).getComparisonStrategy()).getFields());
-    }
+  private Lists listsBefore;
+  private Iterables iterablesBefore;
+
+  @Before
+  public void before() {
+	listsBefore = getLists(assertions);
+	iterablesBefore = getIterables(assertions);
+  }
+
+  @Override
+  protected ListAssert<String> invoke_api_method() {
+	return assertions.usingElementComparatorOnFields("field");
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	Lists lists = getLists(assertions);
+	Iterables iterables = getIterables(assertions);
+	assertThat(lists).isNotSameAs(listsBefore);
+	assertThat(iterables).isNotSameAs(iterablesBefore);
+	assertThat(iterables.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+	assertThat(lists.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+	Comparator<?> listsElementComparator = ((ComparatorBasedComparisonStrategy) lists.getComparisonStrategy()).getComparator();
+	assertThat(listsElementComparator).isInstanceOf(OnFieldsComparator.class);
+	assertThat(((OnFieldsComparator) listsElementComparator).getFields()).containsOnly("field");
+	Comparator<?> iterablesElementComparator = ((ComparatorBasedComparisonStrategy) iterables.getComparisonStrategy()).getComparator();
+	assertThat(iterablesElementComparator).isInstanceOf(OnFieldsComparator.class);
+	assertThat(((OnFieldsComparator) iterablesElementComparator).getFields()).containsOnly("field");
+  }
 
 }
diff --git a/src/test/java/org/assertj/core/api/list/ListAssert_usingFieldByFieldElementComparator_Test.java b/src/test/java/org/assertj/core/api/list/ListAssert_usingFieldByFieldElementComparator_Test.java
index a5af13952..d3899a1f4 100644
--- a/src/test/java/org/assertj/core/api/list/ListAssert_usingFieldByFieldElementComparator_Test.java
+++ b/src/test/java/org/assertj/core/api/list/ListAssert_usingFieldByFieldElementComparator_Test.java
@@ -1,37 +1,45 @@
 package org.assertj.core.api.list;
 
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.Comparator;
+
 import org.assertj.core.api.ListAssert;
 import org.assertj.core.api.ListAssertBaseTest;
-import org.assertj.core.internal.FieldByFieldComparisonStrategy;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.FieldByFieldComparator;
 import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.Lists;
 import org.junit.Before;
 
-import static org.junit.Assert.assertNotSame;
-import static org.junit.Assert.assertTrue;
-
 public class ListAssert_usingFieldByFieldElementComparator_Test extends ListAssertBaseTest {
 
-    private Lists listsBefore;
-    private Iterables iterablesBefore;
-
-    @Before
-    public void before() {
-        listsBefore = getLists(assertions);
-        iterablesBefore = getIterables(assertions);
-    }
-
-    @Override
-    protected ListAssert<String> invoke_api_method() {
-        return assertions.usingFieldByFieldElementComparator();
-    }
-
-    @Override
-    protected void verify_internal_effects() {
-        assertNotSame(getLists(assertions), listsBefore);
-        assertNotSame(getIterables(assertions), iterablesBefore);
-        assertTrue(getLists(assertions).getComparisonStrategy() instanceof FieldByFieldComparisonStrategy);
-        assertTrue(getIterables(assertions).getComparisonStrategy() instanceof FieldByFieldComparisonStrategy);
-    }
+  private Lists listsBefore;
+  private Iterables iterablesBefore;
+
+  @Before
+  public void before() {
+	listsBefore = getLists(assertions);
+	iterablesBefore = getIterables(assertions);
+  }
+
+  @Override
+  protected ListAssert<String> invoke_api_method() {
+	return assertions.usingFieldByFieldElementComparator();
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+	Lists lists = getLists(assertions);
+	Iterables iterables = getIterables(assertions);
+	assertThat(lists).isNotSameAs(listsBefore);
+	assertThat(iterables).isNotSameAs(iterablesBefore);
+	assertThat(iterables.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+	assertThat(lists.getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+	Comparator<?> listsElementComparator = ((ComparatorBasedComparisonStrategy) lists.getComparisonStrategy()).getComparator();
+	assertThat(listsElementComparator).isInstanceOf(FieldByFieldComparator.class);
+	Comparator<?> iterablesElementComparator = ((ComparatorBasedComparisonStrategy) iterables.getComparisonStrategy()).getComparator();
+	assertThat(iterablesElementComparator).isInstanceOf(FieldByFieldComparator.class);
+  }
 
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeEqual_newAssertionError_differentiating_expected_and_actual_Test.java b/src/test/java/org/assertj/core/error/ShouldBeEqual_newAssertionError_differentiating_expected_and_actual_Test.java
index 2bd89f53e..ba69556a9 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeEqual_newAssertionError_differentiating_expected_and_actual_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeEqual_newAssertionError_differentiating_expected_and_actual_Test.java
@@ -32,7 +32,8 @@ import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
 /**
- * Tests for <code>{@link ShouldBeEqual#newAssertionError(Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for
+ * <code>{@link ShouldBeEqual#newAssertionError(Description, org.assertj.core.presentation.Representation)}</code>.
  * 
  * @author Joel Costigliola (based on Tomasz Nurkiewicz ideas)
  */
@@ -44,77 +45,82 @@ public class ShouldBeEqual_newAssertionError_differentiating_expected_and_actual
 
   @Before
   public void setUp() {
-    description = new TestDescription("my test");
+	description = new TestDescription("my test");
   }
 
   @Test
   public void should_create_AssertionError_with_message_differentiating_expected_double_and_actual_float() {
-    Float actual = 42f;
-    Double expected = 42d;
-    shouldBeEqual = (ShouldBeEqual) shouldBeEqual(actual, expected, new StandardRepresentation());
-    shouldBeEqual.descriptionFormatter = mock(DescriptionFormatter.class);
-    when(shouldBeEqual.descriptionFormatter.format(description)).thenReturn(formattedDescription);
+	Float actual = 42f;
+	Double expected = 42d;
+	shouldBeEqual = (ShouldBeEqual) shouldBeEqual(actual, expected, new StandardRepresentation());
+	shouldBeEqual.descriptionFormatter = mock(DescriptionFormatter.class);
+	when(shouldBeEqual.descriptionFormatter.format(description)).thenReturn(formattedDescription);
 
-    AssertionError error = shouldBeEqual.newAssertionError(description, new StandardRepresentation());
+	AssertionError error = shouldBeEqual.newAssertionError(description, new StandardRepresentation());
 
-    assertThat(error.getMessage()).isEqualTo("[my test] expected:<42.0[]> but was:<42.0[f]>");
+	assertThat(error.getMessage()).isEqualTo("[my test] expected:<42.0[]> but was:<42.0[f]>");
   }
 
   @Test
   public void should_create_AssertionError_with_message_differentiating_expected_and_actual_persons() {
-    Person actual = new Person("Jake", 43);
-    Person expected = new Person("Jake", 47);
-    shouldBeEqual = (ShouldBeEqual) shouldBeEqual(actual, expected, new StandardRepresentation());
-    shouldBeEqual.descriptionFormatter = mock(DescriptionFormatter.class);
-    when(shouldBeEqual.descriptionFormatter.format(description)).thenReturn(formattedDescription);
-
-    AssertionError error = shouldBeEqual.newAssertionError(description, new StandardRepresentation());
-
-    assertThat(error.getMessage()).isEqualTo(
-        "[my test] \nExpecting:\n <\"Person[name=Jake] (Person@" + toHexString(actual.hashCode())
-            + ")\">\nto be equal to:\n <\"Person[name=Jake] (Person@" + toHexString(expected.hashCode())
-            + ")\">\nbut was not."
-    );
+	Person actual = new Person("Jake", 43);
+	Person expected = new Person("Jake", 47);
+	shouldBeEqual = (ShouldBeEqual) shouldBeEqual(actual, expected, new StandardRepresentation());
+	shouldBeEqual.descriptionFormatter = mock(DescriptionFormatter.class);
+	when(shouldBeEqual.descriptionFormatter.format(description)).thenReturn(formattedDescription);
+
+	AssertionError error = shouldBeEqual.newAssertionError(description, new StandardRepresentation());
+
+	assertThat(error.getMessage()).isEqualTo(
+	                                         "[my test] \nExpecting:\n <\"Person[name=Jake] (Person@"
+	                                             + toHexString(actual.hashCode())
+	                                             + ")\">\nto be equal to:\n <\"Person[name=Jake] (Person@"
+	                                             + toHexString(expected.hashCode())
+	                                             + ")\">\nbut was not."
+	                              );
   }
 
   @Test
   public void should_create_AssertionError_with_message_differentiating_expected_and_actual_persons_even_if_a_comparator_based_comparison_strategy_is_used() {
-    Person actual = new Person("Jake", 43);
-    Person expected = new Person("Jake", 47);
-    ComparisonStrategy ageComparisonStrategy = new ComparatorBasedComparisonStrategy(new PersonComparator());
-    shouldBeEqual = (ShouldBeEqual) shouldBeEqual(actual, expected, ageComparisonStrategy,
-        new StandardRepresentation());
-    shouldBeEqual.descriptionFormatter = mock(DescriptionFormatter.class);
-    when(shouldBeEqual.descriptionFormatter.format(description)).thenReturn(formattedDescription);
-
-    AssertionError error = shouldBeEqual.newAssertionError(description, new StandardRepresentation());
-
-    assertThat(error.getMessage())
-        .isEqualTo("[my test] \nExpecting:\n <\"Person[name=Jake] (Person@" + toHexString(actual.hashCode())
-            + ")\">\nto be equal to:\n <\"Person[name=Jake] (Person@" + toHexString(expected.hashCode())
-            + ")\">\naccording to 'PersonComparator' comparator but was not.");
+	Person actual = new Person("Jake", 43);
+	Person expected = new Person("Jake", 47);
+	ComparisonStrategy ageComparisonStrategy = new ComparatorBasedComparisonStrategy(new PersonComparator());
+	shouldBeEqual = (ShouldBeEqual) shouldBeEqual(actual, expected, ageComparisonStrategy,
+	                                              new StandardRepresentation());
+	shouldBeEqual.descriptionFormatter = mock(DescriptionFormatter.class);
+	when(shouldBeEqual.descriptionFormatter.format(description)).thenReturn(formattedDescription);
+
+	AssertionError error = shouldBeEqual.newAssertionError(description, new StandardRepresentation());
+
+	assertThat(error.getMessage()).isEqualTo("[my test] \n"
+	                                         + "Expecting:\n"
+	                                         + " <\"Person[name=Jake] (Person@" + toHexString(actual.hashCode())
+	                                         + ")\">\n"
+	                                         + "to be equal to:\n <\"Person[name=Jake] (Person@"
+	                                         + toHexString(expected.hashCode()) + ")\">\n"
+	                                         + "when comparing values using 'PersonComparator' but was not.");
   }
 
   private static class Person {
-    private final String name;
-    private final int age;
-
-    public Person(String name, int age) {
-      this.name = name;
-      this.age = age;
-    }
-
-    @Override
-    public String toString() {
-      return concat("Person[name=", name, "]");
-    }
+	private final String name;
+	private final int age;
+
+	public Person(String name, int age) {
+	  this.name = name;
+	  this.age = age;
+	}
+
+	@Override
+	public String toString() {
+	  return concat("Person[name=", name, "]");
+	}
   }
 
   private static class PersonComparator implements Comparator<Person> {
-    @Override
-    public int compare(Person p1, Person p2) {
-      return p1.age - p2.age;
-    }
+	@Override
+	public int compare(Person p1, Person p2) {
+	  return p1.age - p2.age;
+	}
   }
 
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeGreaterOrEqual_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeGreaterOrEqual_create_Test.java
index b97a9bf35..b888a3f03 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeGreaterOrEqual_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeGreaterOrEqual_create_Test.java
@@ -14,8 +14,8 @@
  */
 package org.assertj.core.error;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.ShouldBeGreaterOrEqual.shouldBeGreaterOrEqual;
-import static org.junit.Assert.assertEquals;
 
 import org.assertj.core.description.Description;
 import org.assertj.core.description.TextDescription;
@@ -26,7 +26,8 @@ import org.junit.Before;
 import org.junit.Test;
 
 /**
- * Tests for <code>{@link ShouldBeGreaterOrEqual#create(Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for
+ * <code>{@link ShouldBeGreaterOrEqual#create(Description, org.assertj.core.presentation.Representation)}</code>.
  * 
  * @author Alex Ruiz
  * @author Joel Costigliola
@@ -37,21 +38,27 @@ public class ShouldBeGreaterOrEqual_create_Test {
 
   @Before
   public void setUp() {
-    factory = shouldBeGreaterOrEqual(6, 8);
+	factory = shouldBeGreaterOrEqual(6, 8);
   }
 
   @Test
   public void should_create_error_message() {
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <6>\nto be greater than or equal to:\n <8> ", message);
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n" +
+	                              "Expecting:\n" +
+	                              " <6>\n" +
+	                              "to be greater than or equal to:\n" +
+	                              " <8> ");
   }
 
   @Test
   public void should_create_error_message_with_custom_comparison_strategy() {
-    factory = shouldBeGreaterOrEqual(6, 8, new ComparatorBasedComparisonStrategy(new AbsValueComparator<Integer>()));
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals(
-        "[Test] \nExpecting:\n <6>\nto be greater than or equal to:\n <8> according to 'AbsValueComparator' comparator",
-        message);
+	factory = shouldBeGreaterOrEqual(6, 8, new ComparatorBasedComparisonStrategy(new AbsValueComparator<Integer>()));
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n" +
+	                              "Expecting:\n" +
+	                              " <6>\n" +
+	                              "to be greater than or equal to:\n" +
+	                              " <8> when comparing values using 'AbsValueComparator'");
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeGreater_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeGreater_create_Test.java
index 5e36f630c..7f09e8bde 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeGreater_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeGreater_create_Test.java
@@ -14,8 +14,8 @@
  */
 package org.assertj.core.error;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.ShouldBeGreater.shouldBeGreater;
-import static org.junit.Assert.assertEquals;
 
 import org.assertj.core.description.Description;
 import org.assertj.core.description.TextDescription;
@@ -37,20 +37,27 @@ public class ShouldBeGreater_create_Test {
 
   @Before
   public void setUp() {
-    factory = shouldBeGreater(6, 8);
+	factory = shouldBeGreater(6, 8);
   }
 
   @Test
   public void should_create_error_message() {
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <6>\nto be greater than:\n <8> ", message);
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n" +
+	                              "Expecting:\n" +
+	                              " <6>\n" +
+	                              "to be greater than:\n" +
+	                              " <8> ");
   }
 
   @Test
   public void should_create_error_message_with_custom_comparison_strategy() {
-    factory = shouldBeGreater(6, 8, new ComparatorBasedComparisonStrategy(new AbsValueComparator<Integer>()));
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <6>\nto be greater than:\n <8> according to 'AbsValueComparator' comparator",
-        message);
+	factory = shouldBeGreater(6, 8, new ComparatorBasedComparisonStrategy(new AbsValueComparator<Integer>()));
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n" +
+	                              "Expecting:\n" +
+	                              " <6>\n" +
+	                              "to be greater than:\n" +
+	                              " <8> when comparing values using 'AbsValueComparator'");
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeIn_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeIn_create_Test.java
index 081ea0e56..a6f14a277 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeIn_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeIn_create_Test.java
@@ -53,7 +53,7 @@ public class ShouldBeIn_create_Test {
         CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals(
-        "[Test] \nExpecting:\n <\"Yoda\">\nto be in:\n <[\"Luke\", \"Leia\"]>\naccording to 'CaseInsensitiveStringComparator' comparator",
+        "[Test] \nExpecting:\n <\"Yoda\">\nto be in:\n <[\"Luke\", \"Leia\"]>\nwhen comparing values using 'CaseInsensitiveStringComparator'",
         message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeLess_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeLess_create_Test.java
index 0fc7c5994..a9cb01ef3 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeLess_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeLess_create_Test.java
@@ -14,8 +14,8 @@
  */
 package org.assertj.core.error;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.ShouldBeLess.shouldBeLess;
-import static org.junit.Assert.assertEquals;
 
 import org.assertj.core.description.TextDescription;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
@@ -25,7 +25,9 @@ import org.junit.Before;
 import org.junit.Test;
 
 /**
- * Tests for <code>{@link ShouldBeLess#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for
+ * <code>{@link ShouldBeLess#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>
+ * .
  * 
  * @author Alex Ruiz
  * @author Joel Costigliola
@@ -36,19 +38,27 @@ public class ShouldBeLess_create_Test {
 
   @Before
   public void setUp() {
-    factory = shouldBeLess(8, 6);
+	factory = shouldBeLess(8, 6);
   }
 
   @Test
   public void should_create_error_message() {
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <8>\nto be less than:\n <6> ", message);
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n" +
+	                              "Expecting:\n" +
+	                              " <8>\n" +
+	                              "to be less than:\n" +
+	                              " <6> ");
   }
 
   @Test
   public void should_create_error_message_with_custom_comparison_strategy() {
-    factory = shouldBeLess(8, 6, new ComparatorBasedComparisonStrategy(new AbsValueComparator<Integer>()));
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <8>\nto be less than:\n <6> according to 'AbsValueComparator' comparator", message);
+	factory = shouldBeLess(8, 6, new ComparatorBasedComparisonStrategy(new AbsValueComparator<Integer>()));
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n" +
+	                              "Expecting:\n" +
+	                              " <8>\n" +
+	                              "to be less than:\n" +
+	                              " <6> when comparing values using 'AbsValueComparator'");
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeSubsetOf_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeSubsetOf_create_Test.java
index 93263243d..95aff41d6 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeSubsetOf_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeSubsetOf_create_Test.java
@@ -53,7 +53,7 @@ public class ShouldBeSubsetOf_create_Test {
         newArrayList("Yoda"), new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals(
-        "[Test] \nExpecting according to 'CaseInsensitiveStringComparator' comparator:\n <[\"Yoda\", \"Luke\"]>\nto be subset of\n <[\"Han\", \"Luke\"]>\nbut found those extra elements:\n <[\"Yoda\"]>",
+        "[Test] \nExpecting when comparing values using 'CaseInsensitiveStringComparator':\n <[\"Yoda\", \"Luke\"]>\nto be subset of\n <[\"Han\", \"Luke\"]>\nbut found those extra elements:\n <[\"Yoda\"]>",
         message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContainAtIndex_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainAtIndex_create_Test.java
index cfe62e1e4..fa38bb896 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainAtIndex_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainAtIndex_create_Test.java
@@ -47,6 +47,6 @@ public class ShouldContainAtIndex_create_Test {
         new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <\"Leia\">\nat index <1> but found:\n <\"Luke\">\nin:\n <[\"Yoda\", \"Luke\"]>\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContainExactly_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainExactly_create_Test.java
index 59306e730..4fe968f93 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainExactly_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainExactly_create_Test.java
@@ -60,7 +60,7 @@ public class ShouldContainExactly_create_Test {
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <[\"Yoda\", \"Han\"]>\nto contain exactly (and in same order):\n"
         + " <[\"Luke\", \"Yoda\"]>\nbut some elements were not found:\n <[\"Luke\"]>\nand others were not expected:\n"
-        + " <[\"Han\"]>\naccording to 'CaseInsensitiveStringComparator' comparator", message);
+        + " <[\"Han\"]>\nwhen comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 
   @Test
@@ -79,7 +79,7 @@ public class ShouldContainExactly_create_Test {
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals(
         "[Test] \nActual and expected have the same elements but not in the same order, at index 1 actual element was:\n"
-            + " <\"Luke\">\nwhereas expected element was:\n <\"Han\">\naccording to 'CaseInsensitiveStringComparator' comparator",
+            + " <\"Luke\">\nwhereas expected element was:\n <\"Han\">\nwhen comparing values using 'CaseInsensitiveStringComparator'",
         message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContainOnly_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainOnly_create_Test.java
index 0710807fa..686ed686c 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainOnly_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainOnly_create_Test.java
@@ -57,6 +57,6 @@ public class ShouldContainOnly_create_Test {
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <[\"Yoda\", \"Han\"]>\nto contain only:\n <[\"Luke\", \"Yoda\"]>\n"
         + "elements not found:\n <[\"Luke\"]>\nand elements not expected:\n <[\"Han\"]>\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java
index e2538bf40..5994bb0f7 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainSequenceString_create_Test.java
@@ -59,7 +59,7 @@ public class ShouldContainSequenceString_create_Test {
         + "to contain the following CharSequences in this order:\n"
         + " <[\"{\", \"author\", \"title\", \"}\"]>\n"
         + "but <\"title\"> was found before <\"author\">\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContainSequence_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainSequence_create_Test.java
index 7df5868ee..10a46ca7c 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainSequence_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainSequence_create_Test.java
@@ -54,6 +54,6 @@ public class ShouldContainSequence_create_Test {
         new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <[\"Yoda\", \"Luke\"]>\nto contain sequence:\n <[\"Han\", \"Leia\"]>\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContainString_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainString_create_Test.java
index 924a49ed2..b8af9e9ae 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainString_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainString_create_Test.java
@@ -49,7 +49,7 @@ public class ShouldContainString_create_Test {
     factory = shouldContain("Yoda", "Luke",
                             new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <\"Yoda\">\nto contain:\n <\"Luke\"> according to 'CaseInsensitiveStringComparator' comparator",
+    assertEquals("[Test] \nExpecting:\n <\"Yoda\">\nto contain:\n <\"Luke\"> when comparing values using 'CaseInsensitiveStringComparator'",
                  message);
   }
 
diff --git a/src/test/java/org/assertj/core/error/ShouldContainSubsequence_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainSubsequence_create_Test.java
index 29e5dee93..9caa1b8fd 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainSubsequence_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainSubsequence_create_Test.java
@@ -52,6 +52,6 @@ public class ShouldContainSubsequence_create_Test {
         new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <[\"Yoda\", \"Luke\"]>\nto contain subsequence:\n <[\"Han\", \"Leia\"]>\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldContain_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContain_create_Test.java
index 77924fa16..01a59aa53 100644
--- a/src/test/java/org/assertj/core/error/ShouldContain_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContain_create_Test.java
@@ -56,7 +56,7 @@ public class ShouldContain_create_Test {
         CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <[\"Yoda\"]>\nto contain:\n <[\"Luke\", \"Yoda\"]>\nbut could not find:\n"
-        + " <[\"Luke\"]>\naccording to 'CaseInsensitiveStringComparator' comparator", message);
+        + " <[\"Luke\"]>\nwhen comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 
 
diff --git a/src/test/java/org/assertj/core/error/ShouldContainsOnlyOnce_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainsOnlyOnce_create_Test.java
index 0ca57d872..a984f9559 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainsOnlyOnce_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainsOnlyOnce_create_Test.java
@@ -69,7 +69,7 @@ public class ShouldContainsOnlyOnce_create_Test {
         " <[\"Luke\"]>\n" +
         "and others were found more than once:\n" +
         " <[\"Han\"]>\n" +
-        "according to 'CaseInsensitiveStringComparator' comparator", message);
+        "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/error/ShouldContainsStringOnlyOnce_create_Test.java b/src/test/java/org/assertj/core/error/ShouldContainsStringOnlyOnce_create_Test.java
index 8fd5cc6a4..e717dd07a 100644
--- a/src/test/java/org/assertj/core/error/ShouldContainsStringOnlyOnce_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldContainsStringOnlyOnce_create_Test.java
@@ -45,7 +45,7 @@ public class ShouldContainsStringOnlyOnce_create_Test {
         new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals(
-        "[Test] \nExpecting:\n <\"MOtif\">\nto appear only once in:\n <\"aaamoDifmoifaabbbmotfaaa\">\nbut it did not appear according to 'CaseInsensitiveStringComparator' comparator",
+        "[Test] \nExpecting:\n <\"MOtif\">\nto appear only once in:\n <\"aaamoDifmoifaabbbmotfaaa\">\nbut it did not appear when comparing values using 'CaseInsensitiveStringComparator'",
         message);
   }
 
@@ -55,7 +55,7 @@ public class ShouldContainsStringOnlyOnce_create_Test {
         new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals(
-        "[Test] \nExpecting:\n <\"MOtif\">\nto appear only once in:\n <\"aaamotIFmoTifaabbbmotifaaa\">\nbut it appeared 3 times according to 'CaseInsensitiveStringComparator' comparator",
+        "[Test] \nExpecting:\n <\"MOtif\">\nto appear only once in:\n <\"aaamotIFmoTifaabbbmotifaaa\">\nbut it appeared 3 times when comparing values using 'CaseInsensitiveStringComparator'",
         message);
   }
 
diff --git a/src/test/java/org/assertj/core/error/ShouldEndWith_create_Test.java b/src/test/java/org/assertj/core/error/ShouldEndWith_create_Test.java
index 9c9158553..e1c629bce 100644
--- a/src/test/java/org/assertj/core/error/ShouldEndWith_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldEndWith_create_Test.java
@@ -49,6 +49,6 @@ public class ShouldEndWith_create_Test {
         CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <[\"Yoda\", \"Luke\"]>\nto end with:\n <[\"Han\", \"Leia\"]>\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveComparableElementsAccordingToComparator_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveComparableElementsAccordingToComparator_create_Test.java
index 137802732..d4e90fc74 100644
--- a/src/test/java/org/assertj/core/error/ShouldHaveComparableElementsAccordingToComparator_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldHaveComparableElementsAccordingToComparator_create_Test.java
@@ -1,32 +1,33 @@
 /*
  * Created on Sep 17, 2010
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2010-2011 the original author or authors.
  */
 package org.assertj.core.error;
 
-import static junit.framework.Assert.assertEquals;
-
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.ShouldBeSorted.shouldHaveComparableElementsAccordingToGivenComparator;
 import static org.assertj.core.util.Arrays.array;
 
 import org.assertj.core.internal.TestDescription;
 import org.assertj.core.presentation.StandardRepresentation;
 import org.assertj.core.util.CaseInsensitiveStringComparator;
-import org.junit.*;
-
+import org.junit.Before;
+import org.junit.Test;
 
 /**
- * Tests for <code>{@link ShouldBeSorted#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for
+ * <code>{@link ShouldBeSorted#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>
+ * .
  * 
  * @author Joel Costigliola
  */
@@ -36,14 +37,15 @@ public class ShouldHaveComparableElementsAccordingToComparator_create_Test {
 
   @Before
   public void setUp() {
-    factory = shouldHaveComparableElementsAccordingToGivenComparator(array("b", "c", "a"), new CaseInsensitiveStringComparator());
+	factory = shouldHaveComparableElementsAccordingToGivenComparator(array("b", "c", "a"),
+	                                                                 new CaseInsensitiveStringComparator());
   }
 
   @Test
   public void should_create_error_message() {
-    String message = factory.create(new TestDescription("Test"), new StandardRepresentation());
-    assertEquals(
-        "[Test] \nsome elements are not mutually comparable according to 'CaseInsensitiveStringComparator' comparator in group:\n<[\"b\", \"c\", \"a\"]>",
-        message);
+	String message = factory.create(new TestDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \nsome elements are not mutually comparable according to 'CaseInsensitiveStringComparator' comparator in group:\n"
+	                                  + "<[\"b\", \"c\", \"a\"]>");
+
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldNotBeEqual_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotBeEqual_create_Test.java
index ed1317486..193e14fdb 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotBeEqual_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotBeEqual_create_Test.java
@@ -51,6 +51,6 @@ public class ShouldNotBeEqual_create_Test {
     factory = shouldNotBeEqual("Yoda", "Luke", new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TestDescription("Jedi"), new StandardRepresentation());
     assertEquals(
-        "[Jedi] \nExpecting:\n <\"Yoda\">\nnot to be equal to:\n <\"Luke\">\naccording to 'CaseInsensitiveStringComparator' comparator", message);
+        "[Jedi] \nExpecting:\n <\"Yoda\">\nnot to be equal to:\n <\"Luke\">\nwhen comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldNotBeIn_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotBeIn_create_Test.java
index 7f16a40f4..6b49140df 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotBeIn_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotBeIn_create_Test.java
@@ -1,24 +1,23 @@
 /*
  * Created on Feb 3, 2011
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2011 the original author or authors.
  */
 package org.assertj.core.error;
 
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.ShouldNotBeIn.shouldNotBeIn;
 import static org.assertj.core.util.Arrays.array;
 
-import static org.junit.Assert.assertEquals;
-
 import org.assertj.core.description.TextDescription;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.presentation.StandardRepresentation;
@@ -26,9 +25,10 @@ import org.assertj.core.util.CaseInsensitiveStringComparator;
 import org.junit.Before;
 import org.junit.Test;
 
-
 /**
- * Tests for <code>{@link ShouldNotBeIn#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for
+ * <code>{@link ShouldNotBeIn#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>
+ * .
  * 
  * @author Yvonne Wang
  * @author Joel Costigliola
@@ -39,21 +39,29 @@ public class ShouldNotBeIn_create_Test {
 
   @Before
   public void setUp() {
-    factory = shouldNotBeIn("Luke", array("Luke", "Leia"));
+	factory = shouldNotBeIn("Luke", array("Luke", "Leia"));
   }
 
   @Test
   public void should_create_error_message() {
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <\"Luke\">\nnot to be in:\n <[\"Luke\", \"Leia\"]>\n", message);
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n"
+	                              + "Expecting:\n"
+	                              + " <\"Luke\">\n"
+	                              + "not to be in:\n"
+	                              + " <[\"Luke\", \"Leia\"]>\n");
   }
 
   @Test
   public void should_create_error_message_with_custom_comparison_strategy() {
-    factory = shouldNotBeIn("Luke", array("Luke", "Leia"), new ComparatorBasedComparisonStrategy(
-        CaseInsensitiveStringComparator.instance));
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <\"Luke\">\nnot to be in:\n <[\"Luke\", \"Leia\"]>\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+	factory = shouldNotBeIn("Luke", array("Luke", "Leia"),
+	                        new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n"
+	                              + "Expecting:\n"
+	                              + " <\"Luke\">\n"
+	                              + "not to be in:\n"
+	                              + " <[\"Luke\", \"Leia\"]>\n"
+	                              + "when comparing values using 'CaseInsensitiveStringComparator'");
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldNotContainAtIndex_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotContainAtIndex_create_Test.java
index 106bc54b3..3d13cbb72 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotContainAtIndex_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotContainAtIndex_create_Test.java
@@ -53,6 +53,6 @@ public class ShouldNotContainAtIndex_create_Test {
         new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <[\"Yoda\", \"Luke\"]>\nnot to contain:\n <\"Luke\">\n"
-        + "at index <1>\n" + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "at index <1>\n" + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldNotContainString_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotContainString_create_Test.java
index 70fc07412..c7faaaeda 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotContainString_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotContainString_create_Test.java
@@ -46,7 +46,7 @@ public class ShouldNotContainString_create_Test {
     ErrorMessageFactory factory = shouldNotContain("Yoda", "od", new ComparatorBasedComparisonStrategy(
         CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting:\n <\"Yoda\">\nnot to contain:\n <\"od\"> according to 'CaseInsensitiveStringComparator' comparator",
+    assertEquals("[Test] \nExpecting:\n <\"Yoda\">\nnot to contain:\n <\"od\"> when comparing values using 'CaseInsensitiveStringComparator'",
         message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldNotContain_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotContain_create_Test.java
index 84f586b02..ccbbfcd9e 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotContain_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotContain_create_Test.java
@@ -14,10 +14,10 @@
  */
 package org.assertj.core.error;
 
-import static junit.framework.Assert.assertEquals;
+import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.ShouldNotContain.shouldNotContain;
-import static org.assertj.core.util.Lists.*;
-import static org.assertj.core.util.Sets.*;
+import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Sets.newLinkedHashSet;
 
 import org.assertj.core.description.TextDescription;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
@@ -26,7 +26,9 @@ import org.assertj.core.util.CaseInsensitiveStringComparator;
 import org.junit.Test;
 
 /**
- * Tests for <code>{@link ShouldNotContain#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>.
+ * Tests for
+ * <code>{@link ShouldNotContain#create(org.assertj.core.description.Description, org.assertj.core.presentation.Representation)}</code>
+ * .
  * 
  * @author Alex Ruiz
  * @author Yvonne Wang
@@ -36,19 +38,32 @@ public class ShouldNotContain_create_Test {
 
   @Test
   public void should_create_error_message() {
-    ErrorMessageFactory factory = shouldNotContain(newArrayList("Yoda"), newArrayList("Luke", "Yoda"),
-        newLinkedHashSet("Yoda"));
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting\n <[\"Yoda\"]>\nnot to contain\n <[\"Luke\", \"Yoda\"]>\nbut found\n <[\"Yoda\"]>\n",
-        message);
+	ErrorMessageFactory factory = shouldNotContain(newArrayList("Yoda"), newArrayList("Luke", "Yoda"),
+	                                               newLinkedHashSet("Yoda"));
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n" +
+	                              "Expecting\n" +
+	                              " <[\"Yoda\"]>\n" +
+	                              "not to contain\n" +
+	                              " <[\"Luke\", \"Yoda\"]>\n" +
+	                              "but found\n" +
+	                              " <[\"Yoda\"]>\n");
   }
 
   @Test
   public void should_create_error_message_with_custom_comparison_strategy() {
-    ErrorMessageFactory factory = shouldNotContain(newArrayList("Yoda"), newArrayList("Luke", "Yoda"),
-        newLinkedHashSet("Yoda"), new ComparatorBasedComparisonStrategy(CaseInsensitiveStringComparator.instance));
-    String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
-    assertEquals("[Test] \nExpecting\n <[\"Yoda\"]>\nnot to contain\n <[\"Luke\", \"Yoda\"]>\n"
-        + "but found\n <[\"Yoda\"]>\naccording to 'CaseInsensitiveStringComparator' comparator", message);
+	ErrorMessageFactory factory = shouldNotContain(newArrayList("Yoda"),
+	                                               newArrayList("Luke", "Yoda"),
+	                                               newLinkedHashSet("Yoda"),
+	                                               new ComparatorBasedComparisonStrategy(
+	                                                                                     CaseInsensitiveStringComparator.instance));
+	String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
+	assertThat(message).isEqualTo("[Test] \n" +
+	                              "Expecting\n" +
+	                              " <[\"Yoda\"]>\n" +
+	                              "not to contain\n" +
+	                              " <[\"Luke\", \"Yoda\"]>\n" +
+	                              "but found\n <[\"Yoda\"]>\n" +
+	                              "when comparing values using 'CaseInsensitiveStringComparator'");
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldNotHaveDuplicates_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotHaveDuplicates_create_Test.java
index 8bb97ec45..ecb69a6bc 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotHaveDuplicates_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotHaveDuplicates_create_Test.java
@@ -54,6 +54,6 @@ public class ShouldNotHaveDuplicates_create_Test {
         CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nFound duplicate(s):\n <[\"Yoda\"]>\nin:\n <[\"Yoda\", \"Yoda\", \"Luke\"]>\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldStartWith_create_Test.java b/src/test/java/org/assertj/core/error/ShouldStartWith_create_Test.java
index fe6cb6c75..e462299c3 100644
--- a/src/test/java/org/assertj/core/error/ShouldStartWith_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldStartWith_create_Test.java
@@ -54,6 +54,6 @@ public class ShouldStartWith_create_Test {
         CaseInsensitiveStringComparator.instance));
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     assertEquals("[Test] \nExpecting:\n <[\"Yoda\", \"Luke\"]>\nto start with:\n <[\"Han\", \"Leia\"]>\n"
-        + "according to 'CaseInsensitiveStringComparator' comparator", message);
+        + "when comparing values using 'CaseInsensitiveStringComparator'", message);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/FieldByFieldComparisonStrategy_areEqual_Test.java b/src/test/java/org/assertj/core/internal/FieldByFieldComparisonStrategy_areEqual_Test.java
index fbd721116..9965a02ab 100644
--- a/src/test/java/org/assertj/core/internal/FieldByFieldComparisonStrategy_areEqual_Test.java
+++ b/src/test/java/org/assertj/core/internal/FieldByFieldComparisonStrategy_areEqual_Test.java
@@ -1,60 +1,64 @@
 package org.assertj.core.internal;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.ExpectedException.none;
 
+import org.assertj.core.test.ExpectedException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
-
 public class FieldByFieldComparisonStrategy_areEqual_Test {
 
-    private FieldByFieldComparisonStrategy fieldByFieldComparisonStrategy;
+  @Rule
+  public ExpectedException thrown = none();
 
-    @Before
-    public void setUp() {
-        fieldByFieldComparisonStrategy = new FieldByFieldComparisonStrategy();
-    }
+  private FieldByFieldComparisonStrategy fieldByFieldComparisonStrategy;
 
-    @Test
-    public void should_return_true_if_both_Objects_are_null() {
-        assertTrue(fieldByFieldComparisonStrategy.areEqual(null, null));
-    }
+  @Before
+  public void setUp() {
+	fieldByFieldComparisonStrategy = new FieldByFieldComparisonStrategy();
+  }
 
-    @Test
-    public void should_return_true_if_Objects_are_equal() {
-        assertTrue(fieldByFieldComparisonStrategy.areEqual(new JarJar("Yoda"), new JarJar("Yoda")));
-    }
+  @Test
+  public void should_return_true_if_both_Objects_are_null() {
+	assertThat(fieldByFieldComparisonStrategy.areEqual(null, null)).isTrue();
+  }
 
-    @Test
-    public void should_return_false_if_Objects_are_not_equal() {
-        assertFalse(fieldByFieldComparisonStrategy.areEqual(new JarJar("Yoda"), new JarJar("HanSolo")));
-    }
+  @Test
+  public void should_return_true_if_Objects_are_equal() {
+	assertThat(fieldByFieldComparisonStrategy.areEqual(new JarJar("Yoda"), new JarJar("Yoda"))).isTrue();
+  }	
 
-    @Test
-    public void should_return_are_not_equal_if_first_Object_is_null_and_second_is_not() {
-        assertFalse(fieldByFieldComparisonStrategy.areEqual(null, new JarJar("Yoda")));
-    }
+  @Test
+  public void should_return_false_if_Objects_are_not_equal() {
+	assertThat(fieldByFieldComparisonStrategy.areEqual(new JarJar("Yoda"), new JarJar("HanSolo"))).isFalse();
+  }
 
-    @Test
-    public void should_return_are_not_equal_if_second_Object_is_null_and_first_is_not() {
-        assertFalse(fieldByFieldComparisonStrategy.areEqual(new JarJar("Yoda"), null));
-    }
+  @Test
+  public void should_return_are_not_equal_if_first_Object_is_null_and_second_is_not() {
+	assertThat(fieldByFieldComparisonStrategy.areEqual(null, new JarJar("Yoda"))).isFalse();
+  }
 
-    @Test
-    public void should_return_are_not_equal_if_Objects_are_not_equal() {
-        assertFalse(fieldByFieldComparisonStrategy.areEqual(new JarJar("Yoda"), 2));
-    }
+  @Test
+  public void should_return_are_not_equal_if_second_Object_is_null_and_first_is_not() {
+	assertThat(fieldByFieldComparisonStrategy.areEqual(new JarJar("Yoda"), null)).isFalse();
+  }
 
-    public static class JarJar {
+  @Test
+  public void should_throw_exception_if_Objects_have_not_the_same_properties() {
+	thrown.expect(IllegalArgumentException.class);
+	assertThat(fieldByFieldComparisonStrategy.areEqual(new JarJar("Yoda"), 2)).isFalse();
+  }
 
-        public final String field;
+  public static class JarJar {
 
-        public JarJar(String field) {
-            this.field = field;
-        }
+	public final String field;
 
-    }
+	public JarJar(String field) {
+	  this.field = field;
+	}
 
+  }
 
 }
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/IgnoringFieldsComparisonStrategy_areEqual_Test.java b/src/test/java/org/assertj/core/internal/IgnoringFieldsComparisonStrategy_areEqual_Test.java
index ca551bd91..b29bfac44 100644
--- a/src/test/java/org/assertj/core/internal/IgnoringFieldsComparisonStrategy_areEqual_Test.java
+++ b/src/test/java/org/assertj/core/internal/IgnoringFieldsComparisonStrategy_areEqual_Test.java
@@ -1,61 +1,68 @@
 package org.assertj.core.internal;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.ExpectedException.none;
 
+import org.assertj.core.test.ExpectedException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
-
 public class IgnoringFieldsComparisonStrategy_areEqual_Test {
 
-    private IgnoringFieldsComparisonStrategy ignoringFieldsComparisonStrategy;
+  @Rule
+  public ExpectedException thrown = none();
+
+  private IgnoringFieldsComparisonStrategy ignoringFieldsComparisonStrategy;
 
-    @Before
-    public void setUp() {
-        ignoringFieldsComparisonStrategy = new IgnoringFieldsComparisonStrategy("thinking");
-    }
+  @Before
+  public void setUp() {
+	ignoringFieldsComparisonStrategy = new IgnoringFieldsComparisonStrategy("thinking");
+  }
 
-    @Test
-    public void should_return_true_if_both_Objects_are_null() {
-        assertTrue(ignoringFieldsComparisonStrategy.areEqual(null, null));
-    }
+  @Test
+  public void should_return_true_if_both_Objects_are_null() {
+	assertThat(ignoringFieldsComparisonStrategy.areEqual(null, null)).isTrue();
+  }
 
-    @Test
-    public void should_return_are_not_equal_if_first_Object_is_null_and_second_is_not() {
-        assertFalse(ignoringFieldsComparisonStrategy.areEqual(null, new DarthVader("I like you", "I'll kill you")));
-    }
+  @Test
+  public void should_return_are_not_equal_if_first_Object_is_null_and_second_is_not() {
+	assertThat(ignoringFieldsComparisonStrategy.areEqual(null, new DarthVader("I like you", "I'll kill you"))).isFalse();
+  }
 
-    @Test
-    public void should_return_are_not_equal_if_second_Object_is_null_and_first_is_not() {
-        assertFalse(ignoringFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), null));
-    }
+  @Test
+  public void should_return_are_not_equal_if_second_Object_is_null_and_first_is_not() {
+	assertThat(ignoringFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), null)).isFalse();
+  }
 
-    @Test
-    public void should_return_true_if_all_but_ignored_fields_are_equal() {
-        assertTrue(ignoringFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), new DarthVader("I like you", "I like you")));
-    }
+  @Test
+  public void should_return_true_if_all_but_ignored_fields_are_equal() {
+	assertThat(ignoringFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"),
+	                                                     new DarthVader("I like you", "I like you"))).isTrue();
+  }
 
-    @Test
-    public void should_return_false_if_all_but_ignored_fields_are_not_equal() {
-        assertFalse(ignoringFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), new DarthVader("I'll kill you", "I'll kill you")));
-    }
+  @Test
+  public void should_return_false_if_all_but_ignored_fields_are_not_equal() {
+	assertThat(ignoringFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"),
+	                                                      new DarthVader("I'll kill you", "I'll kill you"))).isFalse();
+  }
 
-    @Test
-    public void should_return_are_not_equal_if_Objects_are_not_equal() {
-        assertFalse(ignoringFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), 2));
-    }
+  @Test
+  public void should_throw_exception_if_Objects_have_not_the_same_properties() {
+	thrown.expect(IllegalArgumentException.class);
+	assertThat(ignoringFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), 2)).isFalse();
+  }
 
-    public static class DarthVader {
+  public static class DarthVader {
 
-        public final String telling;
-        public final String thinking;
+	public final String telling;
+	public final String thinking;
 
-        public DarthVader(String telling, String thinking) {
-            this.telling = telling;
-            this.thinking = thinking;
-        }
+	public DarthVader(String telling, String thinking) {
+	  this.telling = telling;
+	  this.thinking = thinking;
+	}
 
-    }
+  }
 
 }
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/OnFieldsComparisonStrategy_areEqual_Test.java b/src/test/java/org/assertj/core/internal/OnFieldsComparisonStrategy_areEqual_Test.java
index 384c6cfca..8d3e0438f 100644
--- a/src/test/java/org/assertj/core/internal/OnFieldsComparisonStrategy_areEqual_Test.java
+++ b/src/test/java/org/assertj/core/internal/OnFieldsComparisonStrategy_areEqual_Test.java
@@ -1,62 +1,70 @@
 package org.assertj.core.internal;
 
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertTrue;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.ExpectedException.none;
 
+import org.assertj.core.test.ExpectedException;
 import org.junit.Before;
+import org.junit.Rule;
 import org.junit.Test;
 
-
 public class OnFieldsComparisonStrategy_areEqual_Test {
 
-    private OnFieldsComparisonStrategy onFieldsComparisonStrategy;
-
-    @Before
-    public void setUp() {
-        onFieldsComparisonStrategy = new OnFieldsComparisonStrategy("telling");
-    }
-
-    @Test
-    public void should_return_true_if_both_Objects_are_null() {
-        assertTrue(onFieldsComparisonStrategy.areEqual(null, null));
-    }
-
-    @Test
-    public void should_return_are_not_equal_if_first_Object_is_null_and_second_is_not() {
-        assertFalse(onFieldsComparisonStrategy.areEqual(null, new DarthVader("I like you", "I'll kill you")));
-    }
-
-    @Test
-    public void should_return_are_not_equal_if_second_Object_is_null_and_first_is_not() {
-        assertFalse(onFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), null));
-    }
-
-    @Test
-    public void should_return_true_if_given_fields_are_equal() {
-        assertTrue(onFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), new DarthVader("I like you", "I like you")));
-    }
-
-    @Test
-    public void should_return_false_if_given_fields_are_not_equal() {
-        assertFalse(onFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), new DarthVader("I'll kill you", "I'll kill you")));
-    }
-
-    @Test
-    public void should_return_are_not_equal_if_Objects_are_not_equal() {
-        assertFalse(onFieldsComparisonStrategy.areEqual(new DarthVader("I like you", "I'll kill you"), 2));
-    }
-
-    public static class DarthVader {
-
-        public final String telling;
-        public final String thinking;
-
-        public DarthVader(String telling, String thinking) {
-            this.telling = telling;
-            this.thinking = thinking;
-        }
-
-    }
-
+  @Rule
+  public ExpectedException thrown = none();
+
+  private OnFieldsComparator onFieldsComparator;
+
+  @Before
+  public void setUp() {
+	onFieldsComparator = new OnFieldsComparator("telling");
+  }
+
+  @Test
+  public void should_return_true_if_both_Objects_are_null() {
+	assertThat(onFieldsComparator.compare(null, null)).isZero();
+  }
+
+  @Test
+  public void should_return_are_not_equal_if_first_Object_is_null_and_second_is_not() {
+	assertThat(onFieldsComparator.compare(null, new DarthVader("I like you", "I'll kill you"))).isNotZero();
+  }
+
+  @Test
+  public void should_return_are_not_equal_if_second_Object_is_null_and_first_is_not() {
+	assertThat(onFieldsComparator.compare(new DarthVader("I like you", "I'll kill you"), null)).isNotZero();
+  }
+
+  @Test
+  public void should_return_true_if_given_fields_are_equal() {
+	DarthVader actual = new DarthVader("I like you", "I'll kill you");
+	DarthVader other = new DarthVader("I like you", "I like you");
+	assertThat(onFieldsComparator.compare(actual, other)).isZero();
+  }
+
+  @Test
+  public void should_return_false_if_given_fields_are_not_equal() {
+	DarthVader actual = new DarthVader("I like you", "I'll kill you");
+	DarthVader other = new DarthVader("I'll kill you", "I'll kill you");
+	assertThat(onFieldsComparator.compare(actual, other)).isNotZero();
+  }
+
+  @Test
+  public void should_throw_exception_if_Objects_have_not_the_same_properties() {
+	thrown.expect(IllegalArgumentException.class);
+	assertThat(onFieldsComparator.compare(new DarthVader("I like you", "I'll kill you"), 2)).isNotZero();
+  }
+
+  public static class DarthVader {
+
+	public final String telling;
+	public final String thinking;
+
+	public DarthVader(String telling, String thinking) {
+	  this.telling = telling;
+	  this.thinking = thinking;
+	}
+
+  }
 
 }
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsNotPositive_Test.java b/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsNotPositive_Test.java
index ee2a19345..158b129d1 100644
--- a/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsNotPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsNotPositive_Test.java
@@ -47,13 +47,13 @@ public class BigDecimals_assertIsNotPositive_Test extends BigDecimalsBaseTest {
 
   @Test
   public void should_fail_since_actual_can_be_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <-1>\nto be less than or equal to:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <-1>\nto be less than or equal to:\n <0> when comparing values using 'AbsValueComparator'");
     bigDecimalsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), new BigDecimal(-1));
   }
 
   @Test
   public void should_fail_since_actual_is_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <1>\nto be less than or equal to:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <1>\nto be less than or equal to:\n <0> when comparing values using 'AbsValueComparator'");
     bigDecimalsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), BigDecimal.ONE);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsPositive_Test.java b/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsPositive_Test.java
index f83a36a84..f9e29782f 100644
--- a/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/bigdecimals/BigDecimals_assertIsPositive_Test.java
@@ -55,7 +55,7 @@ public class BigDecimals_assertIsPositive_Test extends BigDecimalsBaseTest {
   @Test
   public void should_fail_since_actual_is_not_positive_according_to_custom_comparison_strategy() {
     thrown
-        .expectAssertionError("\nExpecting:\n <0>\nto be greater than:\n <0> according to 'BigDecimalComparator' comparator");
+        .expectAssertionError("\nExpecting:\n <0>\nto be greater than:\n <0> when comparing values using 'BigDecimalComparator'");
     bigDecimalsWithComparatorComparisonStrategy.assertIsPositive(someInfo(), BigDecimal.ZERO);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsNegative_Test.java b/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsNegative_Test.java
index 90f552593..6175ab37d 100644
--- a/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsNegative_Test.java
+++ b/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsNegative_Test.java
@@ -50,24 +50,24 @@ public class Bytes_assertIsNegative_Test extends BytesBaseTest {
 
   @Test
   public void should_fail_since_actual_is_not_negative_according_to_absolute_value_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <-6>\nto be less than:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <-6>\nto be less than:\n <0> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsNegative(someInfo(), (byte) -6);
   }
 
   @Test
   public void should_fail_since_actual_is_not_negative_according_to_absolute_value_comparison_strategy_in_hex_representation() {
-    thrown.expectAssertionError("\nExpecting:\n <0xFA>\nto be less than:\n <0x00> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <0xFA>\nto be less than:\n <0x00> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsNegative(someHexInfo(), (byte) 0xFA);
   }
 
   @Test
   public void should_fail_since_actual_is_not_negative_according_to_absolute_value_comparison_strategy2() {
-    thrown.expectAssertionError("\nExpecting:\n <6>\nto be less than:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <6>\nto be less than:\n <0> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsNegative(someInfo(), (byte) 6);
   }
   @Test
   public void should_fail_since_actual_is_not_negative_according_to_absolute_value_comparison_strategy2_in_hex_representation() {
-    thrown.expectAssertionError("\nExpecting:\n <0x06>\nto be less than:\n <0x00> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <0x06>\nto be less than:\n <0x00> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsNegative(someHexInfo(), (byte) 0x06);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsNotPositive_Test.java b/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsNotPositive_Test.java
index 78b9d1d88..b7416f027 100644
--- a/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsNotPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsNotPositive_Test.java
@@ -52,25 +52,25 @@ public class Bytes_assertIsNotPositive_Test extends BytesBaseTest {
 
   @Test
   public void should_fail_since_actual_can_be_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <-1>\nto be less than or equal to:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <-1>\nto be less than or equal to:\n <0> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), (byte) -1);
   }
 
   @Test
   public void should_fail_since_actual_can_be_positive_according_to_custom_comparison_strategy_in_hex_representation() {
-    thrown.expectAssertionError("\nExpecting:\n <0xFF>\nto be less than or equal to:\n <0x00> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <0xFF>\nto be less than or equal to:\n <0x00> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsNotPositive(someHexInfo(), (byte) 0xFF);
   }
 
   @Test
   public void should_fail_since_actual_is_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <1>\nto be less than or equal to:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <1>\nto be less than or equal to:\n <0> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), (byte) 1);
   }
 
   @Test
   public void should_fail_since_actual_is_positive_according_to_custom_comparison_strategy_in_hex_representation() {
-    thrown.expectAssertionError("\nExpecting:\n <0x01>\nto be less than or equal to:\n <0x00> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <0x01>\nto be less than or equal to:\n <0x00> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsNotPositive(someHexInfo(), (byte) 0x01);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsPositive_Test.java b/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsPositive_Test.java
index 2847a3f00..cb4797278 100644
--- a/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/bytes/Bytes_assertIsPositive_Test.java
@@ -55,14 +55,14 @@ public class Bytes_assertIsPositive_Test extends BytesBaseTest {
   @Test
   public void should_fail_since_actual_is_not_positive_according_to_custom_comparison_strategy() {
     thrown
-        .expectAssertionError("\nExpecting:\n <0>\nto be greater than:\n <0> according to 'AbsValueComparator' comparator");
+        .expectAssertionError("\nExpecting:\n <0>\nto be greater than:\n <0> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsPositive(someInfo(), (byte) 0);
   }
 
   @Test
   public void should_fail_since_actual_is_not_positive_according_to_custom_comparison_strategy_in_hex_representation() {
     thrown
-        .expectAssertionError("\nExpecting:\n <0x00>\nto be greater than:\n <0x00> according to 'AbsValueComparator' comparator");
+        .expectAssertionError("\nExpecting:\n <0x00>\nto be greater than:\n <0x00> when comparing values using 'AbsValueComparator'");
     bytesWithAbsValueComparisonStrategy.assertIsPositive(someHexInfo(), (byte) 0x00);
   }
 }
diff --git a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNegative_Test.java b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNegative_Test.java
index d0d681007..fc075e970 100644
--- a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNegative_Test.java
+++ b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNegative_Test.java
@@ -43,13 +43,13 @@ public class Doubles_assertIsNegative_Test extends DoublesBaseTest {
 
   @Test
   public void should_fail_since_actual_is_not_negative_according_to_absolute_value_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <-6.0>\nto be less than:\n <0.0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <-6.0>\nto be less than:\n <0.0> when comparing values using 'AbsValueComparator'");
     doublesWithAbsValueComparisonStrategy.assertIsNegative(someInfo(), -6.0d);
   }
 
   @Test
   public void should_fail_since_actual_is_not_negative_according_to_absolute_value_comparison_strategy2() {
-    thrown.expectAssertionError("\nExpecting:\n <6.0>\nto be less than:\n <0.0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <6.0>\nto be less than:\n <0.0> when comparing values using 'AbsValueComparator'");
     doublesWithAbsValueComparisonStrategy.assertIsNegative(someInfo(), 6.0d);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNotPositive_Test.java b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNotPositive_Test.java
index d0028d899..74f7e953c 100644
--- a/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNotPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/doubles/Doubles_assertIsNotPositive_Test.java
@@ -45,13 +45,13 @@ public class Doubles_assertIsNotPositive_Test extends DoublesBaseTest {
 
   @Test
   public void should_fail_since_actual_can_be_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <-1.0>\nto be less than or equal to:\n <0.0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <-1.0>\nto be less than or equal to:\n <0.0> when comparing values using 'AbsValueComparator'");
     doublesWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), -1d);
   }
 
   @Test
   public void should_fail_since_actual_is_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <1.0>\nto be less than or equal to:\n <0.0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <1.0>\nto be less than or equal to:\n <0.0> when comparing values using 'AbsValueComparator'");
     doublesWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), 1d);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/floats/Floats_assertIsNegative_Test.java b/src/test/java/org/assertj/core/internal/floats/Floats_assertIsNegative_Test.java
index 436819ddb..b9285ed05 100644
--- a/src/test/java/org/assertj/core/internal/floats/Floats_assertIsNegative_Test.java
+++ b/src/test/java/org/assertj/core/internal/floats/Floats_assertIsNegative_Test.java
@@ -43,7 +43,7 @@ public class Floats_assertIsNegative_Test extends FloatsBaseTest {
 
   @Test
   public void should_fail_since_actual_is_not_negative_according_to_absolute_value_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <-6.0f>\nto be less than:\n <0.0f> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <-6.0f>\nto be less than:\n <0.0f> when comparing values using 'AbsValueComparator'");
     floatsWithAbsValueComparisonStrategy.assertIsNegative(someInfo(), (float) -6);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/floats/Floats_assertIsNotPositive_Test.java b/src/test/java/org/assertj/core/internal/floats/Floats_assertIsNotPositive_Test.java
index 4d32dad6d..b1d9843c8 100644
--- a/src/test/java/org/assertj/core/internal/floats/Floats_assertIsNotPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/floats/Floats_assertIsNotPositive_Test.java
@@ -1,17 +1,14 @@
 /*
  * Created on May 28, 2012
  * 
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
- * with the
- * License. You may obtain a copy of the License at
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
  * 
  * http://www.apache.org/licenses/LICENSE-2.0
  * 
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
- * on an "AS IS"
- * BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific
- * language
- * governing permissions and limitations under the License.
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
  * 
  * Copyright @2010-2012 the original author or authors.
  */
@@ -23,7 +20,6 @@ import org.assertj.core.internal.FloatsBaseTest;
 
 import org.junit.Test;
 
-
 /**
  * Tests for <code>{@link org.assertj.core.internal.Floats#assertIsNotPositive(org.assertj.core.api.AssertionInfo,
  * Comparable)} ())}</code>.
@@ -34,32 +30,30 @@ public class Floats_assertIsNotPositive_Test extends FloatsBaseTest {
 
   @Test
   public void should_succeed_since_actual_is_not_positive() {
-    floats.assertIsNotPositive(someInfo(), -6f);
+	floats.assertIsNotPositive(someInfo(), -6f);
   }
 
   @Test
   public void should_succeed_since_actual_is_zero() {
-    floats.assertIsNotPositive(someInfo(), 0f);
+	floats.assertIsNotPositive(someInfo(), 0f);
   }
 
   @Test
   public void should_fail_since_actual_is_positive() {
-    thrown.expectAssertionError("\nExpecting:\n <6.0f>\nto be less than or equal to:\n <0.0f>");
-    floats.assertIsNotPositive(someInfo(), 6f);
+	thrown.expectAssertionError("\nExpecting:\n <6.0f>\nto be less than or equal to:\n <0.0f>");
+	floats.assertIsNotPositive(someInfo(), 6f);
   }
 
   @Test
   public void should_fail_since_actual_can_be_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <-1.0f>\nto be less than or equal to:\n <0.0f> according to " +
-                                  "'AbsValueComparator' comparator");
-    floatsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), -1f);
+	thrown.expectAssertionError("\nExpecting:\n <-1.0f>\nto be less than or equal to:\n <0.0f> when comparing values using 'AbsValueComparator'");
+	floatsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), -1f);
   }
 
   @Test
   public void should_fail_since_actual_is_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <1.0f>\nto be less than or equal to:\n <0.0f> according to " +
-                                  "'AbsValueComparator' comparator");
-    floatsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), 1f);
+	thrown.expectAssertionError("\nExpecting:\n <1.0f>\nto be less than or equal to:\n <0.0f> when comparing values using 'AbsValueComparator'");
+	floatsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), 1f);
   }
 
 }
diff --git a/src/test/java/org/assertj/core/internal/integers/Integers_assertIsNegative_Test.java b/src/test/java/org/assertj/core/internal/integers/Integers_assertIsNegative_Test.java
index b590e8c6c..5d3634bb9 100644
--- a/src/test/java/org/assertj/core/internal/integers/Integers_assertIsNegative_Test.java
+++ b/src/test/java/org/assertj/core/internal/integers/Integers_assertIsNegative_Test.java
@@ -43,7 +43,7 @@ public class Integers_assertIsNegative_Test extends IntegersBaseTest {
 
   @Test
   public void should_fail_since_actual_can_not_be_negative_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("Expecting:\n <-1>\nto be less than:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("Expecting:\n <-1>\nto be less than:\n <0> when comparing values using 'AbsValueComparator'");
     integersWithAbsValueComparisonStrategy.assertIsNegative(someInfo(), -1);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/integers/Integers_assertIsNotPositive_Test.java b/src/test/java/org/assertj/core/internal/integers/Integers_assertIsNotPositive_Test.java
index 2521a8c97..ea5a38e25 100644
--- a/src/test/java/org/assertj/core/internal/integers/Integers_assertIsNotPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/integers/Integers_assertIsNotPositive_Test.java
@@ -50,15 +50,13 @@ public class Integers_assertIsNotPositive_Test extends IntegersBaseTest {
 
   @Test
   public void should_fail_since_actual_can_be_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("Expecting:\n <-1>\nto be less than or equal to:\n <0> according to " +
-                                  "'AbsValueComparator' comparator");
+    thrown.expectAssertionError("Expecting:\n <-1>\nto be less than or equal to:\n <0> when comparing values using 'AbsValueComparator'");
     integersWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), -1);
   }
 
   @Test
   public void should_fail_since_actual_is_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("Expecting:\n <1>\nto be less than or equal to:\n <0> according to " +
-                                  "'AbsValueComparator' comparator");
+    thrown.expectAssertionError("Expecting:\n <1>\nto be less than or equal to:\n <0> when comparing values using 'AbsValueComparator'");
     integersWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), 1);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/integers/Integers_assertIsPositive_Test.java b/src/test/java/org/assertj/core/internal/integers/Integers_assertIsPositive_Test.java
index 9852c0128..7a5743e03 100644
--- a/src/test/java/org/assertj/core/internal/integers/Integers_assertIsPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/integers/Integers_assertIsPositive_Test.java
@@ -48,7 +48,7 @@ public class Integers_assertIsPositive_Test extends IntegersBaseTest {
   @Test
   public void should_fail_since_actual_is_not_positive_according_to_custom_comparison_strategy() {
     thrown
-        .expectAssertionError("\nExpecting:\n <0>\nto be greater than:\n <0> according to 'AbsValueComparator' comparator");
+        .expectAssertionError("\nExpecting:\n <0>\nto be greater than:\n <0> when comparing values using 'AbsValueComparator'");
     integersWithAbsValueComparisonStrategy.assertIsPositive(someInfo(), 0);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/longs/Longs_assertIsNegative_Test.java b/src/test/java/org/assertj/core/internal/longs/Longs_assertIsNegative_Test.java
index 12502a46c..297c69f00 100644
--- a/src/test/java/org/assertj/core/internal/longs/Longs_assertIsNegative_Test.java
+++ b/src/test/java/org/assertj/core/internal/longs/Longs_assertIsNegative_Test.java
@@ -43,7 +43,7 @@ public class Longs_assertIsNegative_Test extends LongsBaseTest {
 
   @Test
   public void should_fail_since_actual_can_not_be_negative_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("Expecting:\n <-1L>\nto be less than:\n <0L> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("Expecting:\n <-1L>\nto be less than:\n <0L> when comparing values using 'AbsValueComparator'");
     longsWithAbsValueComparisonStrategy.assertIsNegative(someInfo(), -1L);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/longs/Longs_assertIsNotPositive_Test.java b/src/test/java/org/assertj/core/internal/longs/Longs_assertIsNotPositive_Test.java
index 30c682d39..97e8d6ce3 100644
--- a/src/test/java/org/assertj/core/internal/longs/Longs_assertIsNotPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/longs/Longs_assertIsNotPositive_Test.java
@@ -45,13 +45,13 @@ public class Longs_assertIsNotPositive_Test extends LongsBaseTest {
 
   @Test
   public void should_fail_since_actual_can_be_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("Expecting:\n <-1L>\nto be less than or equal to:\n <0L> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("Expecting:\n <-1L>\nto be less than or equal to:\n <0L> when comparing values using 'AbsValueComparator'");
     longsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), -1L);
   }
 
   @Test
   public void should_fail_since_actual_is_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("Expecting:\n <1L>\nto be less than or equal to:\n <0L> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("Expecting:\n <1L>\nto be less than or equal to:\n <0L> when comparing values using 'AbsValueComparator'");
     longsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), 1L);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/longs/Longs_assertIsPositive_Test.java b/src/test/java/org/assertj/core/internal/longs/Longs_assertIsPositive_Test.java
index ff4a24ece..d7249a7dd 100644
--- a/src/test/java/org/assertj/core/internal/longs/Longs_assertIsPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/longs/Longs_assertIsPositive_Test.java
@@ -48,7 +48,7 @@ public class Longs_assertIsPositive_Test extends LongsBaseTest {
   @Test
   public void should_fail_since_actual_is_not_positive_according_to_custom_comparison_strategy() {
     thrown
-        .expectAssertionError("\nExpecting:\n <0L>\nto be greater than:\n <0L> according to 'AbsValueComparator' comparator");
+        .expectAssertionError("\nExpecting:\n <0L>\nto be greater than:\n <0L> when comparing values using 'AbsValueComparator'");
     longsWithAbsValueComparisonStrategy.assertIsPositive(someInfo(), 0L);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsNegative_Test.java b/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsNegative_Test.java
index c5f3faf0c..02e6fdde7 100644
--- a/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsNegative_Test.java
+++ b/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsNegative_Test.java
@@ -43,7 +43,7 @@ public class Shorts_assertIsNegative_Test extends ShortsBaseTest {
 
   @Test
   public void should_fail_since_actual_can_not_be_negative_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("\nExpecting:\n <-1>\nto be less than:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("\nExpecting:\n <-1>\nto be less than:\n <0> when comparing values using 'AbsValueComparator'");
     shortsWithAbsValueComparisonStrategy.assertIsNegative(someInfo(), (short) -1);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsNotPositive_Test.java b/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsNotPositive_Test.java
index 4650a5b4c..f67e99d1b 100644
--- a/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsNotPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsNotPositive_Test.java
@@ -45,13 +45,13 @@ public class Shorts_assertIsNotPositive_Test extends ShortsBaseTest {
 
   @Test
   public void should_fail_since_actual_can_be_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("Expecting:\n <-1>\nto be less than or equal to:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("Expecting:\n <-1>\nto be less than or equal to:\n <0> when comparing values using 'AbsValueComparator'");
     shortsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), (short) -1);
   }
 
   @Test
   public void should_fail_since_actual_is_positive_according_to_custom_comparison_strategy() {
-    thrown.expectAssertionError("Expecting:\n <1>\nto be less than or equal to:\n <0> according to 'AbsValueComparator' comparator");
+    thrown.expectAssertionError("Expecting:\n <1>\nto be less than or equal to:\n <0> when comparing values using 'AbsValueComparator'");
     shortsWithAbsValueComparisonStrategy.assertIsNotPositive(someInfo(), (short) 1);
   }
 
diff --git a/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsPositive_Test.java b/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsPositive_Test.java
index b27e2793b..394af2ddb 100644
--- a/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsPositive_Test.java
+++ b/src/test/java/org/assertj/core/internal/shorts/Shorts_assertIsPositive_Test.java
@@ -48,7 +48,7 @@ public class Shorts_assertIsPositive_Test extends ShortsBaseTest {
   @Test
   public void should_fail_since_actual_is_not_positive_according_to_custom_comparison_strategy() {
     thrown
-        .expectAssertionError("\nExpecting:\n <0>\nto be greater than:\n <0> according to 'AbsValueComparator' comparator");
+        .expectAssertionError("\nExpecting:\n <0>\nto be greater than:\n <0> when comparing values using 'AbsValueComparator'");
     shortsWithAbsValueComparisonStrategy.assertIsPositive(someInfo(), (short) 0);
   }
 }
diff --git a/src/test/java/org/assertj/core/util/StandardRepresentation_toStringOf_Test.java b/src/test/java/org/assertj/core/util/StandardRepresentation_toStringOf_Test.java
index 2d2b88dac..03cfce59a 100644
--- a/src/test/java/org/assertj/core/util/StandardRepresentation_toStringOf_Test.java
+++ b/src/test/java/org/assertj/core/util/StandardRepresentation_toStringOf_Test.java
@@ -143,7 +143,7 @@ public class StandardRepresentation_toStringOf_Test {
         return s1.length() - s2.length();
       }
     };
-    assertEquals("'Anonymous Comparator class'", new StandardRepresentation().toStringOf(anonymousComparator));
+    assertEquals("'anonymous comparator class'", new StandardRepresentation().toStringOf(anonymousComparator));
   }
 
   @Test
