diff --git a/src/main/java/org/assertj/core/util/introspection/Introspection.java b/src/main/java/org/assertj/core/util/introspection/Introspection.java
index a385b4c25..ae35044f7 100644
--- a/src/main/java/org/assertj/core/util/introspection/Introspection.java
+++ b/src/main/java/org/assertj/core/util/introspection/Introspection.java
@@ -107,7 +107,7 @@ public final class Introspection {
   }
 
   private static boolean isValidGetter(Method method) {
-    return method != null && !Modifier.isStatic(method.getModifiers());
+    return method != null && !Modifier.isStatic(method.getModifiers()) && !Void.TYPE.equals(method.getReturnType());
   }
 
   private static Method findMethod(String name, Object target) {
diff --git a/src/test/java/org/assertj/core/api/Assertions_useRepresentation_Test.java b/src/test/java/org/assertj/core/api/Assertions_useRepresentation_Test.java
index 9e5720c0c..dde04bdd5 100644
--- a/src/test/java/org/assertj/core/api/Assertions_useRepresentation_Test.java
+++ b/src/test/java/org/assertj/core/api/Assertions_useRepresentation_Test.java
@@ -17,13 +17,12 @@ import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.fail;
 
 import org.assertj.core.presentation.StandardRepresentation;
-import org.assertj.core.util.Introspection_getProperty_Test.Example;
 import org.junit.jupiter.api.AfterEach;
 import org.junit.jupiter.api.Test;
 
 class Assertions_useRepresentation_Test {
 
-  private CustomRepresentation customRepresentation = new CustomRepresentation();
+  private final CustomRepresentation customRepresentation = new CustomRepresentation();
 
   @AfterEach
   public void afterTest() {
@@ -31,14 +30,14 @@ class Assertions_useRepresentation_Test {
   }
 
   @Test
-  public void should_use_given_representation_in_assertion_error_messages() {
+  void should_use_given_representation_in_assertion_error_messages() {
     Assertions.useRepresentation(customRepresentation);
     assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat("foo").startsWith("bar"))
                                                    .withMessageContaining("$foo$").withMessageContaining("$bar$");
   }
 
   @Test
-  public void should_use_default_representation_in_assertion_error_messages_after_calling_useDefaultRepresentation() {
+  void should_use_default_representation_in_assertion_error_messages_after_calling_useDefaultRepresentation() {
     Assertions.useRepresentation(customRepresentation);
     Assertions.useDefaultRepresentation();
     try {
@@ -51,7 +50,10 @@ class Assertions_useRepresentation_Test {
     fail("AssertionError expected");
   }
 
-  private class CustomRepresentation extends StandardRepresentation {
+  private static class Example {
+  }
+
+  private static class CustomRepresentation extends StandardRepresentation {
 
     // override needed to hook specific formatting
     @Override
diff --git a/src/test/java/org/assertj/core/test/Employee.java b/src/test/java/org/assertj/core/test/Employee.java
index 1a2a99464..1d59090af 100644
--- a/src/test/java/org/assertj/core/test/Employee.java
+++ b/src/test/java/org/assertj/core/test/Employee.java
@@ -33,7 +33,7 @@ public class Employee {
   private int age;
   // keep private to test we are able to read private field without property
   @SuppressWarnings("unused")
-  private String city = "New York";
+  private final String city = "New York";
   private Map<String, String> attributes;
   private Map<String, Employee> relations;
 
diff --git a/src/test/java/org/assertj/core/util/Introspection_getProperty_Test.java b/src/test/java/org/assertj/core/util/Introspection_getProperty_Test.java
index aae810a8c..f181e35b2 100644
--- a/src/test/java/org/assertj/core/util/Introspection_getProperty_Test.java
+++ b/src/test/java/org/assertj/core/util/Introspection_getProperty_Test.java
@@ -12,63 +12,86 @@
  */
 package org.assertj.core.util;
 
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.introspection.Introspection.getPropertyGetter;
 
 import java.lang.reflect.Method;
 
 import org.assertj.core.util.introspection.IntrospectionError;
-import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
-public class Introspection_getProperty_Test {
+@DisplayName("Introspection getProperty")
+class Introspection_getProperty_Test {
 
-  private Employee judy;
-
-  @BeforeEach
-  public void initData() {
-    judy = new Employee(100000.0, 31);
-  }
+  private final Employee judy = new Employee(100000.0, 31);
 
   @Test
-  void get_getter_for_property() {
+  void should_succeed() {
+    // WHEN
     Method getter = getPropertyGetter("age", judy);
-    assertThat(getter).isNotNull();
+    // THEN
+    then(getter).isNotNull();
   }
 
   @Test
   void should_raise_an_error_because_of_missing_getter() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> getPropertyGetter("salary", judy))
-                                                       .withMessage("No getter for property 'salary' in org.assertj.core.util.Employee");
+    // WHEN
+    Throwable thrown = catchThrowable(() -> getPropertyGetter("salary", judy));
+    // THEN
+    then(thrown).isInstanceOf(IntrospectionError.class)
+                .hasMessage("No getter for property 'salary' in org.assertj.core.util.Employee");
   }
 
   @Test
   void should_raise_an_error_because_of_non_public_getter_when_getter_does_not_exists() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> getPropertyGetter("company", judy))
-                                                       .withMessage("No public getter for property 'company' in org.assertj.core.util.Employee");
+    // WHEN
+    Throwable thrown = catchThrowable(() -> getPropertyGetter("company", judy));
+    // THEN
+    then(thrown).isInstanceOf(IntrospectionError.class)
+                .hasMessage("No public getter for property 'company' in org.assertj.core.util.Employee");
   }
 
   @Test
   void should_raise_an_error_because_of_non_public_getter_when_getter_is_package_private() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> getPropertyGetter("firstJob", judy))
-                                                       .withMessage("No public getter for property 'firstJob' in org.assertj.core.util.Employee");
+    // WHEN
+    Throwable thrown = catchThrowable(() -> getPropertyGetter("firstJob", judy));
+    // THEN
+    then(thrown).isInstanceOf(IntrospectionError.class)
+                .hasMessage("No public getter for property 'firstJob' in org.assertj.core.util.Employee");
   }
 
   @Test
   void should_raise_an_error_because_of_non_public_getter_when_getter_is_in_superclass() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> getPropertyGetter("name",
-                                                                                           new Example()))
-                                                       .withMessage("No public getter for property 'name' in org.assertj.core.util.Introspection_getProperty_Test$Example");
+    // WHEN
+    Throwable thrown = catchThrowable(() -> getPropertyGetter("name", new Example()));
+    // THEN
+    then(thrown).isInstanceOf(IntrospectionError.class)
+                .hasMessage("No public getter for property 'name' in org.assertj.core.util.Introspection_getProperty_Test$Example");
+  }
+
+  @Test
+  void should_raise_an_error_because_of_getter_with_void_return_type() {
+    // WHEN
+    Throwable thrown = catchThrowable(() -> getPropertyGetter("surname", new VoidGetter()));
+    // THEN
+    then(thrown).isInstanceOf(IntrospectionError.class)
+                .hasMessage("No getter for property 'surname' in org.assertj.core.util.Introspection_getProperty_Test$VoidGetter");
   }
 
-  public static class Example extends Super {
+  static class Example extends Super {
   }
 
-  public static class Super {
+  static class Super {
     @SuppressWarnings("unused")
     private String getName() {
       return "a";
     }
   }
+
+  static class VoidGetter {
+    public void getSurname() {}
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/util/introspection/PropertyOrFieldSupport_getValueOf_Test.java b/src/test/java/org/assertj/core/util/introspection/PropertyOrFieldSupport_getValueOf_Test.java
index dd06c81fc..ea301e751 100644
--- a/src/test/java/org/assertj/core/util/introspection/PropertyOrFieldSupport_getValueOf_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/PropertyOrFieldSupport_getValueOf_Test.java
@@ -14,8 +14,9 @@ package org.assertj.core.util.introspection;
 
 import static java.util.Arrays.asList;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
-import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.introspection.FieldSupport.EXTRACTION_OF_PUBLIC_FIELD_ONLY;
 
 import java.util.HashMap;
 import java.util.List;
@@ -24,131 +25,159 @@ import java.util.Map;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.Name;
 import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
+@DisplayName("PropertyOrFieldSupport getValueOf")
 class PropertyOrFieldSupport_getValueOf_Test {
 
-  private PropertyOrFieldSupport propertyOrFieldSupport;
-  private Employee yoda;
+  private final PropertyOrFieldSupport underTest = PropertyOrFieldSupport.EXTRACTION;
+  private final Employee yoda = new Employee(1L, new Name("Yoda"), 800);
 
   @BeforeEach
-  public void setup() {
-    propertyOrFieldSupport = PropertyOrFieldSupport.EXTRACTION;
-    yoda = new Employee(1L, new Name("Yoda"), 800);
+  void setup() {
     yoda.setRelation("padawan", new Employee(3L, new Name("Luke", "Skywalker"), 24));
   }
 
   @Test
   void should_extract_property_value() {
-    Object value = propertyOrFieldSupport.getValueOf("age", yoda);
-
-    assertThat(value).isEqualTo(800);
+    // WHEN
+    Object value = underTest.getValueOf("age", yoda);
+    // THEN
+    then(value).isEqualTo(800);
   }
 
   @Test
   void should_extract_property_with_no_corresponding_field() {
-    Object value = propertyOrFieldSupport.getValueOf("adult", yoda);
-
-    assertThat(value).isEqualTo(true);
+    // WHEN
+    Object value = underTest.getValueOf("adult", yoda);
+    // THEN
+    then(value).isEqualTo(true);
   }
 
   @Test
   void should_prefer_properties_over_fields() {
-    Object extractedValue = propertyOrFieldSupport.getValueOf("name", employeeWithOverriddenName("Overridden Name"));
-
-    assertThat(extractedValue).isEqualTo(new Name("Overridden Name"));
+    // WHEN
+    Object extractedValue = underTest.getValueOf("name", employeeWithOverriddenName("Overridden Name"));
+    // THEN
+    then(extractedValue).isEqualTo(new Name("Overridden Name"));
   }
 
   @Test
   void should_extract_public_field_values_as_no_property_matches_given_name() {
-    Object value = propertyOrFieldSupport.getValueOf("id", yoda);
-
-    assertThat(value).isEqualTo(1L);
+    // WHEN
+    Object value = underTest.getValueOf("id", yoda);
+    // THEN
+    then(value).isEqualTo(1L);
   }
 
   @Test
   void should_extract_private_field_values_as_no_property_matches_given_name() {
-    Object value = propertyOrFieldSupport.getValueOf("city", yoda);
-
-    assertThat(value).isEqualTo("New York");
+    // WHEN
+    Object value = underTest.getValueOf("city", yoda);
+    // THEN
+    then(value).isEqualTo("New York");
   }
 
   @Test
   void should_fallback_to_field_if_exception_has_been_thrown_on_property_access() {
-    Object extractedValue = propertyOrFieldSupport.getValueOf("name", employeeWithBrokenName("Name"));
-
-    assertThat(extractedValue).isEqualTo(new Name("Name"));
+    // WHEN
+    Object extractedValue = underTest.getValueOf("name", employeeWithBrokenName("Name"));
+    // THEN
+    then(extractedValue).isEqualTo(new Name("Name"));
   }
 
   @Test
   void should_return_null_if_one_of_nested_property_or_field_value_is_null() {
-    Object value = propertyOrFieldSupport.getValueOf("surname.first", yoda);
-
-    assertThat(value).isNull();
+    // WHEN
+    Object value = underTest.getValueOf("surname.first", yoda);
+    // THEN
+    then(value).isNull();
   }
 
   @Test
   void should_extract_nested_property_field_combinations() {
+    // GIVEN
     Employee darth = new Employee(1L, new Name("Darth", "Vader"), 100);
     Employee luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
     darth.field = luke;
     luke.field = darth;
     luke.surname = new Name("Young", "Padawan");
-    Object value = propertyOrFieldSupport.getValueOf("me.field.me.field.me.field.surname.name", darth);
-    assertThat(value).isEqualTo("Young Padawan");
+    // WHEN
+    Object value = underTest.getValueOf("me.field.me.field.me.field.surname.name", darth);
+    // THEN
+    then(value).isEqualTo("Young Padawan");
   }
 
   @Test
   void should_extract_value_from_nested_map() {
+    // GIVEN
     Employee darth = new Employee(1L, new Name("Darth", "Vader"), 100);
     darth.setAttribute("side", "dark");
-
-    Object value = propertyOrFieldSupport.getValueOf("attributes.side", darth);
-    assertThat(value).isEqualTo("dark");
+    // WHEN
+    Object value = underTest.getValueOf("attributes.side", darth);
+    // THEN
+    then(value).isEqualTo("dark");
   }
 
   @Test
   void should_extract_nested_property_field_within_nested_map() {
-    Object value = propertyOrFieldSupport.getValueOf("relations.padawan.name.first", yoda);
-    assertThat(value).isEqualTo("Luke");
+    // WHEN
+    Object value = underTest.getValueOf("relations.padawan.name.first", yoda);
+    // THEN
+    then(value).isEqualTo("Luke");
   }
 
   @Test
   void should_throw_error_when_no_property_nor_field_match_given_name() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> propertyOrFieldSupport.getValueOf("unknown", yoda));
+    // WHEN
+    Throwable thrown = catchThrowable(() -> underTest.getValueOf("unknown", yoda));
+    // THEN
+    then(thrown).isInstanceOf(IntrospectionError.class);
   }
 
   @Test
   void should_throw_error_when_no_property_nor_public_field_match_given_name_if_extraction_is_limited_to_public_fields() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> {
-      propertyOrFieldSupport = new PropertyOrFieldSupport(new PropertySupport(),
-                                                          FieldSupport.EXTRACTION_OF_PUBLIC_FIELD_ONLY);
-
-      propertyOrFieldSupport.getValueOf("city", yoda);
-    });
+    // GIVEN
+    PropertyOrFieldSupport underTest = new PropertyOrFieldSupport(new PropertySupport(), EXTRACTION_OF_PUBLIC_FIELD_ONLY);
+    // WHEN
+    Throwable thrown = catchThrowable(() -> underTest.getValueOf("city", yoda));
+    // THEN
+    then(thrown).isInstanceOf(IntrospectionError.class);
   }
 
   @Test
   void should_throw_exception_when_given_property_or_field_name_is_null() {
-    assertThatIllegalArgumentException().isThrownBy(() -> propertyOrFieldSupport.getValueOf(null, yoda))
-                                        .withMessage("The name of the property/field to read should not be null");
+    // WHEN
+    Throwable thrown = catchThrowable(() -> underTest.getValueOf(null, yoda));
+    // THEN
+    then(thrown).isInstanceOf(IllegalArgumentException.class)
+                .hasMessage("The name of the property/field to read should not be null");
   }
 
   @Test
   void should_throw_exception_when_given_name_is_empty() {
-    assertThatIllegalArgumentException().isThrownBy(() -> propertyOrFieldSupport.getValueOf("", yoda))
-                                        .withMessage("The name of the property/field to read should not be empty");
+    // WHEN
+    Throwable thrown = catchThrowable(() -> underTest.getValueOf("", yoda));
+    // THEN
+    then(thrown).isInstanceOf(IllegalArgumentException.class)
+                .hasMessage("The name of the property/field to read should not be empty");
   }
 
   @Test
   void should_throw_exception_if_property_cannot_be_extracted_due_to_runtime_exception_during_property_access() {
-    assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> propertyOrFieldSupport.getValueOf("adult",
-                                                                                                           brokenEmployee()));
+    // WHEN
+    Throwable thrown = catchThrowable(() -> underTest.getValueOf("adult", brokenEmployee()));
+    // THEN
+    then(thrown).isInstanceOf(IntrospectionError.class);
   }
 
   @Test
   void should_throw_exception_if_no_object_is_given() {
-    assertThatIllegalArgumentException().isThrownBy(() -> propertyOrFieldSupport.getValueOf("name", null));
+    // WHEN
+    Throwable thrown = catchThrowable(() -> underTest.getValueOf("name", null));
+    // THEN
+    then(thrown).isInstanceOf(IllegalArgumentException.class);
   }
 
   @Test
@@ -174,23 +203,34 @@ class PropertyOrFieldSupport_getValueOf_Test {
 
   @Test
   void should_extract_field_value_if_only_static_getter_matches_name() {
-    Object value = propertyOrFieldSupport.getValueOf("city", new StaticPropertyEmployee());
-
-    assertThat(value).isEqualTo("New York");
+    // WHEN
+    Object value = underTest.getValueOf("city", new StaticPropertyEmployee());
+    // THEN
+    then(value).isEqualTo("New York");
   }
 
   @Test
   void should_extract_field_value_if_only_static_is_method_matches_name() {
-    Object value = propertyOrFieldSupport.getValueOf("tall", new StaticBooleanPropertyEmployee());
-
-    assertThat(value).isEqualTo(false);
+    // WHEN
+    Object value = underTest.getValueOf("tall", new StaticBooleanPropertyEmployee());
+    // THEN
+    then(value).isEqualTo(false);
   }
 
   @Test
   void should_extract_field_value_if_only_static_bare_method_matches_name() {
-    Object value = propertyOrFieldSupport.getValueOf("city", new StaticBarePropertyEmployee());
+    // WHEN
+    Object value = underTest.getValueOf("city", new StaticBarePropertyEmployee());
+    // THEN
+    then(value).isEqualTo("New York");
+  }
 
-    assertThat(value).isEqualTo("New York");
+  @Test
+  void should_extract_field_value_if_only_void_method_matches_name() {
+    // WHEN
+    Object value = underTest.getValueOf("city", new VoidGetterPropertyEmployee());
+    // THEN
+    then(value).isEqualTo("New York");
   }
 
   private Employee employeeWithBrokenName(String name) {
@@ -233,6 +273,7 @@ class PropertyOrFieldSupport_getValueOf_Test {
   }
 
   static class StaticBooleanPropertyEmployee extends Employee {
+    @SuppressWarnings("unused")
     boolean tall = false;
 
     public static boolean isTall() {
@@ -240,4 +281,8 @@ class PropertyOrFieldSupport_getValueOf_Test {
     }
   }
 
+  static class VoidGetterPropertyEmployee extends Employee {
+    public void getCity() {}
+  }
+
 }
