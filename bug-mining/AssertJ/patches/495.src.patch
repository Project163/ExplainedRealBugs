diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index d67a94eba..540c4de78 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -2623,10 +2623,16 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
    * <ul>
    *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
-   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but not the collection/array itself)</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
    * </ul>
+   * <p>You can change how the recursive assertion deals with arrays, collections, maps and optionals, see:</p>
+   * <ul>
+   *   <li>{@link RecursiveAssertionAssert#withCollectionAssertionPolicy(RecursiveAssertionConfiguration.CollectionAssertionPolicy)} for collections and arrays</li>
+   *   <li>{@link RecursiveAssertionAssert#withMapAssertionPolicy(RecursiveAssertionConfiguration.MapAssertionPolicy)} for maps</li>
+   *   <li>{@link RecursiveAssertionAssert#withOptionalAssertionPolicy(RecursiveAssertionConfiguration.OptionalAssertionPolicy)} for optionals</li>
+   * </ul>
    *
    * <p>It is possible to assert several predicates over the object graph in a row.</p>
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractMapAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractMapAssert.java
index 3c59cad6b..5f8814763 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractMapAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractMapAssert.java
@@ -2116,10 +2116,16 @@ public abstract class AbstractMapAssert<SELF extends AbstractMapAssert<SELF, ACT
    * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
    * <ul>
    *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
-   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but not the collection/array itself)</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
    * </ul>
+   * <p>You can change how the recursive assertion deals with arrays, collections, maps and optionals, see:</p>
+   * <ul>
+   *   <li>{@link RecursiveAssertionAssert#withCollectionAssertionPolicy(RecursiveAssertionConfiguration.CollectionAssertionPolicy)} for collections and arrays</li>
+   *   <li>{@link RecursiveAssertionAssert#withMapAssertionPolicy(RecursiveAssertionConfiguration.MapAssertionPolicy)} for maps</li>
+   *   <li>{@link RecursiveAssertionAssert#withOptionalAssertionPolicy(RecursiveAssertionConfiguration.OptionalAssertionPolicy)} for optionals</li>
+   * </ul>
    *
    * <p>It is possible to assert several predicates over the object graph in a row.</p>
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index aeb945b0f..1301fb9d3 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -4015,10 +4015,16 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
    * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
    * <ul>
    *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
-   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but not the collection/array itself)</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
    * </ul>
+   * <p>You can change how the recursive assertion deals with arrays, collections, maps and optionals, see:</p>
+   * <ul>
+   *   <li>{@link RecursiveAssertionAssert#withCollectionAssertionPolicy(RecursiveAssertionConfiguration.CollectionAssertionPolicy)} for collections and arrays</li>
+   *   <li>{@link RecursiveAssertionAssert#withMapAssertionPolicy(RecursiveAssertionConfiguration.MapAssertionPolicy)} for maps</li>
+   *   <li>{@link RecursiveAssertionAssert#withOptionalAssertionPolicy(RecursiveAssertionConfiguration.OptionalAssertionPolicy)} for optionals</li>
+   * </ul>
    *
    * <p>It is possible to assert several predicates over the object graph in a row.</p>
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
index a1aa1ed8a..84299dcdd 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractObjectAssert.java
@@ -1235,14 +1235,20 @@ public abstract class AbstractObjectAssert<SELF extends AbstractObjectAssert<SEL
    *
    * <p>The recursive algorithm employs cycle detection, so object graphs with cyclic references can safely be asserted over without causing looping.</p>
    *
-   * <p>This method enables recursive asserting using default configuration, which means all fields of all objects have the  
+   * <p>This method enables recursive asserting using default configuration, which means all fields of all objects have the
    * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
    * <ul>
    *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
-   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but not the collection/array itself)</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
    * </ul>
+   * <p>You can change how the recursive assertion deals with arrays, collections, maps and optionals, see:</p>
+   * <ul>
+   *   <li>{@link RecursiveAssertionAssert#withCollectionAssertionPolicy(RecursiveAssertionConfiguration.CollectionAssertionPolicy)} for collections and arrays</li>
+   *   <li>{@link RecursiveAssertionAssert#withMapAssertionPolicy(RecursiveAssertionConfiguration.MapAssertionPolicy)} for maps</li>
+   *   <li>{@link RecursiveAssertionAssert#withOptionalAssertionPolicy(RecursiveAssertionConfiguration.OptionalAssertionPolicy)} for optionals</li>
+   * </ul>
    *
    * <p>It is possible to assert several predicates over the object graph in a row.</p>
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/AbstractOptionalAssert.java b/assertj-core/src/main/java/org/assertj/core/api/AbstractOptionalAssert.java
index a9fb1d059..36e35620f 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/AbstractOptionalAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/AbstractOptionalAssert.java
@@ -557,10 +557,16 @@ public abstract class AbstractOptionalAssert<SELF extends AbstractOptionalAssert
    * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
    * <ul>
    *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
-   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but not the collection/array itself)</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
    * </ul>
+   * <p>You can change how the recursive assertion deals with arrays, collections, maps and optionals, see:</p>
+   * <ul>
+   *   <li>{@link RecursiveAssertionAssert#withCollectionAssertionPolicy(RecursiveAssertionConfiguration.CollectionAssertionPolicy)} for collections and arrays</li>
+   *   <li>{@link RecursiveAssertionAssert#withMapAssertionPolicy(RecursiveAssertionConfiguration.MapAssertionPolicy)} for maps</li>
+   *   <li>{@link RecursiveAssertionAssert#withOptionalAssertionPolicy(RecursiveAssertionConfiguration.OptionalAssertionPolicy)} for optionals</li>
+   * </ul>
    *
    * <p>It is possible to assert several predicates over the object graph in a row.</p>
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveAssertionAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveAssertionAssert.java
index e7db733c6..0bc884a10 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveAssertionAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveAssertionAssert.java
@@ -55,10 +55,16 @@ public class RecursiveAssertionAssert extends AbstractAssert<RecursiveAssertionA
    * {@link java.util.function.Predicate} applied to them (including primitive fields), no fields are excluded, but:
    * <ul>
    *   <li>The recursion does not enter into Java Class Library types (java.*, javax.*)</li>
-   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but the collection/array itself)</li>
+   *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Collection} and array elements (but not the collection/array itself)</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Map} values but not the map itself or its keys</li>
    *   <li>The {@link java.util.function.Predicate} is applied to {@link java.util.Optional} and primitive optional values</li>
    * </ul>
+   * <p>You can change how the recursive assertion deals with arrays, collections, maps and optionals, see:</p>
+   * <ul>
+   *   <li>{@link RecursiveAssertionAssert#withCollectionAssertionPolicy(RecursiveAssertionConfiguration.CollectionAssertionPolicy)} for collections and arrays</li>
+   *   <li>{@link RecursiveAssertionAssert#withMapAssertionPolicy(RecursiveAssertionConfiguration.MapAssertionPolicy)} for maps</li>
+   *   <li>{@link RecursiveAssertionAssert#withOptionalAssertionPolicy(RecursiveAssertionConfiguration.OptionalAssertionPolicy)} for optionals</li>
+   * </ul>
    *
    * <p>It is possible to assert several predicates over the object graph in a row.</p>
    *
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver.java
index 6b85f10ab..4b8e00018 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionDriver.java
@@ -154,6 +154,9 @@ public class RecursiveAssertionDriver {
 
   private void recurseIntoCollection(Predicate<Object> predicate, Collection<?> collection, FieldLocation fieldLocation) {
     // TODO handle collection if needed by policy
+    if (collection == null) {
+      return; // no way to recursive into the collection, anyway the collection node has already been visited
+    }
     int index = 0;
     for (Object element : collection) {
       assertRecursively(predicate, element, safeGetClass(element), fieldLocation.field(format(INDEX_FORMAT, index)));
@@ -162,6 +165,9 @@ public class RecursiveAssertionDriver {
   }
 
   private void recurseIntoArray(Predicate<Object> predicate, Object node, Class<?> nodeType, FieldLocation fieldLocation) {
+    if (node == null) {
+      return; // no way to recursive into the array, anyway the array node has already been visited
+    }
     Class<?> arrayType = nodeType.getComponentType();
     Object[] array = Arrays.asObjectArray(node);
     for (int i = 0; i < array.length; i++) {
@@ -198,6 +204,9 @@ public class RecursiveAssertionDriver {
   private void recurseIntoMap(Predicate<Object> predicate, Map<?, ?> node, FieldLocation fieldLocation) {
     // If we are here, we can assume the policy is not MAP_OBJECT_ONLY
     // For both policies VALUES_ONLY and MAP_OBJECT_AND_ENTRIES we have to recurse over the values.
+    if (node == null) {
+      return; // no way to recursive into the map, anyway the map node has already been visited
+    }
     recurseIntoMapValues(predicate, node, fieldLocation);
     if (configuration.getMapAssertionPolicy() == MAP_OBJECT_AND_ENTRIES) {
       recurseIntoMapKeys(predicate, node, fieldLocation);
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_hasNoNullFields_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_hasNoNullFields_Test.java
index 3f97490ba..91d912d40 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_hasNoNullFields_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/assertion/RecursiveAssertionAssert_hasNoNullFields_Test.java
@@ -15,11 +15,17 @@ package org.assertj.core.api.recursive.assertion;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.BDDAssertions.thenNoException;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.CollectionAssertionPolicy.COLLECTION_OBJECT_AND_ELEMENTS;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.MapAssertionPolicy.MAP_OBJECT_AND_ENTRIES;
+import static org.assertj.core.api.recursive.assertion.RecursiveAssertionConfiguration.OptionalAssertionPolicy.OPTIONAL_OBJECT_AND_VALUE;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 
 import java.util.ArrayList;
+import java.util.Collection;
 import java.util.List;
+import java.util.Map;
+import java.util.Optional;
 
 import org.junit.jupiter.api.Test;
 
@@ -86,4 +92,99 @@ class RecursiveAssertionAssert_hasNoNullFields_Test {
     }
   }
 
+  @SuppressWarnings("unused")
+  class OuterWithArray {
+    InnerWithArray inner = new InnerWithArray();
+    byte[] arrayOuter = null;
+  }
+
+  @SuppressWarnings("unused")
+  class InnerWithArray {
+    byte[] array = null;
+  }
+
+  @Test
+  public void should_report_null_arrays() {
+    // GIVEN
+    Object testObject = new OuterWithArray();
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(testObject).usingRecursiveAssertion()
+                                                                            .withCollectionAssertionPolicy(COLLECTION_OBJECT_AND_ELEMENTS)
+                                                                            .hasNoNullFields());
+    // THEN
+    then(error).hasMessageContainingAll("arrayOuter", "inner.array");
+
+    assertThat(testObject).usingRecursiveAssertion().hasNoNullFields();
+
+  }
+
+  @SuppressWarnings("unused")
+  class OuterWithCollection {
+    InnerWithCollection inner = new InnerWithCollection();
+    Collection<String> collectionOuter = null;
+  }
+
+  @SuppressWarnings("unused")
+  class InnerWithCollection {
+    Collection<String> collectionInner = null;
+  }
+
+  @Test
+  public void should_report_null_collections() {
+    // GIVEN
+    Object testObject = new OuterWithCollection();
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(testObject).usingRecursiveAssertion()
+                                                                            .withCollectionAssertionPolicy(COLLECTION_OBJECT_AND_ELEMENTS)
+                                                                            .hasNoNullFields());
+    // THEN
+    then(error).hasMessageContainingAll("collectionOuter", "inner.collection");
+  }
+
+  @SuppressWarnings("unused")
+  class OuterWithMap {
+    InnerWithMap inner = new InnerWithMap();
+    Map<String, String> mapOuter = null;
+  }
+
+  @SuppressWarnings("unused")
+  class InnerWithMap {
+    Map<String, String> mapInner = null;
+  }
+
+  @Test
+  public void should_report_null_maps() {
+    // GIVEN
+    Object testObject = new OuterWithMap();
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(testObject).usingRecursiveAssertion()
+                                                                            .withMapAssertionPolicy(MAP_OBJECT_AND_ENTRIES)
+                                                                            .hasNoNullFields());
+    // THEN
+    then(error).hasMessageContainingAll("mapOuter", "inner.mapInner");
+  }
+
+  @SuppressWarnings("unused")
+  class OuterWithOptional {
+    InnerWithOptional inner = new InnerWithOptional();
+    Optional<String> optionalOuter = null;
+  }
+
+  @SuppressWarnings("unused")
+  class InnerWithOptional {
+    Optional<String> optionalInner = null;
+  }
+
+  @Test
+  public void should_report_null_optionals() {
+    // GIVEN
+    Object testObject = new OuterWithOptional();
+    // WHEN
+    AssertionError error = expectAssertionError(() -> assertThat(testObject).usingRecursiveAssertion()
+                                                                            .withOptionalAssertionPolicy(OPTIONAL_OBJECT_AND_VALUE)
+                                                                            .hasNoNullFields());
+    // THEN
+    then(error).hasMessageContainingAll("optionalOuter", "inner.optional");
+  }
+
 }
