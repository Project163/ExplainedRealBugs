diff --git a/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java b/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java
index c92235e59..1cdf028f2 100644
--- a/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java
+++ b/src/main/java/org/assertj/core/api/DefaultAssertionErrorCollector.java
@@ -16,11 +16,15 @@ import static java.lang.String.format;
 import static java.util.Collections.synchronizedList;
 import static java.util.Collections.unmodifiableList;
 import static java.util.stream.Collectors.toList;
+import static org.assertj.core.extractor.Extractors.byName;
 
 import java.lang.reflect.Constructor;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.Optional;
+import java.util.stream.Stream;
+
+import org.assertj.core.util.introspection.IntrospectionError;
 
 public class DefaultAssertionErrorCollector implements AssertionErrorCollector {
 
@@ -160,17 +164,49 @@ public class DefaultAssertionErrorCollector implements AssertionErrorCollector {
 
   private static <T extends Throwable> T createNewInstanceWithLineNumberInErrorMessage(T error,
                                                                                        StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
+    T errorWithLineNumber = isOpentest4jAssertionFailedError(error)
+        ? buildOpentest4jAssertionFailedErrorWithLineNumbers(error, testStackTraceElement)
+        : buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(error, testStackTraceElement);
+    errorWithLineNumber.setStackTrace(error.getStackTrace());
+    Stream.of(error.getSuppressed()).forEach(suppressed -> errorWithLineNumber.addSuppressed(suppressed));
+    return errorWithLineNumber;
+  }
+
+  private static <T extends Throwable> boolean isOpentest4jAssertionFailedError(T error) {
+    return "org.opentest4j.AssertionFailedError".equals(error.getClass().getName());
+  }
+
+  private static <T extends Throwable> T buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(T error,
+                                                                                                       StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
     @SuppressWarnings("unchecked")
     Constructor<? extends T> constructor = (Constructor<? extends T>) error.getClass().getConstructor(String.class,
                                                                                                       Throwable.class);
-    T errorWithLineNumber = constructor.newInstance(buildErrorMessageWithLineNumber(error.getMessage(),
-                                                                                    testStackTraceElement),
-                                                    error.getCause());
-    errorWithLineNumber.setStackTrace(error.getStackTrace());
-    for (Throwable suppressed : error.getSuppressed()) {
-      errorWithLineNumber.addSuppressed(suppressed);
+    return constructor.newInstance(buildErrorMessageWithLineNumber(error.getMessage(), testStackTraceElement), error.getCause());
+  }
+
+  private static <T extends Throwable> T buildOpentest4jAssertionFailedErrorWithLineNumbers(T error,
+                                                                                            StackTraceElement testStackTraceElement) throws ReflectiveOperationException {
+    // AssertionFailedError has actual and expected fields of type ValueWrapper
+    Object actualWrapper = byName("actual").apply(error);
+    Object expectedWrapper = byName("expected").apply(error);
+    if (actualWrapper != null && expectedWrapper != null) {
+      // try to call AssertionFailedError(String message, Object expected, Object actual, Throwable cause)
+      try {
+        Object actual = byName("value").apply(actualWrapper);
+        Object expected = byName("value").apply(expectedWrapper);
+        Constructor<? extends T> constructor = (Constructor<? extends T>) error.getClass().getConstructor(String.class,
+                                                                                                          Object.class,
+                                                                                                          Object.class,
+                                                                                                          Throwable.class);
+        return constructor.newInstance(buildErrorMessageWithLineNumber(error.getMessage(), testStackTraceElement),
+                                                        expected,
+                                                        actual,
+                                                        error.getCause());
+      } catch (IntrospectionError e) {
+        // fallback to AssertionFailedError(String message, Throwable cause) constructor
+      }
     }
-    return errorWithLineNumber;
+    return buildAssertionErrorWithLineNumbersButNoActualOrExpectedValues(error, testStackTraceElement);
   }
 
   private static String buildErrorMessageWithLineNumber(String originalErrorMessage, StackTraceElement testStackTraceElement) {
diff --git a/src/test/java/org/example/test/DefaultAssertionErrorCollector_Test.java b/src/test/java/org/example/test/DefaultAssertionErrorCollector_Test.java
index ef3e02541..d7abcca02 100644
--- a/src/test/java/org/example/test/DefaultAssertionErrorCollector_Test.java
+++ b/src/test/java/org/example/test/DefaultAssertionErrorCollector_Test.java
@@ -14,6 +14,7 @@ package org.example.test;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.extractor.Extractors.byName;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 
 import java.util.List;
@@ -21,6 +22,7 @@ import java.util.List;
 import org.assertj.core.api.DefaultAssertionErrorCollector;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
+import org.opentest4j.AssertionFailedError;
 
 // not in an assertj package to be able to check the stack trace as we filter the stack trace element in assertj packages
 @DisplayName("DefaultAssertionErrorCollector assertionErrorsCollected")
@@ -39,9 +41,42 @@ class DefaultAssertionErrorCollector_Test {
     List<AssertionError> decoratedErrors = defaultAssertionErrorCollector.assertionErrorsCollected();
     // THEN
     then(decoratedErrors.get(0)).hasMessageContainingAll("at DefaultAssertionErrorCollector_Test.lambda",
-                                                         "(DefaultAssertionErrorCollector_Test.java:34)");
-    then(decoratedErrors.get(1)).hasMessageContaining("at DefaultAssertionErrorCollector_Test.lambda",
-                                                      "(DefaultAssertionErrorCollector_Test.java:35)");
+                                                         "(DefaultAssertionErrorCollector_Test.java:36)");
+    then(decoratedErrors.get(1)).hasMessageContainingAll("at DefaultAssertionErrorCollector_Test.lambda",
+                                                         "(DefaultAssertionErrorCollector_Test.java:37)");
+  }
+
+  @Test
+  void decorated_AssertionFailedError_should_keep_actual_and_expected_values_when_populated() {
+    // GIVEN
+    AssertionError error = expectAssertionError(() -> assertThat("foo").isEqualTo("bar"));
+    defaultAssertionErrorCollector.collectAssertionError(error);
+    // WHEN
+    AssertionError decoratedError = defaultAssertionErrorCollector.assertionErrorsCollected().get(0);
+    // THEN
+    then(decoratedError).isInstanceOf(AssertionFailedError.class);
+    Object actualInOriginalError = byName("actual.value").apply(error);
+    Object actualInDecoratedError = byName("actual.value").apply(decoratedError);
+    then(actualInDecoratedError).isSameAs(actualInOriginalError);
+    Object expectedInOriginalError = byName("expected.value").apply(error);
+    Object expectedInDecoratedError = byName("expected.value").apply(decoratedError);
+    then(expectedInDecoratedError).isSameAs(expectedInOriginalError);
+  }
+
+  @Test
+  void decorated_AssertionFailedError_should_not_have_null_actual_and_expected_values_when_not_populated() {
+    // GIVEN
+    AssertionError error = new AssertionFailedError("boom");
+    defaultAssertionErrorCollector.collectAssertionError(error);
+    // WHEN
+    AssertionError decoratedError = defaultAssertionErrorCollector.assertionErrorsCollected().get(0);
+    // THEN
+    then(decoratedError).isInstanceOf(AssertionFailedError.class)
+                        .hasMessageContainingAll(error.getMessage(),
+                                                 "(DefaultAssertionErrorCollector_Test.java:69)");
+    AssertionFailedError decoratedAssertionFailedError = (AssertionFailedError) decoratedError;
+    then(decoratedAssertionFailedError.isActualDefined()).isFalse();
+    then(decoratedAssertionFailedError.isExpectedDefined()).isFalse();
   }
 
 }
