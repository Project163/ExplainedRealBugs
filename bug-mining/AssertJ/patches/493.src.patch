diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 00e8ffc60..b8d267af3 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -14,12 +14,14 @@ package org.assertj.core.api.recursive.comparison;
 
 import static java.lang.String.format;
 import static java.util.Objects.deepEquals;
+import static java.util.stream.Collectors.groupingBy;
 import static java.util.stream.Collectors.joining;
+import static java.util.stream.Collectors.toList;
+import static java.util.stream.StreamSupport.stream;
 import static org.assertj.core.api.recursive.comparison.ComparisonDifference.rootComparisonDifference;
 import static org.assertj.core.api.recursive.comparison.DualValue.DEFAULT_ORDERED_COLLECTION_TYPES;
 import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
 import static org.assertj.core.util.IterableUtil.sizeOf;
-import static org.assertj.core.util.IterableUtil.toCollection;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newHashSet;
 
@@ -30,9 +32,9 @@ import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
-import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.Objects;
 import java.util.Optional;
 import java.util.Set;
 import java.util.concurrent.ConcurrentHashMap;
@@ -462,12 +464,12 @@ public class RecursiveComparisonDifferenceCalculator {
       // no need to inspect elements, arrays are not equal as they don't have the same size
       return;
     }
-    // register pair of elements with same index for later comparison as we compare elements in order
+    // register a pair of elements with same index for later comparison as we compare elements in order
     Iterator<?> expectedIterator = expectedCollection.iterator();
     int i = 0;
     for (Object element : actualCollection) {
-      FieldLocation elementFielLocation = dualValue.fieldLocation.field(format("[%d]", i));
-      DualValue elementDualValue = new DualValue(elementFielLocation, element, expectedIterator.next());
+      FieldLocation elementFieldLocation = dualValue.fieldLocation.field(format("[%d]", i));
+      DualValue elementDualValue = new DualValue(elementFieldLocation, element, expectedIterator.next());
       comparisonState.registerForComparison(elementDualValue);
       i++;
     }
@@ -493,41 +495,61 @@ public class RecursiveComparisonDifferenceCalculator {
       // no need to inspect elements, iterables are not equal as they don't have the same size
       return;
     }
-    // copy actual as we will remove elements found in expected
-    Collection<?> actualCopy = new LinkedList<>(toCollection(actual));
+    Map<Integer, ? extends List<?>> actualByHashCode = stream(actual.spliterator(), false).collect(groupingBy(Objects::hashCode,
+                                                                                                              toList()));
     List<Object> expectedElementsNotFound = list();
     for (Object expectedElement : expected) {
       boolean expectedElementMatched = false;
-      // compare recursively expectedElement to all remaining actual elements
-      Iterator<?> actualIterator = actualCopy.iterator();
-      while (actualIterator.hasNext()) {
-        Object actualElement = actualIterator.next();
-        // we need to get the currently visited dual values otherwise a cycle would cause an infinite recursion.
-        List<ComparisonDifference> differences = determineDifferences(actualElement, expectedElement, dualValue.fieldLocation,
-                                                                      comparisonState.visitedDualValues,
-                                                                      comparisonState.recursiveComparisonConfiguration);
-        if (differences.isEmpty()) {
-          // found an element in actual matching expectedElement, remove it as it can't be used to match other expected elements
-          actualIterator.remove();
-          expectedElementMatched = true;
-          // jump to next actual element check
-          break;
-        }
+      // speed up comparison by selecting actual elements matching expected hash code, note that the hash code might not be
+      // relevant if fields used to compute it are ignored in the recursive comparison, it's a good heuristic though to check
+      // the first actual elements that could match the expected one, worst case we compare all actual elements.
+      Integer expectedHash = Objects.hashCode(expectedElement);
+      List<?> actualHashBucket = actualByHashCode.get(expectedHash);
+      if (actualHashBucket != null) {
+        Iterator<?> actualIterator = actualHashBucket.iterator();
+        expectedElementMatched = searchIterableForElement(actualIterator, expectedElement, dualValue, comparisonState);
       }
+      // It may be that expectedElement matches an actual element in a different hash bucket, to account for this, we check the
+      // other actual elements for matches. This may result in O(n^2) complexity in the worst case.
       if (!expectedElementMatched) {
-        expectedElementsNotFound.add(expectedElement);
+        for (Map.Entry<Integer, ? extends List<?>> entry : actualByHashCode.entrySet()) {
+          // avoid checking the same bucket twice
+          if (entry.getKey().equals(expectedHash)) continue;
+          Iterator<?> actualIterator = entry.getValue().iterator();
+          expectedElementMatched = searchIterableForElement(actualIterator, expectedElement, dualValue, comparisonState);
+          if (expectedElementMatched) break;
+        }
+        if (!expectedElementMatched) expectedElementsNotFound.add(expectedElement);
       }
     }
 
     if (!expectedElementsNotFound.isEmpty()) {
       String unmatched = format("The following expected elements were not matched in the actual %s:%n  %s",
-                                actual.getClass().getSimpleName(), expectedElementsNotFound);
+        actual.getClass().getSimpleName(), expectedElementsNotFound);
       comparisonState.addDifference(dualValue, unmatched);
       // TODO could improve the error by listing the actual elements not in expected but that would need
       // another double loop inverting actual and expected to find the actual elements not matched in expected
     }
   }
 
+  private static boolean searchIterableForElement(Iterator<?> actualIterator, Object expectedElement,
+                                                  DualValue dualValue, ComparisonState comparisonState) {
+    while (actualIterator.hasNext()) {
+      Object actualElement = actualIterator.next();
+      // we need to get the currently visited dual values otherwise a cycle would cause an infinite recursion.
+      List<ComparisonDifference> differences = determineDifferences(actualElement, expectedElement,
+                                                                    dualValue.fieldLocation,
+                                                                    comparisonState.visitedDualValues,
+                                                                    comparisonState.recursiveComparisonConfiguration);
+      if (differences.isEmpty()) {
+        // found an element in actual matching expectedElement, remove it as it can't be used to match other expected elements
+        actualIterator.remove();
+        return true;
+      }
+    }
+    return false;
+  }
+
   // TODO replace by ordered map
   private static <K, V> void compareSortedMap(DualValue dualValue, ComparisonState comparisonState) {
     if (!dualValue.isActualFieldASortedMap()) {
diff --git a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
index 063023abf..de464961c 100644
--- a/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
+++ b/assertj-core/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.java
@@ -14,6 +14,7 @@ package org.assertj.core.api.recursive.comparison;
 
 import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.Type.FIRST;
 import static org.assertj.core.api.recursive.comparison.RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test.Type.SECOND;
 import static org.assertj.core.internal.objects.data.FriendlyPerson.friend;
@@ -23,6 +24,7 @@ import static org.junit.jupiter.params.provider.Arguments.arguments;
 
 import java.util.ArrayList;
 import java.util.List;
+import java.util.Objects;
 import java.util.stream.Stream;
 
 import org.assertj.core.api.RecursiveComparisonAssert_isEqualTo_BaseTest;
@@ -407,6 +409,19 @@ class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
       this.type = type;
     }
 
+    @Override
+    public boolean equals(Object o) {
+      if (this == o) return true;
+      if (o == null || getClass() != o.getClass()) return false;
+      PersonWithInt that = (PersonWithInt) o;
+      return type == that.type && Objects.equals(name, that.name);
+    }
+
+    @Override
+    public int hashCode() {
+      return Objects.hash(name, type);
+    }
+
     @Override
     public String toString() {
       return String.format("Person [name=%s, type=%s]", name, type);
@@ -420,13 +435,12 @@ class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
     List<PersonWithInt> persons = list(new PersonWithInt("name-1", 1),
                                        new PersonWithInt("name-2", 1),
                                        new PersonWithInt("name-2", 2));
-
     // WHEN/THEN
-    assertThat(persons).usingRecursiveComparison()
-                       .ignoringCollectionOrder()
-                       .isEqualTo(list(new PersonWithInt("name-2", 2),
-                                       new PersonWithInt("name-2", 1),
-                                       new PersonWithInt("name-1", 1)));
+    then(persons).usingRecursiveComparison()
+                 .ignoringCollectionOrder()
+                 .isEqualTo(list(new PersonWithInt("name-2", 2),
+                                 new PersonWithInt("name-2", 1),
+                                 new PersonWithInt("name-1", 1)));
   }
 
   // https://github.com/assertj/assertj/issues/2954
@@ -457,15 +471,16 @@ class RecursiveComparisonAssert_isEqualTo_ignoringCollectionOrder_Test
 
   @Test
   void evaluating_visited_dual_values_should_check_location() {
+    // GIVEN
     Data d1 = new Data("111");
     Data d2 = new Data("222");
     DataStore dataStore1 = createDataStore(d1, d2);
     DataStore dataStore2 = createDataStore(d2, d1);
-
-    assertThat(dataStore1).usingRecursiveComparison()
-                          .withEqualsForType((data1, data2) -> data1.text.equals(data2.text), Data.class)
-                          .ignoringCollectionOrder()
-                          .isEqualTo(dataStore2);
+    // WHEN/THEN
+    then(dataStore1).usingRecursiveComparison()
+                    .withEqualsForType((data1, data2) -> data1.text.equals(data2.text), Data.class)
+                    .ignoringCollectionOrder()
+                    .isEqualTo(dataStore2);
   }
 
   private static DataStore createDataStore(Data d1, Data d2) {
