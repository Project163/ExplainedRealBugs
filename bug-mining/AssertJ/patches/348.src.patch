diff --git a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
index 850a0b820..fd48e1693 100644
--- a/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
+++ b/src/main/java/org/assertj/core/presentation/StandardRepresentation.java
@@ -17,6 +17,8 @@ import static java.lang.reflect.Array.getLength;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Arrays.isArrayTypePrimitive;
 import static org.assertj.core.util.Arrays.isObjectArray;
+import static org.assertj.core.util.DateUtil.formatAsDatetime;
+import static org.assertj.core.util.DateUtil.formatAsDatetimeWithMs;
 import static org.assertj.core.util.Preconditions.checkArgument;
 import static org.assertj.core.util.Strings.concat;
 import static org.assertj.core.util.Strings.quote;
@@ -27,6 +29,10 @@ import java.lang.reflect.Array;
 import java.lang.reflect.Method;
 import java.text.SimpleDateFormat;
 import java.time.Duration;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.OffsetDateTime;
+import java.time.ZonedDateTime;
 import java.util.Calendar;
 import java.util.Collection;
 import java.util.Comparator;
@@ -59,7 +65,6 @@ import org.assertj.core.data.MapEntry;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.util.Arrays;
-import org.assertj.core.util.DateUtil;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.diff.ChangeDelta;
 import org.assertj.core.util.diff.DeleteDelta;
@@ -97,6 +102,8 @@ public class StandardRepresentation implements Representation {
   private static int maxElementsForPrinting = Configuration.MAX_ELEMENTS_FOR_PRINTING;
 
   private static final Map<Class<?>, Function<?, String>> customFormatterByType = new HashMap<>();
+  private static final Class<?>[] TYPE_WITH_UNAMBIGUOUS_REPRESENTATION = { Date.class, LocalDateTime.class, ZonedDateTime.class,
+      OffsetDateTime.class, Calendar.class };
 
   /**
    * It resets the static defaults for the standard representation.
@@ -168,6 +175,10 @@ public class StandardRepresentation implements Representation {
     if (object instanceof Class<?>) return toStringOf((Class<?>) object);
     if (object instanceof Date) return toStringOf((Date) object);
     if (object instanceof Duration) return toStringOf((Duration) object);
+    if (object instanceof LocalDate) return toStringOf((LocalDate) object);
+    if (object instanceof LocalDateTime) return toStringOf((LocalDateTime) object);
+    if (object instanceof OffsetDateTime) return toStringOf((OffsetDateTime) object);
+    if (object instanceof ZonedDateTime) return toStringOf((ZonedDateTime) object);
     if (object instanceof AtomicBoolean) return toStringOf((AtomicBoolean) object);
     if (object instanceof AtomicInteger) return toStringOf((AtomicInteger) object);
     if (object instanceof AtomicLong) return toStringOf((AtomicLong) object);
@@ -210,11 +221,22 @@ public class StandardRepresentation implements Representation {
 
   @Override
   public String unambiguousToStringOf(Object obj) {
-    return obj == null ? null
-        : String.format("%s (%s@%s)",
-                        toStringOf(obj),
-                        obj.getClass().isAnonymousClass() ? obj.getClass().getName() : obj.getClass().getSimpleName(),
-                        toHexString(System.identityHashCode(obj)));
+    // some types have already an unambiguous toString, no need to double down
+    if (hasAlreadyAnUnambiguousToStringOf(obj)) return toStringOf(obj);
+    return obj == null ? null : String.format("%s (%s@%s)", toStringOf(obj), classNameOf(obj), identityHexCodeOf(obj));
+  }
+
+  /**
+   * Determine whether the given object's type has a representation that is not ambiguous.
+   * @param obj the object to check
+   * @return true if the given object's type has a representation that is not ambiguous, false otherwise.
+   */
+  // not static so that it can be overridden
+  protected boolean hasAlreadyAnUnambiguousToStringOf(Object obj) {
+    for (int i = 0; i < TYPE_WITH_UNAMBIGUOUS_REPRESENTATION.length; i++) {
+      if (TYPE_WITH_UNAMBIGUOUS_REPRESENTATION[i].isInstance(obj)) return true;
+    }
+    return false;
   }
 
   /**
@@ -262,8 +284,8 @@ public class StandardRepresentation implements Representation {
         : quote(comparatorDescription);
   }
 
-  protected String toStringOf(Calendar c) {
-    return DateUtil.formatAsDatetime(c);
+  protected String toStringOf(Calendar calendar) {
+    return formatAsDatetime(calendar) + classNameDisambiguation(calendar);
   }
 
   protected String toStringOf(Class<?> c) {
@@ -283,8 +305,32 @@ public class StandardRepresentation implements Representation {
     return p.isDefault() ? String.format("%s", p.description) : String.format("'%s'", p.description);
   }
 
-  protected String toStringOf(Date d) {
-    return DateUtil.formatAsDatetimeWithMs(d);
+  protected String toStringOf(Date date) {
+    return formatAsDatetimeWithMs(date) + classNameDisambiguation(date);
+  }
+
+  protected String toStringOf(LocalDateTime localDateTime) {
+    return defaultToStringWithClassNameDisambiguation(localDateTime);
+  }
+
+  protected String toStringOf(OffsetDateTime offsetDateTime) {
+    return defaultToStringWithClassNameDisambiguation(offsetDateTime);
+  }
+
+  protected String toStringOf(ZonedDateTime zonedDateTime) {
+    return defaultToStringWithClassNameDisambiguation(zonedDateTime);
+  }
+
+  protected String toStringOf(LocalDate localDate) {
+    return defaultToStringWithClassNameDisambiguation(localDate);
+  }
+
+  protected String classNameDisambiguation(Object o) {
+    return String.format(" (%s)", o.getClass().getName());
+  }
+
+  private String defaultToStringWithClassNameDisambiguation(Object o) {
+    return o.toString() + classNameDisambiguation(o);
   }
 
   protected String toStringOf(Float f) {
@@ -542,4 +588,12 @@ public class StandardRepresentation implements Representation {
     return singleLineDescription == null || singleLineDescription.length() < maxLengthForSingleLineDescription;
   }
 
+  private static String identityHexCodeOf(Object obj) {
+    return toHexString(System.identityHashCode(obj));
+  }
+
+  private static Object classNameOf(Object obj) {
+    return obj.getClass().isAnonymousClass() ? obj.getClass().getName() : obj.getClass().getSimpleName();
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/AutoCloseableBDDSoftAssertionsTest.java b/src/test/java/org/assertj/core/api/AutoCloseableBDDSoftAssertionsTest.java
index 77370fc7d..a0a88b657 100644
--- a/src/test/java/org/assertj/core/api/AutoCloseableBDDSoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/AutoCloseableBDDSoftAssertionsTest.java
@@ -59,11 +59,11 @@ public class AutoCloseableBDDSoftAssertionsTest {
       softly.then(false).isTrue();
       softly.then(new boolean[] { false }).isEqualTo(new boolean[] { true });
 
-      softly.then(new Byte((byte) 0)).isEqualTo((byte) 1);
+      softly.then(Byte.valueOf((byte) 0)).isEqualTo((byte) 1);
       softly.then((byte) 2).inHexadecimal().isEqualTo((byte) 3);
       softly.then(new byte[] { 4 }).isEqualTo(new byte[] { 5 });
 
-      softly.then(new Character((char) 65)).isEqualTo(new Character((char) 66));
+      softly.then(Character.valueOf((char) 65)).isEqualTo(Character.valueOf((char) 66));
       softly.then((char) 67).isEqualTo((char) 68);
       softly.then(new char[] { 69 }).isEqualTo(new char[] { 70 });
 
@@ -73,7 +73,7 @@ public class AutoCloseableBDDSoftAssertionsTest {
 
       softly.then(parseDatetime("1999-12-31T23:59:59")).isEqualTo(parseDatetime("2000-01-01T00:00:01"));
 
-      softly.then(new Double(6.0d)).isEqualTo(new Double(7.0d));
+      softly.then(Double.valueOf(6.0d)).isEqualTo(Double.valueOf(7.0d));
       softly.then(8.0d).isEqualTo(9.0d);
       softly.then(new double[] { 10.0d }).isEqualTo(new double[] { 11.0d });
 
@@ -81,14 +81,14 @@ public class AutoCloseableBDDSoftAssertionsTest {
             .overridingErrorMessage(format("%nExpecting:%n <File(a)>%nto be equal to:%n <File(b)>%nbut was not."))
             .isEqualTo(new File("b"));
 
-      softly.then(new Float(12f)).isEqualTo(new Float(13f));
+      softly.then(Float.valueOf(12f)).isEqualTo(Float.valueOf(13f));
       softly.then(14f).isEqualTo(15f);
       softly.then(new float[] { 16f }).isEqualTo(new float[] { 17f });
 
       softly.then(new ByteArrayInputStream(new byte[] { (byte) 65 }))
             .hasSameContentAs(new ByteArrayInputStream(new byte[] { (byte) 66 }));
 
-      softly.then(new Integer(20)).isEqualTo(new Integer(21));
+      softly.then(Integer.valueOf(20)).isEqualTo(Integer.valueOf(21));
       softly.then(22).isEqualTo(23);
       softly.then(new int[] { 24 }).isEqualTo(new int[] { 25 });
 
@@ -96,13 +96,13 @@ public class AutoCloseableBDDSoftAssertionsTest {
       softly.then(list("28").iterator()).isExhausted();
       softly.then(list("30")).isEqualTo(Lists.newArrayList("31"));
 
-      softly.then(new Long(32L)).isEqualTo(new Long(33L));
+      softly.then(Long.valueOf(32L)).isEqualTo(Long.valueOf(33L));
       softly.then(34L).isEqualTo(35L);
       softly.then(new long[] { 36L }).isEqualTo(new long[] { 37L });
 
       softly.then(mapOf(MapEntry.entry("38", "39"))).isEqualTo(mapOf(MapEntry.entry("40", "41")));
 
-      softly.then(new Short((short) 42)).isEqualTo(new Short((short) 43));
+      softly.then(Short.valueOf((short) 42)).isEqualTo(Short.valueOf((short) 43));
       softly.then((short) 44).isEqualTo((short) 45);
       softly.then(new short[] { (short) 46 }).isEqualTo(new short[] { (short) 47 });
 
@@ -165,7 +165,7 @@ public class AutoCloseableBDDSoftAssertionsTest {
 
       assertThat(errors.get(11)).contains(format("%nExpecting:%n <java.lang.Object>%nto be equal to:%n <java.lang.String>%nbut was not."));
 
-      assertThat(errors.get(12)).contains(format("%nExpecting:%n <1999-12-31T23:59:59.000>%nto be equal to:%n <2000-01-01T00:00:01.000>%nbut was not."));
+      assertThat(errors.get(12)).contains(format("%nExpecting:%n <1999-12-31T23:59:59.000 (java.util.Date)>%nto be equal to:%n <2000-01-01T00:00:01.000 (java.util.Date)>%nbut was not."));
 
       assertThat(errors.get(13)).contains(format("%nExpecting:%n <6.0>%nto be equal to:%n <7.0>%nbut was not."));
       assertThat(errors.get(14)).contains(format("%nExpecting:%n <8.0>%nto be equal to:%n <9.0>%nbut was not."));
@@ -218,7 +218,8 @@ public class AutoCloseableBDDSoftAssertionsTest {
 
       assertThat(errors.get(42)).contains(format("%nExpecting:%n <12:00>%nto be equal to:%n <13:00>%nbut was not."));
       assertThat(errors.get(43)).contains(format("%nExpecting:%n <12:00Z>%nto be equal to:%n <13:00Z>%nbut was not."));
-      assertThat(errors.get(44)).contains(format("%nExpecting:%n <-999999999-01-01T00:00+18:00>%nto be equal to:%n <+999999999-12-31T23:59:59.999999999-18:00>%n" +
+      assertThat(errors.get(44)).contains(format("%nExpecting:%n <-999999999-01-01T00:00+18:00 (java.time.OffsetDateTime)>%nto be equal to:%n <+999999999-12-31T23:59:59.999999999-18:00 (java.time.OffsetDateTime)>%n"
+                                                 +
         "when comparing values using '%s'%nbut was not.", OffsetDateTimeByInstantComparator.getInstance()));
       return;
     }
diff --git a/src/test/java/org/assertj/core/api/AutoCloseableSoftAssertionsTest.java b/src/test/java/org/assertj/core/api/AutoCloseableSoftAssertionsTest.java
index 1cb14831f..5aad3c69d 100644
--- a/src/test/java/org/assertj/core/api/AutoCloseableSoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/AutoCloseableSoftAssertionsTest.java
@@ -65,11 +65,11 @@ public class AutoCloseableSoftAssertionsTest {
       softly.assertThat(false).isTrue();
       softly.assertThat(new boolean[] { false }).isEqualTo(new boolean[] { true });
 
-      softly.assertThat(new Byte((byte) 0)).isEqualTo((byte) 1);
+      softly.assertThat(Byte.valueOf((byte) 0)).isEqualTo((byte) 1);
       softly.assertThat((byte) 2).inHexadecimal().isEqualTo((byte) 3);
       softly.assertThat(new byte[] { 4 }).isEqualTo(new byte[] { 5 });
 
-      softly.assertThat(new Character((char) 65)).isEqualTo(new Character((char) 66));
+      softly.assertThat(Character.valueOf((char) 65)).isEqualTo(Character.valueOf((char) 66));
       softly.assertThat((char) 67).isEqualTo((char) 68);
       softly.assertThat(new char[] { 69 }).isEqualTo(new char[] { 70 });
 
@@ -79,7 +79,7 @@ public class AutoCloseableSoftAssertionsTest {
 
       softly.assertThat(parseDatetime("1999-12-31T23:59:59")).isEqualTo(parseDatetime("2000-01-01T00:00:01"));
 
-      softly.assertThat(new Double(6.0d)).isEqualTo(new Double(7.0d));
+      softly.assertThat(Double.valueOf(6.0d)).isEqualTo(Double.valueOf(7.0d));
       softly.assertThat(8.0d).isEqualTo(9.0d);
       softly.assertThat(new double[] { 10.0d }).isEqualTo(new double[] { 11.0d });
 
@@ -87,14 +87,14 @@ public class AutoCloseableSoftAssertionsTest {
             .overridingErrorMessage(format("%nExpecting:%n <File(a)>%nto be equal to:%n <File(b)>%nbut was not."))
             .isEqualTo(new File("b"));
 
-      softly.assertThat(new Float(12f)).isEqualTo(new Float(13f));
+      softly.assertThat(Float.valueOf(12f)).isEqualTo(Float.valueOf(13f));
       softly.assertThat(14f).isEqualTo(15f);
       softly.assertThat(new float[] { 16f }).isEqualTo(new float[] { 17f });
 
       softly.assertThat(new ByteArrayInputStream(new byte[] { (byte) 65 }))
             .hasSameContentAs(new ByteArrayInputStream(new byte[] { (byte) 66 }));
 
-      softly.assertThat(new Integer(20)).isEqualTo(new Integer(21));
+      softly.assertThat(Integer.valueOf(20)).isEqualTo(Integer.valueOf(21));
       softly.assertThat(22).isEqualTo(23);
       softly.assertThat(new int[] { 24 }).isEqualTo(new int[] { 25 });
 
@@ -102,13 +102,13 @@ public class AutoCloseableSoftAssertionsTest {
       softly.assertThat(list("28").iterator()).isExhausted();
       softly.assertThat(list("30")).isEqualTo(list("31"));
 
-      softly.assertThat(new Long(32L)).isEqualTo(new Long(33L));
+      softly.assertThat(Long.valueOf(32L)).isEqualTo(Long.valueOf(33L));
       softly.assertThat(34L).isEqualTo(35L);
       softly.assertThat(new long[] { 36L }).isEqualTo(new long[] { 37L });
 
       softly.assertThat(mapOf(entry("38", "39"))).isEqualTo(mapOf(entry("40", "41")));
 
-      softly.assertThat(new Short((short) 42)).isEqualTo(new Short((short) 43));
+      softly.assertThat(Short.valueOf((short) 42)).isEqualTo(Short.valueOf((short) 43));
       softly.assertThat((short) 44).isEqualTo((short) 45);
       softly.assertThat(new short[] { (short) 46 }).isEqualTo(new short[] { (short) 47 });
 
@@ -180,7 +180,7 @@ public class AutoCloseableSoftAssertionsTest {
 
       assertThat(errors.get(11)).contains(format("%nExpecting:%n <java.lang.Object>%nto be equal to:%n <java.lang.String>%nbut was not."));
 
-      assertThat(errors.get(12)).contains(format("%nExpecting:%n <1999-12-31T23:59:59.000>%nto be equal to:%n <2000-01-01T00:00:01.000>%nbut was not."));
+      assertThat(errors.get(12)).contains(format("%nExpecting:%n <1999-12-31T23:59:59.000 (java.util.Date)>%nto be equal to:%n <2000-01-01T00:00:01.000 (java.util.Date)>%nbut was not."));
 
       assertThat(errors.get(13)).contains(format("%nExpecting:%n <6.0>%nto be equal to:%n <7.0>%nbut was not."));
       assertThat(errors.get(14)).contains(format("%nExpecting:%n <8.0>%nto be equal to:%n <9.0>%nbut was not."));
@@ -230,10 +230,12 @@ public class AutoCloseableSoftAssertionsTest {
                                                    + "but was:%n"
                                                  + "  <\"something was wrong\">"));
       assertThat(errors.get(39)).contains(format("%nExpecting:%n <Optional[bad option]>%nto be equal to:%n <Optional[good option]>%nbut was not."));
-      assertThat(errors.get(40)).contains(format("%nExpecting:%n <2015-01-01>%nto be equal to:%n <2015-01-02>%nbut was not."));
-      assertThat(errors.get(41)).contains(format("%nExpecting:%n <2015-01-01T23:59:59>%nto be equal to:%n <2015-01-01T23:59>%n" +
+      assertThat(errors.get(40)).contains(format("%nExpecting:%n <2015-01-01 (java.time.LocalDate)>%nto be equal to:%n <2015-01-02 (java.time.LocalDate)>%nbut was not."));
+      assertThat(errors.get(41)).contains(format("%nExpecting:%n <2015-01-01T23:59:59 (java.time.LocalDateTime)>%nto be equal to:%n <2015-01-01T23:59 (java.time.LocalDateTime)>%n"
+                                                 +
         "when comparing values using '%s'%nbut was not.", ChronoLocalDateTimeComparator.getInstance()));
-      assertThat(errors.get(42)).contains(format("%nExpecting:%n <2015-01-01T23:59:59Z>%nto be equal to:%n <2015-01-01T23:59Z>%n" +
+      assertThat(errors.get(42)).contains(format("%nExpecting:%n <2015-01-01T23:59:59Z (java.time.ZonedDateTime)>%nto be equal to:%n <2015-01-01T23:59Z (java.time.ZonedDateTime)>%n"
+                                                 +
         "when comparing values using '%s'%nbut was not.", ChronoZonedDateTimeByInstantComparator.getInstance()));
 
       assertThat(errors.get(43)).contains(format("%nExpecting:%n <OptionalInt[0]>%nto be equal to:%n <1>%nbut was not."));
@@ -243,7 +245,8 @@ public class AutoCloseableSoftAssertionsTest {
       assertThat(errors.get(46)).contains(format("%nExpecting:%n <12:00>%nto be equal to:%n <13:00>%nbut was not."));
       assertThat(errors.get(47)).contains(format("%nExpecting:%n <12:00Z>%nto be equal to:%n <13:00Z>%nbut was not."));
 
-      assertThat(errors.get(48)).contains(format("%nExpecting:%n <-999999999-01-01T00:00+18:00>%nto be equal to:%n <+999999999-12-31T23:59:59.999999999-18:00>%n" +
+      assertThat(errors.get(48)).contains(format("%nExpecting:%n <-999999999-01-01T00:00+18:00 (java.time.OffsetDateTime)>%nto be equal to:%n <+999999999-12-31T23:59:59.999999999-18:00 (java.time.OffsetDateTime)>%n"
+                                                 +
         "when comparing values using '%s'%nbut was not.", OffsetDateTimeByInstantComparator.getInstance()));
 
       return;
diff --git a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
index 58c27c1cf..91804d292 100644
--- a/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/BDDSoftAssertionsTest.java
@@ -305,7 +305,7 @@ public class BDDSoftAssertionsTest extends BaseAssertionsTest {
     assertThat(errors.get(9)).contains(format("%nExpecting:%n <['E']>%nto be equal to:%n <['F']>%nbut was not."));
     assertThat(errors.get(10)).contains(format("%nExpecting:%n <a>%nto be equal to:%n <b>%nbut was not."));
     assertThat(errors.get(11)).contains(format("%nExpecting:%n <java.lang.Object>%nto be equal to:%n <java.lang.String>%nbut was not."));
-    assertThat(errors.get(12)).contains(format("%nExpecting:%n <1999-12-31T23:59:59.000>%nto be equal to:%n <2000-01-01T00:00:01.000>%nbut was not."));
+    assertThat(errors.get(12)).contains(format("%nExpecting:%n <1999-12-31T23:59:59.000 (java.util.Date)>%nto be equal to:%n <2000-01-01T00:00:01.000 (java.util.Date)>%nbut was not."));
     assertThat(errors.get(13)).contains(format("%nExpecting:%n <6.0>%nto be equal to:%n <7.0>%nbut was not."));
     assertThat(errors.get(14)).contains(format("%nExpecting:%n <8.0>%nto be equal to:%n <9.0>%nbut was not."));
     assertThat(errors.get(15)).contains(format("%nExpecting:%n <[10.0]>%nto be equal to:%n <[11.0]>%nbut was not."));
diff --git a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
index 0bb6ed31b..1b9650759 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertionsTest.java
@@ -345,7 +345,7 @@ public class SoftAssertionsTest extends BaseAssertionsTest {
 
       assertThat(errors.get(11)).contains(format("%nExpecting:%n <java.lang.Object>%nto be equal to:%n <java.lang.String>%nbut was not."));
 
-      assertThat(errors.get(12)).contains(format("%nExpecting:%n <1999-12-31T23:59:59.000>%nto be equal to:%n <2000-01-01T00:00:01.000>%nbut was not."));
+      assertThat(errors.get(12)).contains(format("%nExpecting:%n <1999-12-31T23:59:59.000 (java.util.Date)>%nto be equal to:%n <2000-01-01T00:00:01.000 (java.util.Date)>%nbut was not."));
 
       assertThat(errors.get(13)).contains(format("%nExpecting:%n <6.0>%nto be equal to:%n <7.0>%nbut was not."));
       assertThat(errors.get(14)).contains(format("%nExpecting:%n <8.0>%nto be equal to:%n <9.0>%nbut was not."));
diff --git a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isEqualTo_Test.java
index 738dfc379..a90951deb 100644
--- a/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isEqualTo_Test.java
+++ b/src/test/java/org/assertj/core/api/localdate/LocalDateAssert_isEqualTo_Test.java
@@ -15,7 +15,8 @@ package org.assertj.core.api.localdate;
 import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
-import static org.assertj.core.util.AssertionsUtil.assertThatAssertionErrorIsThrownBy;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 
 import java.time.LocalDate;
 
@@ -40,10 +41,11 @@ public class LocalDateAssert_isEqualTo_Test extends LocalDateAssertBaseTest {
   @Test
   public void should_fail_if_actual_is_not_equal_to_date_as_string_parameter() {
     // WHEN
-    ThrowingCallable code = () -> assertThat(AFTER).isEqualTo(REFERENCE.toString());
+    AssertionError assertionError = expectAssertionError(() -> assertThat(AFTER).isEqualTo(REFERENCE.toString()));
     // THEN
-    assertThatAssertionErrorIsThrownBy(code).withMessage(format("%nExpecting:%n <%s>%nto be equal to:%n <%s>%nbut was not.",
-                                                                AFTER, REFERENCE));
+    then(assertionError).hasMessage(format("%nExpecting:%n <%s>%nto be equal to:%n <%s>%nbut was not.",
+                                           AFTER + " (java.time.LocalDate)",
+                                           REFERENCE + " (java.time.LocalDate)"));
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringHours_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringHours_Test.java
index 5b2405783..fb86cc790 100644
--- a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringHours_Test.java
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringHours_Test.java
@@ -15,8 +15,9 @@ package org.assertj.core.api.localdatetime;
 import static java.lang.String.format;
 import static org.assertj.core.api.AbstractLocalDateTimeAssert.NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.LocalDateTime;
@@ -34,24 +35,28 @@ public class LocalDateTimeAssert_isEqualToIgnoringHours_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_localdatetime_with_hour_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refLocalDateTime).isEqualToIgnoringHours(refLocalDateTime.minusHours(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-02T00:00>%nto have same year, month and day as:%n  <2000-01-01T23:00>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refLocalDateTime).isEqualToIgnoringHours(refLocalDateTime.minusHours(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-02T00:00 (java.time.LocalDateTime)>%nto have same year, month and day as:%n  <2000-01-01T23:00 (java.time.LocalDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_as_hours_fields_are_different_even_if_time_difference_is_less_than_a_hour() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refLocalDateTime).isEqualToIgnoringHours(refLocalDateTime.minusNanos(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-02T00:00>%nto have same year, month and day as:%n  <2000-01-01T23:59:59.999999999>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refLocalDateTime).isEqualToIgnoringHours(refLocalDateTime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-02T00:00 (java.time.LocalDateTime)>%nto have same year, month and day as:%n  <2000-01-01T23:59:59.999999999 (java.time.LocalDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      LocalDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringHours(LocalDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    LocalDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringHours(LocalDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringMinutes_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringMinutes_Test.java
index 77c6f7141..4c9bef560 100644
--- a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringMinutes_Test.java
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringMinutes_Test.java
@@ -15,15 +15,15 @@ package org.assertj.core.api.localdatetime;
 import static java.lang.String.format;
 import static org.assertj.core.api.AbstractLocalDateTimeAssert.NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.LocalDateTime;
 
 import org.junit.jupiter.api.Test;
 
-
 public class LocalDateTimeAssert_isEqualToIgnoringMinutes_Test {
 
   private final LocalDateTime refLocalDateTime = LocalDateTime.of(2000, 1, 1, 23, 0, 0, 0);
@@ -35,24 +35,28 @@ public class LocalDateTimeAssert_isEqualToIgnoringMinutes_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_localdatetime_with_minute_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refLocalDateTime).isEqualToIgnoringMinutes(refLocalDateTime.minusMinutes(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-01T23:00>%nto have same year, month, day and hour as:%n  <2000-01-01T22:59>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refLocalDateTime).isEqualToIgnoringMinutes(refLocalDateTime.minusMinutes(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-01T23:00 (java.time.LocalDateTime)>%nto have same year, month, day and hour as:%n  <2000-01-01T22:59 (java.time.LocalDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_as_minutes_fields_are_different_even_if_time_difference_is_less_than_a_minute() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refLocalDateTime).isEqualToIgnoringMinutes(refLocalDateTime.minusNanos(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-01T23:00>%nto have same year, month, day and hour as:%n  <2000-01-01T22:59:59.999999999>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refLocalDateTime).isEqualToIgnoringMinutes(refLocalDateTime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-01T23:00 (java.time.LocalDateTime)>%nto have same year, month, day and hour as:%n  <2000-01-01T22:59:59.999999999 (java.time.LocalDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      LocalDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringMinutes(LocalDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    LocalDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringMinutes(LocalDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
index a3b0dbd49..6b1b6a48f 100644
--- a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
@@ -15,15 +15,15 @@ package org.assertj.core.api.localdatetime;
 import static java.lang.String.format;
 import static org.assertj.core.api.AbstractLocalDateTimeAssert.NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.LocalDateTime;
 
 import org.junit.jupiter.api.Test;
 
-
 public class LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test {
 
   private final LocalDateTime refLocalDateTime = LocalDateTime.of(2000, 1, 1, 0, 0, 1, 0);
@@ -36,22 +36,28 @@ public class LocalDateTimeAssert_isEqualToIgnoringNanoseconds_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_localdatetime_with_nanoseconds_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refLocalDateTime).isEqualToIgnoringNanos(refLocalDateTime.plusSeconds(1)))
-                                                   .withMessage(format("%nExpecting:%n  <2000-01-01T00:00:01>%nto have same year, month, day, hour, minute and second as:%n  <2000-01-01T00:00:02>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refLocalDateTime).isEqualToIgnoringNanos(refLocalDateTime.plusSeconds(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-01T00:00:01 (java.time.LocalDateTime)>%nto have same year, month, day, hour, minute and second as:%n  <2000-01-01T00:00:02 (java.time.LocalDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refLocalDateTime).isEqualToIgnoringNanos(refLocalDateTime.minusNanos(1)))
-                                                   .withMessage(format("%nExpecting:%n  <2000-01-01T00:00:01>%nto have same year, month, day, hour, minute and second as:%n  <2000-01-01T00:00:00.999999999>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refLocalDateTime).isEqualToIgnoringNanos(refLocalDateTime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-01T00:00:01 (java.time.LocalDateTime)>%nto have same year, month, day, hour, minute and second as:%n  <2000-01-01T00:00:00.999999999 (java.time.LocalDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      LocalDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringNanos(LocalDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    LocalDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringNanos(LocalDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringSeconds_Test.java b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringSeconds_Test.java
index a73568a97..ae686b853 100644
--- a/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringSeconds_Test.java
+++ b/src/test/java/org/assertj/core/api/localdatetime/LocalDateTimeAssert_isEqualToIgnoringSeconds_Test.java
@@ -15,8 +15,9 @@ package org.assertj.core.api.localdatetime;
 import static java.lang.String.format;
 import static org.assertj.core.api.AbstractLocalDateTimeAssert.NULL_LOCAL_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.LocalDateTime;
@@ -35,22 +36,29 @@ public class LocalDateTimeAssert_isEqualToIgnoringSeconds_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_localdatetime_with_second_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refLocalDateTime).isEqualToIgnoringSeconds(refLocalDateTime.plusMinutes(1)))
-                                                   .withMessage(format("%nExpecting:%n  <2000-01-01T23:51>%nto have same year, month, day, hour and minute as:%n  <2000-01-01T23:52>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refLocalDateTime).isEqualToIgnoringSeconds(refLocalDateTime.plusMinutes(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-01T23:51 (java.time.LocalDateTime)>%nto have same year, month, day, hour and minute as:%n  <2000-01-01T23:52 (java.time.LocalDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refLocalDateTime).isEqualToIgnoringSeconds(refLocalDateTime.minusNanos(1)))
-                                                   .withMessage(format("%nExpecting:%n  <2000-01-01T23:51>%nto have same year, month, day, hour and minute as:%n  <2000-01-01T23:50:59.999999999>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refLocalDateTime).isEqualToIgnoringSeconds(refLocalDateTime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-01T23:51 (java.time.LocalDateTime)>%nto have same year, month, day, hour and minute as:%n  <2000-01-01T23:50:59.999999999 (java.time.LocalDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      LocalDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringSeconds(LocalDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    LocalDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringSeconds(LocalDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringHours_Test.java b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringHours_Test.java
index eaec74fa0..4e277b1c0 100644
--- a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringHours_Test.java
+++ b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringHours_Test.java
@@ -17,8 +17,9 @@ import static java.time.OffsetDateTime.of;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractOffsetDateTimeAssert.NULL_OFFSET_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.OffsetDateTime;
@@ -36,31 +37,37 @@ public class OffsetDateTimeAssert_isEqualToIgnoringHours_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_offsetdatetime_with_hour_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringHours(refOffsetDateTime.minusHours(1)))
-                                                   .withMessage(format("%n" +
-                                                                       "Expecting:%n" +
-                                                                       "  <2000-01-02T00:00Z>%n" +
-                                                                       "to have same year, month and day as:%n" +
-                                                                       "  <2000-01-01T23:00Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refOffsetDateTime).isEqualToIgnoringHours(refOffsetDateTime.minusHours(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-02T00:00Z (java.time.OffsetDateTime)>%n" +
+                                           "to have same year, month and day as:%n" +
+                                           "  <2000-01-01T23:00Z (java.time.OffsetDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_as_hours_fields_are_different_even_if_time_difference_is_less_than_a_hour() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringHours(refOffsetDateTime.minusNanos(1)))
-                                                   .withMessage(format("%n" +
-                                                                       "Expecting:%n" +
-                                                                       "  <2000-01-02T00:00Z>%n" +
-                                                                       "to have same year, month and day as:%n" +
-                                                                       "  <2000-01-01T23:59:59.999999999Z>%n" +
-                                                                       "but had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refOffsetDateTime).isEqualToIgnoringHours(refOffsetDateTime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-02T00:00Z (java.time.OffsetDateTime)>%n" +
+                                           "to have same year, month and day as:%n" +
+                                           "  <2000-01-01T23:59:59.999999999Z (java.time.OffsetDateTime)>%n"
+                                           + "but had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      OffsetDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringHours(OffsetDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    OffsetDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringHours(OffsetDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringMinutes_Test.java b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringMinutes_Test.java
index 3f5050053..88840304e 100644
--- a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringMinutes_Test.java
+++ b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringMinutes_Test.java
@@ -17,8 +17,9 @@ import static java.time.OffsetDateTime.of;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractOffsetDateTimeAssert.NULL_OFFSET_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.OffsetDateTime;
@@ -36,30 +37,36 @@ public class OffsetDateTimeAssert_isEqualToIgnoringMinutes_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_offsetdatetime_with_minute_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringMinutes(refOffsetDateTime.minusMinutes(1)))
-                                                   .withMessage(format("%n" +
-                                                                       "Expecting:%n" +
-                                                                       "  <2000-01-01T23:00Z>%n" +
-                                                                       "to have same year, month, day and hour as:%n" +
-                                                                       "  <2000-01-01T22:59Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refOffsetDateTime).isEqualToIgnoringMinutes(refOffsetDateTime.minusMinutes(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T23:00Z (java.time.OffsetDateTime)>%n" +
+                                           "to have same year, month, day and hour as:%n" +
+                                           "  <2000-01-01T22:59Z (java.time.OffsetDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_as_minutes_fields_are_different_even_if_time_difference_is_less_than_a_minute() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringMinutes(refOffsetDateTime.minusNanos(1)))
-                                                   .withMessage(format("%n" +
-                                                                       "Expecting:%n" +
-                                                                       "  <2000-01-01T23:00Z>%n" +
-                                                                       "to have same year, month, day and hour as:%n" +
-                                                                       "  <2000-01-01T22:59:59.999999999Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refOffsetDateTime).isEqualToIgnoringMinutes(refOffsetDateTime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T23:00Z (java.time.OffsetDateTime)>%n" +
+                                           "to have same year, month, day and hour as:%n" +
+                                           "  <2000-01-01T22:59:59.999999999Z (java.time.OffsetDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      OffsetDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringMinutes(OffsetDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    OffsetDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringMinutes(OffsetDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
index 6a6d92498..acacf2f88 100644
--- a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
+++ b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
@@ -17,8 +17,9 @@ import static java.time.OffsetDateTime.of;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractOffsetDateTimeAssert.NULL_OFFSET_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.OffsetDateTime;
@@ -37,33 +38,37 @@ public class OffsetDateTimeAssert_isEqualToIgnoringNanoseconds_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_offsetdatetime_with_nanoseconds_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringNanos(refOffsetDateTime.plusSeconds(1)))
-                                                   .withMessage(format("%nExpecting:%n" +
-                                                                       "  <2000-01-01T00:00:01Z>%n" +
-                                                                       "to have same year, month, day, hour, minute and second as:%n"
-                                                                       +
-                                                                       "  <2000-01-01T00:00:02Z>%nb" +
-                                                                       "ut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refOffsetDateTime).isEqualToIgnoringNanos(refOffsetDateTime.plusSeconds(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n" +
+                                           "  <2000-01-01T00:00:01Z (java.time.OffsetDateTime)>%n" +
+                                           "to have same year, month, day, hour, minute and second as:%n" +
+                                           "  <2000-01-01T00:00:02Z (java.time.OffsetDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_as_seconds_fields_are_different() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringNanos(refOffsetDateTime.minusNanos(1)))
-                                                   .withMessage(format("%n" +
-                                                                       "Expecting:%n" +
-                                                                       "  <2000-01-01T00:00:01Z>%n" +
-                                                                       "to have same year, month, day, hour, minute and second as:%n"
-                                                                       +
-                                                                       "  <2000-01-01T00:00:00.999999999Z>%n" +
-                                                                       "but had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refOffsetDateTime).isEqualToIgnoringNanos(refOffsetDateTime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T00:00:01Z (java.time.OffsetDateTime)>%n" +
+                                           "to have same year, month, day, hour, minute and second as:%n" +
+                                           "  <2000-01-01T00:00:00.999999999Z (java.time.OffsetDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      OffsetDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringNanos(OffsetDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    OffsetDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringNanos(OffsetDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringSeconds_Test.java b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringSeconds_Test.java
index 99d290ac0..536fddc71 100644
--- a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringSeconds_Test.java
+++ b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringSeconds_Test.java
@@ -16,8 +16,9 @@ import static java.lang.String.format;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractOffsetDateTimeAssert.NULL_OFFSET_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.OffsetDateTime;
@@ -35,34 +36,38 @@ public class OffsetDateTimeAssert_isEqualToIgnoringSeconds_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_offsetdatetime_with_second_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringSeconds(refOffsetDateTime.plusMinutes(1)))
-                                                   .withMessage(format("%n" +
-                                                                       "Expecting:%n" +
-                                                                       "  <2000-01-01T23:51Z>%n" +
-                                                                       "to have same year, month, day, hour and minute as:%n"
-                                                                       +
-                                                                       "  <2000-01-01T23:52Z>%n" +
-                                                                       "but had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refOffsetDateTime).isEqualToIgnoringSeconds(refOffsetDateTime.plusMinutes(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T23:51Z (java.time.OffsetDateTime)>%n" +
+                                           "to have same year, month, day, hour and minute as:%n" +
+                                           "  <2000-01-01T23:52Z (java.time.OffsetDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refOffsetDateTime).isEqualToIgnoringSeconds(refOffsetDateTime.minusNanos(1)))
-                                                   .withMessage(format("%n" +
-                                                                       "Expecting:%n" +
-                                                                       "  <2000-01-01T23:51Z>%n" +
-                                                                       "to have same year, month, day, hour and minute as:%n"
-                                                                       +
-                                                                       "  <2000-01-01T23:50:59.999999999Z>%n" +
-                                                                       "but had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refOffsetDateTime).isEqualToIgnoringSeconds(refOffsetDateTime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T23:51Z (java.time.OffsetDateTime)>%n" +
+                                           "to have same year, month, day, hour and minute as:%n" +
+                                           "  <2000-01-01T23:50:59.999999999Z (java.time.OffsetDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      OffsetDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringSeconds(OffsetDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    OffsetDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringSeconds(OffsetDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringTimezone_Test.java b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringTimezone_Test.java
index 3dca2d16c..eee5b485b 100644
--- a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringTimezone_Test.java
+++ b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualToIgnoringTimezone_Test.java
@@ -18,8 +18,9 @@ import static java.time.ZoneOffset.MAX;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractOffsetDateTimeAssert.NULL_OFFSET_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.OffsetDateTime;
@@ -27,37 +28,39 @@ import java.time.OffsetDateTime;
 import org.junit.jupiter.api.Test;
 
 public class OffsetDateTimeAssert_isEqualToIgnoringTimezone_Test {
-  private final OffsetDateTime actual = of(2000, 1, 5, 12, 0, 0, 0, MAX);
+
+  private final OffsetDateTime actual = OffsetDateTime.of(2000, 1, 5, 12, 0, 0, 0, MAX);
 
   @Test
   public void should_pass_if_actual_is_equal_to_other_ignoring_timezone_fields() {
-    assertThat(actual).isEqualToIgnoringTimezone(of(2000, 1, 5, 12, 0, 0, 0, UTC));
+    // GIVEN
+    OffsetDateTime offsetDateTime = of(2000, 1, 5, 12, 0, 0, 0, UTC);
+    // THEN
+    assertThat(actual).isEqualToIgnoringTimezone(offsetDateTime);
   }
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_OffsetDateTime_with_timezone_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(actual).isEqualToIgnoringTimezone(of(2000,
-                                                                                                                     1,
-                                                                                                                     5,
-                                                                                                                     12,
-                                                                                                                     1,
-                                                                                                                     0,
-                                                                                                                     0,
-                                                                                                                     UTC)))
-                                                   .withMessage(format("%nExpecting:%n  " +
-                                                                       "<2000-01-05T12:00+18:00>%n" +
-                                                                       "to have same time fields except timezone as:%n"
-                                                                       +
-                                                                       "  <2000-01-05T12:01Z>%n" +
-                                                                       "but had not."));
+    // GIVEN
+    OffsetDateTime offsetDateTime = OffsetDateTime.of(2000, 1, 5, 12, 1, 0, 0, UTC);
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringTimezone(offsetDateTime));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  " +
+                                           "<2000-01-05T12:00+18:00 (java.time.OffsetDateTime)>%n" +
+                                           "to have same time fields except timezone as:%n" +
+                                           "  <2000-01-05T12:01Z (java.time.OffsetDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      OffsetDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringTimezone(OffsetDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    OffsetDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringTimezone(OffsetDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualTo_Test.java b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualTo_Test.java
index 637dc8b43..6a606b9e1 100644
--- a/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualTo_Test.java
+++ b/src/test/java/org/assertj/core/api/offsetdatetime/OffsetDateTimeAssert_isEqualTo_Test.java
@@ -65,7 +65,7 @@ public class OffsetDateTimeAssert_isEqualTo_Test extends AbstractOffsetDateTimeA
     // GIVEN
     Temporal reference = REFERENCE;
     // WHEN/THEN
-    assertThat(REFERENCE_WITH_DIFFERENT_OFFSET).isEqualTo(reference);
+    then(REFERENCE_WITH_DIFFERENT_OFFSET).isEqualTo(reference);
   }
 
   @Test
@@ -74,7 +74,8 @@ public class OffsetDateTimeAssert_isEqualTo_Test extends AbstractOffsetDateTimeA
     AssertionError assertionError = expectAssertionError(() -> assertThat(AFTER_WITH_DIFFERENT_OFFSET).isEqualTo(REFERENCE));
     // THEN
     then(assertionError).hasMessage("%nExpecting:%n <%s>%nto be equal to:%n <%s>%nwhen comparing values using 'OffsetDateTime.timeLineOrder()'%nbut was not.",
-                                    AFTER_WITH_DIFFERENT_OFFSET, REFERENCE);
+                                    AFTER_WITH_DIFFERENT_OFFSET + " (java.time.OffsetDateTime)",
+                                    REFERENCE + " (java.time.OffsetDateTime)");
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringHours_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringHours_Test.java
index 11ef1e701..5c62b7b12 100644
--- a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringHours_Test.java
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringHours_Test.java
@@ -16,9 +16,9 @@ import static java.lang.String.format;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractZonedDateTimeAssert.NULL_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
-import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.ZoneId;
@@ -37,41 +37,53 @@ public class ZonedDateTimeAssert_isEqualToIgnoringHours_Test {
 
   @Test
   public void should_pass_if_actual_is_equal_to_other_ignoring_hours_in_different_timezone() {
+    // GIVEN
     ZonedDateTime utcDateTime = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, UTC);
     ZoneId cestTimeZone = ZoneId.of("Europe/Berlin");
     // new DateTime(2013, 6, 10, 5, 0, cestTimeZone) = DateTime(2013, 6, 10, 3, 0, DateTimeZone.UTC)
     assertThat(utcDateTime).isEqualToIgnoringHours(ZonedDateTime.of(2013, 6, 10, 5, 0, 0, 0, cestTimeZone));
     // new DateTime(2013, 6, 11, 1, 0, cestTimeZone) = DateTime(2013, 6, 10, 23, 0, DateTimeZone.UTC)
     assertThat(utcDateTime).isEqualToIgnoringHours(ZonedDateTime.of(2013, 6, 11, 1, 0, 0, 0, cestTimeZone));
-
     // DateTime(2013, 6, 10, 0, 0, cestTimeZone) = DateTime(2013, 6, 9, 22, 0, DateTimeZone.UTC)
-    Throwable error = catchThrowable(() -> assertThat(utcDateTime)
-      .isEqualToIgnoringHours(ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, cestTimeZone)));
+    ZonedDateTime expected = ZonedDateTime.of(2013, 6, 10, 0, 0, 0, 0, cestTimeZone);
+
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(utcDateTime).isEqualToIgnoringHours(expected));
 
     // THEN
-    assertThat(error).isInstanceOf(AssertionError.class)
-      .hasMessage(format("%nExpecting:%n  <2013-06-10T00:00Z>%nto have same year, month and day as:%n  <2013-06-09T22:00Z>%nbut had not."));
+    assertThat(assertionError).hasMessage(format("%n" +
+                                                 "Expecting:%n" +
+                                                 "  <2013-06-10T00:00Z (java.time.ZonedDateTime)>%n" +
+                                                 "to have same year, month and day as:%n" +
+                                                 "  <2013-06-09T22:00Z (java.time.ZonedDateTime)>%n" +
+                                                 "but had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_datetime_with_hours_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refDatetime).isEqualToIgnoringHours(refDatetime.minusHours(1)))
-                                                   .withMessage(format("%nExpecting:%n  <2000-01-02T00:00Z>%nto have same year, month and day as:%n  <2000-01-01T23:00Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refDatetime).isEqualToIgnoringHours(refDatetime.minusHours(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%nExpecting:%n  <2000-01-02T00:00Z (java.time.ZonedDateTime)>%nto have same year, month and day as:%n  <2000-01-01T23:00Z (java.time.ZonedDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_as_hours_fields_are_different_even_if_time_difference_is_less_than_a_hour() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refDatetime).isEqualToIgnoringHours(refDatetime.minusNanos(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-02T00:00Z>%nto have same year, month and day as:%n  <2000-01-01T23:59:59.999999999Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refDatetime).isEqualToIgnoringHours(refDatetime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format(
+                                           "%nExpecting:%n  <2000-01-02T00:00Z (java.time.ZonedDateTime)>%nto have same year, month and day as:%n  <2000-01-01T23:59:59.999999999Z (java.time.ZonedDateTime)>%nbut had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() ->{
-      ZonedDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringHours(ZonedDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    ZonedDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringHours(ZonedDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test.java
index b502911c6..7517e5b3e 100644
--- a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test.java
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test.java
@@ -16,15 +16,15 @@ import static java.lang.String.format;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractZonedDateTimeAssert.NULL_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.ZonedDateTime;
 
 import org.junit.jupiter.api.Test;
 
-
 public class ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test {
 
   private final ZonedDateTime refDatetime = ZonedDateTime.of(2000, 1, 1, 23, 0, 0, 0, UTC);
@@ -36,24 +36,38 @@ public class ZonedDateTimeAssert_isEqualToIgnoringMinutes_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_datetime_with_minute_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refDatetime).isEqualToIgnoringMinutes(refDatetime.minusMinutes(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-01T23:00Z>%nto have same year, month, day and hour as:%n  <2000-01-01T22:59Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refDatetime).isEqualToIgnoringMinutes(refDatetime.minusMinutes(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T23:00Z (java.time.ZonedDateTime)>%n" +
+                                           "to have same year, month, day and hour as:%n" +
+                                           "  <2000-01-01T22:59Z (java.time.ZonedDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_as_minutes_fields_are_different_even_if_time_difference_is_less_than_a_minute() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refDatetime).isEqualToIgnoringMinutes(refDatetime.minusNanos(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-01T23:00Z>%nto have same year, month, day and hour as:%n  <2000-01-01T22:59:59.999999999Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refDatetime).isEqualToIgnoringMinutes(refDatetime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T23:00Z (java.time.ZonedDateTime)>%n" +
+                                           "to have same year, month, day and hour as:%n" +
+                                           "  <2000-01-01T22:59:59.999999999Z (java.time.ZonedDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      ZonedDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringMinutes(ZonedDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    ZonedDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringMinutes(ZonedDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
index 9ee5b6201..2a765c783 100644
--- a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test.java
@@ -16,8 +16,9 @@ import static java.lang.String.format;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractZonedDateTimeAssert.NULL_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.ZonedDateTime;
@@ -36,24 +37,39 @@ public class ZonedDateTimeAssert_isEqualToIgnoringNanoseconds_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_datetime_with_nanoseconds_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refDatetime).isEqualToIgnoringNanos(refDatetime.plusSeconds(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-01T00:00:01Z>%nto have same year, month, day, hour, minute and second as:%n  <2000-01-01T00:00:02Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refDatetime).isEqualToIgnoringNanos(refDatetime.plusSeconds(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T00:00:01Z (java.time.ZonedDateTime)>%n" +
+                                           "to have same year, month, day, hour, minute and second as:%n" +
+                                           "  <2000-01-01T00:00:02Z (java.time.ZonedDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refDatetime).isEqualToIgnoringNanos(refDatetime.minusNanos(1)))
-                                                   .withMessage(format(
-                                                                       "%nExpecting:%n  <2000-01-01T00:00:01Z>%nto have same year, month, day, hour, minute and second as:%n  <2000-01-01T00:00:00.999999999Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refDatetime).isEqualToIgnoringNanos(refDatetime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T00:00:01Z (java.time.ZonedDateTime)>%n" +
+                                           "to have same year, month, day, hour, minute and second as:%n" +
+                                           "  <2000-01-01T00:00:00.999999999Z (java.time.ZonedDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      ZonedDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringNanos(ZonedDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    ZonedDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringNanos(ZonedDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test.java
index 1159791d9..e4ae3d70e 100644
--- a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test.java
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test.java
@@ -16,15 +16,15 @@ import static java.lang.String.format;
 import static java.time.ZoneOffset.UTC;
 import static org.assertj.core.api.AbstractZonedDateTimeAssert.NULL_DATE_TIME_PARAMETER_MESSAGE;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.time.ZonedDateTime;
 
 import org.junit.jupiter.api.Test;
 
-
 public class ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test {
 
   private final ZonedDateTime refDatetime = ZonedDateTime.of(2000, 1, 1, 23, 51, 0, 0, UTC);
@@ -36,22 +36,38 @@ public class ZonedDateTimeAssert_isEqualToIgnoringSeconds_Test {
 
   @Test
   public void should_fail_if_actual_is_not_equal_to_given_datetime_with_second_ignored() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refDatetime).isEqualToIgnoringSeconds(refDatetime.plusMinutes(1)))
-                                                   .withMessage(format("%nExpecting:%n  <2000-01-01T23:51Z>%nto have same year, month, day, hour and minute as:%n  <2000-01-01T23:52Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refDatetime).isEqualToIgnoringSeconds(refDatetime.plusMinutes(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T23:51Z (java.time.ZonedDateTime)>%n" +
+                                           "to have same year, month, day, hour and minute as:%n" +
+                                           "  <2000-01-01T23:52Z (java.time.ZonedDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_as_seconds_fields_are_different_even_if_time_difference_is_less_than_a_second() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(refDatetime).isEqualToIgnoringSeconds(refDatetime.minusNanos(1)))
-                                                   .withMessage(format("%nExpecting:%n  <2000-01-01T23:51Z>%nto have same year, month, day, hour and minute as:%n  <2000-01-01T23:50:59.999999999Z>%nbut had not."));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(refDatetime).isEqualToIgnoringSeconds(refDatetime.minusNanos(1)));
+    // THEN
+    then(assertionError).hasMessage(format("%n" +
+                                           "Expecting:%n" +
+                                           "  <2000-01-01T23:51Z (java.time.ZonedDateTime)>%n" +
+                                           "to have same year, month, day, hour and minute as:%n" +
+                                           "  <2000-01-01T23:50:59.999999999Z (java.time.ZonedDateTime)>%n" +
+                                           "but had not."));
   }
 
   @Test
   public void should_fail_if_actual_is_null() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> {
-      ZonedDateTime actual = null;
-      assertThat(actual).isEqualToIgnoringSeconds(ZonedDateTime.now());
-    }).withMessage(actualIsNull());
+    // GIVEN
+    ZonedDateTime actual = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(actual).isEqualToIgnoringSeconds(ZonedDateTime.now()));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_errors_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_errors_Test.java
index 7f8ef0b6c..e47d1fa8d 100644
--- a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_errors_Test.java
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isIn_errors_Test.java
@@ -44,7 +44,7 @@ public class ZonedDateTimeAssert_isIn_errors_Test extends ZonedDateTimeAssertBas
     assertThatExceptionOfType(AssertionError.class).isThrownBy(() ->{
       assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC)).isIn(ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC)
                                                                                   .toString());
-    }).withMessage(format("%nExpecting:%n <2000-01-05T03:00:05Z>%nto be in:%n <[2012-01-01T03:03:03Z]>%n"));
+    }).withMessage(format("%nExpecting:%n <2000-01-05T03:00:05Z (java.time.ZonedDateTime)>%nto be in:%n <[2012-01-01T03:03:03Z (java.time.ZonedDateTime)]>%n"));
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java
index dcc3b425f..5ad5aacdf 100644
--- a/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java
+++ b/src/test/java/org/assertj/core/api/zoneddatetime/ZonedDateTimeAssert_isNotIn_errors_Test.java
@@ -43,9 +43,9 @@ public class ZonedDateTimeAssert_isNotIn_errors_Test extends ZonedDateTimeAssert
   public void test_isNotIn_assertion_error_message() {
     assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0,
                                                                                                  UTC)).isNotIn(ZonedDateTime.of(2000, 1, 5, 3, 0, 5, 0, UTC).toString(), ZonedDateTime.of(2012, 1, 1, 3, 3, 3, 0, UTC).toString()))
-                                                   .withMessage(format("%nExpecting:%n <2000-01-05T03:00:05Z>%nnot to be in:%n"
+                                                   .withMessage(format("%nExpecting:%n <2000-01-05T03:00:05Z (java.time.ZonedDateTime)>%nnot to be in:%n"
                                                                        +
-                                                                       " <[2000-01-05T03:00:05Z, 2012-01-01T03:03:03Z]>%n"));
+                                                                       " <[2000-01-05T03:00:05Z (java.time.ZonedDateTime),%n    2012-01-01T03:03:03Z (java.time.ZonedDateTime)]>%n"));
   }
 
   @Test
diff --git a/src/test/java/org/assertj/core/error/ShouldBeAfterOrEqualTo_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeAfterOrEqualTo_create_Test.java
index 439a4744d..275193b14 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeAfterOrEqualTo_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeAfterOrEqualTo_create_Test.java
@@ -42,9 +42,9 @@ public class ShouldBeAfterOrEqualTo_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2011-01-01T00:00:00.000>%n" +
+                                   "  <2011-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be after or equal to:%n" +
-                                   "  <2012-01-01T00:00:00.000>%n"));
+                                   "  <2012-01-01T00:00:00.000 (java.util.Date)>%n"));
   }
 
   @Test
@@ -57,9 +57,9 @@ public class ShouldBeAfterOrEqualTo_create_Test {
     // THEN
     then(message).isEqualTo("[Test] %n" +
                             "Expecting:%n" +
-                            "  <2011-01-01T00:00:00.000>%n" +
+                            "  <2011-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "to be after or equal to:%n" +
-                            "  <2012-01-01T00:00:00.000>%n" +
+                            "  <2012-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "when comparing values using '%s'",
                             NEVER_EQUALS.description());
   }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeAfter_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeAfter_create_Test.java
index b1403ff55..6b4acf48a 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeAfter_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeAfter_create_Test.java
@@ -41,9 +41,9 @@ public class ShouldBeAfter_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2011-01-01T00:00:00.000>%n" +
+                                   "  <2011-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be strictly after:%n" +
-                                   "  <2012-01-01T00:00:00.000>%n"));
+                                   "  <2012-01-01T00:00:00.000 (java.util.Date)>%n"));
   }
 
   @Test
@@ -56,9 +56,9 @@ public class ShouldBeAfter_create_Test {
     // THEN
     then(message).isEqualTo("[Test] %n" +
                             "Expecting:%n" +
-                            "  <2011-01-01T00:00:00.000>%n" +
+                            "  <2011-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "to be strictly after:%n" +
-                            "  <2012-01-01T00:00:00.000>%n" +
+                            "  <2012-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "when comparing values using '%s'",
                             NEVER_EQUALS.description());
   }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeAtSameInstant_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeAtSameInstant_create_Test.java
index 1a3537100..d2ad6e052 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeAtSameInstant_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeAtSameInstant_create_Test.java
@@ -37,9 +37,9 @@ class ShouldBeAtSameInstant_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting%n" +
-                                   "  <2000-12-14T00:00Z>%n" +
+                                   "  <2000-12-14T00:00Z (java.time.OffsetDateTime)>%n" +
                                    "to be at the same instant as:%n" +
-                                   "  <2000-12-14T00:00-03:00>%n" +
+                                   "  <2000-12-14T00:00-03:00 (java.time.OffsetDateTime)>%n" +
                                    "but actual instance was%n" +
                                    "  <2000-12-14T00:00:00Z>%n" +
                                    "and expected instant was:%n" +
diff --git a/src/test/java/org/assertj/core/error/ShouldBeBeforeOrEqualTo_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeBeforeOrEqualTo_create_Test.java
index 659a87312..9844f1f45 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeBeforeOrEqualTo_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeBeforeOrEqualTo_create_Test.java
@@ -34,9 +34,9 @@ public class ShouldBeBeforeOrEqualTo_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2019-01-01T00:00:00.000>%n" +
+                                   "  <2019-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be before or equal to:%n" +
-                                   "  <2012-01-01T00:00:00.000>%n"));
+                                   "  <2012-01-01T00:00:00.000 (java.util.Date)>%n"));
   }
 
   @Test
@@ -49,9 +49,9 @@ public class ShouldBeBeforeOrEqualTo_create_Test {
     // THEN
     then(message).isEqualTo("[Test] %n" +
                             "Expecting:%n" +
-                            "  <2019-01-01T00:00:00.000>%n" +
+                            "  <2019-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "to be before or equal to:%n" +
-                            "  <2012-01-01T00:00:00.000>%n" +
+                            "  <2012-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "when comparing values using '%s'",
                             NEVER_EQUALS.description());
   }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeBefore_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeBefore_create_Test.java
index 631c26ced..e41021bdb 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeBefore_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeBefore_create_Test.java
@@ -40,9 +40,9 @@ public class ShouldBeBefore_create_Test {
     // WHEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2019-01-01T00:00:00.000>%n" +
+                                   "  <2019-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be strictly before:%n" +
-                                   "  <2012-01-01T00:00:00.000>%n"));
+                                   "  <2012-01-01T00:00:00.000 (java.util.Date)>%n"));
   }
 
   @Test
@@ -55,9 +55,9 @@ public class ShouldBeBefore_create_Test {
     // THEN
     then(message).isEqualTo("[Test] %n" +
                             "Expecting:%n" +
-                            "  <2019-01-01T00:00:00.000>%n" +
+                            "  <2019-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "to be strictly before:%n" +
-                            "  <2012-01-01T00:00:00.000>%n" +
+                            "  <2012-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "when comparing values using '%s'",
                             NEVER_EQUALS.description());
   }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeBetween_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeBetween_create_Test.java
index 4039cbc53..bdfc0b663 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeBetween_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeBetween_create_Test.java
@@ -39,9 +39,9 @@ public class ShouldBeBetween_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2010-01-01T00:00:00.000>%n" +
+                                   " <2010-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be in period:%n" +
-                                   " [2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000]%n"));
+                                   " [2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)]%n"));
   }
 
   @Test
@@ -53,9 +53,9 @@ public class ShouldBeBetween_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2010-01-01T00:00:00.000>%n" +
+                                   " <2010-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be in period:%n" +
-                                   " [2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000[%n"));
+                                   " [2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)[%n"));
   }
 
   @Test
@@ -67,9 +67,9 @@ public class ShouldBeBetween_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2010-01-01T00:00:00.000>%n" +
+                                   " <2010-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be in period:%n" +
-                                   " ]2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000]%n"));
+                                   " ]2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)]%n"));
   }
 
   @Test
@@ -81,9 +81,9 @@ public class ShouldBeBetween_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2010-01-01T00:00:00.000>%n" +
+                                   " <2010-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be in period:%n" +
-                                   " ]2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000[%n"));
+                                   " ]2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)[%n"));
   }
 
   @Test
@@ -97,9 +97,9 @@ public class ShouldBeBetween_create_Test {
     // THEN
     then(message).isEqualTo("[Test] %n" +
                             "Expecting:%n" +
-                            " <2010-01-01T00:00:00.000>%n" +
+                            " <2010-01-01T00:00:00.000 (java.util.Date)>%n" +
                             "to be in period:%n" +
-                            " ]2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000[%n" +
+                            " ]2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)[%n" +
                             "when comparing values using '%s'",
                             NEVER_EQUALS.description());
   }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeEqualIgnoringTimezone_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeEqualIgnoringTimezone_create_Test.java
index 3116c6150..e31d21fb6 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeEqualIgnoringTimezone_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeEqualIgnoringTimezone_create_Test.java
@@ -60,9 +60,9 @@ public class ShouldBeEqualIgnoringTimezone_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2000-05-13T12:00Z>%n" +
+                                   "  <2000-05-13T12:00Z (java.time.OffsetDateTime)>%n" +
                                    "to have same time fields except timezone as:%n" +
-                                   "  <2000-05-13T12:00-18:00>%n" +
+                                   "  <2000-05-13T12:00-18:00 (java.time.OffsetDateTime)>%n" +
                                    "but had not."));
   }
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeEqualWithTimePrecision_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeEqualWithTimePrecision_create_Test.java
index 2d7576389..91982c531 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeEqualWithTimePrecision_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeEqualWithTimePrecision_create_Test.java
@@ -39,9 +39,9 @@ public class ShouldBeEqualWithTimePrecision_create_Test {
 
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     then(message).isEqualTo(format("[Test] %nExpecting:%n" +
-                                   "  <2011-01-01T05:00:00.000>%n" +
+                                   "  <2011-01-01T05:00:00.000 (java.util.Date)>%n" +
                                    "to have same year, month, day, hour, minute and second as:%n" +
-                                   "  <2011-01-01T06:05:17.003>%n" +
+                                   "  <2011-01-01T06:05:17.003 (java.util.Date)>%n" +
                                    "but had not."));
   }
 
@@ -52,9 +52,9 @@ public class ShouldBeEqualWithTimePrecision_create_Test {
 
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     then(message).isEqualTo(format("[Test] %nExpecting:%n" +
-                                   "  <2011-01-01T05:00:00.000>%n" +
+                                   "  <2011-01-01T05:00:00.000 (java.util.Date)>%n" +
                                    "to have same year, month, day, hour and minute as:%n" +
-                                   "  <2011-01-01T06:05:17.003>%n" +
+                                   "  <2011-01-01T06:05:17.003 (java.util.Date)>%n" +
                                    "but had not."));
   }
 
@@ -65,9 +65,9 @@ public class ShouldBeEqualWithTimePrecision_create_Test {
 
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     then(message).isEqualTo(format("[Test] %nExpecting:%n" +
-                                   "  <2011-01-01T05:00:00.000>%n" +
+                                   "  <2011-01-01T05:00:00.000 (java.util.Date)>%n" +
                                    "to have same year, month, day and hour as:%n" +
-                                   "  <2011-01-01T06:05:17.003>%n" +
+                                   "  <2011-01-01T06:05:17.003 (java.util.Date)>%n" +
                                    "but had not."));
   }
 
@@ -78,9 +78,9 @@ public class ShouldBeEqualWithTimePrecision_create_Test {
 
     String message = factory.create(new TextDescription("Test"), new StandardRepresentation());
     then(message).isEqualTo(format("[Test] %nExpecting:%n" +
-                                   "  <2011-01-01T05:00:00.000>%n" +
+                                   "  <2011-01-01T05:00:00.000 (java.util.Date)>%n" +
                                    "to have same year, month and day as:%n" +
-                                   "  <2011-01-01T06:05:17.003>%n" +
+                                   "  <2011-01-01T06:05:17.003 (java.util.Date)>%n" +
                                    "but had not."));
   }
 
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameDay_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameDay_create_Test.java
index 1cb64d705..d736e9bac 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameDay_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameDay_create_Test.java
@@ -38,9 +38,9 @@ public class ShouldBeInSameDay_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2010-01-01T00:00:00.000>%n" +
+                                   " <2010-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be on same year, month and day as:%n" +
-                                   " <2010-01-25T00:00:00.000>"));
+                                   " <2010-01-25T00:00:00.000 (java.util.Date)>"));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameHourWindow_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameHourWindow_create_Test.java
index 4eb296428..723e4b794 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameHourWindow_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameHourWindow_create_Test.java
@@ -41,9 +41,9 @@ public class ShouldBeInSameHourWindow_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2011-01-01T05:00:00.000>%n" +
+                                   "  <2011-01-01T05:00:00.000 (java.util.Date)>%n" +
                                    "to be close to:%n" +
-                                   "  <2011-01-01T06:05:17.003>%n" +
+                                   "  <2011-01-01T06:05:17.003 (java.util.Date)>%n" +
                                    "by less than one hour (strictly) but difference was: 1h 5m 17s and 3ms"));
   }
 
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameMinuteWindow_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameMinuteWindow_create_Test.java
index 2ba7738a6..5acbb8209 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameMinuteWindow_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameMinuteWindow_create_Test.java
@@ -41,9 +41,9 @@ public class ShouldBeInSameMinuteWindow_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2011-01-01T05:00:00.000>%n" +
+                                   "  <2011-01-01T05:00:00.000 (java.util.Date)>%n" +
                                    "to be close to:%n" +
-                                   "  <2011-01-01T05:02:01.000>%n" +
+                                   "  <2011-01-01T05:02:01.000 (java.util.Date)>%n" +
                                    "by less than one minute (strictly) but difference was: 2m and 1s"));
   }
 
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameMonth_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameMonth_create_Test.java
index 25ed98959..82c171122 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameMonth_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameMonth_create_Test.java
@@ -39,9 +39,9 @@ public class ShouldBeInSameMonth_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2010-01-01T00:00:00.000>%n" +
+                                   " <2010-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be on same year and month as:%n" +
-                                   " <2010-02-01T00:00:00.000>"));
+                                   " <2010-02-01T00:00:00.000 (java.util.Date)>"));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameSecondWindow_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameSecondWindow_create_Test.java
index 4a91cd456..91b9079a9 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameSecondWindow_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameSecondWindow_create_Test.java
@@ -41,9 +41,9 @@ public class ShouldBeInSameSecondWindow_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2011-01-01T05:00:01.000>%n" +
+                                   "  <2011-01-01T05:00:01.000 (java.util.Date)>%n" +
                                    "to be close to:%n" +
-                                   "  <2011-01-01T05:00:02.001>%n" +
+                                   "  <2011-01-01T05:00:02.001 (java.util.Date)>%n" +
                                    "by less than one second (strictly) but difference was: 1s and 1ms"));
   }
 
diff --git a/src/test/java/org/assertj/core/error/ShouldBeInSameYear_create_Test.java b/src/test/java/org/assertj/core/error/ShouldBeInSameYear_create_Test.java
index 9779b4228..0eeefe434 100644
--- a/src/test/java/org/assertj/core/error/ShouldBeInSameYear_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldBeInSameYear_create_Test.java
@@ -39,9 +39,9 @@ public class ShouldBeInSameYear_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2010-01-01T00:00:00.000>%n" +
+                                   " <2010-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "to be on same year as:%n" +
-                                   " <2011-01-01T00:00:00.000>"));
+                                   " <2011-01-01T00:00:00.000 (java.util.Date)>"));
   }
 
 }
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveDateField_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveDateField_create_Test.java
index 06be68d14..b97162aa1 100644
--- a/src/test/java/org/assertj/core/error/ShouldHaveDateField_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldHaveDateField_create_Test.java
@@ -35,7 +35,7 @@ public class ShouldHaveDateField_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   "  <2015-12-31T00:00:00.000>%n" +
+                                   "  <2015-12-31T00:00:00.000 (java.util.Date)>%n" +
                                    "to be on \"month\" <10>"));
   }
 
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveSameTime_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveSameTime_create_Test.java
index 0aa304e3c..644be07a0 100644
--- a/src/test/java/org/assertj/core/error/ShouldHaveSameTime_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldHaveSameTime_create_Test.java
@@ -42,9 +42,9 @@ public class ShouldHaveSameTime_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting%n" +
-                                   "  <2011-01-01T05:01:00.000>%n" +
+                                   "  <2011-01-01T05:01:00.000 (java.util.Date)>%n" +
                                    "to have the same time as:%n" +
-                                   "  <2011-01-01T05:01:01.000>%n" +
+                                   "  <2011-01-01T05:01:01.000 (java.util.Date)>%n" +
                                    "but actual time is%n" +
                                    "  <" + actual.getTime() + "L>%n" +
                                    "and expected was:%n" +
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveTime_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveTime_create_Test.java
index 48cfbea53..bd7b6f0bc 100644
--- a/src/test/java/org/assertj/core/error/ShouldHaveTime_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldHaveTime_create_Test.java
@@ -44,7 +44,7 @@ public class ShouldHaveTime_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting%n" +
-                                   " <2011-01-01T05:01:00.000>%n" +
+                                   " <2011-01-01T05:01:00.000 (java.util.Date)>%n" +
                                    "to have time:%n" +
                                    " <123L>%n" +
                                    "but was:%n" +
diff --git a/src/test/java/org/assertj/core/error/ShouldNotBeBetween_create_Test.java b/src/test/java/org/assertj/core/error/ShouldNotBeBetween_create_Test.java
index aa7f57a37..02a0d3985 100644
--- a/src/test/java/org/assertj/core/error/ShouldNotBeBetween_create_Test.java
+++ b/src/test/java/org/assertj/core/error/ShouldNotBeBetween_create_Test.java
@@ -40,9 +40,9 @@ public class ShouldNotBeBetween_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2009-01-01T00:00:00.000>%n" +
+                                   " <2009-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "not to be in period:%n" +
-                                   " [2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000]"));
+                                   " [2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)]"));
   }
 
   @Test
@@ -55,9 +55,9 @@ public class ShouldNotBeBetween_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2012-01-01T00:00:00.000>%n" +
+                                   " <2012-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "not to be in period:%n" +
-                                   " [2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000["));
+                                   " [2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)["));
   }
 
   @Test
@@ -70,9 +70,9 @@ public class ShouldNotBeBetween_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2011-01-01T00:00:00.000>%n" +
+                                   " <2011-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "not to be in period:%n" +
-                                   " ]2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000]"));
+                                   " ]2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)]"));
   }
 
   @Test
@@ -85,8 +85,8 @@ public class ShouldNotBeBetween_create_Test {
     // THEN
     then(message).isEqualTo(format("[Test] %n" +
                                    "Expecting:%n" +
-                                   " <2011-01-01T00:00:00.000>%n" +
+                                   " <2011-01-01T00:00:00.000 (java.util.Date)>%n" +
                                    "not to be in period:%n" +
-                                   " ]2011-01-01T00:00:00.000, 2012-01-01T00:00:00.000["));
+                                   " ]2011-01-01T00:00:00.000 (java.util.Date), 2012-01-01T00:00:00.000 (java.util.Date)["));
   }
 }
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
index d6a8e673e..f7a14ea52 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_toStringOf_Test.java
@@ -20,12 +20,17 @@ import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.Assertions.tuple;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Arrays.array;
-import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Lists.list;
 
 import java.io.File;
 import java.lang.reflect.Method;
 import java.text.SimpleDateFormat;
 import java.time.Duration;
+import java.time.LocalDate;
+import java.time.LocalDateTime;
+import java.time.OffsetDateTime;
+import java.time.ZoneOffset;
+import java.time.ZonedDateTime;
 import java.util.Arrays;
 import java.util.Calendar;
 import java.util.Collection;
@@ -96,7 +101,7 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void should_return_toString_of_Collection_of_String() {
-    Collection<String> collection = newArrayList("s1", "s2");
+    Collection<String> collection = list("s1", "s2");
     // assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo(format("[\"s1\",%n" +
     // " \"s2\"]"));
     assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo(format("[\"s1\", \"s2\"]"));
@@ -104,27 +109,26 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void should_return_toString_of_Collection_of_arrays() {
-    List<Boolean[]> collection = newArrayList(array(true, false), array(true, false, true));
+    List<Boolean[]> collection = list(array(true, false), array(true, false, true));
     assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo("[[true, false], [true, false, true]]");
   }
 
   @Test
   public void should_return_toString_of_Collection_of_arrays_up_to_the_maximum_allowed_elements() {
-    List<Boolean[]> collection = newArrayList(array(true, false), array(true, false, true), array(true, true));
+    List<Boolean[]> collection = list(array(true, false), array(true, false, true), array(true, true));
     StandardRepresentation.setMaxElementsForPrinting(2);
     assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo("[[true, false], [true, false, ...], ...]");
   }
 
   @Test
   public void should_return_toString_of_Collection_of_Collections() {
-    Collection<List<String>> collection = newArrayList(newArrayList("s1", "s2"), newArrayList("s3", "s4", "s5"));
+    Collection<List<String>> collection = list(list("s1", "s2"), list("s3", "s4", "s5"));
     assertThat(STANDARD_REPRESENTATION.toStringOf(collection)).isEqualTo("[[\"s1\", \"s2\"], [\"s3\", \"s4\", \"s5\"]]");
   }
 
   @Test
   public void should_return_toString_of_Collection_of_Collections_up_to_the_maximum_allowed_elements() {
-    Collection<List<String>> collection = newArrayList(newArrayList("s1", "s2"), newArrayList("s3", "s4", "s5"),
-                                                       newArrayList("s6", "s7"));
+    Collection<List<String>> collection = list(list("s1", "s2"), list("s3", "s4", "s5"), list("s6", "s7"));
     StandardRepresentation.setMaxElementsForPrinting(2);
     assertThat(STANDARD_REPRESENTATION.toStringOf(collection))
                                                               .isEqualTo("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ...], ...]");
@@ -163,15 +167,65 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
   }
 
   @Test
-  public void should_return_toString_of_calendar() {
+  public void should_return_unambiguous_toString_of_calendar() {
+    // GIVEN
     GregorianCalendar calendar = new GregorianCalendar(2011, Calendar.JANUARY, 18, 23, 53, 17);
-    assertThat(STANDARD_REPRESENTATION.toStringOf(calendar)).isEqualTo("2011-01-18T23:53:17");
+    // WHEN
+    String stringOfCalendar = STANDARD_REPRESENTATION.toStringOf(calendar);
+    // THEN
+    then(stringOfCalendar).isEqualTo("2011-01-18T23:53:17 (java.util.GregorianCalendar)");
   }
 
   @Test
-  public void should_return_toString_of_date() {
+  public void should_return_unambiguous_toString_of_date() {
+    // GIVEN
     Date date = new GregorianCalendar(2011, Calendar.JUNE, 18, 23, 53, 17).getTime();
-    assertThat(STANDARD_REPRESENTATION.toStringOf(date)).isEqualTo("2011-06-18T23:53:17.000");
+    // WHEN
+    String dateRepresentation = STANDARD_REPRESENTATION.toStringOf(date);
+    // THEN
+    then(dateRepresentation).isEqualTo("2011-06-18T23:53:17.000 (java.util.Date)");
+  }
+
+  @Test
+  public void should_return_unambiguous_toString_of_LocalDate() {
+    // GIVEN use Object to call toStringOf(Object) and not toStringOf(LocalDateTime)
+    Object localDate = LocalDate.of(2011, 6, 18);
+    // WHEN
+    String localDateRepresentation = STANDARD_REPRESENTATION.toStringOf(localDate);
+    // THEN
+    then(localDateRepresentation).isEqualTo("2011-06-18 (java.time.LocalDate)");
+  }
+
+  @Test
+  public void should_return_unambiguous_toString_of_LocalDateTime() {
+    // GIVEN use Object to call toStringOf(Object) and not toStringOf(LocalDateTime)
+    Object localDateTime = LocalDateTime.of(2011, 6, 18, 23, 53, 17);
+    // WHEN
+    String localDateTimeRepresentation = STANDARD_REPRESENTATION.toStringOf(localDateTime);
+    // THEN
+    then(localDateTimeRepresentation).isEqualTo("2011-06-18T23:53:17 (java.time.LocalDateTime)");
+  }
+
+  @Test
+  public void should_return_unambiguous_toString_of_OffsetDateTime() {
+    // GIVEN use Object to call toStringOf(Object) and not toStringOf(LocalDateTime)
+    LocalDateTime localDateTime = LocalDateTime.of(2011, 6, 18, 23, 53, 17);
+    Object offsetDateTime = OffsetDateTime.of(localDateTime, ZoneOffset.UTC);
+    // WHEN
+    String offsetDateTimeRepresentation = STANDARD_REPRESENTATION.toStringOf(offsetDateTime);
+    // THEN
+    then(offsetDateTimeRepresentation).isEqualTo("2011-06-18T23:53:17Z (java.time.OffsetDateTime)");
+  }
+
+  @Test
+  public void should_return_unambiguous_toString_of_ZonedDateTime() {
+    // GIVEN use Object to call toStringOf(Object) and not toStringOf(LocalDateTime)
+    LocalDateTime localDateTime = LocalDateTime.of(2011, 6, 18, 23, 53, 17);
+    Object offsetDateTime = ZonedDateTime.of(localDateTime, ZoneOffset.UTC);
+    // WHEN
+    String offsetDateTimeRepresentation = STANDARD_REPRESENTATION.toStringOf(offsetDateTime);
+    // THEN
+    then(offsetDateTimeRepresentation).isEqualTo("2011-06-18T23:53:17Z (java.time.ZonedDateTime)");
   }
 
   @Test
@@ -212,6 +266,7 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void toString_with_anonymous_comparator() {
+    @SuppressWarnings("unused")
     Comparator<String> anonymousComparator = new Comparator<String>() {
       @Override
       public int compare(String s1, String s2) {
@@ -223,6 +278,7 @@ public class StandardRepresentation_toStringOf_Test extends AbstractBaseRepresen
 
   @Test
   public void toString_with_anonymous_comparator_overriding_toString() {
+    @SuppressWarnings("unused")
     Comparator<String> anonymousComparator = new Comparator<String>() {
       @Override
       public int compare(String s1, String s2) {
diff --git a/src/test/java/org/assertj/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java b/src/test/java/org/assertj/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
index 406273480..156f2623e 100644
--- a/src/test/java/org/assertj/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
+++ b/src/test/java/org/assertj/core/presentation/StandardRepresentation_unambiguousToStringOf_Test.java
@@ -20,7 +20,7 @@ import static org.assertj.core.api.Assertions.catchThrowableOfType;
 import static org.assertj.core.api.Assertions.entry;
 import static org.assertj.core.api.Assertions.tuple;
 import static org.assertj.core.util.Arrays.array;
-import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Lists.list;
 
 import java.io.File;
 import java.lang.reflect.Method;
@@ -103,26 +103,24 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
 
   @Test
   public void should_return_toString_of_Collection_of_String() {
-    Collection<String> collection = newArrayList("s1", "s2");
+    Collection<String> collection = list("s1", "s2");
     assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[\"s1\", \"s2\"] (ArrayList@%s)",
                                                                    toHexString(System.identityHashCode(collection))));
   }
 
   @Test
   public void should_return_toString_of_Collection_of_arrays() {
-    List<Boolean[]> collection = newArrayList(
-                                              array(true, false),
-                                              array(true, false, true));
+    List<Boolean[]> collection = list(array(true, false),
+                                      array(true, false, true));
     assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[[true, false], [true, false, true]] (ArrayList@%s)",
                                                                    toHexString(System.identityHashCode(collection))));
   }
 
   @Test
   public void should_return_toString_of_Collection_of_arrays_up_to_the_maximum_allowed_elements() {
-    List<Boolean[]> collection = newArrayList(
-                                              array(true, false),
-                                              array(true, false, true),
-                                              array(true, true));
+    List<Boolean[]> collection = list(array(true, false),
+                                      array(true, false, true),
+                                      array(true, true));
     StandardRepresentation.setMaxElementsForPrinting(2);
     assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[[true, false], [true, false, ...], ...] (ArrayList@%s)",
                                                                    toHexString(System.identityHashCode(collection))));
@@ -130,19 +128,18 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
 
   @Test
   public void should_return_toString_of_Collection_of_Collections() {
-    Collection<List<String>> collection = newArrayList(
-                                                       newArrayList("s1", "s2"),
-                                                       newArrayList("s3", "s4", "s5"));
+    Collection<List<String>> collection = list(
+                                               list("s1", "s2"),
+                                               list("s3", "s4", "s5"));
     assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[[\"s1\", \"s2\"], [\"s3\", \"s4\", \"s5\"]] (ArrayList@%s)",
                                                                    toHexString(System.identityHashCode(collection))));
   }
 
   @Test
   public void should_return_toString_of_Collection_of_Collections_up_to_the_maximum_allowed_elements() {
-    Collection<List<String>> collection = newArrayList(
-                                                       newArrayList("s1", "s2"),
-                                                       newArrayList("s3", "s4", "s5"),
-                                                       newArrayList("s6", "s7"));
+    Collection<List<String>> collection = list(list("s1", "s2"),
+                                               list("s3", "s4", "s5"),
+                                               list("s6", "s7"));
     StandardRepresentation.setMaxElementsForPrinting(2);
     assertThat(unambiguousToStringOf(collection)).isEqualTo(format("[[\"s1\", \"s2\"], [\"s3\", \"s4\", ...], ...] (ArrayList@%s)",
                                                                    toHexString(System.identityHashCode(collection))));
@@ -166,8 +163,7 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
 
   @Test
   public void should_return_toString_of_array_of_arrays() {
-    String[][] array = array(
-                             array("s1", "s2"),
+    String[][] array = array(array("s1", "s2"),
                              array("s3", "s4", "s5"));
     assertThat(unambiguousToStringOf(array)).isEqualTo(format("[[\"s1\", \"s2\"], [\"s3\", \"s4\", \"s5\"]] (String[][]@%s)",
                                                               toHexString(System.identityHashCode(array))));
@@ -175,8 +171,7 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
 
   @Test
   public void should_return_toString_of_array_of_arrays_up_to_the_maximum_allowed_elements() {
-    String[][] array = array(
-                             array("s1", "s2"),
+    String[][] array = array(array("s1", "s2"),
                              array("s3", "s4", "s5"),
                              array("s6", "s7"));
     StandardRepresentation.setMaxElementsForPrinting(2);
@@ -194,15 +189,13 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
   @Test
   public void should_return_toString_of_calendar() {
     GregorianCalendar calendar = new GregorianCalendar(2011, Calendar.JANUARY, 18, 23, 53, 17);
-    assertThat(unambiguousToStringOf(calendar)).isEqualTo(format("2011-01-18T23:53:17 (GregorianCalendar@%s)",
-                                                                 toHexString(System.identityHashCode(calendar))));
+    assertThat(unambiguousToStringOf(calendar)).isEqualTo("2011-01-18T23:53:17 (java.util.GregorianCalendar)");
   }
 
   @Test
   public void should_return_toString_of_date() {
     Date date = new GregorianCalendar(2011, Calendar.JUNE, 18, 23, 53, 17).getTime();
-    assertThat(unambiguousToStringOf(date)).isEqualTo(format("2011-06-18T23:53:17.000 (Date@%s)",
-                                                             toHexString(System.identityHashCode(date))));
+    assertThat(unambiguousToStringOf(date)).isEqualTo("2011-06-18T23:53:17.000 (java.util.Date)");
   }
 
   @Test
@@ -252,6 +245,7 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
 
   @Test
   public void toString_with_anonymous_comparator() {
+    @SuppressWarnings("unused")
     Comparator<String> anonymousComparator = new Comparator<String>() {
       @Override
       public int compare(String s1, String s2) {
@@ -283,6 +277,7 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
 
   @Test
   public void toString_with_anonymous_comparator_overriding_toString() {
+    @SuppressWarnings("unused")
     Comparator<String> anonymousComparator = new Comparator<String>() {
       @Override
       public int compare(String s1, String s2) {
@@ -337,13 +332,10 @@ public class StandardRepresentation_unambiguousToStringOf_Test extends AbstractB
     assertThat(unambiguousToStringOf(b)).isNotEqualTo(unambiguousToStringOf(c));
     assertThat(unambiguousToStringOf(b)).isNotEqualTo(unambiguousToStringOf(s));
     assertThat(unambiguousToStringOf(c)).isNotEqualTo(unambiguousToStringOf(s));
-    assertThat(unambiguousToStringOf(b))
-                                        .isEqualTo(format("20 (Byte@%s)", toHexString(System.identityHashCode(b))));
-    assertThat(unambiguousToStringOf(c))
-                                        .isEqualTo(format("'\u0014' (Character@%s)",
+    assertThat(unambiguousToStringOf(b)).isEqualTo(format("20 (Byte@%s)", toHexString(System.identityHashCode(b))));
+    assertThat(unambiguousToStringOf(c)).isEqualTo(format("'\u0014' (Character@%s)",
                                                           toHexString(System.identityHashCode(c))));
-    assertThat(unambiguousToStringOf(s))
-                                        .isEqualTo(format("20 (Short@%s)", toHexString(System.identityHashCode(s))));
+    assertThat(unambiguousToStringOf(s)).isEqualTo(format("20 (Short@%s)", toHexString(System.identityHashCode(s))));
   }
 
   @Test
