diff --git a/src/main/java/org/assertj/core/api/AbstractDateAssert.java b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
index 1c70066b2..3646e5a66 100644
--- a/src/main/java/org/assertj/core/api/AbstractDateAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractDateAssert.java
@@ -2555,8 +2555,8 @@ public abstract class AbstractDateAssert<S extends AbstractDateAssert<S>> extend
     date = parseDateWithDefaultDateFormats(dateAsString);
     if (date != null) return date;
     // no matching date format, throw an error
-    throw new AssertionError("Failed to parse " + dateAsString + " with any of these date formats: "
-                             + info.representation().toStringOf(dateFormatsInOrderOfUsage()));
+    throw new AssertionError(String.format("Failed to parse %s with any of these date formats:%n   %s", dateAsString,
+                                           info.representation().toStringOf(dateFormatsInOrderOfUsage())));
   }
 
   private Date parseDateWithDefaultDateFormats(final String dateAsString) {
diff --git a/src/main/java/org/assertj/core/presentation/DefaultToString.java b/src/main/java/org/assertj/core/presentation/DefaultToString.java
index a70878957..5f3f76961 100644
--- a/src/main/java/org/assertj/core/presentation/DefaultToString.java
+++ b/src/main/java/org/assertj/core/presentation/DefaultToString.java
@@ -47,7 +47,7 @@ public final class DefaultToString {
   public static String toStringOf(Representation representation, Object o) {
     if (o instanceof Path) return o.toString();
     if (isArray(o)) return Arrays.format(representation, o);
-    if (o instanceof Collection<?>) return IterableUtil.format(representation, (Collection<?>) o);
+    if (o instanceof Collection<?>) return IterableUtil.smartFormat(representation, (Collection<?>) o);
     if (o instanceof Map<?, ?>) return Maps.format(representation, (Map<?, ?>) o);
     if (o instanceof Tuple) return toStringOf((Tuple) o, representation);
     return o == null ? null : o.toString();
diff --git a/src/main/java/org/assertj/core/util/ArrayFormatter.java b/src/main/java/org/assertj/core/util/ArrayFormatter.java
deleted file mode 100644
index 063a08d51..000000000
--- a/src/main/java/org/assertj/core/util/ArrayFormatter.java
+++ /dev/null
@@ -1,116 +0,0 @@
-/**
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- * Copyright 2012-2015 the original author or authors.
- */
-package org.assertj.core.util;
-
-import org.assertj.core.presentation.Representation;
-
-import static java.lang.reflect.Array.getLength;
-import static org.assertj.core.util.Arrays.isArray;
-
-import java.lang.reflect.Array;
-import java.util.HashSet;
-import java.util.Set;
-
-/**
- * Creates a {@code String} representation of an array.
- *
- * @author Alex Ruiz
- * @author Joel Costigliola
- */
-final class ArrayFormatter {
-  private static final String NULL = "null";
-
-  String format(Representation p, Object o) {
-    if (!isArray(o)) {
-      return null;
-    }
-    return isObjectArray(o) ? formatObjectArray(p, o) : formatPrimitiveArray(p, o);
-  }
-
-  private String formatObjectArray(Representation p, Object o) {
-    Object[] array = (Object[]) o;
-    int size = array.length;
-    if (size == 0) {
-      return "[]";
-    }
-    StringBuilder buffer = new StringBuilder(20 * (size - 1));
-    deepToString(p, array, buffer, new HashSet<Object[]>());
-    return buffer.toString();
-  }
-
-  private void deepToString(Representation p, Object[] array, StringBuilder buffer, Set<Object[]> alreadyFormatted) {
-    if (array == null) {
-      buffer.append(NULL);
-      return;
-    }
-    alreadyFormatted.add(array);
-    buffer.append('[');
-    int size = array.length;
-    for (int i = 0; i < size; i++) {
-      if (i != 0) {
-        buffer.append(", ");
-      }
-      Object element = array[i];
-      if (!isArray(element)) {
-        buffer.append(element == null ? NULL : p.toStringOf(element));
-        continue;
-      }
-      if (!isObjectArray(element)) {
-        buffer.append(formatPrimitiveArray(p, element));
-        continue;
-      }
-      if (alreadyFormatted.contains(element)) {
-        buffer.append("[...]");
-        continue;
-      }
-      deepToString(p, (Object[]) element, buffer, alreadyFormatted);
-    }
-    buffer.append(']');
-    alreadyFormatted.remove(array);
-  }
-
-  private boolean isObjectArray(Object o) {
-    return isArray(o) && !isArrayTypePrimitive(o);
-  }
-
-  private String formatPrimitiveArray(Representation p, Object o) {
-    if (!isArray(o)) {
-      return null;
-    }
-    if (!isArrayTypePrimitive(o)) {
-      throw notAnArrayOfPrimitives(o);
-    }
-    int size = getLength(o);
-    if (size == 0) {
-      return "[]";
-    }
-    StringBuilder buffer = new StringBuilder();
-    buffer.append('[');
-    buffer.append(p.toStringOf(Array.get(o, 0)));
-    for (int i = 1; i < size; i++) {
-      Object element = Array.get(o, i);
-      buffer.append(", ");
-      buffer.append(p.toStringOf(element));
-    }
-    buffer.append("]");
-    return buffer.toString();
-  }
-
-  private boolean isArrayTypePrimitive(Object o) {
-    return o.getClass().getComponentType().isPrimitive();
-  }
-
-  private IllegalArgumentException notAnArrayOfPrimitives(Object o) {
-    return new IllegalArgumentException(String.format("<%s> is not an array of primitives", o));
-  }
-}
diff --git a/src/main/java/org/assertj/core/util/Arrays.java b/src/main/java/org/assertj/core/util/Arrays.java
index c22f6a2c7..ee534455b 100644
--- a/src/main/java/org/assertj/core/util/Arrays.java
+++ b/src/main/java/org/assertj/core/util/Arrays.java
@@ -12,13 +12,17 @@
  */
 package org.assertj.core.util;
 
-import org.assertj.core.presentation.Representation;
-import org.assertj.core.presentation.StandardRepresentation;
-
+import static java.lang.reflect.Array.getLength;
 import static java.util.Collections.emptyList;
 import static org.assertj.core.util.Preconditions.checkNotNull;
 
-import java.util.*;
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Set;
+
+import org.assertj.core.presentation.Representation;
 
 /**
  * Utility methods related to arrays.
@@ -26,9 +30,9 @@ import java.util.*;
  * @author Alex Ruiz
  * @author Joel Costigliola
  */
-public class Arrays {
-  private static final ArrayFormatter FORMATTER = new ArrayFormatter();
-  private static final StandardRepresentation STANDARD_REPRESENTATION = new StandardRepresentation();
+public class Arrays extends GroupFormatUtil {
+
+  private static final String NULL = "null";
 
   /**
    * Indicates whether the given object is not {@code null} and is an array.
@@ -48,7 +52,7 @@ public class Arrays {
    * @return {@code true} if the given array is {@code null} or empty, otherwise {@code false}.
    */
   public static <T> boolean isNullOrEmpty(T[] array) {
-    return array == null || !hasElements(array);
+    return array == null || isEmpty(array);
   }
 
   /**
@@ -63,30 +67,6 @@ public class Arrays {
     return values;
   }
 
-  /**
-   * Returns the {@code String} representation of the given array, or {@code null} if the given object is either
-   * {@code null} or not an array. This method supports arrays having other arrays as elements.
-   *
-   * @param representation
-   * @param array the object that is expected to be an array.
-   * @return the {@code String} representation of the given array.
-   */
-  public static String format(Representation representation, Object array) {
-    return FORMATTER.format(representation, array);
-  }
-
-  /**
-   * Returns the {@code String} {@link org.assertj.core.presentation.StandardRepresentation standard representation} of
-   * the given array, or {@code null} if the given object is either {@code null} or not an array.
-   * This method supports arrays having other arrays as elements.
-   *
-   * @param array the object that is expected to be an array.
-   * @return the {@code String} standard representation of the given array.
-   */
-  public static Object format(final Object array) {
-    return format(STANDARD_REPRESENTATION, array);
-  }
-
   /**
    * Returns all the non-{@code null} elements in the given array.
    * 
@@ -97,14 +77,10 @@ public class Arrays {
    * @since 1.1.3
    */
   public static <T> List<T> nonNullElementsIn(T[] array) {
-    if (array == null) {
-      return emptyList();
-    }
+    if (array == null) return emptyList();
     List<T> nonNullElements = new ArrayList<>();
     for (T o : array) {
-      if (o != null) {
-        nonNullElements.add(o);
-      }
+      if (o != null) nonNullElements.add(o);
     }
     return nonNullElements;
   }
@@ -121,19 +97,107 @@ public class Arrays {
    */
   public static <T> boolean hasOnlyNullElements(T[] array) {
     checkNotNull(array);
-    if (!hasElements(array)) {
-      return false;
-    }
+    if (isEmpty(array)) return false;
     for (T o : array) {
-      if (o != null) {
-        return false;
-      }
+      if (o != null) return false;
     }
     return true;
   }
 
-  private static <T> boolean hasElements(T[] array) {
-    return array.length > 0;
+  /**
+   * Returns the {@code String} representation of the given array, or {@code null} if the given object is either
+   * {@code null} or not an array. This method supports arrays having other arrays as elements.
+   *
+   * @param representation
+   * @param array the object that is expected to be an array.
+   * @return the {@code String} representation of the given array.
+   */
+  public static String format(Representation representation, Object o) {
+    if (!isArray(o)) return null;
+    return isObjectArray(o) ? smartFormat(representation, (Object[]) o) : formatPrimitiveArray(representation, o);
+  }
+
+  private static <T> boolean isEmpty(T[] array) {
+    return array.length == 0;
+  }
+
+  private static boolean isObjectArray(Object o) {
+    return isArray(o) && !isArrayTypePrimitive(o);
+  }
+
+  private static boolean isArrayTypePrimitive(Object o) {
+    return o != null && o.getClass().getComponentType().isPrimitive();
+  }
+
+  static IllegalArgumentException notAnArrayOfPrimitives(Object o) {
+    return new IllegalArgumentException(String.format("<%s> is not an array of primitives", o));
+  }
+
+  private static String smartFormat(Representation representation, Object[] iterable) {
+    Set<Object[]> alreadyFormatted = new HashSet<>();
+    String singleLineDescription = singleLineFormat(representation, iterable, DEFAULT_START, DEFAULT_END,
+                                                    alreadyFormatted);
+    return doesDescriptionFitOnSingleLine(singleLineDescription) ?
+        singleLineDescription : multiLineFormat(representation, iterable, alreadyFormatted);
+  }
+
+  private static String singleLineFormat(Representation representation, Object[] iterable, String start, String end,
+                                        Set<Object[]> alreadyFormatted) {
+    return format(representation, iterable, ELEMENT_SEPARATOR, INDENTATION_FOR_SINGLE_LINE, alreadyFormatted);
+  }
+
+  private static String multiLineFormat(Representation representation, Object[] iterable, Set<Object[]> alreadyFormatted) {
+    return format(representation, iterable, ELEMENT_SEPARATOR_WITH_NEWLINE, INDENTATION_AFTER_NEWLINE, alreadyFormatted);
+  }
+
+  private static boolean doesDescriptionFitOnSingleLine(String singleLineDescription) {
+    return singleLineDescription == null || singleLineDescription.length() < maxLengthForSingleLineDescription;
+  }
+
+  private static String format(Representation representation, Object[] array, String elementSeparator,
+                               String indentation, Set<Object[]> alreadyFormatted) {
+    if (array == null) return null;
+    if (array.length == 0) return DEFAULT_START + DEFAULT_END;
+    // iterable has some elements
+    StringBuilder desc = new StringBuilder();
+    desc.append(DEFAULT_START);
+    alreadyFormatted.add(array); // used to avoid infinite recursion when array contains itself
+    int i = 0;
+    while (true) {
+      Object element = array[i];
+      // do not indent first element
+      if (i != 0) desc.append(indentation);
+      // add element representation
+      if (!isArray(element)) desc.append(element == null ? NULL : representation.toStringOf(element));
+      else if (isArrayTypePrimitive(element)) desc.append(formatPrimitiveArray(representation, element));
+      else if (alreadyFormatted.contains(element)) desc.append("(this array)");
+      else desc.append(format(representation, (Object[]) element, elementSeparator, indentation, alreadyFormatted));
+      // manage end description
+      if (i == array.length - 1) {
+        alreadyFormatted.remove(array);
+        return desc.append(DEFAULT_END).toString();
+      }
+      // there are still elements to be describe
+      desc.append(elementSeparator);
+      i++;
+    }
+  }
+
+  private static String formatPrimitiveArray(Representation representation, Object o) {
+    if (!isArray(o)) return null;
+    if (!isArrayTypePrimitive(o)) throw Arrays.notAnArrayOfPrimitives(o);
+    int size = getLength(o);
+    if (size == 0) return DEFAULT_START + DEFAULT_END;;
+    StringBuilder buffer = new StringBuilder();
+    buffer.append(DEFAULT_START);
+    buffer.append(representation.toStringOf(Array.get(o, 0)));
+    for (int i = 1; i < size; i++) {
+      buffer.append(ELEMENT_SEPARATOR)
+            .append(INDENTATION_FOR_SINGLE_LINE)
+            .append(representation.toStringOf(Array.get(o, i)));
+    }
+    buffer.append(DEFAULT_END);
+    return buffer.toString();
   }
 
   private Arrays() {}
diff --git a/src/main/java/org/assertj/core/util/GroupFormatUtil.java b/src/main/java/org/assertj/core/util/GroupFormatUtil.java
new file mode 100644
index 000000000..114f5b7c4
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/GroupFormatUtil.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.util;
+
+public class GroupFormatUtil {
+
+  static final String ELEMENT_SEPARATOR = ",";
+  static final String ELEMENT_SEPARATOR_WITH_NEWLINE = ELEMENT_SEPARATOR + System.lineSeparator();
+  static final String DEFAULT_END = "]";
+  static final String DEFAULT_START = "[";
+  // 4 spaces indentation : 2 space indentation after new line + '<' + '['
+  static final String INDENTATION_AFTER_NEWLINE = "    ";
+  // used when formatting iterable to a single line
+  static final String INDENTATION_FOR_SINGLE_LINE = " ";
+  @VisibleForTesting
+  static int maxLengthForSingleLineDescription = 80;
+
+  public static void setMaxLengthForSingleLineDescription(int maxLengthForSingleLineDescription) {
+    if (maxLengthForSingleLineDescription <= 0)
+      throw new IllegalArgumentException("maxLengthForSingleLineDescription must be > 0 but was "
+                                         + maxLengthForSingleLineDescription);
+    IterableUtil.maxLengthForSingleLineDescription = maxLengthForSingleLineDescription;
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/util/IterableUtil.java b/src/main/java/org/assertj/core/util/IterableUtil.java
index 789412e6f..0e842e93d 100644
--- a/src/main/java/org/assertj/core/util/IterableUtil.java
+++ b/src/main/java/org/assertj/core/util/IterableUtil.java
@@ -23,16 +23,7 @@ import java.util.List;
 
 import org.assertj.core.presentation.Representation;
 
-public final class IterableUtil {
-
-  private static final String ELEMENT_SEPARATOR = ",";
-  private static final String ELEMENT_SEPARATOR_WITH_NEWLINE = ELEMENT_SEPARATOR + System.lineSeparator();
-  private static final String DEFAULT_END = "]";
-  private static final String DEFAULT_START = "[";
-  // 4 spaces indentation : 2 space indentation after new line + '<' + '['
-  private static final String INDENTATION_AFTER_NEWLINE = "    ";
-  // used when formatting iterable to a single line
-  private static final String INDENTATION_FOR_SINGLE_LINE = " ";
+public final class IterableUtil extends GroupFormatUtil {
 
   /**
    * Indicates whether the given {@link Iterable} is {@code null} or empty.
@@ -134,25 +125,18 @@ public final class IterableUtil {
   /**
    * Returns the {@code String} representation of the given {@code Iterable}, or {@code null} if the given
    * {@code Iterable} is {@code null}.
-   * 
-   * @param representation
-   * @param iterable the {@code Iterable} to format.
-   * @return the {@code String} representation of the given {@code Collection}.
-   */
-  public static String format(Representation representation, Iterable<?> iterable) {
-    return format(representation, iterable, DEFAULT_START, DEFAULT_END);
-  }
-
-  /**
-   * Returns the {@code String} representation of the given {@code Iterable}, or {@code null} if the given
-   * {@code Iterable} is {@code null}.
+   * <p>
+   * The {@code Iterable} will be formatted to a single line if it does not exceed 100 char, otherwise each elements
+   * will be formatted on a new line with 4 space indentation.
    * 
    * @param representation
    * @param iterable the {@code Iterable} to format.
    * @return the {@code String} representation of the given {@code Iterable}.
    */
-  public static String format(Representation representation, Iterable<?> iterable, String start, String end) {
-    return singleLineFormat(representation, iterable, start, end);
+  public static String smartFormat(Representation representation, Iterable<?> iterable) {
+    String singleLineDescription = singleLineFormat(representation, iterable, DEFAULT_START, DEFAULT_END);
+    return doesDescriptionFitOnSingleLine(singleLineDescription) ?
+        singleLineDescription : multiLineFormat(representation, iterable);
   }
 
   public static String singleLineFormat(Representation representation, Iterable<?> iterable, String start, String end) {
@@ -164,6 +148,10 @@ public final class IterableUtil {
                   INDENTATION_AFTER_NEWLINE);
   }
 
+  private static boolean doesDescriptionFitOnSingleLine(String singleLineDescription) {
+    return singleLineDescription == null || singleLineDescription.length() < maxLengthForSingleLineDescription;
+  }
+
   private static String format(Representation representation, Iterable<?> iterable, String start, String end,
                                String elementSeparator, String indentation) {
     if (iterable == null) return null;
diff --git a/src/test/java/org/assertj/core/api/date/AbstractDateAssertWithDateArg_Test.java b/src/test/java/org/assertj/core/api/date/AbstractDateAssertWithDateArg_Test.java
index 26da4e391..9adf193f1 100644
--- a/src/test/java/org/assertj/core/api/date/AbstractDateAssertWithDateArg_Test.java
+++ b/src/test/java/org/assertj/core/api/date/AbstractDateAssertWithDateArg_Test.java
@@ -12,8 +12,8 @@
  */
 package org.assertj.core.api.date;
 
-import static org.assertj.core.test.ExpectedException.none;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.test.ExpectedException.none;
 
 import java.text.ParseException;
 import java.text.SimpleDateFormat;
@@ -86,11 +86,12 @@ public abstract class AbstractDateAssertWithDateArg_Test extends DateAssertBaseT
 
   @Test
   public void should_fail_because_date_string_representation_does_not_follow_expected_format() {
-    thrown.expectAssertionError("Failed to parse " + dateAsStringWithBadFormat + " with any of these date formats: [" +
-                                "yyyy-MM-dd'T'HH:mm:ss.SSS, " +
-                                "yyyy-MM-dd HH:mm:ss.SSS, " +
-                                "yyyy-MM-dd'T'HH:mm:ss, " +
-                                "yyyy-MM-dd]");
+    thrown.expectAssertionError(String.format("Failed to parse " + dateAsStringWithBadFormat
+                                              + " with any of these date formats:%n" +
+                                              "   [yyyy-MM-dd'T'HH:mm:ss.SSS,%n" +
+                                              "    yyyy-MM-dd HH:mm:ss.SSS,%n" +
+                                              "    yyyy-MM-dd'T'HH:mm:ss,%n" +
+                                              "    yyyy-MM-dd]"));
     assertionInvocationWithStringArg(dateAsStringWithBadFormat);
   }
 
diff --git a/src/test/java/org/assertj/core/api/date/DateAssert_with_string_based_date_representation_Test.java b/src/test/java/org/assertj/core/api/date/DateAssert_with_string_based_date_representation_Test.java
index ae255d387..26365d3a9 100644
--- a/src/test/java/org/assertj/core/api/date/DateAssert_with_string_based_date_representation_Test.java
+++ b/src/test/java/org/assertj/core/api/date/DateAssert_with_string_based_date_representation_Test.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.core.api.date;
 
+import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.registerCustomDateFormat;
 import static org.assertj.core.api.Assertions.useDefaultDateFormatsOnly;
@@ -74,11 +75,11 @@ public class DateAssert_with_string_based_date_representation_Test extends DateA
   @Test
   public void should_fail_if_given_date_string_representation_cant_be_parsed_with_default_date_formats() {
     final String dateAsString = "2003/04/26";
-    thrown.expectAssertionError("Failed to parse " + dateAsString + " with any of these date formats: [" +
-                                "yyyy-MM-dd'T'HH:mm:ss.SSS, " +
-                                "yyyy-MM-dd HH:mm:ss.SSS, " +
-                                "yyyy-MM-dd'T'HH:mm:ss, " +
-                                "yyyy-MM-dd]");
+    thrown.expectAssertionError(format("Failed to parse 2003/04/26 with any of these date formats:%n" +
+                                       "   [yyyy-MM-dd'T'HH:mm:ss.SSS,%n" +
+                                       "    yyyy-MM-dd HH:mm:ss.SSS,%n" +
+                                       "    yyyy-MM-dd'T'HH:mm:ss,%n" +
+                                       "    yyyy-MM-dd]"));
     assertThat(new Date()).isEqualTo(dateAsString);
   }
 
@@ -91,9 +92,13 @@ public class DateAssert_with_string_based_date_representation_Test extends DateA
 
   @Test
   public void should_fail_if_given_date_string_representation_cant_be_parsed_with_any_custom_date_formats() {
-    thrown.expectAssertionError("Failed to parse 2003 04 26 with any of these date formats: "
-                                +
-                                "[yyyy/MM/dd'T'HH:mm:ss, yyyy/MM/dd, yyyy-MM-dd'T'HH:mm:ss.SSS, yyyy-MM-dd HH:mm:ss.SSS, yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]");
+    thrown.expectAssertionError(format("Failed to parse 2003 04 26 with any of these date formats:%n" +
+                                       "   [yyyy/MM/dd'T'HH:mm:ss,%n" +
+                                       "    yyyy/MM/dd,%n" +
+                                       "    yyyy-MM-dd'T'HH:mm:ss.SSS,%n" +
+                                       "    yyyy-MM-dd HH:mm:ss.SSS,%n" +
+                                       "    yyyy-MM-dd'T'HH:mm:ss,%n" +
+                                       "    yyyy-MM-dd]"));
     final Date date = DateUtil.parse("2003-04-26");
     registerCustomDateFormat("yyyy/MM/dd'T'HH:mm:ss");
     // registering again has no effect
@@ -122,9 +127,12 @@ public class DateAssert_with_string_based_date_representation_Test extends DateA
       // fail : the registered format does not match the given date
       assertThat(date).isEqualTo("2003/04/26");
     } catch (AssertionError e) {
-      assertThat(e).hasMessage("Failed to parse 2003/04/26 with any of these date formats: "
-                                   +
-                                   "[yyyy/MM/dd'T'HH:mm:ss, yyyy-MM-dd'T'HH:mm:ss.SSS, yyyy-MM-dd HH:mm:ss.SSS, yyyy-MM-dd'T'HH:mm:ss, yyyy-MM-dd]");
+      assertThat(e).hasMessage(format("Failed to parse 2003/04/26 with any of these date formats:%n" +
+                                      "   [yyyy/MM/dd'T'HH:mm:ss,%n" +
+                                      "    yyyy-MM-dd'T'HH:mm:ss.SSS,%n" +
+                                      "    yyyy-MM-dd HH:mm:ss.SSS,%n" +
+                                      "    yyyy-MM-dd'T'HH:mm:ss,%n" +
+                                      "    yyyy-MM-dd]"));
     }
 
     // register the expected custom formats, they are used in the order they have been registered.
@@ -151,11 +159,11 @@ public class DateAssert_with_string_based_date_representation_Test extends DateA
       // date with a custom format : failure since the default formats don't match.
       assertThat(date).isEqualTo("2003/04/26");
     } catch (AssertionError e) {
-      assertThat(e).hasMessage("Failed to parse 2003/04/26 with any of these date formats: [" +
-                               "yyyy-MM-dd'T'HH:mm:ss.SSS, " +
-                               "yyyy-MM-dd HH:mm:ss.SSS, " +
-                               "yyyy-MM-dd'T'HH:mm:ss, " +
-                               "yyyy-MM-dd]");
+      assertThat(e).hasMessage(format("Failed to parse 2003/04/26 with any of these date formats:%n" +
+                                      "   [yyyy-MM-dd'T'HH:mm:ss.SSS,%n" +
+                                      "    yyyy-MM-dd HH:mm:ss.SSS,%n" +
+                                      "    yyyy-MM-dd'T'HH:mm:ss,%n" +
+                                      "    yyyy-MM-dd]"));
     }
 
     // registering a custom date format to make the assertion pass
@@ -169,12 +177,13 @@ public class DateAssert_with_string_based_date_representation_Test extends DateA
       // but if not format at all matches, it fails.
       assertThat(date).isEqualTo("2003 04 26");
     } catch (AssertionError e) {
-      assertThat(e).hasMessage("Failed to parse 2003 04 26 with any of these date formats: [" +
-                               "yyyy/MM/dd, " +
-                               "yyyy-MM-dd'T'HH:mm:ss.SSS, " +
-                               "yyyy-MM-dd HH:mm:ss.SSS, " +
-                               "yyyy-MM-dd'T'HH:mm:ss, " +
-                               "yyyy-MM-dd]");
+      assertThat(e).hasMessage(format("Failed to parse 2003 04 26 with any of these date formats:%n" +
+                                      "   [yyyy/MM/dd,%n" +
+                                      "    yyyy-MM-dd'T'HH:mm:ss.SSS,%n" +
+                                      "    yyyy-MM-dd HH:mm:ss.SSS,%n" +
+                                      "    yyyy-MM-dd'T'HH:mm:ss,%n" +
+                                      "    yyyy-MM-dd]"));
+
     }
 
     // register a new custom format should work
diff --git a/src/test/java/org/assertj/core/util/ArrayFormatter_format_Test.java b/src/test/java/org/assertj/core/util/ArrayFormatter_format_Test.java
deleted file mode 100644
index db1c0ccb4..000000000
--- a/src/test/java/org/assertj/core/util/ArrayFormatter_format_Test.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/**
- * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
- * the License. You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
- * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
- * specific language governing permissions and limitations under the License.
- *
- * Copyright 2012-2015 the original author or authors.
- */
-package org.assertj.core.util;
-
-import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.util.Strings.quote;
-
-import org.assertj.core.presentation.HexadecimalRepresentation;
-import org.assertj.core.presentation.StandardRepresentation;
-import org.junit.BeforeClass;
-import org.junit.Test;
-
-/**
- * Tests for {@link ArrayFormatter#format(org.assertj.core.presentation.Representation, Object)}.
- * 
- * @author Alex Ruiz
- */
-public class ArrayFormatter_format_Test {
-  private static ArrayFormatter formatter;
-
-  @BeforeClass
-  public static void setUpOnce() {
-    formatter = new ArrayFormatter();
-  }
-
-  @Test
-  public void should_return_null_if_array_is_null() {
-    assertThat(formatter.format(new StandardRepresentation(), null)).isNull();
-  }
-
-  @Test
-  public void should_return_null_if_parameter_is_not_array() {
-    assertThat(formatter.format(new StandardRepresentation(), "Hello")).isNull();
-  }
-
-  @Test
-  public void should_format_boolean_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new boolean[]{true, false, true}))
-        .isEqualTo("[true, false, true]");
-  }
-
-  @Test
-  public void should_format_char_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new char[] { 'a', 'b', 'c' }))
-        .isEqualTo("['a', 'b', 'c']");
-  }
-
-  @Test
-  public void should_format_byte_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new byte[] { 6, 8 }))
-        .isEqualTo("[6, 8]");
-  }
-
-  @Test
-  public void should_format_byte_array_in_hex_representation() {
-    assertThat(formatter.format(new HexadecimalRepresentation(), new byte[] { 6, 8 }))
-        .isEqualTo("[0x06, 0x08]");
-  }
-
-  @Test
-  public void should_format_short_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new short[] { 6, 8 }))
-        .isEqualTo("[6, 8]");
-  }
-
-  @Test
-  public void should_format_int_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new int[] { 6, 8 }))
-        .isEqualTo("[6, 8]");
-  }
-
-  @Test
-  public void should_format_longArray() {
-    assertThat(formatter.format(new StandardRepresentation(), new long[] { 6l, 8l }))
-        .isEqualTo("[6L, 8L]");
-  }
-
-  @Test
-  public void should_format_float_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new float[] { 6f, 8f }))
-        .isEqualTo("[6.0f, 8.0f]");
-  }
-
-  @Test
-  public void should_format_double_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new double[] { 6d, 8d }))
-        .isEqualTo("[6.0, 8.0]");
-  }
-
-  @Test
-  public void should_format_String_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new Object[] { "Hello", "World" }))
-        .isEqualTo("[\"Hello\", \"World\"]");
-  }
-
-  @Test
-  public void should_format_array_with_null_element() {
-    assertThat(formatter.format(new StandardRepresentation(), new Object[] { "Hello", null }))
-        .isEqualTo("[\"Hello\", null]");
-  }
-
-  @Test
-  public void should_format_Object_array() {
-    assertThat(formatter.format(new StandardRepresentation(), new Object[] { "Hello", new Person("Anakin") }))
-        .isEqualTo("[\"Hello\", 'Anakin']");
-  }
-
-  @Test
-  public void should_format_Object_array_that_has_primitive_array_as_element() {
-    boolean booleans[] = { true, false };
-    Object[] array = { "Hello", booleans };
-    assertThat(formatter.format(new StandardRepresentation(), array))
-        .isEqualTo("[\"Hello\", [true, false]]");
-  }
-
-  @Test
-  public void should_format_Object_array_having_itself_as_element() {
-    Object[] array1 = { "Hello", "World" };
-    Object[] array2 = { array1 };
-    array1[1] = array2;
-    assertThat(formatter.format(new StandardRepresentation(), array2))
-        .isEqualTo("[[\"Hello\", [...]]]");
-  }
-
-  private static class Person {
-    private final String name;
-
-    Person(String name) {
-      this.name = name;
-    }
-
-    @Override
-    public String toString() {
-      return quote(name);
-    }
-  }
-}
diff --git a/src/test/java/org/assertj/core/util/Arrays_format_Test.java b/src/test/java/org/assertj/core/util/Arrays_format_Test.java
index e83645052..2cc895a77 100644
--- a/src/test/java/org/assertj/core/util/Arrays_format_Test.java
+++ b/src/test/java/org/assertj/core/util/Arrays_format_Test.java
@@ -12,10 +12,11 @@
  */
 package org.assertj.core.util;
 
-import static org.assertj.core.api.Assertions.*;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
+import static org.assertj.core.util.Strings.quote;
 
 import org.assertj.core.presentation.HexadecimalRepresentation;
-import org.assertj.core.presentation.StandardRepresentation;
 import org.junit.Test;
 
 /**
@@ -28,36 +29,25 @@ public class Arrays_format_Test {
   @Test
   public void should_return_null_if_array_is_null() {
     final Object array = null;
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isNull();
-    assertThat(Arrays.format(array)).isNull();
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isNull();
   }
 
   @Test
   public void should_return_empty_brackets_if_array_is_empty() {
     final Object[] array = new Object[0];
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[]");
-    assertThat(Arrays.format(array)).isEqualTo("[]");
-  }
-
-  @Test
-  public void should_format_Object_array() {
-    Object array = new Object[] { "First", 3 };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[\"First\", 3]");
-    assertThat(Arrays.format(array)).isEqualTo("[\"First\", 3]");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[]");
   }
 
   @Test
   public void should_format_boolean_array() {
     Object array = new boolean[] { true, false };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[true, false]");
-    assertThat(Arrays.format(array)).isEqualTo("[true, false]");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[true, false]");
   }
 
   @Test
   public void should_format_byte_array() {
     Object array = new byte[] { (byte) 3, (byte) 8 };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[3, 8]");
-    assertThat(Arrays.format(array)).isEqualTo("[3, 8]");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[3, 8]");
   }
 
   @Test
@@ -69,42 +59,90 @@ public class Arrays_format_Test {
   @Test
   public void should_format_char_array() {
     Object array = new char[] { 'a', 'b' };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("['a', 'b']");
-    assertThat(Arrays.format(array)).isEqualTo("['a', 'b']");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("['a', 'b']");
   }
 
   @Test
   public void should_format_double_array() {
     Object array = new double[] { 6.8, 8.3 };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[6.8, 8.3]");
-    assertThat(Arrays.format(array)).isEqualTo("[6.8, 8.3]");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[6.8, 8.3]");
   }
 
   @Test
   public void should_format_float_array() {
     Object array = new float[] { 6.1f, 8.6f };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[6.1f, 8.6f]");
-    assertThat(Arrays.format(array)).isEqualTo("[6.1f, 8.6f]");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[6.1f, 8.6f]");
   }
 
   @Test
   public void should_format_int_array() {
     Object array = new int[] { 78, 66 };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[78, 66]");
-    assertThat(Arrays.format(array)).isEqualTo("[78, 66]");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[78, 66]");
   }
 
   @Test
   public void should_format_long_array() {
     Object array = new long[] { 160l, 98l };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[160L, 98L]");
-    assertThat(Arrays.format(array)).isEqualTo("[160L, 98L]");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[160L, 98L]");
   }
 
   @Test
   public void should_format_short_array() {
     Object array = new short[] { (short) 5, (short) 8 };
-    assertThat(Arrays.format(new StandardRepresentation(), array)).isEqualTo("[5, 8]");
-    assertThat(Arrays.format(array)).isEqualTo("[5, 8]");
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[5, 8]");
+  }
+
+  @Test
+  public void should_return_null_if_parameter_is_not_array() {
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, "Hello")).isNull();
+  }
+
+  @Test
+  public void should_format_longArray() {
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, new long[] { 6l, 8l })).isEqualTo("[6L, 8L]");
+  }
+
+  @Test
+  public void should_format_String_array() {
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, new Object[] { "Hello", "World" })).isEqualTo("[\"Hello\", \"World\"]");
+  }
+
+  @Test
+  public void should_format_array_with_null_element() {
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, new Object[] { "Hello", null })).isEqualTo("[\"Hello\", null]");
   }
+
+  @Test
+  public void should_format_Object_array() {
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, new Object[] { "Hello", new Person("Anakin") })).isEqualTo("[\"Hello\", 'Anakin']");
+  }
+
+  @Test
+  public void should_format_Object_array_that_has_primitive_array_as_element() {
+    boolean booleans[] = { true, false };
+    Object[] array = { "Hello", booleans };
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array)).isEqualTo("[\"Hello\", [true, false]]");
+  }
+
+  @Test
+  public void should_format_Object_array_having_itself_as_element() {
+    Object[] array1 = { "Hello", "World" };
+    Object[] array2 = { array1 };
+    array1[1] = array2;
+    assertThat(Arrays.format(STANDARD_REPRESENTATION, array2)).isEqualTo("[[\"Hello\", (this array)]]");
+  }
+
+  private static class Person {
+    private final String name;
+
+    Person(String name) {
+      this.name = name;
+    }
+
+    @Override
+    public String toString() {
+      return quote(name);
+    }
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/util/IterableUtil_format_Test.java b/src/test/java/org/assertj/core/util/IterableUtil_format_Test.java
index f23409262..8b40eaf49 100644
--- a/src/test/java/org/assertj/core/util/IterableUtil_format_Test.java
+++ b/src/test/java/org/assertj/core/util/IterableUtil_format_Test.java
@@ -18,6 +18,7 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.presentation.HexadecimalRepresentation.HEXA_REPRESENTATION;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
 import static org.assertj.core.util.IterableUtil.multiLineFormat;
+import static org.assertj.core.util.IterableUtil.smartFormat;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -28,25 +29,34 @@ public class IterableUtil_format_Test {
 
   @Test
   public void should_return_null_if_iterable_is_null() {
-    assertThat(IterableUtil.format(STANDARD_REPRESENTATION, null)).isNull();
+    assertThat(IterableUtil.smartFormat(STANDARD_REPRESENTATION, null)).isNull();
   }
 
   @Test
   public void should_return_empty_brackets_if_iterable_is_empty() {
-    assertThat(IterableUtil.format(STANDARD_REPRESENTATION, asList())).isEqualTo("[]");
+    assertThat(IterableUtil.smartFormat(STANDARD_REPRESENTATION, asList())).isEqualTo("[]");
   }
 
   @Test
-  public void should_format_iterable() {
-    List<? extends Object> list = asList("First", 3);
-    assertThat(IterableUtil.format(STANDARD_REPRESENTATION, list)).isEqualTo("[\"First\", 3]");
+  public void should_format_iterable_on_one_line_if_description_is_short_enough() {
+    String e1 = stringOfLength(IterableUtil.maxLengthForSingleLineDescription / 10);
+    String e2 = stringOfLength(IterableUtil.maxLengthForSingleLineDescription / 10);
+    assertThat(smartFormat(STANDARD_REPRESENTATION, asList(e1, e2))).isEqualTo("[\"" + e1 + "\", \"" + e2 + "\"]");
+  }
+
+  @Test
+  public void should_format_iterable_with_an_element_per_line_if_single_line_description_is_too_long() {
+    String e1 = stringOfLength(IterableUtil.maxLengthForSingleLineDescription);
+    String e2 = stringOfLength(IterableUtil.maxLengthForSingleLineDescription);
+    assertThat(smartFormat(STANDARD_REPRESENTATION, asList(e1, e2))).isEqualTo(format("[\"" + e1 + "\",%n" +
+                                                                                      "    \"" + e2 + "\"]"));
   }
 
   @Test
   public void should_format_iterable_with_custom_start_and_end() {
     List<? extends Object> list = asList("First", 3);
-    assertThat(IterableUtil.format(STANDARD_REPRESENTATION, list, "{", "}")).isEqualTo("{\"First\", 3}");
-    assertThat(IterableUtil.format(STANDARD_REPRESENTATION, asList(), "{", "}")).isEqualTo("{}");
+    assertThat(IterableUtil.singleLineFormat(STANDARD_REPRESENTATION, list, "{", "}")).isEqualTo("{\"First\", 3}");
+    assertThat(IterableUtil.singleLineFormat(STANDARD_REPRESENTATION, asList(), "{", "}")).isEqualTo("{}");
   }
 
   @Test
@@ -80,4 +90,12 @@ public class IterableUtil_format_Test {
                                            "    (this Collection)]"));
   }
 
+  private static String stringOfLength(int length) {
+    StringBuilder sb = new StringBuilder();
+    for (int i = 0; i < length; i++) {
+      sb.append(i % 10);
+    }
+    return sb.toString();
+  }
+
 }
