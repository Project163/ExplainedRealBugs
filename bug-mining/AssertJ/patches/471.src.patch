diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 7fb5e46f7..41221c5cc 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -641,11 +641,7 @@ public class RecursiveComparisonConfiguration {
   }
 
   boolean shouldIgnore(DualValue dualValue) {
-    FieldLocation fieldLocation = dualValue.fieldLocation;
-    return !shouldBeCompared(fieldLocation)
-           || matchesAnIgnoredField(fieldLocation)
-           || matchesAnIgnoredFieldRegex(fieldLocation)
-           || shouldIgnoreFieldBasedOnFieldValue(dualValue);
+    return shouldIgnoreFieldBasedOnFieldLocation(dualValue.fieldLocation) || shouldIgnoreFieldBasedOnFieldValue(dualValue);
   }
 
   private boolean shouldBeCompared(FieldLocation fieldLocation) {
@@ -663,7 +659,7 @@ public class RecursiveComparisonConfiguration {
                             || field.hasChild(comparedField); // ex: field "name" and "name.first" compared field
   }
 
-  Set<String> getNonIgnoredActualFieldNames(DualValue dualValue) {
+  Set<String> getActualFieldNamesToCompare(DualValue dualValue) {
     Set<String> actualFieldsNames = Objects.getFieldsNames(dualValue.actual.getClass());
     // we are doing the same as shouldIgnore(DualValue dualValue) but in two steps for performance reasons:
     // - we filter first ignored field by names that don't need building DualValues
@@ -690,7 +686,7 @@ public class RecursiveComparisonConfiguration {
   }
 
   private boolean shouldIgnoreFieldBasedOnFieldLocation(FieldLocation fieldLocation) {
-    return matchesAnIgnoredField(fieldLocation) || matchesAnIgnoredFieldRegex(fieldLocation);
+    return !shouldBeCompared(fieldLocation) || matchesAnIgnoredField(fieldLocation) || matchesAnIgnoredFieldRegex(fieldLocation);
   }
 
   private static DualValue dualValueForField(DualValue parentDualValue, String fieldName) {
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 6cbfd795c..343918ff7 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -124,14 +124,14 @@ public class RecursiveComparisonDifferenceCalculator {
         // disregard the equals method and start comparing fields
         // TODO should fail if actual and expected don't have the same fields to compare (taking into account ignored/compared
         // fields)
-        Set<String> nonIgnoredActualFieldsNames = recursiveComparisonConfiguration.getNonIgnoredActualFieldNames(dualValue);
-        if (!nonIgnoredActualFieldsNames.isEmpty()) {
+        Set<String> actualFieldNamesToCompare = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
+        if (!actualFieldNamesToCompare.isEmpty()) {
           // fields to ignore are evaluated when adding their corresponding dualValues to dualValuesToCompare which filters
           // ignored fields according to recursiveComparisonConfiguration
           Set<String> expectedFieldsNames = getFieldsNames(expected.getClass());
-          if (expectedFieldsNames.containsAll(nonIgnoredActualFieldsNames)) {
+          if (expectedFieldsNames.containsAll(actualFieldNamesToCompare)) {
             // we compare actual fields vs expected, ignoring expected additional fields
-            for (String nonIgnoredActualFieldName : nonIgnoredActualFieldsNames) {
+            for (String nonIgnoredActualFieldName : actualFieldNamesToCompare) {
               DualValue fieldDualValue = new DualValue(fieldLocation.field(nonIgnoredActualFieldName),
                                                        COMPARISON.getSimpleValue(nonIgnoredActualFieldName, actual),
                                                        COMPARISON.getSimpleValue(nonIgnoredActualFieldName, expected));
@@ -322,7 +322,7 @@ public class RecursiveComparisonDifferenceCalculator {
         continue;
       }
 
-      Set<String> actualNonIgnoredFieldsNames = recursiveComparisonConfiguration.getNonIgnoredActualFieldNames(dualValue);
+      Set<String> actualNonIgnoredFieldsNames = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
       Set<String> expectedFieldsNames = getFieldsNames(expectedFieldClass);
       // Check if expected has more fields than actual, in that case the additional fields are reported as difference
       if (!expectedFieldsNames.containsAll(actualNonIgnoredFieldsNames)) {
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
index e67c75417..9c34fbe32 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test.java
@@ -199,4 +199,55 @@ class RecursiveComparisonAssert_isEqualTo_comparingOnlyFields_Test extends Recur
                 .isEqualTo(expected);
   }
 
+  static class StaffWithLessFields {
+    Boolean deleted;
+  }
+
+  @Test
+  public void should_fail_when_actual_differs_from_expected_on_compared_fields_independent_of_object_order() {
+    // GIVEN
+    Staff staff = new Staff();
+    StaffWithLessFields staffWithLessFields = new StaffWithLessFields();
+    staff.setDeleted(Boolean.TRUE);
+    staffWithLessFields.deleted = Boolean.FALSE;
+    // WHEN
+    recursiveComparisonConfiguration.compareOnlyFields("deleted");
+    // THEN
+    compareRecursivelyFailsAsExpected(staffWithLessFields, staff);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(staffWithLessFields, staff,
+                                                              diff("deleted", staffWithLessFields.deleted, staff.deleted));
+    compareRecursivelyFailsAsExpected(staff, staffWithLessFields);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(staff, staffWithLessFields,
+                                                              diff("deleted", staff.deleted, staffWithLessFields.deleted));
+  }
+
+  // https://github.com/assertj/assertj-core/issues/2610
+  static class A1 {
+    final int a, b;
+
+    A1(int a, int b) {
+      this.a = a;
+      this.b = b;
+    }
+  }
+  static class A2 {
+    final int a;
+
+    A2(int a) {
+      this.a = a;
+    }
+  }
+
+  @Test
+  public void should_fix_2610() {
+    // GIVEN
+    A1 actual = new A1(1, 2);
+    A2 expected = new A2(2);
+    recursiveComparisonConfiguration.compareOnlyFields("a");
+    // WHEN
+    compareRecursivelyFailsAsExpected(actual, expected);
+    // THEN
+    ComparisonDifference difference = diff("a", actual.a, expected.a);
+    verifyShouldBeEqualByComparingFieldByFieldRecursivelyCall(actual, expected, difference);
+  }
 }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
index 416f88070..093acebc7 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test.java
@@ -12,19 +12,18 @@
  */
 package org.assertj.core.api.recursive.comparison;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.util.Lists.list;
 
 import java.util.Date;
 import java.util.Set;
 
 import org.assertj.core.internal.objects.data.Person;
+import org.assertj.core.internal.objects.data.PersonDtoWithPersonNeighbour;
 import org.junit.jupiter.api.BeforeEach;
-import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
-@DisplayName("RecursiveComparisonConfiguration getNonIgnoredActualFieldNames")
-class RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test {
+class RecursiveComparisonConfiguration_getActualFieldNamesToCompare_Test {
 
   private RecursiveComparisonConfiguration recursiveComparisonConfiguration;
 
@@ -51,9 +50,45 @@ class RecursiveComparisonConfiguration_getActualNonIgnoreFields_Test {
     person2.neighbour.home.address.number = 456;
     DualValue dualValue = new DualValue(list("people"), person1, person2);
     // WHEN
-    Set<String> fields = recursiveComparisonConfiguration.getNonIgnoredActualFieldNames(dualValue);
+    Set<String> fields = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
     // THEN
-    assertThat(fields).doesNotContain("number", "dateOfBirth", "name");
+    then(fields).doesNotContain("number", "dateOfBirth", "name");
   }
 
+  @Test
+  void should_compute_ignored_fields_honoring_comparingOnly_fields() {
+    // GIVEN
+    recursiveComparisonConfiguration.compareOnlyFields("dateOfBirth", "home.address");
+    Person person1 = new Person("John");
+    person1.home.address.number = 1;
+    person1.dateOfBirth = new Date(123);
+    person1.neighbour = new Person("Jack");
+    person1.neighbour.home.address.number = 123;
+    Person person2 = new Person("John");
+    person2.home.address.number = 1;
+    person2.dateOfBirth = new Date(123);
+    person2.neighbour = new Person("Jim");
+    person2.neighbour.home.address.number = 456;
+    DualValue dualValue = new DualValue(list(), person1, person2);
+    // WHEN
+    Set<String> fields = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
+    // THEN
+    // "home.address" is not present since getActualFieldNamesToCompare look at the direct fields
+    // it registers "home" because we need to compare "home.address",
+    // getActualFieldNamesToCompare will return "address" when inspecting "home"
+    then(fields).containsOnly("dateOfBirth", "home");
+  }
+
+  @Test
+  void should_only_return_fields_from_compareOnlyFields_list() {
+    // GIVEN
+    recursiveComparisonConfiguration.compareOnlyFields("people.name");
+    Person person1 = new Person("John");
+    PersonDtoWithPersonNeighbour person2 = new PersonDtoWithPersonNeighbour("John");
+    DualValue dualValue = new DualValue(list("people"), person2, person1);
+    // WHEN
+    Set<String> fields = recursiveComparisonConfiguration.getActualFieldNamesToCompare(dualValue);
+    // THEN
+    then(fields).containsExactly("name");
+  }
 }
