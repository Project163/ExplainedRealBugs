diff --git a/src/main/java/org/assertj/core/condition/AllOf.java b/src/main/java/org/assertj/core/condition/AllOf.java
index 70a29c28a..217907171 100644
--- a/src/main/java/org/assertj/core/condition/AllOf.java
+++ b/src/main/java/org/assertj/core/condition/AllOf.java
@@ -12,12 +12,18 @@
  */
 package org.assertj.core.condition;
 
+import static java.util.stream.Collectors.toList;
+
+import java.util.List;
+
 import org.assertj.core.api.Condition;
+import org.assertj.core.description.Description;
+import org.assertj.core.description.JoinDescription;
 
 /**
  * Returns {@code true} if all of the joined conditions are satisfied.
  * @param <T> the type of object this condition accepts.
- * 
+ *
  * @author Yvonne Wang
  * @author Mikhail Mazursky
  */
@@ -65,6 +71,9 @@ public class AllOf<T> extends Join<T> {
 
   @Override
   public String toString() {
-    return String.format("all of:<%s>", conditions);
+    List<Description> descriptions = conditions.stream()
+                                               .map(Condition::description)
+                                               .collect(toList());
+    return new JoinDescription("all of:[", "]", descriptions).value();
   }
 }
diff --git a/src/main/java/org/assertj/core/condition/AnyOf.java b/src/main/java/org/assertj/core/condition/AnyOf.java
index 2477ccaf0..80eb4140d 100644
--- a/src/main/java/org/assertj/core/condition/AnyOf.java
+++ b/src/main/java/org/assertj/core/condition/AnyOf.java
@@ -12,12 +12,18 @@
  */
 package org.assertj.core.condition;
 
+import static java.util.stream.Collectors.toList;
+
+import java.util.List;
+
 import org.assertj.core.api.Condition;
+import org.assertj.core.description.Description;
+import org.assertj.core.description.JoinDescription;
 
 /**
  * Returns {@code true} if any of the joined conditions is satisfied.
  * @param <T> the type of object this condition accepts.
- * 
+ *
  * @author Yvonne Wang
  * @author Mikhail Mazursky
  */
@@ -25,7 +31,7 @@ public class AnyOf<T> extends Join<T> {
 
   /**
    * Creates a new <code>{@link AnyOf}</code>
-   * 
+   *
    * @param <T> the type of object the given condition accept.
    * @param conditions the conditions to evaluate.
    * @return the created {@code AnyOf}.
@@ -66,6 +72,9 @@ public class AnyOf<T> extends Join<T> {
 
   @Override
   public String toString() {
-    return String.format("any of:<%s>", conditions);
+    List<Description> descriptions = conditions.stream()
+                                               .map(Condition::description)
+                                               .collect(toList());
+    return new JoinDescription("any of:[", "]", descriptions).value();
   }
 }
diff --git a/src/main/java/org/assertj/core/description/JoinDescription.java b/src/main/java/org/assertj/core/description/JoinDescription.java
new file mode 100644
index 000000000..87bf968fa
--- /dev/null
+++ b/src/main/java/org/assertj/core/description/JoinDescription.java
@@ -0,0 +1,196 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.description;
+
+import static java.util.Objects.requireNonNull;
+import static java.util.stream.Collectors.toList;
+import static org.assertj.core.util.Objects.HASH_CODE_PRIME;
+import static org.assertj.core.util.Objects.areEqual;
+import static org.assertj.core.util.Objects.hashCodeFor;
+
+import java.util.Collection;
+import java.util.Iterator;
+
+import org.assertj.core.util.Preconditions;
+import org.assertj.core.util.VisibleForTesting;
+
+/**
+ * The {@code Description} combining multiple {@code Description}s. It'll honor the nested descriptions and will indent
+ * them as appropriate.
+ *
+ * @author Edgar Asatryan
+ * @author Joel Costigliola
+ */
+public class JoinDescription extends Description {
+  private static final int DEFAULT_INDENTATION = 3;
+  private static final String LINE_SEPARATOR = System.lineSeparator();
+  /**
+   * Delimiter string between {@code descriptions}.
+   */
+  private static final String DELIMITER = ',' + LINE_SEPARATOR;
+
+  @VisibleForTesting
+  final Collection<Description> descriptions;
+  @VisibleForTesting
+  final String prefix;
+  @VisibleForTesting
+  final String suffix;
+
+  /**
+   * Creates a new <code>{@link JoinDescription}</code>.
+   *
+   * @param prefix       The beginning part of this description.
+   * @param suffix       The ending part of this description.
+   * @param descriptions The descriptions to combine.
+   *
+   * @throws NullPointerException if the given prefix is {@code null}.
+   * @throws NullPointerException if the given suffix is {@code null}.
+   * @throws NullPointerException if the given descriptions contains {@code null} elements or descriptions itself is
+   *                              {@code null}.
+   */
+  public JoinDescription(String prefix, String suffix, Collection<Description> descriptions) {
+    this.prefix = requireNonNull(prefix);
+    this.suffix = requireNonNull(suffix);
+    this.descriptions = requireNonNull(descriptions).stream()
+                                                    .map(JoinDescription::checkNotNull)
+                                                    .collect(toList());
+  }
+
+  private static Description checkNotNull(Description description) {
+    Preconditions.checkNotNull(description, "The descriptions should not contain null elements");
+    return description;
+  }
+
+  @Override
+  public String value() {
+    IndentedAppendable indentableBuilder = new IndentedAppendable(new StringBuilder());
+    return appendIndentedValueTo(indentableBuilder).toString();
+  }
+
+  @Override
+  public int hashCode() {
+    return HASH_CODE_PRIME + hashCodeFor(prefix) + hashCodeFor(suffix) + hashCodeFor(descriptions);
+  }
+
+  @Override
+  public boolean equals(Object o) {
+    if (this == o) return true;
+    if (!(o instanceof JoinDescription)) return false;
+    JoinDescription that = (JoinDescription) o;
+    return areEqual(descriptions, that.descriptions) &&
+           areEqual(prefix, that.prefix) &&
+           areEqual(suffix, that.suffix);
+  }
+
+  private IndentedAppendable appendIndentedValueTo(IndentedAppendable indentableBuilder) {
+    // indent and begin adding the current description starting with prefix
+    indentableBuilder.indent().append(prefix);
+
+    // special case where there is no descriptions
+    if (descriptions.isEmpty()) return indentableBuilder.append(suffix); // no line sep
+
+    // descriptions section
+    indentableBuilder.append(LINE_SEPARATOR);
+    // increase indention to write nested conditions
+    indentableBuilder.changeIndentationBy(DEFAULT_INDENTATION);
+    Iterator<? extends Description> it = descriptions.iterator();
+    while (it.hasNext()) {
+      Description description = it.next();
+      if (description instanceof JoinDescription) {
+        JoinDescription joinDescription = (JoinDescription) description;
+        joinDescription.appendIndentedValueTo(indentableBuilder);
+      } else {
+        // we indent according to the current indentation and then we append the value
+        indentableBuilder.indent().append(description.value());
+      }
+      // avoid the trailing delimiter
+      if (it.hasNext()) indentableBuilder.append(DELIMITER);
+    }
+
+    // suffix section
+    return indentableBuilder.append(LINE_SEPARATOR)
+                            .indentBy(-DEFAULT_INDENTATION) // back indention to align with prefix
+                            .append(suffix);
+  }
+
+  /**
+   * The wrapper for {@code StringBuilder} aware of indentation.
+   */
+  private static class IndentedAppendable implements Appendable {
+    private final StringBuilder stringBuilder;
+    private int currentIndentation;
+
+    IndentedAppendable(StringBuilder stringBuilder) {
+      this.stringBuilder = stringBuilder;
+      this.currentIndentation = 0;
+    }
+
+    @Override
+    public IndentedAppendable append(CharSequence charSequence) {
+      stringBuilder.append(charSequence);
+      return this;
+    }
+
+    @Override
+    public IndentedAppendable append(CharSequence charSequence, int start, int end) {
+      stringBuilder.append(charSequence, start, end);
+      return this;
+    }
+
+    @Override
+    public IndentedAppendable append(char c) {
+      stringBuilder.append(c);
+      return this;
+    }
+
+    /**
+     * Adjusts the indentation size by {@code indentation}.
+     *
+     * @param indentation The indentation adjustment.
+     *
+     * @return a this instance.
+     */
+    IndentedAppendable changeIndentationBy(int indentation) {
+      this.currentIndentation += indentation;
+      return this;
+    }
+
+    /**
+     * Appends the indentation according to current size.
+     *
+     * @return a this instance.
+     */
+    IndentedAppendable indent() {
+      for (int i = 0; i < currentIndentation; i++) {
+        stringBuilder.append(' ');
+      }
+      return this;
+    }
+
+    /**
+     * Shortcut method from {@link #changeIndentationBy(int)} and {@link #indent()}
+     *
+     * @param indentation The indentation adjustment.
+     *
+     * @return a this instance.
+     */
+    IndentedAppendable indentBy(int indentation) {
+      return changeIndentationBy(indentation).indent();
+    }
+
+    @Override
+    public String toString() {
+      return stringBuilder.toString();
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/condition/AllOf_toString_Test.java b/src/test/java/org/assertj/core/condition/AllOf_toString_Test.java
index b74bb2bb4..58995ee5b 100644
--- a/src/test/java/org/assertj/core/condition/AllOf_toString_Test.java
+++ b/src/test/java/org/assertj/core/condition/AllOf_toString_Test.java
@@ -12,34 +12,31 @@
  */
 package org.assertj.core.condition;
 
+import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.condition.AllOf.allOf;
 
 import org.assertj.core.api.Condition;
 import org.assertj.core.api.TestCondition;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 /**
  * Tests for <code>{@link AllOf#toString()}</code>.
- * 
+ *
  * @author Yvonne Wang
  */
 public class AllOf_toString_Test {
-  private TestCondition<Object> condition1;
-  private TestCondition<Object> condition2;
-  private Condition<Object> allOf;
-
-  @BeforeEach
-  public void setUp() {
-    condition1 = new TestCondition<>("Condition 1");
-    condition2 = new TestCondition<>("Condition 2");
-    allOf = allOf(condition1, condition2);
-  }
 
   @Test
   public void should_implement_toString_showing_descriptions_of_inner_Conditions() {
-    String expected = "all of:<[Condition 1, Condition 2]>";
-    assertThat(allOf).hasToString(expected);
+    // GIVEN
+    TestCondition<Object> condition1 = new TestCondition<>("Condition 1");
+    TestCondition<Object> condition2 = new TestCondition<>("Condition 2");
+    Condition<Object> allOf = allOf(condition1, condition2);
+    // THEN
+    assertThat(allOf).hasToString(format("all of:[%n" +
+                                         "   Condition 1,%n" +
+                                         "   Condition 2%n" +
+                                         "]"));
   }
 }
diff --git a/src/test/java/org/assertj/core/condition/AnyOf_toString_Test.java b/src/test/java/org/assertj/core/condition/AnyOf_toString_Test.java
index e1c7883c2..6198cba1d 100644
--- a/src/test/java/org/assertj/core/condition/AnyOf_toString_Test.java
+++ b/src/test/java/org/assertj/core/condition/AnyOf_toString_Test.java
@@ -12,34 +12,31 @@
  */
 package org.assertj.core.condition;
 
-import static org.assertj.core.api.Assertions.assertThat;
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.condition.AnyOf.anyOf;
 
 import org.assertj.core.api.Condition;
 import org.assertj.core.api.TestCondition;
-import org.junit.jupiter.api.BeforeEach;
 import org.junit.jupiter.api.Test;
 
 /**
  * Tests for <code>{@link AnyOf#toString()}</code>.
- * 
+ *
  * @author Yvonne Wang
  */
 public class AnyOf_toString_Test {
-  private TestCondition<Object> condition1;
-  private TestCondition<Object> condition2;
-  private Condition<Object> anyOf;
-
-  @BeforeEach
-  public void setUp() {
-    condition1 = new TestCondition<>("Condition 1");
-    condition2 = new TestCondition<>("Condition 2");
-    anyOf = anyOf(condition1, condition2);
-  }
 
   @Test
   public void should_implement_toString_showing_descriptions_of_inner_Conditions() {
-    String expected = "any of:<[Condition 1, Condition 2]>";
-    assertThat(anyOf).hasToString(expected);
+    // GIVEN
+    TestCondition<Object> condition1 = new TestCondition<>("Condition 1");
+    TestCondition<Object> condition2 = new TestCondition<>("Condition 2");
+    Condition<Object> anyOf = anyOf(condition1, condition2);
+    // THEN
+    then(anyOf).hasToString(format("any of:[%n" +
+                                   "   Condition 1,%n" +
+                                   "   Condition 2%n" +
+                                   "]"));
   }
 }
diff --git a/src/test/java/org/assertj/core/description/JoinDescription_constructor_Test.java b/src/test/java/org/assertj/core/description/JoinDescription_constructor_Test.java
new file mode 100644
index 000000000..a3c391d60
--- /dev/null
+++ b/src/test/java/org/assertj/core/description/JoinDescription_constructor_Test.java
@@ -0,0 +1,59 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.description;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatNullPointerException;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.Collection;
+import java.util.List;
+
+import org.assertj.core.internal.TestDescription;
+import org.junit.jupiter.api.DisplayNameGeneration;
+import org.junit.jupiter.api.DisplayNameGenerator;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for {@link JoinDescription#JoinDescription(String, String, Collection)}.
+ *
+ * @author Edgar Asatryan
+ */
+@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
+class JoinDescription_constructor_Test {
+
+  @Test
+  void should_set_values() {
+    // GIVEN
+    String prefix = "a";
+    String suffix = "b";
+    Collection<Description> descriptions = list(new TestDescription("1"), new TestDescription("2"));
+    JoinDescription desc = new JoinDescription(prefix, suffix, descriptions);
+    // THEN
+    assertThat(desc.prefix).isEqualTo(prefix);
+    assertThat(desc.suffix).isEqualTo(suffix);
+    assertThat(desc.descriptions).isEqualTo(descriptions);
+  }
+
+  @Test
+  void should_throw_when_descriptions_contains_null() {
+    // GIVEN
+    List<Description> descriptions = list(new TestDescription("1"),
+                                          new TestDescription("2"),
+                                          null,
+                                          new TestDescription("3"));
+    // THEN
+    assertThatNullPointerException().isThrownBy(() -> new JoinDescription("a", "b", descriptions))
+                                    .withMessage("The descriptions should not contain null elements");
+  }
+}
diff --git a/src/test/java/org/assertj/core/description/JoinDescription_value_Test.java b/src/test/java/org/assertj/core/description/JoinDescription_value_Test.java
new file mode 100644
index 000000000..4a8e4f0a2
--- /dev/null
+++ b/src/test/java/org/assertj/core/description/JoinDescription_value_Test.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2019 the original author or authors.
+ */
+package org.assertj.core.description;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.util.Lists.list;
+
+import org.assertj.core.internal.TestDescription;
+import org.junit.jupiter.api.DisplayNameGeneration;
+import org.junit.jupiter.api.DisplayNameGenerator;
+import org.junit.jupiter.api.Test;
+
+/**
+ * Tests for {@link JoinDescription#value()}.
+ *
+ * @author Edgar Asatryan
+ */
+@DisplayNameGeneration(DisplayNameGenerator.ReplaceUnderscores.class)
+class JoinDescription_value_Test {
+
+  @Test
+  void should_not_use_newline_when_empty() {
+    // GIVEN
+    JoinDescription joinDescription = allOf(); // with no descriptions
+    // WHEN
+    String actual = joinDescription.value();
+    // THEN
+    assertThat(actual).isEqualTo("all of:[]");
+  }
+
+  @Test
+  void should_use_new_line_when_non_empty() {
+    // GIVEN
+    JoinDescription joinDescription = allOf(description("1"), description("2"));
+    // WHEN
+    String actual = joinDescription.value();
+    // THEN
+    assertThat(actual).isEqualTo(format("all of:[%n" +
+                                        "   1,%n" +
+                                        "   2%n" +
+                                        "]"));
+  }
+
+  @Test
+  void should_indent_nested_join_descriptions() {
+    // GIVEN
+    JoinDescription joinDescription = allOf(description("1"),
+                                            anyOf(allOf(description("2"),
+                                                        anyOf(description("3a"), description("3b"))),
+                                                  description("4"),
+                                                  description("5")));
+    // WHEN
+    String actual = joinDescription.value();
+    // THEN
+    assertThat(actual).isEqualTo(format("all of:[%n" +
+                                        "   1,%n" +
+                                        "   any of:[%n" +
+                                        "      all of:[%n" +
+                                        "         2,%n" +
+                                        "         any of:[%n" +
+                                        "            3a,%n" +
+                                        "            3b%n" +
+                                        "         ]%n" +
+                                        "      ],%n" +
+                                        "      4,%n" +
+                                        "      5%n" +
+                                        "   ]%n" +
+                                        "]"));
+  }
+
+  private static Description description(String desc) {
+    return new TestDescription(desc);
+  }
+
+  private static JoinDescription allOf(Description... descriptions) {
+    return new JoinDescription("all of:[", "]", list(descriptions));
+  }
+
+  private static JoinDescription anyOf(Description... descriptions) {
+    return new JoinDescription("any of:[", "]", list(descriptions));
+  }
+}
