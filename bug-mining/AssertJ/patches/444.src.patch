diff --git a/src/main/java/org/assertj/core/api/AbstractAssert.java b/src/main/java/org/assertj/core/api/AbstractAssert.java
index 4916d9cf3..bf0bd0f0c 100644
--- a/src/main/java/org/assertj/core/api/AbstractAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractAssert.java
@@ -1110,9 +1110,7 @@ public abstract class AbstractAssert<SELF extends AbstractAssert<SELF, ACTUAL>,
                                                                        AssertFactory<T, ASSERT> assertFactory) {
     requireNonNull(extractor, shouldNotBeNull("extractor")::create);
     requireNonNull(assertFactory, shouldNotBeNull("assertFactory")::create);
-    if (actual == null) {
-      throwAssertionError(shouldNotBeNull());
-    }
+    if (actual == null) throwAssertionError(shouldNotBeNull());
     T extractedValue = extractor.apply(actual);
     return (ASSERT) assertFactory.createAssert(extractedValue).withAssertionState(myself);
   }
diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index bd7ac1e4a..8585f5755 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -18,6 +18,7 @@ import static java.util.stream.StreamSupport.stream;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.filter.Filters.filter;
 import static org.assertj.core.description.Description.mostRelevantDescription;
+import static org.assertj.core.error.ShouldNotBeNull.shouldNotBeNull;
 import static org.assertj.core.extractor.Extractors.byName;
 import static org.assertj.core.extractor.Extractors.extractedDescriptionOf;
 import static org.assertj.core.extractor.Extractors.extractedDescriptionOfMethod;
@@ -1391,6 +1392,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   }
 
   private <V> AbstractListAssert<?, List<? extends V>, V, ObjectAssert<V>> internalExtracting(Function<? super ELEMENT, V> extractor) {
+    if (actual == null) throwAssertionError(shouldNotBeNull());
     List<V> values = FieldsOrPropertiesExtractor.extract(actual, extractor);
     return newListAssertInstanceForMethodsChangingElementType(values);
   }
@@ -1949,12 +1951,12 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   // The public method for it (the one not ending with "ForProxy") is marked as final and annotated with @SafeVarargs
   // in order to avoid compiler warning in user code
   protected AbstractListAssert<?, List<? extends Tuple>, Tuple, ObjectAssert<Tuple>> extractingForProxy(Function<? super ELEMENT, ?>[] extractors) {
+    if (actual == null) throwAssertionError(shouldNotBeNull());
     // combine all extractors into one function
     Function<ELEMENT, Tuple> tupleExtractor = objectToExtractValueFrom -> new Tuple(Stream.of(extractors)
                                                                                           .map(extractor -> extractor.apply(objectToExtractValueFrom))
                                                                                           .toArray());
-    List<Tuple> tuples = stream(actual.spliterator(), false).map(tupleExtractor)
-                                                            .collect(toList());
+    List<Tuple> tuples = stream(actual.spliterator(), false).map(tupleExtractor).collect(toList());
     return newListAssertInstanceForMethodsChangingElementType(tuples);
   }
 
@@ -3796,7 +3798,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     iterables.assertAnySatisfy(info, actual, requirements);
     return myself;
   }
-  
+
   /**
    * {@inheritDoc}
    */
@@ -3817,7 +3819,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     iterables.assertNoneSatisfy(info, actual, restrictions);
     return myself;
   }
-  
+
   /**
    * {@inheritDoc}
    */
@@ -3835,7 +3837,7 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
   public final SELF satisfiesExactly(ThrowingConsumer<? super ELEMENT>... requirements) {
     return satisfiesExactlyForProxy(requirements);
   }
-  
+
   // This method is protected in order to be proxied for SoftAssertions / Assumptions.
   // The public method for it (the one not ending with "ForProxy") is marked as final and annotated with @SafeVarargs
   // in order to avoid compiler warning in user code
diff --git a/src/test/java/org/assertj/core/api/GroupAssertTestHelper.java b/src/test/java/org/assertj/core/api/GroupAssertTestHelper.java
index aae43823c..688e80fb4 100644
--- a/src/test/java/org/assertj/core/api/GroupAssertTestHelper.java
+++ b/src/test/java/org/assertj/core/api/GroupAssertTestHelper.java
@@ -37,5 +37,6 @@ public class GroupAssertTestHelper {
   public static final Function<Employee, String> lastNameFunction = employee -> employee.name.getLast();
   public static final Function<Employee, String> firstNameFunction = employee -> employee.name.first;
   public static final ThrowingExtractor<Employee, String, Exception> throwingFirstNameExtractor = employee -> employee.name.first;
+  public static final ThrowingExtractor<Employee, String, Exception> throwingLastNameExtractor = employee -> employee.name.getLast();
 
 }
diff --git a/src/test/java/org/assertj/core/api/abstract_/AbstractAssert_extracting_with_Function_and_AssertFactory_Test.java b/src/test/java/org/assertj/core/api/abstract_/AbstractAssert_extracting_with_Function_and_AssertFactory_Test.java
index 9f2e7cec4..03cf4bc36 100644
--- a/src/test/java/org/assertj/core/api/abstract_/AbstractAssert_extracting_with_Function_and_AssertFactory_Test.java
+++ b/src/test/java/org/assertj/core/api/abstract_/AbstractAssert_extracting_with_Function_and_AssertFactory_Test.java
@@ -19,6 +19,7 @@ import static org.assertj.core.api.InstanceOfAssertFactories.CHAR_SEQUENCE;
 import static org.assertj.core.api.InstanceOfAssertFactories.INTEGER;
 import static org.assertj.core.error.ShouldNotBeNull.shouldNotBeNull;
 import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
 
 import java.util.function.Function;
 
@@ -125,7 +126,7 @@ class AbstractAssert_extracting_with_Function_and_AssertFactory_Test implements
     // WHEN
     AssertionError assertionError = expectAssertionError(() -> assertThatObject(actual).extracting(Object::getClass));
     // THEN
-    then(assertionError).hasMessageContaining(shouldNotBeNull().create());
+    then(assertionError).hasMessage(actualIsNull());
   }
 
   @Override
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
index b589c7fd7..a25e194ea 100644
--- a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_Test.java
@@ -16,12 +16,12 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.assertThatExceptionOfType;
 import static org.assertj.core.api.Assertions.assertThatThrownBy;
 import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithNamesOf;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorForElementFieldsWithTypeOf;
 import static org.assertj.core.api.GroupAssertTestHelper.comparatorsByTypeOf;
 import static org.assertj.core.api.GroupAssertTestHelper.firstNameFunction;
 import static org.assertj.core.api.GroupAssertTestHelper.lastNameFunction;
-import static org.assertj.core.api.GroupAssertTestHelper.throwingFirstNameExtractor;
 import static org.assertj.core.data.TolkienCharacter.Race.DWARF;
 import static org.assertj.core.data.TolkienCharacter.Race.ELF;
 import static org.assertj.core.data.TolkienCharacter.Race.HOBBIT;
@@ -32,6 +32,8 @@ import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRES
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TIMESTAMP;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Lists.newArrayList;
 
 import java.sql.Timestamp;
@@ -74,14 +76,6 @@ class IterableAssert_extracting_Test {
 
   private static final Function<Employee, Integer> age = Employee::getAge;
 
-  private static final ThrowingExtractor<Employee, Object, Exception> throwingExtractor = new ThrowingExtractor<Employee, Object, Exception>() {
-    @Override
-    public Object extractThrows(Employee employee) throws Exception {
-      if (employee.getAge() < 20) throw new Exception("age < 20");
-      return employee.getName().getFirst();
-    }
-  };
-
   @BeforeEach
   void setUp() {
     yoda = new Employee(1L, new Name("Yoda"), 800);
@@ -131,6 +125,27 @@ class IterableAssert_extracting_Test {
                      .containsOnly(null, new Name("Luke", "Skywalker"));
   }
 
+  @Test
+  void should_throw_assertion_error_if_actual_is_null() {
+    // GIVEN
+    jedis = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(jedis).extracting(firstNameFunction));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_throw_assertion_error_if_actual_is_null_when_passing_multiple_functions() {
+    // GIVEN
+    List<TolkienCharacter> elves = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(elves).extracting(TolkienCharacter::getName,
+                                                                                            TolkienCharacter::getRace));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
   @Test
   void should_allow_assertions_on_field_values_extracted_from_given_iterable() {
     assertThat(jedis).extracting("id")
@@ -170,15 +185,17 @@ class IterableAssert_extracting_Test {
 
   @Test
   void should_allow_assertions_on_multiple_extracted_values_from_given_iterable() {
-    assertThat(jedis).extracting("name.first", "age", "id").containsOnly(tuple("Yoda", 800, 1L),
-                                                                         tuple("Luke", 26, 2L));
+    assertThat(jedis).extracting("name.first", "age", "id")
+                     .containsOnly(tuple("Yoda", 800, 1L),
+                                   tuple("Luke", 26, 2L));
   }
 
   @Test
   void should_throw_error_if_one_property_or_field_can_not_be_extracted() {
     assertThatExceptionOfType(IntrospectionError.class).isThrownBy(() -> {
       assertThat(jedis).extracting("unknown", "age", "id")
-                       .containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+                       .containsOnly(tuple("Yoda", 800, 1L),
+                                     tuple("Luke", 26, 2L));
     });
   }
 
@@ -204,53 +221,8 @@ class IterableAssert_extracting_Test {
 
   @Test
   void should_allow_assertions_on_extractor_assertions_extracted_from_given_array() {
-    assertThat(jedis).extracting(input -> input.getName().getFirst()).containsOnly("Yoda", "Luke");
-  }
-
-  @Test
-  void should_rethrow_throwing_extractor_checked_exception_as_a_runtime_exception() {
-    assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> assertThat(jedis).extracting(employee -> {
-      if (employee.getAge() > 100) throw new Exception("age > 100");
-      return employee.getName().getFirst();
-    })).withMessage("java.lang.Exception: age > 100");
-  }
-
-  @Test
-  void should_let_throwing_extractor_runtime_exception_bubble_up() {
-    assertThatExceptionOfType(RuntimeException.class).isThrownBy(() -> assertThat(jedis).extracting(employee -> {
-      if (employee.getAge() > 100) throw new RuntimeException("age > 100");
-      return employee.getName().getFirst();
-    })).withMessage("age > 100");
-  }
-
-  @Test
-  void should_allow_extracting_with_throwing_extractor() {
-    assertThat(jedis).extracting(employee -> {
-      if (employee.getAge() < 20) throw new Exception("age < 20");
-      return employee.getName().getFirst();
-    }).containsOnly("Yoda", "Luke");
-  }
-
-  @Test
-  void should_allow_extracting_with_anonymous_class_throwing_extractor() {
-    assertThat(jedis).extracting(new ThrowingExtractor<Employee, Object, Exception>() {
-      @Override
-      public Object extractThrows(Employee employee) throws Exception {
-        if (employee.getAge() < 20) throw new Exception("age < 20");
-        return employee.getName().getFirst();
-      }
-    }).containsOnly("Yoda", "Luke");
-  }
-
-  @SuppressWarnings("deprecation")
-  @Test
-  void should_allow_extracting_multiple_values_using_extractor() {
-    assertThat(jedis).extracting(new Extractor<Employee, Tuple>() {
-      @Override
-      public Tuple extract(Employee input) {
-        return new Tuple(input.getName().getFirst(), input.getAge(), input.id);
-      }
-    }).containsOnly(tuple("Yoda", 800, 1L), tuple("Luke", 26, 2L));
+    assertThat(jedis).extracting(input -> input.getName().getFirst())
+                     .containsOnly("Yoda", "Luke");
   }
 
   @Test
@@ -378,17 +350,22 @@ class IterableAssert_extracting_Test {
 
   @Test
   void should_use_property_field_names_as_description_when_extracting_simple_value_list() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(jedis).extracting("name.first").isEmpty()).withMessageContaining("[Extracted: name.first]");
+    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(jedis).extracting("name.first").isEmpty())
+                                                   .withMessageContaining("[Extracted: name.first]");
   }
 
   @Test
   void should_use_property_field_names_as_description_when_extracting_typed_simple_value_list() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(jedis).extracting("name.first", String.class).isEmpty()).withMessageContaining("[Extracted: name.first]");
+    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(jedis).extracting("name.first", String.class)
+                                                                                      .isEmpty())
+                                                   .withMessageContaining("[Extracted: name.first]");
   }
 
   @Test
   void should_use_property_field_names_as_description_when_extracting_tuples_list() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(jedis).extracting("name.first", "name.last").isEmpty()).withMessageContaining("[Extracted: name.first, name.last]");
+    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(jedis).extracting("name.first", "name.last")
+                                                                                      .isEmpty())
+                                                   .withMessageContaining("[Extracted: name.first, name.last]");
   }
 
   @Test
@@ -431,20 +408,13 @@ class IterableAssert_extracting_Test {
                                                    .withMessageContaining("[check employees first name]");
   }
 
-  @Test
-  void should_keep_existing_description_if_set_when_extracting_using_throwing_extractor() {
-    assertThatExceptionOfType(AssertionError.class).isThrownBy(() -> assertThat(jedis).as("expected exception")
-                                                                                      .extracting(throwingExtractor)
-                                                                                      .containsOnly("Luke"))
-                                                   .withMessageContaining("[expected exception]");
-  }
-
   @Test
   void should_extract_tuples_according_to_given_functions() {
     assertThat(jedis).extracting(firstNameFunction, lastNameFunction)
                      .contains(tuple("Yoda", null), tuple("Luke", "Skywalker"));
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void extracting_by_several_functions_should_keep_assertion_state() {
     // WHEN
@@ -468,6 +438,7 @@ class IterableAssert_extracting_Test {
     assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void extracting_by_name_should_keep_assertion_state() {
     // WHEN
@@ -491,6 +462,7 @@ class IterableAssert_extracting_Test {
     assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void extracting_by_strongly_typed_name_should_keep_assertion_state() {
     // WHEN
@@ -514,6 +486,7 @@ class IterableAssert_extracting_Test {
     assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void extracting_by_multiple_names_should_keep_assertion_state() {
     // WHEN
@@ -537,6 +510,7 @@ class IterableAssert_extracting_Test {
     assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void extracting_by_single_extractor_should_keep_assertion_state() {
     // WHEN
@@ -560,27 +534,4 @@ class IterableAssert_extracting_Test {
     assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
   }
 
-  @Test
-  void extracting_by_throwing_extractor_should_keep_assertion_state() {
-    // WHEN
-    // not all comparators are used but we want to test that they are passed correctly after extracting
-    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
-                                                                .withFailMessage("error message")
-                                                                .withRepresentation(UNICODE_REPRESENTATION)
-                                                                .usingComparatorForElementFieldsWithNames(ALWAY_EQUALS_STRING,
-                                                                                                          "foo")
-                                                                .usingComparatorForElementFieldsWithType(ALWAY_EQUALS_TIMESTAMP,
-                                                                                                         Timestamp.class)
-                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
-                                                                .extracting(throwingFirstNameExtractor)
-                                                                .contains("YODA", "Luke");
-    // THEN
-    assertThat(assertion.descriptionText()).isEqualTo("test description");
-    assertThat(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
-    assertThat(assertion.info.overridingErrorMessage()).isEqualTo("error message");
-    assertThat(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
-    assertThat(comparatorForElementFieldsWithTypeOf(assertion).get(Timestamp.class)).isSameAs(ALWAY_EQUALS_TIMESTAMP);
-    assertThat(comparatorForElementFieldsWithNamesOf(assertion).get("foo")).isSameAs(ALWAY_EQUALS_STRING);
-  }
-
 }
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_with_throwing_extractor_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_with_throwing_extractor_Test.java
new file mode 100644
index 000000000..53404ff71
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_extracting_with_throwing_extractor_Test.java
@@ -0,0 +1,157 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.catchThrowableOfType;
+import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.api.GroupAssertTestHelper.comparatorsByTypeOf;
+import static org.assertj.core.api.GroupAssertTestHelper.throwingFirstNameExtractor;
+import static org.assertj.core.api.GroupAssertTestHelper.throwingLastNameExtractor;
+import static org.assertj.core.presentation.UnicodeRepresentation.UNICODE_REPRESENTATION;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_STRING;
+import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Lists.list;
+
+import org.assertj.core.api.AbstractListAssert;
+import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.assertj.core.groups.Tuple;
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.Name;
+import org.junit.jupiter.api.Test;
+
+class IterableAssert_extracting_with_throwing_extractor_Test {
+
+  private Iterable<Employee> jedis = list(new Employee(1L, new Name("Yoda"), 800),
+                                          new Employee(2L, new Name("Luke", "Skywalker"), 26));
+
+  private static final ThrowingExtractor<Employee, Object, Exception> throwingExtractor = new ThrowingExtractor<Employee, Object, Exception>() {
+    @Override
+    public Object extractThrows(Employee employee) throws Exception {
+      if (employee.getAge() < 20) throw new Exception("age < 20");
+      return employee.getName().getFirst();
+    }
+  };
+
+  @Test
+  void should_extract_tuples_according_to_given_throwing_extractor() {
+    assertThat(jedis).extracting(throwingFirstNameExtractor)
+                     .contains("Yoda", "Luke");
+  }
+
+  @Test
+  void should_extract_tuples_according_to_given_throwing_extractors() {
+    assertThat(jedis).extracting(throwingFirstNameExtractor, throwingLastNameExtractor)
+                     .contains(tuple("Yoda", null), tuple("Luke", "Skywalker"));
+  }
+
+  @Test
+  void should_allow_extracting_with_anonymous_class_throwing_extractor() {
+    // GIVEN
+    ThrowingExtractor<Employee, Object, Exception> nameThrowingExtractor = new ThrowingExtractor<Employee, Object, Exception>() {
+      @Override
+      public Object extractThrows(Employee employee) throws Exception {
+        if (employee.getAge() < 20) throw new Exception("age < 20");
+        return employee.getName().getFirst();
+      }
+    };
+    // WHEN/THEN
+    then(jedis).extracting(nameThrowingExtractor).containsOnly("Yoda", "Luke");
+  }
+
+  @Test
+  void should_throw_assertion_error_if_actual_is_null() {
+    // GIVEN
+    jedis = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(jedis).extracting(throwingFirstNameExtractor));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_rethrow_throwing_extractor_checked_exception_as_a_runtime_exception() {
+    // GIVEN
+    ThrowingCallable code = () -> assertThat(jedis).extracting(employee -> {
+      if (employee.getAge() > 100) throw new Exception("age > 100");
+      return employee.getName().getFirst();
+    });
+    // WHEN
+    RuntimeException runtimeException = catchThrowableOfType(code, RuntimeException.class);
+    // THEN
+    then(runtimeException).hasMessage("java.lang.Exception: age > 100");
+  }
+
+  @Test
+  void should_let_throwing_extractor_runtime_exception_bubble_up() {
+    // GIVEN
+    ThrowingCallable code = () -> assertThat(jedis).extracting(employee -> {
+      if (employee.getAge() > 100) throw new RuntimeException("age > 100");
+      return employee.getName().getFirst();
+    });
+    // WHEN
+    RuntimeException runtimeException = catchThrowableOfType(code, RuntimeException.class);
+    // THEN
+    then(runtimeException).hasMessage("age > 100");
+  }
+
+  @Test
+  void should_keep_existing_description_if_set_when_extracting_using_throwing_extractor() {
+    // GIVEN
+    String description = "expected exception";
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(jedis).as(description)
+                                                                                .extracting(throwingExtractor)
+                                                                                .containsOnly("Luke"));
+    // THEN
+    then(assertionError).hasMessageContaining(description);
+  }
+
+  @Test
+  void extracting_by_several_throwing_extractors_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForType(ALWAY_EQUALS_TUPLE, Tuple.class)
+                                                                .extracting(throwingFirstNameExtractor, throwingLastNameExtractor)
+                                                                .contains(tuple("YODA", null), tuple("Luke", "Skywalker"));
+    // THEN
+    then(assertion.descriptionText()).isEqualTo("test description");
+    then(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    then(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    then(comparatorsByTypeOf(assertion).get(Tuple.class)).isSameAs(ALWAY_EQUALS_TUPLE);
+  }
+
+  @Test
+  void extracting_by_throwing_extractor_should_keep_assertion_state() {
+    // WHEN
+    // not all comparators are used but we want to test that they are passed correctly after extracting
+    AbstractListAssert<?, ?, ?, ?> assertion = assertThat(jedis).as("test description")
+                                                                .withFailMessage("error message")
+                                                                .withRepresentation(UNICODE_REPRESENTATION)
+                                                                .usingComparatorForType(ALWAY_EQUALS_STRING, String.class)
+                                                                .extracting(throwingFirstNameExtractor)
+                                                                .contains("YODA", "Luke");
+    // THEN
+    then(assertion.descriptionText()).isEqualTo("test description");
+    then(assertion.info.representation()).isEqualTo(UNICODE_REPRESENTATION);
+    then(assertion.info.overridingErrorMessage()).isEqualTo("error message");
+    then(comparatorsByTypeOf(assertion).get(String.class)).isSameAs(ALWAY_EQUALS_STRING);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_map_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_map_Test.java
new file mode 100644
index 000000000..baf1c7491
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_map_Test.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.TolkienCharacter.Race.HOBBIT;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.data.TolkienCharacter;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public class IterableAssert_map_Test {
+
+  private final List<TolkienCharacter> hobbits = new ArrayList<>();
+
+  @BeforeEach
+  void setUp() {
+    hobbits.add(TolkienCharacter.of("Frodo", 33, HOBBIT));
+    hobbits.add(TolkienCharacter.of("Sam", 38, HOBBIT));
+    hobbits.add(TolkienCharacter.of("Pippin", 28, HOBBIT));
+  }
+
+  @Test
+  void should_allow_assertions_on_values_extracted_by_given_using_function() {
+    then(hobbits).map(TolkienCharacter::getName)
+                 .containsExactly("Frodo", "Sam", "Pippin");
+  }
+
+  @Test
+  void should_allow_assertions_on_tuple_values_extracted_by_given_throwing_extractors() {
+    then(hobbits).map(TolkienCharacter::getName, TolkienCharacter::getRace)
+                 .containsExactly(tuple("Frodo", HOBBIT),
+                                  tuple("Sam", HOBBIT),
+                                  tuple("Pippin", HOBBIT));
+  }
+
+  @Test
+  void should_throw_assertion_error_if_actual_is_null() {
+    // GIVEN
+    List<TolkienCharacter> elves = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(elves).map(TolkienCharacter::getName));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_throw_assertion_error_if_actual_is_null_when_passing_multiple_functions() {
+    // GIVEN
+    List<TolkienCharacter> elves = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(elves).map(TolkienCharacter::getName,
+                                                                                     TolkienCharacter::getRace));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_map_with_throwing_extractor_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_map_with_throwing_extractor_Test.java
new file mode 100644
index 000000000..c175af5df
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_map_with_throwing_extractor_Test.java
@@ -0,0 +1,78 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.tuple;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.data.TolkienCharacter.Race.HOBBIT;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.assertj.core.data.TolkienCharacter;
+import org.assertj.core.data.TolkienCharacter.Race;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public class IterableAssert_map_with_throwing_extractor_Test {
+
+  private final List<TolkienCharacter> hobbits = new ArrayList<>();
+  private final ThrowingExtractor<TolkienCharacter, String, Exception> nameThrowingExtractor = TolkienCharacter::getName;
+  private final ThrowingExtractor<TolkienCharacter, Race, Exception> raceThrowingExtractor = TolkienCharacter::getRace;
+
+  @BeforeEach
+  void setUp() {
+    hobbits.add(TolkienCharacter.of("Frodo", 33, HOBBIT));
+    hobbits.add(TolkienCharacter.of("Sam", 38, HOBBIT));
+    hobbits.add(TolkienCharacter.of("Pippin", 28, HOBBIT));
+  }
+
+  @Test
+  void should_allow_assertions_on_values_extracted_by_throwing_extractor() {
+    then(hobbits).map(nameThrowingExtractor)
+                 .containsExactly("Frodo", "Sam", "Pippin");
+  }
+
+  @Test
+  void should_allow_assertions_on_tuple_values_extracted_by_given_throwing_extractors() {
+    then(hobbits).map(nameThrowingExtractor, raceThrowingExtractor)
+                 .containsExactly(tuple("Frodo", HOBBIT), 
+                                  tuple("Sam", HOBBIT), 
+                                  tuple("Pippin", HOBBIT));
+  }
+
+  @Test
+  void should_throw_assertion_error_if_actual_is_null() {
+    // GIVEN
+    List<TolkienCharacter> elves = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(elves).map(nameThrowingExtractor));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_throw_assertion_error_if_actual_is_null_when_passing_multiple_throwing_extractors() {
+    // GIVEN
+    List<TolkienCharacter> elves = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(elves).map(nameThrowingExtractor,
+                                                                                     raceThrowingExtractor));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+}
