diff --git a/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java b/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
index 0c7afb984..c4da6d6d7 100644
--- a/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractCompletableFutureAssert.java
@@ -28,9 +28,13 @@ import static org.assertj.core.error.future.ShouldNotHaveFailed.shouldNotHaveFai
 
 import java.time.Duration;
 import java.util.Objects;
+import java.util.concurrent.CancellationException;
 import java.util.concurrent.CompletableFuture;
 import java.util.concurrent.CompletionException;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.TimeoutException;
 import java.util.function.Predicate;
 
 import org.assertj.core.internal.Failures;
@@ -55,7 +59,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
-   * Verifies that the {@link CompletableFuture} is done i.e. completed normally, exceptionally, or via cancellation.
+   * Verifies that the {@link CompletableFuture} is {@link CompletableFuture#isDone() done} i.e. completed normally, exceptionally, or via cancellation.
    * <p>
    * Assertion will pass :
    * <pre><code class='java'> assertThat(CompletableFuture.completedFuture("something")).isDone();</code></pre>
@@ -93,10 +97,9 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
-   * Verifies that the {@link CompletableFuture} is completed exceptionally.
-   * Possible causes include cancellation, explicit invocation of completeExceptionally, and abrupt termination of a CompletionStage action.
+   * Verifies that the {@link CompletableFuture} is {@link CompletableFuture#isCompletedExceptionally() completed exceptionally}.
    * <p>
-   * If you only want to check that actual future is completed exceptionally but not cancelled, use {@link #hasFailed()} or {@link #hasFailedWithThrowableThat()}.
+   * Possible causes include cancellation, explicit invocation of completeExceptionally, and abrupt termination of a CompletionStage action.
    * <p>
    * Assertion will pass :
    * <pre><code class='java'> CompletableFuture future = new CompletableFuture();
@@ -138,7 +141,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
-   * Verifies that the {@link CompletableFuture} is cancelled.
+   * Verifies that the {@link CompletableFuture} is {@link CompletableFuture#isCancelled() cancelled}.
    * <p>
    * Assertion will pass :
    * <pre><code class='java'> CompletableFuture future = new CompletableFuture();
@@ -181,7 +184,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
 
   /**
    * Verifies that the {@link CompletableFuture} is completed normally (i.e.{@link CompletableFuture#isDone() done} but not
-   * {@link CompletableFuture#isCompletedExceptionally() completed exceptionally}) or {@link CompletableFuture#isCancelled() cancelled}).
+   * {@link CompletableFuture#isCompletedExceptionally() completed exceptionally}) or {@link CompletableFuture#isCancelled() cancelled}.
    * <p>
    * Assertion will pass :
    * <pre><code class='java'> assertThat(CompletableFuture.completedFuture("something")).isCompleted();</code></pre>
@@ -292,6 +295,17 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
+   * @deprecated
+   * <p>
+   * Combine isCompletedExceptionally with isNotCancelled instead:
+   *
+   * <pre><code class='java'> assertThat(future).isCompletedExceptionally()
+   *                   .isNotCancelled();</code></pre>
+   *
+   * This assertion is deprecated to change the semantics of failed to correspond to {@link CompletableFuture#get()} failing.
+   * <p>
+   * <b>Original javadoc</b>
+   * <p>
    * Verifies that the {@link CompletableFuture} has completed exceptionally but has not been cancelled,
    * this assertion is equivalent to:
    * <pre><code class='java'> assertThat(future).isCompletedExceptionally()
@@ -309,6 +323,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
    *
    * @return this assertion object.
    */
+  @Deprecated
   public SELF hasFailed() {
     isNotNull();
     if (!(actual.isCompletedExceptionally() && !actual.isCancelled())) throwAssertionError(shouldHaveFailed(actual));
@@ -316,6 +331,16 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
+   * @deprecated
+   * <p>
+   * Use matches with the following combination instead:
+   *
+   * <pre><code class='java'> assertThat(future).matches (f -&gt; f.isCompletedExceptionally() {@literal &&} !f.isCancelled());</code></pre>
+   *
+   * This assertion is deprecated because its semantic is not obvious.
+   * <p>
+   * <b>Original javadoc</b>
+   * <p>
    * Verifies that the {@link CompletableFuture} has not failed i.e: incomplete, completed or cancelled.<br>
    * This is different from {@link #isNotCompletedExceptionally()} as a cancelled future has not failed but is completed exceptionally.
    * <p>
@@ -331,6 +356,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
    *
    * @return this assertion object.
    */
+  @Deprecated
   public SELF hasNotFailed() {
     isNotNull();
     if (actual.isCompletedExceptionally() && !actual.isCancelled()) throwAssertionError(shouldNotHaveFailed(actual));
@@ -476,6 +502,22 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
   }
 
   /**
+   * @deprecated
+   * <p>
+   * Although not 100% the same, consider using {@link #failsWithin(Duration)} or {@link #failsWithin(long, TimeUnit)} instead:
+   *
+   * <pre><code class='java'> CompletableFuture future = new CompletableFuture();
+   * future.completeExceptionally(new RuntimeException("boom!"));
+   *
+   * assertThat(future).failsWithin(1, TimeUnit.SECONDS)
+   *                   .withThrowableOfType(RuntimeException.class)
+   *                   .withMessage("boom!"); </code></pre>
+   *
+   * This assertion is deprecated because it relies on {@link #hasFailed()} semantics which we want to move away from (they
+   * are not clear!) and to use failure semantics corresponding to {@link CompletableFuture#get()} failing.
+   * <p>
+   * <b>Original javadoc</b>
+   * <p>
    * Verifies that the {@link CompletableFuture} has completed exceptionally and
    * returns a Throwable assertion object allowing to check the Throwable that has caused the future to fail.
    * <p>
@@ -495,6 +537,7 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
    *
    * @return an exception assertion object.
    */
+  @Deprecated
   public AbstractThrowableAssert<?, ? extends Throwable> hasFailedWithThrowableThat() {
     hasFailed();
     try {
@@ -504,4 +547,84 @@ public abstract class AbstractCompletableFutureAssert<SELF extends AbstractCompl
       return assertThat(e.getCause());
     }
   }
+
+  /**
+   * Checks that the future does not complete within the given time (by calling {@link Future#get(long, TimeUnit)}) and returns
+   * the exception that caused the failure for further (exception) assertions, the exception can be any of
+   * {@link InterruptedException}, {@link ExecutionException}, {@link TimeoutException} or {@link CancellationException}.
+   * <p>
+   * <b>WARNING</b>
+   * <p>
+   * {@code failsWithin} does not fully integrate with soft assertions, if the future completes the test will fail immediately (the
+   * error is not collected as a soft assertion error), if the assertion succeeds the chained assertions are executed and any
+   * errors will be collected as a soft assertion errors.<br>
+   * The rationale is that if we collect {@code failsWithin} error as a soft assertion error, the chained assertions would be
+   * executed but that does not make sense since there is no exception to check as the future has completed.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> CompletableFuture&lt;?&gt; future = futureCompletingAfterMs(100);
+   *
+   * // assertion succeeds as the future is not completed after 50ms
+   * assertThat(future).failsWithin(Duration.ofMillis(50))
+   *                   .withThrowableOfType(TimeoutException.class)
+   *                   .withMessage(null);
+   *
+   * // fails as the future is completed after within 200ms
+   * assertThat(future).failsWithin(Duration.ofMillis(200));</code></pre>
+   *
+   * @param timeout the maximum time to wait
+   * @return a new assertion instance on the the future's exception.
+   * @throws AssertionError if the actual {@code CompletableFuture} is {@code null}.
+   * @throws AssertionError if the actual {@code CompletableFuture} succeeds within the given timeout.
+   * @since 3.18.0
+   */
+  public WithThrowable failsWithin(Duration timeout) {
+    return internalFailsWithin(timeout);
+  }
+
+  /**
+   * Checks that the future does not complete within the given time (by calling {@link Future#get(long, TimeUnit)}) and returns
+   * the exception that caused the failure for further (exception) assertions, the exception can be any of
+   * {@link InterruptedException}, {@link ExecutionException}, {@link TimeoutException} or {@link CancellationException}.
+   * <p>
+   * <b>WARNING</b>
+   * <p>
+   * {@code failsWithin} does not fully integrate with soft assertions, if the future completes the test will fail immediately (the
+   * error is not collected as a soft assertion error), if the assertion succeeds the chained assertions are executed and any
+   * errors will be collected as a soft assertion errors.<br>
+   * The rationale is that if we collect {@code failsWithin} error as a soft assertion error, the chained assertions would be
+   * executed but that does not make sense since there is no exception to check as the future has completed.
+   * <p>
+   * Examples:
+   * <pre><code class='java'> CompletableFuture&lt;?&gt; future = futureCompletingAfterMs(100);
+   *
+   * // assertion succeeds as the future is not completed after 50ms
+   * assertThat(future).failsWithin(50, TimeUnit.MILLISECONDS)
+   *                   .withThrowableOfType(TimeoutException.class)
+   *                   .withMessage(null);
+   *
+   * // fails as the future is completed after within 200ms
+   * assertThat(future).failsWithin(200, TimeUnit.MILLISECONDS);</code></pre>
+   *
+   * @param timeout the maximum time to wait
+   * @param unit the time unit
+   * @return a new assertion instance on the the future's exception.
+   * @throws AssertionError if the actual {@code CompletableFuture} is {@code null}.
+   * @throws AssertionError if the actual {@code CompletableFuture} succeeds within the given timeout.
+   * @since 3.18.0
+   */
+  public WithThrowable failsWithin(long timeout, TimeUnit unit) {
+    return internalFailsWithin(timeout, unit);
+  }
+
+  private WithThrowable internalFailsWithin(Duration timeout) {
+    Exception exception = futures.assertFailedWithin(info, actual, timeout);
+    return new WithThrowable(exception);
+  }
+
+  private WithThrowable internalFailsWithin(long timeout, TimeUnit unit) {
+    Exception exception = futures.assertFailedWithin(info, actual, timeout, unit);
+    return new WithThrowable(exception);
+  }
+
 }
diff --git a/src/test/java/org/assertj/core/api/BDDSoftAssertions_future_Test.java b/src/test/java/org/assertj/core/api/BDDSoftAssertions_future_Test.java
index 983781ed8..273dc3494 100644
--- a/src/test/java/org/assertj/core/api/BDDSoftAssertions_future_Test.java
+++ b/src/test/java/org/assertj/core/api/BDDSoftAssertions_future_Test.java
@@ -41,6 +41,7 @@ class BDDSoftAssertions_future_Test extends BaseAssertionsTest {
     softly = new BDDSoftAssertions();
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void should_work_with_CompletionStage() {
     // GIVEN
@@ -176,6 +177,28 @@ class BDDSoftAssertions_future_Test extends BaseAssertionsTest {
     then(assertionError).hasMessageContaining("to have failed within 0.01S.");
   }
 
+  @Test
+  void should_not_collect_AssertionError_from_CompletableFuture_failsWithin() {
+    // GIVEN
+    CompletableFuture<String> future = completedFuture("done");
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> softly.then(future).failsWithin(10, MILLISECONDS));
+    // THEN
+    then(softly.errorsCollected()).isEmpty();
+    then(assertionError).hasMessageContaining("to have failed within 10L MILLISECONDS.");
+  }
+
+  @Test
+  void should_not_collect_AssertionError_from_CompletableFuture_failsWithin_Duration() {
+    // GIVEN
+    CompletableFuture<String> future = completedFuture("done");
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> softly.then(future).failsWithin(TEN_MILLIS));
+    // THEN
+    then(softly.errorsCollected()).isEmpty();
+    then(assertionError).hasMessageContaining("to have failed within 0.01S.");
+  }
+
   @Test
   void should_only_collect_error_from_chained_assertions_performed_after_CompletableFuture_succeedsWithin() {
     // GIVEN
diff --git a/src/test/java/org/assertj/core/api/SoftAssertions_future_Test.java b/src/test/java/org/assertj/core/api/SoftAssertions_future_Test.java
index 87c3ad2a2..09ed340cc 100644
--- a/src/test/java/org/assertj/core/api/SoftAssertions_future_Test.java
+++ b/src/test/java/org/assertj/core/api/SoftAssertions_future_Test.java
@@ -42,6 +42,7 @@ class SoftAssertions_future_Test extends BaseAssertionsTest {
     softly = new SoftAssertions();
   }
 
+  @SuppressWarnings("deprecation")
   @Test
   void should_work_with_CompletionStage() {
     // GIVEN
@@ -177,6 +178,28 @@ class SoftAssertions_future_Test extends BaseAssertionsTest {
     then(assertionError).hasMessageContaining("to have failed within 0.01S.");
   }
 
+  @Test
+  void should_not_collect_AssertionError_from_CompletableFuture_failsWithin() {
+    // GIVEN
+    CompletableFuture<String> future = completedFuture("done");
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> softly.assertThat(future).failsWithin(10, MILLISECONDS));
+    // THEN
+    then(softly.errorsCollected()).isEmpty();
+    then(assertionError).hasMessageContaining("to have failed within 10L MILLISECONDS.");
+  }
+
+  @Test
+  void should_not_collect_AssertionError_from_CompletableFuture_failsWithin_Duration() {
+    // GIVEN
+    CompletableFuture<String> future = completedFuture("done");
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> softly.assertThat(future).failsWithin(TEN_MILLIS));
+    // THEN
+    then(softly.errorsCollected()).isEmpty();
+    then(assertionError).hasMessageContaining("to have failed within 0.01S.");
+  }
+
   @Test
   void should_only_collect_error_from_chained_assertions_performed_after_CompletableFuture_succeedsWithin() {
     // GIVEN
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_failsWithin_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_failsWithin_Test.java
new file mode 100644
index 000000000..3d9a5a433
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_failsWithin_Test.java
@@ -0,0 +1,127 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.future;
+
+import static java.util.concurrent.TimeUnit.MILLISECONDS;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+
+import java.time.Duration;
+import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.ExecutionException;
+import java.util.concurrent.TimeoutException;
+
+import org.junit.jupiter.api.DisplayName;
+import org.junit.jupiter.api.Test;
+
+@DisplayName("FutureAssert failsWithin")
+class CompletableFutureAssert_failsWithin_Test {
+
+  private static final Duration ONE_SECOND = Duration.ofSeconds(1);
+
+  @Test
+  void should_pass_when_future_does_not_complete_within_timeout_Duration() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND);
+    // WHEN/THEN
+    assertThat(future).failsWithin(Duration.ofMillis(50));
+  }
+
+  @Test
+  void should_pass_when_future_does_not_complete_within_timeout() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND);
+    // WHEN/THEN
+    assertThat(future).failsWithin(50, MILLISECONDS);
+  }
+
+  @Test
+  void should_allow_assertion_on_future_exception_when_future_did_not_complete_within_timeout_Duration() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND);
+    // WHEN/THEN
+    assertThat(future).failsWithin(Duration.ofMillis(50))
+                      .withThrowableOfType(TimeoutException.class)
+                      .withMessage(null);
+  }
+
+  @Test
+  void should_allow_assertion_on_future_exception_when_future_did_not_complete_within_timeout() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(ONE_SECOND);
+    // WHEN/THEN
+    assertThat(future).failsWithin(50, MILLISECONDS)
+                      .withThrowableOfType(TimeoutException.class)
+                      .withMessage(null);
+  }
+
+  @Test
+  void should_fail_if_future_completes_within_given_timeout() {
+    // GIVEN
+    CompletableFuture<Void> future = futureCompletingAfter(Duration.ofMillis(10));
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).failsWithin(50, MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessageContainingAll("Completed", "to have failed within 50L MILLISECONDS.");
+  }
+
+  @Test
+  void should_pass_if_future_is_cancelled() {
+    // GIVEN
+    CompletableFuture<Void> future = new CompletableFuture<>();
+    future.cancel(false);
+    // WHEN/THEN
+    then(future).failsWithin(1, MILLISECONDS);
+    then(future).failsWithin(Duration.ofMillis(1));
+  }
+
+  @Test
+  void should_pass_if_future_execution_fails() {
+    // GIVEN
+    CompletableFuture<Void> completableFuture = new CompletableFuture<>();
+    completableFuture.completeExceptionally(new RuntimeException("boom!"));
+    CompletableFuture<Void> future = completableFuture;
+    // WHEN/THEN
+    then(future).failsWithin(1, MILLISECONDS)
+                .withThrowableOfType(ExecutionException.class)
+                .withMessageContaining("boom!");
+    then(future).failsWithin(Duration.ofMillis(1))
+                .withThrowableOfType(ExecutionException.class)
+                .withMessageContaining("boom!");
+  }
+
+  @Test
+  void should_fail_when_future_is_null() {
+    // GIVEN
+    CompletableFuture<Void> future = null;
+    // WHEN
+    AssertionError assertionError = expectAssertionError(() -> assertThat(future).failsWithin(1, MILLISECONDS));
+    // THEN
+    then(assertionError).hasMessage(actualIsNull());
+  }
+
+  private static CompletableFuture<Void> futureCompletingAfter(Duration duration) {
+    return CompletableFuture.runAsync(() -> sleep(duration));
+  }
+
+  private static void sleep(Duration duration) {
+    try {
+      Thread.sleep(duration.toMillis());
+    } catch (@SuppressWarnings("unused") InterruptedException e) {
+      // do nothing
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasFailedWithThrowableThat_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasFailedWithThrowableThat_Test.java
index bd548ae32..2ad094121 100644
--- a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasFailedWithThrowableThat_Test.java
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasFailedWithThrowableThat_Test.java
@@ -24,6 +24,7 @@ import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
+@SuppressWarnings("deprecation")
 @DisplayName("CompletableFutureAssert hasFailedWithThrowableThat")
 class CompletableFutureAssert_hasFailedWithThrowableThat_Test {
 
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasFailed_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasFailed_Test.java
index e695af9dd..67a712529 100644
--- a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasFailed_Test.java
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasFailed_Test.java
@@ -12,6 +12,7 @@
  */
 package org.assertj.core.api.future;
 
+import static java.util.concurrent.CompletableFuture.completedFuture;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.future.ShouldHaveFailed.shouldHaveFailed;
 import static org.assertj.core.util.AssertionsUtil.assertThatAssertionErrorIsThrownBy;
@@ -23,6 +24,7 @@ import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
+@SuppressWarnings("deprecation")
 @DisplayName("CompletableFutureAssert hasFailed")
 class CompletableFutureAssert_hasFailed_Test {
 
@@ -59,7 +61,7 @@ class CompletableFutureAssert_hasFailed_Test {
   @Test
   void should_fail_if_completable_future_is_completed() {
     // GIVEN
-    CompletableFuture<String> future = CompletableFuture.completedFuture("done");
+    CompletableFuture<String> future = completedFuture("done");
     // WHEN
     ThrowingCallable code = () -> assertThat(future).hasFailed();
     // THEN
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasNotFailed_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasNotFailed_Test.java
index a6b64065e..70cc3b356 100644
--- a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasNotFailed_Test.java
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_hasNotFailed_Test.java
@@ -24,6 +24,7 @@ import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
 import org.junit.jupiter.api.DisplayName;
 import org.junit.jupiter.api.Test;
 
+@SuppressWarnings("deprecation")
 @DisplayName("CompletableFutureAssert hasNotFailed")
 class CompletableFutureAssert_hasNotFailed_Test {
 
diff --git a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompleted_Test.java b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompleted_Test.java
index d6d1eb2d9..80a6566ec 100644
--- a/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompleted_Test.java
+++ b/src/test/java/org/assertj/core/api/future/CompletableFutureAssert_isCompleted_Test.java
@@ -13,6 +13,7 @@
 package org.assertj.core.api.future;
 
 import static java.lang.String.format;
+import static java.util.concurrent.CompletableFuture.completedFuture;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.error.future.ShouldBeCompleted.shouldBeCompleted;
 import static org.assertj.core.error.future.Warning.WARNING;
@@ -31,7 +32,7 @@ class CompletableFutureAssert_isCompleted_Test {
   @Test
   void should_pass_if_completable_future_is_completed() {
     // GIVEN
-    CompletableFuture<String> future = CompletableFuture.completedFuture("done");
+    CompletableFuture<String> future = completedFuture("done");
     // THEN
     assertThat(future).isCompleted();
   }
diff --git a/src/test/java/org/assertj/core/error/future/ShouldHaveFailedWithin_create_Test.java b/src/test/java/org/assertj/core/error/future/ShouldHaveFailedWithin_create_Test.java
index b14551a64..2eeb327ba 100644
--- a/src/test/java/org/assertj/core/error/future/ShouldHaveFailedWithin_create_Test.java
+++ b/src/test/java/org/assertj/core/error/future/ShouldHaveFailedWithin_create_Test.java
@@ -13,12 +13,14 @@
 package org.assertj.core.error.future;
 
 import static java.lang.String.format;
+import static java.util.concurrent.CompletableFuture.completedFuture;
 import static org.assertj.core.api.BDDAssertions.then;
 import static org.assertj.core.error.future.ShouldHaveFailedWithin.shouldHaveFailedWithin;
 import static org.assertj.core.error.future.Warning.WARNING;
 
 import java.time.Duration;
 import java.util.concurrent.CompletableFuture;
+import java.util.concurrent.Future;
 import java.util.concurrent.TimeUnit;
 
 import org.assertj.core.internal.TestDescription;
@@ -28,20 +30,24 @@ class ShouldHaveFailedWithin_create_Test {
 
   @Test
   void should_create_error_message_with_duration() {
+    // GIVEN
+    CompletableFuture<Object> actual = completedFuture("ok");
     // WHEN
-    String error = shouldHaveFailedWithin(new CompletableFuture<>(), Duration.ofHours(1)).create(new TestDescription("TEST"));
+    String error = shouldHaveFailedWithin(actual, Duration.ofHours(1)).create(new TestDescription("TEST"));
     // THEN
     then(error).isEqualTo(format("[TEST] %n" +
                                  "Expecting%n" +
-                                 "  <CompletableFuture[Incomplete]>%n" +
+                                 "  <CompletableFuture[Completed: \"ok\"]>%n" +
                                  "to have failed within 1H.%n%s",
                                  WARNING));
   }
 
   @Test
   void should_create_error_message_with_time_unit() {
+    // GIVEN
+    Future<Object> actual = new CompletableFuture<>();
     // WHEN
-    String error = shouldHaveFailedWithin(new CompletableFuture<>(), 1, TimeUnit.HOURS).create(new TestDescription("TEST"));
+    String error = shouldHaveFailedWithin(actual, 1, TimeUnit.HOURS).create(new TestDescription("TEST"));
     // THEN
     then(error).isEqualTo(format("[TEST] %n" +
                                  "Expecting%n" +
