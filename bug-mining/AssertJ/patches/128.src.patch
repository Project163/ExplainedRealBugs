diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 8b65c6052..722a92095 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -12,11 +12,13 @@
  */
 package org.assertj.core.api;
 
+import static org.assertj.core.api.filter.Filters.filter;
 import static org.assertj.core.extractor.Extractors.byName;
 import static org.assertj.core.extractor.Extractors.resultOf;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Iterables.toArray;
 import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Preconditions.checkNotNull;
 
 import java.lang.reflect.Array;
 import java.util.Collection;
@@ -24,7 +26,10 @@ import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
 
+import org.assertj.core.api.filter.FilterOperator;
+import org.assertj.core.api.filter.Filters;
 import org.assertj.core.api.iterable.Extractor;
+import org.assertj.core.condition.Not;
 import org.assertj.core.groups.FieldsOrPropertiesExtractor;
 import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.CommonErrors;
@@ -1183,4 +1188,252 @@ public abstract class AbstractIterableAssert<S extends AbstractIterableAssert<S,
   public S inBinary() {
     return super.inBinary();
   }
+
+  /**
+   * Filter the iterable under test keeping only elements having a property or field equal to {@code expectedValue}, the
+   * property/field is specified by {@code propertyOrFieldName} parameter.
+   * <p>
+   * The filter first tries to get the value from a property (named {@code propertyOrFieldName}), if no such property
+   * exists it tries to read the value from a field. Reading private fields is supported by default, this can be
+   * globally disabled by calling {@link Assertions#setAllowExtractingPrivateFields(boolean)
+   * Assertions.setAllowExtractingPrivateFields(false)}.
+   * <p>
+   * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
+   * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
+   * <p>
+   * 
+   * As an example, let's check all employees 800 years old (yes, special employees):
+   * 
+   * <pre><code class='java'> 
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   *
+   * assertThat(employees).filterOn("age", 800)
+   *                      .containsOnly(yoda, obiwan);
+   * </code></pre>
+   * Nested properties/fields are supported:
+   * 
+   * <pre><code class='java'>
+   * // Name is bean class with 'first' and 'last' String properties 
+   *
+   * // name is null for noname => it does not match the filter on "name.first" 
+   * assertThat(employees).filterOn("name.first", "Luke")
+   *                      .containsOnly(luke);
+   * 
+   * assertThat(employees).filterOn("name.last", "Vader")
+   *                      .isEmpty();
+   * </code></pre>
+   * <p>
+   * If you want to filter on null value, use {@link #filteredOnNull(String)} as Java will resolve the call to
+   * {@link #filteredOn(String, FilterOperator)} instead of this method.
+   * <p>
+   * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the iterable
+   * elements.
+   * <p>
+   * You can chain filters:
+   * 
+   * <pre><code class='java'>
+   * // fellowshipOfTheRing is a list of TolkienCharacter having race and name fields
+   * // 'not' filter is statically imported from Assertions.not 
+   * 
+   * assertThat(fellowshipOfTheRing).filteredOn("race.name", "Man")
+   *                                .filteredOn("name", not("Boromir"))
+   *                                .containsOnly(aragorn);
+   * </code></pre>
+   * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
+   * filter to apply.
+   * 
+   * @param propertyOrFieldName the name of the property or field to read
+   * @param expectedValue the value to compare element's property or field with
+   * @return a new assertion object with the filtered iterable under test
+   * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null} or empty.
+   * @throws IntrospectionError if the given propertyOrFieldName can't be found in one of the iterable elements.
+   */
+  @SuppressWarnings("unchecked")
+  public S filteredOn(String propertyOrFieldName, Object expectedValue) {
+    Filters<? extends T> filter = filter((Iterable<? extends T>) actual);
+    Iterable<? extends T> filteredIterable = filter.with(propertyOrFieldName, expectedValue).get();
+    return (S) new ListAssert<>(newArrayList(filteredIterable));
+  }
+
+  /**
+   * Filter the iterable under test keeping only elements whose property or field specified by
+   * {@code propertyOrFieldName} is null.
+   * <p>
+   * The filter first tries to get the value from a property (named {@code propertyOrFieldName}), if no such property
+   * exists it tries to read the value from a field. Reading private fields is supported by default, this can be
+   * globally disabled by calling {@link Assertions#setAllowExtractingPrivateFields(boolean)
+   * Assertions.setAllowExtractingPrivateFields(false)}.
+   * <p>
+   * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
+   * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
+   * <p>
+   * As an example, let's check all employees 800 years old (yes, special employees):
+   * 
+   * <pre><code class='java'> 
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   *
+   * assertThat(employees).filterOnNull("name")
+   *                      .containsOnly(noname);
+   * </code></pre>
+   * Nested properties/fields are supported:
+   * 
+   * <pre><code class='java'>
+   * // Name is bean class with 'first' and 'last' String properties 
+   *
+   * assertThat(employees).filterOnNull("name.last")
+   *                      .containsOnly(yoda, obiwan, noname);
+   * </code></pre>
+   * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the iterable
+   * elements.
+   * <p>
+   * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
+   * filter to apply.
+   * 
+   * @param propertyOrFieldName the name of the property or field to read
+   * @return a new assertion object with the filtered iterable under test
+   * @throws IntrospectionError if the given propertyOrFieldName can't be found in one of the iterable elements.
+   */
+  public S filteredOnNull(String propertyOrFieldName) {
+    // need to cast nulll to Object otherwise it calls :
+    // filterOn(String propertyOrFieldName, FilterOperation<?> filterOperation)
+    return filteredOn(propertyOrFieldName, (Object) null);
+  }
+
+  /**
+   * Filter the iterable under test keeping only elements having a property or field matching the filter expressed with
+   * the {@link FilterOperator}, the property/field is specified by {@code propertyOrFieldName} parameter.
+   * <p>
+   * The existing filters are :
+   * <ul>
+   * <li> {@link Assertions#not(Object) not(Object)}</li>
+   * <li> {@link Assertions#in(Object...) in(Object...)}</li>
+   * <li> {@link Assertions#notIn(Object...) notIn(Object...)}</li>
+   * </ul>
+   * <p>
+   * Whatever filter is applied, it first tries to get the value from a property (named {@code propertyOrFieldName}), if
+   * no such property exists it tries to read the value from a field. Reading private fields is supported by default,
+   * this can be globally disabled by calling {@link Assertions#setAllowExtractingPrivateFields(boolean)
+   * Assertions.setAllowExtractingPrivateFields(false)}.
+   * <p>
+   * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
+   * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
+   * <p>
+   * 
+   * As an example, let's check stuff on some special employees :
+   * 
+   * <pre><code class='java'> 
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * 
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   *
+   * // 'not' filter is statically imported from Assertions.not 
+   * assertThat(employees).filterOn("age", not(800))
+   *                      .containsOnly(luke);
+   * 
+   * // 'in' filter is statically imported from Assertions.in
+   * // Name is bean class with 'first' and 'last' String properties 
+   * assertThat(employees).filterOn("name.first", in("Yoda", "Luke"))
+   *                      .containsOnly(yoda, luke);
+   * 
+   * // 'notIn' filter is statically imported from Assertions.notIn
+   * assertThat(employees).filterOn("name.first", notIn("Yoda", "Luke"))
+   *                      .containsOnly(obiwan);
+   * </code></pre>
+   * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the iterable
+   * elements.
+   * <p>
+   * Note that combining filter operators is not supported, thus the following code is not correct:
+   * 
+   * <pre><code class='java'>
+   * // Combining filter operators like not(in(800)) is NOT supported
+   * // -&gt; throws UnsupportedOperationException
+   * assertThat(employees).filterOn("age", not(in(800)))
+   *                      .contains(luke);
+   * </code></pre>
+   * <p>
+   * You can chain filters:
+   * 
+   * <pre><code class='java'>
+   * // fellowshipOfTheRing is a list of TolkienCharacter having race and name fields
+   * // 'not' filter is statically imported from Assertions.not 
+   * 
+   * assertThat(fellowshipOfTheRing).filteredOn("race.name", "Man")
+   *                                .filteredOn("name", not("Boromir"))
+   *                                .containsOnly(aragorn);
+   * </code></pre>
+   * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
+   * filter to apply.
+   * 
+   * @param propertyOrFieldName the name of the property or field to read
+   * @param filterOperator the filter operator to apply
+   * @return a new assertion object with the filtered iterable under test
+   * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null} or empty.
+   */
+  @SuppressWarnings("unchecked")
+  public S filteredOn(String propertyOrFieldName, FilterOperator<?> filterOperator) {
+    checkNotNull(filterOperator);
+    Filters<? extends T> filter = filter((Iterable<? extends T>) actual).with(propertyOrFieldName);
+    filterOperator.applyOn(filter);
+    return (S) new ListAssert<>(newArrayList(filter.get()));
+  }
+
+  /**
+   * Filter the iterable under test keeping only elements matching the given {@link Condition}.
+   * <p>
+   * Let's check old employees whose age > 100:
+   * 
+   * 
+   * 
+   * <pre><code class='java'> 
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   * 
+   * // old employee condition, "old employees" describes the condition in error message
+   * // you just have to implement 'matches' method 
+   * Condition&lt;Employee&gt; oldEmployees = new Condition&lt;Employee&gt;("old employees") {
+   *       {@literal @}Override
+   *       public boolean matches(Employee employee) {
+   *         return employee.getAge() > 100;
+   *       }
+   *     };
+   *   }
+   * assertThat(employees).filteredOn(oldEmployees)
+   *                      .containsOnly(yoda, obiwan);
+   *                      
+   * </code></pre>
+   * You can combine {@link Condition} with condition operator like {@link Not}:
+   * 
+   * <pre><code class='java'>
+   * // 'not' filter is statically imported from Assertions.not 
+   * assertThat(employees).filteredOn(not(oldEmployees))
+   *                      .contains(luke, noname);
+   * </code></pre>
+   * 
+   * @param condition the filter condition / predicate
+   * @return a new assertion object with the filtered iterable under test
+   * @throws IllegalArgumentException if the given condition is {@code null}.
+   */
+  @SuppressWarnings("unchecked")
+  public S filteredOn(Condition<? super T> condition) {
+    Filters<? extends T> filter = filter((Iterable<? extends T>) actual);
+    Iterable<? extends T> filteredIterable = filter.being(condition).get();
+    return (S) new ListAssert<>(newArrayList(filteredIterable));
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 837d9e6ce..e61474b76 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -12,11 +12,13 @@
  */
 package org.assertj.core.api;
 
+import static org.assertj.core.api.filter.Filters.filter;
 import static org.assertj.core.extractor.Extractors.byName;
 import static org.assertj.core.extractor.Extractors.resultOf;
 import static org.assertj.core.util.Arrays.isArray;
 import static org.assertj.core.util.Iterables.toArray;
 import static org.assertj.core.util.Lists.newArrayList;
+import static org.assertj.core.util.Preconditions.checkNotNull;
 
 import java.lang.reflect.Array;
 import java.util.Arrays;
@@ -25,7 +27,10 @@ import java.util.Comparator;
 import java.util.HashSet;
 import java.util.List;
 
+import org.assertj.core.api.filter.FilterOperator;
+import org.assertj.core.api.filter.Filters;
 import org.assertj.core.api.iterable.Extractor;
+import org.assertj.core.condition.Not;
 import org.assertj.core.data.Index;
 import org.assertj.core.groups.FieldsOrPropertiesExtractor;
 import org.assertj.core.groups.Tuple;
@@ -844,4 +849,249 @@ public abstract class AbstractObjectArrayAssert<S extends AbstractObjectArrayAss
   public S inBinary() {
     return super.inBinary();
   }
+
+  /**
+   * Filter the array under test keeping only elements having a property or field equal to {@code expectedValue}, the
+   * property/field is specified by {@code propertyOrFieldName} parameter.
+   * <p>
+   * The filter first tries to get the value from a property (named {@code propertyOrFieldName}), if no such property
+   * exists it tries to read the value from a field. Reading private fields is supported by default, this can be
+   * globally disabled by calling {@link Assertions#setAllowExtractingPrivateFields(boolean)
+   * Assertions.setAllowExtractingPrivateFields(false)}.
+   * <p>
+   * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
+   * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
+   * <p>
+   * 
+   * As an example, let's check all employees 800 years old (yes, special employees):
+   * 
+   * <pre><code class='java'> 
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
+   *
+   * assertThat(employees).filterOn("age", 800)
+   *                      .containsOnly(yoda, obiwan);
+   * </code></pre>
+   * Nested properties/fields are supported:
+   * 
+   * <pre><code class='java'>
+   * // Name is bean class with 'first' and 'last' String properties 
+   *
+   * // name is null for noname => it does not match the filter on "name.first" 
+   * assertThat(employees).filterOn("name.first", "Luke")
+   *                      .containsOnly(luke);
+   * 
+   * assertThat(employees).filterOn("name.last", "Vader")
+   *                      .isEmpty();
+   * </code></pre>
+   * <p>
+   * If you want to filter on null value, use {@link #filteredOnNull(String)} as Java will resolve the call to
+   * {@link #filteredOn(String, FilterOperator)} instead of this method.
+   * <p>
+   * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the array
+   * elements.
+   * <p>
+   * You can chain filters:
+   * 
+   * <pre><code class='java'>
+   * // fellowshipOfTheRing is an array of TolkienCharacter having race and name fields
+   * // 'not' filter is statically imported from Assertions.not 
+   * 
+   * assertThat(fellowshipOfTheRing).filteredOn("race.name", "Man")
+   *                                .filteredOn("name", not("Boromir"))
+   *                                .containsOnly(aragorn);
+   * </code></pre>
+   * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
+   * filter to apply.
+   * 
+   * @param propertyOrFieldName the name of the property or field to read
+   * @param expectedValue the value to compare element's property or field with
+   * @return a new assertion object with the filtered array under test
+   * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null} or empty.
+   * @throws IntrospectionError if the given propertyOrFieldName can't be found in one of the array elements.
+   */
+  @SuppressWarnings("unchecked")
+  public S filteredOn(String propertyOrFieldName, Object expectedValue) {
+    Iterable<? extends T> filteredIterable = filter(actual).with(propertyOrFieldName, expectedValue).get();
+    return (S) new ObjectArrayAssert<>(toArray(filteredIterable));
+  }
+
+  /**
+   * Filter the array under test keeping only elements whose property or field specified by {@code propertyOrFieldName}
+   * is null.
+   * <p>
+   * exists it tries to read the value from a field. Reading private fields is supported by default, this can be
+   * globally disabled by calling {@link Assertions#setAllowExtractingPrivateFields(boolean)
+   * Assertions.setAllowExtractingPrivateFields(false)}.
+   * <p>
+   * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
+   * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
+   * <p>
+   * As an example, let's check all employees 800 years old (yes, special employees):
+   * 
+   * <pre><code class='java'> 
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
+   *
+   * assertThat(employees).filterOnNull("name")
+   *                      .containsOnly(noname);
+   * </code></pre>
+   * Nested properties/fields are supported:
+   * 
+   * <pre><code class='java'>
+   * // Name is bean class with 'first' and 'last' String properties 
+   *
+   * assertThat(employees).filterOnNull("name.last")
+   *                      .containsOnly(yoda, obiwan, noname);
+   * </code></pre>
+   * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the array
+   * elements.
+   * <p>
+   * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
+   * filter to apply.
+   * 
+   * @param propertyOrFieldName the name of the property or field to read
+   * @return a new assertion object with the filtered array under test
+   * @throws IntrospectionError if the given propertyOrFieldName can't be found in one of the array elements.
+   */
+  public S filteredOnNull(String propertyOrFieldName) {
+    // need to cast nulll to Object otherwise it calls :
+    // filterOn(String propertyOrFieldName, FilterOperation<?> filterOperation)
+    return filteredOn(propertyOrFieldName, (Object) null);
+  }
+
+  /**
+   * Filter the array under test keeping only elements having a property or field matching the filter expressed with
+   * the {@link FilterOperator}, the property/field is specified by {@code propertyOrFieldName} parameter.
+   * <p>
+   * The existing filters are :
+   * <ul>
+   * <li> {@link Assertions#not(Object) not(Object)}</li>
+   * <li> {@link Assertions#in(Object...) in(Object...)}</li>
+   * <li> {@link Assertions#notIn(Object...) notIn(Object...)}</li>
+   * </ul>
+   * <p>
+   * Whatever filter is applied, it first tries to get the value from a property (named {@code propertyOrFieldName}), if
+   * no such property exists it tries to read the value from a field. Reading private fields is supported by default,
+   * this can be globally disabled by calling {@link Assertions#setAllowExtractingPrivateFields(boolean)
+   * Assertions.setAllowExtractingPrivateFields(false)}.
+   * <p>
+   * When reading <b>nested</b> property/field, if an intermediate value is null the whole nested property/field is
+   * considered to be null, thus reading "address.street.name" value will return null if "street" value is null.
+   * <p>
+   * 
+   * As an example, let's check stuff on some special employees :
+   * 
+   * <pre><code class='java'> 
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * 
+   * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
+   *
+   * // 'not' filter is statically imported from Assertions.not 
+   * assertThat(employees).filterOn("age", not(800))
+   *                      .containsOnly(luke);
+   * 
+   * // 'in' filter is statically imported from Assertions.in
+   * // Name is bean class with 'first' and 'last' String properties 
+   * assertThat(employees).filterOn("name.first", in("Yoda", "Luke"))
+   *                      .containsOnly(yoda, luke);
+   * 
+   * // 'notIn' filter is statically imported from Assertions.notIn
+   * assertThat(employees).filterOn("name.first", notIn("Yoda", "Luke"))
+   *                      .containsOnly(obiwan);
+   * </code></pre>
+   * An {@link IntrospectionError} is thrown if the given propertyOrFieldName can't be found in one of the array
+   * elements.
+   * <p>
+   * Note that combining filter operators is not supported, thus the following code is not correct:
+   * 
+   * <pre><code class='java'>
+   * // Combining filter operators like not(in(800)) is NOT supported
+   * // -&gt; throws UnsupportedOperationException
+   * assertThat(employees).filterOn("age", not(in(800)))
+   *                      .contains(luke);
+   * </code></pre>
+   * <p>
+   * You can chain filters:
+   * 
+   * <pre><code class='java'>
+   * // fellowshipOfTheRing is an array of TolkienCharacter having race and name fields
+   * // 'not' filter is statically imported from Assertions.not 
+   * 
+   * assertThat(fellowshipOfTheRing).filteredOn("race.name", "Man")
+   *                                .filteredOn("name", not("Boromir"))
+   *                                .containsOnly(aragorn);
+   * </code></pre>
+   * If you need more complex filter, use {@link #filteredOn(Condition)} and provide a {@link Condition} to specify the
+   * filter to apply.
+   * 
+   * @param propertyOrFieldName the name of the property or field to read
+   * @param filterOperator the filter operator to apply
+   * @return a new assertion object with the filtered array under test
+   * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null} or empty.
+   */
+  @SuppressWarnings("unchecked")
+  public S filteredOn(String propertyOrFieldName, FilterOperator<?> filterOperator) {
+    checkNotNull(filterOperator);
+    Filters<? extends T> filter = filter(actual).with(propertyOrFieldName);
+    filterOperator.applyOn(filter);
+    return (S) new ObjectArrayAssert<>(toArray(filter.get()));
+  }
+
+  /**
+   * Filter the array under test keeping only elements matching the given {@link Condition}.
+   * <p>
+   * Let's check old employees whose age > 100:
+   * 
+   * 
+   * 
+   * <pre><code class='java'> 
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * Employee[] employees = new Employee[] { yoda, luke, obiwan, noname };
+   * 
+   * // old employee condition, "old employees" describes the condition in error message
+   * // you just have to implement 'matches' method 
+   * Condition&lt;Employee&gt; oldEmployees = new Condition&lt;Employee&gt;("old employees") {
+   *       {@literal @}Override
+   *       public boolean matches(Employee employee) {
+   *         return employee.getAge() > 100;
+   *       }
+   *     };
+   *   }
+   * assertThat(employees).filteredOn(oldEmployees)
+   *                      .containsOnly(yoda, obiwan);
+   *                      
+   * </code></pre>
+   * You can combine {@link Condition} with condition operator like {@link Not}:
+   * 
+   * <pre><code class='java'>
+   * // 'not' filter is statically imported from Assertions.not 
+   * assertThat(employees).filteredOn(not(oldEmployees))
+   *                      .contains(luke, noname);
+   * </code></pre>
+   * 
+   * @param condition the filter condition / predicate
+   * @return a new assertion object with the filtered array under test
+   * @throws IllegalArgumentException if the given condition is {@code null}.
+   */
+  @SuppressWarnings("unchecked")
+  public S filteredOn(Condition<? super T> condition) {
+    Iterable<? extends T> filteredIterable = filter(actual).being(condition).get();
+    return (S) new ObjectArrayAssert<>(toArray(filteredIterable));
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/api/Assertions.java b/src/main/java/org/assertj/core/api/Assertions.java
index 99f8af124..7e279991d 100644
--- a/src/main/java/org/assertj/core/api/Assertions.java
+++ b/src/main/java/org/assertj/core/api/Assertions.java
@@ -27,7 +27,11 @@ import java.util.List;
 import java.util.Map;
 
 import org.assertj.core.api.ThrowableAssert.ThrowingCallable;
+import org.assertj.core.api.filter.FilterOperator;
 import org.assertj.core.api.filter.Filters;
+import org.assertj.core.api.filter.InFilter;
+import org.assertj.core.api.filter.NotFilter;
+import org.assertj.core.api.filter.NotInFilter;
 import org.assertj.core.condition.AllOf;
 import org.assertj.core.condition.AnyOf;
 import org.assertj.core.condition.DoesNotHave;
@@ -1114,6 +1118,84 @@ public class Assertions {
     return Filters.filter(iterableToFilter);
   }
 
+  /**
+   * Create a {@link FilterOperator} to use in {@link AbstractIterableAssert#filteredOn(String, FilterOperator)
+   * filterOn(String, FilterOperation)} to express a filter keeping all Iterable elements whose property/field
+   * value matches one of the given values.
+   * <p/>
+   * As often, an example helps:
+   * 
+   * <pre><code class='java'>
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   * 
+   * assertThat(employees).filterOn("age", in(800, 26))
+   *                      .containsOnly(yoda, obiwan, luke);
+   * </code></pre>
+   * 
+   * @param values values to match (one match is sufficient)
+   * @return the created "in" filter
+   */
+  public static InFilter in(Object... values) {
+    return InFilter.in(values);
+  }
+
+  /**
+   * Create a {@link FilterOperator} to use in {@link AbstractIterableAssert#filteredOn(String, FilterOperator)
+   * filterOn(String, FilterOperation)} to express a filter keeping all Iterable elements whose property/field
+   * value matches does not match any of the given values.
+   * <p/>
+   * As often, an example helps:
+   * 
+   * <pre><code class='java'>
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   * 
+   * assertThat(employees).filterOn("age", notIn(800, 50))
+   *                      .containsOnly(luke);
+   * </code></pre>
+   * 
+   * @param valuesNotToMatch values not to match (none of the values must match)
+   * @return the created "not in" filter
+   */
+  public static NotInFilter notIn(Object... valuesNotToMatch) {
+    return NotInFilter.notIn(valuesNotToMatch);
+  }
+
+  /**
+   * Create a {@link FilterOperator} to use in {@link AbstractIterableAssert#filteredOn(String, FilterOperator)
+   * filterOn(String, FilterOperation)} to express a filter keeping all Iterable elements whose property/field
+   * value matches does not match the given value.
+   * <p>
+   * As often, an example helps:
+   * 
+   * <pre><code class='java'>
+   * Employee yoda   = new Employee(1L, new Name("Yoda"), 800);
+   * Employee obiwan = new Employee(2L, new Name("Obiwan"), 800);
+   * Employee luke   = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+   * Employee noname = new Employee(4L, null, 50);
+   * 
+   * List&lt;Employee&gt; employees = newArrayList(yoda, luke, obiwan, noname);
+   * 
+   * assertThat(employees).filterOn("age", not(800))
+   *                      .containsOnly(luke, noname);
+   * </code></pre>
+   * 
+   * @param valueNotToMatch the value not to match
+   * @return the created "not" filter
+   */
+  public static NotFilter not(Object valueNotToMatch) {
+    return NotFilter.not(valueNotToMatch);
+  }
+
   // --------------------------------------------------------------------------------------------------
   // File methods : not assertions but here to have a single entry point to all AssertJ features.
   // --------------------------------------------------------------------------------------------------
diff --git a/src/main/java/org/assertj/core/api/IterableAssert.java b/src/main/java/org/assertj/core/api/IterableAssert.java
index 4525df301..bb4890d19 100644
--- a/src/main/java/org/assertj/core/api/IterableAssert.java
+++ b/src/main/java/org/assertj/core/api/IterableAssert.java
@@ -73,6 +73,7 @@ public class IterableAssert<T> extends AbstractIterableAssert<IterableAssert<T>,
       }
       return size;
     }
+
   }
 
   private static <T> Iterable<T> toIterable(Iterator<T> iterator) {
diff --git a/src/main/java/org/assertj/core/api/filter/FilterOperator.java b/src/main/java/org/assertj/core/api/filter/FilterOperator.java
new file mode 100644
index 000000000..1cc3a73ab
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/filter/FilterOperator.java
@@ -0,0 +1,28 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.filter;
+
+public abstract class FilterOperator<T> {
+
+  private static final String COMBINING_OPERATOR_IS_NOT_SUPPORTED = "Combining operator is not supported, but you can use Filters as in http://joel-costigliola.github.io/assertj/assertj-core-features-highlight.html#filters";
+  protected final T filterParameter;
+
+  protected FilterOperator(T filterValue) {
+    if (filterValue instanceof FilterOperator<?>)
+      throw new UnsupportedOperationException(COMBINING_OPERATOR_IS_NOT_SUPPORTED);
+    this.filterParameter = filterValue;
+  }
+
+  public abstract <E> Filters<E> applyOn(Filters<E> filters);
+
+}
diff --git a/src/main/java/org/assertj/core/api/filter/Filters.java b/src/main/java/org/assertj/core/api/filter/Filters.java
index a0046afc2..c05194514 100644
--- a/src/main/java/org/assertj/core/api/filter/Filters.java
+++ b/src/main/java/org/assertj/core/api/filter/Filters.java
@@ -16,22 +16,27 @@ import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.Objects.areEqual;
 
 import java.util.ArrayList;
-import java.util.Collections;
 import java.util.List;
 
+import org.assertj.core.api.Assertions;
 import org.assertj.core.api.Condition;
-import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.introspection.IntrospectionError;
-
+import org.assertj.core.util.introspection.PropertyOrFieldSupport;
 
 /**
  * Filters the elements of a given <code>{@link Iterable}</code> or array according to the specified filter criteria.
  * <p>
  * Filter criteria can be expressed either by a {@link Condition} or a pseudo filter language on elements properties.
  * <p>
- * Note that the given {@link Iterable} or array is not modified, the filters are performed on a copy.
- * <p>
+ * With fluent filter language on element properties/fields :
+ * 
+ * <pre><code class='java'>
+ * assertThat(filter(players).with("pointsPerGame").greaterThan(20)
+ *                           .and("assistsPerGame").greaterThan(7).get())
+ *                           .containsOnly(james, rose);</code></pre>
+ * </code></pre>
+ * 
  * With {@link Condition} :
  * 
  * <pre><code class='java'>
@@ -47,13 +52,6 @@ import org.assertj.core.util.introspection.IntrospectionError;
  * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose)
  * </code></pre>
  * 
- * With pseudo filter language on element properties :
- * 
- * <pre><code class='java'>
- * assertThat(filter(players).with("pointsPerGame").greaterThan(20)
- *                           .and("assistsPerGame").greaterThan(7)
- *                           .get()).containsOnly(james, rose);</code></pre>
- * 
  * @param <E> the type of element of group to filter.
  * 
  * @author Joel Costigliola
@@ -66,25 +64,35 @@ public class Filters<E> {
   final Iterable<E> initialIterable;
   Iterable<E> filteredIterable;
 
-  private final PropertySupport propertySupport = PropertySupport.instance();
+  private final PropertyOrFieldSupport propertyOrFieldSupport = PropertyOrFieldSupport.INSTANCE;
 
   /**
    * The name of the property used for filtering.
    */
-  private String propertyNameToFilterOn;
+  private String propertyOrFieldNameToFilterOn;
 
   /**
    * Creates a new <code>{@link Filters}</code> with the {@link Iterable} to filter.
    * <p>
-   * Chain this call to express filter criteria either by a {@link Condition} or a pseudo filter language on elements properties.
+   * Chain this call to express filter criteria either by a {@link Condition} or a pseudo filter language on elements
+   * properties or fields (reading private fields is supported but disabled by calling
+   * {@link Assertions#setAllowExtractingPrivateFields(boolean) Assertions.setAllowExtractingPrivateFields(false)}.
    * <p>
    * Note that the given {@link Iterable} is not modified, the filters are performed on a copy.
    * <p>
-   * - With {@link Condition} :
+   * With fluent filter language on element properties/fields :
    * 
    * <pre><code class='java'>
    * List&lt;Player&gt; players = ...; 
    *   
+   * assertThat(filter(players).with("pointsPerGame").greaterThan(20)
+   *                           .and("assistsPerGame").greaterThan(7).get())
+   *                           .containsOnly(james, rose);
+   * </code></pre>
+   * 
+   * With {@link Condition} :
+   * 
+   * <pre><code class='java'>
    * Condition&lt;Player&gt; potentialMVP = new Condition&lt;Player&gt;("is a possible MVP"){
    *   public boolean matches(Player player) {
    *     return player.getPointsPerGame() > 20 && player.getAssistsPerGame() > 7;
@@ -95,13 +103,6 @@ public class Filters<E> {
    * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose)
    * </code></pre>
    * 
-   * - With pseudo filter language on element properties :
-   * 
-   * <pre><code class='java'>
-   * assertThat(filter(players).with("pointsPerGame").greaterThan(20)
-   *                           .and("assistsPerGame").greaterThan(7).get())
-   *                           .containsOnly(james, rose);</code></pre>
-   * 
    * @param iterable the {@code Iterable} to filter.
    * @throws NullPointerException if the given iterable is {@code null}.
    * @return the created <code>{@link Filters}</code>.
@@ -114,15 +115,24 @@ public class Filters<E> {
   /**
    * Creates a new <code>{@link Filters}</code> with the array to filter.
    * <p>
-   * Chain this call to express filter criteria either by a {@link Condition} or a pseudo filter language on elements properties.
+   * Chain this call to express filter criteria either by a {@link Condition} or a pseudo filter language on elements
+   * properties.
    * <p>
    * Note that the given array is not modified, the filters are performed on an {@link Iterable} copy of the array.
    * <p>
    * With {@link Condition} :
    * 
    * <pre><code class='java'>
-   * List&lt;Player&gt; players = ...; 
+   * Player[] players = ...; 
    *   
+   * assertThat(filter(players).with("pointsPerGame").greaterThan(20)
+   *                           .and("assistsPerGame").greaterThan(7).get())
+   *                           .containsOnly(james, rose);
+   * </code></pre>
+   * 
+   * With {@link Condition} :
+   * 
+   * <pre><code class='java'>
    * Condition&lt;Player&gt; potentialMVP = new Condition&lt;Player&gt;("is a possible MVP"){
    *   public boolean matches(Player player) {
    *     return player.getPointsPerGame() > 20 && player.getAssistsPerGame() > 7;
@@ -130,15 +140,9 @@ public class Filters<E> {
    * };
    * 
    * // use filter static method to build Filters
-   * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose);
+   * assertThat(filter(players).being(potentialMVP).get()).containsOnly(james, rose)
    * </code></pre>
    * 
-   * With pseudo filter language on element properties :
-   * 
-   * <pre><code class='java'>
-   * assertThat(filter(players).with("pointsPerGame").greaterThan(20)
-   *                           .and("assistsPerGame").greaterThan(7)
-   *                           .get()).containsOnly(james, rose);</code></pre>
    * @param array the array to filter.
    * @throws NullPointerException if the given array is {@code null}.
    * @return the created <code>{@link Filters}</code>.
@@ -148,20 +152,14 @@ public class Filters<E> {
     return new Filters<>(array);
   }
 
-  @VisibleForTesting
-  Filters(Iterable<E> iterable) {
+  private Filters(Iterable<E> iterable) {
     this.initialIterable = iterable;
     // copy list to avoid modifying iterable
     this.filteredIterable = newArrayList(iterable);
   }
 
-  @VisibleForTesting
-  Filters(E[] array) {
-    List<E> iterable = new ArrayList<>(array.length);
-    Collections.addAll(iterable, array);
-    this.initialIterable = iterable;
-    // copy list to avoid modifying iterable
-    this.filteredIterable = newArrayList(iterable);
+  private Filters(E[] array) {
+    this(newArrayList(array));
   }
 
   /**
@@ -182,10 +180,10 @@ public class Filters<E> {
    * 
    * @param condition the filter {@link Condition}.
    * @return this {@link Filters} to chain other filter operations.
-   * @throws NullPointerException if the given condition is {@code null}.
+   * @throws IllegalArgumentException if the given condition is {@code null}.
    */
   public Filters<E> being(Condition<? super E> condition) {
-    if (condition == null) throw new NullPointerException("The filter condition should not be null");
+    if (condition == null) throw new IllegalArgumentException("The filter condition should not be null");
     return applyFilterCondition(condition);
   }
 
@@ -207,10 +205,10 @@ public class Filters<E> {
    * 
    * @param condition the filter {@link Condition}.
    * @return this {@link Filters} to chain other filter operations.
-   * @throws NullPointerException if the given condition is {@code null}.
+   * @throws IllegalArgumentException if the given condition is {@code null}.
    */
   public Filters<E> having(Condition<? super E> condition) {
-    if (condition == null) throw new NullPointerException("The filter condition should not be null");
+    if (condition == null) throw new IllegalArgumentException("The filter condition should not be null");
     return applyFilterCondition(condition);
   }
 
@@ -239,20 +237,23 @@ public class Filters<E> {
    * filter(employees).with("name").equalsTo("Alex").get();
    * </code></pre>
    * 
-   * @param propertyName the name of the property whose value will compared to given value. It may be a nested property.
+   * @param propertyOrFieldName the name of the property/field whose value will compared to given value. It may be a
+   *          nested property.
    * @param propertyValue the expected property value.
    * @return this {@link Filters} to chain other filter operations.
-   * @throws IntrospectionError if an element in the given {@code Iterable} does not have a property with a given propertyName.
-   * @throws NullPointerException if the given propertyName is {@code null}.
+   * @throws IntrospectionError if an element in the given {@code Iterable} does not have a property with a given
+   *           propertyOrFieldName.
+   * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null}.
    */
-  public Filters<E> with(String propertyName, Object propertyValue) {
-    if (propertyName == null) throw new NullPointerException("The property name to filter on should not be null");
-    propertyNameToFilterOn = propertyName;
+  public Filters<E> with(String propertyOrFieldName, Object propertyValue) {
+    validatePropertyOrFieldName(propertyOrFieldName);
+    propertyOrFieldNameToFilterOn = propertyOrFieldName;
     return equalsTo(propertyValue);
   }
 
   /**
-   * Sets the name of the property used for filtering, it may be a nested property like <code>"adress.street.name"</code>.
+   * Sets the name of the property used for filtering, it may be a nested property like
+   * <code>"adress.street.name"</code>.
    * <p>
    * The typical usage is to chain this call with a comparison method, for example :
    * 
@@ -260,16 +261,21 @@ public class Filters<E> {
    * filter(employees).with("name").equalsTo("Alex").get();
    * </code></pre>
    * 
-   * @param propertyName the name of the property used for filtering. It may be a nested property.
+   * @param propertyOrFieldName the name of the property/field used for filtering. It may be a nested property.
    * @return this {@link Filters} to chain other filter operation.
-   * @throws NullPointerException if the given propertyName is {@code null}.
+   * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null}.
    */
-  public Filters<E> with(String propertyName) {
-    if (propertyName == null) throw new NullPointerException("The property name to filter on should not be null");
-    propertyNameToFilterOn = propertyName;
+  public Filters<E> with(String propertyOrFieldName) {
+    validatePropertyOrFieldName(propertyOrFieldName);
+    propertyOrFieldNameToFilterOn = propertyOrFieldName;
     return this;
   }
 
+  private void validatePropertyOrFieldName(String propertyOrFieldName) {
+    if (propertyOrFieldName == null || propertyOrFieldName.isEmpty())
+      throw new IllegalArgumentException("The property/field name to filter on should not be null or empty");
+  }
+
   /**
    * Alias of {@link #with(String)} for synthetic sugar to write things like :.
    * 
@@ -277,16 +283,17 @@ public class Filters<E> {
    * filter(employees).with("name").equalsTo("Alex").and("job").notEqualsTo("lawyer").get();
    * </code></pre>
    * 
-   * @param propertyName the name of the property used for filtering. It may be a nested property.
+   * @param propertyOrFieldName the name of the property/field used for filtering. It may be a nested property.
    * @return this {@link Filters} to chain other filter operation.
-   * @throws NullPointerException if the given propertyName is {@code null}.
+   * @throws IllegalArgumentException if the given propertyOrFieldName is {@code null}.
    */
-  public Filters<E> and(String propertyName) {
-    return with(propertyName);
+  public Filters<E> and(String propertyOrFieldName) {
+    return with(propertyOrFieldName);
   }
 
   /**
-   * Filters the underlying iterable to keep object with property (specified by {@link #with(String)}) <b>equals to</b> given
+   * Filters the underlying iterable to keep object with property (specified by {@link #with(String)}) <b>equals to</b>
+   * given
    * value.
    * <p>
    * Typical usage :
@@ -297,25 +304,22 @@ public class Filters<E> {
    * 
    * @param propertyValue the filter value.
    * @return this {@link Filters} to chain other filter operation.
-   * @throws NullPointerException if the property name to filter on has not been set.
+   * @throws IllegalArgumentException if the property name to filter on has not been set.
    */
   public Filters<E> equalsTo(Object propertyValue) {
     checkPropertyNameToFilterOnIsNotNull();
     List<E> newFilteredIterable = new ArrayList<>();
     for (E element : filteredIterable) {
-      // As we don't know the propertyValue class, we use Object.class
-      Class<?> propertyValueClass = propertyValue == null ? Object.class : propertyValue.getClass();
-      Object propertyValueOfCurrentElement = propertySupport.propertyValueOf(propertyNameToFilterOn, propertyValueClass, element);
-      if (areEqual(propertyValueOfCurrentElement, propertyValue)) {
-        newFilteredIterable.add(element);
-      }
+      Object propertyValueOfCurrentElement = propertyOrFieldSupport.getValueOf(propertyOrFieldNameToFilterOn, element);
+      if (areEqual(propertyValueOfCurrentElement, propertyValue)) newFilteredIterable.add(element);
     }
     this.filteredIterable = newFilteredIterable;
     return this;
   }
 
   /**
-   * Filters the underlying iterable to keep object with property (specified by {@link #with(String)}) <b>not equals to</b> given
+   * Filters the underlying iterable to keep object with property (specified by {@link #with(String)}) <b>not equals
+   * to</b> given
    * value.
    * <p>
    * Typical usage :
@@ -326,29 +330,27 @@ public class Filters<E> {
    * 
    * @param propertyValue the filter value.
    * @return this {@link Filters} to chain other filter operation.
-   * @throws NullPointerException if the property name to filter on has not been set.
+   * @throws IllegalArgumentException if the property name to filter on has not been set.
    */
   public Filters<E> notEqualsTo(Object propertyValue) {
     checkPropertyNameToFilterOnIsNotNull();
     List<E> newFilteredIterable = new ArrayList<>();
     for (E element : filteredIterable) {
-      Object propertyValueOfCurrentElement = propertySupport.propertyValueOf(propertyNameToFilterOn, propertyValue.getClass(),
-          element);
-      if (!areEqual(propertyValueOfCurrentElement, propertyValue)) {
-        newFilteredIterable.add(element);
-      }
+      Object propertyValueOfCurrentElement = propertyOrFieldSupport.getValueOf(propertyOrFieldNameToFilterOn, element);
+      if (!areEqual(propertyValueOfCurrentElement, propertyValue)) newFilteredIterable.add(element);
     }
     this.filteredIterable = newFilteredIterable;
     return this;
   }
 
   private void checkPropertyNameToFilterOnIsNotNull() {
-    if (propertyNameToFilterOn == null)
-      throw new NullPointerException("The property name to filter on has not been set - no filtering is possible");
+    if (propertyOrFieldNameToFilterOn == null)
+      throw new IllegalArgumentException("The property name to filter on has not been set - no filtering is possible");
   }
 
   /**
-   * Filters the underlying iterable to keep object with property (specified by {@link #with(String)}) <b>equals to</b> one of the
+   * Filters the underlying iterable to keep object with property (specified by {@link #with(String)}) <b>equals to</b>
+   * one of the
    * given values.
    * <p>
    * Typical usage :
@@ -359,24 +361,22 @@ public class Filters<E> {
    * 
    * @param propertyValues the filter values.
    * @return this {@link Filters} to chain other filter operation.
-   * @throws NullPointerException if the property name to filter on has not been set.
+   * @throws IllegalArgumentException if the property name to filter on has not been set.
    */
   public Filters<E> in(Object... propertyValues) {
     checkPropertyNameToFilterOnIsNotNull();
     List<E> newFilteredIterable = new ArrayList<>();
     for (E element : filteredIterable) {
-      Object propertyValueOfCurrentElement = propertySupport.propertyValueOf(propertyNameToFilterOn, propertyValues.getClass()
-          .getComponentType(), element);
-      if (isItemInArray(propertyValueOfCurrentElement, propertyValues)) {
-        newFilteredIterable.add(element);
-      }
+      Object propertyValueOfCurrentElement = propertyOrFieldSupport.getValueOf(propertyOrFieldNameToFilterOn, element);
+      if (isItemInArray(propertyValueOfCurrentElement, propertyValues)) newFilteredIterable.add(element);
     }
     this.filteredIterable = newFilteredIterable;
     return this;
   }
 
   /**
-   * Filters the underlying iterable to keep object with property (specified by {@link #with(String)}) <b>not in</b> the given
+   * Filters the underlying iterable to keep object with property (specified by {@link #with(String)}) <b>not in</b> the
+   * given
    * values.
    * <p>
    * Typical usage :
@@ -387,17 +387,14 @@ public class Filters<E> {
    * 
    * @param propertyValues the filter values.
    * @return this {@link Filters} to chain other filter operation.
-   * @throws NullPointerException if the property name to filter on has not been set.
+   * @throws IllegalArgumentException if the property name to filter on has not been set.
    */
   public Filters<E> notIn(Object... propertyValues) {
     checkPropertyNameToFilterOnIsNotNull();
     List<E> newFilteredIterable = new ArrayList<>();
     for (E element : filteredIterable) {
-      Object propertyValueOfCurrentElement = propertySupport.propertyValueOf(propertyNameToFilterOn, propertyValues.getClass()
-          .getComponentType(), element);
-      if (!isItemInArray(propertyValueOfCurrentElement, propertyValues)) {
-        newFilteredIterable.add(element);
-      }
+      Object propertyValueOfCurrentElement = propertyOrFieldSupport.getValueOf(propertyOrFieldNameToFilterOn, element);
+      if (!isItemInArray(propertyValueOfCurrentElement, propertyValues)) newFilteredIterable.add(element);
     }
     this.filteredIterable = newFilteredIterable;
     return this;
@@ -405,6 +402,7 @@ public class Filters<E> {
 
   /**
    * Returns <code>true</code> if given item is in given array, <code>false</code> otherwise.
+   * 
    * @param item the object to look for in arrayOfValues
    * @param arrayOfValues the array of values
    * @return <code>true</code> if given item is in given array, <code>false</code> otherwise.
@@ -417,6 +415,7 @@ public class Filters<E> {
 
   /**
    * Returns the resulting filtered Iterable&lt;E&gt; (even if the constructor parameter type was an array).
+   * 
    * @return the Iterable&lt;E&gt; containing the filtered elements.
    */
   public Iterable<E> get() {
diff --git a/src/main/java/org/assertj/core/api/filter/InFilter.java b/src/main/java/org/assertj/core/api/filter/InFilter.java
new file mode 100644
index 000000000..a1f52f668
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/filter/InFilter.java
@@ -0,0 +1,29 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.filter;
+
+public class InFilter extends FilterOperator<Object[]> {
+
+  private InFilter(Object... filterParameter) {
+    super(filterParameter);
+  }
+
+  public static InFilter in(Object... values) {
+    return new InFilter(values);
+  }
+
+  @Override
+  public <E> Filters<E> applyOn(Filters<E> filters) {
+    return filters.in(filterParameter);
+  }
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/filter/NotFilter.java b/src/main/java/org/assertj/core/api/filter/NotFilter.java
new file mode 100644
index 000000000..548edf8d5
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/filter/NotFilter.java
@@ -0,0 +1,35 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.filter;
+
+import static org.assertj.core.util.Objects.areEqual;
+
+public class NotFilter extends FilterOperator<Object> {
+
+  private NotFilter(Object filterParameter) {
+    super(filterParameter);
+  }
+
+  public static NotFilter not(Object valueNotToMatch) {
+    return new NotFilter(valueNotToMatch);
+  }
+
+  boolean filter(Object propertyValueOfCurrentElement) {
+    return !areEqual(propertyValueOfCurrentElement, filterParameter);
+  }
+
+  @Override
+  public <E> Filters<E> applyOn(Filters<E> filters) {
+    return filters.notEqualsTo(filterParameter);
+  }
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/api/filter/NotInFilter.java b/src/main/java/org/assertj/core/api/filter/NotInFilter.java
new file mode 100644
index 000000000..5d3201f13
--- /dev/null
+++ b/src/main/java/org/assertj/core/api/filter/NotInFilter.java
@@ -0,0 +1,33 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.filter;
+
+public class NotInFilter extends FilterOperator<Object[]> {
+
+  private NotInFilter(Object... filterParameter) {
+    super(filterParameter);
+  }
+
+  public static NotInFilter notIn(Object... valuesNotToMatch) {
+    return new NotInFilter(valuesNotToMatch);
+  }
+
+  public boolean filter(Object propertyValueOfCurrentElement) {
+    return false;
+  }
+
+  @Override
+  public <E> Filters<E> applyOn(Filters<E> filters) {
+    return filters.notIn(filterParameter);
+  }
+}
\ No newline at end of file
diff --git a/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java b/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
index becc645fe..636c77e37 100644
--- a/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
+++ b/src/main/java/org/assertj/core/extractor/ByNameSingleExtractor.java
@@ -12,20 +12,17 @@
  */
 package org.assertj.core.extractor;
 
-import static java.lang.String.format;
-
 import java.util.Map;
 
 import org.assertj.core.api.iterable.Extractor;
-import org.assertj.core.internal.PropertySupport;
-import org.assertj.core.util.introspection.FieldSupport;
-import org.assertj.core.util.introspection.IntrospectionError;
+import org.assertj.core.util.VisibleForTesting;
+import org.assertj.core.util.introspection.PropertyOrFieldSupport;
 
 class ByNameSingleExtractor<T> implements Extractor<T, Object> {
-  private static final String SEPARATOR = ".";
 
   private final String propertyOrFieldName;
 
+  @VisibleForTesting
   ByNameSingleExtractor(String propertyOrFieldName) {
     this.propertyOrFieldName = propertyOrFieldName;
   }
@@ -45,50 +42,7 @@ class ByNameSingleExtractor<T> implements Extractor<T, Object> {
       return map.get(propertyOrFieldName);
     }
 
-    return extract(propertyOrFieldName, input);
-  }
-
-  private Object extract(String propertyOrFieldName, Object input) {
-    if (isNested(propertyOrFieldName)) {
-      String firstPropertyName = popNameFrom(propertyOrFieldName);
-      Object propertyOrFieldValue = extractValue(firstPropertyName, input);
-      // extract next sub-property/field value until reaching the last sub-property/field
-      return extract(nextNameFrom(propertyOrFieldName), propertyOrFieldValue);
-    }
-    return extractValue(propertyOrFieldName, input);
-  }
-
-  private Object extractValue(String propertyOrFieldName, Object input) {
-    // first try to get given property values from objects, then try fields
-    try {
-      return PropertySupport.instance().propertyValueOf(propertyOrFieldName, Object.class, input);
-    } catch (IntrospectionError fieldIntrospectionError) {
-      // no luck with properties, let's try fields
-      try {
-        return FieldSupport.extraction().fieldValue(propertyOrFieldName, Object.class, input);
-      } catch (IntrospectionError propertyIntrospectionError) {
-        // no field nor property found with given name, it is considered as an error
-        String message = format("%nCan't find any field or property with name '%s'.%nError when introspecting fields was :%n- %s %nError when introspecting properties was :%n- %s",
-                                propertyOrFieldName, fieldIntrospectionError.getMessage(),
-                                propertyIntrospectionError.getMessage());
-        throw new IntrospectionError(message);
-      }
-    }
-  }
-
-  private String popNameFrom(String propertyOrFieldNameChain) {
-    if (!isNested(propertyOrFieldNameChain)) return propertyOrFieldNameChain;
-    return propertyOrFieldNameChain.substring(0, propertyOrFieldNameChain.indexOf(SEPARATOR));
+    return PropertyOrFieldSupport.INSTANCE.getValueOf(propertyOrFieldName, input);
   }
 
-  private String nextNameFrom(String propertyOrFieldNameChain) {
-    if (!isNested(propertyOrFieldNameChain)) return "";
-    return propertyOrFieldNameChain.substring(propertyOrFieldNameChain.indexOf(SEPARATOR) + 1);
-  }
-
-  private boolean isNested(String propertyOrFieldName) {
-    return propertyOrFieldName.contains(SEPARATOR)
-           && !propertyOrFieldName.startsWith(SEPARATOR)
-           && !propertyOrFieldName.endsWith(SEPARATOR);
-  }
 }
diff --git a/src/main/java/org/assertj/core/groups/Properties.java b/src/main/java/org/assertj/core/groups/Properties.java
index e2cc1afc6..816143ca5 100644
--- a/src/main/java/org/assertj/core/groups/Properties.java
+++ b/src/main/java/org/assertj/core/groups/Properties.java
@@ -16,9 +16,9 @@ import static org.assertj.core.util.ArrayWrapperList.wrap;
 
 import java.util.List;
 
-import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.introspection.IntrospectionError;
+import org.assertj.core.util.introspection.PropertySupport;
 
 
 
diff --git a/src/main/java/org/assertj/core/internal/Iterables.java b/src/main/java/org/assertj/core/internal/Iterables.java
index d0b9d0714..ad6a00d93 100644
--- a/src/main/java/org/assertj/core/internal/Iterables.java
+++ b/src/main/java/org/assertj/core/internal/Iterables.java
@@ -251,7 +251,7 @@ public class Iterables {
     // check for elements in values that are missing in actual.
     Set<Object> notExpected = setFromIterable(actual);
     Set<Object> notFound = containsOnly(notExpected, values);
-    if (!notExpected.isEmpty() && !notFound.isEmpty()) {
+    if (!notExpected.isEmpty() || !notFound.isEmpty()) {
       throw failures.failure(info, shouldContainOnly(actual, values, notFound, notExpected, comparisonStrategy));
     }
   }
diff --git a/src/main/java/org/assertj/core/internal/Objects.java b/src/main/java/org/assertj/core/internal/Objects.java
index ecd6b1bf3..2e88e5e06 100644
--- a/src/main/java/org/assertj/core/internal/Objects.java
+++ b/src/main/java/org/assertj/core/internal/Objects.java
@@ -49,6 +49,7 @@ import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.util.VisibleForTesting;
 import org.assertj.core.util.introspection.FieldSupport;
 import org.assertj.core.util.introspection.IntrospectionError;
+import org.assertj.core.util.introspection.PropertySupport;
 
 /**
  * Reusable assertions for {@code Object}s.
@@ -677,6 +678,7 @@ public class Objects {
    * @throws IntrospectionError is field value can't get retrieved.
    */
   private <A> Object getFieldOrPropertyValue(A a, String fieldName) {
+    // TODO use PropertyOrFieldSupport but the order is not the same
     try {
       return fieldSupport.fieldValue(fieldName, Object.class, a);
     } catch (IntrospectionError e) {
diff --git a/src/main/java/org/assertj/core/util/Preconditions.java b/src/main/java/org/assertj/core/util/Preconditions.java
index cee683fd8..cddb257f0 100644
--- a/src/main/java/org/assertj/core/util/Preconditions.java
+++ b/src/main/java/org/assertj/core/util/Preconditions.java
@@ -12,6 +12,10 @@
  */
 package org.assertj.core.util;
 
+import static java.lang.String.format;
+
+import org.assertj.core.api.filter.FilterOperator;
+
 /**
  * Verifies correct argument values and state. Borrowed from Guava.
  * 
@@ -94,9 +98,21 @@ public final class Preconditions {
     return reference;
   }
 
-  private Preconditions() {
+  /**
+   * Verifies that the given FilterOperator reference is not {@code null}.
+   * 
+   * @param reference the given object reference.
+   * @throws NullPointerException if the given object reference is {@code null}.
+   */
+  public static <T> void checkNotNull(FilterOperator<T> filterOperator) {
+    // @format:off
+    if (filterOperator == null) throw new IllegalArgumentException(format("The expected value should not be null.%n"
+        + "If you were trying to filter on a null value, please use filterOnNull(String propertyOrFieldName) instead"));
+    // @format:on
   }
 
+  private Preconditions() {}
+
   private static void throwExceptionForBeingEmpty() {
     throwExceptionForBeingEmpty(ARGUMENT_EMPTY);
   }
diff --git a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
index 2e03f0445..b8c14f6bb 100644
--- a/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/FieldSupport.java
@@ -31,6 +31,7 @@ import java.util.List;
 public enum FieldSupport {
 
   EXTRACTION(true),
+  EXTRACTION_OF_PUBLIC_FIELD_ONLY(false),
   COMPARISON(true);
 
   private static final String SEPARATOR = ".";
diff --git a/src/main/java/org/assertj/core/internal/JavaBeanDescriptor.java b/src/main/java/org/assertj/core/util/introspection/JavaBeanDescriptor.java
similarity index 96%
rename from src/main/java/org/assertj/core/internal/JavaBeanDescriptor.java
rename to src/main/java/org/assertj/core/util/introspection/JavaBeanDescriptor.java
index 128e32f71..a2cb2765b 100644
--- a/src/main/java/org/assertj/core/internal/JavaBeanDescriptor.java
+++ b/src/main/java/org/assertj/core/util/introspection/JavaBeanDescriptor.java
@@ -10,7 +10,7 @@
  *
  * Copyright 2012-2015 the original author or authors.
  */
-package org.assertj.core.internal;
+package org.assertj.core.util.introspection;
 
 import java.beans.PropertyDescriptor;
 import java.lang.reflect.InvocationTargetException;
diff --git a/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java b/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java
new file mode 100644
index 000000000..6bc9c77ce
--- /dev/null
+++ b/src/main/java/org/assertj/core/util/introspection/PropertyOrFieldSupport.java
@@ -0,0 +1,98 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static java.lang.String.format;
+
+import org.assertj.core.util.VisibleForTesting;
+
+public class PropertyOrFieldSupport {
+  private static final String SEPARATOR = ".";
+  private PropertySupport propertySupport;
+  private FieldSupport fieldSupport;
+
+  public static final PropertyOrFieldSupport INSTANCE = new PropertyOrFieldSupport();
+
+  PropertyOrFieldSupport() {
+    this.propertySupport = PropertySupport.instance();
+    this.fieldSupport = FieldSupport.extraction();
+  }
+
+  @VisibleForTesting
+  PropertyOrFieldSupport(PropertySupport propertySupport, FieldSupport fieldSupport) {
+    this.propertySupport = propertySupport;
+    this.fieldSupport = fieldSupport;
+  }
+
+  public void setAllowUsingPrivateFields(boolean allowUsingPrivateFields) {
+    fieldSupport.setAllowUsingPrivateFields(allowUsingPrivateFields);
+  }
+
+  public Object getValueOf(String propertyOrFieldName, Object input) {
+    if (propertyOrFieldName == null)
+      throw new IllegalArgumentException("The name of the property/field to read should not be null");
+    if (propertyOrFieldName.isEmpty())
+      throw new IllegalArgumentException("The name of the property/field to read should not be empty");
+    if (input == null)
+      throw new IllegalArgumentException("The object to extract property/field from should not be null");
+
+    if (isNested(propertyOrFieldName)) {
+      String firstPropertyName = popNameFrom(propertyOrFieldName);
+      Object propertyOrFieldValue = getSimpleValue(firstPropertyName, input);
+      // when one of the intermediate nested property/field value is null, return null
+      if (propertyOrFieldValue == null) return null;
+      // extract next sub-property/field value until reaching the last sub-property/field
+      return getValueOf(nextNameFrom(propertyOrFieldName), propertyOrFieldValue);
+    }
+    return getSimpleValue(propertyOrFieldName, input);
+  }
+
+  private Object getSimpleValue(String propertyOrFieldName, Object input) {
+    // first try to get given property values from objects, then try fields
+    try {
+      return propertySupport.propertyValueOf(propertyOrFieldName, Object.class, input);
+    } catch (IntrospectionError propertyIntrospectionError) {
+      // no luck with properties, let's try fields
+      try {
+        return fieldSupport.fieldValue(propertyOrFieldName, Object.class, input);
+      } catch (IntrospectionError fieldIntrospectionError) {
+        // no field nor property found with given name, it is considered as an error
+        String message = format("%nCan't find any field or property with name '%s'.%n" +
+                                "Error when introspecting properties was :%n" +
+                                "- %s %n" +
+                                "Error when introspecting fields was :%n" +
+                                "- %s",
+                                propertyOrFieldName, propertyIntrospectionError.getMessage(),
+                                fieldIntrospectionError.getMessage());
+        throw new IntrospectionError(message);
+      }
+    }
+  }
+
+  private String popNameFrom(String propertyOrFieldNameChain) {
+    if (!isNested(propertyOrFieldNameChain)) return propertyOrFieldNameChain;
+    return propertyOrFieldNameChain.substring(0, propertyOrFieldNameChain.indexOf(SEPARATOR));
+  }
+
+  private String nextNameFrom(String propertyOrFieldNameChain) {
+    if (!isNested(propertyOrFieldNameChain)) return "";
+    return propertyOrFieldNameChain.substring(propertyOrFieldNameChain.indexOf(SEPARATOR) + 1);
+  }
+
+  private boolean isNested(String propertyOrFieldName) {
+    return propertyOrFieldName.contains(SEPARATOR)
+           && !propertyOrFieldName.startsWith(SEPARATOR)
+           && !propertyOrFieldName.endsWith(SEPARATOR);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/internal/PropertySupport.java b/src/main/java/org/assertj/core/util/introspection/PropertySupport.java
similarity index 98%
rename from src/main/java/org/assertj/core/internal/PropertySupport.java
rename to src/main/java/org/assertj/core/util/introspection/PropertySupport.java
index 0fc9ca98c..e1518f23f 100644
--- a/src/main/java/org/assertj/core/internal/PropertySupport.java
+++ b/src/main/java/org/assertj/core/util/introspection/PropertySupport.java
@@ -10,7 +10,7 @@
  *
  * Copyright 2012-2015 the original author or authors.
  */
-package org.assertj.core.internal;
+package org.assertj.core.util.introspection;
 
 import static java.lang.String.format;
 import static java.util.Collections.*;
@@ -22,7 +22,6 @@ import java.util.ArrayList;
 import java.util.List;
 
 import org.assertj.core.util.VisibleForTesting;
-import org.assertj.core.util.introspection.IntrospectionError;
 
 /**
  * Utility methods for properties access.
diff --git a/src/test/java/org/assertj/core/api/filter/AbstractTest_equals_filter.java b/src/test/java/org/assertj/core/api/filter/AbstractTest_equals_filter.java
index 67174c8cd..a78431a17 100644
--- a/src/test/java/org/assertj/core/api/filter/AbstractTest_equals_filter.java
+++ b/src/test/java/org/assertj/core/api/filter/AbstractTest_equals_filter.java
@@ -14,11 +14,11 @@ package org.assertj.core.api.filter;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 import static org.assertj.core.api.filter.Filters.filter;
 
 import org.assertj.core.test.Player;
 import org.assertj.core.util.introspection.IntrospectionError;
-
 import org.junit.Test;
 
 
@@ -37,25 +37,33 @@ public abstract class AbstractTest_equals_filter extends AbstractTest_filter {
     assertThat(players).hasSize(4);
   }
 
+  @Test
+  public void should_filter_iterable_elements_with_field_equals_to_given_value() {
+    Iterable<Player> bullsPlayers = filterIterable(players, "highestScore", 50);
+    assertThat(bullsPlayers).containsOnly(rose, james);
+    // players is not modified
+    assertThat(players).hasSize(4);
+  }
+
   protected abstract Iterable<Player> filterIterable(Iterable<Player> players, String propertyName, Object propertyValue);
 
   @Test
   public void should_fail_if_property_to_filter_on_is_null() {
     try {
       filterIterable(players, null, 6000L);
-      fail("NullPointerException expected");
-    } catch (NullPointerException e) {
-      assertThat(e).hasMessage("The property name to filter on should not be null");
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("The property/field name to filter on should not be null or empty");
     }
   }
 
   @Test
   public void should_fail_if_elements_to_filter_do_not_have_property_used_by_filter() {
     try {
-      filterIterable(players, "nickname", "dude");
+      filterIterable(players, "country", "France");
       fail("IntrospectionError expected");
     } catch (IntrospectionError e) {
-      assertThat(e).hasMessage("No getter for property 'nickname' in org.assertj.core.test.Player");
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'country'");
     }
   }
 
diff --git a/src/test/java/org/assertj/core/api/filter/AbstractTest_filter.java b/src/test/java/org/assertj/core/api/filter/AbstractTest_filter.java
index e79a07708..d1c2d0d94 100644
--- a/src/test/java/org/assertj/core/api/filter/AbstractTest_filter.java
+++ b/src/test/java/org/assertj/core/api/filter/AbstractTest_filter.java
@@ -35,18 +35,22 @@ public class AbstractTest_filter {
     rose.setAssistsPerGame(8);
     rose.setPointsPerGame(25);
     rose.setReboundsPerGame(5);
+    rose.setHighestScore(50);
     james = new Player(new Name("Lebron", "James"), "Miami Heat");
     james.setAssistsPerGame(6);
     james.setPointsPerGame(27);
     james.setReboundsPerGame(8);
+    james.setHighestScore(50);
     durant = new Player(new Name("Kevin", "Durant"), "OKC");
     durant.setAssistsPerGame(4);
     durant.setPointsPerGame(30);
     durant.setReboundsPerGame(5);
+    durant.setHighestScore(60);
     noah = new Player(new Name("Joachim", "Noah"), "Chicago Bulls");
     noah.setAssistsPerGame(4);
     noah.setPointsPerGame(10);
     noah.setReboundsPerGame(11);
+    noah.setHighestScore(20);
     players = newArrayList(rose, james, durant, noah);
   }
 
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_being_condition_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_being_condition_Test.java
index 1237fd99d..3a8fd43fa 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_being_condition_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_being_condition_Test.java
@@ -13,10 +13,9 @@
 package org.assertj.core.api.filter;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 import static org.assertj.core.api.filter.Filters.filter;
 
-import static org.assertj.core.api.Assertions.fail;
-
 import org.assertj.core.test.Player;
 import org.junit.Test;
 
@@ -37,8 +36,8 @@ public class Filter_being_condition_Test extends AbstractTest_filter {
   public void should_fail_if_filter_condition_is_null() {
     try {
       filter(players).being(null);
-      fail("NullPointerException expected");
-    } catch (NullPointerException e) {
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("The filter condition should not be null");
     }
   }
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_having_condition_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_having_condition_Test.java
index 71e6af3fd..db770bd27 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_having_condition_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_having_condition_Test.java
@@ -13,10 +13,9 @@
 package org.assertj.core.api.filter;
 
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
 import static org.assertj.core.api.filter.Filters.filter;
 
-import static org.assertj.core.api.Assertions.fail;
-
 import org.assertj.core.test.Player;
 import org.junit.Test;
 
@@ -37,8 +36,8 @@ public class Filter_having_condition_Test extends AbstractTest_filter {
   public void should_fail_if_filter_condition_is_null() {
     try {
       filter(players).having(null);
-      fail("NullPointerException expected");
-    } catch (NullPointerException e) {
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
       assertThat(e).hasMessage("The filter condition should not be null");
     }
   }
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_on_differents_properties_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_on_differents_properties_Test.java
index 062631e79..f8ce00051 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_on_differents_properties_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_on_differents_properties_Test.java
@@ -13,42 +13,30 @@
 package org.assertj.core.api.filter;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.filter.Filters.filter;
-
 import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.api.filter.Filters.filter;
 
+import org.assertj.core.test.Player;
 import org.assertj.core.util.introspection.IntrospectionError;
-
 import org.junit.Test;
 
-
 public class Filter_on_differents_properties_Test extends AbstractTest_filter {
 
   @Test
   public void should_filter_iterable_elements_on_different_properties() {
     // rose and durant have 5 rebounds per game but only rose does not play in OKC
-    assertThat(filter(players).with("reboundsPerGame").equalsTo(5).and("team").notEqualsTo("OKC").get()).containsOnly(rose);
-    // players is not modified
-    assertThat(players).hasSize(4);
-  }
-
-  @Test
-  public void should_fail_if_property_to_filter_on_is_null() {
-    try {
-      filter(players).with("reboundsPerGame").equalsTo(5).and(null).equalsTo("OKC");
-      fail("NullPointerException expected");
-    } catch (NullPointerException e) {
-      assertThat(e.getMessage()).isEqualTo("The property name to filter on should not be null");
-    }
+    Iterable<Player> filteredPlayers = filter(players).with("reboundsPerGame").equalsTo(5)
+                                                      .and("team").notEqualsTo("OKC").get();
+    assertThat(filteredPlayers).containsOnly(rose);
   }
 
   @Test
-  public void should_fail_if_elements_to_filter_do_not_have_property_used_by_filter() {
+  public void should_fail_if_elements_to_filter_do_not_have_one_of_the_property_or_field_used_by_filter() {
     try {
-      filter(players).with("reboundsPerGame").equalsTo(5).and("nickname").notEqualsTo("dude");
+      filter(players).with("reboundsPerGame").equalsTo(5).and("numberOfTitle").notEqualsTo(0);
       fail("IntrospectionError expected");
     } catch (IntrospectionError e) {
-      assertThat(e.getMessage()).isEqualTo("No getter for property 'nickname' in org.assertj.core.test.Player");
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'numberOfTitle'");
     }
   }
 
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_with_common_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_with_common_Test.java
new file mode 100644
index 000000000..96f6b653d
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/filter/Filter_with_common_Test.java
@@ -0,0 +1,55 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.filter;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.filter.Filters.filter;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.List;
+
+import org.assertj.core.test.Player;
+import org.junit.Test;
+
+public class Filter_with_common_Test extends AbstractTest_filter {
+
+  @Test
+  public void filter_does_not_modify_given_iterable() {
+    List<Player> playersCopy = newArrayList(players);
+    // filter players
+    filter(players).with("reboundsPerGame").equalsTo(5).get();
+    assertThat(playersCopy).isEqualTo(players);
+  }
+
+  @Test
+  public void should_fail_if_property_or_field_to_filter_on_is_null() {
+    try {
+      filter(players).with("reboundsPerGame").equalsTo(5).and(null).equalsTo("OKC");
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("The property/field name to filter on should not be null or empty");
+    }
+  }
+
+  @Test
+  public void should_fail_if_property_or_field_to_filter_on_is_empty() {
+    try {
+      filter(players).with("").equalsTo("OKC");
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("The property/field name to filter on should not be null or empty");
+    }
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_with_property_in_given_values_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_with_property_in_given_values_Test.java
index cd7ef4b7b..89f7440ef 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_with_property_in_given_values_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_with_property_in_given_values_Test.java
@@ -13,13 +13,12 @@
 package org.assertj.core.api.filter;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.filter.Filters.filter;
-
 import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.filter.Filters.filter;
 
 import org.assertj.core.test.Player;
 import org.assertj.core.util.introspection.IntrospectionError;
-
 import org.junit.Test;
 
 
@@ -42,20 +41,20 @@ public class Filter_with_property_in_given_values_Test extends AbstractTest_filt
   public void should_fail_if_property_to_filter_on_is_null() {
     try {
       filter(players).with(null).in("foo", "bar");
-      fail("NullPointerException expected");
-    } catch (NullPointerException e) {
-      assertThat(e.getMessage()).isEqualTo("The property name to filter on should not be null");
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("The property/field name to filter on should not be null or empty");
     }
   }
 
   @Test
-  public void should_fail_if_elements_to_filter_do_not_have_property_used_by_filter() {
+  public void should_fail_if_elements_to_filter_do_not_have_property_or_field_used_by_filter() {
     try {
-      filter(players).with("nickname").in("dude", "al");
+      filter(players).with("country").in("France", "Italy");
       fail("IntrospectionError expected");
     } catch (IntrospectionError e) {
-      assertThat(e.getMessage()).isEqualTo("No getter for property 'nickname' in org.assertj.core.test.Player");
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'country'");
     }
   }
 
-}
\ No newline at end of file
+}
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_equals_to_given_value_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_equals_to_given_value_Test.java
index b571076ab..8e0f99460 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_equals_to_given_value_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_equals_to_given_value_Test.java
@@ -13,13 +13,12 @@
 package org.assertj.core.api.filter;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.filter.Filters.filter;
-
 import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.filter.Filters.filter;
 
 import org.assertj.core.test.Player;
 import org.assertj.core.util.introspection.IntrospectionError;
-
 import org.junit.Test;
 
 
@@ -42,19 +41,19 @@ public class Filter_with_property_not_equals_to_given_value_Test extends Abstrac
   public void should_fail_if_property_to_filter_on_is_null() {
     try {
       filter(players).with(null).notEqualsTo("foo");
-      fail("NullPointerException expected");
-    } catch (NullPointerException e) {
-      assertThat(e.getMessage()).isEqualTo("The property name to filter on should not be null");
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("The property/field name to filter on should not be null or empty");
     }
   }
 
   @Test
   public void should_fail_if_elements_to_filter_do_not_have_property_used_by_filter() {
     try {
-      filter(players).with("nickname").notEqualsTo("dude");
+      filter(players).with("country").notEqualsTo("France");
       fail("IntrospectionError expected");
     } catch (IntrospectionError e) {
-      assertThat(e.getMessage()).isEqualTo("No getter for property 'nickname' in org.assertj.core.test.Player");
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'country'");
     }
   }
 
diff --git a/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_in_given_values_Test.java b/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_in_given_values_Test.java
index 94b55fc0a..291189c18 100644
--- a/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_in_given_values_Test.java
+++ b/src/test/java/org/assertj/core/api/filter/Filter_with_property_not_in_given_values_Test.java
@@ -13,13 +13,12 @@
 package org.assertj.core.api.filter;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.filter.Filters.filter;
-
 import static org.assertj.core.api.Assertions.fail;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.filter.Filters.filter;
 
 import org.assertj.core.test.Player;
 import org.assertj.core.util.introspection.IntrospectionError;
-
 import org.junit.Test;
 
 
@@ -42,19 +41,19 @@ public class Filter_with_property_not_in_given_values_Test extends AbstractTest_
   public void should_fail_if_property_to_filter_on_is_null() {
     try {
       filter(players).with(null).notIn("foo", "bar");
-      fail("NullPointerException expected");
-    } catch (NullPointerException e) {
-      assertThat(e.getMessage()).isEqualTo("The property name to filter on should not be null");
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage("The property/field name to filter on should not be null or empty");
     }
   }
 
   @Test
   public void should_fail_if_elements_to_filter_do_not_have_property_used_by_filter() {
     try {
-      filter(players).with("nickname").notIn("dude", "al");
+      filter(players).with("country").in("France", "Italy");
       fail("IntrospectionError expected");
     } catch (IntrospectionError e) {
-      assertThat(e.getMessage()).isEqualTo("No getter for property 'nickname' in org.assertj.core.test.Player");
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'country'");
     }
   }
 
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOnNull_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOnNull_Test.java
new file mode 100644
index 000000000..8ac92278f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOnNull_Test.java
@@ -0,0 +1,44 @@
+package org.assertj.core.api.iterable;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class IterableAssert_filteredOnNull_Test extends IterableAssert_filtered_baseTest {
+
+  @Test
+  public void should_filter_iterable_under_test_on_null_property_values() {
+    assertThat(employees).filteredOnNull("name").containsOnly(noname);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_null_nested_property_values() {
+    assertThat(employees).filteredOnNull("name.last").containsOnly(yoda, obiwan, noname);
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_iterable_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOnNull("secret");
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_Test.java
new file mode 100644
index 000000000..47c1099f1
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_Test.java
@@ -0,0 +1,131 @@
+package org.assertj.core.api.iterable;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.in;
+import static org.assertj.core.api.Assertions.not;
+import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
+import static org.assertj.core.util.Sets.newHashSet;
+
+import java.util.Set;
+
+import org.assertj.core.test.Employee;
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class IterableAssert_filteredOn_Test extends IterableAssert_filtered_baseTest {
+
+  @Test
+  public void should_filter_iterable_under_test_on_property_values() {
+    assertThat(employees).filteredOn("age", 800).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_set_under_test_on_property_values() {
+    Set<Employee> employeeSet = newHashSet(employees);
+    assertThat(employeeSet).filteredOn("age", 800).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_property_not_backed_by_a_field_values() {
+    assertThat(employees).filteredOn("adult", false).containsOnly(noname);
+    assertThat(employees).filteredOn("adult", true).containsOnly(yoda, obiwan, luke);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_public_field_values() {
+    assertThat(employees).filteredOn("id", 1L).containsOnly(yoda);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_private_field_values() {
+    assertThat(employees).filteredOn("city", "New York").containsOnly(yoda, obiwan, luke, noname);
+    assertThat(employees).filteredOn("city", "Paris").isEmpty();
+  }
+
+  @Test
+  public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
+    setAllowExtractingPrivateFields(false);
+    try {
+      assertThat(employees).filteredOn("city", "New York").isEmpty();
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      // expected
+    } finally {
+      setAllowExtractingPrivateFields(true);
+    }
+  }
+
+  @Test
+  public void should_filter_iterator_under_test_on_property_values() {
+    assertThat(employees.iterator()).filteredOn("age", 800).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_nested_property_values() {
+    assertThat(employees).filteredOn("name.first", "Luke").containsOnly(luke);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_nested_mixed_property_and_field_values() {
+    assertThat(employees).filteredOn("name.last", "Vader").isEmpty();
+    assertThat(employees).filteredOn("name.last", "Skywalker").containsOnly(luke);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn(null, 800);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_empty() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn("", 800);
+  }
+
+  @Test
+  public void should_fail_if_given_expected_value_is_null() {
+    try {
+      assertThat(employees).filteredOn("name", null);
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(format("The expected value should not be null.%n"
+                                      + "If you were trying to filter on a null value, please use filterOnNull(String propertyOrFieldName) instead"));
+    }
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_iterable_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOn("secret", "???");
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+
+  @Test
+  public void should_fail_if_filter_operators_are_combined() {
+    try {
+      assertThat(employees).filteredOn("age", not(in(800))).containsOnly(luke, noname);
+      failBecauseExceptionWasNotThrown(UnsupportedOperationException.class);
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessageStartingWith("Combining operator is not supported");
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_condition_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_condition_Test.java
new file mode 100644
index 000000000..14e02297f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_condition_Test.java
@@ -0,0 +1,56 @@
+package org.assertj.core.api.iterable;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.not;
+
+import org.assertj.core.api.Condition;
+import org.assertj.core.test.Employee;
+import org.junit.Before;
+import org.junit.Test;
+
+public class IterableAssert_filteredOn_condition_Test extends IterableAssert_filtered_baseTest {
+
+  protected Condition<Employee> oldEmployees;
+
+  @Override
+  @Before
+  public void setUp() {
+    super.setUp();
+    oldEmployees = new Condition<Employee>("old employees") {
+      @Override
+      public boolean matches(Employee employee) {
+        return employee.getAge() > 100;
+      }
+    };
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_condition() {
+    assertThat(employees).filteredOn(oldEmployees).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_combined_condition() {
+    assertThat(employees).filteredOn(not(oldEmployees)).contains(luke, noname);
+  }
+
+  @Test
+  public void should_fail_if_given_condition_is_null() {
+    thrown.expectIllegalArgumentException("The filter condition should not be null");
+    assertThat(employees).filteredOn(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_in_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_in_Test.java
new file mode 100644
index 000000000..6dd23ea25
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_in_Test.java
@@ -0,0 +1,100 @@
+package org.assertj.core.api.iterable;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.in;
+import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class IterableAssert_filteredOn_in_Test extends IterableAssert_filtered_baseTest {
+
+  @Test
+  public void should_apply_in_filter() {
+    assertThat(employees).filteredOn("age", in(800, 26)).containsOnly(yoda, obiwan, luke);
+    assertThat(employees).filteredOn("age", in(800)).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_property_not_backed_by_a_field_values() {
+    assertThat(employees).filteredOn("adult", in(false)).containsOnly(noname);
+    assertThat(employees).filteredOn("adult", in(true)).containsOnly(yoda, obiwan, luke);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_public_field_values() {
+    assertThat(employees).filteredOn("id", 1L).containsOnly(yoda);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_private_field_values() {
+    assertThat(employees).filteredOn("city", in("New York")).containsOnly(yoda, obiwan, luke, noname);
+    assertThat(employees).filteredOn("city", in("Paris")).isEmpty();
+  }
+
+  @Test
+  public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
+    setAllowExtractingPrivateFields(false);
+    try {
+      assertThat(employees).filteredOn("city", in("New York")).isEmpty();
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      // expected
+    } finally {
+      setAllowExtractingPrivateFields(true);
+    }
+  }
+
+  @Test
+  public void should_filter_iterator_under_test_on_property_values() {
+    assertThat(employees.iterator()).filteredOn("age", in(800)).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_nested_property_values() {
+    assertThat(employees).filteredOn("name.first", in("Luke")).containsOnly(luke);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_nested_mixed_property_and_field_values() {
+    assertThat(employees).filteredOn("name.last", in("Vader")).isEmpty();
+    assertThat(employees).filteredOn("name.last", in("Skywalker")).containsOnly(luke);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn(null, in(800));
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_empty() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn("", in(800));
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_iterable_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOn("secret", in("???"));
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_notIn_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_notIn_Test.java
new file mode 100644
index 000000000..1208f9145
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_notIn_Test.java
@@ -0,0 +1,103 @@
+package org.assertj.core.api.iterable;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.notIn;
+import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class IterableAssert_filteredOn_notIn_Test extends IterableAssert_filtered_baseTest {
+
+  @Test
+  public void should_apply_notIn_filter() {
+    assertThat(employees).filteredOn("age", notIn(800, 10)).containsOnly(luke);
+    assertThat(employees).filteredOn("age", notIn(800)).containsOnly(luke, noname);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_property_not_backed_by_a_field_values() {
+    assertThat(employees).filteredOn("adult", notIn(false)).containsOnly(yoda, obiwan, luke);
+    assertThat(employees).filteredOn("adult", notIn(true)).containsOnly(noname);
+    assertThat(employees).filteredOn("adult", notIn(true, false)).isEmpty();
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_public_field_values() {
+    assertThat(employees).filteredOn("id", notIn(2L, 3L, 4L)).containsOnly(yoda);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_private_field_values() {
+    assertThat(employees).filteredOn("city", notIn("Paris")).containsOnly(yoda, obiwan, luke, noname);
+    assertThat(employees).filteredOn("city", notIn("New York")).isEmpty();
+    assertThat(employees).filteredOn("city", notIn("New York", "Paris")).isEmpty();
+  }
+
+  @Test
+  public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
+    setAllowExtractingPrivateFields(false);
+    try {
+      assertThat(employees).filteredOn("city", notIn("New York")).isEmpty();
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      // expected
+    } finally {
+      setAllowExtractingPrivateFields(true);
+    }
+  }
+
+  @Test
+  public void should_filter_iterator_under_test_on_property_values() {
+    assertThat(employees.iterator()).filteredOn("age", notIn(800)).containsOnly(luke, noname);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_nested_property_values() {
+    assertThat(employees).filteredOn("name.first", notIn("Luke")).containsOnly(yoda, obiwan, noname);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_nested_mixed_property_and_field_values() {
+    assertThat(employees).filteredOn("name.last", notIn("Skywalker")).containsOnly(yoda, obiwan, noname);
+    assertThat(employees).filteredOn("name.last", notIn("Skywalker", null)).isEmpty();;
+    assertThat(employees).filteredOn("name.last", notIn("Vader")).containsOnly(yoda, obiwan, noname, luke);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn(null, notIn(800));
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_empty() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn("", notIn(800));
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_iterable_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOn("secret", notIn("???"));
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_not_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_not_Test.java
new file mode 100644
index 000000000..846dbcb4c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filteredOn_not_Test.java
@@ -0,0 +1,110 @@
+package org.assertj.core.api.iterable;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.not;
+import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class IterableAssert_filteredOn_not_Test extends IterableAssert_filtered_baseTest {
+
+  @Test
+  public void should_apply_not_filter() {
+    assertThat(employees).filteredOn("age", not(800)).containsOnly(luke, noname);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_property_not_backed_by_a_field_values() {
+    assertThat(employees).filteredOn("adult", not(false)).containsOnly(yoda, obiwan, luke);
+    assertThat(employees).filteredOn("adult", not(true)).containsOnly(noname);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_public_field_values() {
+    assertThat(employees).filteredOn("id", not(1L)).containsOnly(noname, obiwan, luke);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_private_field_values() {
+    assertThat(employees).filteredOn("city", not("New York")).isEmpty();
+    assertThat(employees).filteredOn("city", not("Paris")).containsOnly(yoda, obiwan, luke, noname);
+  }
+
+  @Test
+  public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
+    setAllowExtractingPrivateFields(false);
+    try {
+      assertThat(employees).filteredOn("city", not("New York"));
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      // expected
+    } finally {
+      setAllowExtractingPrivateFields(true);
+    }
+  }
+
+  @Test
+  public void should_filter_iterator_under_test_on_property_values() {
+    assertThat(employees.iterator()).filteredOn("age", not(800)).containsOnly(luke, noname);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_nested_property_values() {
+    assertThat(employees).filteredOn("name.first", not("Luke")).containsOnly(yoda, obiwan, noname);
+  }
+
+  @Test
+  public void should_filter_iterable_under_test_on_nested_mixed_property_and_field_values() {
+    assertThat(employees).filteredOn("name.last", not("Vader")).containsOnly(luke, yoda, obiwan, noname);
+    assertThat(employees).filteredOn("name.last", not("Skywalker")).containsOnly(yoda, obiwan, noname);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn(null, not(800));
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_empty() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn("", not(800));
+  }
+
+  @Test
+  public void should_fail_if_given_expected_value_is_null() {
+    try {
+      assertThat(employees).filteredOn("name", null);
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(format("The expected value should not be null.%n"
+                                      + "If you were trying to filter on a null value, please use filterOnNull(String propertyOrFieldName) instead"));
+    }
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_iterable_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOn("secret", not("???"));
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_filtered_baseTest.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filtered_baseTest.java
new file mode 100644
index 000000000..6b68269ae
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_filtered_baseTest.java
@@ -0,0 +1,49 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.assertj.core.test.ExpectedException.none;
+import static org.assertj.core.util.Lists.newArrayList;
+
+import java.util.List;
+
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.test.Name;
+import org.junit.Before;
+import org.junit.Rule;
+
+public class IterableAssert_filtered_baseTest {
+
+  protected Employee yoda;
+  protected Employee obiwan;
+  protected Employee luke;
+  protected Employee noname;
+  protected List<Employee> employees;
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Before
+  public void setUp() {
+    yoda = new Employee(1L, new Name("Yoda"), 800);
+    obiwan = new Employee(2L, new Name("Obi"), 800);
+    luke = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+    noname = new Employee(4L, null, 10);
+    employees = newArrayList(yoda, luke, obiwan, noname);
+  }
+
+  public IterableAssert_filtered_baseTest() {
+    super();
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_Test.java
new file mode 100644
index 000000000..cfef1cd76
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_Test.java
@@ -0,0 +1,116 @@
+package org.assertj.core.api.objectarray;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.in;
+import static org.assertj.core.api.Assertions.not;
+import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class ObjectArrayAssert_filteredOn_Test extends ObjectArrayAssert_filtered_baseTest {
+
+  @Test
+  public void should_filter_object_array_under_test_on_property_values() {
+    assertThat(employees).filteredOn("age", 800).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_property_not_backed_by_a_field_values() {
+    assertThat(employees).filteredOn("adult", false).containsOnly(noname);
+    assertThat(employees).filteredOn("adult", true).containsOnly(yoda, obiwan, luke);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_public_field_values() {
+    assertThat(employees).filteredOn("id", 1L).containsOnly(yoda);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_private_field_values() {
+    assertThat(employees).filteredOn("city", "New York").containsOnly(yoda, obiwan, luke, noname);
+    assertThat(employees).filteredOn("city", "Paris").isEmpty();
+  }
+
+  @Test
+  public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
+    setAllowExtractingPrivateFields(false);
+    try {
+      assertThat(employees).filteredOn("city", "New York").isEmpty();
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      // expected
+    } finally {
+      setAllowExtractingPrivateFields(true);
+    }
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_nested_property_values() {
+    assertThat(employees).filteredOn("name.first", "Luke").containsOnly(luke);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_nested_mixed_property_and_field_values() {
+    assertThat(employees).filteredOn("name.last", "Vader").isEmpty();
+    assertThat(employees).filteredOn("name.last", "Skywalker").containsOnly(luke);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn(null, 800);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_empty() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn("", 800);
+  }
+
+  @Test
+  public void should_fail_if_given_expected_value_is_null() {
+    try {
+      assertThat(employees).filteredOn("name", null);
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(format("The expected value should not be null.%n"
+                                      + "If you were trying to filter on a null value, please use filterOnNull(String propertyOrFieldName) instead"));
+    }
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOn("secret", "???");
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+
+  @Test
+  public void should_fail_if_filter_operators_are_combined() {
+    try {
+      assertThat(employees).filteredOn("age", not(in(800))).containsOnly(luke, noname);
+      failBecauseExceptionWasNotThrown(UnsupportedOperationException.class);
+    } catch (UnsupportedOperationException e) {
+      assertThat(e).hasMessageStartingWith("Combining operator is not supported");
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_condition_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_condition_Test.java
new file mode 100644
index 000000000..0f967a709
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_condition_Test.java
@@ -0,0 +1,56 @@
+package org.assertj.core.api.objectarray;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.not;
+
+import org.assertj.core.api.Condition;
+import org.assertj.core.test.Employee;
+import org.junit.Before;
+import org.junit.Test;
+
+public class ObjectArrayAssert_filteredOn_condition_Test extends ObjectArrayAssert_filtered_baseTest {
+
+  protected Condition<Employee> oldEmployees;
+
+  @Override
+  @Before
+  public void setUp() {
+    super.setUp();
+    oldEmployees = new Condition<Employee>("old employees") {
+      @Override
+      public boolean matches(Employee employee) {
+        return employee.getAge() > 100;
+      }
+    };
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_condition() {
+    assertThat(employees).filteredOn(oldEmployees).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_combined_condition() {
+    assertThat(employees).filteredOn(not(oldEmployees)).contains(luke, noname);
+  }
+
+  @Test
+  public void should_fail_if_given_condition_is_null() {
+    thrown.expectIllegalArgumentException("The filter condition should not be null");
+    assertThat(employees).filteredOn(null);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_in_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_in_Test.java
new file mode 100644
index 000000000..5de012205
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_in_Test.java
@@ -0,0 +1,95 @@
+package org.assertj.core.api.objectarray;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.in;
+import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class ObjectArrayAssert_filteredOn_in_Test extends ObjectArrayAssert_filtered_baseTest {
+
+  @Test
+  public void should_apply_in_filter() {
+    assertThat(employees).filteredOn("age", in(800, 26)).containsOnly(yoda, obiwan, luke);
+    assertThat(employees).filteredOn("age", in(800)).containsOnly(yoda, obiwan);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_property_not_backed_by_a_field_values() {
+    assertThat(employees).filteredOn("adult", in(false)).containsOnly(noname);
+    assertThat(employees).filteredOn("adult", in(true)).containsOnly(yoda, obiwan, luke);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_public_field_values() {
+    assertThat(employees).filteredOn("id", 1L).containsOnly(yoda);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_private_field_values() {
+    assertThat(employees).filteredOn("city", in("New York")).containsOnly(yoda, obiwan, luke, noname);
+    assertThat(employees).filteredOn("city", in("Paris")).isEmpty();
+  }
+
+  @Test
+  public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
+    setAllowExtractingPrivateFields(false);
+    try {
+      assertThat(employees).filteredOn("city", in("New York")).isEmpty();
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      // expected
+    } finally {
+      setAllowExtractingPrivateFields(true);
+    }
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_nested_property_values() {
+    assertThat(employees).filteredOn("name.first", in("Luke")).containsOnly(luke);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_nested_mixed_property_and_field_values() {
+    assertThat(employees).filteredOn("name.last", in("Vader")).isEmpty();
+    assertThat(employees).filteredOn("name.last", in("Skywalker")).containsOnly(luke);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn(null, in(800));
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_empty() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn("", in(800));
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOn("secret", in("???"));
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_notIn_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_notIn_Test.java
new file mode 100644
index 000000000..e3def9020
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_notIn_Test.java
@@ -0,0 +1,98 @@
+package org.assertj.core.api.objectarray;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.notIn;
+import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class ObjectArrayAssert_filteredOn_notIn_Test extends ObjectArrayAssert_filtered_baseTest {
+
+  @Test
+  public void should_apply_notIn_filter() {
+    assertThat(employees).filteredOn("age", notIn(800, 10)).containsOnly(luke);
+    assertThat(employees).filteredOn("age", notIn(800)).containsOnly(luke, noname);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_property_not_backed_by_a_field_values() {
+    assertThat(employees).filteredOn("adult", notIn(false)).containsOnly(yoda, obiwan, luke);
+    assertThat(employees).filteredOn("adult", notIn(true)).containsOnly(noname);
+    assertThat(employees).filteredOn("adult", notIn(true, false)).isEmpty();
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_public_field_values() {
+    assertThat(employees).filteredOn("id", notIn(2L, 3L, 4L)).containsOnly(yoda);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_private_field_values() {
+    assertThat(employees).filteredOn("city", notIn("Paris")).containsOnly(yoda, obiwan, luke, noname);
+    assertThat(employees).filteredOn("city", notIn("New York")).isEmpty();
+    assertThat(employees).filteredOn("city", notIn("New York", "Paris")).isEmpty();
+  }
+
+  @Test
+  public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
+    setAllowExtractingPrivateFields(false);
+    try {
+      assertThat(employees).filteredOn("city", notIn("New York")).isEmpty();
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      // expected
+    } finally {
+      setAllowExtractingPrivateFields(true);
+    }
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_nested_property_values() {
+    assertThat(employees).filteredOn("name.first", notIn("Luke")).containsOnly(yoda, obiwan, noname);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_nested_mixed_property_and_field_values() {
+    assertThat(employees).filteredOn("name.last", notIn("Skywalker")).containsOnly(yoda, obiwan, noname);
+    assertThat(employees).filteredOn("name.last", notIn("Skywalker", null)).isEmpty();;
+    assertThat(employees).filteredOn("name.last", notIn("Vader")).containsOnly(yoda, obiwan, noname, luke);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn(null, notIn(800));
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_empty() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn("", notIn(800));
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOn("secret", notIn("???"));
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_not_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_not_Test.java
new file mode 100644
index 000000000..405a1285f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filteredOn_not_Test.java
@@ -0,0 +1,105 @@
+package org.assertj.core.api.objectarray;
+
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+
+import static java.lang.String.format;
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.failBecauseExceptionWasNotThrown;
+import static org.assertj.core.api.Assertions.not;
+import static org.assertj.core.api.Assertions.setAllowExtractingPrivateFields;
+
+import org.assertj.core.util.introspection.IntrospectionError;
+import org.junit.Test;
+
+public class ObjectArrayAssert_filteredOn_not_Test extends ObjectArrayAssert_filtered_baseTest {
+
+  @Test
+  public void should_apply_not_filter() {
+    assertThat(employees).filteredOn("age", not(800)).containsOnly(luke, noname);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_property_not_backed_by_a_field_values() {
+    assertThat(employees).filteredOn("adult", not(false)).containsOnly(yoda, obiwan, luke);
+    assertThat(employees).filteredOn("adult", not(true)).containsOnly(noname);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_public_field_values() {
+    assertThat(employees).filteredOn("id", not(1L)).containsOnly(noname, obiwan, luke);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_private_field_values() {
+    assertThat(employees).filteredOn("city", not("New York")).isEmpty();
+    assertThat(employees).filteredOn("city", not("Paris")).containsOnly(yoda, obiwan, luke, noname);
+  }
+
+  @Test
+  public void should_fail_if_filter_is_on_private_field_and_reading_private_field_is_disabled() {
+    setAllowExtractingPrivateFields(false);
+    try {
+      assertThat(employees).filteredOn("city", not("New York"));
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      // expected
+    } finally {
+      setAllowExtractingPrivateFields(true);
+    }
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_nested_property_values() {
+    assertThat(employees).filteredOn("name.first", not("Luke")).containsOnly(yoda, obiwan, noname);
+  }
+
+  @Test
+  public void should_filter_object_array_under_test_on_nested_mixed_property_and_field_values() {
+    assertThat(employees).filteredOn("name.last", not("Vader")).containsOnly(luke, yoda, obiwan, noname);
+    assertThat(employees).filteredOn("name.last", not("Skywalker")).containsOnly(yoda, obiwan, noname);
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn(null, not(800));
+  }
+
+  @Test
+  public void should_fail_if_given_property_or_field_name_is_empty() {
+    thrown.expectIllegalArgumentException("The property/field name to filter on should not be null or empty");
+    assertThat(employees).filteredOn("", not(800));
+  }
+
+  @Test
+  public void should_fail_if_given_expected_value_is_null() {
+    try {
+      assertThat(employees).filteredOn("name", null);
+      failBecauseExceptionWasNotThrown(IllegalArgumentException.class);
+    } catch (IllegalArgumentException e) {
+      assertThat(e).hasMessage(format("The expected value should not be null.%n"
+                                      + "If you were trying to filter on a null value, please use filterOnNull(String propertyOrFieldName) instead"));
+    }
+  }
+
+  @Test
+  public void should_fail_if_on_of_the_object_array_element_does_not_have_given_property_or_field() {
+    try {
+      assertThat(employees).filteredOn("secret", not("???"));
+      failBecauseExceptionWasNotThrown(IntrospectionError.class);
+    } catch (IntrospectionError e) {
+      assertThat(e).hasMessageContaining("Can't find any field or property with name 'secret'");
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filtered_baseTest.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filtered_baseTest.java
new file mode 100644
index 000000000..1e088a151
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_filtered_baseTest.java
@@ -0,0 +1,46 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.api.objectarray;
+
+import static org.assertj.core.test.ExpectedException.none;
+
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.test.Name;
+import org.junit.Before;
+import org.junit.Rule;
+
+public class ObjectArrayAssert_filtered_baseTest {
+
+  protected Employee yoda;
+  protected Employee obiwan;
+  protected Employee luke;
+  protected Employee noname;
+  protected Employee[] employees;
+  @Rule
+  public ExpectedException thrown = none();
+
+  @Before
+  public void setUp() {
+    yoda = new Employee(1L, new Name("Yoda"), 800);
+    obiwan = new Employee(2L, new Name("Obi"), 800);
+    luke = new Employee(3L, new Name("Luke", "Skywalker"), 26);
+    noname = new Employee(4L, null, 10);
+    employees = new Employee[] { yoda, luke, obiwan, noname };
+  }
+
+  public ObjectArrayAssert_filtered_baseTest() {
+    super();
+  }
+
+}
\ No newline at end of file
diff --git a/src/test/java/org/assertj/core/groups/Properties_from_with_Collection_Test.java b/src/test/java/org/assertj/core/groups/Properties_from_with_Collection_Test.java
index aef676dad..c1527487d 100644
--- a/src/test/java/org/assertj/core/groups/Properties_from_with_Collection_Test.java
+++ b/src/test/java/org/assertj/core/groups/Properties_from_with_Collection_Test.java
@@ -18,10 +18,9 @@ import static org.mockito.Mockito.*;
 
 import java.util.*;
 
-
 import org.assertj.core.groups.Properties;
-import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.test.*;
+import org.assertj.core.util.introspection.PropertySupport;
 import org.junit.*;
 
 /**
diff --git a/src/test/java/org/assertj/core/groups/Properties_from_with_array_Test.java b/src/test/java/org/assertj/core/groups/Properties_from_with_array_Test.java
index 69300f30f..8fd6acab4 100644
--- a/src/test/java/org/assertj/core/groups/Properties_from_with_array_Test.java
+++ b/src/test/java/org/assertj/core/groups/Properties_from_with_array_Test.java
@@ -16,15 +16,13 @@ import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.util.ArrayWrapperList.wrap;
 import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.Lists.newArrayList;
-
 import static org.mockito.Mockito.*;
 
 import java.util.*;
 
-
 import org.assertj.core.groups.Properties;
-import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.test.*;
+import org.assertj.core.util.introspection.PropertySupport;
 import org.junit.*;
 
 /**
diff --git a/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsOnly_Test.java b/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsOnly_Test.java
index 3a67fb627..90e192d69 100644
--- a/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsOnly_Test.java
+++ b/src/test/java/org/assertj/core/internal/iterables/Iterables_assertContainsOnly_Test.java
@@ -14,7 +14,7 @@ package org.assertj.core.internal.iterables;
 
 import static java.util.Collections.emptyList;
 import static org.assertj.core.error.ShouldContainOnly.shouldContainOnly;
-import static org.assertj.core.test.ErrorMessages.*;
+import static org.assertj.core.test.ErrorMessages.valuesToLookForIsNull;
 import static org.assertj.core.test.ObjectArrays.emptyArray;
 import static org.assertj.core.test.TestData.someInfo;
 import static org.assertj.core.test.TestFailures.failBecauseExpectedAssertionErrorWasNotThrown;
@@ -22,12 +22,10 @@ import static org.assertj.core.util.Arrays.array;
 import static org.assertj.core.util.FailureMessages.actualIsNull;
 import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.Sets.newLinkedHashSet;
-
 import static org.mockito.Mockito.verify;
 
 import java.util.Collection;
 
-
 import org.assertj.core.api.AssertionInfo;
 import org.assertj.core.internal.Iterables;
 import org.assertj.core.internal.IterablesBaseTest;
@@ -75,7 +73,7 @@ public class Iterables_assertContainsOnly_Test extends IterablesBaseTest {
     actual.clear();
     iterables.assertContainsOnly(someInfo(), actual, array());
   }
-  
+
   @Test
   public void should_fail_if_array_of_values_to_look_for_is_empty_and_actual_is_not() {
     thrown.expect(AssertionError.class);
@@ -95,13 +93,42 @@ public class Iterables_assertContainsOnly_Test extends IterablesBaseTest {
   }
 
   @Test
-  public void should_fail_if_actual_does_not_contain_given_values_only() {
+  public void should_fail_if_actual_does_not_contain_all_given_values() {
     AssertionInfo info = someInfo();
     Object[] expected = { "Luke", "Yoda", "Han" };
     try {
       iterables.assertContainsOnly(info, actual, expected);
     } catch (AssertionError e) {
-      verify(failures).failure(info, shouldContainOnly(actual, expected, newLinkedHashSet("Han"), newLinkedHashSet("Leia")));
+      verify(failures).failure(info,
+                               shouldContainOnly(actual, expected, newLinkedHashSet("Han"), newLinkedHashSet("Leia")));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_contains_additional_elements() {
+    AssertionInfo info = someInfo();
+    Object[] expected = { "Luke", "Yoda" };
+    try {
+      iterables.assertContainsOnly(info, actual, expected);
+    } catch (AssertionError e) {
+      verify(failures).failure(info,
+                               shouldContainOnly(actual, expected, newLinkedHashSet(), newLinkedHashSet("Leia")));
+      return;
+    }
+    failBecauseExpectedAssertionErrorWasNotThrown();
+  }
+
+  @Test
+  public void should_fail_if_actual_contains_a_subset_of_expected_elements() {
+    AssertionInfo info = someInfo();
+    Object[] expected = { "Luke", "Yoda", "Obiwan", "Leia" };
+    try {
+      iterables.assertContainsOnly(info, actual, expected);
+    } catch (AssertionError e) {
+      verify(failures).failure(info,
+                               shouldContainOnly(actual, expected, newLinkedHashSet("Obiwan"), newLinkedHashSet()));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
@@ -131,7 +158,7 @@ public class Iterables_assertContainsOnly_Test extends IterablesBaseTest {
   public void should_pass_if_actual_contains_given_values_only_even_if_duplicated_according_to_custom_comparison_strategy() {
     actual.addAll(newArrayList("LUKE"));
     iterablesWithCaseInsensitiveComparisonStrategy.assertContainsOnly(someInfo(), actual,
-        array("LUke", "LUke", "lukE", "YOda", "Leia"));
+                                                                      array("LUke", "LUke", "lukE", "YOda", "Leia"));
   }
 
   @Test
@@ -141,7 +168,9 @@ public class Iterables_assertContainsOnly_Test extends IterablesBaseTest {
     try {
       iterablesWithCaseInsensitiveComparisonStrategy.assertContainsOnly(info, actual, expected);
     } catch (AssertionError e) {
-      verify(failures).failure(info, shouldContainOnly(actual, expected, newLinkedHashSet("Han"), newLinkedHashSet("Leia"), comparisonStrategy));
+      verify(failures).failure(info,
+                               shouldContainOnly(actual, expected, newLinkedHashSet("Han"), newLinkedHashSet("Leia"),
+                                                 comparisonStrategy));
       return;
     }
     failBecauseExpectedAssertionErrorWasNotThrown();
diff --git a/src/test/java/org/assertj/core/test/Employee.java b/src/test/java/org/assertj/core/test/Employee.java
index 2b2bbc423..9dd9242bc 100644
--- a/src/test/java/org/assertj/core/test/Employee.java
+++ b/src/test/java/org/assertj/core/test/Employee.java
@@ -28,6 +28,9 @@ public class Employee {
   public Name surname;
   // keep private to test we are able to read property that is not a public field
   private int age;
+  // keep private to test we are able to read private field without property
+  @SuppressWarnings("unused")
+  private String city = "New York";
 
   public Employee() {}
 
diff --git a/src/test/java/org/assertj/core/test/Player.java b/src/test/java/org/assertj/core/test/Player.java
index a3701f992..66c45f8b6 100644
--- a/src/test/java/org/assertj/core/test/Player.java
+++ b/src/test/java/org/assertj/core/test/Player.java
@@ -25,6 +25,9 @@ public class Player {
   private int assistsPerGame;
   private int reboundsPerGame;
   private String team;
+  // used to test private field access
+  @SuppressWarnings("unused")
+  private int highestScore;
 
   public Player() {}
 
@@ -73,6 +76,10 @@ public class Player {
     this.team = team;
   }
 
+  public void setHighestScore(int highestScore) {
+    this.highestScore = highestScore;
+  }
+
   @Override
   public String toString() {
     return format("%s[%s %s, team=%s]", getClass().getSimpleName(), name.getFirst(), name.getLast(), team);
diff --git a/src/test/java/org/assertj/core/util/introspection/PropertyOrFieldSupport_getValueOf_Test.java b/src/test/java/org/assertj/core/util/introspection/PropertyOrFieldSupport_getValueOf_Test.java
new file mode 100644
index 000000000..9d3b19829
--- /dev/null
+++ b/src/test/java/org/assertj/core/util/introspection/PropertyOrFieldSupport_getValueOf_Test.java
@@ -0,0 +1,191 @@
+/**
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2015 the original author or authors.
+ */
+package org.assertj.core.util.introspection;
+
+import static java.util.Arrays.asList;
+import static org.assertj.core.api.Assertions.assertThat;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import org.assertj.core.test.Employee;
+import org.assertj.core.test.ExpectedException;
+import org.assertj.core.test.Name;
+import org.junit.Before;
+import org.junit.Rule;
+import org.junit.Test;
+
+public class PropertyOrFieldSupport_getValueOf_Test {
+  private static final Employee yoda = new Employee(1L, new Name("Yoda"), 800);
+  private PropertyOrFieldSupport propertyOrFieldSupport;
+
+  @Before
+  public void setup() {
+    propertyOrFieldSupport = PropertyOrFieldSupport.INSTANCE;
+  }
+
+  @Rule
+  public ExpectedException thrown = ExpectedException.none();
+
+  @Test
+  public void should_extract_property_value() {
+    Object value = propertyOrFieldSupport.getValueOf("age", yoda);
+
+    assertThat(value).isEqualTo(800);
+  }
+
+  @Test
+  public void should_extract_property_with_no_corresponding_field() {
+    Object value = propertyOrFieldSupport.getValueOf("adult", yoda);
+
+    assertThat(value).isEqualTo(true);
+  }
+
+  @Test
+  public void should_prefer_properties_over_fields() {
+    Object extractedValue = propertyOrFieldSupport.getValueOf("name", employeeWithOverridenName("Overriden Name"));
+
+    assertThat(extractedValue).isEqualTo(new Name("Overriden Name"));
+  }
+
+  @Test
+  public void should_extract_public_field_values_as_no_property_matches_given_name() {
+    Object value = propertyOrFieldSupport.getValueOf("id", yoda);
+
+    assertThat(value).isEqualTo(1L);
+  }
+
+  @Test
+  public void should_extract_private_field_values_as_no_property_matches_given_name() {
+    Object value = propertyOrFieldSupport.getValueOf("city", yoda);
+
+    assertThat(value).isEqualTo("New York");
+  }
+
+  @Test
+  public void should_fallback_to_field_if_exception_has_been_thrown_on_property_access() {
+    Object extractedValue = propertyOrFieldSupport.getValueOf("name", employeeWithBrokenName("Name"));
+
+    assertThat(extractedValue).isEqualTo(new Name("Name"));
+  }
+
+  @Test
+  public void should_return_null_if_one_of_nested_property_or_field_value_is_null() {
+    Object value = propertyOrFieldSupport.getValueOf("surname.first", yoda);
+
+    assertThat(value).isNull();
+  }
+
+  @Test
+  public void should_extract_nested_property_field_combinations() {
+    Employee darth = new Employee(1L, new Name("Darth", "Vader"), 100);
+    Employee luke = new Employee(2L, new Name("Luke", "Skywalker"), 26);
+    darth.field = luke;
+    luke.field = darth;
+    luke.surname = new Name("Young", "Padawan");
+    Object value = propertyOrFieldSupport.getValueOf("me.field.me.field.me.field.surname.name", darth);
+    assertThat(value).isEqualTo("Young Padawan");
+  }
+
+  @Test
+  public void should_throw_error_when_no_property_nor_field_match_given_name() {
+    thrown.expect(IntrospectionError.class);
+
+    propertyOrFieldSupport.getValueOf("unknown", yoda);
+  }
+
+  @Test
+  public void should_throw_error_when_no_property_nor_public_field_match_given_name_if_extraction_is_limited_to_public_fields() {
+    thrown.expect(IntrospectionError.class);
+
+    propertyOrFieldSupport = new PropertyOrFieldSupport(new PropertySupport(),
+                                                        FieldSupport.EXTRACTION_OF_PUBLIC_FIELD_ONLY);
+
+    propertyOrFieldSupport.getValueOf("city", yoda);
+  }
+
+  @Test
+  public void should_throw_exception_when_given_property_or_field_name_is_null() {
+    thrown.expectIllegalArgumentException("The name of the property/field to read should not be null");
+    propertyOrFieldSupport.getValueOf(null, yoda);
+  }
+
+  @Test
+  public void should_throw_exception_when_given_name_is_empty() {
+    thrown.expectIllegalArgumentException("The name of the property/field to read should not be empty");
+    propertyOrFieldSupport.getValueOf("", yoda);
+  }
+
+  @Test
+  public void should_throw_exception_if_property_cannot_be_extracted_due_to_runtime_exception_during_property_access() {
+    thrown.expect(IntrospectionError.class);
+
+    propertyOrFieldSupport.getValueOf("adult", brokenEmployee());
+  }
+
+  @Test
+  public void should_throw_exception_if_no_object_is_given() {
+    thrown.expect(IllegalArgumentException.class);
+    propertyOrFieldSupport.getValueOf("name", null);
+  }
+
+  @Test
+  public void should_extract_single_value_from_maps_by_key() {
+    String key1 = "key1";
+    String key2 = "key2";
+    Map<String, Employee> map1 = new HashMap<>();
+    map1.put(key1, yoda);
+    Employee luke = new Employee(2L, new Name("Luke"), 22);
+    map1.put(key2, luke);
+
+    Map<String, Employee> map2 = new HashMap<>();
+    map2.put(key1, yoda);
+    Employee han = new Employee(3L, new Name("Han"), 31);
+    map2.put(key2, han);
+
+    List<Map<String, Employee>> maps = asList(map1, map2);
+    assertThat(maps).extracting(key2).containsExactly(luke, han);
+    assertThat(maps).extracting(key2, Employee.class).containsExactly(luke, han);
+    assertThat(maps).extracting(key1).containsExactly(yoda, yoda);
+    assertThat(maps).extracting("bad key").containsExactly(null, null);
+  }
+
+  private Employee employeeWithBrokenName(String name) {
+    return new Employee(1L, new Name(name), 0) {
+      @Override
+      public Name getName() {
+        throw new IllegalStateException();
+      }
+    };
+  }
+
+  private Employee employeeWithOverridenName(final String overridenName) {
+    return new Employee(1L, new Name("Name"), 0) {
+      @Override
+      public Name getName() {
+        return new Name(overridenName);
+      }
+    };
+  }
+
+  private Employee brokenEmployee() {
+    return new Employee() {
+      @Override
+      public boolean isAdult() {
+        throw new IllegalStateException();
+      }
+    };
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_Test.java b/src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_Test.java
index d86085376..95f07009b 100644
--- a/src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_Test.java
@@ -20,7 +20,6 @@ import static org.assertj.core.util.Lists.newArrayList;
 import java.util.Collection;
 import java.util.List;
 
-import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.test.Employee;
 import org.assertj.core.test.ExpectedException;
 import org.assertj.core.test.Name;
diff --git a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java b/src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_with_mocks_Test.java
similarity index 87%
rename from src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
rename to src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_with_mocks_Test.java
index f05c95159..5a5757c82 100644
--- a/src/test/java/org/assertj/core/internal/PropertySupport_propertyValues_with_mocks_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/PropertySupport_propertyValues_with_mocks_Test.java
@@ -10,12 +10,13 @@
  *
  * Copyright 2012-2015 the original author or authors.
  */
-package org.assertj.core.internal;
+package org.assertj.core.util.introspection;
 
+import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.fail;
 import static org.assertj.core.util.Lists.newArrayList;
 import static org.assertj.core.util.introspection.Introspection.getProperty;
-import static org.assertj.core.api.Assertions.fail;
 import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.when;
 
@@ -24,7 +25,6 @@ import java.util.Collection;
 import java.util.List;
 
 import org.assertj.core.test.Name;
-import org.assertj.core.util.introspection.IntrospectionError;
 import org.junit.Before;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -65,9 +65,8 @@ public class PropertySupport_propertyValues_with_mocks_Test {
       propertySupport.propertyValues("age", Long.class, employees);
       fail("expecting an IntrospectionError to be thrown");
     } catch (IntrospectionError expected) {
-      assertThat(expected.getCause()).isSameAs(thrownOnPurpose);
-      String msg = String.format("Unable to obtain the value of the property <'age'> from <%s>", yoda.toString());
-      assertThat(expected.getMessage()).isEqualTo(msg);
+      assertThat(expected).hasCause(thrownOnPurpose)
+                          .hasMessage(format("Unable to obtain the value of the property <'age'> from <%s>", yoda));
     }
   }
 }
diff --git a/src/test/java/org/assertj/core/util/introspection/PropertySupport_publicGetterExistsFor_Test.java b/src/test/java/org/assertj/core/util/introspection/PropertySupport_publicGetterExistsFor_Test.java
index 93003fc7d..08f325302 100644
--- a/src/test/java/org/assertj/core/util/introspection/PropertySupport_publicGetterExistsFor_Test.java
+++ b/src/test/java/org/assertj/core/util/introspection/PropertySupport_publicGetterExistsFor_Test.java
@@ -14,7 +14,6 @@ package org.assertj.core.util.introspection;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-import org.assertj.core.internal.PropertySupport;
 import org.assertj.core.test.Person;
 import org.junit.Before;
 import org.junit.Test;
