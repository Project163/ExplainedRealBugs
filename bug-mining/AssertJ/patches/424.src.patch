diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index 182f465c0..d50e9ca2b 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -861,6 +861,13 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
     return myself;
   }
 
+  /** {@inheritDoc} */
+  @Override
+  public SELF hasExactlyElementsOfTypes(Class<?>... types) {
+    ObjectArrays.instance().assertHasExactlyElementsOfTypes(info, toArray(actual), types);
+    return myself;
+  }
+
   /**
    * {@inheritDoc}
    */
diff --git a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
index 8129bbb54..93c13369c 100644
--- a/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractObjectArrayAssert.java
@@ -985,6 +985,37 @@ public abstract class AbstractObjectArrayAssert<SELF extends AbstractObjectArray
     return myself;
   }
 
+  /**
+   * Verifies that the actual elements are of the given types in the given order, there should be as many expected types as there are actual elements.
+   * <p>
+   * Example:
+   * <pre><code class='java'> Object[] objects = { 1, "a", "b", 1.00 };
+   *
+   * // assertion succeeds
+   * assertThat(objects).hasExactlyElementsOfTypes(Integer.class, String.class, String.class, Double.class);
+   *
+   * // assertions fail
+   * // missing second String type
+   * assertThat(objects).hasExactlyElementsOfTypes(Integer.class, String.class, Double.class);
+   * // no Float type in actual
+   * assertThat(objects).hasExactlyElementsOfTypes(Float.class, String.class, String.class, Double.class);
+   * // correct types but wrong order
+   * assertThat(objects).hasExactlyElementsOfTypes(String.class, Integer.class, String.class, Double.class);
+   * // actual has more elements than the specified expected types
+   * assertThat(objects).hasExactlyElementsOfTypes(String.class);</code></pre>
+   *
+   * @param expectedTypes the expected types
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given type array is {@code null}.
+   * @throws AssertionError if actual is {@code null}.
+   * @throws AssertionError if the actual elements types don't exactly match the given ones (in the given order).
+   */
+  @Override
+  public SELF hasExactlyElementsOfTypes(Class<?>... expectedTypes) {
+    arrays.assertHasExactlyElementsOfTypes(info, actual, expectedTypes);
+    return myself;
+  }
+
   /**
    * Verifies that the actual array does not contain the given object at the given index.
    * <p>
diff --git a/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java b/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
index 9028d4ee9..8cd08f00a 100644
--- a/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
+++ b/src/main/java/org/assertj/core/api/AtomicReferenceArrayAssert.java
@@ -1063,6 +1063,38 @@ public class AtomicReferenceArrayAssert<T>
     return myself;
   }
 
+  /**
+   * Verifies that the actual elements are of the given types in the given order, there should be as many expected types as there are actual elements.
+   * <p>
+   * Example:
+   * <pre><code class='java'> AtomicReferenceArray&lt;Object&gt; objects = new AtomicReferenceArray&lt;&gt;(new Object[] { 1, "a", 1.00 });
+   *
+   * // assertion succeeds
+   * assertThat(objects).hasExactlyElementsOfTypes(Integer.class, String.class, String.class, Double.class);
+   *
+   * // assertions fail
+   * // missing second String type
+   * assertThat(objects).hasExactlyElementsOfTypes(Integer.class, String.class, Double.class);
+   * // no Float type in actual
+   * assertThat(objects).hasExactlyElementsOfTypes(Float.class, String.class, String.class, Double.class);
+   * // correct types but wrong order
+   * assertThat(objects).hasExactlyElementsOfTypes(String.class, Integer.class, String.class, Double.class);
+   * // actual has more elements than the specified expected types
+   * assertThat(objects).hasExactlyElementsOfTypes(String.class);</code></pre>
+   *
+   * @param expectedTypes the expected types
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given type array is {@code null}.
+   * @throws AssertionError if actual is {@code null}.
+   * @throws AssertionError if the actual elements types don't exactly match the given ones (in the given order).
+   */
+  @Override
+  public AtomicReferenceArrayAssert<T> hasExactlyElementsOfTypes(Class<?>... expectedTypes) {
+    arrays.assertHasExactlyElementsOfTypes(info, array, expectedTypes);
+    return myself;
+  }
+
+
   /**
    * Verifies that the actual AtomicReferenceArray does not contain the given object at the given index.
    * <p>
diff --git a/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java b/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
index 9b39f6867..136e4ae5c 100644
--- a/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
+++ b/src/main/java/org/assertj/core/api/ObjectEnumerableAssert.java
@@ -953,14 +953,41 @@ public interface ObjectEnumerableAssert<SELF extends ObjectEnumerableAssert<SELF
    * assertThat(objects).hasOnlyElementsOfTypes(String.class, Number.class);
    * assertThat(objects).hasOnlyElementsOfTypes(String.class);</code></pre>
    *
-   * @param types the expected classes and interfaces
+   * @param expectedTypes the expected types
    * @return {@code this} assertion object.
    * @throws NullPointerException if the given argument is {@code null}.
    * @throws AssertionError if the actual group is {@code null}.
    * @throws AssertionError if not all elements of the actual group are instances of one of the given types
    * @since 2.7.0 / 3.7.0
    */
-  SELF hasOnlyElementsOfTypes(Class<?>... types);
+  SELF hasOnlyElementsOfTypes(Class<?>... expectedTypes);
+
+  /**
+   * Verifies that the actual elements are of the given types in the given order, there should be as many expected types as there are actual elements.
+   * <p>
+   * Example:
+   * <pre><code class='java'> Iterable&lt;Object&gt; list = Arrays.asList(1, "a", "b", 1.00);
+   *
+   * // assertion succeeds
+   * assertThat(list).hasExactlyElementsOfTypes(Integer.class, String.class, String.class, Double.class);
+   *
+   * // assertions fail
+   * // missing second String type
+   * assertThat(list).hasExactlyElementsOfTypes(Integer.class, String.class, Double.class);
+   * // no Float type in actual
+   * assertThat(list).hasExactlyElementsOfTypes(Float.class, String.class, String.class, Double.class);
+   * // correct types but wrong order
+   * assertThat(list).hasExactlyElementsOfTypes(String.class, Integer.class, String.class, Double.class);
+   * // actual has more elements than the specified expected types
+   * assertThat(list).hasExactlyElementsOfTypes(String.class);</code></pre>
+   *
+   * @param expectedTypes the expected types
+   * @return {@code this} assertion object.
+   * @throws NullPointerException if the given type array is {@code null}.
+   * @throws AssertionError if actual is {@code null}.
+   * @throws AssertionError if the actual elements types don't exactly match the given ones (in the given order).
+   */
+  SELF hasExactlyElementsOfTypes(Class<?>... expectedTypes);
 
   /**
    * Verifies that at least one element in the actual {@code Object} group has the specified type (matching
diff --git a/src/main/java/org/assertj/core/error/ShouldHaveExactlyTypes.java b/src/main/java/org/assertj/core/error/ShouldHaveExactlyTypes.java
new file mode 100644
index 000000000..d8d7923f6
--- /dev/null
+++ b/src/main/java/org/assertj/core/error/ShouldHaveExactlyTypes.java
@@ -0,0 +1,74 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static org.assertj.core.util.IterableUtil.isNullOrEmpty;
+
+public class ShouldHaveExactlyTypes extends BasicErrorMessageFactory {
+
+  public static ErrorMessageFactory shouldHaveTypes(Object actual, Iterable<Class<?>> expectedTypes,
+                                                    Iterable<Class<?>> expectedTypesNotFoundInActual,
+                                                    Iterable<Class<?>> actualTypesNotExpected) {
+    if (!isNullOrEmpty(actualTypesNotExpected) && !isNullOrEmpty(expectedTypesNotFoundInActual)) {
+      return new ShouldHaveExactlyTypes(actual, expectedTypes, expectedTypesNotFoundInActual, actualTypesNotExpected);
+    }
+    // empty actualTypesNotExpected means expectedTypesNotFoundInActual is not empty
+    boolean expectedTypesNotFoundInActualOnly = isNullOrEmpty(actualTypesNotExpected);
+    Iterable<Class<?>> diff = expectedTypesNotFoundInActualOnly ? expectedTypesNotFoundInActual : actualTypesNotExpected;
+    return new ShouldHaveExactlyTypes(actual, expectedTypes, diff, expectedTypesNotFoundInActualOnly);
+  }
+
+  public static ErrorMessageFactory elementsTypesDifferAtIndex(Object actualElement, Class<?> expectedElement,
+                                                               int indexOfDifference) {
+    return new ShouldHaveExactlyTypes(actualElement, expectedElement, indexOfDifference);
+  }
+
+  private ShouldHaveExactlyTypes(Object actual, Iterable<Class<?>> expected, Iterable<Class<?>> expectedTypesNotFoundInActual,
+                                 Iterable<Class<?>> actualTypesNotExpected) {
+    super("%n" +
+          "Expecting actual elements:%n" +
+          "  %s%n" +
+          "to have the following types (in this order):%n" +
+          "  %s%n" +
+          "but there were no actual elements with these types:%n" +
+          "  %s%n" +
+          "and these actual elements types were not expected:%n" +
+          "  %s",
+          actual, expected, expectedTypesNotFoundInActual, actualTypesNotExpected);
+  }
+
+  private ShouldHaveExactlyTypes(Object actual, Iterable<Class<?>> expected, Iterable<Class<?>> diff,
+                                 boolean expectedTypesNotFoundInActualOnly) {
+    // @format:off
+    super("%n" +
+          "Expecting actual elements:%n" +
+          "  %s%n" +
+          "to have the following types (in this order):%n" +
+          "  %s%n" +
+          (expectedTypesNotFoundInActualOnly
+              ? "but there were no actual elements with these types"
+              : "but these actual elements types were not expected") + ":%n" +
+          "  %s",
+          actual, expected, diff);
+    // @format:on
+  }
+
+  private ShouldHaveExactlyTypes(Object actualElement, Class<?> expectedType, int indexOfDifference) {
+    super("%n" +
+          "actual element at index %s does not have the expected type, element was:%s%n" +
+          "actual element type: %s%n" +
+          "expected type      : %s",
+          indexOfDifference, actualElement, actualElement.getClass(), expectedType);
+  }
+
+}
diff --git a/src/main/java/org/assertj/core/internal/IterableDiff.java b/src/main/java/org/assertj/core/internal/IterableDiff.java
index 768c4cff5..e40ef6e82 100644
--- a/src/main/java/org/assertj/core/internal/IterableDiff.java
+++ b/src/main/java/org/assertj/core/internal/IterableDiff.java
@@ -19,14 +19,17 @@ import java.util.ArrayList;
 import java.util.List;
 
 // immutable
-class IterableDiff {
+/**
+ * @param T the type of element to compare.
+ */
+class IterableDiff<T> {
 
   private final ComparisonStrategy comparisonStrategy;
 
-  List<Object> unexpected;
-  List<Object> missing;
+  List<T> unexpected;
+  List<T> missing;
 
-  <T> IterableDiff(Iterable<T> actual, Iterable<T> expected, ComparisonStrategy comparisonStrategy) {
+  IterableDiff(Iterable<T> actual, Iterable<T> expected, ComparisonStrategy comparisonStrategy) {
     this.comparisonStrategy = comparisonStrategy;
     // return the elements in actual that are not in expected: actual - expected
     this.unexpected = unexpectedActualElements(actual, expected);
@@ -34,8 +37,12 @@ class IterableDiff {
     this.missing = missingActualElements(actual, expected);
   }
 
-  static <T> IterableDiff diff(Iterable<T> actual, Iterable<T> expected, ComparisonStrategy comparisonStrategy) {
-    return new IterableDiff(actual, expected, comparisonStrategy);
+  static <T> IterableDiff<T> diff(Iterable<T> actual, Iterable<T> expected, ComparisonStrategy comparisonStrategy) {
+    return new IterableDiff<>(actual, expected, comparisonStrategy);
+  }
+
+  static <T> IterableDiff<T> diff(Iterable<T> actual, Iterable<T> expected) {
+    return diff(actual, expected, StandardComparisonStrategy.instance());
   }
 
   boolean differencesFound() {
@@ -45,16 +52,15 @@ class IterableDiff {
   /**
    * Returns the list of elements in the first iterable that are not in the second, i.e. first - second
    *
-   * @param <T> the element type
    * @param actual the list we want to subtract from
    * @param expected the list to subtract
    * @return the list of elements in the first iterable that are not in the second, i.e. first - second
    */
-  private <T> List<Object> unexpectedActualElements(Iterable<T> actual, Iterable<T> expected) {
-    List<Object> missingInFirst = new ArrayList<>();
+  private List<T> unexpectedActualElements(Iterable<T> actual, Iterable<T> expected) {
+    List<T> missingInFirst = new ArrayList<>();
     // use a copy to deal correctly with potential duplicates
     List<T> copyOfExpected = newArrayList(expected);
-    for (Object elementInActual : actual) {
+    for (T elementInActual : actual) {
       if (isActualElementInExpected(elementInActual, copyOfExpected)) {
         // remove the element otherwise a duplicate would be found in the case if there is one in actual
         iterablesRemoveFirst(copyOfExpected, elementInActual);
@@ -65,7 +71,7 @@ class IterableDiff {
     return unmodifiableList(missingInFirst);
   }
 
-  private <T> boolean isActualElementInExpected(Object elementInActual, List<T> copyOfExpected) {
+  private boolean isActualElementInExpected(T elementInActual, List<T> copyOfExpected) {
     // the order of comparisonStrategy.areEqual is important if element comparison is not symmetrical, we must compare actual to
     // expected but not expected to actual, for ex recursive comparison where:
     // - actual element is PersonDto, expected a list of Person
@@ -74,11 +80,11 @@ class IterableDiff {
     return copyOfExpected.stream().anyMatch(expectedElement -> comparisonStrategy.areEqual(elementInActual, expectedElement));
   }
 
-  private <T> List<Object> missingActualElements(Iterable<T> actual, Iterable<T> expected) {
-    List<Object> missingInExpected = new ArrayList<>();
+  private List<T> missingActualElements(Iterable<T> actual, Iterable<T> expected) {
+    List<T> missingInExpected = new ArrayList<>();
     // use a copy to deal correctly with potential duplicates
     List<T> copyOfActual = newArrayList(actual);
-    for (Object expectedElement : expected) {
+    for (T expectedElement : expected) {
       if (iterableContains(copyOfActual, expectedElement)) {
         // remove the element otherwise a duplicate would be found in the case if there is one in actual
         iterablesRemoveFirst(copyOfActual, expectedElement);
@@ -89,11 +95,11 @@ class IterableDiff {
     return unmodifiableList(missingInExpected);
   }
 
-  private boolean iterableContains(Iterable<?> actual, Object expectedElement) {
+  private boolean iterableContains(Iterable<?> actual, T expectedElement) {
     return comparisonStrategy.iterableContains(actual, expectedElement);
   }
 
-  private void iterablesRemoveFirst(Iterable<?> actual, Object value) {
+  private void iterablesRemoveFirst(Iterable<?> actual, T value) {
     comparisonStrategy.iterablesRemoveFirst(actual, value);
   }
 }
diff --git a/src/main/java/org/assertj/core/internal/ObjectArrays.java b/src/main/java/org/assertj/core/internal/ObjectArrays.java
index e10166ace..cf7fc6966 100644
--- a/src/main/java/org/assertj/core/internal/ObjectArrays.java
+++ b/src/main/java/org/assertj/core/internal/ObjectArrays.java
@@ -12,23 +12,33 @@
  */
 package org.assertj.core.internal;
 
-import org.assertj.core.api.ArraySortedAssert;
-import org.assertj.core.api.AssertionInfo;
-import org.assertj.core.api.Condition;
-import org.assertj.core.data.Index;
-import org.assertj.core.util.VisibleForTesting;
-
-import java.util.*;
-
+import static java.util.stream.Collectors.toList;
 import static org.assertj.core.error.ShouldHaveAtLeastOneElementOfType.shouldHaveAtLeastOneElementOfType;
+import static org.assertj.core.error.ShouldHaveExactlyTypes.elementsTypesDifferAtIndex;
+import static org.assertj.core.error.ShouldHaveExactlyTypes.shouldHaveTypes;
 import static org.assertj.core.error.ShouldHaveOnlyElementsOfType.shouldHaveOnlyElementsOfType;
 import static org.assertj.core.error.ShouldNotHaveAnyElementsOfTypes.shouldNotHaveAnyElementsOfTypes;
 import static org.assertj.core.internal.CommonValidations.checkIsNotNullAndNotEmpty;
+import static org.assertj.core.internal.IterableDiff.diff;
+import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Lists.newArrayList;
 
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Stream;
+
+import org.assertj.core.api.ArraySortedAssert;
+import org.assertj.core.api.AssertionInfo;
+import org.assertj.core.api.Condition;
+import org.assertj.core.data.Index;
+import org.assertj.core.util.VisibleForTesting;
+
 /**
  * Reusable assertions for arrays of objects.
- * 
+ *
  * @author Alex Ruiz
  * @author Joel Costigliola
  * @author Nicolas Fran√ßois
@@ -40,7 +50,7 @@ public class ObjectArrays {
 
   /**
    * Returns the singleton instance of this class.
-   * 
+   *
    * @return the singleton instance of this class.
    */
   public static ObjectArrays instance() {
@@ -81,7 +91,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array is {@code null} or empty.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @throws AssertionError if the given array is not {@code null} *and* contains one or more elements.
@@ -92,7 +102,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array is empty.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @throws AssertionError if the given array is {@code null}.
@@ -104,7 +114,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array is not empty.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @throws AssertionError if the given array is {@code null}.
@@ -116,7 +126,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the number of elements in the given array is equal to the expected one.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param expectedSize the expected size of {@code actual}.
@@ -195,7 +205,7 @@ public class ObjectArrays {
 
   /**
    * Assert that the actual array has the same size as the other {@code Iterable}.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given iterable.
    * @param other the group to compare
@@ -209,7 +219,7 @@ public class ObjectArrays {
 
   /**
    * Assert that the actual array has the same size as the other array.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param other the group to compare
@@ -223,7 +233,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array contains the given values, in any order.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param values the values that are expected to be in the given array.
@@ -238,7 +248,7 @@ public class ObjectArrays {
 
   /**
    * Verifies that the given array contains the given object at the given index.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param value the object to look for.
@@ -255,7 +265,7 @@ public class ObjectArrays {
 
   /**
    * Verifies that the given array does not contain the given object at the given index.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param value the object to look for.
@@ -270,7 +280,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array contains only the given values and nothing else, in any order.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param values the values that are expected to be in the given array.
@@ -294,7 +304,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array contains only once the given values.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param values the values that are expected to be in the given array.
@@ -323,7 +333,7 @@ public class ObjectArrays {
 
   /**
    * Verifies that the given array contains the given sequence of objects, without any other objects between them.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param sequence the sequence of objects to look for.
@@ -353,7 +363,7 @@ public class ObjectArrays {
 
   /**
    * Verifies that the given array contains the given subsequence of objects (possibly with other values between them).
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param subsequence the subsequence of objects to look for.
@@ -384,7 +394,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array does not contain the given values.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param values the values that are expected not to be in the given array.
@@ -406,7 +416,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array does not have duplicate values.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @throws NullPointerException if the array of values is {@code null}.
@@ -422,7 +432,7 @@ public class ObjectArrays {
    * Verifies that the given array starts with the given sequence of objects, without any other objects between them.
    * Similar to <code>{@link #assertContainsSequence(AssertionInfo, Object[], Object[])}</code>, but it also verifies
    * that the first element in the sequence is also the first element of the given array.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @param sequence the sequence of objects to look for.
@@ -474,7 +484,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array contains at least a null element.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @throws AssertionError if the given array is {@code null}.
@@ -486,7 +496,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array does not contain null elements.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    * @throws AssertionError if the given array is {@code null}.
@@ -498,7 +508,7 @@ public class ObjectArrays {
 
   /**
    * Assert that each element of given array satisfies the given condition.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -512,7 +522,7 @@ public class ObjectArrays {
 
   /**
    * Assert that each element of given array not satisfies the given condition.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -526,7 +536,7 @@ public class ObjectArrays {
 
   /**
    * Assert that each element of given array satisfies the given condition.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -540,7 +550,7 @@ public class ObjectArrays {
 
   /**
    * Assert that each element of given array not satisfies the given condition.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -554,7 +564,7 @@ public class ObjectArrays {
 
   /**
    * Assert that there are <b>at least</b> <i>n</i> array elements satisfying the given condition.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -569,7 +579,7 @@ public class ObjectArrays {
 
   /**
    * Assert that there are <b>at most</b> <i>n</i> array elements satisfying the given condition.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -584,7 +594,7 @@ public class ObjectArrays {
 
   /**
    * Verifies that there are <b>exactly</b> <i>n</i> array elements satisfying the given condition.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -600,7 +610,7 @@ public class ObjectArrays {
   /**
    * An alias method of {@link #assertAreAtLeast(AssertionInfo, Object[], int, Condition)} to provide a richer fluent
    * api (same logic, only error message differs).
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -616,7 +626,7 @@ public class ObjectArrays {
   /**
    * An alias method of {@link #assertAreAtMost(AssertionInfo, Object[], int, Condition)} to provide a richer fluent api
    * (same logic, only error message differs).
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -632,7 +642,7 @@ public class ObjectArrays {
   /**
    * An alias method of {@link #assertAreExactly(AssertionInfo, Object[], int, Condition)} to provide a richer fluent
    * api (same logic, only error message differs).
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -669,6 +679,23 @@ public class ObjectArrays {
     arrays.assertHasOnlyElementsOfTypes(info, failures, actual, types);
   }
 
+  public <E> void assertHasExactlyElementsOfTypes(AssertionInfo info, E[] actual, Class<?>... expectedTypes) {
+    Objects.instance().assertNotNull(info, actual);
+    List<Class<?>> actualTypeList = Stream.of(actual).map(Object::getClass).collect(toList());
+    IterableDiff<Class<?>> typesDiff = diff(actualTypeList, list(expectedTypes));
+    if (typesDiff.differencesFound()) {
+      throw failures.failure(info, shouldHaveTypes(actual, list(expectedTypes), typesDiff.missing, typesDiff.unexpected));
+    }
+    // actual elements have the expected types but are they in the correct order?
+    int i = 0;
+    for (E actualElement : actual) {
+      if (!java.util.Objects.equals(actualElement.getClass(), expectedTypes[i])) {
+        throw failures.failure(info, elementsTypesDifferAtIndex(actualElement, expectedTypes[i], i));
+      }
+      i++;
+    }
+  }
+
   public <E> void assertDoesNotHaveAnyElementsOfTypes(AssertionInfo info, E[] actual, Class<?>... unexpectedTypes) {
     Objects.instance().assertNotNull(info, actual);
     Map<Class<?>, List<Object>> nonMatchingElementsByType = new LinkedHashMap<>();
@@ -689,7 +716,7 @@ public class ObjectArrays {
 
   /**
    * Concrete implementation of {@link ArraySortedAssert#isSorted()}.
-   * 
+   *
    * @param info contains information about the assertion.
    * @param actual the given array.
    */
@@ -699,7 +726,7 @@ public class ObjectArrays {
 
   /**
    * Concrete implementation of {@link ArraySortedAssert#isSortedAccordingTo(Comparator)}.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
@@ -712,7 +739,7 @@ public class ObjectArrays {
 
   /**
    * Asserts that the given array contains all the elements of the given {@code Iterable}, in any order.
-   * 
+   *
    * @param <E> element type
    * @param info contains information about the assertion.
    * @param actual the given array.
diff --git a/src/test/java/org/assertj/core/api/WithAssertions_delegation_Test.java b/src/test/java/org/assertj/core/api/WithAssertions_delegation_Test.java
index 68be886aa..efd800e0b 100644
--- a/src/test/java/org/assertj/core/api/WithAssertions_delegation_Test.java
+++ b/src/test/java/org/assertj/core/api/WithAssertions_delegation_Test.java
@@ -820,6 +820,7 @@ class WithAssertions_delegation_Test implements WithAssertions {
   void withAssertions_registerCustomDateFormat_Test() {
     registerCustomDateFormat("YYYY-MMMM-dddd");
     registerCustomDateFormat(DateFormat.getInstance());
+    useDefaultDateFormatsOnly();
   }
 
   /**
diff --git a/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_hasExactlyElementsOfTypes_Test.java b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_hasExactlyElementsOfTypes_Test.java
new file mode 100644
index 000000000..3f9b89d7f
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/atomic/referencearray/AtomicReferenceArrayAssert_hasExactlyElementsOfTypes_Test.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.atomic.referencearray;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AtomicReferenceArrayAssert;
+import org.assertj.core.api.AtomicReferenceArrayAssertBaseTest;
+
+/**
+ * Tests for <code>{@link AtomicReferenceArrayAssert#hasExactlyElementsOfTypes(Class...)} </code>.
+ */
+class AtomicReferenceArrayAssert_hasExactlyElementsOfTypes_Test extends AtomicReferenceArrayAssertBaseTest {
+
+  private final Class<?>[] types = { Short.class };
+
+  @Override
+  protected AtomicReferenceArrayAssert<Object> invoke_api_method() {
+    return assertions.hasExactlyElementsOfTypes(types);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(arrays).assertHasExactlyElementsOfTypes(getInfo(assertions), internalArray(), types);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasExactlyElementsOfTypes_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasExactlyElementsOfTypes_Test.java
new file mode 100644
index 000000000..48d994415
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_hasExactlyElementsOfTypes_Test.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.AbstractIterableAssert;
+import org.assertj.core.api.ObjectArrayAssert;
+import org.assertj.core.api.ObjectArrayAssertBaseTest;
+
+/**
+ * Tests for <code>{@link AbstractIterableAssert#hasExactlyElementsOfTypes(Class...)}</code>.
+ */
+class IterableAssert_hasExactlyElementsOfTypes_Test extends ObjectArrayAssertBaseTest {
+
+  @Override
+  protected ObjectArrayAssert<Object> invoke_api_method() {
+    return assertions.hasExactlyElementsOfTypes(Integer.class, Double.class);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(arrays).assertHasExactlyElementsOfTypes(getInfo(assertions), getActual(assertions), Integer.class, Double.class);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasExactlyElementsOfTypes_Test.java b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasExactlyElementsOfTypes_Test.java
new file mode 100644
index 000000000..aaa0a5c8c
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/objectarray/ObjectArrayAssert_hasExactlyElementsOfTypes_Test.java
@@ -0,0 +1,36 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.api.objectarray;
+
+import static org.mockito.Mockito.verify;
+
+import org.assertj.core.api.ObjectArrayAssert;
+import org.assertj.core.api.ObjectArrayAssertBaseTest;
+
+/**
+ * Tests for <code>{@link ObjectArrayAssert#hasExactlyElementsOfTypes(Class...)} </code>.
+ */
+class ObjectArrayAssert_hasExactlyElementsOfTypes_Test extends ObjectArrayAssertBaseTest {
+
+  private final Class<?>[] types = { Integer.class };
+
+  @Override
+  protected ObjectArrayAssert<Object> invoke_api_method() {
+    return assertions.hasExactlyElementsOfTypes(types);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    verify(arrays).assertHasExactlyElementsOfTypes(getInfo(assertions), getActual(assertions), types);
+  }
+}
diff --git a/src/test/java/org/assertj/core/error/ShouldHaveExactlyTypes_create_Test.java b/src/test/java/org/assertj/core/error/ShouldHaveExactlyTypes_create_Test.java
new file mode 100644
index 000000000..facb1df1f
--- /dev/null
+++ b/src/test/java/org/assertj/core/error/ShouldHaveExactlyTypes_create_Test.java
@@ -0,0 +1,98 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.error;
+
+import static java.lang.String.format;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldHaveExactlyTypes.elementsTypesDifferAtIndex;
+import static org.assertj.core.error.ShouldHaveExactlyTypes.shouldHaveTypes;
+import static org.assertj.core.util.Lists.list;
+
+import org.assertj.core.description.TextDescription;
+import org.junit.jupiter.api.Test;
+
+class ShouldHaveExactlyTypes_create_Test {
+
+  @Test
+  void should_display_missing_and_unexpected_elements_types() {
+    // GIVEN
+    ErrorMessageFactory factory = shouldHaveTypes(list("Yoda", 123),
+                                                       list(String.class, Double.class),
+                                                       list(Double.class),
+                                                       list(Integer.class));
+    // WHEN
+    String message = factory.create(new TextDescription("Test"));
+    // THEN
+    then(message).isEqualTo(format("[Test] %n"
+                                   + "Expecting actual elements:%n"
+                                   + "  [\"Yoda\", 123]%n"
+                                   + "to have the following types (in this order):%n"
+                                   + "  [java.lang.String, java.lang.Double]%n"
+                                   + "but there were no actual elements with these types:%n"
+                                   + "  [java.lang.Double]%n"
+                                   + "and these actual elements types were not expected:%n"
+                                   + "  [java.lang.Integer]"));
+  }
+
+  @Test
+  void should_not_display_missing_elements_types_when_there_are_none() {
+    // GIVEN
+    ErrorMessageFactory factory = shouldHaveTypes(list("Yoda", 123),
+                                                       list(String.class, String.class),
+                                                       list(),
+                                                       list(Integer.class));
+    // WHEN
+    String message = factory.create(new TextDescription("Test"));
+    // THEN
+    then(message).isEqualTo(format("[Test] %n"
+                                   + "Expecting actual elements:%n"
+                                   + "  [\"Yoda\", 123]%n"
+                                   + "to have the following types (in this order):%n"
+                                   + "  [java.lang.String, java.lang.String]%n"
+                                   + "but these actual elements types were not expected:%n"
+                                   + "  [java.lang.Integer]"));
+  }
+
+  @Test
+  void should_not_display_unexpected_elements_types_when_there_are_none() {
+    // GIVEN
+    ErrorMessageFactory factory = shouldHaveTypes(list("Yoda", 123, 456),
+                                                       list(String.class, Integer.class, Double.class),
+                                                       list(Double.class),
+                                                       list());
+    // WHEN
+    String message = factory.create(new TextDescription("Test"));
+    // THEN
+    then(message).isEqualTo(format("[Test] %n"
+                                   + "Expecting actual elements:%n"
+                                   + "  [\"Yoda\", 123, 456]%n"
+                                   + "to have the following types (in this order):%n"
+                                   + "  [java.lang.String, java.lang.Integer, java.lang.Double]%n"
+                                   + "but there were no actual elements with these types:%n"
+                                   + "  [java.lang.Double]"));
+  }
+
+  @Test
+  void should_display_first_wrong_element_type_when_only_elements_types_order_differs() {
+    // GIVEN
+    ErrorMessageFactory factory = elementsTypesDifferAtIndex("Luke", Double.class, 1);
+    // WHEN
+    String message = factory.create(new TextDescription("Test"));
+    // THEN
+    then(message).isEqualTo(format("[Test] %n" +
+                                   "actual element at index 1 does not have the expected type, element was:\"Luke\"%n" +
+                                   "actual element type: java.lang.String%n" +
+                                   "expected type      : java.lang.Double"));
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasExactlyElementsOfTypes_Test.java b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasExactlyElementsOfTypes_Test.java
new file mode 100644
index 000000000..8a5340421
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/objectarrays/ObjectArrays_assertHasExactlyElementsOfTypes_Test.java
@@ -0,0 +1,134 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2021 the original author or authors.
+ */
+package org.assertj.core.internal.objectarrays;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.error.ShouldHaveExactlyTypes.elementsTypesDifferAtIndex;
+import static org.assertj.core.error.ShouldHaveExactlyTypes.shouldHaveTypes;
+import static org.assertj.core.test.TestData.someInfo;
+import static org.assertj.core.util.AssertionsUtil.expectAssertionError;
+import static org.assertj.core.util.FailureMessages.actualIsNull;
+import static org.assertj.core.util.Lists.list;
+
+import java.util.LinkedList;
+
+import org.assertj.core.api.WritableAssertionInfo;
+import org.assertj.core.internal.ObjectArraysBaseTest;
+import org.junit.jupiter.api.Test;
+
+class ObjectArrays_assertHasExactlyElementsOfTypes_Test extends ObjectArraysBaseTest {
+
+  private static final WritableAssertionInfo INFO = someInfo();
+
+  private static final Object[] ACTUAL = { "a", new LinkedList<>(), 10L };
+
+  @Test
+  void should_pass_if_actual_has_exactly_elements_of_the_expected_types_in_order() {
+    arrays.assertHasExactlyElementsOfTypes(INFO, ACTUAL, String.class, LinkedList.class, Long.class);
+  }
+
+  @Test
+  void should_fail_if_actual_is_null() {
+    // GIVEN
+    Object[] array = null;
+    // WHEN
+    AssertionError error = expectAssertionError(() -> arrays.assertHasExactlyElementsOfTypes(INFO, array, String.class));
+    // THEN
+    then(error).hasMessage(actualIsNull());
+  }
+
+  @Test
+  void should_fail_if_one_element_in_actual_does_not_have_the_expected_type() {
+    // GIVEN
+    Class<?>[] expected = { String.class, LinkedList.class, Double.class };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> arrays.assertHasExactlyElementsOfTypes(INFO, ACTUAL, expected));
+    // THEN
+    then(error).hasMessage(shouldHaveTypes(ACTUAL, list(expected), list(Double.class), list(Long.class)).create());
+  }
+
+  @Test
+  void should_fail_if_types_of_elements_are_not_in_the_same_order_as_expected() {
+    // GIVEN
+    Class<?>[] expected = { LinkedList.class, String.class, Long.class };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> arrays.assertHasExactlyElementsOfTypes(INFO, ACTUAL, expected));
+    // THEN
+    then(error).hasMessage(elementsTypesDifferAtIndex(ACTUAL[0], LinkedList.class, 0).create());
+  }
+
+  @Test
+  void should_fail_if_actual_has_more_elements_than_expected() {
+    // GIVEN
+    Class<?>[] expected = { String.class };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> arrays.assertHasExactlyElementsOfTypes(INFO, ACTUAL, expected));
+    // THEN
+    then(error).hasMessage(shouldHaveTypes(ACTUAL, list(expected), list(), list(LinkedList.class, Long.class)).create());
+  }
+
+  @Test
+  void should_fail_if_actual_elements_types_are_found_but_there_are_not_enough_expected_type_elements() {
+    // GIVEN
+    Class<?>[] expected = { String.class, LinkedList.class, Long.class, Long.class };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> arrays.assertHasExactlyElementsOfTypes(INFO, ACTUAL, expected));
+    // THEN
+    then(error).hasMessage(shouldHaveTypes(ACTUAL, list(expected), list(Long.class), list()).create());
+  }
+
+  // ------------------------------------------------------------------------------------------------------------------
+  // tests using a custom comparison strategy
+  // ------------------------------------------------------------------------------------------------------------------
+
+  @Test
+  void should_pass_if_actual_has_exactly_elements_of_the_expected_types_whatever_the_custom_comparison_strategy_is() {
+    arraysWithCustomComparisonStrategy.assertHasExactlyElementsOfTypes(INFO, ACTUAL, String.class, LinkedList.class, Long.class);
+  }
+
+  @Test
+  void should_fail_if_one_element_in_actual_does_not_have_the_expected_type_whatever_the_custom_comparison_strategy_is() {
+    // GIVEN
+    Class<?>[] expected = { String.class, LinkedList.class, Double.class };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> arraysWithCustomComparisonStrategy.assertHasExactlyElementsOfTypes(INFO,
+                                                                                                                         ACTUAL,
+                                                                                                                         expected));
+    // THEN
+    then(error).hasMessage(shouldHaveTypes(ACTUAL, list(expected), list(Double.class), list(Long.class)).create());
+  }
+
+  @Test
+  void should_fail_if_types_of_elements_are_not_in_the_same_order_as_expected_whatever_the_custom_comparison_strategy_is() {
+    // GIVEN
+    Class<?>[] expected = { LinkedList.class, String.class, Long.class };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> arraysWithCustomComparisonStrategy.assertHasExactlyElementsOfTypes(INFO,
+                                                                                                                         ACTUAL,
+                                                                                                                         expected));
+    // THEN
+    then(error).hasMessage(elementsTypesDifferAtIndex(ACTUAL[0], LinkedList.class, 0).create());
+  }
+
+  @Test
+  void should_fail_if_actual_elements_types_are_found_but_there_are_not_enough_expected_type_elements_whatever_the_custom_comparison_strategy_is() {
+    // GIVEN
+    Class<?>[] expected = { String.class, LinkedList.class, Long.class, Long.class };
+    // WHEN
+    AssertionError error = expectAssertionError(() -> arraysWithCustomComparisonStrategy.assertHasExactlyElementsOfTypes(INFO,
+                                                                                                                         ACTUAL,
+                                                                                                                         expected));
+    // THEN
+    then(error).hasMessage(shouldHaveTypes(ACTUAL, list(expected), list(Long.class), list()).create());
+  }
+}
