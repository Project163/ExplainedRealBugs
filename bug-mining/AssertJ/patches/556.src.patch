diff --git a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 47a6c31ec..4b0538800 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -1421,6 +1421,37 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
     return myself;
   }
 
+  /**
+   * Makes the recursive comparison to consider empty and null iterables as equal.
+   * <p>
+   * Example:
+   * <pre><code class='java'> class Person {
+   *   String name;
+   *   List&lt;Person&gt; friends;
+   * }
+   *
+   * Person person1 = new Person("John Doe");
+   * person1.friends = null;
+   * Person person2 = new Person("John Doe");
+   * person2.friends = new ArrayList&lt;&gt;();
+   *
+   * // assertion succeeds as the friend field values (null vs empty list) are considered equal
+   * assertThat(person1).usingRecursiveComparison()
+   *                    .treatingNullAndEmptyIterablesAsEqual()
+   *                    .isEqualTo(person2);
+   *
+   * // assertion fails as the friend field values are different (null vs empty list)
+   * assertThat(person1).usingRecursiveComparison()
+   *                    .isEqualTo(person2);</code></pre>
+   *
+   * @return this {@link RecursiveComparisonAssert} to chain other methods.
+   */
+  @CheckReturnValue
+  public SELF treatingNullAndEmptyIterablesAsEqual() {
+    recursiveComparisonConfiguration.treatNullAndEmptyIterablesAsEqual();
+    return myself;
+  }
+
   /**
    * Makes the recursive comparison to check that actual's type is compatible with expected's type (and do the same for each field). <br>
    * Compatible means that the expected's type is the same or a subclass of actual's type.
@@ -1914,4 +1945,5 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
   private List<ComparisonDifference> determineDifferencesWith(Object expected) {
     return recursiveComparisonDifferenceCalculator.determineDifferences(actual, expected, recursiveComparisonConfiguration);
   }
+
 }
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 5c7723e46..ce81c442f 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -76,6 +76,7 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
   private boolean ignoreArrayOrder = false;
   private Set<String> ignoredCollectionOrderInFields = new LinkedHashSet<>();
   private final List<Pattern> ignoredCollectionOrderInFieldsMatchingRegexes = new ArrayList<>();
+  private boolean treatingNullAndEmptyCollectionsAsEqual = false;
 
   // registered comparators section
   private TypeComparators typeComparators = defaultTypeComparators();
@@ -442,6 +443,19 @@ public class RecursiveComparisonConfiguration extends AbstractRecursiveOperation
     return ignoredCollectionOrderInFieldsMatchingRegexes;
   }
 
+  public boolean isTreatingNullAndEmptyIterablesAsEqualEnabled() {
+    return treatingNullAndEmptyCollectionsAsEqual;
+  }
+
+  /**
+   * Makes the recursive comparison to consider empty and null iterables as equal.
+   * <p>
+   * See {@link RecursiveComparisonAssert#treatingNullAndEmptyIterablesAsEqual()} for examples.
+   */
+  public void treatNullAndEmptyIterablesAsEqual() {
+    treatingNullAndEmptyCollectionsAsEqual = true;
+  }
+
   /**
    * Registers the given {@link Comparator} to compare the fields with the given type.
    * <p>
diff --git a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
index 18f8d87d4..015337049 100644
--- a/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
+++ b/assertj-core/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonDifferenceCalculator.java
@@ -21,6 +21,7 @@ import static java.util.stream.StreamSupport.stream;
 import static org.assertj.core.api.recursive.comparison.ComparisonDifference.rootComparisonDifference;
 import static org.assertj.core.api.recursive.comparison.DualValue.DEFAULT_ORDERED_COLLECTION_TYPES;
 import static org.assertj.core.api.recursive.comparison.FieldLocation.rootFieldLocation;
+import static org.assertj.core.util.IterableUtil.isNullOrEmpty;
 import static org.assertj.core.util.IterableUtil.sizeOf;
 import static org.assertj.core.util.Lists.list;
 import static org.assertj.core.util.Sets.newHashSet;
@@ -290,6 +291,19 @@ public class RecursiveComparisonDifferenceCalculator {
 
       if (actualFieldValue == expectedFieldValue) continue;
 
+      if (recursiveComparisonConfiguration.isTreatingNullAndEmptyIterablesAsEqualEnabled()
+          && (actualFieldValue == null || dualValue.isActualFieldAnIterable())
+          && (expectedFieldValue == null || dualValue.isExpectedFieldAnIterable())
+          && isNullOrEmpty((Iterable<?>) dualValue.actual)
+          && isNullOrEmpty((Iterable<?>) dualValue.expected)) {
+        // we know one of the value is not null since actualFieldValue != expectedFieldValue and is an iterable
+        // if the other value is null, we can't know if it was an iterable, we just assume so, this is true if actual
+        // and expected root values had the same type, but could be false if the types are different and both have a
+        // field with the same name but the field type is not an iterable in one of them.
+        // TODO add type to introspection strategy ?
+        continue;
+      }
+
       if (actualFieldValue == null || expectedFieldValue == null) {
         // one of the value is null while the other is not as we already know that actualFieldValue != expectedFieldValue
         comparisonState.addDifference(dualValue);
diff --git a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
index c45e8bfe5..f92fefcde 100644
--- a/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
+++ b/assertj-tests/assertj-integration-tests/assertj-core-tests/src/test/java/org/assertj/tests/core/api/recursive/comparison/fields/RecursiveComparisonAssert_isEqualTo_with_iterables_Test.java
@@ -15,6 +15,7 @@ package org.assertj.tests.core.api.recursive.comparison.fields;
 import static com.google.common.collect.Sets.newHashSet;
 import static java.lang.String.format;
 import static java.util.Collections.emptyList;
+import static java.util.Collections.emptySet;
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.assertj.core.api.Assertions.catchThrowable;
 import static org.assertj.core.api.Assertions.tuple;
@@ -27,8 +28,10 @@ import static org.assertj.tests.core.api.recursive.data.Author.authorsTreeSet;
 import static org.assertj.tests.core.util.AssertionsUtil.expectAssertionError;
 
 import java.util.Collection;
+import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
+import java.util.TreeSet;
 import java.util.UnknownFormatConversionException;
 import java.util.stream.Stream;
 
@@ -47,11 +50,11 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends WithCompar
   @MethodSource
   void should_pass_when_comparing_same_collection_fields(Collection<Author> authors1, Collection<Author> authors2) {
     // GIVEN
-    WithCollection<Author> actual = new WithCollection<>(authors1);
-    WithCollection<Author> expected = new WithCollection<>(authors2);
+    WithIterable<Author> actual = new WithIterable<>(authors1);
+    WithIterable<Author> expected = new WithIterable<>(authors2);
     // THEN
-    assertThat(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
-                      .isEqualTo(expected);
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .isEqualTo(expected);
   }
 
   static Stream<Arguments> should_pass_when_comparing_same_collection_fields() {
@@ -94,8 +97,8 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends WithCompar
   void should_fail_when_comparing_different_collection_fields(Collection<Author> authors1, Collection<Author> authors2,
                                                               ComparisonDifference difference) {
     // GIVEN
-    WithCollection<Author> actual = new WithCollection<>(authors1);
-    WithCollection<Author> expected = new WithCollection<>(authors2);
+    WithIterable<Author> actual = new WithIterable<>(authors1);
+    WithIterable<Author> expected = new WithIterable<>(authors2);
     // WHEN/THEN
     compareRecursivelyFailsWithDifferences(actual, expected, difference);
   }
@@ -150,7 +153,7 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends WithCompar
                                                            String path, Object value1, Object value2, String desc) {
     // GIVEN
     WithObject actual = new WithObject(actualFieldValue);
-    WithCollection<Author> expected = new WithCollection<>(expectedFieldValue);
+    WithIterable<Author> expected = new WithIterable<>(expectedFieldValue);
     // WHEN/THEN
     ComparisonDifference difference = desc == null ? diff(path, value1, value2) : diff(path, value1, value2, desc);
     compareRecursivelyFailsWithDifferences(actual, expected, difference);
@@ -203,16 +206,16 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends WithCompar
     then(thrown).isNotInstanceOf(UnknownFormatConversionException.class);
   }
 
-  public static class WithCollection<E> {
-    public Collection<E> group;
+  public static class WithIterable<E> {
+    public Iterable<E> group;
 
-    public WithCollection(Collection<E> collection) {
-      this.group = collection;
+    public WithIterable(Iterable<E> iterable) {
+      this.group = iterable;
     }
 
     @Override
     public String toString() {
-      return "WithCollection group=%s".formatted(group);
+      return "WithIterable(%s)".formatted(group);
     }
 
   }
@@ -233,4 +236,31 @@ class RecursiveComparisonAssert_isEqualTo_with_iterables_Test extends WithCompar
     then(assertionError).hasMessageContaining(format("The following expected elements were not matched in the actual HashSet:%n" +
                                                      "  [Item(Shoes, 2)]"));
   }
+
+  @ParameterizedTest
+  @MethodSource
+  void should_treat_null_and_empty_iterables_as_equal(Iterable<?> iterable1, Iterable<?> iterable2) {
+    // GIVEN
+    WithIterable<?> actual = new WithIterable<>(iterable1);
+    WithIterable<?> expected = new WithIterable<>(iterable2);
+    // THEN
+    then(actual).usingRecursiveComparison(recursiveComparisonConfiguration)
+                .treatingNullAndEmptyIterablesAsEqual()
+                .isEqualTo(expected);
+  }
+
+  static Stream<Arguments> should_treat_null_and_empty_iterables_as_equal() {
+    List<Author> emptyList = emptyList();
+    Set<Author> emptySet = emptySet();
+    Set<String> emptyTreeSet = new TreeSet<>();
+    Set<String> emptyHashSet = new HashSet<>();
+    return Stream.of(Arguments.of(null, emptyList),
+                     Arguments.of(emptyList, null),
+                     Arguments.of(null, emptySet),
+                     Arguments.of(emptySet, null),
+                     Arguments.of(null, emptyHashSet),
+                     Arguments.of(emptyHashSet, null),
+                     Arguments.of(null, emptyTreeSet),
+                     Arguments.of(emptyTreeSet, null));
+  }
 }
