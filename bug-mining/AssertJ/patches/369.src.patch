diff --git a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
index c216ac869..2fa9e6b4f 100644
--- a/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
+++ b/src/main/java/org/assertj/core/api/AbstractIterableAssert.java
@@ -60,6 +60,7 @@ import org.assertj.core.groups.Tuple;
 import org.assertj.core.internal.CommonErrors;
 import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
 import org.assertj.core.internal.ComparisonStrategy;
+import org.assertj.core.internal.ConfigurableRecursiveFieldByFieldComparator;
 import org.assertj.core.internal.ExtendedByTypesComparator;
 import org.assertj.core.internal.FieldByFieldComparator;
 import org.assertj.core.internal.IgnoringFieldsComparator;
@@ -1925,9 +1926,121 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
                                                                                      getComparatorsForElementPropertyOrFieldTypes()));
   }
 
+  /**
+   * Enable using a recursive field by field comparison strategy similar to {@link #usingRecursiveComparison()} but contrary to the latter <b>you can chain any iterable assertions after this method</b> (this is why this method exists).
+   * <p>
+   * The given {@link RecursiveComparisonConfiguration} is used to tweak the comparison behavior, for example by {@link RecursiveComparisonConfiguration#ignoreCollectionOrder(boolean) ignoring collection order}.
+   * <p>
+   * <b>Warning:</b> the comparison won't use any comparators set with:
+   * <ul>
+   *   <li>{@link #usingComparatorForType(Comparator, Class)}</li>
+   *   <li>{@link #withTypeComparators(TypeComparators)}</li>
+   *   <li>{@link #usingComparatorForElementFieldsWithType(Comparator, Class)}</li>
+   *   <li>{@link #withComparatorsForElementPropertyOrFieldTypes(TypeComparators)}</li>
+   *   <li>{@link #usingComparatorForElementFieldsWithNames(Comparator, String...)}</li>
+   *   <li>{@link #withComparatorsForElementPropertyOrFieldNames(Map)}</li>
+   * </ul>
+   * <p>
+   * These features (and many more) are provided through {@link RecursiveComparisonConfiguration} with:
+   * <ul>
+   *   <li>{@link RecursiveComparisonConfiguration#registerComparatorForType(Comparator, Class) registerComparatorForType(Comparator, Class)} / {@link RecursiveComparisonConfiguration.Builder#withComparatorForType(Comparator, Class) withComparatorForType(Comparator, Class)} (using {@link RecursiveComparisonConfiguration.Builder})</li>
+   *   <li>{@link RecursiveComparisonConfiguration#registerComparatorForFields(Comparator, String...) registerComparatorForFields(Comparator comparator, String... fields)} / {@link RecursiveComparisonConfiguration.Builder#withComparatorForFields(Comparator, String...) withComparatorForField(Comparator comparator, String... fields)} (using {@link RecursiveComparisonConfiguration.Builder})</li>
+   * </ul>
+   * <p>
+   * RecursiveComparisonConfiguration exposes a {@link RecursiveComparisonConfiguration.Builder builder} to ease setting the comparison behaviour,
+   * call {@link RecursiveComparisonConfiguration#builder() RecursiveComparisonConfiguration.builder()} to start building your configuration.
+   * <p>
+   * There are differences between this approach and {@link #usingRecursiveComparison()}:
+   * <ul>
+   *   <li>contrary to {@link RecursiveComparisonAssert}, you can chain any iterable assertions after this method.</li>
+   *   <li>no comparators registered with {@link AbstractIterableAssert#usingComparatorForType(Comparator, Class)} will be used, you need to register them in the configuration object.</li>
+   *   <li>the assertion errors won't be as detailed as {@link RecursiveComparisonAssert#isEqualTo(Object)} which shows the field differences.</li>
+   * </ul>
+   * <p>
+   * This last point makes sense, take the {@link #contains(Object...)} assertion, it would not be relevant to report the differences of all the iterable's elements differing from the values to look for.
+   * <p>
+   * Example:
+   * <pre><code class='java'> public class Person {
+   *   String name;
+   *   boolean hasPhd;
+   * }
+   *
+   * public class Doctor {
+   *  String name;
+   *  boolean hasPhd;
+   * }
+   *
+   * Doctor drSheldon = new Doctor("Sheldon Cooper", true);
+   * Doctor drLeonard = new Doctor("Leonard Hofstadter", true);
+   * Doctor drRaj = new Doctor("Raj Koothrappali", true);
+   *
+   * Person sheldon = new Person("Sheldon Cooper", false);
+   * Person leonard = new Person("Leonard Hofstadter", false);
+   * Person raj = new Person("Raj Koothrappali", false);
+   * Person howard = new Person("Howard Wolowitz", false);
+   *
+   * List&lt;Doctor&gt; doctors = Arrays.asList(drSheldon, drLeonard, drRaj);
+   * List&lt;Person&gt; people = Arrays.asList(sheldon, leonard, raj);
+   *
+   * RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+   *                                                                                  .withIgnoredFieldsâ€‹("hasPhd");
+   *
+   * // assertion succeeds as both lists contains equivalent items in order.
+   * assertThat(doctors).usingConfigurableRecursiveFieldByFieldElementComparator(configuration)
+   *                    .contains(sheldon);
+   *
+   * // assertion fails because leonard names are different.
+   * leonard.setName("Leonard Ofstater");
+   * assertThat(doctors).usingRecursiveComparison()
+   *                    .contains(leonard);
+   *
+   * // assertion fails because howard is missing and leonard is not expected.
+   * people = Arrays.asList(howard, sheldon, raj)
+   * assertThat(doctors).usingRecursiveComparison()
+   *                    .contains(howard);</code></pre>
+   *
+   * A detailed documentation for the recursive comparison is available here: <a href="https://assertj.github.io/doc/#assertj-core-recursive-comparison">https://assertj.github.io/doc/#assertj-core-recursive-comparison</a>.
+   * <p>
+   * The default recursive comparison behavior is {@link RecursiveComparisonConfiguration configured} as follows:
+   * <ul>
+   *   <li> different types of iterable can be compared by default, this allows to compare for example an {@code List<Person>} and a {@code LinkedHashSet<PersonDto>}.<br>
+   *        This behavior can be turned off by calling {@link RecursiveComparisonAssert#withStrictTypeChecking() withStrictTypeChecking}.</li>
+   *   <li>overridden equals methods are used in the comparison (unless stated otherwise - see <a href="https://assertj.github.io/doc/#assertj-core-recursive-comparison-ignoring-equals">https://assertj.github.io/doc/#assertj-core-recursive-comparison-ignoring-equals</a>)</li>
+   *   <li>the following types are compared with these comparators:
+   *     <ul>
+   *       <li>{@code java.lang.Double}: {@code DoubleComparator} with precision of 1.0E-15</li>
+   *       <li>{@code java.lang.Float}: {@code FloatComparator }with precision of 1.0E-6</li>
+   *     </ul>
+   *   </li>
+   * </ul>
+   * <p>
+   * Another point worth mentionning: <b>elements order does matter if the expected iterable is ordered</b>, for example comparing a {@code Set<Person>} to a {@code List<Person>} fails as {@code List} is ordered and {@code Set} is not.<br>
+   * The ordering can be ignored by calling {@link RecursiveComparisonAssert#ignoringCollectionOrder ignoringCollectionOrder} allowing ordered/unordered iterable comparison, note that {@link RecursiveComparisonAssert#ignoringCollectionOrder ignoringCollectionOrder} is applied recursively on any nested iterable fields, if this behavior is too generic,
+   * use the more fine grained {@link RecursiveComparisonAssert#ignoringCollectionOrderInFields(String...) ignoringCollectionOrderInFields} or
+   * {@link RecursiveComparisonAssert#ignoringCollectionOrderInFieldsMatchingRegexes(String...) ignoringCollectionOrderInFieldsMatchingRegexes}.
+   *
+   * @param configuration the recursive comparison configuration.
+   *
+   * @return {@code this} assertion object.
+   * @since 3.17.0
+   * @see RecursiveComparisonConfiguration
+   */
+  public SELF usingRecursiveFieldByFieldElementComparator(RecursiveComparisonConfiguration configuration) {
+    return usingElementComparator(new ConfigurableRecursiveFieldByFieldComparator(configuration));
+  }
+
   /**
    * Enable using a recursive field by field comparison strategy when calling the chained {@link RecursiveComparisonAssert},
    * <p>
+   * There are differences between this approach and {@link #usingRecursiveFieldByFieldElementComparator(RecursiveComparisonConfiguration)}:
+   * <ul>
+   *   <li>you can only chain {@link RecursiveComparisonAssert} assertions (basically {@link RecursiveComparisonAssert#isEqualTo(Object) isEqualTo}), no iterable assertions.</li>
+   *   <li>{@link RecursiveComparisonAssert#isEqualTo(Object) isEqualTo} assertion error will report all field differences (very detailed).</li>
+   *   <li>no comparators registered with {@link AbstractIterableAssert#usingComparatorForType(Comparator, Class)} will be used, you need to register them in chained call like {@link RecursiveComparisonAssert#withComparatorForType(Comparator, Class)}.</li>
+   * </ul>
+   * <p>
+   * If you need to chain iterable assertions using recursive comparisons call {@link #usingRecursiveFieldByFieldElementComparator(RecursiveComparisonConfiguration)} instead.
+   * <p>
    * Example:
    * <pre><code class='java'> public class Person {
    *   String name;
@@ -1976,7 +2089,6 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
    *     <ul>
    *       <li>{@code java.lang.Double}: {@code DoubleComparator} with precision of 1.0E-15</li>
    *       <li>{@code java.lang.Float}: {@code FloatComparator }with precision of 1.0E-6</li>
-   *       <li>any comparators previously registered with {@link AbstractIterableAssert#usingComparatorForType(Comparator, Class)} </li>
    *     </ul>
    *   </li>
    * </ul>
@@ -2000,6 +2112,9 @@ public abstract class AbstractIterableAssert<SELF extends AbstractIterableAssert
 
   /**
    * Same as {@link #usingRecursiveComparison()} but allows to specify your own {@link RecursiveComparisonConfiguration}.
+   * <p>
+   * Another difference is that any comparators previously registered with {@link AbstractIterableAssert#usingComparatorForType(Comparator, Class)} will be used in the comparison.
+   *
    * @param recursiveComparisonConfiguration the {@link RecursiveComparisonConfiguration} used in the chained {@link RecursiveComparisonAssert#isEqualTo(Object) isEqualTo} assertion.
    *
    * @return a new {@link RecursiveComparisonAssert} instance built with the given {@link RecursiveComparisonConfiguration}.
diff --git a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
index 81a559eb6..39e3bee0b 100644
--- a/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
+++ b/src/main/java/org/assertj/core/api/RecursiveComparisonAssert.java
@@ -23,10 +23,8 @@ import java.util.Optional;
 import java.util.OptionalDouble;
 import java.util.OptionalInt;
 import java.util.OptionalLong;
-import java.util.stream.Stream;
 
 import org.assertj.core.api.recursive.comparison.ComparisonDifference;
-import org.assertj.core.api.recursive.comparison.FieldLocation;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
 import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCalculator;
 // import org.assertj.core.error.ShouldNotBeEqualComparingFieldByFieldRecursively;
@@ -956,9 +954,7 @@ public class RecursiveComparisonAssert<SELF extends RecursiveComparisonAssert<SE
    */
   @CheckReturnValue
   public SELF withComparatorForFields(Comparator<?> comparator, String... fieldLocations) {
-    Stream.of(fieldLocations)
-          .map(FieldLocation::new)
-          .forEach(fieldLocation -> recursiveComparisonConfiguration.registerComparatorForField(comparator, fieldLocation));
+    recursiveComparisonConfiguration.registerComparatorForFields(comparator, fieldLocations);
     return myself;
   }
 
diff --git a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
index 091f6d21b..df42fa2b7 100644
--- a/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
+++ b/src/main/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration.java
@@ -54,7 +54,7 @@ public class RecursiveComparisonConfiguration {
   // overridden equals method to ignore section
   private List<Class<?>> ignoredOverriddenEqualsForTypes = new ArrayList<>();
   private List<FieldLocation> ignoredOverriddenEqualsForFields = new ArrayList<>();
-  private List<Pattern> ignoredOverriddenEqualsRegexes = new ArrayList<>();
+  private List<Pattern> ignoredOverriddenEqualsForFieldsMatchingRegexes = new ArrayList<>();
   private boolean ignoreAllOverriddenEquals = false;
 
   // ignore order in collections section
@@ -66,6 +66,27 @@ public class RecursiveComparisonConfiguration {
   private TypeComparators typeComparators = defaultTypeComparators();
   private FieldComparators fieldComparators = new FieldComparators();
 
+  private RecursiveComparisonConfiguration(Builder builder) {
+    this.strictTypeChecking = builder.strictTypeChecking;
+    this.ignoreAllActualNullFields = builder.ignoreAllActualNullFields;
+    this.ignoreAllActualEmptyOptionalFields = builder.ignoreAllActualEmptyOptionalFields;
+    this.ignoreAllExpectedNullFields = builder.ignoreAllExpectedNullFields;
+    this.ignoredFields = new LinkedHashSet<>(FieldLocation.from(builder.ignoredFields));
+    ignoreFieldsMatchingRegexes(builder.ignoredFieldsMatchingRegexes);
+    ignoreFieldsOfTypes(builder.ignoredTypes);
+    ignoreOverriddenEqualsForTypes(builder.ignoredOverriddenEqualsForTypes);
+    this.ignoredOverriddenEqualsForFields = new ArrayList<>(FieldLocation.from(builder.ignoredOverriddenEqualsForFields));
+    ignoreOverriddenEqualsForFieldsMatchingRegexes(builder.ignoredOverriddenEqualsForFieldsMatchingRegexes);
+    this.ignoreAllOverriddenEquals = builder.ignoreAllOverriddenEquals;
+    this.ignoreCollectionOrder = builder.ignoreCollectionOrder;
+    this.ignoredCollectionOrderInFields = new LinkedHashSet<>(FieldLocation.from(builder.ignoredCollectionOrderInFields));
+    ignoreCollectionOrderInFieldsMatchingRegexes(builder.ignoredCollectionOrderInFieldsMatchingRegexes);
+    this.typeComparators = builder.typeComparators;
+    this.fieldComparators = builder.fieldComparators;
+  }
+
+  public RecursiveComparisonConfiguration() {}
+
   public boolean hasComparatorForField(String fieldName) {
     return fieldComparators.hasComparatorForField(new FieldLocation(fieldName));
   }
@@ -103,6 +124,16 @@ public class RecursiveComparisonConfiguration {
     return ignoreAllActualNullFields;
   }
 
+  @VisibleForTesting
+  boolean getIgnoreAllExpectedNullFields() {
+    return ignoreAllExpectedNullFields;
+  }
+
+  @VisibleForTesting
+  boolean getIgnoreAllOverriddenEquals() {
+    return ignoreAllOverriddenEquals;
+  }
+
   /**
    * Sets whether actual empty optional fields are ignored in the recursive comparison.
    * <p>
@@ -172,7 +203,7 @@ public class RecursiveComparisonConfiguration {
    * <p>
    * Note that if some object under test fields are null, they are not ignored by this method as their type can't be evaluated.
    * <p>
-   * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFields(String...)} for examples.
+   * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFieldsOfTypes(Class...)} for examples.
    *
    * @param types the types of the object under test to ignore in the comparison.
    */
@@ -240,9 +271,9 @@ public class RecursiveComparisonConfiguration {
    * @param regexes regexes used to specify the fields we want to force a recursive comparison on.
    */
   public void ignoreOverriddenEqualsForFieldsMatchingRegexes(String... regexes) {
-    ignoredOverriddenEqualsRegexes.addAll(Stream.of(regexes)
-                                                .map(Pattern::compile)
-                                                .collect(toList()));
+    ignoredOverriddenEqualsForFieldsMatchingRegexes.addAll(Stream.of(regexes)
+                                                                 .map(Pattern::compile)
+                                                                 .collect(toList()));
   }
 
   /**
@@ -318,7 +349,7 @@ public class RecursiveComparisonConfiguration {
   /**
    * Registers the given {@link Comparator} to compare the fields with the given type.
    * <p>
-   * Comparators specified by this method have less precedence than comparators added with {@link #registerComparatorForField(Comparator, FieldLocation)}.
+   * Comparators specified by this method have less precedence than comparators added with {@link #registerComparatorForFields(Comparator, String...)}.
    * <p>
    * See {@link RecursiveComparisonAssert#withComparatorForType(Comparator, Class)} for examples.
    *
@@ -330,22 +361,32 @@ public class RecursiveComparisonConfiguration {
     typeComparators.put(type, comparator);
   }
 
+  /**
+   * @deprecated Since 3.17.0 use {@link #registerComparatorForFields(Comparator, String...)} instead.
+   */
+  @Deprecated
+  public void registerComparatorForField(Comparator<?> comparator, FieldLocation fieldLocation) {
+    fieldComparators.registerComparator(fieldLocation, comparator);
+  }
+
   /**
    * Registers the given {@link Comparator} to compare the fields with the given locations.
    * <p>
-   * The field locations must be specified from the root object,
-   * for example if {@code Foo} has a {@code Bar} field which has an {@code id}, one can register to a comparator for Bar's {@code id} by calling:
-   * <pre><code class='java'> registerComparatorForField(new FieldLocation("bar.id"), idComparator)</code></pre>
+   * The fields must be specified from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
+   * one can register to a comparator for Foo and Bar's {@code id} by calling:
+   * <pre><code class='java'> registerComparatorForFields(idComparator, "foo.id", "bar.id")</code></pre>
    * <p>
    * Comparators specified by this method have precedence over comparators added with {@link #registerComparatorForType(Comparator, Class)}.
    * <p>
    * See {@link RecursiveComparisonAssert#withComparatorForFields(Comparator, String...) RecursiveComparisonAssert#withComparatorForFields(Comparator, String...)} for examples.
    *
    * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
-   * @param fieldLocation the location from the root object of the field the comparator should be used for
+   * @param fieldLocations the locations from the root object of the fields the comparator should be used for
    */
-  public void registerComparatorForField(Comparator<?> comparator, FieldLocation fieldLocation) {
-    fieldComparators.registerComparator(fieldLocation, comparator);
+  public void registerComparatorForFields(Comparator<?> comparator, String... fieldLocations) {
+    Stream.of(fieldLocations)
+          .map(FieldLocation::new)
+          .forEach(fieldLocation -> fieldComparators.registerComparator(fieldLocation, comparator));
   }
 
   /**
@@ -376,8 +417,8 @@ public class RecursiveComparisonConfiguration {
     return ignoredOverriddenEqualsForFields;
   }
 
-  public List<Pattern> getIgnoredOverriddenEqualsRegexes() {
-    return ignoredOverriddenEqualsRegexes;
+  public List<Pattern> getIgnoredOverriddenEqualsForFieldsMatchingRegexes() {
+    return ignoredOverriddenEqualsForFieldsMatchingRegexes;
   }
 
   public Stream<Entry<FieldLocation, Comparator<?>>> comparatorByFields() {
@@ -389,6 +430,41 @@ public class RecursiveComparisonConfiguration {
     return multiLineDescription(CONFIGURATION_PROVIDER.representation());
   }
 
+  @Override
+  public int hashCode() {
+    return java.util.Objects.hash(fieldComparators, ignoreAllActualEmptyOptionalFields, ignoreAllActualNullFields,
+                                  ignoreAllExpectedNullFields, ignoreAllOverriddenEquals, ignoreCollectionOrder,
+                                  ignoredCollectionOrderInFields, ignoredCollectionOrderInFieldsMatchingRegexes, ignoredFields,
+                                  ignoredFieldsRegexes, ignoredOverriddenEqualsForFields, ignoredOverriddenEqualsForTypes,
+                                  ignoredOverriddenEqualsForFieldsMatchingRegexes, ignoredTypes, strictTypeChecking,
+                                  typeComparators);
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (obj == null) return false;
+    if (getClass() != obj.getClass()) return false;
+    RecursiveComparisonConfiguration other = (RecursiveComparisonConfiguration) obj;
+    return java.util.Objects.equals(fieldComparators, other.fieldComparators)
+           && ignoreAllActualEmptyOptionalFields == other.ignoreAllActualEmptyOptionalFields
+           && ignoreAllActualNullFields == other.ignoreAllActualNullFields
+           && ignoreAllExpectedNullFields == other.ignoreAllExpectedNullFields
+           && ignoreAllOverriddenEquals == other.ignoreAllOverriddenEquals
+           && ignoreCollectionOrder == other.ignoreCollectionOrder
+           && java.util.Objects.equals(ignoredCollectionOrderInFields, other.ignoredCollectionOrderInFields)
+           && java.util.Objects.equals(ignoredFields, other.ignoredFields)
+           && java.util.Objects.equals(ignoredFieldsRegexes, other.ignoredFieldsRegexes)
+           && java.util.Objects.equals(ignoredOverriddenEqualsForFields, other.ignoredOverriddenEqualsForFields)
+           && java.util.Objects.equals(ignoredOverriddenEqualsForTypes, other.ignoredOverriddenEqualsForTypes)
+           && java.util.Objects.equals(ignoredOverriddenEqualsForFieldsMatchingRegexes,
+                                       other.ignoredOverriddenEqualsForFieldsMatchingRegexes)
+           && java.util.Objects.equals(ignoredTypes, other.ignoredTypes) && strictTypeChecking == other.strictTypeChecking
+           && java.util.Objects.equals(typeComparators, other.typeComparators)
+           && java.util.Objects.equals(ignoredCollectionOrderInFieldsMatchingRegexes,
+                                       other.ignoredCollectionOrderInFieldsMatchingRegexes);
+  }
+
   public String multiLineDescription(Representation representation) {
     StringBuilder description = new StringBuilder();
     describeIgnoreAllActualNullFields(description);
@@ -540,9 +616,9 @@ public class RecursiveComparisonConfiguration {
     if (!ignoredOverriddenEqualsForTypes.isEmpty())
       description.append(format("%s the following types: %s%n", INDENT_LEVEL_2,
                                 describeIgnoredOverriddenEqualsForTypes(representation)));
-    if (!ignoredOverriddenEqualsRegexes.isEmpty())
+    if (!ignoredOverriddenEqualsForFieldsMatchingRegexes.isEmpty())
       description.append(format("%s the types matching the following regexes: %s%n", INDENT_LEVEL_2,
-                                describeRegexes(ignoredOverriddenEqualsRegexes)));
+                                describeRegexes(ignoredOverriddenEqualsForFieldsMatchingRegexes)));
   }
 
   private String describeIgnoredOverriddenEqualsForTypes(Representation representation) {
@@ -576,10 +652,10 @@ public class RecursiveComparisonConfiguration {
   }
 
   private boolean matchesAnIgnoredOverriddenEqualsRegex(Class<?> clazz) {
-    if (ignoredOverriddenEqualsRegexes.isEmpty()) return false; // shortcut
+    if (ignoredOverriddenEqualsForFieldsMatchingRegexes.isEmpty()) return false; // shortcut
     String canonicalName = clazz.getCanonicalName();
-    return ignoredOverriddenEqualsRegexes.stream()
-                                         .anyMatch(regex -> regex.matcher(canonicalName).matches());
+    return ignoredOverriddenEqualsForFieldsMatchingRegexes.stream()
+                                                          .anyMatch(regex -> regex.matcher(canonicalName).matches());
   }
 
   private boolean matchesAnIgnoredOverriddenEqualsType(Class<?> clazz) {
@@ -661,7 +737,7 @@ public class RecursiveComparisonConfiguration {
   }
 
   private boolean isConfiguredToIgnoreSomeOverriddenEqualsMethods() {
-    return !ignoredOverriddenEqualsRegexes.isEmpty()
+    return !ignoredOverriddenEqualsForFieldsMatchingRegexes.isEmpty()
            || !ignoredOverriddenEqualsForTypes.isEmpty()
            || !ignoredOverriddenEqualsForFields.isEmpty();
   }
@@ -710,4 +786,265 @@ public class RecursiveComparisonConfiguration {
     description.append(format(str));
   }
 
+  /**
+   * Creates builder to build {@link RecursiveComparisonConfiguration}.
+   * @return created builder
+   */
+  public static Builder builder() {
+    return new Builder();
+  }
+
+  /**
+   * Builder to build {@link RecursiveComparisonConfiguration}.
+   */
+  public static final class Builder {
+    private boolean strictTypeChecking;
+    private boolean ignoreAllActualNullFields;
+    private boolean ignoreAllActualEmptyOptionalFields;
+    private boolean ignoreAllExpectedNullFields;
+    private String[] ignoredFields = {};
+    private String[] ignoredFieldsMatchingRegexes = {};
+    private Class<?>[] ignoredTypes = {};
+    private Class<?>[] ignoredOverriddenEqualsForTypes = {};
+    private String[] ignoredOverriddenEqualsForFields = {};
+    private String[] ignoredOverriddenEqualsForFieldsMatchingRegexes = {};
+    private boolean ignoreAllOverriddenEquals;
+    private boolean ignoreCollectionOrder;
+    private String[] ignoredCollectionOrderInFields = {};
+    private String[] ignoredCollectionOrderInFieldsMatchingRegexes = {};
+    private TypeComparators typeComparators = new TypeComparators();
+    private FieldComparators fieldComparators = new FieldComparators();
+
+    private Builder() {}
+
+    /**
+     * Sets whether the recursive comparison will check that actual's type is compatible with expected's type (the same applies for each field).
+     * Compatible means that the expected's type is the same or a subclass of actual's type.
+     * <p>
+     * See {@link RecursiveComparisonAssert#withStrictTypeChecking()} for code examples.
+     *
+     * @param strictTypeChecking whether the recursive comparison will check that actual's type is compatible with expected's type.
+     * @return this builder.
+     */
+    public Builder withStrictTypeChecking(boolean strictTypeChecking) {
+      this.strictTypeChecking = strictTypeChecking;
+      return this;
+    }
+
+    /**
+     * Sets whether actual null fields are ignored in the recursive comparison.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringActualNullFields()} for code examples.
+     *
+     * @param ignoreAllActualNullFields whether to ignore actual null fields in the recursive comparison
+     * @return this builder.
+     */
+    public Builder withIgnoreAllActualNullFields(boolean ignoreAllActualNullFields) {
+      this.ignoreAllActualNullFields = ignoreAllActualNullFields;
+      return this;
+    }
+
+    /**
+     * Sets whether actual empty optional fields are ignored in the recursive comparison.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringActualEmptyOptionalFields()} for code examples.
+     *
+     * @param ignoreAllActualEmptyOptionalFields whether to ignore actual empty optional fields in the recursive comparison
+     * @return this builder.
+     */
+    public Builder withIgnoreAllActualEmptyOptionalFields(boolean ignoreAllActualEmptyOptionalFields) {
+      this.ignoreAllActualEmptyOptionalFields = ignoreAllActualEmptyOptionalFields;
+      return this;
+    }
+
+    /**
+     * Sets whether expected null fields are ignored in the recursive comparison.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringExpectedNullFields()} for code examples.
+     *
+     * @param ignoreAllExpectedNullFields whether to ignore expected null fields in the recursive comparison
+     * @return this builder.
+     */
+    public Builder withIgnoreAllExpectedNullFields(boolean ignoreAllExpectedNullFields) {
+      this.ignoreAllExpectedNullFields = ignoreAllExpectedNullFields;
+      return this;
+    }
+
+    /**
+     * Adds the given fields to the list of the object under test fields to ignore in the recursive comparison. Nested fields can be specified like this: home.address.street.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFields(String...)} for examples.
+     *
+     * @param fieldsToIgnore the fields of the object under test to ignore in the comparison.
+     * @return this builder.
+     */
+    public Builder withIgnoredFields(String... fieldsToIgnore) {
+      this.ignoredFields = fieldsToIgnore;
+      return this;
+    }
+
+    /**
+     * Allows to ignore in the recursive comparison the object under test fields matching the given regexes. The given regexes are added to the already registered ones.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringFieldsMatchingRegexes(String...)} for examples.
+     *
+     * @param regexes regexes used to ignore fields in the comparison.
+     * @return this builder.
+     */
+    public Builder withIgnoredFieldsMatchingRegexes(String... regexes) {
+      this.ignoredFieldsMatchingRegexes = regexes;
+      return this;
+    }
+
+    /**
+     * Adds the given types to the list of the object under test fields types to ignore in the recursive comparison.
+     * The fields are ignored if their types exactly match one of the ignored types, if a field is a subtype of an ignored type it won't be ignored.
+     * <p>
+     * Note that if some object under test fields are null, they are not ignored by this method as their type can't be evaluated.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringFields(String...) RecursiveComparisonAssert#ignoringFieldsOfTypes(Class...)} for examples.
+     *
+     * @param types the types of the object under test to ignore in the comparison.
+     * @return this builder.
+     */
+    public Builder withIgnoredFieldsOfTypes(Class<?>... types) {
+      this.ignoredTypes = types;
+      return this;
+    }
+
+    /**
+     * Adds the given types to the list of types to force a recursive comparison on.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringOverriddenEqualsForTypes(Class...) RecursiveComparisonAssert#ignoringOverriddenEqualsForTypes(Class...)} for examples.
+     *
+     * @param types the types to the list of types to force a recursive comparison on.
+     * @return this builder.
+     */
+    public Builder withIgnoredOverriddenEqualsForTypes(Class<?>... types) {
+      this.ignoredOverriddenEqualsForTypes = types;
+      return this;
+    }
+
+    /**
+     * Adds the given fields to the list of fields to force a recursive comparison on.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringOverriddenEqualsForFields(String...) RecursiveComparisonAssert#ignoringOverriddenEqualsForFields(String...)} for examples.
+     *
+     * @param fields the fields to force a recursive comparison on.
+     * @return this builder.
+     */
+    public Builder withIgnoredOverriddenEqualsForFields(String... fields) {
+      this.ignoredOverriddenEqualsForFields = fields;
+      return this;
+    }
+
+    /**
+     * Adds the given regexes to the list of regexes used find the fields to force a recursive comparison on.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringOverriddenEqualsForFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringOverriddenEqualsForFieldsMatchingRegexes(String...)} for examples.
+     *
+     * @param regexes regexes used to specify the fields we want to force a recursive comparison on.
+     * @return this builder.
+     */
+    public Builder withIgnoredOverriddenEqualsForFieldsMatchingRegexes(String... regexes) {
+      this.ignoredOverriddenEqualsForFieldsMatchingRegexes = regexes;
+      return this;
+    }
+
+    /**
+     * Force a recursive comparison on all fields (except java types) if true.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringAllOverriddenEquals()} for examples.
+     *
+     * @param ignoreAllOverriddenEquals whether to force a recursive comparison on all fields (except java types) or not.
+     * @return this builder.
+     */
+    public Builder withIgnoreAllOverriddenEquals(boolean ignoreAllOverriddenEquals) {
+      this.ignoreAllOverriddenEquals = ignoreAllOverriddenEquals;
+      return this;
+    }
+
+    /**
+     * Sets whether to ignore collection order in the comparison.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringCollectionOrder()} for code examples.
+     *
+     * @param ignoreCollectionOrder whether to ignore collection order in the comparison.
+     * @return this builder.
+     */
+    public Builder withIgnoreCollectionOrder(boolean ignoreCollectionOrder) {
+      this.ignoreCollectionOrder = ignoreCollectionOrder;
+      return this;
+    }
+
+    /**
+     * Adds the given fields to the list of the object under test fields to ignore collection order in the recursive comparison.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringCollectionOrderInFields(String...) RecursiveComparisonAssert#ignoringCollectionOrderInFields(String...)} for examples.
+     *
+     * @param fieldsToIgnoreCollectionOrder the fields of the object under test to ignore collection order in the comparison.
+     * @return this builder.
+     */
+    public Builder withIgnoredCollectionOrderInFields(String... fieldsToIgnoreCollectionOrder) {
+      this.ignoredCollectionOrderInFields = fieldsToIgnoreCollectionOrder;
+      return this;
+    }
+
+    /**
+     * Adds the given regexes to the list of regexes used to find the object under test fields to ignore collection order in the recursive comparison.
+     * <p>
+     * See {@link RecursiveComparisonAssert#ignoringCollectionOrderInFieldsMatchingRegexes(String...) RecursiveComparisonAssert#ignoringCollectionOrderInFieldsMatchingRegexes(String...)} for examples.
+     *
+     * @param regexes regexes used to find the object under test fields to ignore collection order in in the comparison.
+     * @return this builder.
+     */
+    public Builder withIgnoredCollectionOrderInFieldsMatchingRegexes(String... regexes) {
+      this.ignoredCollectionOrderInFieldsMatchingRegexes = regexes;
+      return this;
+    }
+
+    /**
+     * Registers the given {@link Comparator} to compare the fields with the given type.
+     * <p>
+     * Comparators specified by this method have less precedence than comparators added with {@link #withComparatorForFields(Comparator, String...)}.
+     * <p>
+     * See {@link RecursiveComparisonAssert#withComparatorForType(Comparator, Class)} for examples.
+     *
+     * @param <T> the class type to register a comparator for
+     * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
+     * @param type the type to be compared with the given comparator.
+     * @return this builder.
+     */
+    public <T> Builder withComparatorForType(Comparator<? super T> comparator, Class<T> type) {
+      this.typeComparators.put(type, comparator);
+      return this;
+    }
+
+    /**
+     * Registers the given {@link Comparator} to compare the fields with the given locations.
+     * <p>
+     * The fields must be specified from the root object, for example if {@code Foo} has a {@code Bar} field and both have an {@code id} field,
+     * one can register to a comparator for Foo and Bar's {@code id} by calling:
+     * <pre><code class='java'> registerComparatorForFields(idComparator, "foo.id", "bar.id")</code></pre>
+     * <p>
+     * Comparators specified by this method have precedence over comparators added with {@link #withComparatorForType(Comparator, Class)}.
+     * <p>
+     * See {@link RecursiveComparisonAssert#withComparatorForFields(Comparator, String...) RecursiveComparisonAssert#withComparatorForFields(Comparator comparator, String...fields)} for examples.
+     *
+     * @param comparator the {@link java.util.Comparator Comparator} to use to compare the given field
+     * @param fields the fields the comparator should be used for
+     * @return this builder.
+     */
+    public Builder withComparatorForFields(Comparator<?> comparator, String... fields) {
+      Stream.of(fields)
+            .map(FieldLocation::new)
+            .forEach(fieldLocation -> fieldComparators.registerComparator(fieldLocation, comparator));
+      return this;
+    }
+
+    public RecursiveComparisonConfiguration build() {
+      return new RecursiveComparisonConfiguration(this);
+    }
+  }
+
 }
diff --git a/src/main/java/org/assertj/core/internal/ConfigurableRecursiveFieldByFieldComparator.java b/src/main/java/org/assertj/core/internal/ConfigurableRecursiveFieldByFieldComparator.java
new file mode 100644
index 000000000..a945c2dc4
--- /dev/null
+++ b/src/main/java/org/assertj/core/internal/ConfigurableRecursiveFieldByFieldComparator.java
@@ -0,0 +1,81 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.lang.String.format;
+import static java.util.Objects.requireNonNull;
+import static org.assertj.core.internal.ComparatorBasedComparisonStrategy.NOT_EQUAL;
+
+import java.util.Comparator;
+import java.util.Objects;
+
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCalculator;
+import org.assertj.core.util.introspection.IntrospectionError;
+
+/**
+ * Compares objects field/property by field/property recursively based on the given {@link RecursiveComparisonConfiguration} allowing fine tuning of the comparison.
+ */
+public class ConfigurableRecursiveFieldByFieldComparator implements Comparator<Object> {
+
+  private RecursiveComparisonConfiguration configuration;
+  private RecursiveComparisonDifferenceCalculator recursiveComparisonDifferenceCalculator;
+
+  // for testing
+  ConfigurableRecursiveFieldByFieldComparator(RecursiveComparisonConfiguration configuration,
+                                              RecursiveComparisonDifferenceCalculator recursiveComparisonDifferenceCalculator) {
+    requireNonNull(configuration, "RecursiveComparisonConfiguration must not be null");
+    this.configuration = configuration;
+    this.recursiveComparisonDifferenceCalculator = recursiveComparisonDifferenceCalculator;
+  }
+
+  public ConfigurableRecursiveFieldByFieldComparator(RecursiveComparisonConfiguration configuration) {
+    this(configuration, new RecursiveComparisonDifferenceCalculator());
+  }
+
+  @Override
+  public int compare(Object actual, Object other) {
+    if (actual == null && other == null) return 0;
+    if (actual == null || other == null) return NOT_EQUAL;
+    return areEqual(actual, other) ? 0 : NOT_EQUAL;
+  }
+
+  protected boolean areEqual(Object actual, Object other) {
+    try {
+      return recursiveComparisonDifferenceCalculator.determineDifferences(actual, other, configuration).isEmpty();
+    } catch (@SuppressWarnings("unused") IntrospectionError e) {
+      return false;
+    }
+  }
+
+  @Override
+  public String toString() {
+    return format("recursive field/property by field/property comparator on all fields/properties using the following configuration:%n%s",
+                  configuration);
+  }
+
+  @Override
+  public int hashCode() {
+    return Objects.hash(configuration);
+  }
+
+  @Override
+  public boolean equals(Object obj) {
+    if (this == obj) return true;
+    if (obj == null) return false;
+    if (getClass() != obj.getClass()) return false;
+    ConfigurableRecursiveFieldByFieldComparator other = (ConfigurableRecursiveFieldByFieldComparator) obj;
+    return Objects.equals(configuration, other.configuration);
+  }
+
+}
diff --git a/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparator_with_RecursiveComparisonConfiguration_Test.java b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparator_with_RecursiveComparisonConfiguration_Test.java
new file mode 100644
index 000000000..06c86b9f6
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/iterable/IterableAssert_usingRecursiveFieldByFieldElementComparator_with_RecursiveComparisonConfiguration_Test.java
@@ -0,0 +1,92 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.iterable;
+
+import static java.util.Collections.singletonList;
+import static org.assertj.core.api.BDDAssertions.then;
+
+import org.assertj.core.api.ConcreteIterableAssert;
+import org.assertj.core.api.IterableAssertBaseTest;
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
+import org.assertj.core.internal.ComparatorBasedComparisonStrategy;
+import org.assertj.core.internal.ConfigurableRecursiveFieldByFieldComparator;
+import org.assertj.core.internal.IterableElementComparisonStrategy;
+import org.assertj.core.internal.Iterables;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+
+public class IterableAssert_usingRecursiveFieldByFieldElementComparator_with_RecursiveComparisonConfiguration_Test extends IterableAssertBaseTest {
+
+  private Iterables iterablesBefore;
+  private RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+
+  @BeforeEach
+  public void before() {
+    iterablesBefore = getIterables(assertions);
+  }
+
+  @Override
+  protected ConcreteIterableAssert<Object> invoke_api_method() {
+    return assertions.usingRecursiveFieldByFieldElementComparator(recursiveComparisonConfiguration);
+  }
+
+  @Override
+  protected void verify_internal_effects() {
+    then(iterablesBefore).isNotSameAs(getIterables(assertions));
+    then(getIterables(assertions).getComparisonStrategy()).isInstanceOf(ComparatorBasedComparisonStrategy.class);
+    then(getObjects(assertions).getComparisonStrategy()).isInstanceOf(IterableElementComparisonStrategy.class);
+    ConfigurableRecursiveFieldByFieldComparator expectedComparator = new ConfigurableRecursiveFieldByFieldComparator(recursiveComparisonConfiguration);
+    then(getIterables(assertions).getComparator()).isEqualTo(expectedComparator);
+    then(getObjects(assertions).getComparisonStrategy()).extracting("elementComparator").isEqualTo(expectedComparator);
+  }
+
+  @Test
+  public void should_be_able_to_use_specific_RecursiveComparisonConfiguration_when_using_recursive_field_by_field_element_comparator() {
+    // GIVEN
+    Foo actual = new Foo("1", new Bar(1));
+    Foo other = new Foo("2", new Bar(1));
+    RecursiveComparisonConfiguration configuration = new RecursiveComparisonConfiguration();
+    configuration.ignoreFields("id");
+    // WHEN/THEN
+    then(singletonList(actual)).usingRecursiveFieldByFieldElementComparator(configuration)
+                               .contains(other);
+  }
+
+  public static class Foo {
+    public String id;
+    public Bar bar;
+
+    public Foo(String id, Bar bar) {
+      this.id = id;
+      this.bar = bar;
+    }
+
+    @Override
+    public String toString() {
+      return "Foo(id=" + id + ", bar=" + bar + ")";
+    }
+  }
+
+  public static class Bar {
+    public int id;
+
+    public Bar(int id) {
+      this.id = id;
+    }
+
+    @Override
+    public String toString() {
+      return "Bar(id=" + id + ")";
+    }
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
index 2bb930353..e3ac23c16 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_fluent_API_Test.java
@@ -56,7 +56,7 @@ public class RecursiveComparisonAssert_fluent_API_Test {
     assertThat(recursiveComparisonConfiguration.getIgnoredFieldsRegexes()).isEmpty();
     assertThat(recursiveComparisonConfiguration.getIgnoredOverriddenEqualsForFields()).isEmpty();
     assertThat(recursiveComparisonConfiguration.getIgnoredOverriddenEqualsForTypes()).isEmpty();
-    assertThat(recursiveComparisonConfiguration.getIgnoredOverriddenEqualsRegexes()).isEmpty();
+    assertThat(recursiveComparisonConfiguration.getIgnoredOverriddenEqualsForFieldsMatchingRegexes()).isEmpty();
     assertThat(recursiveComparisonConfiguration.hasCustomComparators()).isTrue();
   }
 
@@ -166,7 +166,7 @@ public class RecursiveComparisonAssert_fluent_API_Test {
                                                                        .ignoringOverriddenEqualsForFieldsMatchingRegexes(regex1, regex2)
                                                                        .getRecursiveComparisonConfiguration();
     // THEN
-    assertThat(configuration.getIgnoredOverriddenEqualsRegexes()).extracting(Pattern::pattern)
+    assertThat(configuration.getIgnoredOverriddenEqualsForFieldsMatchingRegexes()).extracting(Pattern::pattern)
                                                                  .containsExactly(regex1, regex2);
   }
 
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringOverriddenEquals_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringOverriddenEquals_Test.java
index a98f4a914..4c1c4d6ee 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringOverriddenEquals_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_ignoringOverriddenEquals_Test.java
@@ -140,7 +140,7 @@ public class RecursiveComparisonAssert_isEqualTo_ignoringOverriddenEquals_Test
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFieldsMatchingRegexes("foo");
     recursiveComparisonConfiguration.ignoreOverriddenEqualsForFieldsMatchingRegexes("bar", "baz");
     // THEN
-    List<Pattern> ignoredOverriddenEqualsRegexes = recursiveComparisonConfiguration.getIgnoredOverriddenEqualsRegexes();
+    List<Pattern> ignoredOverriddenEqualsRegexes = recursiveComparisonConfiguration.getIgnoredOverriddenEqualsForFieldsMatchingRegexes();
     assertThat(ignoredOverriddenEqualsRegexes).extracting(Pattern::pattern)
                                               .containsExactlyInAnyOrder("foo", "bar", "baz");
   }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test.java
index 55d3d4e02..f2ce5a73f 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test.java
@@ -13,7 +13,6 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.recursive.comparison.FieldLocation.fielLocation;
 import static org.assertj.core.internal.objects.SymmetricDateComparator.SYMMETRIC_DATE_COMPARATOR;
 import static org.assertj.core.test.AlwaysDifferentComparator.alwaysDifferent;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS;
@@ -102,8 +101,7 @@ public class RecursiveComparisonAssert_isEqualTo_withFieldComparators_Test
     expected.neighbour = new Person("Jack");
     expected.neighbour.home.address.number = 123;
     // register comparators for some fields that will fail the comparison
-    recursiveComparisonConfiguration.registerComparatorForField(alwaysDifferent(), fielLocation("dateOfBirth"));
-    recursiveComparisonConfiguration.registerComparatorForField(alwaysDifferent(), fielLocation("neighbour.home.address"));
+    recursiveComparisonConfiguration.registerComparatorForFields(alwaysDifferent(), "dateOfBirth", "neighbour.home.address");
 
     // WHEN
     compareRecursivelyFailsAsExpected(actual, expected);
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
new file mode 100644
index 000000000..e757ca11a
--- /dev/null
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_builder_Test.java
@@ -0,0 +1,232 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.api.recursive.comparison;
+
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.assertj.core.test.AlwaysEqualComparator.alwaysEqual;
+
+import java.util.regex.Pattern;
+
+import org.apache.commons.lang3.RandomUtils;
+import org.assertj.core.test.AlwaysEqualComparator;
+import org.junit.jupiter.api.Test;
+
+public class RecursiveComparisonConfiguration_builder_Test {
+
+  @Test
+  public void should_set_ignoreAllActualNullFields() {
+    // GIVEN
+    boolean value = RandomUtils.nextBoolean();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoreAllActualNullFields(value)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoreAllActualNullFields()).isEqualTo(value);
+  }
+
+  @Test
+  public void should_set_ignoreAllActualEmptyOptionalFields() {
+    // GIVEN
+    boolean value = RandomUtils.nextBoolean();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoreAllActualEmptyOptionalFields(value)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoreAllActualEmptyOptionalFields()).isEqualTo(value);
+  }
+
+  @Test
+  public void should_set_ignoreAllExpectedNullFields() {
+    // GIVEN
+    boolean value = RandomUtils.nextBoolean();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoreAllExpectedNullFields(value)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoreAllExpectedNullFields()).isEqualTo(value);
+  }
+
+  @Test
+  public void should_set_ignoreAllOverriddenEquals() {
+    // GIVEN
+    boolean value = RandomUtils.nextBoolean();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoreAllOverriddenEquals(value)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoreAllOverriddenEquals()).isEqualTo(value);
+  }
+
+  @Test
+  public void should_set_ignoreCollectionOrder() {
+    // GIVEN
+    boolean value = RandomUtils.nextBoolean();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoreCollectionOrder(value)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoreCollectionOrder()).isEqualTo(value);
+  }
+
+  @Test
+  public void should_set_ignoreCollectionOrderInFields() {
+    // GIVEN
+    String[] values = { "foo", "bar" };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoredCollectionOrderInFields(values)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoredCollectionOrderInFields()).extracting(FieldLocation::getFieldPath)
+                                                           .containsExactly(values);
+  }
+
+  @Test
+  public void should_set_ignoreCollectionOrderInFieldsMatchingRegexes() {
+    // GIVEN
+    String[] values = { "foo", "bar" };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoredCollectionOrderInFieldsMatchingRegexes(values)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoredCollectionOrderInFieldsMatchingRegexes()).extracting(Pattern::pattern)
+                                                                          .containsExactly(values);
+  }
+
+  @Test
+  public void should_set_ignoredFields() {
+    // GIVEN
+    String[] values = { "foo", "bar" };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoredFields(values)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoredFields()).extracting(FieldLocation::getFieldPath)
+                                          .containsExactly(values);
+  }
+
+  @Test
+  public void should_set_ignoredFieldsRegexes() {
+    // GIVEN
+    String[] values = { "foo", "bar" };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoredFieldsMatchingRegexes(values)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoredFieldsRegexes()).extracting(Pattern::pattern)
+                                                 .containsExactly(values);
+  }
+
+  @Test
+  public void should_set_ignoredOverriddenEqualsForFields() {
+    // GIVEN
+    String[] values = { "foo", "bar" };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoredOverriddenEqualsForFields(values)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoredOverriddenEqualsForFields()).extracting(FieldLocation::getFieldPath)
+                                                             .containsExactly(values);
+  }
+
+  @Test
+  public void should_set_ignoredOverriddenEqualsForTypes() {
+    // GIVEN
+    Class<?>[] values = { String.class, Long.class, int.class };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoredOverriddenEqualsForTypes(values)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoredOverriddenEqualsForTypes()).containsExactly(String.class, Long.class, int.class);
+  }
+
+  @Test
+  public void should_set_ignoredOverriddenEqualsRegexes() {
+    // GIVEN
+    String[] values = { "foo", "bar" };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoredOverriddenEqualsForFieldsMatchingRegexes(values)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoredOverriddenEqualsForFieldsMatchingRegexes()).extracting(Pattern::pattern)
+                                                                            .containsExactly(values);
+  }
+
+  @Test
+  public void should_set_strictTypeCheckingMode() {
+    // GIVEN
+    boolean value = RandomUtils.nextBoolean();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withStrictTypeChecking(value)
+                                                                                     .build();
+    // THEN
+    then(configuration.isInStrictTypeCheckingMode()).isEqualTo(value);
+  }
+
+  @Test
+  public void should_set_ignoredTypes() {
+    // GIVEN
+    Class<?>[] values = { String.class, Long.class, Object.class, int.class };
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withIgnoredFieldsOfTypes(values)
+                                                                                     .build();
+    // THEN
+    then(configuration.getIgnoredTypes()).containsExactly(String.class, Long.class, Object.class, Integer.class);
+  }
+
+  @Test
+  public void should_set_comparatorForField() {
+    // GIVEN
+    String fooLocation = "foo";
+    String barLocation = "foo.bar";
+    AlwaysEqualComparator<?> alwaysEqualComparator = alwaysEqual();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withComparatorForFields(alwaysEqualComparator,
+                                                                                                              fooLocation,
+                                                                                                              barLocation)
+                                                                                     .build();
+    // THEN
+    then(configuration.hasComparatorForField(fooLocation)).isTrue();
+    then(configuration.getComparatorForField(fooLocation)).isSameAs(alwaysEqualComparator);
+    then(configuration.hasComparatorForField(barLocation)).isTrue();
+    then(configuration.getComparatorForField(barLocation)).isSameAs(alwaysEqualComparator);
+  }
+
+  @Test
+  public void should_set_comparatorForType() {
+    // GIVEN
+    AlwaysEqualComparator<String> alwaysEqualComparator = alwaysEqual();
+    // WHEN
+    RecursiveComparisonConfiguration configuration = RecursiveComparisonConfiguration.builder()
+                                                                                     .withComparatorForType(alwaysEqualComparator,
+                                                                                                            String.class)
+                                                                                     .build();
+    // THEN
+    then(configuration.hasComparatorForType(String.class)).isTrue();
+    then(configuration.getComparatorForType(String.class)).isSameAs(alwaysEqualComparator);
+  }
+}
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
index d377cf534..a46686f5d 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_fieldComparators_Test.java
@@ -13,7 +13,6 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.recursive.comparison.FieldLocation.fielLocation;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
 
 import org.assertj.core.util.AbsValueComparator;
@@ -33,8 +32,8 @@ public class RecursiveComparisonConfiguration_fieldComparators_Test {
   public void should_register_given_field_comparators() {
     // GIVEN
     AbsValueComparator<Integer> integerComparator = new AbsValueComparator<>();
-    recursiveComparisonConfiguration.registerComparatorForField(integerComparator, fielLocation("height"));
-    recursiveComparisonConfiguration.registerComparatorForField(ALWAY_EQUALS_TUPLE, fielLocation("weight"));
+    recursiveComparisonConfiguration.registerComparatorForFields(integerComparator, "height");
+    recursiveComparisonConfiguration.registerComparatorForFields(ALWAY_EQUALS_TUPLE, "weight");
     // THEN
     assertThat(recursiveComparisonConfiguration.getComparatorForField("height")).isSameAs(integerComparator);
     assertThat(recursiveComparisonConfiguration.getComparatorForField("weight")).isSameAs(ALWAY_EQUALS_TUPLE);
@@ -43,8 +42,8 @@ public class RecursiveComparisonConfiguration_fieldComparators_Test {
   @Test
   public void should_replace_a_registered_field_comparator() {
     // GIVEN
-    recursiveComparisonConfiguration.registerComparatorForField(new AbsValueComparator<>(), fielLocation("height"));
-    recursiveComparisonConfiguration.registerComparatorForField(ALWAY_EQUALS_TUPLE, fielLocation("height"));
+    recursiveComparisonConfiguration.registerComparatorForFields(new AbsValueComparator<>(), "height");
+    recursiveComparisonConfiguration.registerComparatorForFields(ALWAY_EQUALS_TUPLE, "height");
     // THEN
     assertThat(recursiveComparisonConfiguration.getComparatorForField("height")).isSameAs(ALWAY_EQUALS_TUPLE);
   }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_hasCustomComparators_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_hasCustomComparators_Test.java
index 3835a297f..b22dd31b9 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_hasCustomComparators_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_hasCustomComparators_Test.java
@@ -13,7 +13,6 @@
 package org.assertj.core.api.recursive.comparison;
 
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.recursive.comparison.FieldLocation.fielLocation;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS;
 
 import org.junit.jupiter.api.BeforeEach;
@@ -46,7 +45,7 @@ public class RecursiveComparisonConfiguration_hasCustomComparators_Test {
     // GIVEN
     recursiveComparisonConfiguration.getTypeComparators().clear();
     // WHEN
-    recursiveComparisonConfiguration.registerComparatorForField(ALWAY_EQUALS, fielLocation("foo"));
+    recursiveComparisonConfiguration.registerComparatorForFields(ALWAY_EQUALS, "foo");
     // THEN
     assertThat(recursiveComparisonConfiguration.hasCustomComparators()).isTrue();
   }
diff --git a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
index a366bdb49..66653472e 100644
--- a/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
+++ b/src/test/java/org/assertj/core/api/recursive/comparison/RecursiveComparisonConfiguration_multiLineDescription_Test.java
@@ -14,7 +14,6 @@ package org.assertj.core.api.recursive.comparison;
 
 import static java.lang.String.format;
 import static org.assertj.core.api.Assertions.assertThat;
-import static org.assertj.core.api.recursive.comparison.FieldLocation.fielLocation;
 import static org.assertj.core.presentation.StandardRepresentation.STANDARD_REPRESENTATION;
 import static org.assertj.core.test.AlwaysDifferentComparator.alwaysDifferent;
 import static org.assertj.core.test.AlwaysEqualComparator.ALWAY_EQUALS_TUPLE;
@@ -219,9 +218,9 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
   @Test
   public void should_show_the_registered_comparator_for_specific_fields_alphabetically() {
     // GIVEN
-    recursiveComparisonConfiguration.registerComparatorForField(ALWAY_EQUALS_TUPLE, fielLocation("foo"));
-    recursiveComparisonConfiguration.registerComparatorForField(alwaysDifferent(), fielLocation("bar"));
-    recursiveComparisonConfiguration.registerComparatorForField(new PercentageComparator(), fielLocation("height"));
+    recursiveComparisonConfiguration.registerComparatorForFields(ALWAY_EQUALS_TUPLE, "foo");
+    recursiveComparisonConfiguration.registerComparatorForFields(alwaysDifferent(), "bar");
+    recursiveComparisonConfiguration.registerComparatorForFields(new PercentageComparator(), "height");
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
@@ -270,8 +269,8 @@ public class RecursiveComparisonConfiguration_multiLineDescription_Test {
     recursiveComparisonConfiguration.ignoreCollectionOrderInFieldsMatchingRegexes("f.*", "ba.", "foo.*");
     recursiveComparisonConfiguration.registerComparatorForType(new AbsValueComparator<>(), Integer.class);
     recursiveComparisonConfiguration.registerComparatorForType(AlwaysEqualComparator.ALWAY_EQUALS_TUPLE, Tuple.class);
-    recursiveComparisonConfiguration.registerComparatorForField(ALWAY_EQUALS_TUPLE, fielLocation("foo"));
-    recursiveComparisonConfiguration.registerComparatorForField(alwaysDifferent(), fielLocation("bar.baz"));
+    recursiveComparisonConfiguration.registerComparatorForFields(ALWAY_EQUALS_TUPLE, "foo");
+    recursiveComparisonConfiguration.registerComparatorForFields(alwaysDifferent(), "bar.baz");
     // WHEN
     String multiLineDescription = recursiveComparisonConfiguration.multiLineDescription(STANDARD_REPRESENTATION);
     // THEN
diff --git a/src/test/java/org/assertj/core/internal/ConfigurableRecursiveFieldByFieldComparator_Test.java b/src/test/java/org/assertj/core/internal/ConfigurableRecursiveFieldByFieldComparator_Test.java
new file mode 100644
index 000000000..7689093be
--- /dev/null
+++ b/src/test/java/org/assertj/core/internal/ConfigurableRecursiveFieldByFieldComparator_Test.java
@@ -0,0 +1,90 @@
+/*
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
+ * the License. You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
+ * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
+ * specific language governing permissions and limitations under the License.
+ *
+ * Copyright 2012-2020 the original author or authors.
+ */
+package org.assertj.core.internal;
+
+import static java.util.Collections.emptyList;
+import static org.assertj.core.api.Assertions.catchThrowable;
+import static org.assertj.core.api.BDDAssertions.then;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.BDDMockito.given;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
+
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonConfiguration;
+import org.assertj.core.api.recursive.comparison.RecursiveComparisonDifferenceCalculator;
+import org.junit.jupiter.api.Test;
+
+public class ConfigurableRecursiveFieldByFieldComparator_Test {
+
+  private ConfigurableRecursiveFieldByFieldComparator configurableRecursiveFieldByFieldComparator;
+
+  @Test
+  public void should_delegate_comparison_to_recursiveComparisonDifferenceCalculator() {
+    // GIVEN
+    RecursiveComparisonDifferenceCalculator recursiveComparisonDifferenceCalculator = mock(RecursiveComparisonDifferenceCalculator.class);
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+    configurableRecursiveFieldByFieldComparator = new ConfigurableRecursiveFieldByFieldComparator(recursiveComparisonConfiguration,
+                                                                                                  recursiveComparisonDifferenceCalculator);
+    given(recursiveComparisonDifferenceCalculator.determineDifferences(any(), any(), any())).willReturn(emptyList());
+    String actual = "foo";
+    String other = "bar";
+    // WHEN
+    int compare = configurableRecursiveFieldByFieldComparator.compare(actual, other);
+    // THEN
+    verify(recursiveComparisonDifferenceCalculator).determineDifferences(actual, other, recursiveComparisonConfiguration);
+    then(compare).isZero();
+  }
+
+  @Test
+  public void should_return_0_when_both_values_are_null() {
+    // GIVEN
+    RecursiveComparisonDifferenceCalculator recursiveComparisonDifferenceCalculator = mock(RecursiveComparisonDifferenceCalculator.class);
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+    configurableRecursiveFieldByFieldComparator = new ConfigurableRecursiveFieldByFieldComparator(recursiveComparisonConfiguration,
+                                                                                                  recursiveComparisonDifferenceCalculator);
+    // WHEN
+    int comparisonResult = configurableRecursiveFieldByFieldComparator.compare(null, null);
+    // THEN
+    verifyNoInteractions(recursiveComparisonDifferenceCalculator);
+    then(comparisonResult).isZero();
+  }
+
+  @Test
+  public void should_not_return_0_when_only_one_of_both_value_is_null() {
+    // GIVEN
+    RecursiveComparisonDifferenceCalculator recursiveComparisonDifferenceCalculator = mock(RecursiveComparisonDifferenceCalculator.class);
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = new RecursiveComparisonConfiguration();
+    configurableRecursiveFieldByFieldComparator = new ConfigurableRecursiveFieldByFieldComparator(recursiveComparisonConfiguration,
+                                                                                                  recursiveComparisonDifferenceCalculator);
+    // WHEN
+    int comparisonResult1 = configurableRecursiveFieldByFieldComparator.compare(null, "foo");
+    int comparisonResult2 = configurableRecursiveFieldByFieldComparator.compare("foo", null);
+    // THEN
+    verifyNoInteractions(recursiveComparisonDifferenceCalculator);
+    then(comparisonResult1).isNotZero();
+    then(comparisonResult2).isNotZero();
+  }
+
+  @Test
+  public void should_throw_an_NPE_if_given_RecursiveComparisonConfiguration_is_null() {
+    // GIVEN
+    RecursiveComparisonConfiguration recursiveComparisonConfiguration = null;
+    // WHEN
+    Throwable throwable = catchThrowable(() -> new ConfigurableRecursiveFieldByFieldComparator(recursiveComparisonConfiguration));
+    // THEN
+    then(throwable).isInstanceOf(NullPointerException.class)
+                   .hasMessage("RecursiveComparisonConfiguration must not be null");
+  }
+
+}
