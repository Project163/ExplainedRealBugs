<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sun Nov 09 05:58:21 UTC 2025

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[JEXL-246] Intermittent ambiguous method invocation when processing assignOverload</title>
                <link>https://issues.apache.org/jira/browse/JEXL-246</link>
                <project id="12310479" key="JEXL">Commons JEXL</project>
                    <description>&lt;p&gt;Sometimes the simple operator like &lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;z += 1&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt; when &lt;tt&gt;z&lt;/tt&gt; has not been defined yet raises an exception &lt;tt&gt;org.apache.commons.jexl3.internal.introspection.MethodKey$AmbiguousException&lt;/tt&gt; with the following stack trace: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ambiguous method invocation: MyArithmetic.selfAdd(null, java.lang.Integer)&lt;br/&gt;
org.apache.commons.jexl3.internal.introspection.MethodKey$AmbiguousException: null&lt;br/&gt;
	at org.apache.commons.jexl3.internal.introspection.MethodKey$Parameters.getMostSpecific(MethodKey.java:540)&lt;br/&gt;
	at org.apache.commons.jexl3.internal.introspection.MethodKey$Parameters.access$000(MethodKey.java:452)&lt;br/&gt;
	at org.apache.commons.jexl3.internal.introspection.MethodKey.getMostSpecificMethod(MethodKey.java:261)&lt;br/&gt;
	at org.apache.commons.jexl3.internal.introspection.ClassMap.getMethod(ClassMap.java:178) &lt;br/&gt;
	at org.apache.commons.jexl3.internal.introspection.Introspector.getMethod(Introspector.java:146)&lt;br/&gt;
	at org.apache.commons.jexl3.internal.introspection.MethodExecutor.discover(MethodExecutor.java:52)&lt;br/&gt;
	at org.apache.commons.jexl3.internal.introspection.Uberspect.getMethod(Uberspect.java:218) &lt;br/&gt;
	at MyUberspect.getMethod(MyUberspect.java:168)&lt;br/&gt;
	at org.apache.commons.jexl3.internal.introspection.Uberspect$ArithmeticUberspect.getOperator(Uberspect.java:413)&lt;br/&gt;
	at org.apache.commons.jexl3.internal.Operators.tryOverload(Operators.java:85) &lt;br/&gt;
	at org.apache.commons.jexl3.internal.Operators.tryAssignOverload(Operators.java:118) &lt;br/&gt;
	at org.apache.commons.jexl3.internal.Interpreter.executeAssign(Interpreter.java:1292) &lt;br/&gt;
	at org.apache.commons.jexl3.internal.Interpreter.visit(Interpreter.java:1102) &lt;br/&gt;
....&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;The class MyArithmetic contains a couple of overloaded&lt;br/&gt;
&lt;tt&gt;public JexlOperator selfAdd(T x, Object y)&lt;/tt&gt; methods with the first argument being the desired type &lt;tt&gt;T&lt;/tt&gt; like &lt;tt&gt;Appendable&lt;/tt&gt; or &lt;tt&gt;Collection&lt;/tt&gt; for which the &lt;tt&gt;+=&lt;/tt&gt; operator is overloaded.&lt;/p&gt;

&lt;p&gt;Obviously in case where the first argument is null and the second argument is an Integer it is not possible to differentiate between &lt;tt&gt;public JexlOperator selfAdd(Collection x, Object y)&lt;/tt&gt; and &lt;tt&gt;public JexlOperator selfAdd(Appendable x, Object y)&lt;/tt&gt; but I wonder is there any point in trying to perform &lt;tt&gt;selfAdd&lt;/tt&gt; on the null variable? What questions me more is that this error is intermittent and sometimes there is an exception and sometimes there is not, so at the moment I have no test case to reproduce. So I think this is a bug.&lt;/p&gt;</description>
                <environment></environment>
        <key id="13127673">JEXL-246</key>
            <summary>Intermittent ambiguous method invocation when processing assignOverload</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="4" iconUrl="https://issues.apache.org/jira/images/icons/priorities/minor.svg">Minor</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="henrib">Henri Biestro</assignee>
                                    <reporter username="dmitri_blinov">Dmitri Blinov</reporter>
                        <labels>
                    </labels>
                <created>Fri, 29 Dec 2017 13:38:44 +0000</created>
                <updated>Mon, 7 Jun 2021 13:14:36 +0000</updated>
                            <resolved>Tue, 16 Jan 2018 19:40:32 +0000</resolved>
                                    <version>3.1</version>
                                    <fixVersion>3.2</fixVersion>
                                        <due></due>
                            <votes>0</votes>
                                    <watches>2</watches>
                                                                                                                <comments>
                            <comment id="16316464" author="henrib" created="Mon, 8 Jan 2018 15:16:09 +0000"  >&lt;p&gt;The behavior is not intermittent; when JEXL detects an ambiguity when resolving a method, it will log this exception as an info (using the JEXL engine logger if configured to allow these) and will remember this signature as a cache-miss. The second time this resolution is attempted, the cache-miss will be detected to return a null (and avoid throwing the same exception twice).&lt;br/&gt;
In effect, the MethodKey.AmbiguousException will only be logged once (per lifetime of the Introspector).&lt;/p&gt;

&lt;p&gt;The fix makes it clearer to determine what the error is due to; in the accompanying case, it is due to a null operand (z) during operator evaluation.&lt;/p&gt;

&lt;p&gt;trunk/RELEASE-NOTES.txt&lt;br/&gt;
trunk/src/main/java/org/apache/commons/jexl3/internal/Operators.java&lt;br/&gt;
trunk/src/site/xdoc/changes.xml&lt;br/&gt;
trunk/src/test/java/org/apache/commons/jexl3/IssuesTest200.java&lt;/p&gt;

&lt;p&gt;Committed revision 1820568.&lt;/p&gt;</comment>
                            <comment id="16318098" author="dmitri_blinov" created="Tue, 9 Jan 2018 09:15:52 +0000"  >&lt;p&gt;Well, while I can not say JEXL does not do its job here, I hate the idea of having even once an exception logged for a such simple situation. Obviously we have a contradiction with overloading. For a JEXL extension writer it would be not uncommon to try to overload an operator more than once using different signatures for different types. But that would surely lead to ambiguity with &lt;b&gt;null&lt;/b&gt; arguments. The solution I see right now on the developer side is to replace all overloaded methods with the only most broad definition like &lt;tt&gt;public JexlOperator selfAdd(Object x, Object y)&lt;/tt&gt;, and do class checking inside that method, forwarding further calls to the specific methods from there, and blocking &lt;b&gt;null&lt;/b&gt; arguements. But that kills the idea of using JEXL feature for resolving most specific methods, possibly conflicting with default JEXL implementation for other types, not speaking of creating messy code. Otherwise, if we try to fix it on JEXL side, in case where the first argument is &lt;b&gt;null&lt;/b&gt;, we should try to resolve this only to the overloaded methods whose first argument is &lt;b&gt;Object&lt;/b&gt;, like &lt;tt&gt;public JexlOperator selfAdd(Object x, T y)&lt;/tt&gt; of even unary &lt;tt&gt;public JexlOperator selfAdd(T y)&lt;/tt&gt;&lt;/p&gt;

&lt;p&gt;Null arguments are not suited for type checking, and even if we have had the only one overloaded method in Arithmetic class, for example &lt;tt&gt;public JexlOperator selfAdd(Collection x, Object y)&lt;/tt&gt;, it would be pointless to try to do anything with &lt;b&gt;null&lt;/b&gt; collection, except for returning JexlEngine.TRY_FAILED&lt;/p&gt;</comment>
                            <comment id="16322231" author="henrib" created="Thu, 11 Jan 2018 13:51:55 +0000"  >&lt;p&gt;Ambiguities related to null argument handling should not trigger logging an exception.&lt;/p&gt;</comment>
                            <comment id="16322248" author="henrib" created="Thu, 11 Jan 2018 14:06:10 +0000"  >&lt;p&gt;Adds the concept of severity to an AmbiguousException:&lt;/p&gt;

&lt;p&gt;The only &lt;b&gt;non-severe&lt;/b&gt; case is when there is at least one null argument and at most one method/ctor is having a corresponding &apos;Object&apos; parameter.&lt;br/&gt;
We thus consider that ambiguity is benign in presence of null arguments but in the case where the &apos;catch all&apos; type Object is applicable more than once.&lt;/p&gt;

&lt;p&gt;In other words:&lt;br/&gt;
If all arguments are valid instances - no null argument -, ambiguity is severe.&lt;br/&gt;
If there is at least one null argument, the ambiguity is severe if more than one method has a&lt;br/&gt;
corresponding parameter of class &apos;Object&apos;.&lt;/p&gt;

&lt;p&gt;src/main/java/org/apache/commons/jexl3/internal/introspection/Introspector.java&lt;br/&gt;
src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java&lt;br/&gt;
src/test/java/org/apache/commons/jexl3/IssuesTest200.java&lt;/p&gt;

&lt;p&gt;Committed revision 1820883.&lt;/p&gt;</comment>
                            <comment id="16324122" author="dmitri_blinov" created="Fri, 12 Jan 2018 15:28:45 +0000"  >&lt;p&gt;As it has turned out for me, Jexl restricts me, for some reason, from overloading operators in Arithmetic, if the operator signature is of generalized form, like &lt;tt&gt;operator(Object)&lt;/tt&gt; or &lt;tt&gt;operator(Object, Object)&lt;/tt&gt;. So the idea of having &lt;tt&gt;public JexlOperator selfAdd(Object x, Object y)&lt;/tt&gt; does not apply. I don&apos;t know if it worth raising an issue about that, or it&apos;s better to find the more appropriate solution to the original problem. Lets not over-complicate. Suppose, we have an original script for &lt;tt&gt;z += 1&lt;/tt&gt; and standard Arithmetic without any &lt;tt&gt;selfAdd&lt;/tt&gt; overloaded operators. Should this work for an empty z value? I think it should. So, it should work exactly the same as with any number of &lt;tt&gt;selfAdd&lt;/tt&gt; overloaded operators too. It&apos;s not an ambiguity, it&apos;s like Jexl couldn&apos;t find an appropriate overloaded operator for this case, and reverted to the default implementation.&lt;/p&gt;</comment>
                            <comment id="16327643" author="henrib" created="Tue, 16 Jan 2018 19:25:07 +0000"  >&lt;p&gt;Not all Overloads on side-effects operators are properly&#160;detected.&lt;/p&gt;

&lt;p&gt;Note that&#160;the &lt;b&gt;default&lt;/b&gt; behavior of self assignment is based on the base operator behavior; so&#160;&#160;&apos;x += y&apos; is equivalent to &apos;x = x + y&apos;. If y == null, x + y will provoque an error due to a null operand. &apos;x += y&apos; will generate an error with the same cause.&lt;/p&gt;

&lt;p&gt;&#160;&lt;/p&gt;</comment>
                            <comment id="16327665" author="henrib" created="Tue, 16 Jan 2018 19:40:32 +0000"  >&lt;p&gt;Uberspect&#160;on&#160;JexlArithmetic now properly sees&#160;all operator methods that are not mere overrides of base implementation. For instance &apos;JexlOperator selfAdd(Object...&apos; is now detected.&lt;/p&gt;

&lt;p&gt;MethodKey has relaxed rules wrt ambiguity with nulls; if there are several applicable method and one&#160;the parameter is null, if one applicable defines&#160;this parameter as an Object, no ambiguity will be reported and that method will be chosen. In other words, when null is present as argument, parameter of type Object is considered the best match (over more precisely typed parameters).&lt;/p&gt;

&lt;p&gt;src/main/java/org/apache/commons/jexl3/internal/introspection/MethodKey.java&lt;br/&gt;
src/main/java/org/apache/commons/jexl3/internal/introspection/Uberspect.java&lt;br/&gt;
src/test/java/org/apache/commons/jexl3/IssuesTest200.java&lt;br/&gt;
src/test/java/org/apache/commons/jexl3/SideEffectTest.java&lt;/p&gt;

&lt;p&gt;Committed revision 1821295.&lt;/p&gt;</comment>
                            <comment id="16334042" author="dmitri_blinov" created="Mon, 22 Jan 2018 08:47:04 +0000"  >&lt;p&gt;The following messages have started to appear in the log&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;Method public java.lang.Object MyArithmetic.add(java.lang.Object,java.lang.Object) is already registered, key: addjava.lang.Objectjava.lang.Object&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;for the overridden methods in MyArithmetic&lt;/p&gt;
&lt;div class=&quot;code panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;codeContent panelContent&quot;&gt;
&lt;pre class=&quot;code-java&quot;&gt;
@Override
&lt;span class=&quot;code-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; add(&lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; left, &lt;span class=&quot;code-object&quot;&gt;Object&lt;/span&gt; right) {
   ....&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;This is expected the behaviour to have the basic JexlArithmetic class methods overridden, right? So why this message?&lt;/p&gt;</comment>
                            <comment id="16334201" author="henrib" created="Mon, 22 Jan 2018 12:30:50 +0000"  >&lt;p&gt;Fixed; message is only intended when signature is undistinguishable from JEXL point of view&#160;&lt;/p&gt;

&lt;p&gt;(for instance, void setFoo(Integer o) ; vs void setFoo(int i); )&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            7 years, 42 weeks, 5 days ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i3odaf:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>9223372036854775807</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>