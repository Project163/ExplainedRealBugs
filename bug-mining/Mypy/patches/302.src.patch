diff --git a/mypy/subtypes.py b/mypy/subtypes.py
index b322cf7b6..9c6518b9e 100644
--- a/mypy/subtypes.py
+++ b/mypy/subtypes.py
@@ -1802,6 +1802,9 @@ def covers_at_runtime(item: Type, supertype: Type) -> bool:
             # Special case useful for selecting TypedDicts from unions using isinstance(x, dict).
             if supertype.type.fullname == "builtins.dict":
                 return True
+        elif isinstance(item, TypeVarType):
+            if is_proper_subtype(item.upper_bound, supertype, ignore_promotions=True):
+                return True
         elif isinstance(item, Instance) and supertype.type.fullname == "builtins.int":
             # "int" covers all native int types
             if item.type.fullname in MYPYC_NATIVE_INT_NAMES:
diff --git a/test-data/unit/check-selftype.test b/test-data/unit/check-selftype.test
index 752de3741..8083aaf7c 100644
--- a/test-data/unit/check-selftype.test
+++ b/test-data/unit/check-selftype.test
@@ -1829,3 +1829,21 @@ class C(Generic[T]):
         reveal_type(self.val)  # N: Revealed type is "__main__.A" \
                                # N: Revealed type is "__main__.B"
         self.val = x
+
+[case testNarrowSelfType]
+from typing import Self, Union
+
+class A: ...
+class B:
+    def f1(self, v: Union[Self, A]) -> A:
+        if isinstance(v, B):
+            return A()
+        else:
+            return v
+    def f2(self, v: Union[Self, A]) -> A:
+        if isinstance(v, B):
+            return A()
+        else:
+            return B()  # E: Incompatible return value type (got "B", expected "A")
+
+[builtins fixtures/isinstancelist.pyi]
