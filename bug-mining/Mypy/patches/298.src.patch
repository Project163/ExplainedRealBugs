diff --git a/mypy/expandtype.py b/mypy/expandtype.py
index 9a8675319..21c3a5926 100644
--- a/mypy/expandtype.py
+++ b/mypy/expandtype.py
@@ -485,9 +485,15 @@ class ExpandTypeVisitor(TypeVisitor[Type]):
         # After substituting for type variables in t.items, some resulting types
         # might be subtypes of others, however calling  make_simplified_union()
         # can cause recursion, so we just remove strict duplicates.
-        return UnionType.make_union(
+        simplified = UnionType.make_union(
             remove_trivial(flatten_nested_unions(expanded)), t.line, t.column
         )
+        # This call to get_proper_type() is unfortunate but is required to preserve
+        # the invariant that ProperType will stay ProperType after applying expand_type(),
+        # otherwise a single item union of a type alias will break it. Note this should not
+        # cause infinite recursion since pathological aliases like A = Union[A, B] are
+        # banned at the semantic analysis level.
+        return get_proper_type(simplified)
 
     def visit_partial_type(self, t: PartialType) -> Type:
         return t
diff --git a/test-data/unit/check-type-aliases.test b/test-data/unit/check-type-aliases.test
index d7cccd2d6..9dd56ad30 100644
--- a/test-data/unit/check-type-aliases.test
+++ b/test-data/unit/check-type-aliases.test
@@ -1028,3 +1028,18 @@ RHSAlias3: type = tuple[int, ...]
 WrongTypeElement = str | tuple[float, 1]  # E: Invalid type: try using Literal[1] instead?
 WrongEllipsis = str | tuple[float, float, ...]  # E: Unexpected "..."
 [builtins fixtures/tuple.pyi]
+
+[case testCompiledNoCrashOnSingleItemUnion]
+# flags: --no-strict-optional
+from typing import Callable, Union, Generic, TypeVar
+
+Alias = Callable[[], int]
+
+T = TypeVar("T")
+class C(Generic[T]):
+    attr: Union[Alias, None] = None
+
+    @classmethod
+    def test(cls) -> None:
+        cls.attr
+[builtins fixtures/classmethod.pyi]
