diff --git a/mypy/checker.py b/mypy/checker.py
index 415cb0d5c..106c8e9a0 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -2709,8 +2709,10 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
         if inferred.info:
             for base in inferred.info.mro[1:]:
                 base_type, base_node = self.lvalue_type_from_base(inferred, base)
-                if base_type and not (
-                    isinstance(base_node, Var) and base_node.invalid_partial_type
+                if (
+                    base_type
+                    and not (isinstance(base_node, Var) and base_node.invalid_partial_type)
+                    and not isinstance(base_type, PartialType)
                 ):
                     type_contexts.append(base_type)
         # Use most derived supertype as type context if available.
@@ -2813,6 +2815,8 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
                     continue
 
                 base_type, base_node = self.lvalue_type_from_base(lvalue_node, base)
+                if isinstance(base_type, PartialType):
+                    base_type = None
 
                 if base_type:
                     assert base_node is not None
diff --git a/test-data/unit/check-inference.test b/test-data/unit/check-inference.test
index ffcd6d8d9..26b468342 100644
--- a/test-data/unit/check-inference.test
+++ b/test-data/unit/check-inference.test
@@ -3328,3 +3328,12 @@ class C(P, M):
     x = []  # E: Need type annotation for "x" (hint: "x: List[<type>] = ...")
 reveal_type(C.x)  # N: Revealed type is "builtins.list[Any]"
 [builtins fixtures/list.pyi]
+
+[case testNoPartialInSupertypeAsContext]
+class A:
+    args = {}  # E: Need type annotation for "args" (hint: "args: Dict[<type>, <type>] = ...")
+    def f(self) -> None:
+        value = {1: "Hello"}
+        class B(A):
+            args = value
+[builtins fixtures/dict.pyi]
