diff --git a/docs/source/error_code_list2.rst b/docs/source/error_code_list2.rst
index 0a2d8a8c5..0cf96ba9c 100644
--- a/docs/source/error_code_list2.rst
+++ b/docs/source/error_code_list2.rst
@@ -82,6 +82,25 @@ Example:
         # Error: Redundant cast to "int"  [redundant-cast]
         return cast(int, x)
 
+Check that methods do not have redundant Self annotations [redundant-self]
+--------------------------------------------------------------------------
+
+Such annotations are allowed by :pep:`673` but are redundant, so if you want
+warnings about them, enable this error code.
+
+Example:
+
+.. code-block:: python
+
+   # mypy: enable-error-code="redundant-self"
+
+   from typing import Self
+
+   class C:
+       # Error: Redundant Self annotation on method first argument
+       def copy(self: Self) -> Self:
+           return type(self)()
+
 Check that comparisons are overlapping [comparison-overlap]
 -----------------------------------------------------------
 
diff --git a/docs/source/generics.rst b/docs/source/generics.rst
index 3ae616f78..59d4aa1a2 100644
--- a/docs/source/generics.rst
+++ b/docs/source/generics.rst
@@ -264,15 +264,8 @@ Generic methods and generic self
 You can also define generic methods â€” just use a type variable in the
 method signature that is different from class type variables. In particular,
 ``self`` may also be generic, allowing a method to return the most precise
-type known at the point of access.
-
-.. note::
-
-   This feature is experimental. Checking code with type annotations for self
-   arguments is still not fully implemented. Mypy may disallow valid code or
-   allow unsafe code.
-
-In this way, for example, you can typecheck chaining of setter methods:
+type known at the point of access. In this way, for example, you can typecheck
+chaining of setter methods:
 
 .. code-block:: python
 
@@ -333,8 +326,69 @@ or a deserialization method returns the actual type of self. Therefore
 you may need to silence mypy inside these methods (but not at the call site),
 possibly by making use of the ``Any`` type.
 
+Note that this feature may accept some unsafe code for the purpose of
+*practicality*. For example:
+
+.. code-block:: python
+
+   from typing import TypeVar
+
+   T = TypeVar("T")
+   class Base:
+       def compare(self: T, other: T) -> bool:
+           return False
+
+   class Sub(Base):
+       def __init__(self, x: int) -> None:
+           self.x = x
+
+       # This is unsafe (see below), but allowed because it is
+       # a common pattern, and rarely causes issues in practice.
+       def compare(self, other: Sub) -> bool:
+           return self.x > other.x
+
+   b: Base = Sub(42)
+   b.compare(Base())  # Runtime error here: 'Base' object has no attribute 'x'
+
 For some advanced uses of self-types see :ref:`additional examples <advanced_self>`.
 
+Automatic self types using typing.Self
+**************************************
+
+The patterns described above are quite common, so there is a syntactic sugar
+for them introduced in :pep:`673`. Instead of defining a type variable and
+using an explicit ``self`` annotation, you can import a magic type ``typing.Self``
+that is automatically transformed into a type variable with an upper bound of
+current class, and you don't need an annotation for ``self`` (or ``cls`` for
+class methods). The above example can thus be rewritten as:
+
+.. code-block:: python
+
+   from typing import Self
+
+   class Friend:
+       other: Self | None = None
+
+       @classmethod
+       def make_pair(cls) -> tuple[Self, Self]:
+           a, b = cls(), cls()
+           a.other = b
+           b.other = a
+           return a, b
+
+   class SuperFriend(Friend):
+       pass
+
+   a, b = SuperFriend.make_pair()
+
+This is more compact than using explicit type variables, plus additionally
+you can use ``Self`` in attribute annotations, not just in methods.
+
+.. note::
+
+   To use this feature on versions of Python before 3.11, you will need to
+   import ``Self`` from ``typing_extensions`` version 4.0 or newer.
+
 .. _variance-of-generics:
 
 Variance of generic types
@@ -548,7 +602,7 @@ Note that class decorators are handled differently than function decorators in
 mypy: decorating a class does not erase its type, even if the decorator has
 incomplete type annotations.
 
-Suppose we have the following decorator, not type annotated yet, 
+Suppose we have the following decorator, not type annotated yet,
 that preserves the original function's signature and merely prints the decorated function's name:
 
 .. code-block:: python
diff --git a/docs/source/more_types.rst b/docs/source/more_types.rst
index 707411e95..722909a03 100644
--- a/docs/source/more_types.rst
+++ b/docs/source/more_types.rst
@@ -804,9 +804,10 @@ classes are generic, self-type allows giving them precise signatures:
 .. code-block:: python
 
    T = TypeVar('T')
-   Q = TypeVar('Q', bound='Base[Any]')
 
    class Base(Generic[T]):
+       Q = TypeVar('Q', bound='Base[T]')
+
        def __init__(self, item: T) -> None:
            self.item = item
 
diff --git a/mypy/checker.py b/mypy/checker.py
index ea7f46af5..57725bd91 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -39,7 +39,7 @@ from mypy.constraints import SUPERTYPE_OF
 from mypy.erasetype import erase_type, erase_typevars, remove_instance_last_known_values
 from mypy.errorcodes import TYPE_VAR, UNUSED_AWAITABLE, UNUSED_COROUTINE, ErrorCode
 from mypy.errors import Errors, ErrorWatcher, report_internal_error
-from mypy.expandtype import expand_type, expand_type_by_instance
+from mypy.expandtype import expand_self_type, expand_type, expand_type_by_instance
 from mypy.join import join_types
 from mypy.literals import Key, literal, literal_hash
 from mypy.maptype import map_instance_to_supertype
@@ -2488,6 +2488,10 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
                 second_sig = self.bind_and_map_method(second, second_type, ctx, base2)
                 ok = is_subtype(first_sig, second_sig, ignore_pos_arg_names=True)
         elif first_type and second_type:
+            if isinstance(first.node, Var):
+                first_type = expand_self_type(first.node, first_type, fill_typevars(ctx))
+            if isinstance(second.node, Var):
+                second_type = expand_self_type(second.node, second_type, fill_typevars(ctx))
             ok = is_equivalent(first_type, second_type)
             if not ok:
                 second_node = base2[name].node
@@ -3068,6 +3072,8 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
         if base_var:
             base_node = base_var.node
             base_type = base_var.type
+            if isinstance(base_node, Var) and base_type is not None:
+                base_type = expand_self_type(base_node, base_type, fill_typevars(expr_node.info))
             if isinstance(base_node, Decorator):
                 base_node = base_node.func
                 base_type = base_node.type
diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index a271fb876..376e1f811 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -2667,6 +2667,10 @@ class ExpressionChecker(ExpressionVisitor[Type]):
 
             if isinstance(base, RefExpr) and isinstance(base.node, MypyFile):
                 module_symbol_table = base.node.names
+            if isinstance(base, RefExpr) and isinstance(base.node, Var):
+                is_self = base.node.is_self
+            else:
+                is_self = False
 
             member_type = analyze_member_access(
                 e.name,
@@ -2680,6 +2684,7 @@ class ExpressionChecker(ExpressionVisitor[Type]):
                 chk=self.chk,
                 in_literal_context=self.is_literal_context(),
                 module_symbol_table=module_symbol_table,
+                is_self=is_self,
             )
 
             return member_type
diff --git a/mypy/checkmember.py b/mypy/checkmember.py
index 6c9da4a6c..c81b3fbe4 100644
--- a/mypy/checkmember.py
+++ b/mypy/checkmember.py
@@ -6,7 +6,7 @@ from typing import TYPE_CHECKING, Callable, Sequence, cast
 
 from mypy import meet, message_registry, subtypes
 from mypy.erasetype import erase_typevars
-from mypy.expandtype import expand_type_by_instance, freshen_function_type_vars
+from mypy.expandtype import expand_self_type, expand_type_by_instance, freshen_function_type_vars
 from mypy.maptype import map_instance_to_supertype
 from mypy.messages import MessageBuilder
 from mypy.nodes import (
@@ -37,6 +37,7 @@ from mypy.typeops import (
     erase_to_bound,
     function_type,
     make_simplified_union,
+    supported_self_type,
     tuple_fallback,
     type_object_type_from_function,
 )
@@ -90,6 +91,7 @@ class MemberContext:
         self_type: Type | None,
         module_symbol_table: SymbolTable | None = None,
         no_deferral: bool = False,
+        is_self: bool = False,
     ) -> None:
         self.is_lvalue = is_lvalue
         self.is_super = is_super
@@ -101,6 +103,7 @@ class MemberContext:
         self.chk = chk
         self.module_symbol_table = module_symbol_table
         self.no_deferral = no_deferral
+        self.is_self = is_self
 
     def named_type(self, name: str) -> Instance:
         return self.chk.named_type(name)
@@ -152,6 +155,7 @@ def analyze_member_access(
     self_type: Type | None = None,
     module_symbol_table: SymbolTable | None = None,
     no_deferral: bool = False,
+    is_self: bool = False,
 ) -> Type:
     """Return the type of attribute 'name' of 'typ'.
 
@@ -187,6 +191,7 @@ def analyze_member_access(
         self_type=self_type,
         module_symbol_table=module_symbol_table,
         no_deferral=no_deferral,
+        is_self=is_self,
     )
     result = _analyze_member_access(name, typ, mx, override_info)
     possible_literal = get_proper_type(result)
@@ -682,12 +687,12 @@ def analyze_descriptor_access(descriptor_type: Type, mx: MemberContext) -> Type:
     return inferred_dunder_get_type.ret_type
 
 
-def is_instance_var(var: Var, info: TypeInfo) -> bool:
+def is_instance_var(var: Var) -> bool:
     """Return if var is an instance variable according to PEP 526."""
     return (
         # check the type_info node is the var (not a decorated function, etc.)
-        var.name in info.names
-        and info.names[var.name].node is var
+        var.name in var.info.names
+        and var.info.names[var.name].node is var
         and not var.is_classvar
         # variables without annotations are treated as classvar
         and not var.is_inferred
@@ -722,12 +727,16 @@ def analyze_var(
             mx.msg.read_only_property(name, itype.type, mx.context)
         if mx.is_lvalue and var.is_classvar:
             mx.msg.cant_assign_to_classvar(name, mx.context)
+        if not (mx.is_self or mx.is_super) or supported_self_type(
+            get_proper_type(mx.original_type)
+        ):
+            typ = expand_self_type(var, typ, mx.original_type)
         t = get_proper_type(expand_type_by_instance(typ, itype))
         result: Type = t
         typ = get_proper_type(typ)
         if (
             var.is_initialized_in_class
-            and (not is_instance_var(var, info) or mx.is_operator)
+            and (not is_instance_var(var) or mx.is_operator)
             and isinstance(typ, FunctionLike)
             and not typ.is_type_obj()
         ):
@@ -945,7 +954,12 @@ def analyze_class_attribute_access(
             #         x: T
             #     C.x  # Error, ambiguous access
             #     C[int].x  # Also an error, since C[int] is same as C at runtime
-            if isinstance(t, TypeVarType) or has_type_vars(t):
+            # Exception is Self type wrapped in ClassVar, that is safe.
+            if node.node.info.self_type is not None and node.node.is_classvar:
+                exclude = node.node.info.self_type.id
+            else:
+                exclude = None
+            if isinstance(t, TypeVarType) and t.id != exclude or has_type_vars(t, exclude):
                 # Exception: access on Type[...], including first argument of class methods is OK.
                 if not isinstance(get_proper_type(mx.original_type), TypeType) or node.implicit:
                     if node.node.is_classvar:
@@ -958,6 +972,7 @@ def analyze_class_attribute_access(
             # In the above example this means that we infer following types:
             #     C.x -> Any
             #     C[int].x -> int
+            t = get_proper_type(expand_self_type(node.node, t, itype))
             t = erase_typevars(expand_type_by_instance(t, isuper))
 
         is_classmethod = (is_decorated and cast(Decorator, node.node).func.is_class) or (
diff --git a/mypy/errorcodes.py b/mypy/errorcodes.py
index 3aee68810..e1efc10b7 100644
--- a/mypy/errorcodes.py
+++ b/mypy/errorcodes.py
@@ -186,6 +186,12 @@ UNUSED_AWAITABLE: Final = ErrorCode(
     "General",
     default_enabled=False,
 )
+REDUNDANT_SELF_TYPE = ErrorCode(
+    "redundant-self",
+    "Warn about redundant Self type annotations on method first argument",
+    "General",
+    default_enabled=False,
+)
 
 
 # Syntax errors are often blocking.
diff --git a/mypy/expandtype.py b/mypy/expandtype.py
index 08bc21668..5a56857e1 100644
--- a/mypy/expandtype.py
+++ b/mypy/expandtype.py
@@ -2,7 +2,7 @@ from __future__ import annotations
 
 from typing import Iterable, Mapping, Sequence, TypeVar, cast, overload
 
-from mypy.nodes import ARG_STAR
+from mypy.nodes import ARG_STAR, Var
 from mypy.types import (
     AnyType,
     CallableType,
@@ -383,3 +383,20 @@ def expand_unpack_with_variables(
             raise NotImplementedError(f"Invalid type replacement to expand: {repl}")
     else:
         raise NotImplementedError(f"Invalid type to expand: {t.type}")
+
+
+@overload
+def expand_self_type(var: Var, typ: ProperType, replacement: ProperType) -> ProperType:
+    ...
+
+
+@overload
+def expand_self_type(var: Var, typ: Type, replacement: Type) -> Type:
+    ...
+
+
+def expand_self_type(var: Var, typ: Type, replacement: Type) -> Type:
+    """Expand appearances of Self type in a variable type."""
+    if var.info.self_type is not None and not var.is_property:
+        return expand_type(typ, {var.info.self_type.id: replacement})
+    return typ
diff --git a/mypy/message_registry.py b/mypy/message_registry.py
index 219c44549..a067763d8 100644
--- a/mypy/message_registry.py
+++ b/mypy/message_registry.py
@@ -238,6 +238,7 @@ CANNOT_OVERRIDE_CLASS_VAR: Final = ErrorMessage(
     "variable"
 )
 CLASS_VAR_WITH_TYPEVARS: Final = "ClassVar cannot contain type variables"
+CLASS_VAR_WITH_GENERIC_SELF: Final = "ClassVar cannot contain Self type in generic classes"
 CLASS_VAR_OUTSIDE_OF_CLASS: Final = "ClassVar can only be used for assignments in class body"
 
 # Protocol
diff --git a/mypy/nodes.py b/mypy/nodes.py
index 0ea89611d..7f2fd9a49 100644
--- a/mypy/nodes.py
+++ b/mypy/nodes.py
@@ -2813,6 +2813,7 @@ class TypeInfo(SymbolNode):
         "has_type_var_tuple_type",
         "type_var_tuple_prefix",
         "type_var_tuple_suffix",
+        "self_type",
     )
 
     _fullname: Bogus[str]  # Fully qualified name
@@ -2953,6 +2954,9 @@ class TypeInfo(SymbolNode):
     # in case we are doing multiple semantic analysis passes.
     special_alias: TypeAlias | None
 
+    # Shared type variable for typing.Self in this class (if used, otherwise None).
+    self_type: mypy.types.TypeVarType | None
+
     FLAGS: Final = [
         "is_abstract",
         "is_enum",
@@ -3005,6 +3009,7 @@ class TypeInfo(SymbolNode):
         self.is_newtype = False
         self.is_intersection = False
         self.metadata = {}
+        self.self_type = None
 
     def add_type_vars(self) -> None:
         self.has_type_var_tuple_type = False
@@ -3222,6 +3227,7 @@ class TypeInfo(SymbolNode):
             "metadata": self.metadata,
             "slots": list(sorted(self.slots)) if self.slots is not None else None,
             "deletable_attributes": self.deletable_attributes,
+            "self_type": self.self_type.serialize() if self.self_type is not None else None,
         }
         return data
 
@@ -3278,6 +3284,8 @@ class TypeInfo(SymbolNode):
         ti.slots = set(data["slots"]) if data["slots"] is not None else None
         ti.deletable_attributes = data["deletable_attributes"]
         set_flags(ti, data["flags"])
+        st = data["self_type"]
+        ti.self_type = mypy.types.TypeVarType.deserialize(st) if st is not None else None
         return ti
 
 
diff --git a/mypy/plugins/dataclasses.py b/mypy/plugins/dataclasses.py
index 26bc8ae80..75496d5e5 100644
--- a/mypy/plugins/dataclasses.py
+++ b/mypy/plugins/dataclasses.py
@@ -2,8 +2,10 @@
 
 from __future__ import annotations
 
+from typing import Optional
 from typing_extensions import Final
 
+from mypy.expandtype import expand_type
 from mypy.nodes import (
     ARG_NAMED,
     ARG_NAMED_OPT,
@@ -50,6 +52,7 @@ from mypy.types import (
     TypeVarType,
     get_proper_type,
 )
+from mypy.typevars import fill_typevars
 
 # The set of decorators that generate dataclasses.
 dataclass_makers: Final = {"dataclass", "dataclasses.dataclass"}
@@ -83,7 +86,7 @@ class DataclassAttribute:
         self.info = info
         self.kw_only = kw_only
 
-    def to_argument(self) -> Argument:
+    def to_argument(self, current_info: TypeInfo) -> Argument:
         arg_kind = ARG_POS
         if self.kw_only and self.has_default:
             arg_kind = ARG_NAMED_OPT
@@ -92,11 +95,23 @@ class DataclassAttribute:
         elif not self.kw_only and self.has_default:
             arg_kind = ARG_OPT
         return Argument(
-            variable=self.to_var(), type_annotation=self.type, initializer=None, kind=arg_kind
+            variable=self.to_var(current_info),
+            type_annotation=self.expand_type(current_info),
+            initializer=None,
+            kind=arg_kind,
         )
 
-    def to_var(self) -> Var:
-        return Var(self.name, self.type)
+    def expand_type(self, current_info: TypeInfo) -> Optional[Type]:
+        if self.type is not None and self.info.self_type is not None:
+            # In general, it is not safe to call `expand_type()` during semantic analyzis,
+            # however this plugin is called very late, so all types should be fully ready.
+            # Also, it is tricky to avoid eager expansion of Self types here (e.g. because
+            # we serialize attributes).
+            return expand_type(self.type, {self.info.self_type.id: fill_typevars(current_info)})
+        return self.type
+
+    def to_var(self, current_info: TypeInfo) -> Var:
+        return Var(self.name, self.expand_type(current_info))
 
     def serialize(self) -> JsonDict:
         assert self.type
@@ -175,11 +190,12 @@ class DataclassTransformer:
             and attributes
         ):
 
-            args = [
-                attr.to_argument()
-                for attr in attributes
-                if attr.is_in_init and not self._is_kw_only_type(attr.type)
-            ]
+            with state.strict_optional_set(ctx.api.options.strict_optional):
+                args = [
+                    attr.to_argument(info)
+                    for attr in attributes
+                    if attr.is_in_init and not self._is_kw_only_type(attr.type)
+                ]
 
             if info.fallback_to_any:
                 # Make positional args optional since we don't know their order.
@@ -548,7 +564,7 @@ class DataclassTransformer:
                 if isinstance(var, Var):
                     var.is_property = True
             else:
-                var = attr.to_var()
+                var = attr.to_var(info)
                 var.info = info
                 var.is_property = True
                 var._fullname = info.fullname + "." + var.name
@@ -567,7 +583,7 @@ class DataclassTransformer:
         info = self._ctx.cls.info
         for attr in attributes:
             if isinstance(get_proper_type(attr.type), CallableType):
-                var = attr.to_var()
+                var = attr.to_var(info)
                 var.info = info
                 var.is_property = True
                 var.is_settable_property = settable
diff --git a/mypy/semanal.py b/mypy/semanal.py
index 46ae4b26d..b8ffdc98e 100644
--- a/mypy/semanal.py
+++ b/mypy/semanal.py
@@ -219,12 +219,14 @@ from mypy.semanal_shared import (
 from mypy.semanal_typeddict import TypedDictAnalyzer
 from mypy.tvar_scope import TypeVarLikeScope
 from mypy.typeanal import (
+    SELF_TYPE_NAMES,
     TypeAnalyser,
     TypeVarLikeList,
     TypeVarLikeQuery,
     analyze_type_alias,
     check_for_explicit_any,
     detect_diverging_alias,
+    find_self_type,
     fix_instance_types,
     has_any_from_unimported_type,
     no_subscript_builtin_alias,
@@ -339,7 +341,7 @@ class SemanticAnalyzer(
     # Nested block depths of scopes
     block_depth: list[int]
     # TypeInfo of directly enclosing class (or None)
-    type: TypeInfo | None = None
+    _type: TypeInfo | None = None
     # Stack of outer classes (the second tuple item contains tvars).
     type_stack: list[TypeInfo | None]
     # Type variables bound by the current scope, be it class or function
@@ -418,7 +420,7 @@ class SemanticAnalyzer(
             FuncItem | GeneratorExpr | DictionaryComprehension, SymbolTable
         ] = {}
         self.imports = set()
-        self.type = None
+        self._type = None
         self.type_stack = []
         # Are the namespaces of classes being processed complete?
         self.incomplete_type_stack: list[bool] = []
@@ -458,6 +460,10 @@ class SemanticAnalyzer(
 
     # mypyc doesn't properly handle implementing an abstractproperty
     # with a regular attribute so we make them properties
+    @property
+    def type(self) -> TypeInfo | None:
+        return self._type
+
     @property
     def is_stub_file(self) -> bool:
         return self._is_stub_file
@@ -771,7 +777,7 @@ class SemanticAnalyzer(
             if active_type:
                 scope.leave_class()
                 self.leave_class()
-                self.type = None
+                self._type = None
                 self.incomplete_type_stack.pop()
         del self.options
 
@@ -812,7 +818,10 @@ class SemanticAnalyzer(
 
         if defn.type:
             assert isinstance(defn.type, CallableType)
-            self.update_function_type_variables(defn.type, defn)
+            has_self_type = self.update_function_type_variables(defn.type, defn)
+        else:
+            has_self_type = False
+
         self.function_stack.pop()
 
         if self.is_class_scope():
@@ -823,7 +832,7 @@ class SemanticAnalyzer(
                 assert isinstance(defn.type, CallableType)
                 if isinstance(get_proper_type(defn.type.ret_type), AnyType):
                     defn.type = defn.type.copy_modified(ret_type=NoneType())
-            self.prepare_method_signature(defn, self.type)
+            self.prepare_method_signature(defn, self.type, has_self_type)
 
         # Analyze function signature
         with self.tvar_scope_frame(self.tvar_scope.method_frame()):
@@ -842,6 +851,10 @@ class SemanticAnalyzer(
                 assert isinstance(result, ProperType)
                 if isinstance(result, CallableType):
                     result = self.remove_unpack_kwargs(defn, result)
+                    if has_self_type and self.type is not None:
+                        info = self.type
+                        if info.self_type is not None:
+                            result.variables = [info.self_type] + list(result.variables)
                 defn.type = result
                 self.add_type_alias_deps(analyzer.aliases_used)
                 self.check_function_signature(defn)
@@ -914,7 +927,7 @@ class SemanticAnalyzer(
         new_arg_types = typ.arg_types[:-1] + [last_type]
         return typ.copy_modified(arg_types=new_arg_types, unpack_kwargs=True)
 
-    def prepare_method_signature(self, func: FuncDef, info: TypeInfo) -> None:
+    def prepare_method_signature(self, func: FuncDef, info: TypeInfo, has_self_type: bool) -> None:
         """Check basic signature validity and tweak annotation of self/cls argument."""
         # Only non-static methods are special.
         functype = func.type
@@ -926,10 +939,51 @@ class SemanticAnalyzer(
             elif isinstance(functype, CallableType):
                 self_type = get_proper_type(functype.arg_types[0])
                 if isinstance(self_type, AnyType):
-                    leading_type: Type = fill_typevars(info)
+                    if has_self_type:
+                        assert self.type is not None and self.type.self_type is not None
+                        leading_type: Type = self.type.self_type
+                    else:
+                        leading_type = fill_typevars(info)
                     if func.is_class or func.name == "__new__":
                         leading_type = self.class_type(leading_type)
                     func.type = replace_implicit_first_type(functype, leading_type)
+                elif has_self_type and isinstance(func.unanalyzed_type, CallableType):
+                    if not isinstance(get_proper_type(func.unanalyzed_type.arg_types[0]), AnyType):
+                        if self.is_expected_self_type(
+                            self_type, func.is_class or func.name == "__new__"
+                        ):
+                            # This error is off by default, since it is explicitly allowed
+                            # by the PEP 673.
+                            self.fail(
+                                "Redundant Self annotation on method first argument",
+                                func,
+                                code=codes.REDUNDANT_SELF_TYPE,
+                            )
+                        else:
+                            self.fail(
+                                "Method cannot have explicit self annotation and Self type", func
+                            )
+        elif has_self_type:
+            self.fail("Static methods cannot use Self type", func)
+
+    def is_expected_self_type(self, typ: Type, is_classmethod: bool) -> bool:
+        """Does this (analyzed or not) type represent the expected Self type for a method?"""
+        assert self.type is not None
+        typ = get_proper_type(typ)
+        if is_classmethod:
+            if isinstance(typ, TypeType):
+                return self.is_expected_self_type(typ.item, is_classmethod=False)
+            if isinstance(typ, UnboundType):
+                sym = self.lookup_qualified(typ.name, typ, suppress_errors=True)
+                if sym is not None and sym.fullname == "typing.Type" and typ.args:
+                    return self.is_expected_self_type(typ.args[0], is_classmethod=False)
+            return False
+        if isinstance(typ, TypeVarType):
+            return typ == self.type.self_type
+        if isinstance(typ, UnboundType):
+            sym = self.lookup_qualified(typ.name, typ, suppress_errors=True)
+            return sym is not None and sym.fullname in SELF_TYPE_NAMES
+        return False
 
     def set_original_def(self, previous: Node | None, new: FuncDef | Decorator) -> bool:
         """If 'new' conditionally redefine 'previous', set 'previous' as original
@@ -954,15 +1008,32 @@ class SemanticAnalyzer(
         else:
             return False
 
-    def update_function_type_variables(self, fun_type: CallableType, defn: FuncItem) -> None:
+    def update_function_type_variables(self, fun_type: CallableType, defn: FuncItem) -> bool:
         """Make any type variables in the signature of defn explicit.
 
         Update the signature of defn to contain type variable definitions
-        if defn is generic.
+        if defn is generic. Return True, if the signature contains typing.Self
+        type, or False otherwise.
         """
         with self.tvar_scope_frame(self.tvar_scope.method_frame()):
             a = self.type_analyzer()
-            fun_type.variables = a.bind_function_type_variables(fun_type, defn)
+            fun_type.variables, has_self_type = a.bind_function_type_variables(fun_type, defn)
+            if has_self_type and self.type is not None:
+                self.setup_self_type()
+            return has_self_type
+
+    def setup_self_type(self) -> None:
+        """Setup a (shared) Self type variable for current class.
+
+        We intentionally don't add it to the class symbol table,
+        so it can be accessed only by mypy and will not cause
+        clashes with user defined names.
+        """
+        assert self.type is not None
+        info = self.type
+        if info.self_type is not None:
+            return
+        info.self_type = TypeVarType("Self", f"{info.fullname}.Self", 0, [], fill_typevars(info))
 
     def visit_overloaded_func_def(self, defn: OverloadedFuncDef) -> None:
         self.statement = defn
@@ -1641,7 +1712,7 @@ class SemanticAnalyzer(
         self.locals.append(None)  # Add class scope
         self.is_comprehension_stack.append(False)
         self.block_depth.append(-1)  # The class body increments this to 0
-        self.type = info
+        self._type = info
         self.missing_names.append(set())
 
     def leave_class(self) -> None:
@@ -1649,7 +1720,7 @@ class SemanticAnalyzer(
         self.block_depth.pop()
         self.locals.pop()
         self.is_comprehension_stack.pop()
-        self.type = self.type_stack.pop()
+        self._type = self.type_stack.pop()
         self.missing_names.pop()
 
     def analyze_class_decorator(self, defn: ClassDef, decorator: Expression) -> None:
@@ -4069,6 +4140,12 @@ class SemanticAnalyzer(
                 # See https://github.com/python/mypy/issues/11538
 
                 self.fail(message_registry.CLASS_VAR_WITH_TYPEVARS, s)
+            if (
+                analyzed is not None
+                and self.type.self_type in get_type_vars(analyzed)
+                and self.type.defn.type_vars
+            ):
+                self.fail(message_registry.CLASS_VAR_WITH_GENERIC_SELF, s)
         elif not isinstance(lvalue, MemberExpr) or self.is_self_member_ref(lvalue):
             # In case of member access, report error only when assigning to self
             # Other kinds of member assignments should be already reported
@@ -6104,6 +6181,7 @@ class SemanticAnalyzer(
         allow_required: bool = False,
         allow_param_spec_literals: bool = False,
         report_invalid_types: bool = True,
+        prohibit_self_type: str | None = None,
     ) -> TypeAnalyser:
         if tvar_scope is None:
             tvar_scope = self.tvar_scope
@@ -6119,6 +6197,7 @@ class SemanticAnalyzer(
             allow_placeholder=allow_placeholder,
             allow_required=allow_required,
             allow_param_spec_literals=allow_param_spec_literals,
+            prohibit_self_type=prohibit_self_type,
         )
         tpan.in_dynamic_func = bool(self.function_stack and self.function_stack[-1].is_dynamic())
         tpan.global_scope = not self.type and not self.function_stack
@@ -6138,6 +6217,7 @@ class SemanticAnalyzer(
         allow_required: bool = False,
         allow_param_spec_literals: bool = False,
         report_invalid_types: bool = True,
+        prohibit_self_type: str | None = None,
         third_pass: bool = False,
     ) -> Type | None:
         """Semantically analyze a type.
@@ -6160,6 +6240,11 @@ class SemanticAnalyzer(
         NOTE: The caller shouldn't defer even if this returns None or a
               placeholder type.
         """
+        has_self_type = find_self_type(
+            typ, lambda name: self.lookup_qualified(name, typ, suppress_errors=True)
+        )
+        if has_self_type and self.type and prohibit_self_type is None:
+            self.setup_self_type()
         a = self.type_analyzer(
             tvar_scope=tvar_scope,
             allow_unbound_tvars=allow_unbound_tvars,
@@ -6168,6 +6253,7 @@ class SemanticAnalyzer(
             allow_required=allow_required,
             allow_param_spec_literals=allow_param_spec_literals,
             report_invalid_types=report_invalid_types,
+            prohibit_self_type=prohibit_self_type,
         )
         tag = self.track_incomplete_refs()
         typ = typ.accept(a)
diff --git a/mypy/semanal_namedtuple.py b/mypy/semanal_namedtuple.py
index 1727c18b6..04308db99 100644
--- a/mypy/semanal_namedtuple.py
+++ b/mypy/semanal_namedtuple.py
@@ -178,6 +178,7 @@ class NamedTupleAnalyzer:
                         stmt.type,
                         allow_placeholder=not self.options.disable_recursive_aliases
                         and not self.api.is_func_scope(),
+                        prohibit_self_type="NamedTuple item type",
                     )
                     if analyzed is None:
                         # Something is incomplete. We need to defer this named tuple.
@@ -445,6 +446,7 @@ class NamedTupleAnalyzer:
                     type,
                     allow_placeholder=not self.options.disable_recursive_aliases
                     and not self.api.is_func_scope(),
+                    prohibit_self_type="NamedTuple item type",
                 )
                 # Workaround #4987 and avoid introducing a bogus UnboundType
                 if isinstance(analyzed, UnboundType):
diff --git a/mypy/semanal_shared.py b/mypy/semanal_shared.py
index 63f4f5516..ee9218f02 100644
--- a/mypy/semanal_shared.py
+++ b/mypy/semanal_shared.py
@@ -119,6 +119,11 @@ class SemanticAnalyzerCoreInterface:
     def is_func_scope(self) -> bool:
         raise NotImplementedError
 
+    @property
+    @abstractmethod
+    def type(self) -> TypeInfo | None:
+        raise NotImplementedError
+
 
 @trait
 class SemanticAnalyzerInterface(SemanticAnalyzerCoreInterface):
@@ -162,6 +167,7 @@ class SemanticAnalyzerInterface(SemanticAnalyzerCoreInterface):
         allow_required: bool = False,
         allow_placeholder: bool = False,
         report_invalid_types: bool = True,
+        prohibit_self_type: str | None = None,
     ) -> Type | None:
         raise NotImplementedError
 
diff --git a/mypy/semanal_typeddict.py b/mypy/semanal_typeddict.py
index b864c2a30..e8be82bd4 100644
--- a/mypy/semanal_typeddict.py
+++ b/mypy/semanal_typeddict.py
@@ -305,6 +305,7 @@ class TypedDictAnalyzer:
                         allow_required=True,
                         allow_placeholder=not self.options.disable_recursive_aliases
                         and not self.api.is_func_scope(),
+                        prohibit_self_type="TypedDict item type",
                     )
                     if analyzed is None:
                         return None, [], [], set()  # Need to defer
@@ -500,6 +501,7 @@ class TypedDictAnalyzer:
                 allow_required=True,
                 allow_placeholder=not self.options.disable_recursive_aliases
                 and not self.api.is_func_scope(),
+                prohibit_self_type="TypedDict item type",
             )
             if analyzed is None:
                 return None
diff --git a/mypy/subtypes.py b/mypy/subtypes.py
index f928e1cc7..7e49c19c4 100644
--- a/mypy/subtypes.py
+++ b/mypy/subtypes.py
@@ -8,7 +8,7 @@ import mypy.applytype
 import mypy.constraints
 import mypy.typeops
 from mypy.erasetype import erase_type
-from mypy.expandtype import expand_type_by_instance
+from mypy.expandtype import expand_self_type, expand_type_by_instance
 from mypy.maptype import map_instance_to_supertype
 
 # Circular import; done in the function instead.
@@ -1196,6 +1196,8 @@ def find_node_type(
         )
     else:
         typ = node.type
+        if typ is not None:
+            typ = expand_self_type(node, typ, subtype)
     p_typ = get_proper_type(typ)
     if typ is None:
         return AnyType(TypeOfAny.from_error)
diff --git a/mypy/typeanal.py b/mypy/typeanal.py
index 55d819071..18a63011c 100644
--- a/mypy/typeanal.py
+++ b/mypy/typeanal.py
@@ -89,6 +89,7 @@ from mypy.types import (
     get_proper_type,
 )
 from mypy.typetraverser import TypeTraverserVisitor
+from mypy.typevars import fill_typevars
 
 T = TypeVar("T")
 
@@ -117,6 +118,8 @@ GENERIC_STUB_NOT_AT_RUNTIME_TYPES: Final = {
     "asyncio.futures.Future",
 }
 
+SELF_TYPE_NAMES: Final = {"typing.Self", "typing_extensions.Self"}
+
 
 def analyze_type_alias(
     node: Expression,
@@ -148,6 +151,7 @@ def analyze_type_alias(
         is_typeshed_stub,
         defining_alias=True,
         allow_placeholder=allow_placeholder,
+        prohibit_self_type="type alias target",
     )
     analyzer.in_dynamic_func = in_dynamic_func
     analyzer.global_scope = global_scope
@@ -196,6 +200,7 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
         allow_required: bool = False,
         allow_param_spec_literals: bool = False,
         report_invalid_types: bool = True,
+        prohibit_self_type: str | None = None,
     ) -> None:
         self.api = api
         self.lookup_qualified = api.lookup_qualified
@@ -231,6 +236,7 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
         self.is_typeshed_stub = is_typeshed_stub
         # Names of type aliases encountered while analysing a type will be collected here.
         self.aliases_used: set[str] = set()
+        self.prohibit_self_type = prohibit_self_type
 
     def visit_unbound_type(self, t: UnboundType, defining_literal: bool = False) -> Type:
         typ = self.visit_unbound_type_nonoptional(t, defining_literal)
@@ -575,6 +581,24 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
                 self.fail("Unpack[...] requires exactly one type argument", t)
                 return AnyType(TypeOfAny.from_error)
             return UnpackType(self.anal_type(t.args[0]), line=t.line, column=t.column)
+        elif fullname in SELF_TYPE_NAMES:
+            if t.args:
+                self.fail("Self type cannot have type arguments", t)
+            if self.prohibit_self_type is not None:
+                self.fail(f"Self type cannot be used in {self.prohibit_self_type}", t)
+                return AnyType(TypeOfAny.from_error)
+            if self.api.type is None:
+                self.fail("Self type is only allowed in annotations within class definition", t)
+                return AnyType(TypeOfAny.from_error)
+            if self.api.type.has_base("builtins.type"):
+                self.fail("Self type cannot be used in a metaclass", t)
+            if self.api.type.self_type is not None:
+                if self.api.type.is_final:
+                    return fill_typevars(self.api.type)
+                return self.api.type.self_type.copy_modified(line=t.line, column=t.column)
+            # TODO: verify this is unreachable and replace with an assert?
+            self.fail("Unexpected Self type", t)
+            return AnyType(TypeOfAny.from_error)
         return None
 
     def get_omitted_any(self, typ: Type, fullname: str | None = None) -> AnyType:
@@ -853,7 +877,7 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
             if self.defining_alias:
                 variables = t.variables
             else:
-                variables = self.bind_function_type_variables(t, t)
+                variables, _ = self.bind_function_type_variables(t, t)
             special = self.anal_type_guard(t.ret_type)
             arg_kinds = t.arg_kinds
             if len(arg_kinds) >= 2 and arg_kinds[-2] == ARG_STAR and arg_kinds[-1] == ARG_STAR2:
@@ -1347,19 +1371,26 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
 
     def bind_function_type_variables(
         self, fun_type: CallableType, defn: Context
-    ) -> Sequence[TypeVarLikeType]:
+    ) -> tuple[Sequence[TypeVarLikeType], bool]:
         """Find the type variables of the function type and bind them in our tvar_scope"""
+        has_self_type = False
         if fun_type.variables:
             defs = []
             for var in fun_type.variables:
+                if self.api.type and self.api.type.self_type and var == self.api.type.self_type:
+                    has_self_type = True
+                    continue
                 var_node = self.lookup_qualified(var.name, defn)
                 assert var_node, "Binding for function type variable not found within function"
                 var_expr = var_node.node
                 assert isinstance(var_expr, TypeVarLikeExpr)
                 binding = self.tvar_scope.bind_new(var.name, var_expr)
                 defs.append(binding)
-            return defs
+            return defs, has_self_type
         typevars = self.infer_type_variables(fun_type)
+        has_self_type = find_self_type(
+            fun_type, lambda name: self.api.lookup_qualified(name, defn, suppress_errors=True)
+        )
         # Do not define a new type variable if already defined in scope.
         typevars = [
             (name, tvar) for name, tvar in typevars if not self.is_defined_type_var(name, defn)
@@ -1375,7 +1406,7 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
             binding = self.tvar_scope.bind_new(name, tvar)
             defs.append(binding)
 
-        return defs
+        return defs, has_self_type
 
     def is_defined_type_var(self, tvar: str, context: Context) -> bool:
         tvar_node = self.lookup_qualified(tvar, context)
@@ -1959,3 +1990,19 @@ class InstanceFixer(TypeTraverserVisitor):
                 python_version=self.python_version,
                 use_generic_error=True,
             )
+
+
+def find_self_type(typ: Type, lookup: Callable[[str], SymbolTableNode | None]) -> bool:
+    return typ.accept(HasSelfType(lookup))
+
+
+class HasSelfType(TypeQuery[bool]):
+    def __init__(self, lookup: Callable[[str], SymbolTableNode | None]) -> None:
+        self.lookup = lookup
+        super().__init__(any)
+
+    def visit_unbound_type(self, t: UnboundType) -> bool:
+        sym = self.lookup(t.name)
+        if sym and sym.fullname in SELF_TYPE_NAMES:
+            return True
+        return super().visit_unbound_type(t)
diff --git a/mypy/types.py b/mypy/types.py
index a73c41904..242d64ee9 100644
--- a/mypy/types.py
+++ b/mypy/types.py
@@ -402,7 +402,8 @@ class TypeVarId:
     # For plain variables (type parameters of generic classes and
     # functions) raw ids are allocated by semantic analysis, using
     # positive ids 1, 2, ... for generic class parameters and negative
-    # ids -1, ... for generic function type arguments. This convention
+    # ids -1, ... for generic function type arguments. A special value 0
+    # is reserved for Self type variable (autogenerated). This convention
     # is only used to keep type variable ids distinct when allocating
     # them; the type checker makes no distinction between class and
     # function type variables.
@@ -522,6 +523,8 @@ class TypeVarType(TypeVarLikeType):
         values: Bogus[list[Type]] = _dummy,
         upper_bound: Bogus[Type] = _dummy,
         id: Bogus[TypeVarId | int] = _dummy,
+        line: Bogus[int] = _dummy,
+        column: Bogus[int] = _dummy,
     ) -> TypeVarType:
         return TypeVarType(
             self.name,
@@ -530,8 +533,8 @@ class TypeVarType(TypeVarLikeType):
             self.values if values is _dummy else values,
             self.upper_bound if upper_bound is _dummy else upper_bound,
             self.variance,
-            self.line,
-            self.column,
+            self.line if line is _dummy else line,
+            self.column if column is _dummy else column,
         )
 
     def accept(self, visitor: TypeVisitor[T]) -> T:
@@ -3233,11 +3236,12 @@ def replace_alias_tvars(
 
 
 class HasTypeVars(TypeQuery[bool]):
-    def __init__(self) -> None:
+    def __init__(self, exclude: TypeVarId | None = None) -> None:
         super().__init__(any)
+        self.exclude = exclude
 
     def visit_type_var(self, t: TypeVarType) -> bool:
-        return True
+        return t.id != self.exclude
 
     def visit_type_var_tuple(self, t: TypeVarTupleType) -> bool:
         return True
@@ -3246,9 +3250,9 @@ class HasTypeVars(TypeQuery[bool]):
         return True
 
 
-def has_type_vars(typ: Type) -> bool:
+def has_type_vars(typ: Type, exclude: TypeVarId | None = None) -> bool:
     """Check if a type contains any type variables (recursively)."""
-    return typ.accept(HasTypeVars())
+    return typ.accept(HasTypeVars(exclude))
 
 
 class HasRecursiveType(TypeQuery[bool]):
diff --git a/test-data/unit/check-dataclasses.test b/test-data/unit/check-dataclasses.test
index d40641241..02abe8f1d 100644
--- a/test-data/unit/check-dataclasses.test
+++ b/test-data/unit/check-dataclasses.test
@@ -1933,3 +1933,28 @@ B = List[C]
 class C(CC): ...
 class CC: ...
 [builtins fixtures/dataclasses.pyi]
+
+[case testDataclassSelfType]
+# flags: --strict-optional
+from dataclasses import dataclass
+from typing import Self, TypeVar, Generic, Optional
+
+T = TypeVar("T")
+
+@dataclass
+class LinkedList(Generic[T]):
+    value: T
+    next: Optional[Self] = None
+
+    def meth(self) -> None:
+        reveal_type(self.next)  # N: Revealed type is "Union[Self`0, None]"
+
+l_int: LinkedList[int] = LinkedList(1, LinkedList("no", None))  # E: Argument 1 to "LinkedList" has incompatible type "str"; expected "int"
+
+@dataclass
+class SubLinkedList(LinkedList[int]): ...
+
+lst = SubLinkedList(1, LinkedList(2))  # E: Argument 2 to "SubLinkedList" has incompatible type "LinkedList[int]"; expected "Optional[SubLinkedList]"
+reveal_type(lst.next)  # N: Revealed type is "Union[__main__.SubLinkedList, None]"
+reveal_type(SubLinkedList)  # N: Revealed type is "def (value: builtins.int, next: Union[__main__.SubLinkedList, None] =) -> __main__.SubLinkedList"
+[builtins fixtures/dataclasses.pyi]
diff --git a/test-data/unit/check-incremental.test b/test-data/unit/check-incremental.test
index 131cd039a..5fca0f55a 100644
--- a/test-data/unit/check-incremental.test
+++ b/test-data/unit/check-incremental.test
@@ -6312,3 +6312,25 @@ reveal_type(xs)
 [out]
 [out2]
 tmp/m.py:9: note: Revealed type is "builtins.list[builtins.int]"
+
+[case testTypingSelfCoarse]
+import m
+[file lib.py]
+from typing import Self
+
+class C:
+    def meth(self, other: Self) -> Self: ...
+
+[file m.py]
+import lib
+class D: ...
+[file m.py.2]
+import lib
+class D(lib.C): ...
+
+reveal_type(D.meth)
+reveal_type(D().meth)
+[out]
+[out2]
+tmp/m.py:4: note: Revealed type is "def [Self <: lib.C] (self: Self`0, other: Self`0) -> Self`0"
+tmp/m.py:5: note: Revealed type is "def (other: m.D) -> m.D"
diff --git a/test-data/unit/check-namedtuple.test b/test-data/unit/check-namedtuple.test
index 438e17a6b..4eda14c2c 100644
--- a/test-data/unit/check-namedtuple.test
+++ b/test-data/unit/check-namedtuple.test
@@ -1306,3 +1306,32 @@ class C(
 
 [builtins fixtures/tuple.pyi]
 [typing fixtures/typing-namedtuple.pyi]
+
+[case testNamedTupleSelfItemNotAllowed]
+from typing import Self, NamedTuple, Optional
+
+class NT(NamedTuple):
+    val: int
+    next: Optional[Self]  # E: Self type cannot be used in NamedTuple item type
+NTC = NamedTuple("NTC", [("val", int), ("next", Optional[Self])])  # E: Self type cannot be used in NamedTuple item type
+[builtins fixtures/tuple.pyi]
+[typing fixtures/typing-namedtuple.pyi]
+
+[case testNamedTupleTypingSelfMethod]
+from typing import Self, NamedTuple, TypeVar, Generic
+
+T = TypeVar("T")
+class NT(NamedTuple, Generic[T]):
+    key: str
+    val: T
+    def meth(self) -> Self:
+        nt: NT[int]
+        if bool():
+            return nt._replace()  # E: Incompatible return value type (got "NT[int]", expected "Self")
+        else:
+            return self._replace()
+
+class SNT(NT[int]): ...
+reveal_type(SNT("test", 42).meth())  # N: Revealed type is "Tuple[builtins.str, builtins.int, fallback=__main__.SNT]"
+[builtins fixtures/tuple.pyi]
+[typing fixtures/typing-namedtuple.pyi]
diff --git a/test-data/unit/check-protocols.test b/test-data/unit/check-protocols.test
index 77c14b92b..a8d033444 100644
--- a/test-data/unit/check-protocols.test
+++ b/test-data/unit/check-protocols.test
@@ -3890,3 +3890,54 @@ def f() -> str: ...
 [file package/badmod.py]
 def nothing() -> int: ...
 [builtins fixtures/module.pyi]
+
+[case testProtocolSelfTypeNewSyntax]
+from typing import Protocol, Self
+
+class P(Protocol):
+    @property
+    def next(self) -> Self: ...
+
+class C:
+    next: C
+class S:
+    next: Self
+
+x: P = C()
+y: P = S()
+
+z: P
+reveal_type(S().next)  # N: Revealed type is "__main__.S"
+reveal_type(z.next)  # N: Revealed type is "__main__.P"
+[builtins fixtures/property.pyi]
+
+[case testProtocolSelfTypeNewSyntaxSubProtocol]
+from typing import Protocol, Self
+
+class P(Protocol):
+    @property
+    def next(self) -> Self: ...
+class PS(P, Protocol):
+    @property
+    def other(self) -> Self: ...
+
+class C:
+    next: C
+    other: C
+class S:
+    next: Self
+    other: Self
+
+x: PS = C()
+y: PS = S()
+[builtins fixtures/property.pyi]
+
+[case testProtocolClassVarSelfType]
+from typing import ClassVar, Self, Protocol
+
+class P(Protocol):
+    DEFAULT: ClassVar[Self]
+class C:
+    DEFAULT: ClassVar[C]
+
+x: P = C()
diff --git a/test-data/unit/check-selftype.test b/test-data/unit/check-selftype.test
index 3d801d23a..a7dc41a2f 100644
--- a/test-data/unit/check-selftype.test
+++ b/test-data/unit/check-selftype.test
@@ -531,15 +531,15 @@ reveal_type(B().ft())  # N: Revealed type is "Tuple[builtins.int, builtins.int,
 [builtins fixtures/property.pyi]
 
 [case testSelfTypeProperSupertypeAttributeMeta]
-from typing import Callable, TypeVar, Type
+from typing import Callable, TypeVar, Type, ClassVar
 T = TypeVar('T')
 class A(type):
     @property
     def g(cls: object) -> int: return 0
     @property
     def gt(cls: T) -> T: return cls
-    f: Callable[[object], int]
-    ft: Callable[[T], T]
+    f: ClassVar[Callable[[object], int]]
+    ft: ClassVar[Callable[[T], T]]
 
 class B(A):
     pass
@@ -1353,3 +1353,380 @@ class Test(Generic[T]):
         a: deque[List[T]]
         # previously this failed with 'Incompatible types in assignment (expression has type "deque[List[List[T]]]", variable has type "deque[List[T]]")'
         b: deque[List[T]] = a.copy()
+
+[case testTypingSelfBasic]
+from typing import Self, List
+
+class C:
+    attr: List[Self]
+    def meth(self) -> List[Self]: ...
+    def test(self) -> Self:
+        if bool():
+            return C()  # E: Incompatible return value type (got "C", expected "Self")
+        else:
+            return self
+class D(C): ...
+
+reveal_type(C.meth)  # N: Revealed type is "def [Self <: __main__.C] (self: Self`0) -> builtins.list[Self`0]"
+C.attr  # E: Access to generic instance variables via class is ambiguous
+reveal_type(D().meth())  # N: Revealed type is "builtins.list[__main__.D]"
+reveal_type(D().attr)  # N: Revealed type is "builtins.list[__main__.D]"
+
+[case testTypingSelfInvalidLocations]
+from typing import Self, Callable
+
+var: Self  # E: Self type is only allowed in annotations within class definition
+reveal_type(var)  # N: Revealed type is "Any"
+
+def foo() -> Self: ...  # E: Self type is only allowed in annotations within class definition
+reveal_type(foo)  # N: Revealed type is "def () -> Any"
+
+bad: Callable[[Self], Self]  # E: Self type is only allowed in annotations within class definition
+reveal_type(bad)  # N: Revealed type is "def (Any) -> Any"
+
+def func() -> None:
+    var: Self  # E: Self type is only allowed in annotations within class definition
+
+class C(Self): ...  # E: Self type is only allowed in annotations within class definition
+
+[case testTypingSelfInvalidArgs]
+from typing import Self, List
+
+class C:
+    x: Self[int]  # E: Self type cannot have type arguments
+    def meth(self) -> List[Self[int]]:  # E: Self type cannot have type arguments
+        ...
+
+[case testTypingSelfConflict]
+from typing import Self, TypeVar, Tuple
+
+T = TypeVar("T")
+class C:
+    def meth(self: T) -> Tuple[Self, T]: ...  # E: Method cannot have explicit self annotation and Self type
+reveal_type(C().meth())  # N: Revealed type is "Tuple[<nothing>, __main__.C]"
+[builtins fixtures/property.pyi]
+
+[case testTypingSelfProperty]
+from typing import Self, Tuple
+class C:
+    @property
+    def attr(self) -> Tuple[Self, ...]: ...
+class D(C): ...
+
+reveal_type(D().attr)  # N: Revealed type is "builtins.tuple[__main__.D, ...]"
+[builtins fixtures/property.pyi]
+
+[case testTypingSelfCallableVar]
+from typing import Self, Callable
+
+class C:
+    x: Callable[[Self], Self]
+    def meth(self) -> Callable[[Self], Self]: ...
+class D(C): ...
+
+reveal_type(C().x)  # N: Revealed type is "def (__main__.C) -> __main__.C"
+reveal_type(D().x)  # N: Revealed type is "def (__main__.D) -> __main__.D"
+reveal_type(D().meth())  # N: Revealed type is "def (__main__.D) -> __main__.D"
+
+[case testTypingSelfClassMethod]
+from typing import Self
+
+class C:
+    @classmethod
+    def meth(cls) -> Self: ...
+    @staticmethod
+    def bad() -> Self: ...  # E: Static methods cannot use Self type \
+        # E: A function returning TypeVar should receive at least one argument containing the same TypeVar \
+        # N: Consider using the upper bound "C" instead
+
+class D(C): ...
+reveal_type(D.meth())  # N: Revealed type is "__main__.D"
+reveal_type(D.bad())  # N: Revealed type is "<nothing>"
+[builtins fixtures/classmethod.pyi]
+
+[case testTypingSelfOverload]
+from typing import Self, overload, Union
+
+class C:
+    @overload
+    def foo(self, other: Self) -> Self: ...
+    @overload
+    def foo(self, other: int) -> int: ...
+    def foo(self, other: Union[Self, int]) -> Union[Self, int]:
+        return other
+class D(C): ...
+reveal_type(D().foo)  # N: Revealed type is "Overload(def (other: __main__.D) -> __main__.D, def (other: builtins.int) -> builtins.int)"
+
+[case testTypingSelfNestedInAlias]
+from typing import Generic, Self, TypeVar, List, Tuple
+
+T = TypeVar("T")
+Pairs = List[Tuple[T, T]]
+
+class C(Generic[T]):
+    def pairs(self) -> Pairs[Self]: ...
+class D(C[T]): ...
+reveal_type(D[int]().pairs())  # N: Revealed type is "builtins.list[Tuple[__main__.D[builtins.int], __main__.D[builtins.int]]]"
+[builtins fixtures/tuple.pyi]
+
+[case testTypingSelfOverrideVar]
+from typing import Self, TypeVar, Generic
+
+T = TypeVar("T")
+class C(Generic[T]):
+    x: Self
+
+class D(C[int]):
+    x: D
+class Bad(C[int]):
+    x: C[int]  # E: Incompatible types in assignment (expression has type "C[int]", base class "C" defined the type as "Bad")
+
+[case testTypingSelfOverrideVarMulti]
+from typing import Self
+
+class C:
+    x: Self
+class D:
+    x: C
+class E:
+    x: Good
+
+class Bad(D, C):  # E: Definition of "x" in base class "D" is incompatible with definition in base class "C"
+    ...
+class Good(E, C):
+    ...
+
+[case testTypingSelfAlternativeGenericConstructor]
+from typing import Self, Generic, TypeVar, Tuple
+
+T = TypeVar("T")
+class C(Generic[T]):
+    def __init__(self, val: T) -> None: ...
+    @classmethod
+    def pair(cls, val: T) -> Tuple[Self, Self]:
+        return (cls(val), C(val))  # E: Incompatible return value type (got "Tuple[Self, C[T]]", expected "Tuple[Self, Self]")
+
+class D(C[int]): pass
+reveal_type(C.pair(42))  # N: Revealed type is "Tuple[__main__.C[builtins.int], __main__.C[builtins.int]]"
+reveal_type(D.pair("no"))  # N: Revealed type is "Tuple[__main__.D, __main__.D]" \
+    # E: Argument 1 to "pair" of "C" has incompatible type "str"; expected "int"
+[builtins fixtures/classmethod.pyi]
+
+[case testTypingSelfMixedTypeVars]
+from typing import Self, TypeVar, Generic, Tuple
+
+T = TypeVar("T")
+S = TypeVar("S")
+
+class C(Generic[T]):
+    def meth(self, arg: S) -> Tuple[Self, S, T]: ...
+
+class D(C[int]): ...
+
+c: C[int]
+d: D
+reveal_type(c.meth("test"))  # N: Revealed type is "Tuple[__main__.C[builtins.int], builtins.str, builtins.int]"
+reveal_type(d.meth("test"))  # N: Revealed type is "Tuple[__main__.D, builtins.str, builtins.int]"
+[builtins fixtures/tuple.pyi]
+
+[case testTypingSelfRecursiveInit]
+from typing import Self
+
+class C:
+    def __init__(self, other: Self) -> None: ...
+class D(C): ...
+
+reveal_type(C)  # N: Revealed type is "def (other: __main__.C) -> __main__.C"
+reveal_type(D)  # N: Revealed type is "def (other: __main__.D) -> __main__.D"
+
+[case testTypingSelfCorrectName]
+from typing import Self, List
+
+class C:
+    Self = List[C]
+    def meth(self) -> Self: ...
+reveal_type(C.meth)  # N: Revealed type is "def (self: __main__.C) -> builtins.list[__main__.C]"
+
+[case testTypingSelfClassVar]
+from typing import Self, ClassVar, Generic, TypeVar
+
+class C:
+    DEFAULT: ClassVar[Self]
+reveal_type(C.DEFAULT)  # N: Revealed type is "__main__.C"
+
+T = TypeVar("T")
+class G(Generic[T]):
+    BAD: ClassVar[Self]  # E: ClassVar cannot contain Self type in generic classes
+reveal_type(G.BAD)  # N: Revealed type is "__main__.G[Any]"
+
+[case testTypingSelfMetaClassDisabled]
+from typing import Self
+
+class Meta(type):
+    def meth(cls) -> Self: ...  # E: Self type cannot be used in a metaclass
+
+[case testTypingSelfNonAnnotationUses]
+from typing import Self, List, cast
+
+class C:
+    A = List[Self]  # E: Self type cannot be used in type alias target
+    B = cast(Self, ...)
+    def meth(self) -> A: ...
+
+class D(C): ...
+reveal_type(D().meth())  # N: Revealed type is "builtins.list[Any]"
+reveal_type(D().B)  # N: Revealed type is "__main__.D"
+
+[case testTypingSelfInternalSafe]
+from typing import Self
+
+class C:
+    x: Self
+    def __init__(self, x: C) -> None:
+        self.x = x  # E: Incompatible types in assignment (expression has type "C", variable has type "Self")
+
+[case testTypingSelfRedundantAllowed]
+from typing import Self, Type
+
+class C:
+    def f(self: Self) -> Self:
+        d: Defer
+        class Defer: ...
+        return self
+
+    @classmethod
+    def g(cls: Type[Self]) -> Self:
+        d: DeferAgain
+        class DeferAgain: ...
+        return cls()
+[builtins fixtures/classmethod.pyi]
+
+[case testTypingSelfRedundantWarning]
+# mypy: enable-error-code="redundant-self"
+
+from typing import Self, Type
+
+class C:
+    def copy(self: Self) -> Self:  # E: Redundant Self annotation on method first argument
+        d: Defer
+        class Defer: ...
+        return self
+
+    @classmethod
+    def g(cls: Type[Self]) -> Self:  # E: Redundant Self annotation on method first argument
+        d: DeferAgain
+        class DeferAgain: ...
+        return cls()
+[builtins fixtures/classmethod.pyi]
+
+[case testTypingSelfAssertType]
+from typing import Self, assert_type
+
+class C:
+    def foo(self) -> None:
+        assert_type(self, Self)  # E: Expression is of type "C", not "Self"
+        assert_type(C(), Self)  # E: Expression is of type "C", not "Self"
+
+    def bar(self) -> Self:
+        assert_type(self, Self)  # OK
+        assert_type(C(), Self)  # E: Expression is of type "C", not "Self"
+        return self
+
+[case testTypingSelfTypeVarClash]
+from typing import Self, TypeVar, Tuple
+
+S = TypeVar("S")
+class C:
+    def bar(self) -> Self: ...
+    def foo(self, x: S) -> Tuple[Self, S]: ...
+
+reveal_type(C.foo)  # N: Revealed type is "def [Self <: __main__.C, S] (self: Self`0, x: S`-1) -> Tuple[Self`0, S`-1]"
+reveal_type(C().foo(42))  # N: Revealed type is "Tuple[__main__.C, builtins.int]"
+[builtins fixtures/tuple.pyi]
+
+[case testTypingSelfTypeVarClashAttr]
+from typing import Self, TypeVar, Tuple, Callable
+
+class Defer(This): ...
+
+S = TypeVar("S")
+class C:
+    def bar(self) -> Self: ...
+    foo: Callable[[S, Self], Tuple[Self, S]]
+
+reveal_type(C().foo)  # N: Revealed type is "def [S] (S`-1, __main__.C) -> Tuple[__main__.C, S`-1]"
+reveal_type(C().foo(42, C()))  # N: Revealed type is "Tuple[__main__.C, builtins.int]"
+class This: ...
+[builtins fixtures/tuple.pyi]
+
+[case testTypingSelfAttrOldVsNewStyle]
+from typing import Self, TypeVar
+
+T = TypeVar("T", bound=C)
+class C:
+    x: Self
+    def foo(self: T) -> T:
+        return self.x
+    def bar(self: T) -> T:
+        self.x = self
+        return self
+    def baz(self: Self) -> None:
+        self.x = self
+    def bad(self) -> None:
+        # This is unfortunate, but required by PEP 484
+        self.x = self  # E: Incompatible types in assignment (expression has type "C", variable has type "Self")
+
+[case testTypingSelfClashInBodies]
+from typing import Self, TypeVar
+
+T = TypeVar("T")
+class C:
+    def very_bad(self, x: T) -> None:
+        self.x = x  # E: Incompatible types in assignment (expression has type "T", variable has type "Self")
+    x: Self
+    def baz(self: Self, x: T) -> None:
+        y: T = x
+
+[case testTypingSelfClashUnrelated]
+from typing import Self, Generic, TypeVar
+
+class B: ...
+
+T = TypeVar("T", bound=B)
+class C(Generic[T]):
+    def __init__(self, val: T) -> None:
+        self.val = val
+    def foo(self) -> Self: ...
+
+def test(x: C[T]) -> T:
+    reveal_type(x.val)  # N: Revealed type is "T`-1"
+    return x.val
+
+[case testTypingSelfGenericBound]
+from typing import Self, Generic, TypeVar
+
+T = TypeVar("T")
+class C(Generic[T]):
+    val: T
+    def foo(self) -> Self:
+        reveal_type(self.val)  # N: Revealed type is "T`1"
+        return self
+
+[case testTypingSelfDifferentImport]
+import typing as t
+
+class Foo:
+    def foo(self) -> t.Self:
+        return self
+    @classmethod
+    def bar(cls) -> t.Self:
+        return cls()
+[builtins fixtures/classmethod.pyi]
+
+[case testTypingSelfAllowAliasUseInFinalClasses]
+from typing import Self, final
+
+@final
+class C:
+    def meth(self) -> Self:
+        return C()  # OK for final classes
diff --git a/test-data/unit/check-typeddict.test b/test-data/unit/check-typeddict.test
index 796f2f547..24521062a 100644
--- a/test-data/unit/check-typeddict.test
+++ b/test-data/unit/check-typeddict.test
@@ -2590,3 +2590,14 @@ TD[str](key=0, value=0)  # E: Incompatible types (expression has type "int", Typ
 TD[str]({"key": 0, "value": 0})  # E: Incompatible types (expression has type "int", TypedDict item "value" has type "str")
 [builtins fixtures/dict.pyi]
 [typing fixtures/typing-typeddict.pyi]
+
+[case testTypedDictSelfItemNotAllowed]
+from typing import Self, TypedDict, Optional
+
+class TD(TypedDict):
+    val: int
+    next: Optional[Self]  # E: Self type cannot be used in TypedDict item type
+TDC = TypedDict("TDC", {"val": int, "next": Optional[Self]})  # E: Self type cannot be used in TypedDict item type
+
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
diff --git a/test-data/unit/fine-grained.test b/test-data/unit/fine-grained.test
index 32c4ff2ee..2fa3deadd 100644
--- a/test-data/unit/fine-grained.test
+++ b/test-data/unit/fine-grained.test
@@ -10130,3 +10130,28 @@ b.py:2: error: "int" not callable
 a.py:1: error: Unsupported operand types for + ("int" and "str")
     1 + ''
         ^~
+
+[case testTypingSelfFine]
+import m
+[file lib.py]
+from typing import Any
+
+class C:
+    def meth(self, other: Any) -> C: ...
+[file lib.py.2]
+from typing import Self
+
+class C:
+    def meth(self, other: Self) -> Self: ...
+
+[file n.py]
+import lib
+class D(lib.C): ...
+[file m.py]
+from n import D
+d = D()
+def test() -> None:
+    d.meth(42)
+[out]
+==
+m.py:4: error: Argument 1 to "meth" of "C" has incompatible type "int"; expected "D"
diff --git a/test-data/unit/fixtures/typing-namedtuple.pyi b/test-data/unit/fixtures/typing-namedtuple.pyi
index d51134ead..1a3154946 100644
--- a/test-data/unit/fixtures/typing-namedtuple.pyi
+++ b/test-data/unit/fixtures/typing-namedtuple.pyi
@@ -5,6 +5,7 @@ overload = 0
 Type = 0
 Literal = 0
 Optional = 0
+Self = 0
 
 T_co = TypeVar('T_co', covariant=True)
 KT = TypeVar('KT')
diff --git a/test-data/unit/fixtures/typing-typeddict.pyi b/test-data/unit/fixtures/typing-typeddict.pyi
index 378570b4c..e398dff3f 100644
--- a/test-data/unit/fixtures/typing-typeddict.pyi
+++ b/test-data/unit/fixtures/typing-typeddict.pyi
@@ -25,6 +25,7 @@ TypedDict = 0
 NoReturn = 0
 Required = 0
 NotRequired = 0
+Self = 0
 
 T = TypeVar('T')
 T_co = TypeVar('T_co', covariant=True)
diff --git a/test-data/unit/lib-stub/typing.pyi b/test-data/unit/lib-stub/typing.pyi
index 23d97704d..f3850d393 100644
--- a/test-data/unit/lib-stub/typing.pyi
+++ b/test-data/unit/lib-stub/typing.pyi
@@ -27,6 +27,7 @@ NoReturn = 0
 Never = 0
 NewType = 0
 ParamSpec = 0
+Self = 0
 TYPE_CHECKING = 0
 
 T = TypeVar('T')
