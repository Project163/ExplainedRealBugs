diff --git a/mypy/typeops.py b/mypy/typeops.py
index d058bb820..341c96c08 100644
--- a/mypy/typeops.py
+++ b/mypy/typeops.py
@@ -789,9 +789,9 @@ def false_only(t: Type) -> ProperType:
             if not ret_type.can_be_false:
                 return UninhabitedType(line=t.line)
         elif isinstance(t, Instance):
-            if t.type.is_final or t.type.is_enum:
+            if (t.type.is_final or t.type.is_enum) and state.strict_optional:
                 return UninhabitedType(line=t.line)
-        elif isinstance(t, LiteralType) and t.is_enum_literal():
+        elif isinstance(t, LiteralType) and t.is_enum_literal() and state.strict_optional:
             return UninhabitedType(line=t.line)
 
         new_t = copy_type(t)
diff --git a/test-data/unit/check-inference.test b/test-data/unit/check-inference.test
index 63278d6c4..24ea61f2c 100644
--- a/test-data/unit/check-inference.test
+++ b/test-data/unit/check-inference.test
@@ -1964,6 +1964,31 @@ if 'x' in d:  # E: "None" has no attribute "__iter__" (not iterable)
 reveal_type(d)  # N: Revealed type is "None"
 [builtins fixtures/dict.pyi]
 
+[case testNoWrongUnreachableWarningWithNoStrictOptionalAndFinalInstance]
+# flags: --no-strict-optional --warn-unreachable
+from typing import final, Optional
+
+@final
+class C: ...
+
+x: Optional[C]
+if not x:
+    x = C()
+[builtins fixtures/dict.pyi]
+
+[case testNoWrongUnreachableWarningWithNoStrictOptionalAndEnumLiteral]
+# flags: --no-strict-optional --warn-unreachable
+from enum import Enum
+from typing import Literal, Optional
+
+class E(Enum):
+    a = 1
+
+x: Optional[Literal[E.a]]
+if not x:
+    x = E.a
+[builtins fixtures/dict.pyi]
+
 [case testInferFromEmptyListWhenUsingInWithStrictEquality]
 # flags: --strict-equality
 def f() -> None:
