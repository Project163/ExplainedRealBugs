diff --git a/mypy/checker.py b/mypy/checker.py
index d6eac718f..6929543db 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -2285,7 +2285,7 @@ class TypeChecker(NodeVisitor[None], TypeCheckerSharedApi):
                 original_type,
                 defn.name,
                 name,
-                base.name,
+                base.name if base.module_name == self.tree.fullname else base.fullname,
                 original_class_or_static,
                 override_class_or_static,
                 context,
diff --git a/test-data/unit/check-classes.test b/test-data/unit/check-classes.test
index dc421cbd4..c75ede7cc 100644
--- a/test-data/unit/check-classes.test
+++ b/test-data/unit/check-classes.test
@@ -397,7 +397,7 @@ class A:
   def __eq__(self, other: A) -> bool: pass  # Fail
 [builtins fixtures/plugin_attrs.pyi]
 [out]
-main:2: error: Argument 1 of "__eq__" is incompatible with supertype "object"; supertype defines the argument type as "object"
+main:2: error: Argument 1 of "__eq__" is incompatible with supertype "builtins.object"; supertype defines the argument type as "object"
 main:2: note: This violates the Liskov substitution principle
 main:2: note: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
 main:2: note: It is recommended for "__eq__" to work with arbitrary objects, for example:
diff --git a/test-data/unit/check-functions.test b/test-data/unit/check-functions.test
index f86d4ed76..4b980f102 100644
--- a/test-data/unit/check-functions.test
+++ b/test-data/unit/check-functions.test
@@ -3592,6 +3592,28 @@ class Bar(Foo):
     def foo(self, value: Union[int, str]) -> Union[int, str]:
         return super().foo(value)  # E: Call to abstract method "foo" of "Foo" with trivial body via super() is unsafe
 
+[case fullNamesOfImportedBaseClassesDisplayed]
+from a import A
+
+class B(A):
+    def f(self, x: str) -> None:  # E: Argument 1 of "f" is incompatible with supertype "a.A"; supertype defines the argument type as "int" \
+                                  # N: This violates the Liskov substitution principle \
+                                  # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#incompatible-overrides
+        ...
+    def g(self, x: str) -> None:  # E: Signature of "g" incompatible with supertype "a.A" \
+                                  # N:      Superclass: \
+                                  # N:          def g(self) -> None \
+                                  # N:      Subclass: \
+                                  # N:          def g(self, x: str) -> None
+        ...
+
+[file a.py]
+class A:
+    def f(self, x: int) -> None:
+        ...
+    def g(self) -> None:
+        ...
+
 [case testBoundMethodsAssignedInClassBody]
 from typing import Callable
 
diff --git a/test-data/unit/check-modules.test b/test-data/unit/check-modules.test
index dcc64f092..5ae4b4e57 100644
--- a/test-data/unit/check-modules.test
+++ b/test-data/unit/check-modules.test
@@ -3206,13 +3206,13 @@ class Bar(Foo):
     def frobnicate(self, *args: int) -> None: pass # type: ignore[override] # I know
 [builtins fixtures/dict.pyi]
 [out1]
-tmp/b.py:3: error: Signature of "frobnicate" incompatible with supertype "Foo"
+tmp/b.py:3: error: Signature of "frobnicate" incompatible with supertype "a.Foo"
 tmp/b.py:3: note:      Superclass:
 tmp/b.py:3: note:          def frobnicate(self, x: str, *args: Any, **kwargs: Any) -> Any
 tmp/b.py:3: note:      Subclass:
 tmp/b.py:3: note:          def frobnicate(self) -> None
 [out2]
-tmp/b.py:3: error: Signature of "frobnicate" incompatible with supertype "Foo"
+tmp/b.py:3: error: Signature of "frobnicate" incompatible with supertype "a.Foo"
 tmp/b.py:3: note:      Superclass:
 tmp/b.py:3: note:          def frobnicate(self, x: str, *args: Any, **kwargs: Any) -> Any
 tmp/b.py:3: note:      Subclass:
diff --git a/test-data/unit/fine-grained.test b/test-data/unit/fine-grained.test
index ddb1b7266..7e34a2352 100644
--- a/test-data/unit/fine-grained.test
+++ b/test-data/unit/fine-grained.test
@@ -1051,9 +1051,9 @@ class A:
 [file n.py.3]
 [out]
 ==
-main:3: error: Return type "str" of "f" incompatible with return type "int" in supertype "A"
+main:3: error: Return type "str" of "f" incompatible with return type "int" in supertype "m.A"
 ==
-main:3: error: Return type "str" of "f" incompatible with return type "int" in supertype "A"
+main:3: error: Return type "str" of "f" incompatible with return type "int" in supertype "m.A"
 
 [case testModifyBaseClassMethodCausingInvalidOverride]
 import m
@@ -1067,7 +1067,7 @@ class A:
     def f(self) -> int: pass
 [out]
 ==
-main:3: error: Return type "str" of "f" incompatible with return type "int" in supertype "A"
+main:3: error: Return type "str" of "f" incompatible with return type "int" in supertype "m.A"
 
 [case testAddBaseClassAttributeCausingErrorInSubclass]
 import m
@@ -1974,11 +1974,11 @@ class B:
 class B:
     def foo(self) -> int: return 12
 [out]
-a.py:9: error: Return type "int" of "foo" incompatible with return type "str" in supertype "B"
+a.py:9: error: Return type "int" of "foo" incompatible with return type "str" in supertype "b.B"
 ==
-a.py:9: error: Return type "int" of "foo" incompatible with return type "str" in supertype "B"
+a.py:9: error: Return type "int" of "foo" incompatible with return type "str" in supertype "b.B"
 ==
-a.py:9: error: Return type "int" of "foo" incompatible with return type "str" in supertype "B"
+a.py:9: error: Return type "int" of "foo" incompatible with return type "str" in supertype "b.B"
 ==
 
 [case testPreviousErrorInMethodSemanal1]
@@ -7337,7 +7337,7 @@ class Parent:
     def f(self, arg: Any) -> Any: ...
 [out]
 ==
-main:4: error: Signature of "f" incompatible with supertype "Parent"
+main:4: error: Signature of "f" incompatible with supertype "b.Parent"
 main:4: note:      Superclass:
 main:4: note:          @overload
 main:4: note:          def f(self, arg: int) -> int
@@ -7380,7 +7380,7 @@ class Parent:
     def f(self, arg: Any) -> Any: ...
 [out]
 ==
-main:4: error: Signature of "f" incompatible with supertype "Parent"
+main:4: error: Signature of "f" incompatible with supertype "b.Parent"
 main:4: note:      Superclass:
 main:4: note:          @overload
 main:4: note:          def f(self, arg: int) -> int
@@ -7765,7 +7765,7 @@ def deco(f: F) -> F:
 [out]
 main:7: error: Unsupported operand types for + ("str" and "int")
 ==
-main:5: error: Return type "str" of "m" incompatible with return type "int" in supertype "B"
+main:5: error: Return type "str" of "m" incompatible with return type "int" in supertype "b.B"
 
 [case testLiskovFineVariableClean-only_when_nocache]
 import b
@@ -7870,7 +7870,7 @@ def deco(f: F) -> F:
     pass
 [out]
 ==
-main:5: error: Return type "str" of "m" incompatible with return type "int" in supertype "B"
+main:5: error: Return type "str" of "m" incompatible with return type "int" in supertype "b.B"
 
 [case testAddAbstractMethod]
 from b import D
@@ -8518,7 +8518,7 @@ class D:
 ==
 ==
 a.py:3: error: Cannot override final attribute "meth" (previously declared in base class "C")
-a.py:3: error: Signature of "meth" incompatible with supertype "C"
+a.py:3: error: Signature of "meth" incompatible with supertype "c.C"
 a.py:3: note:      Superclass:
 a.py:3: note:          @overload
 a.py:3: note:          def meth(self, x: int) -> int
@@ -8565,7 +8565,7 @@ class D:
 ==
 ==
 a.py:3: error: Cannot override final attribute "meth" (previously declared in base class "C")
-a.py:3: error: Signature of "meth" incompatible with supertype "C"
+a.py:3: error: Signature of "meth" incompatible with supertype "c.C"
 a.py:3: note:      Superclass:
 a.py:3: note:          @overload
 a.py:3: note:          def meth(x: int) -> int
