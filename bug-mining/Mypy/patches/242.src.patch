diff --git a/docs/source/generics.rst b/docs/source/generics.rst
index a5c7b8acc..a867bc863 100644
--- a/docs/source/generics.rst
+++ b/docs/source/generics.rst
@@ -916,9 +916,5 @@ defeating the purpose of using aliases.  Example:
 
     OIntVec = Optional[Vec[int]]
 
-.. note::
-
-    A type alias does not define a new type. For generic type aliases
-    this means that variance of type variables used for alias definition does not
-    apply to aliases. A parameterized generic alias is treated simply as an original
-    type with the corresponding type variables substituted.
+Using type variable bounds or values in generic aliases, has the same effect
+as in generic classes/functions.
diff --git a/mypy/checker.py b/mypy/checker.py
index 431fde299..f9acc9766 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -7115,7 +7115,7 @@ class SetNothingToAny(TypeTranslator):
         return t
 
     def visit_type_alias_type(self, t: TypeAliasType) -> Type:
-        # Target of the alias cannot by an ambiguous <nothing>, so we just
+        # Target of the alias cannot be an ambiguous <nothing>, so we just
         # replace the arguments.
         return t.copy_modified(args=[a.accept(self) for a in t.args])
 
diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index 78ae41207..362ef1eeb 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -3854,10 +3854,8 @@ class ExpressionChecker(ExpressionVisitor[Type]):
 
         There are two different options here, depending on whether expr refers
         to a type alias or directly to a generic class. In the first case we need
-        to use a dedicated function typeanal.expand_type_aliases. This
-        is due to the fact that currently type aliases machinery uses
-        unbound type variables, while normal generics use bound ones;
-        see TypeAlias docstring for more details.
+        to use a dedicated function typeanal.expand_type_alias(). This
+        is due to some differences in how type arguments are applied and checked.
         """
         if isinstance(tapp.expr, RefExpr) and isinstance(tapp.expr.node, TypeAlias):
             # Subscription of a (generic) alias in runtime context, expand the alias.
diff --git a/mypy/erasetype.py b/mypy/erasetype.py
index 89c07186f..6533d0c4e 100644
--- a/mypy/erasetype.py
+++ b/mypy/erasetype.py
@@ -176,8 +176,8 @@ class TypeVarEraser(TypeTranslator):
         return t
 
     def visit_type_alias_type(self, t: TypeAliasType) -> Type:
-        # Type alias target can't contain bound type variables, so
-        # it is safe to just erase the arguments.
+        # Type alias target can't contain bound type variables (not bound by the type
+        # alias itself), so it is safe to just erase the arguments.
         return t.copy_modified(args=[a.accept(self) for a in t.args])
 
 
diff --git a/mypy/expandtype.py b/mypy/expandtype.py
index 43f4e6bcd..d3286480e 100644
--- a/mypy/expandtype.py
+++ b/mypy/expandtype.py
@@ -15,7 +15,6 @@ from mypy.types import (
     NoneType,
     Overloaded,
     Parameters,
-    ParamSpecFlavor,
     ParamSpecType,
     PartialType,
     ProperType,
@@ -34,6 +33,7 @@ from mypy.types import (
     UninhabitedType,
     UnionType,
     UnpackType,
+    expand_param_spec,
     get_proper_type,
 )
 from mypy.typevartuples import (
@@ -212,32 +212,8 @@ class ExpandTypeVisitor(TypeVisitor[Type]):
             # TODO: what does prefix mean in this case?
             # TODO: why does this case even happen? Instances aren't plural.
             return repl
-        elif isinstance(repl, ParamSpecType):
-            return repl.copy_modified(
-                flavor=t.flavor,
-                prefix=t.prefix.copy_modified(
-                    arg_types=t.prefix.arg_types + repl.prefix.arg_types,
-                    arg_kinds=t.prefix.arg_kinds + repl.prefix.arg_kinds,
-                    arg_names=t.prefix.arg_names + repl.prefix.arg_names,
-                ),
-            )
-        elif isinstance(repl, Parameters) or isinstance(repl, CallableType):
-            # if the paramspec is *P.args or **P.kwargs:
-            if t.flavor != ParamSpecFlavor.BARE:
-                assert isinstance(repl, CallableType), "Should not be able to get here."
-                # Is this always the right thing to do?
-                param_spec = repl.param_spec()
-                if param_spec:
-                    return param_spec.with_flavor(t.flavor)
-                else:
-                    return repl
-            else:
-                return Parameters(
-                    t.prefix.arg_types + repl.arg_types,
-                    t.prefix.arg_kinds + repl.arg_kinds,
-                    t.prefix.arg_names + repl.arg_names,
-                    variables=[*t.prefix.variables, *repl.variables],
-                )
+        elif isinstance(repl, (ParamSpecType, Parameters, CallableType)):
+            return expand_param_spec(t, repl)
         else:
             # TODO: should this branch be removed? better not to fail silently
             return repl
@@ -446,8 +422,8 @@ class ExpandTypeVisitor(TypeVisitor[Type]):
         return TypeType.make_normalized(item)
 
     def visit_type_alias_type(self, t: TypeAliasType) -> Type:
-        # Target of the type alias cannot contain type variables,
-        # so we just expand the arguments.
+        # Target of the type alias cannot contain type variables (not bound by the type
+        # alias itself), so we just expand the arguments.
         return t.copy_modified(args=self.expand_types(t.args))
 
     def expand_types(self, types: Iterable[Type]) -> list[Type]:
diff --git a/mypy/fixup.py b/mypy/fixup.py
index b3a2d43d6..3593e4faa 100644
--- a/mypy/fixup.py
+++ b/mypy/fixup.py
@@ -180,6 +180,8 @@ class NodeFixer(NodeVisitor[None]):
 
     def visit_type_alias(self, a: TypeAlias) -> None:
         a.target.accept(self.type_fixer)
+        for v in a.alias_tvars:
+            v.accept(self.type_fixer)
 
 
 class TypeFixer(TypeVisitor[None]):
diff --git a/mypy/mixedtraverser.py b/mypy/mixedtraverser.py
index d25e9b9b0..771f87fc6 100644
--- a/mypy/mixedtraverser.py
+++ b/mypy/mixedtraverser.py
@@ -25,6 +25,9 @@ from mypy.typetraverser import TypeTraverserVisitor
 class MixedTraverserVisitor(TraverserVisitor, TypeTraverserVisitor):
     """Recursive traversal of both Node and Type objects."""
 
+    def __init__(self) -> None:
+        self.in_type_alias_expr = False
+
     # Symbol nodes
 
     def visit_var(self, var: Var) -> None:
@@ -45,7 +48,9 @@ class MixedTraverserVisitor(TraverserVisitor, TypeTraverserVisitor):
 
     def visit_type_alias_expr(self, o: TypeAliasExpr) -> None:
         super().visit_type_alias_expr(o)
+        self.in_type_alias_expr = True
         o.type.accept(self)
+        self.in_type_alias_expr = False
 
     def visit_type_var_expr(self, o: TypeVarExpr) -> None:
         super().visit_type_var_expr(o)
diff --git a/mypy/nodes.py b/mypy/nodes.py
index ebf2f5cb2..f0fc13dad 100644
--- a/mypy/nodes.py
+++ b/mypy/nodes.py
@@ -12,6 +12,7 @@ from typing import (
     Callable,
     Dict,
     Iterator,
+    List,
     Optional,
     Sequence,
     Tuple,
@@ -2546,7 +2547,7 @@ class TypeAliasExpr(Expression):
 
     # The target type.
     type: mypy.types.Type
-    # Names of unbound type variables used to define the alias
+    # Names of type variables used to define the alias
     tvars: list[str]
     # Whether this alias was defined in bare form. Used to distinguish
     # between
@@ -2559,7 +2560,7 @@ class TypeAliasExpr(Expression):
     def __init__(self, node: TypeAlias) -> None:
         super().__init__()
         self.type = node.target
-        self.tvars = node.alias_tvars
+        self.tvars = [v.name for v in node.alias_tvars]
         self.no_args = node.no_args
         self.node = node
 
@@ -3309,10 +3310,9 @@ class TypeAlias(SymbolNode):
     class-valued attributes. See SemanticAnalyzerPass2.check_and_set_up_type_alias
     for details.
 
-    Aliases can be generic. Currently, mypy uses unbound type variables for
-    generic aliases and identifies them by name. Essentially, type aliases
-    work as macros that expand textually. The definition and expansion rules are
-    following:
+    Aliases can be generic. We use bound type variables for generic aliases, similar
+    to classes. Essentially, type aliases work as macros that expand textually.
+    The definition and expansion rules are following:
 
         1. An alias targeting a generic class without explicit variables act as
         the given class (this doesn't apply to TypedDict, Tuple and Callable, which
@@ -3363,11 +3363,11 @@ class TypeAlias(SymbolNode):
 
     Meaning of other fields:
 
-    target: The target type. For generic aliases contains unbound type variables
-        as nested types.
+    target: The target type. For generic aliases contains bound type variables
+        as nested types (currently TypeVar and ParamSpec are supported).
     _fullname: Qualified name of this type alias. This is used in particular
         to track fine grained dependencies from aliases.
-    alias_tvars: Names of unbound type variables used to define this alias.
+    alias_tvars: Type variables used to define this alias.
     normalized: Used to distinguish between `A = List`, and `A = list`. Both
         are internally stored using `builtins.list` (because `typing.List` is
         itself an alias), while the second cannot be subscripted because of
@@ -3396,7 +3396,7 @@ class TypeAlias(SymbolNode):
         line: int,
         column: int,
         *,
-        alias_tvars: list[str] | None = None,
+        alias_tvars: list[mypy.types.TypeVarLikeType] | None = None,
         no_args: bool = False,
         normalized: bool = False,
         eager: bool = False,
@@ -3446,12 +3446,16 @@ class TypeAlias(SymbolNode):
     def fullname(self) -> str:
         return self._fullname
 
+    @property
+    def has_param_spec_type(self) -> bool:
+        return any(isinstance(v, mypy.types.ParamSpecType) for v in self.alias_tvars)
+
     def serialize(self) -> JsonDict:
         data: JsonDict = {
             ".class": "TypeAlias",
             "fullname": self._fullname,
             "target": self.target.serialize(),
-            "alias_tvars": self.alias_tvars,
+            "alias_tvars": [v.serialize() for v in self.alias_tvars],
             "no_args": self.no_args,
             "normalized": self.normalized,
             "line": self.line,
@@ -3466,7 +3470,8 @@ class TypeAlias(SymbolNode):
     def deserialize(cls, data: JsonDict) -> TypeAlias:
         assert data[".class"] == "TypeAlias"
         fullname = data["fullname"]
-        alias_tvars = data["alias_tvars"]
+        alias_tvars = [mypy.types.deserialize_type(v) for v in data["alias_tvars"]]
+        assert all(isinstance(t, mypy.types.TypeVarLikeType) for t in alias_tvars)
         target = mypy.types.deserialize_type(data["target"])
         no_args = data["no_args"]
         normalized = data["normalized"]
@@ -3477,7 +3482,7 @@ class TypeAlias(SymbolNode):
             fullname,
             line,
             column,
-            alias_tvars=alias_tvars,
+            alias_tvars=cast(List[mypy.types.TypeVarLikeType], alias_tvars),
             no_args=no_args,
             normalized=normalized,
         )
diff --git a/mypy/semanal.py b/mypy/semanal.py
index a5ddcc70e..74ab1c1c6 100644
--- a/mypy/semanal.py
+++ b/mypy/semanal.py
@@ -50,7 +50,7 @@ Some important properties:
 
 from __future__ import annotations
 
-from contextlib import contextmanager
+from contextlib import contextmanager, nullcontext
 from typing import Any, Callable, Collection, Iterable, Iterator, List, TypeVar, cast
 from typing_extensions import Final, TypeAlias as _TypeAlias
 
@@ -459,6 +459,11 @@ class SemanticAnalyzer(
         # rvalues while temporarily setting this to True.
         self.basic_type_applications = False
 
+        # Used to temporarily enable unbound type variables in some contexts. Namely,
+        # in base class expressions, and in right hand sides of type aliases. Do not add
+        # new uses of this, as this may cause leaking `UnboundType`s to type checking.
+        self.allow_unbound_tvars = False
+
     # mypyc doesn't properly handle implementing an abstractproperty
     # with a regular attribute so we make them properties
     @property
@@ -477,6 +482,15 @@ class SemanticAnalyzer(
     def final_iteration(self) -> bool:
         return self._final_iteration
 
+    @contextmanager
+    def allow_unbound_tvars_set(self) -> Iterator[None]:
+        old = self.allow_unbound_tvars
+        self.allow_unbound_tvars = True
+        try:
+            yield
+        finally:
+            self.allow_unbound_tvars = old
+
     #
     # Preparing module (performed before semantic analysis)
     #
@@ -1599,7 +1613,7 @@ class SemanticAnalyzer(
 
     def setup_alias_type_vars(self, defn: ClassDef) -> None:
         assert defn.info.special_alias is not None
-        defn.info.special_alias.alias_tvars = list(defn.info.type_vars)
+        defn.info.special_alias.alias_tvars = list(defn.type_vars)
         target = defn.info.special_alias.target
         assert isinstance(target, ProperType)
         if isinstance(target, TypedDictType):
@@ -2631,7 +2645,10 @@ class SemanticAnalyzer(
         # when analysing any type applications there) thus preventing the further analysis.
         # To break the tie, we first analyse rvalue partially, if it can be a type alias.
         with self.basic_type_applications_set(s):
-            s.rvalue.accept(self)
+            with self.allow_unbound_tvars_set() if self.can_possibly_be_index_alias(
+                s
+            ) else nullcontext():
+                s.rvalue.accept(self)
         if self.found_incomplete_ref(tag) or self.should_wait_rhs(s.rvalue):
             # Initializer couldn't be fully analyzed. Defer the current node and give up.
             # Make sure that if we skip the definition of some local names, they can't be
@@ -2642,7 +2659,8 @@ class SemanticAnalyzer(
         if self.can_possibly_be_index_alias(s):
             # Now re-visit those rvalues that were we skipped type applications above.
             # This should be safe as generally semantic analyzer is idempotent.
-            s.rvalue.accept(self)
+            with self.allow_unbound_tvars_set():
+                s.rvalue.accept(self)
 
         # The r.h.s. is now ready to be classified, first check if it is a special form:
         special_form = False
@@ -3272,42 +3290,56 @@ class SemanticAnalyzer(
         return None
 
     def analyze_alias(
-        self, rvalue: Expression, allow_placeholder: bool = False
-    ) -> tuple[Type | None, list[str], set[str], list[str]]:
+        self, name: str, rvalue: Expression, allow_placeholder: bool = False
+    ) -> tuple[Type | None, list[TypeVarLikeType], set[str], list[str]]:
         """Check if 'rvalue' is a valid type allowed for aliasing (e.g. not a type variable).
 
         If yes, return the corresponding type, a list of
         qualified type variable names for generic aliases, a set of names the alias depends on,
         and a list of type variables if the alias is generic.
-        An schematic example for the dependencies:
+        A schematic example for the dependencies:
             A = int
             B = str
             analyze_alias(Dict[A, B])[2] == {'__main__.A', '__main__.B'}
         """
         dynamic = bool(self.function_stack and self.function_stack[-1].is_dynamic())
         global_scope = not self.type and not self.function_stack
-        res = analyze_type_alias(
-            rvalue,
-            self,
-            self.tvar_scope,
-            self.plugin,
-            self.options,
-            self.is_typeshed_stub_file,
-            allow_placeholder=allow_placeholder,
-            in_dynamic_func=dynamic,
-            global_scope=global_scope,
-        )
-        typ: Type | None = None
+        try:
+            typ = expr_to_unanalyzed_type(rvalue, self.options, self.is_stub_file)
+        except TypeTranslationError:
+            self.fail(
+                "Invalid type alias: expression is not a valid type", rvalue, code=codes.VALID_TYPE
+            )
+            return None, [], set(), []
+
+        found_type_vars = typ.accept(TypeVarLikeQuery(self.lookup_qualified, self.tvar_scope))
+        tvar_defs: list[TypeVarLikeType] = []
+        namespace = self.qualified_name(name)
+        with self.tvar_scope_frame(self.tvar_scope.class_frame(namespace)):
+            for name, tvar_expr in found_type_vars:
+                tvar_def = self.tvar_scope.bind_new(name, tvar_expr)
+                tvar_defs.append(tvar_def)
+
+            res = analyze_type_alias(
+                typ,
+                self,
+                self.tvar_scope,
+                self.plugin,
+                self.options,
+                self.is_typeshed_stub_file,
+                allow_placeholder=allow_placeholder,
+                in_dynamic_func=dynamic,
+                global_scope=global_scope,
+                allowed_alias_tvars=tvar_defs,
+            )
+        analyzed: Type | None = None
         if res:
-            typ, depends_on = res
-            found_type_vars = typ.accept(TypeVarLikeQuery(self.lookup_qualified, self.tvar_scope))
-            alias_tvars = [name for (name, node) in found_type_vars]
+            analyzed, depends_on = res
             qualified_tvars = [node.fullname for (name, node) in found_type_vars]
         else:
-            alias_tvars = []
             depends_on = set()
             qualified_tvars = []
-        return typ, alias_tvars, depends_on, qualified_tvars
+        return analyzed, tvar_defs, depends_on, qualified_tvars
 
     def is_pep_613(self, s: AssignmentStmt) -> bool:
         if s.unanalyzed_type is not None and isinstance(s.unanalyzed_type, UnboundType):
@@ -3387,13 +3419,13 @@ class SemanticAnalyzer(
         res: Type | None = None
         if self.is_none_alias(rvalue):
             res = NoneType()
-            alias_tvars: list[str] = []
+            alias_tvars: list[TypeVarLikeType] = []
             depends_on: set[str] = set()
             qualified_tvars: list[str] = []
         else:
             tag = self.track_incomplete_refs()
             res, alias_tvars, depends_on, qualified_tvars = self.analyze_alias(
-                rvalue, allow_placeholder=True
+                lvalue.name, rvalue, allow_placeholder=True
             )
             if not res:
                 return False
@@ -4978,12 +5010,12 @@ class SemanticAnalyzer(
             except TypeTranslationError:
                 self.fail("Type expected within [...]", expr)
                 return None
-            # We always allow unbound type variables in IndexExpr, since we
-            # may be analysing a type alias definition rvalue. The error will be
-            # reported elsewhere if it is not the case.
             analyzed = self.anal_type(
                 typearg,
-                allow_unbound_tvars=True,
+                # The type application may appear in base class expression,
+                # where type variables are not bound yet. Or when accepting
+                # r.h.s. of type alias before we figured out it is a type alias.
+                allow_unbound_tvars=self.allow_unbound_tvars,
                 allow_placeholder=True,
                 allow_param_spec_literals=has_param_spec,
             )
@@ -6187,7 +6219,7 @@ class SemanticAnalyzer(
         # them semantically analyzed, however, if they need to treat it as an expression
         # and not a type. (Which is to say, mypyc needs to do this.) Do the analysis
         # in a fresh tvar scope in order to suppress any errors about using type variables.
-        with self.tvar_scope_frame(TypeVarLikeScope()):
+        with self.tvar_scope_frame(TypeVarLikeScope()), self.allow_unbound_tvars_set():
             expr.accept(self)
 
     def type_analyzer(
diff --git a/mypy/semanal_typeargs.py b/mypy/semanal_typeargs.py
index 729034231..b9965236c 100644
--- a/mypy/semanal_typeargs.py
+++ b/mypy/semanal_typeargs.py
@@ -7,23 +7,27 @@ operations, including subtype checks.
 
 from __future__ import annotations
 
+from typing import Sequence
+
 from mypy import errorcodes as codes, message_registry
 from mypy.errorcodes import ErrorCode
 from mypy.errors import Errors
 from mypy.messages import format_type
 from mypy.mixedtraverser import MixedTraverserVisitor
-from mypy.nodes import Block, ClassDef, Context, FakeInfo, FuncItem, MypyFile, TypeInfo
+from mypy.nodes import Block, ClassDef, Context, FakeInfo, FuncItem, MypyFile
 from mypy.options import Options
 from mypy.scope import Scope
 from mypy.subtypes import is_same_type, is_subtype
 from mypy.types import (
     AnyType,
     Instance,
+    Parameters,
     ParamSpecType,
     TupleType,
     Type,
     TypeAliasType,
     TypeOfAny,
+    TypeVarLikeType,
     TypeVarTupleType,
     TypeVarType,
     UnboundType,
@@ -35,6 +39,7 @@ from mypy.types import (
 
 class TypeArgumentAnalyzer(MixedTraverserVisitor):
     def __init__(self, errors: Errors, options: Options, is_typeshed_file: bool) -> None:
+        super().__init__()
         self.errors = errors
         self.options = options
         self.is_typeshed_file = is_typeshed_file
@@ -77,7 +82,12 @@ class TypeArgumentAnalyzer(MixedTraverserVisitor):
         # correct aliases.
         if t.alias and len(t.args) != len(t.alias.alias_tvars):
             t.args = [AnyType(TypeOfAny.from_error) for _ in t.alias.alias_tvars]
-        get_proper_type(t).accept(self)
+        assert t.alias is not None, f"Unfixed type alias {t.type_ref}"
+        is_error = self.validate_args(t.alias.name, t.args, t.alias.alias_tvars, t)
+        if not is_error:
+            # If there was already an error for the alias itself, there is no point in checking
+            # the expansion, most likely it will result in the same kind of error.
+            get_proper_type(t).accept(self)
 
     def visit_instance(self, t: Instance) -> None:
         # Type argument counts were checked in the main semantic analyzer pass. We assume
@@ -85,36 +95,67 @@ class TypeArgumentAnalyzer(MixedTraverserVisitor):
         info = t.type
         if isinstance(info, FakeInfo):
             return  # https://github.com/python/mypy/issues/11079
-        for (i, arg), tvar in zip(enumerate(t.args), info.defn.type_vars):
+        self.validate_args(info.name, t.args, info.defn.type_vars, t)
+        super().visit_instance(t)
+
+    def validate_args(
+        self, name: str, args: Sequence[Type], type_vars: list[TypeVarLikeType], ctx: Context
+    ) -> bool:
+        is_error = False
+        for (i, arg), tvar in zip(enumerate(args), type_vars):
             if isinstance(tvar, TypeVarType):
                 if isinstance(arg, ParamSpecType):
                     # TODO: Better message
-                    self.fail(f'Invalid location for ParamSpec "{arg.name}"', t)
+                    is_error = True
+                    self.fail(f'Invalid location for ParamSpec "{arg.name}"', ctx)
+                    self.note(
+                        "You can use ParamSpec as the first argument to Callable, e.g., "
+                        "'Callable[{}, int]'".format(arg.name),
+                        ctx,
+                    )
                     continue
                 if tvar.values:
                     if isinstance(arg, TypeVarType):
+                        if self.in_type_alias_expr:
+                            # Type aliases are allowed to use unconstrained type variables
+                            # error will be checked at substitution point.
+                            continue
                         arg_values = arg.values
                         if not arg_values:
+                            is_error = True
                             self.fail(
-                                message_registry.INVALID_TYPEVAR_AS_TYPEARG.format(
-                                    arg.name, info.name
-                                ),
-                                t,
+                                message_registry.INVALID_TYPEVAR_AS_TYPEARG.format(arg.name, name),
+                                ctx,
                                 code=codes.TYPE_VAR,
                             )
                             continue
                     else:
                         arg_values = [arg]
-                    self.check_type_var_values(info, arg_values, tvar.name, tvar.values, i + 1, t)
+                    if self.check_type_var_values(name, arg_values, tvar.name, tvar.values, ctx):
+                        is_error = True
                 if not is_subtype(arg, tvar.upper_bound):
+                    if self.in_type_alias_expr and isinstance(arg, TypeVarType):
+                        # Type aliases are allowed to use unconstrained type variables
+                        # error will be checked at substitution point.
+                        continue
+                    is_error = True
                     self.fail(
                         message_registry.INVALID_TYPEVAR_ARG_BOUND.format(
-                            format_type(arg), info.name, format_type(tvar.upper_bound)
+                            format_type(arg), name, format_type(tvar.upper_bound)
                         ),
-                        t,
+                        ctx,
                         code=codes.TYPE_VAR,
                     )
-        super().visit_instance(t)
+            elif isinstance(tvar, ParamSpecType):
+                if not isinstance(
+                    get_proper_type(arg), (ParamSpecType, Parameters, AnyType, UnboundType)
+                ):
+                    self.fail(
+                        "Can only replace ParamSpec with a parameter types list or"
+                        f" another ParamSpec, got {format_type(arg)}",
+                        ctx,
+                    )
+        return is_error
 
     def visit_unpack_type(self, typ: UnpackType) -> None:
         proper_type = get_proper_type(typ.type)
@@ -132,28 +173,25 @@ class TypeArgumentAnalyzer(MixedTraverserVisitor):
         self.fail(message_registry.INVALID_UNPACK.format(proper_type), typ)
 
     def check_type_var_values(
-        self,
-        type: TypeInfo,
-        actuals: list[Type],
-        arg_name: str,
-        valids: list[Type],
-        arg_number: int,
-        context: Context,
-    ) -> None:
+        self, name: str, actuals: list[Type], arg_name: str, valids: list[Type], context: Context
+    ) -> bool:
+        is_error = False
         for actual in get_proper_types(actuals):
-            # TODO: bind type variables in class bases/alias targets
-            # so we can safely check this, currently we miss some errors.
+            # We skip UnboundType here, since they may appear in defn.bases,
+            # the error will be caught when visiting info.bases, that have bound type
+            # variables.
             if not isinstance(actual, (AnyType, UnboundType)) and not any(
                 is_same_type(actual, value) for value in valids
             ):
+                is_error = True
                 if len(actuals) > 1 or not isinstance(actual, Instance):
                     self.fail(
-                        message_registry.INVALID_TYPEVAR_ARG_VALUE.format(type.name),
+                        message_registry.INVALID_TYPEVAR_ARG_VALUE.format(name),
                         context,
                         code=codes.TYPE_VAR,
                     )
                 else:
-                    class_name = f'"{type.name}"'
+                    class_name = f'"{name}"'
                     actual_type_name = f'"{actual.type.name}"'
                     self.fail(
                         message_registry.INCOMPATIBLE_TYPEVAR_VALUE.format(
@@ -162,6 +200,10 @@ class TypeArgumentAnalyzer(MixedTraverserVisitor):
                         context,
                         code=codes.TYPE_VAR,
                     )
+        return is_error
 
     def fail(self, msg: str, context: Context, *, code: ErrorCode | None = None) -> None:
         self.errors.report(context.line, context.column, msg, code=code)
+
+    def note(self, msg: str, context: Context, *, code: ErrorCode | None = None) -> None:
+        self.errors.report(context.line, context.column, msg, severity="note", code=code)
diff --git a/mypy/semanal_typeddict.py b/mypy/semanal_typeddict.py
index fb45dcc0d..cd3d02bc6 100644
--- a/mypy/semanal_typeddict.py
+++ b/mypy/semanal_typeddict.py
@@ -189,7 +189,7 @@ class TypedDictAnalyzer:
         valid_items = base_items.copy()
 
         # Always fix invalid bases to avoid crashes.
-        tvars = info.type_vars
+        tvars = info.defn.type_vars
         if len(base_args) != len(tvars):
             any_kind = TypeOfAny.from_omitted_generics
             if base_args:
@@ -235,7 +235,7 @@ class TypedDictAnalyzer:
         return base_args
 
     def map_items_to_base(
-        self, valid_items: dict[str, Type], tvars: list[str], base_args: list[Type]
+        self, valid_items: dict[str, Type], tvars: list[TypeVarLikeType], base_args: list[Type]
     ) -> dict[str, Type]:
         """Map item types to how they would look in their base with type arguments applied.
 
diff --git a/mypy/server/astdiff.py b/mypy/server/astdiff.py
index 41a79db48..97f811384 100644
--- a/mypy/server/astdiff.py
+++ b/mypy/server/astdiff.py
@@ -187,7 +187,7 @@ def snapshot_symbol_table(name_prefix: str, table: SymbolTable) -> dict[str, Sna
         elif isinstance(node, TypeAlias):
             result[name] = (
                 "TypeAlias",
-                node.alias_tvars,
+                snapshot_types(node.alias_tvars),
                 node.normalized,
                 node.no_args,
                 snapshot_optional_type(node.target),
diff --git a/mypy/server/astmerge.py b/mypy/server/astmerge.py
index a14335acc..04422036b 100644
--- a/mypy/server/astmerge.py
+++ b/mypy/server/astmerge.py
@@ -331,6 +331,8 @@ class NodeReplaceVisitor(TraverserVisitor):
 
     def visit_type_alias(self, node: TypeAlias) -> None:
         self.fixup_type(node.target)
+        for v in node.alias_tvars:
+            self.fixup_type(v)
         super().visit_type_alias(node)
 
     # Helpers
diff --git a/mypy/subtypes.py b/mypy/subtypes.py
index a4b045cfa..e4667c45f 100644
--- a/mypy/subtypes.py
+++ b/mypy/subtypes.py
@@ -631,6 +631,8 @@ class SubtypeVisitor(TypeVisitor[bool]):
             and right.flavor == left.flavor
         ):
             return True
+        if isinstance(right, Parameters) and are_trivial_parameters(right):
+            return True
         return self._is_subtype(left.upper_bound, self.right)
 
     def visit_type_var_tuple(self, left: TypeVarTupleType) -> bool:
@@ -1415,6 +1417,18 @@ def is_callable_compatible(
     )
 
 
+def are_trivial_parameters(param: Parameters | NormalizedCallableType) -> bool:
+    param_star = param.var_arg()
+    param_star2 = param.kw_arg()
+    return (
+        param.arg_kinds == [ARG_STAR, ARG_STAR2]
+        and param_star is not None
+        and isinstance(get_proper_type(param_star.typ), AnyType)
+        and param_star2 is not None
+        and isinstance(get_proper_type(param_star2.typ), AnyType)
+    )
+
+
 def are_parameters_compatible(
     left: Parameters | NormalizedCallableType,
     right: Parameters | NormalizedCallableType,
@@ -1435,13 +1449,7 @@ def are_parameters_compatible(
     right_star2 = right.kw_arg()
 
     # Treat "def _(*a: Any, **kw: Any) -> X" similarly to "Callable[..., X]"
-    if (
-        right.arg_kinds == [ARG_STAR, ARG_STAR2]
-        and right_star
-        and isinstance(get_proper_type(right_star.typ), AnyType)
-        and right_star2
-        and isinstance(get_proper_type(right_star2.typ), AnyType)
-    ):
+    if are_trivial_parameters(right):
         return True
 
     # Match up corresponding arguments and check them for compatibility. In
diff --git a/mypy/test/testtypes.py b/mypy/test/testtypes.py
index 18948ee7f..ee0256e20 100644
--- a/mypy/test/testtypes.py
+++ b/mypy/test/testtypes.py
@@ -160,7 +160,8 @@ class TypesSuite(Suite):
 
     def test_recursive_nested_in_non_recursive(self) -> None:
         A, _ = self.fx.def_alias_1(self.fx.a)
-        NA = self.fx.non_rec_alias(Instance(self.fx.gi, [UnboundType("T")]), ["T"], [A])
+        T = TypeVarType("T", "T", -1, [], self.fx.o)
+        NA = self.fx.non_rec_alias(Instance(self.fx.gi, [T]), [T], [A])
         assert not NA.is_recursive
         assert has_recursive_types(NA)
 
diff --git a/mypy/test/typefixture.py b/mypy/test/typefixture.py
index 93e5e4b0b..bd8351171 100644
--- a/mypy/test/typefixture.py
+++ b/mypy/test/typefixture.py
@@ -340,7 +340,10 @@ class TypeFixture:
         return A, target
 
     def non_rec_alias(
-        self, target: Type, alias_tvars: list[str] | None = None, args: list[Type] | None = None
+        self,
+        target: Type,
+        alias_tvars: list[TypeVarLikeType] | None = None,
+        args: list[Type] | None = None,
     ) -> TypeAliasType:
         AN = TypeAlias(target, "__main__.A", -1, -1, alias_tvars=alias_tvars)
         if args is None:
diff --git a/mypy/typeanal.py b/mypy/typeanal.py
index f22fa3070..f34f6ef49 100644
--- a/mypy/typeanal.py
+++ b/mypy/typeanal.py
@@ -10,7 +10,6 @@ from typing_extensions import Final, Protocol
 
 from mypy import errorcodes as codes, message_registry, nodes
 from mypy.errorcodes import ErrorCode
-from mypy.exprtotype import TypeTranslationError, expr_to_unanalyzed_type
 from mypy.messages import MessageBuilder, format_type_bare, quote_type_string, wrong_type_arg_count
 from mypy.nodes import (
     ARG_NAMED,
@@ -23,7 +22,6 @@ from mypy.nodes import (
     ArgKind,
     Context,
     Decorator,
-    Expression,
     MypyFile,
     ParamSpecExpr,
     PlaceholderNode,
@@ -87,6 +85,7 @@ from mypy.types import (
     callable_with_ellipsis,
     flatten_nested_unions,
     get_proper_type,
+    has_type_vars,
 )
 from mypy.typetraverser import TypeTraverserVisitor
 from mypy.typevars import fill_typevars
@@ -122,7 +121,7 @@ SELF_TYPE_NAMES: Final = {"typing.Self", "typing_extensions.Self"}
 
 
 def analyze_type_alias(
-    node: Expression,
+    type: Type,
     api: SemanticAnalyzerCoreInterface,
     tvar_scope: TypeVarLikeScope,
     plugin: Plugin,
@@ -131,6 +130,7 @@ def analyze_type_alias(
     allow_placeholder: bool = False,
     in_dynamic_func: bool = False,
     global_scope: bool = True,
+    allowed_alias_tvars: list[TypeVarLikeType] | None = None,
 ) -> tuple[Type, set[str]] | None:
     """Analyze r.h.s. of a (potential) type alias definition.
 
@@ -138,11 +138,6 @@ def analyze_type_alias(
     full names of type aliases it depends on (directly or indirectly).
     Return None otherwise. 'node' must have been semantically analyzed.
     """
-    try:
-        type = expr_to_unanalyzed_type(node, options, api.is_stub_file)
-    except TypeTranslationError:
-        api.fail("Invalid type alias: expression is not a valid type", node, code=codes.VALID_TYPE)
-        return None
     analyzer = TypeAnalyser(
         api,
         tvar_scope,
@@ -152,6 +147,7 @@ def analyze_type_alias(
         defining_alias=True,
         allow_placeholder=allow_placeholder,
         prohibit_self_type="type alias target",
+        allowed_alias_tvars=allowed_alias_tvars,
     )
     analyzer.in_dynamic_func = in_dynamic_func
     analyzer.global_scope = global_scope
@@ -201,6 +197,7 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
         allow_param_spec_literals: bool = False,
         report_invalid_types: bool = True,
         prohibit_self_type: str | None = None,
+        allowed_alias_tvars: list[TypeVarLikeType] | None = None,
         allow_type_any: bool = False,
     ) -> None:
         self.api = api
@@ -219,8 +216,12 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
         self.always_allow_new_syntax = self.api.is_stub_file or self.api.is_future_flag_set(
             "annotations"
         )
-        # Should we accept unbound type variables (always OK in aliases)?
-        self.allow_unbound_tvars = allow_unbound_tvars or defining_alias
+        # Should we accept unbound type variables? This is currently used for class bases,
+        # and alias right hand sides (before they are analyzed as type aliases).
+        self.allow_unbound_tvars = allow_unbound_tvars
+        if allowed_alias_tvars is None:
+            allowed_alias_tvars = []
+        self.allowed_alias_tvars = allowed_alias_tvars
         # If false, record incomplete ref if we generate PlaceholderType.
         self.allow_placeholder = allow_placeholder
         # Are we in a context where Required[] is allowed?
@@ -263,7 +264,12 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
                         self.api.defer()
                     else:
                         self.api.record_incomplete_ref()
-                    return PlaceholderType(node.fullname, self.anal_array(t.args), t.line)
+                    # Always allow ParamSpec for placeholders, if they are actually not valid,
+                    # they will be reported later, after we resolve placeholders.
+                    with self.set_allow_param_spec_literals(True):
+                        return PlaceholderType(
+                            node.fullname, self.anal_array(t.args, allow_param_spec=True), t.line
+                        )
                 else:
                     if self.api.final_iteration:
                         self.cannot_resolve_type(t)
@@ -290,6 +296,8 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
             tvar_def = self.tvar_scope.get_binding(sym)
             if isinstance(sym.node, ParamSpecExpr):
                 if tvar_def is None:
+                    if self.allow_unbound_tvars:
+                        return t
                     self.fail(f'ParamSpec "{t.name}" is unbound', t, code=codes.VALID_TYPE)
                     return AnyType(TypeOfAny.from_error)
                 assert isinstance(tvar_def, ParamSpecType)
@@ -307,7 +315,12 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
                     line=t.line,
                     column=t.column,
                 )
-            if isinstance(sym.node, TypeVarExpr) and tvar_def is not None and self.defining_alias:
+            if (
+                isinstance(sym.node, TypeVarExpr)
+                and self.defining_alias
+                and not defining_literal
+                and (tvar_def is None or tvar_def not in self.allowed_alias_tvars)
+            ):
                 self.fail(
                     f'Can\'t use bound type variable "{t.name}" to define generic alias',
                     t,
@@ -332,7 +345,9 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
                     column=t.column,
                 )
             if isinstance(sym.node, TypeVarTupleExpr) and (
-                tvar_def is not None and self.defining_alias
+                tvar_def is not None
+                and self.defining_alias
+                and tvar_def not in self.allowed_alias_tvars
             ):
                 self.fail(
                     f'Can\'t use bound type variable "{t.name}" to define generic alias',
@@ -363,7 +378,11 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
                 return special
             if isinstance(node, TypeAlias):
                 self.aliases_used.add(fullname)
-                an_args = self.anal_array(t.args)
+                with self.set_allow_param_spec_literals(node.has_param_spec_type):
+                    an_args = self.anal_array(t.args, allow_param_spec=True)
+                    if node.has_param_spec_type and len(node.alias_tvars) == 1:
+                        an_args = self.pack_paramspec_args(an_args)
+
                 disallow_any = self.options.disallow_any_generics and not self.is_typeshed_stub
                 res = expand_type_alias(
                     node,
@@ -406,6 +425,17 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
         else:  # sym is None
             return AnyType(TypeOfAny.special_form)
 
+    def pack_paramspec_args(self, an_args: Sequence[Type]) -> list[Type]:
+        # "Aesthetic" ParamSpec literals for single ParamSpec: C[int, str] -> C[[int, str]].
+        # These do not support mypy_extensions VarArgs, etc. as they were already analyzed
+        # TODO: should these be re-analyzed to get rid of this inconsistency?
+        count = len(an_args)
+        if count > 0:
+            first_arg = get_proper_type(an_args[0])
+            if not (count == 1 and isinstance(first_arg, (Parameters, ParamSpecType, AnyType))):
+                return [Parameters(an_args, [ARG_POS] * count, [None] * count)]
+        return list(an_args)
+
     def cannot_resolve_type(self, t: UnboundType) -> None:
         # TODO: Move error message generation to messages.py. We'd first
         #       need access to MessageBuilder here. Also move the similar
@@ -422,6 +452,10 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
         # last argument has to be ParamSpec
         ps = self.anal_type(t.args[-1], allow_param_spec=True)
         if not isinstance(ps, ParamSpecType):
+            if isinstance(ps, UnboundType) and self.allow_unbound_tvars:
+                sym = self.lookup_qualified(ps.name, t)
+                if sym is not None and isinstance(sym.node, ParamSpecExpr):
+                    return ps
             self.api.fail(
                 "The last parameter to Concatenate needs to be a ParamSpec",
                 t,
@@ -633,25 +667,8 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
             instance = Instance(
                 info, self.anal_array(args, allow_param_spec=True), ctx.line, ctx.column
             )
-
-        # "aesthetic" paramspec literals
-        # these do not support mypy_extensions VarArgs, etc. as they were already analyzed
-        #   TODO: should these be re-analyzed to get rid of this inconsistency?
-        # another inconsistency is with empty type args (Z[] is more possibly an error imo)
-        if len(info.type_vars) == 1 and info.has_param_spec_type and len(instance.args) > 0:
-            first_arg = get_proper_type(instance.args[0])
-
-            # TODO: can I use tuple syntax to isinstance multiple in 3.6?
-            if not (
-                len(instance.args) == 1
-                and (
-                    isinstance(first_arg, Parameters)
-                    or isinstance(first_arg, ParamSpecType)
-                    or isinstance(first_arg, AnyType)
-                )
-            ):
-                args = instance.args
-                instance.args = (Parameters(args, [ARG_POS] * len(args), [None] * len(args)),)
+        if len(info.type_vars) == 1 and info.has_param_spec_type:
+            instance.args = tuple(self.pack_paramspec_args(instance.args))
 
         if info.has_type_var_tuple_type:
             # - 1 to allow for the empty type var tuple case.
@@ -676,6 +693,7 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
             if info.special_alias:
                 return expand_type_alias(
                     info.special_alias,
+                    # TODO: should we allow NamedTuples generic in ParamSpec?
                     self.anal_array(args),
                     self.fail,
                     False,
@@ -690,6 +708,7 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
             if info.special_alias:
                 return expand_type_alias(
                     info.special_alias,
+                    # TODO: should we allow TypedDicts generic in ParamSpec?
                     self.anal_array(args),
                     self.fail,
                     False,
@@ -810,9 +829,11 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
             )
         else:
             message = 'Cannot interpret reference "{}" as a type'
-        self.fail(message.format(name), t, code=codes.VALID_TYPE)
-        for note in notes:
-            self.note(note, t, code=codes.VALID_TYPE)
+        if not defining_literal:
+            # Literal check already gives a custom error. Avoid duplicating errors.
+            self.fail(message.format(name), t, code=codes.VALID_TYPE)
+            for note in notes:
+                self.note(note, t, code=codes.VALID_TYPE)
 
         # TODO: Would it be better to always return Any instead of UnboundType
         # in case of an error? On one hand, UnboundType has a name so error messages
@@ -1102,6 +1123,16 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
             return None
         tvar_def = self.tvar_scope.get_binding(sym)
         if not isinstance(tvar_def, ParamSpecType):
+            if (
+                tvar_def is None
+                and self.allow_unbound_tvars
+                and isinstance(sym.node, ParamSpecExpr)
+            ):
+                # We are analyzing this type in runtime context (e.g. as type application).
+                # If it is not valid as a type in this position an error will be given later.
+                return callable_with_ellipsis(
+                    AnyType(TypeOfAny.explicit), ret_type=ret_type, fallback=fallback
+                )
             return None
 
         return CallableType(
@@ -1137,6 +1168,14 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
 
         tvar_def = self.anal_type(callable_args, allow_param_spec=True)
         if not isinstance(tvar_def, ParamSpecType):
+            if self.allow_unbound_tvars and isinstance(tvar_def, UnboundType):
+                sym = self.lookup_qualified(tvar_def.name, callable_args)
+                if sym is not None and isinstance(sym.node, ParamSpecExpr):
+                    # We are analyzing this type in runtime context (e.g. as type application).
+                    # If it is not valid as a type in this position an error will be given later.
+                    return callable_with_ellipsis(
+                        AnyType(TypeOfAny.explicit), ret_type=ret_type, fallback=fallback
+                    )
             return None
 
         # ick, CallableType should take ParamSpecType
@@ -1637,12 +1676,12 @@ def expand_type_alias(
     """Expand a (generic) type alias target following the rules outlined in TypeAlias docstring.
 
     Here:
-        target: original target type (contains unbound type variables)
-        alias_tvars: type variable names
+        target: original target type
         args: types to be substituted in place of type variables
         fail: error reporter callback
         no_args: whether original definition used a bare generic `A = List`
         ctx: context where expansion happens
+        unexpanded_type, disallow_any, use_standard_error: used to customize error messages
     """
     exp_len = len(node.alias_tvars)
     act_len = len(args)
@@ -1682,6 +1721,9 @@ def expand_type_alias(
             msg = f"Bad number of arguments for type alias, expected: {exp_len}, given: {act_len}"
         fail(msg, ctx, code=codes.TYPE_ARG)
         return set_any_tvars(node, ctx.line, ctx.column, from_error=True)
+    # TODO: we need to check args validity w.r.t alias.alias_tvars.
+    # Otherwise invalid instantiations will be allowed in runtime context.
+    # Note: in type context, these will be still caught by semanal_typeargs.
     typ = TypeAliasType(node, args, ctx.line, ctx.column)
     assert typ.alias is not None
     # HACK: Implement FlexibleAlias[T, typ] by expanding it to typ here.
@@ -1822,26 +1864,11 @@ class DivergingAliasDetector(TrivialSyntheticTypeTranslator):
         self.scope = scope
         self.diverging = False
 
-    def is_alias_tvar(self, t: Type) -> bool:
-        # Generic type aliases use unbound type variables.
-        if not isinstance(t, UnboundType) or t.args:
-            return False
-        node = self.lookup(t.name, t)
-        if (
-            node
-            and isinstance(node.node, TypeVarLikeExpr)
-            and self.scope.get_binding(node) is None
-        ):
-            return True
-        return False
-
     def visit_type_alias_type(self, t: TypeAliasType) -> Type:
         assert t.alias is not None, f"Unfixed type alias {t.type_ref}"
         if t.alias in self.seen_nodes:
             for arg in t.args:
-                if not self.is_alias_tvar(arg) and bool(
-                    arg.accept(TypeVarLikeQuery(self.lookup, self.scope))
-                ):
+                if not isinstance(arg, TypeVarLikeType) and has_type_vars(arg):
                     self.diverging = True
                     return t
             # All clear for this expansion chain.
diff --git a/mypy/types.py b/mypy/types.py
index 78142d900..7d2ac9911 100644
--- a/mypy/types.py
+++ b/mypy/types.py
@@ -3202,24 +3202,45 @@ def is_named_instance(t: Type, fullnames: str | tuple[str, ...]) -> TypeGuard[In
 
 
 class InstantiateAliasVisitor(TrivialSyntheticTypeTranslator):
-    def __init__(self, vars: list[str], subs: list[Type]) -> None:
-        self.replacements = {v: s for (v, s) in zip(vars, subs)}
+    def __init__(self, vars: list[TypeVarLikeType], subs: list[Type]) -> None:
+        self.replacements = {v.id: s for (v, s) in zip(vars, subs)}
 
     def visit_type_alias_type(self, typ: TypeAliasType) -> Type:
         return typ.copy_modified(args=[t.accept(self) for t in typ.args])
 
-    def visit_unbound_type(self, typ: UnboundType) -> Type:
-        # TODO: stop using unbound type variables for type aliases.
-        # Now that type aliases are very similar to TypeInfos we should
-        # make type variable tracking similar as well. Maybe we can even support
-        # upper bounds etc. for generic type aliases.
-        if typ.name in self.replacements:
-            return self.replacements[typ.name]
+    def visit_type_var(self, typ: TypeVarType) -> Type:
+        if typ.id in self.replacements:
+            return self.replacements[typ.id]
         return typ
 
-    def visit_type_var(self, typ: TypeVarType) -> Type:
-        if typ.name in self.replacements:
-            return self.replacements[typ.name]
+    def visit_callable_type(self, t: CallableType) -> Type:
+        param_spec = t.param_spec()
+        if param_spec is not None:
+            # TODO: this branch duplicates the one in expand_type(), find a way to reuse it
+            # without import cycle types <-> typeanal <-> expandtype.
+            repl = get_proper_type(self.replacements.get(param_spec.id))
+            if isinstance(repl, CallableType) or isinstance(repl, Parameters):
+                prefix = param_spec.prefix
+                t = t.expand_param_spec(repl, no_prefix=True)
+                return t.copy_modified(
+                    arg_types=[t.accept(self) for t in prefix.arg_types] + t.arg_types,
+                    arg_kinds=prefix.arg_kinds + t.arg_kinds,
+                    arg_names=prefix.arg_names + t.arg_names,
+                    ret_type=t.ret_type.accept(self),
+                    type_guard=(t.type_guard.accept(self) if t.type_guard is not None else None),
+                )
+        return super().visit_callable_type(t)
+
+    def visit_param_spec(self, typ: ParamSpecType) -> Type:
+        if typ.id in self.replacements:
+            repl = get_proper_type(self.replacements[typ.id])
+            # TODO: all the TODOs from same logic in expand_type() apply here.
+            if isinstance(repl, Instance):
+                return repl
+            elif isinstance(repl, (ParamSpecType, Parameters, CallableType)):
+                return expand_param_spec(typ, repl)
+            else:
+                return repl
         return typ
 
 
@@ -3236,7 +3257,7 @@ class LocationSetter(TypeTraverserVisitor):
 
 
 def replace_alias_tvars(
-    tp: Type, vars: list[str], subs: list[Type], newline: int, newcolumn: int
+    tp: Type, vars: list[TypeVarLikeType], subs: list[Type], newline: int, newcolumn: int
 ) -> Type:
     """Replace type variables in a generic type alias tp with substitutions subs
     resetting context. Length of subs should be already checked.
@@ -3252,6 +3273,7 @@ def replace_alias_tvars(
 class HasTypeVars(TypeQuery[bool]):
     def __init__(self) -> None:
         super().__init__(any)
+        self.skip_alias_target = True
 
     def visit_type_var(self, t: TypeVarType) -> bool:
         return True
@@ -3406,6 +3428,41 @@ def callable_with_ellipsis(any_type: AnyType, ret_type: Type, fallback: Instance
     )
 
 
+def expand_param_spec(
+    t: ParamSpecType, repl: ParamSpecType | Parameters | CallableType
+) -> ProperType:
+    """This is shared part of the logic w.r.t. ParamSpec instantiation.
+
+    It is shared between type aliases and proper types, that currently use somewhat different
+    logic for instantiation."""
+    if isinstance(repl, ParamSpecType):
+        return repl.copy_modified(
+            flavor=t.flavor,
+            prefix=t.prefix.copy_modified(
+                arg_types=t.prefix.arg_types + repl.prefix.arg_types,
+                arg_kinds=t.prefix.arg_kinds + repl.prefix.arg_kinds,
+                arg_names=t.prefix.arg_names + repl.prefix.arg_names,
+            ),
+        )
+    else:
+        # if the paramspec is *P.args or **P.kwargs:
+        if t.flavor != ParamSpecFlavor.BARE:
+            assert isinstance(repl, CallableType), "Should not be able to get here."
+            # Is this always the right thing to do?
+            param_spec = repl.param_spec()
+            if param_spec:
+                return param_spec.with_flavor(t.flavor)
+            else:
+                return repl
+        else:
+            return Parameters(
+                t.prefix.arg_types + repl.arg_types,
+                t.prefix.arg_kinds + repl.arg_kinds,
+                t.prefix.arg_names + repl.arg_names,
+                variables=[*t.prefix.variables, *repl.variables],
+            )
+
+
 def store_argument_type(
     defn: FuncItem, i: int, typ: CallableType, named_type: Callable[[str, list[Type]], Instance]
 ) -> None:
diff --git a/mypy/typetraverser.py b/mypy/typetraverser.py
index afe77efff..9c4a9157a 100644
--- a/mypy/typetraverser.py
+++ b/mypy/typetraverser.py
@@ -131,6 +131,9 @@ class TypeTraverserVisitor(SyntheticTypeVisitor[None]):
         pass
 
     def visit_type_alias_type(self, t: TypeAliasType) -> None:
+        # TODO: sometimes we want to traverse target as well
+        # We need to find a way to indicate explicitly the intent,
+        # maybe make this method abstract (like for TypeTranslator)?
         self.traverse_types(t.args)
 
     def visit_unpack_type(self, t: UnpackType) -> None:
diff --git a/test-data/unit/check-generics.test b/test-data/unit/check-generics.test
index 04108dded..dd7e31528 100644
--- a/test-data/unit/check-generics.test
+++ b/test-data/unit/check-generics.test
@@ -655,7 +655,7 @@ a: other.Array[float]
 reveal_type(a) # N: Revealed type is "other.array[Any, other.dtype[builtins.float]]"
 
 [out]
-main:3: error: Type argument "float" of "dtype" must be a subtype of "generic"  [type-var]
+main:3: error: Type argument "float" of "Array" must be a subtype of "generic"  [type-var]
     a: other.Array[float]
        ^
 [file other.py]
@@ -1031,8 +1031,9 @@ IntNode[int](1, 1)
 IntNode[int](1, 'a')  # E: Argument 2 to "Node" has incompatible type "str"; expected "int"
 
 SameNode = Node[T, T]
-# TODO: fix https://github.com/python/mypy/issues/7084.
-ff = SameNode[T](1, 1)
+ff = SameNode[T](1, 1)  # E: Type variable "__main__.T" is unbound \
+        # N: (Hint: Use "Generic[T]" or "Protocol[T]" base class to bind "T" inside a class) \
+        # N: (Hint: Use "T" in function signature to bind "T" inside a function)
 a = SameNode(1, 'x')
 reveal_type(a) # N: Revealed type is "__main__.Node[Any, Any]"
 b = SameNode[int](1, 1)
@@ -1101,13 +1102,12 @@ BadA = A[str, T]  # One error here
 SameA = A[T, T]
 
 x = None # type: SameA[int]
-y = None # type: SameA[str] # Two errors here, for both args of A
+y = None # type: SameA[str] # Another error here
 
 [builtins fixtures/list.pyi]
 [out]
 main:9:8: error: Value of type variable "T" of "A" cannot be "str"
-main:13:1: error: Value of type variable "T" of "A" cannot be "str"
-main:13:1: error: Value of type variable "S" of "A" cannot be "str"
+main:13:1: error: Value of type variable "T" of "SameA" cannot be "str"
 
 [case testGenericTypeAliasesIgnoredPotentialAlias]
 class A: ...
@@ -2645,3 +2645,21 @@ class C(Generic[T]):
 
 def foo(x: C[T]) -> T:
     return x.x(42).y  # OK
+
+[case testNestedGenericFunctionTypeApplication]
+from typing import TypeVar, Generic, List
+
+A = TypeVar("A")
+B = TypeVar("B")
+
+class C(Generic[A]):
+    x: A
+
+def foo(x: A) -> A:
+    def bar() -> List[A]:
+        y = C[List[A]]()
+        z = C[List[B]]()  # E: Type variable "__main__.B" is unbound \
+                # N: (Hint: Use "Generic[B]" or "Protocol[B]" base class to bind "B" inside a class) \
+                # N: (Hint: Use "B" in function signature to bind "B" inside a function)
+        return y.x
+    return bar()[0]
diff --git a/test-data/unit/check-isinstance.test b/test-data/unit/check-isinstance.test
index 6eddcd866..0722ee8d9 100644
--- a/test-data/unit/check-isinstance.test
+++ b/test-data/unit/check-isinstance.test
@@ -1750,11 +1750,8 @@ def f(cls: Type[object]) -> None:
 [case testIsinstanceTypeArgs]
 from typing import Iterable, TypeVar
 x = 1
-T = TypeVar('T')
-
 isinstance(x, Iterable)
 isinstance(x, Iterable[int])  # E: Parameterized generics cannot be used with class or instance checks
-isinstance(x, Iterable[T])  # E: Parameterized generics cannot be used with class or instance checks
 isinstance(x, (int, Iterable[int]))  # E: Parameterized generics cannot be used with class or instance checks
 isinstance(x, (int, (str, Iterable[int])))  # E: Parameterized generics cannot be used with class or instance checks
 [builtins fixtures/isinstancelist.pyi]
@@ -1783,10 +1780,8 @@ isinstance(x, It2)  # E: Parameterized generics cannot be used with class or ins
 [case testIssubclassTypeArgs]
 from typing import Iterable, TypeVar
 x = int
-T = TypeVar('T')
 issubclass(x, Iterable)
 issubclass(x, Iterable[int])  # E: Parameterized generics cannot be used with class or instance checks
-issubclass(x, Iterable[T])  # E: Parameterized generics cannot be used with class or instance checks
 issubclass(x, (int, Iterable[int]))  # E: Parameterized generics cannot be used with class or instance checks
 [builtins fixtures/isinstance.pyi]
 [typing fixtures/typing-full.pyi]
diff --git a/test-data/unit/check-literal.test b/test-data/unit/check-literal.test
index ef8c9095e..d523e5c08 100644
--- a/test-data/unit/check-literal.test
+++ b/test-data/unit/check-literal.test
@@ -2437,23 +2437,10 @@ b: Final = 3
 c: Final[Literal[3]] = 3
 d: Literal[3]
 
-# TODO: Consider if we want to support cases 'b' and 'd' or not.
-# Probably not: we want to mostly keep the 'types' and 'value' worlds distinct.
-# However, according to final semantics, we ought to be able to substitute "b" with
-# "3" wherever it's used and get the same behavior -- so maybe we do need to support
-# at least case "b" for consistency?
-a_wrap: Literal[4, a]  # E: Parameter 2 of Literal[...] is invalid \
-                       # E: Variable "__main__.a" is not valid as a type \
-                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
-b_wrap: Literal[4, b]  # E: Parameter 2 of Literal[...] is invalid \
-                       # E: Variable "__main__.b" is not valid as a type \
-                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
-c_wrap: Literal[4, c]  # E: Parameter 2 of Literal[...] is invalid \
-                       # E: Variable "__main__.c" is not valid as a type \
-                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
-d_wrap: Literal[4, d]  # E: Parameter 2 of Literal[...] is invalid \
-                       # E: Variable "__main__.d" is not valid as a type \
-                       # N: See https://mypy.readthedocs.io/en/stable/common_issues.html#variables-vs-type-aliases
+a_wrap: Literal[4, a]  # E: Parameter 2 of Literal[...] is invalid
+b_wrap: Literal[4, b]  # E: Parameter 2 of Literal[...] is invalid
+c_wrap: Literal[4, c]  # E: Parameter 2 of Literal[...] is invalid
+d_wrap: Literal[4, d]  # E: Parameter 2 of Literal[...] is invalid
 [builtins fixtures/tuple.pyi]
 [out]
 
@@ -2517,9 +2504,7 @@ r: Literal[Color.RED]
 g: Literal[Color.GREEN]
 b: Literal[Color.BLUE]
 bad1: Literal[Color]         # E: Parameter 1 of Literal[...] is invalid
-bad2: Literal[Color.func]    # E: Function "__main__.Color.func" is not valid as a type \
-                             # N: Perhaps you need "Callable[...]" or a callback protocol? \
-                             # E: Parameter 1 of Literal[...] is invalid
+bad2: Literal[Color.func]    # E: Parameter 1 of Literal[...] is invalid
 bad3: Literal[Color.func()]  # E: Invalid type: Literal[...] cannot contain arbitrary expressions
 
 def expects_color(x: Color) -> None: pass
diff --git a/test-data/unit/check-parameter-specification.test b/test-data/unit/check-parameter-specification.test
index b13f74bc3..4a5dd0c1b 100644
--- a/test-data/unit/check-parameter-specification.test
+++ b/test-data/unit/check-parameter-specification.test
@@ -429,7 +429,6 @@ class Z(Generic[P]): ...
 # literals can be applied
 n: Z[[int]]
 
-# TODO: type aliases too
 nt1 = Z[[int]]
 nt2: TypeAlias = Z[[int]]
 
@@ -506,8 +505,7 @@ def f2(x: X[int, Concatenate[int, P_2]]) -> str: ...  # Accepted
 def f3(x: X[int, [int, bool]]) -> str: ...            # Accepted
 # ellipsis only show up here, but I can assume it works like Callable[..., R]
 def f4(x: X[int, ...]) -> str: ...                    # Accepted
-# TODO: this is not rejected:
-# def f5(x: X[int, int]) -> str: ...                    # Rejected
+def f5(x: X[int, int]) -> str: ...  # E: Can only replace ParamSpec with a parameter types list or another ParamSpec, got "int"
 
 # CASE 3
 def bar(x: int, *args: bool) -> int: ...
@@ -844,9 +842,7 @@ class A:
         ...
 
 reveal_type(A.func)  # N: Revealed type is "def [_P, _R] (self: __main__.A, action: def (*_P.args, **_P.kwargs) -> _R`-2, *_P.args, **_P.kwargs) -> _R`-2"
-
-# TODO: _R`<n> keeps flip-flopping between 5 (?), 13, 14, 15. Spooky.
-# reveal_type(A().func)  $ N: Revealed type is "def [_P, _R] (action: def (*_P.args, **_P.kwargs) -> _R`13, *_P.args, **_P.kwargs) -> _R`13"
+reveal_type(A().func)  # N: Revealed type is "def [_P, _R] (action: def (*_P.args, **_P.kwargs) -> _R`5, *_P.args, **_P.kwargs) -> _R`5"
 
 def f(x: int) -> int:
     ...
@@ -879,8 +875,7 @@ class A:
         ...
 
 reveal_type(A.func)  # N: Revealed type is "def [_P] (self: __main__.A, action: __main__.Job[_P`-1, None]) -> __main__.Job[_P`-1, None]"
-# TODO: flakey, _P`4 alternates around.
-# reveal_type(A().func)  $ N: Revealed type is "def [_P] (action: __main__.Job[_P`4, None]) -> __main__.Job[_P`4, None]"
+reveal_type(A().func)  # N: Revealed type is "def [_P] (action: __main__.Job[_P`3, None]) -> __main__.Job[_P`3, None]"
 reveal_type(A().func(Job(lambda x: x)))  # N: Revealed type is "__main__.Job[[x: Any], None]"
 
 def f(x: int, y: int) -> None: ...
@@ -1296,3 +1291,144 @@ class C(Generic[P]):
 
 reveal_type(bar(C(fn=foo, x=1)))  # N: Revealed type is "__main__.C[[x: builtins.int]]"
 [builtins fixtures/paramspec.pyi]
+
+[case testParamSpecInTypeAliasBasic]
+from typing import ParamSpec, Callable
+
+P = ParamSpec("P")
+C = Callable[P, int]
+def f(n: C[P]) -> C[P]: ...
+
+@f
+def bar(x: int) -> int: ...
+@f    # E: Argument 1 to "f" has incompatible type "Callable[[int], str]"; expected "Callable[[int], int]"
+def foo(x: int) -> str: ...
+
+x: C[[int, str]]
+reveal_type(x)  # N: Revealed type is "def (builtins.int, builtins.str) -> builtins.int"
+y: C[int, str]
+reveal_type(y)  # N: Revealed type is "def (builtins.int, builtins.str) -> builtins.int"
+[builtins fixtures/paramspec.pyi]
+
+[case testParamSpecInTypeAliasConcatenate]
+from typing import ParamSpec, Callable
+from typing_extensions import Concatenate
+
+P = ParamSpec("P")
+C = Callable[Concatenate[int, P], int]
+def f(n: C[P]) -> C[P]: ...
+
+@f  # E: Argument 1 to "f" has incompatible type "Callable[[], int]"; expected "Callable[[int], int]"
+def bad() -> int: ...
+
+@f
+def bar(x: int) -> int: ...
+
+@f
+def bar2(x: int, y: str) -> int: ...
+reveal_type(bar2)  # N: Revealed type is "def (builtins.int, y: builtins.str) -> builtins.int"
+
+@f  # E: Argument 1 to "f" has incompatible type "Callable[[int], str]"; expected "Callable[[int], int]" \
+    # N: This is likely because "foo" has named arguments: "x". Consider marking them positional-only
+def foo(x: int) -> str: ...
+
+@f  # E: Argument 1 to "f" has incompatible type "Callable[[str, int], int]"; expected "Callable[[int, int], int]" \
+    # N: This is likely because "foo2" has named arguments: "x". Consider marking them positional-only
+def foo2(x: str, y: int) -> int: ...
+
+x: C[[int, str]]
+reveal_type(x)  # N: Revealed type is "def (builtins.int, builtins.int, builtins.str) -> builtins.int"
+y: C[int, str]
+reveal_type(y)  # N: Revealed type is "def (builtins.int, builtins.int, builtins.str) -> builtins.int"
+[builtins fixtures/paramspec.pyi]
+
+[case testParamSpecInTypeAliasRecursive]
+from typing import ParamSpec, Callable, Union
+
+P = ParamSpec("P")
+C = Callable[P, Union[int, C[P]]]
+def f(n: C[P]) -> C[P]: ...
+
+@f
+def bar(x: int) -> int: ...
+
+@f
+def bar2(__x: int) -> Callable[[int], int]: ...
+
+@f  # E: Argument 1 to "f" has incompatible type "Callable[[int], str]"; expected "C[[int]]"
+def foo(x: int) -> str: ...
+
+@f  # E: Argument 1 to "f" has incompatible type "Callable[[int], Callable[[int], str]]"; expected "C[[int]]"
+def foo2(__x: int) -> Callable[[int], str]: ...
+
+x: C[[int, str]]
+reveal_type(x)  # N: Revealed type is "def (builtins.int, builtins.str) -> Union[builtins.int, ...]"
+y: C[int, str]
+reveal_type(y)  # N: Revealed type is "def (builtins.int, builtins.str) -> Union[builtins.int, ...]"
+[builtins fixtures/paramspec.pyi]
+
+[case testParamSpecAliasInRuntimeContext]
+from typing import ParamSpec, Generic
+
+P = ParamSpec("P")
+class C(Generic[P]): ...
+
+c = C[int, str]()
+reveal_type(c)  # N: Revealed type is "__main__.C[[builtins.int, builtins.str]]"
+
+A = C[P]
+a = A[int, str]()
+reveal_type(a)  # N: Revealed type is "__main__.C[[builtins.int, builtins.str]]"
+[builtins fixtures/paramspec.pyi]
+
+[case testParamSpecAliasInvalidLocations]
+from typing import ParamSpec, Generic, List, TypeVar, Callable
+
+P = ParamSpec("P")
+T = TypeVar("T")
+A = List[T]
+def f(x: A[[int, str]]) -> None: ...  # E: Bracketed expression "[...]" is not valid as a type \
+                                      # N: Did you mean "List[...]"?
+def g(x: A[P]) -> None: ...  # E: Invalid location for ParamSpec "P" \
+                             # N: You can use ParamSpec as the first argument to Callable, e.g., 'Callable[P, int]'
+
+C = Callable[P, T]
+x: C[int]  # E: Bad number of arguments for type alias, expected: 2, given: 1
+y: C[int, str]  # E: Can only replace ParamSpec with a parameter types list or another ParamSpec, got "int"
+z: C[int, str, bytes]  # E: Bad number of arguments for type alias, expected: 2, given: 3
+[builtins fixtures/paramspec.pyi]
+
+[case testTrivialParametersHandledCorrectly]
+from typing import ParamSpec, Generic, TypeVar, Callable, Any
+from typing_extensions import Concatenate
+
+P = ParamSpec("P")
+T = TypeVar("T")
+S = TypeVar("S")
+
+class C(Generic[S, P, T]): ...
+
+def foo(f: Callable[P, int]) -> None:
+    x: C[Any, ..., Any]
+    x1: C[int, Concatenate[int, str, P], str]
+    x = x1  # OK
+[builtins fixtures/paramspec.pyi]
+
+[case testParamSpecAliasNested]
+from typing import ParamSpec, Callable, List, TypeVar, Generic
+from typing_extensions import Concatenate
+
+P = ParamSpec("P")
+A = List[Callable[P, None]]
+B = List[Callable[Concatenate[int, P], None]]
+
+fs: A[int, str]
+reveal_type(fs)  # N: Revealed type is "builtins.list[def (builtins.int, builtins.str)]"
+gs: B[int, str]
+reveal_type(gs)  # N: Revealed type is "builtins.list[def (builtins.int, builtins.int, builtins.str)]"
+
+T = TypeVar("T")
+class C(Generic[T]): ...
+C[Callable[P, int]]()  # E: The first argument to Callable must be a list of types, parameter specification, or "..." \
+                       # N: See https://mypy.readthedocs.io/en/stable/kinds_of_types.html#callable-types-and-lambdas
+[builtins fixtures/paramspec.pyi]
diff --git a/test-data/unit/check-type-aliases.test b/test-data/unit/check-type-aliases.test
index fab372976..121be34f0 100644
--- a/test-data/unit/check-type-aliases.test
+++ b/test-data/unit/check-type-aliases.test
@@ -947,3 +947,38 @@ c.SpecialImplicit = 4
 c.SpecialExplicit = 4
 [builtins fixtures/tuple.pyi]
 [typing fixtures/typing-medium.pyi]
+
+[case testValidTypeAliasValues]
+from typing import TypeVar, Generic, List
+
+T = TypeVar("T", int, str)
+S = TypeVar("S", int, bytes)
+
+class C(Generic[T]): ...
+class D(C[S]): ...  # E: Invalid type argument value for "C"
+
+U = TypeVar("U")
+A = List[C[U]]
+x: A[bytes]  # E: Value of type variable "T" of "C" cannot be "bytes"
+
+V = TypeVar("V", bound=int)
+class E(Generic[V]): ...
+B = List[E[U]]
+y: B[str]  # E: Type argument "str" of "E" must be a subtype of "int"
+
+[case testValidTypeAliasValuesMoreRestrictive]
+from typing import TypeVar, Generic, List
+
+T = TypeVar("T")
+S = TypeVar("S", int, str)
+U = TypeVar("U", bound=int)
+
+class C(Generic[T]): ...
+
+A = List[C[S]]
+x: A[int]
+x_bad: A[bytes]  # E: Value of type variable "S" of "A" cannot be "bytes"
+
+B = List[C[U]]
+y: B[int]
+y_bad: B[str]  # E: Type argument "str" of "B" must be a subtype of "int"
