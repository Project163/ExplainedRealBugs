diff --git a/mypy/erasetype.py b/mypy/erasetype.py
index 8acebbd78..3301325eb 100644
--- a/mypy/erasetype.py
+++ b/mypy/erasetype.py
@@ -41,8 +41,7 @@ class EraseTypeVisitor(TypeVisitor[ProperType]):
         return t
 
     def visit_erased_type(self, t: ErasedType) -> ProperType:
-        # Should not get here.
-        raise RuntimeError()
+        return t
 
     def visit_partial_type(self, t: PartialType) -> ProperType:
         # Should not get here.
diff --git a/mypy/subtypes.py b/mypy/subtypes.py
index cb7f53f0d..200106000 100644
--- a/mypy/subtypes.py
+++ b/mypy/subtypes.py
@@ -1167,6 +1167,7 @@ def restrict_subtype_away(t: Type, s: Type, *, ignore_promotions: bool = False)
 def covers_at_runtime(item: Type, supertype: Type, ignore_promotions: bool) -> bool:
     """Will isinstance(item, supertype) always return True at runtime?"""
     item = get_proper_type(item)
+    supertype = get_proper_type(supertype)
 
     # Since runtime type checks will ignore type arguments, erase the types.
     supertype = erase_type(supertype)
diff --git a/test-data/unit/check-inference.test b/test-data/unit/check-inference.test
index 9f9d48b74..4de6e4a76 100644
--- a/test-data/unit/check-inference.test
+++ b/test-data/unit/check-inference.test
@@ -3211,6 +3211,21 @@ def test(seq: List[Union[Iterable, Any]]) -> None:
             reveal_type(k)  # N: Revealed type is "builtins.list[Any]"
 [builtins fixtures/list.pyi]
 
+[case testErasedTypeRuntimeCoverage]
+# https://github.com/python/mypy/issues/11913
+from typing import TypeVar, Type, Generic, Callable, Iterable
+
+class DataType: ...
+
+T1 = TypeVar('T1')
+T2 = TypeVar("T2", bound=DataType)
+
+def map(__func: T1) -> None: ...
+
+def collection_from_dict_value(model: Type[T2]) -> None:
+    map(lambda i: i if isinstance(i, model) else i)
+[builtins fixtures/isinstancelist.pyi]
+
 [case testRegression11705_Strict]
 # flags: --strict-optional
 # See: https://github.com/python/mypy/issues/11705
