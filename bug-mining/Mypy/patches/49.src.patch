diff --git a/mypy/messages.py b/mypy/messages.py
index 086f3d22a..dd6e08c2d 100644
--- a/mypy/messages.py
+++ b/mypy/messages.py
@@ -649,6 +649,7 @@ class MessageBuilder:
     def too_many_arguments(self, callee: CallableType, context: Context) -> None:
         msg = 'Too many arguments' + for_function(callee)
         self.fail(msg, context, code=codes.CALL_ARG)
+        self.maybe_note_about_special_args(callee, context)
 
     def too_many_arguments_from_typed_dict(self,
                                            callee: CallableType,
@@ -668,6 +669,18 @@ class MessageBuilder:
                                       context: Context) -> None:
         msg = 'Too many positional arguments' + for_function(callee)
         self.fail(msg, context)
+        self.maybe_note_about_special_args(callee, context)
+
+    def maybe_note_about_special_args(self, callee: CallableType, context: Context) -> None:
+        # https://github.com/python/mypy/issues/11309
+        first_arg = callee.def_extras.get('first_arg')
+        if first_arg and first_arg not in {'self', 'cls', 'mcs'}:
+            self.note(
+                'Looks like the first special argument in a method '
+                'is not named "self", "cls", or "mcs", '
+                'maybe it is missing?',
+                context,
+            )
 
     def unexpected_keyword_argument(self, callee: CallableType, name: str, arg_type: Type,
                                     context: Context) -> None:
diff --git a/mypy/typeops.py b/mypy/typeops.py
index 09afcb6e6..6adf21fd8 100644
--- a/mypy/typeops.py
+++ b/mypy/typeops.py
@@ -17,7 +17,7 @@ from mypy.types import (
     copy_type, TypeAliasType, TypeQuery, ParamSpecType
 )
 from mypy.nodes import (
-    FuncBase, FuncItem, OverloadedFuncDef, TypeInfo, ARG_STAR, ARG_STAR2, ARG_POS,
+    FuncBase, FuncItem, FuncDef, OverloadedFuncDef, TypeInfo, ARG_STAR, ARG_STAR2, ARG_POS,
     Expression, StrExpr, Var, Decorator, SYMBOL_FUNCBASE_TYPES
 )
 from mypy.maptype import map_instance_to_supertype
@@ -572,6 +572,8 @@ def callable_type(fdef: FuncItem, fallback: Instance,
         line=fdef.line,
         column=fdef.column,
         implicit=True,
+        # We need this for better error messages, like missing `self` note:
+        definition=fdef if isinstance(fdef, FuncDef) else None,
     )
 
 
diff --git a/mypy/types.py b/mypy/types.py
index b7c31f1a4..49a25ef45 100644
--- a/mypy/types.py
+++ b/mypy/types.py
@@ -1059,9 +1059,16 @@ class CallableType(FunctionLike):
             # after serialization, but it is useful in error messages.
             # TODO: decide how to add more info here (file, line, column)
             # without changing interface hash.
-            self.def_extras = {'first_arg': definition.arguments[0].variable.name
-                               if definition.arg_names and definition.info and
-                               not definition.is_static else None}
+            self.def_extras = {
+                'first_arg': (
+                    definition.arguments[0].variable.name
+                    if (getattr(definition, 'arguments', None)
+                        and definition.arg_names
+                        and definition.info
+                        and not definition.is_static)
+                    else None
+                ),
+            }
         else:
             self.def_extras = {}
         self.type_guard = type_guard
diff --git a/test-data/unit/check-abstract.test b/test-data/unit/check-abstract.test
index 6653768aa..859bacebf 100644
--- a/test-data/unit/check-abstract.test
+++ b/test-data/unit/check-abstract.test
@@ -446,7 +446,7 @@ class A(I):
 [out]
 main:10: error: Signature of "g" incompatible with supertype "I"
 main:10: note:      Superclass:
-main:10: note:          def g(x: Any) -> Any
+main:10: note:          def g(self, x: Any) -> Any
 main:10: note:      Subclass:
 main:10: note:          def g(self, x: Any, y: Any) -> None
 
diff --git a/test-data/unit/check-callable.test b/test-data/unit/check-callable.test
index 5278d24eb..05438727e 100644
--- a/test-data/unit/check-callable.test
+++ b/test-data/unit/check-callable.test
@@ -506,3 +506,42 @@ reveal_type(_TYPE)  # N: Revealed type is "def (x: Any) -> builtins.type"
 _TYPE('bar')
 
 [builtins fixtures/callable.pyi]
+
+[case testErrorMessageAboutSelf]
+# https://github.com/python/mypy/issues/11309
+class Some:
+    def method(self, a) -> None: pass
+    @classmethod
+    def cls_method(cls, a) -> None: pass
+    @staticmethod
+    def st_method(a) -> None: pass
+
+    def bad_method(a) -> None: pass
+    @classmethod
+    def bad_cls_method(a) -> None: pass
+    @staticmethod
+    def bad_st_method() -> None: pass
+
+s: Some
+
+s.method(1)
+s.cls_method(1)
+Some.cls_method(1)
+s.st_method(1)
+Some.st_method(1)
+
+s.method(1, 2)  # E: Too many arguments for "method" of "Some"
+s.cls_method(1, 2)  # E: Too many arguments for "cls_method" of "Some"
+Some.cls_method(1, 2)  # E: Too many arguments for "cls_method" of "Some"
+s.st_method(1, 2)  # E: Too many arguments for "st_method" of "Some"
+Some.st_method(1, 2)  # E: Too many arguments for "st_method" of "Some"
+
+s.bad_method(1)  # E: Too many arguments for "bad_method" of "Some" \
+                 # N: Looks like the first special argument in a method is not named "self", "cls", or "mcs", maybe it is missing?
+s.bad_cls_method(1)  # E: Too many arguments for "bad_cls_method" of "Some" \
+                     # N: Looks like the first special argument in a method is not named "self", "cls", or "mcs", maybe it is missing?
+Some.bad_cls_method(1)  # E: Too many arguments for "bad_cls_method" of "Some" \
+                        # N: Looks like the first special argument in a method is not named "self", "cls", or "mcs", maybe it is missing?
+s.bad_st_method(1)  # E: Too many arguments for "bad_st_method" of "Some"
+Some.bad_st_method(1)  # E: Too many arguments for "bad_st_method" of "Some"
+[builtins fixtures/callable.pyi]
diff --git a/test-data/unit/check-classes.test b/test-data/unit/check-classes.test
index 78d261818..62641be92 100644
--- a/test-data/unit/check-classes.test
+++ b/test-data/unit/check-classes.test
@@ -2835,7 +2835,7 @@ C(foo='') # E: Argument "foo" to "C" has incompatible type "str"; expected "Opti
 
 [case testConstructInstanceWithDynamicallyTyped__new__]
 class C:
-    def __new__(cls, foo):
+    def __new__(cls, foo):  # N: "C" defined here
         obj = object.__new__(cls)
         return obj
 
diff --git a/test-data/unit/check-columns.test b/test-data/unit/check-columns.test
index 88f7fb98c..322011974 100644
--- a/test-data/unit/check-columns.test
+++ b/test-data/unit/check-columns.test
@@ -135,7 +135,7 @@ def foobar(): pass
 [builtins fixtures/module.pyi]
 
 [case testColumnUnexpectedOrMissingKeywordArg]
-def f(): pass
+def f(): pass  # N:1: "f" defined here
 # TODO: Point to "x" instead
 (f(x=1)) # E:2: Unexpected keyword argument "x" for "f"
 def g(*, x: int) -> None: pass
@@ -402,7 +402,7 @@ from typing import TypeVar, List
 
 T = TypeVar('T', int, str)
 
-def g(x): pass
+def g(x): pass  # N:1: "g" defined here
 
 def f(x: T) -> T:
     (x.bad) # E:6: "int" has no attribute "bad" \
diff --git a/test-data/unit/check-dynamic-typing.test b/test-data/unit/check-dynamic-typing.test
index 137376535..8ff82819c 100644
--- a/test-data/unit/check-dynamic-typing.test
+++ b/test-data/unit/check-dynamic-typing.test
@@ -730,7 +730,7 @@ class A(B):
 [out]
 main:5: error: Signature of "f" incompatible with supertype "B"
 main:5: note:      Superclass:
-main:5: note:          def f(x: Any, y: Any) -> Any
+main:5: note:          def f(self, x: Any, y: Any) -> Any
 main:5: note:      Subclass:
 main:5: note:          def f(self, x: A) -> None
 
diff --git a/test-data/unit/check-incremental.test b/test-data/unit/check-incremental.test
index 0d7d2f125..b1d521f29 100644
--- a/test-data/unit/check-incremental.test
+++ b/test-data/unit/check-incremental.test
@@ -2886,7 +2886,7 @@ tmp/m/a.py:1: error: Unsupported operand types for + ("int" and "str")
 
 [case testDisallowAnyExprIncremental]
 # cmd: mypy -m main
-# flags:  --disallow-any-expr
+# flags: --disallow-any-expr
 
 [file ns.py]
 class Namespace:
diff --git a/test-data/unit/check-kwargs.test b/test-data/unit/check-kwargs.test
index 4828d1bb3..0340f8dbf 100644
--- a/test-data/unit/check-kwargs.test
+++ b/test-data/unit/check-kwargs.test
@@ -252,7 +252,7 @@ class B: pass
 
 [case testCallingDynamicallyTypedFunctionWithKeywordArgs]
 import typing
-def f(x, y=A()): pass
+def f(x, y=A()): pass  # N: "f" defined here
 f(x=A(), y=A())
 f(y=A(), x=A())
 f(y=A())      # E: Missing positional argument "x" in call to "f"
diff --git a/test-data/unit/check-python38.test b/test-data/unit/check-python38.test
index f033f7e65..c7289593e 100644
--- a/test-data/unit/check-python38.test
+++ b/test-data/unit/check-python38.test
@@ -193,9 +193,9 @@ def f(p1: bytes, p2: float, /) -> None:
     reveal_type(p2)  # N: Revealed type is "builtins.float"
 
 [case testPEP570Unannotated]
-def f(arg, /): ...
+def f(arg, /): ...  # N: "f" defined here
 g = lambda arg, /: arg
-def h(arg=0, /): ...
+def h(arg=0, /): ...  # N: "h" defined here
 i = lambda arg=0, /: arg
 
 f(1)
diff --git a/test-data/unit/fixtures/callable.pyi b/test-data/unit/fixtures/callable.pyi
index 7d4757df4..4ad72bee9 100644
--- a/test-data/unit/fixtures/callable.pyi
+++ b/test-data/unit/fixtures/callable.pyi
@@ -10,6 +10,8 @@ class type:
 
 class tuple(Generic[T]): pass
 
+class classmethod: pass
+class staticmethod: pass
 class function: pass
 
 def isinstance(x: object, t: Union[type, Tuple[type, ...]]) -> bool: pass
