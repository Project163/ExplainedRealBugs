diff --git a/mypy/checker.py b/mypy/checker.py
index fef85d085..2688a611b 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -1869,6 +1869,23 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
                 original_class_or_static = False  # a variable can't be class or static
 
             if isinstance(original_type, FunctionLike):
+                active_self_type = self.scope.active_self_type()
+                if isinstance(original_type, Overloaded) and active_self_type:
+                    # If we have an overload, filter to overloads that match the self type.
+                    # This avoids false positives for concrete subclasses of generic classes,
+                    # see testSelfTypeOverrideCompatibility for an example.
+                    # It's possible we might want to do this as part of bind_and_map_method
+                    filtered_items = [
+                        item
+                        for item in original_type.items
+                        if not item.arg_types or is_subtype(active_self_type, item.arg_types[0])
+                    ]
+                    # If we don't have any filtered_items, maybe it's always a valid override
+                    # of the superclass? However if you get to that point you're in murky type
+                    # territory anyway, so we just preserve the type and have the behaviour match
+                    # that of older versions of mypy.
+                    if filtered_items:
+                        original_type = Overloaded(filtered_items)
                 original_type = self.bind_and_map_method(base_attr, original_type, defn.info, base)
                 if original_node and is_property(original_node):
                     original_type = get_property_type(original_type)
diff --git a/test-data/unit/check-selftype.test b/test-data/unit/check-selftype.test
index bfb0eb5a4..3d801d23a 100644
--- a/test-data/unit/check-selftype.test
+++ b/test-data/unit/check-selftype.test
@@ -156,6 +156,92 @@ class B2(A[T]):
     def f(self: A[bytes]) -> bytes: ...
     def f(self): ...
 
+class C(A[int]):
+    def f(self) -> int: ...
+
+class D(A[str]):
+    def f(self) -> int: ...  # E: Signature of "f" incompatible with supertype "A" \
+                             # N:      Superclass:            \
+                             # N:          @overload          \
+                             # N:          def f(self) -> str \
+                             # N:      Subclass:              \
+                             # N:          def f(self) -> int
+
+class E(A[T]):
+    def f(self) -> int: ...  # E: Signature of "f" incompatible with supertype "A" \
+                             # N:      Superclass:            \
+                             # N:          @overload          \
+                             # N:          def f(self) -> int \
+                             # N:          @overload          \
+                             # N:          def f(self) -> str \
+                             # N:      Subclass:              \
+                             # N:          def f(self) -> int
+
+
+class F(A[bytes]):
+    # Note there's an argument to be made that this is actually compatible with the supertype
+    def f(self) -> bytes: ...  # E: Signature of "f" incompatible with supertype "A" \
+                               # N:      Superclass:            \
+                               # N:          @overload          \
+                               # N:          def f(self) -> int \
+                               # N:          @overload          \
+                               # N:          def f(self) -> str \
+                               # N:      Subclass:              \
+                               # N:          def f(self) -> bytes
+
+class G(A):
+    def f(self): ...
+
+class H(A[int]):
+    def f(self): ...
+
+class I(A[int]):
+    def f(*args): ...
+
+class J(A[int]):
+    def f(self, arg) -> int: ...  # E: Signature of "f" incompatible with supertype "A" \
+                                  # N:      Superclass:            \
+                                  # N:          @overload          \
+                                  # N:          def f(self) -> int \
+                                  # N:      Subclass:              \
+                                  # N:          def f(self, arg: Any) -> int
+
+[builtins fixtures/tuple.pyi]
+
+[case testSelfTypeOverrideCompatibilityTypeVar-xfail]
+from typing import overload, TypeVar, Union
+
+AT = TypeVar("AT", bound="A")
+
+class A:
+    @overload
+    def f(self: AT, x: int) -> AT: ...
+    @overload
+    def f(self, x: str) -> None: ...
+    @overload
+    def f(self: AT) -> bytes: ...
+    def f(*a, **kw): ...
+
+class B(A):
+    @overload  # E: Signature of "f" incompatible with supertype "A" \
+               # N:      Superclass:                                 \
+               # N:          @overload                               \
+               # N:          def f(self, x: int) -> B                \
+               # N:          @overload                               \
+               # N:          def f(self, x: str) -> None             \
+               # N:          @overload                               \
+               # N:          def f(self) -> bytes                    \
+               # N:      Subclass:                                   \
+               # N:          @overload                               \
+               # N:          def f(self, x: int) -> B                \
+               # N:          @overload                               \
+               # N:          def f(self, x: str) -> None
+    def f(self, x: int) -> B: ...
+    @overload
+    def f(self, x: str) -> None: ...
+    def f(*a, **kw): ...
+[builtins fixtures/dict.pyi]
+
 [case testSelfTypeSuper]
 from typing import TypeVar, cast
 
