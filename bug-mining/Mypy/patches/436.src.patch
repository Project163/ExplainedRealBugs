diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index 3532e18b9..2e8e6e2db 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -4341,7 +4341,7 @@ class ExpressionChecker(ExpressionVisitor[Type]):
         elif isinstance(left_type, FunctionLike) and left_type.is_type_obj():
             if left_type.type_object().is_enum:
                 return self.visit_enum_index_expr(left_type.type_object(), e.index, e)
-            elif left_type.type_object().type_vars:
+            elif left_type.type_object().type_vars and self.chk.options.python_version >= (3, 9):
                 return self.named_type("types.GenericAlias")
             elif (
                 left_type.type_object().fullname == "builtins.type"
diff --git a/test-data/unit/check-functions.test b/test-data/unit/check-functions.test
index 6c895c86e..ef5a66b6e 100644
--- a/test-data/unit/check-functions.test
+++ b/test-data/unit/check-functions.test
@@ -1779,6 +1779,7 @@ def Arg(x, y): pass
 F = Callable[[Arg(int, 'x')], int]  # E: Invalid argument constructor "__main__.Arg"
 
 [case testCallableParsingFromExpr]
+# flags: --python-version 3.9
 from typing import Callable, List
 from mypy_extensions import Arg, VarArg, KwArg
 import mypy_extensions
@@ -1799,10 +1800,23 @@ L = Callable[[Arg(name='x', type=int)], int] # ok
 # I have commented out the following test because I don't know how to expect the "defined here" note part of the error.
 # M = Callable[[Arg(gnome='x', type=int)], int]   E: Invalid type alias: expression is not a valid type   E: Unexpected keyword argument "gnome" for "Arg"
 N = Callable[[Arg(name=None, type=int)], int] # ok
-O = Callable[[List[Arg(int)]], int]  # E: Invalid type alias: expression is not a valid type  # E: Value of type "int" is not indexable  # E: Type expected within [...]
+O = Callable[[List[Arg(int)]], int]  # E: Invalid type alias: expression is not a valid type \
+                                     # E: Value of type "int" is not indexable \
+                                     # E: Type expected within [...]
 P = Callable[[mypy_extensions.VarArg(int)], int] # ok
-Q = Callable[[Arg(int, type=int)], int]  # E: Invalid type alias: expression is not a valid type  # E: Value of type "int" is not indexable  # E: "Arg" gets multiple values for keyword argument "type"
-R = Callable[[Arg(int, 'x', name='y')], int]  # E: Invalid type alias: expression is not a valid type  # E: Value of type "int" is not indexable  # E: "Arg" gets multiple values for keyword argument "name"
+Q = Callable[[Arg(int, type=int)], int]  # E: Invalid type alias: expression is not a valid type \
+                                         # E: Value of type "int" is not indexable \
+                                         # E: "Arg" gets multiple values for keyword argument "type"
+R = Callable[[Arg(int, 'x', name='y')], int]  # E: Invalid type alias: expression is not a valid type \
+                                              # E: Value of type "int" is not indexable \
+                                              # E: "Arg" gets multiple values for keyword argument "name"
+
+
+
+
+
+
+
 [builtins fixtures/dict.pyi]
 
 [case testCallableParsing]
