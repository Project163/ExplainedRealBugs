diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index b8f9bf087..3eb54579a 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -1502,7 +1502,7 @@ class ExpressionChecker(ExpressionVisitor[Type], ExpressionCheckerSharedApi):
     def check_union_call_expr(self, e: CallExpr, object_type: UnionType, member: str) -> Type:
         """Type check calling a member expression where the base type is a union."""
         res: list[Type] = []
-        for typ in object_type.relevant_items():
+        for typ in flatten_nested_unions(object_type.relevant_items()):
             # Member access errors are already reported when visiting the member expression.
             with self.msg.filter_errors():
                 item = analyze_member_access(
diff --git a/mypy/plugins/default.py b/mypy/plugins/default.py
index e492b8dd7..7a58307fc 100644
--- a/mypy/plugins/default.py
+++ b/mypy/plugins/default.py
@@ -5,7 +5,7 @@ from typing import Callable, Final
 
 import mypy.errorcodes as codes
 from mypy import message_registry
-from mypy.nodes import DictExpr, IntExpr, StrExpr, UnaryExpr
+from mypy.nodes import DictExpr, Expression, IntExpr, StrExpr, UnaryExpr
 from mypy.plugin import (
     AttributeContext,
     ClassDefContext,
@@ -263,30 +263,40 @@ def typed_dict_get_callback(ctx: MethodContext) -> Type:
         if keys is None:
             return ctx.default_return_type
 
+        default_type: Type
+        default_arg: Expression | None
+        if len(ctx.arg_types) <= 1 or not ctx.arg_types[1]:
+            default_arg = None
+            default_type = NoneType()
+        elif len(ctx.arg_types[1]) == 1 and len(ctx.args[1]) == 1:
+            default_arg = ctx.args[1][0]
+            default_type = ctx.arg_types[1][0]
+        else:
+            return ctx.default_return_type
+
         output_types: list[Type] = []
         for key in keys:
-            value_type = get_proper_type(ctx.type.items.get(key))
+            value_type: Type | None = ctx.type.items.get(key)
             if value_type is None:
                 return ctx.default_return_type
 
-            if len(ctx.arg_types) == 1:
+            if key in ctx.type.required_keys:
                 output_types.append(value_type)
-            elif len(ctx.arg_types) == 2 and len(ctx.arg_types[1]) == 1 and len(ctx.args[1]) == 1:
-                default_arg = ctx.args[1][0]
+            else:
+                # HACK to deal with get(key, {})
                 if (
                     isinstance(default_arg, DictExpr)
                     and len(default_arg.items) == 0
-                    and isinstance(value_type, TypedDictType)
+                    and isinstance(vt := get_proper_type(value_type), TypedDictType)
                 ):
-                    # Special case '{}' as the default for a typed dict type.
-                    output_types.append(value_type.copy_modified(required_keys=set()))
+                    output_types.append(vt.copy_modified(required_keys=set()))
                 else:
                     output_types.append(value_type)
-                    output_types.append(ctx.arg_types[1][0])
-
-        if len(ctx.arg_types) == 1:
-            output_types.append(NoneType())
+                    output_types.append(default_type)
 
+        # for nicer reveal_type, put default at the end, if it is present
+        if default_type in output_types:
+            output_types = [t for t in output_types if t != default_type] + [default_type]
         return make_simplified_union(output_types)
     return ctx.default_return_type
 
diff --git a/test-data/unit/check-incremental.test b/test-data/unit/check-incremental.test
index e91b8778e..94f65a950 100644
--- a/test-data/unit/check-incremental.test
+++ b/test-data/unit/check-incremental.test
@@ -7311,3 +7311,204 @@ x = 2
 [out]
 [rechecked bar]
 [stale]
+
+
+[case testIncrementalTypedDictGetMethodTotalFalse]
+import impl
+[file lib.py]
+from typing import TypedDict
+class Unrelated: pass
+D = TypedDict('D', {'x': int, 'y': str}, total=False)
+[file impl.py]
+pass
+[file impl.py.2]
+from typing import Literal
+from lib import D, Unrelated
+d: D
+u: Unrelated
+x: Literal['x']
+y: Literal['y']
+z: Literal['z']
+x_or_y: Literal['x', 'y']
+x_or_z: Literal['x', 'z']
+x_or_y_or_z: Literal['x', 'y', 'z']
+
+# test with literal expression
+reveal_type(d.get('x'))
+reveal_type(d.get('y'))
+reveal_type(d.get('z'))
+reveal_type(d.get('x', u))
+reveal_type(d.get('x', 1))
+reveal_type(d.get('y', None))
+
+# test with literal type / union of literal types with implicit default
+reveal_type(d.get(x))
+reveal_type(d.get(y))
+reveal_type(d.get(z))
+reveal_type(d.get(x_or_y))
+reveal_type(d.get(x_or_z))
+reveal_type(d.get(x_or_y_or_z))
+
+# test with literal type / union of literal types with explicit default
+reveal_type(d.get(x, u))
+reveal_type(d.get(y, u))
+reveal_type(d.get(z, u))
+reveal_type(d.get(x_or_y, u))
+reveal_type(d.get(x_or_z, u))
+reveal_type(d.get(x_or_y_or_z, u))
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+[out]
+[out2]
+tmp/impl.py:13: note: Revealed type is "Union[builtins.int, None]"
+tmp/impl.py:14: note: Revealed type is "Union[builtins.str, None]"
+tmp/impl.py:15: note: Revealed type is "builtins.object"
+tmp/impl.py:16: note: Revealed type is "Union[builtins.int, lib.Unrelated]"
+tmp/impl.py:17: note: Revealed type is "builtins.int"
+tmp/impl.py:18: note: Revealed type is "Union[builtins.str, None]"
+tmp/impl.py:21: note: Revealed type is "Union[builtins.int, None]"
+tmp/impl.py:22: note: Revealed type is "Union[builtins.str, None]"
+tmp/impl.py:23: note: Revealed type is "builtins.object"
+tmp/impl.py:24: note: Revealed type is "Union[builtins.int, builtins.str, None]"
+tmp/impl.py:25: note: Revealed type is "builtins.object"
+tmp/impl.py:26: note: Revealed type is "builtins.object"
+tmp/impl.py:29: note: Revealed type is "Union[builtins.int, lib.Unrelated]"
+tmp/impl.py:30: note: Revealed type is "Union[builtins.str, lib.Unrelated]"
+tmp/impl.py:31: note: Revealed type is "builtins.object"
+tmp/impl.py:32: note: Revealed type is "Union[builtins.int, builtins.str, lib.Unrelated]"
+tmp/impl.py:33: note: Revealed type is "builtins.object"
+tmp/impl.py:34: note: Revealed type is "builtins.object"
+
+[case testIncrementalTypedDictGetMethodTotalTrue]
+import impl
+[file lib.py]
+from typing import TypedDict
+class Unrelated: pass
+D = TypedDict('D', {'x': int, 'y': str}, total=True)
+[file impl.py]
+pass
+[file impl.py.2]
+from typing import Literal
+from lib import D, Unrelated
+d: D
+u: Unrelated
+x: Literal['x']
+y: Literal['y']
+z: Literal['z']
+x_or_y: Literal['x', 'y']
+x_or_z: Literal['x', 'z']
+x_or_y_or_z: Literal['x', 'y', 'z']
+
+# test with literal expression
+reveal_type(d.get('x'))
+reveal_type(d.get('y'))
+reveal_type(d.get('z'))
+reveal_type(d.get('x', u))
+reveal_type(d.get('x', 1))
+reveal_type(d.get('y', None))
+
+# test with literal type / union of literal types with implicit default
+reveal_type(d.get(x))
+reveal_type(d.get(y))
+reveal_type(d.get(z))
+reveal_type(d.get(x_or_y))
+reveal_type(d.get(x_or_z))
+reveal_type(d.get(x_or_y_or_z))
+
+# test with literal type / union of literal types with explicit default
+reveal_type(d.get(x, u))
+reveal_type(d.get(y, u))
+reveal_type(d.get(z, u))
+reveal_type(d.get(x_or_y, u))
+reveal_type(d.get(x_or_z, u))
+reveal_type(d.get(x_or_y_or_z, u))
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+[out]
+[out2]
+tmp/impl.py:13: note: Revealed type is "builtins.int"
+tmp/impl.py:14: note: Revealed type is "builtins.str"
+tmp/impl.py:15: note: Revealed type is "builtins.object"
+tmp/impl.py:16: note: Revealed type is "builtins.int"
+tmp/impl.py:17: note: Revealed type is "builtins.int"
+tmp/impl.py:18: note: Revealed type is "builtins.str"
+tmp/impl.py:21: note: Revealed type is "builtins.int"
+tmp/impl.py:22: note: Revealed type is "builtins.str"
+tmp/impl.py:23: note: Revealed type is "builtins.object"
+tmp/impl.py:24: note: Revealed type is "Union[builtins.int, builtins.str]"
+tmp/impl.py:25: note: Revealed type is "builtins.object"
+tmp/impl.py:26: note: Revealed type is "builtins.object"
+tmp/impl.py:29: note: Revealed type is "builtins.int"
+tmp/impl.py:30: note: Revealed type is "builtins.str"
+tmp/impl.py:31: note: Revealed type is "builtins.object"
+tmp/impl.py:32: note: Revealed type is "Union[builtins.int, builtins.str]"
+tmp/impl.py:33: note: Revealed type is "builtins.object"
+tmp/impl.py:34: note: Revealed type is "builtins.object"
+
+
+[case testIncrementalTypedDictGetMethodTotalMixed]
+import impl
+[file lib.py]
+from typing import TypedDict
+from typing_extensions import Required, NotRequired
+class Unrelated: pass
+D = TypedDict('D', {'x': Required[int], 'y': NotRequired[str]})
+[file impl.py]
+pass
+[file impl.py.2]
+from typing import Literal
+from lib import D, Unrelated
+d: D
+u: Unrelated
+x: Literal['x']
+y: Literal['y']
+z: Literal['z']
+x_or_y: Literal['x', 'y']
+x_or_z: Literal['x', 'z']
+x_or_y_or_z: Literal['x', 'y', 'z']
+
+# test with literal expression
+reveal_type(d.get('x'))
+reveal_type(d.get('y'))
+reveal_type(d.get('z'))
+reveal_type(d.get('x', u))
+reveal_type(d.get('x', 1))
+reveal_type(d.get('y', None))
+
+# test with literal type / union of literal types with implicit default
+reveal_type(d.get(x))
+reveal_type(d.get(y))
+reveal_type(d.get(z))
+reveal_type(d.get(x_or_y))
+reveal_type(d.get(x_or_z))
+reveal_type(d.get(x_or_y_or_z))
+
+# test with literal type / union of literal types with explicit default
+reveal_type(d.get(x, u))
+reveal_type(d.get(y, u))
+reveal_type(d.get(z, u))
+reveal_type(d.get(x_or_y, u))
+reveal_type(d.get(x_or_z, u))
+reveal_type(d.get(x_or_y_or_z, u))
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+[out]
+[out2]
+tmp/impl.py:13: note: Revealed type is "builtins.int"
+tmp/impl.py:14: note: Revealed type is "Union[builtins.str, None]"
+tmp/impl.py:15: note: Revealed type is "builtins.object"
+tmp/impl.py:16: note: Revealed type is "builtins.int"
+tmp/impl.py:17: note: Revealed type is "builtins.int"
+tmp/impl.py:18: note: Revealed type is "Union[builtins.str, None]"
+tmp/impl.py:21: note: Revealed type is "builtins.int"
+tmp/impl.py:22: note: Revealed type is "Union[builtins.str, None]"
+tmp/impl.py:23: note: Revealed type is "builtins.object"
+tmp/impl.py:24: note: Revealed type is "Union[builtins.int, builtins.str, None]"
+tmp/impl.py:25: note: Revealed type is "builtins.object"
+tmp/impl.py:26: note: Revealed type is "builtins.object"
+tmp/impl.py:29: note: Revealed type is "builtins.int"
+tmp/impl.py:30: note: Revealed type is "Union[builtins.str, lib.Unrelated]"
+tmp/impl.py:31: note: Revealed type is "builtins.object"
+tmp/impl.py:32: note: Revealed type is "Union[builtins.int, builtins.str, lib.Unrelated]"
+tmp/impl.py:33: note: Revealed type is "builtins.object"
+tmp/impl.py:34: note: Revealed type is "builtins.object"
diff --git a/test-data/unit/check-literal.test b/test-data/unit/check-literal.test
index 3c9290b8d..ce0ae2844 100644
--- a/test-data/unit/check-literal.test
+++ b/test-data/unit/check-literal.test
@@ -1884,7 +1884,7 @@ reveal_type(d[a_key])         # N: Revealed type is "builtins.int"
 reveal_type(d[b_key])         # N: Revealed type is "builtins.str"
 d[c_key]                      # E: TypedDict "Outer" has no key "c"
 
-reveal_type(d.get(a_key, u))  # N: Revealed type is "Union[builtins.int, __main__.Unrelated]"
+reveal_type(d.get(a_key, u))  # N: Revealed type is "builtins.int"
 reveal_type(d.get(b_key, u))  # N: Revealed type is "Union[builtins.str, __main__.Unrelated]"
 reveal_type(d.get(c_key, u))  # N: Revealed type is "builtins.object"
 
@@ -1928,7 +1928,7 @@ u: Unrelated
 reveal_type(a[int_key_good])         # N: Revealed type is "builtins.int"
 reveal_type(b[int_key_good])         # N: Revealed type is "builtins.int"
 reveal_type(c[str_key_good])         # N: Revealed type is "builtins.int"
-reveal_type(c.get(str_key_good, u))  # N: Revealed type is "Union[builtins.int, __main__.Unrelated]"
+reveal_type(c.get(str_key_good, u))  # N: Revealed type is "builtins.int"
 reveal_type(c.get(str_key_bad, u))   # N: Revealed type is "builtins.object"
 
 a[int_key_bad]                       # E: Tuple index out of range
@@ -1993,8 +1993,8 @@ optional_keys: Literal["d", "e"]
 bad_keys: Literal["a", "bad"]
 
 reveal_type(test[good_keys])                      # N: Revealed type is "Union[__main__.A, __main__.B]"
-reveal_type(test.get(good_keys))                  # N: Revealed type is "Union[__main__.A, __main__.B, None]"
-reveal_type(test.get(good_keys, 3))               # N: Revealed type is "Union[__main__.A, Literal[3]?, __main__.B]"
+reveal_type(test.get(good_keys))                  # N: Revealed type is "Union[__main__.A, __main__.B]"
+reveal_type(test.get(good_keys, 3))               # N: Revealed type is "Union[__main__.A, __main__.B]"
 reveal_type(test.pop(optional_keys))              # N: Revealed type is "Union[__main__.D, __main__.E]"
 reveal_type(test.pop(optional_keys, 3))           # N: Revealed type is "Union[__main__.D, __main__.E, Literal[3]?]"
 reveal_type(test.setdefault(good_keys, AAndB()))  # N: Revealed type is "Union[__main__.A, __main__.B]"
@@ -2037,15 +2037,18 @@ class D2(TypedDict):
     d: D
 
 x: Union[D1, D2]
-bad_keys: Literal['a', 'b', 'c', 'd']
 good_keys: Literal['b', 'c']
+mixed_keys: Literal['a', 'b', 'c', 'd']
+bad_keys: Literal['e', 'f']
 
-x[bad_keys]         # E: TypedDict "D1" has no key "d" \
+x[mixed_keys]         # E: TypedDict "D1" has no key "d" \
                     # E: TypedDict "D2" has no key "a"
 
 reveal_type(x[good_keys])           # N: Revealed type is "Union[__main__.B, __main__.C]"
-reveal_type(x.get(good_keys))       # N: Revealed type is "Union[__main__.B, __main__.C, None]"
-reveal_type(x.get(good_keys, 3))    # N: Revealed type is "Union[__main__.B, Literal[3]?, __main__.C]"
+reveal_type(x.get(good_keys))       # N: Revealed type is "Union[__main__.B, __main__.C]"
+reveal_type(x.get(good_keys, 3))    # N: Revealed type is "Union[__main__.B, __main__.C]"
+reveal_type(x.get(mixed_keys))      # N: Revealed type is "builtins.object"
+reveal_type(x.get(mixed_keys, 3))   # N: Revealed type is "builtins.object"
 reveal_type(x.get(bad_keys))        # N: Revealed type is "builtins.object"
 reveal_type(x.get(bad_keys, 3))     # N: Revealed type is "builtins.object"
 
diff --git a/test-data/unit/check-recursive-types.test b/test-data/unit/check-recursive-types.test
index 4f451aa06..c82111322 100644
--- a/test-data/unit/check-recursive-types.test
+++ b/test-data/unit/check-recursive-types.test
@@ -690,10 +690,11 @@ class TD(TypedDict, total=False):
     y: TD
 
 td: TD
+reveal_type(td.get("y"))  # N: Revealed type is "Union[TypedDict('__main__.TD', {'x'?: builtins.int, 'y'?: ...}), None]"
 td["y"] = {"x": 0, "y": {}}
 td["y"] = {"x": 0, "y": {"x": 0, "y": 42}}  # E: Incompatible types (expression has type "int", TypedDict item "y" has type "TD")
 
-reveal_type(td.get("y"))  # N: Revealed type is "Union[TypedDict('__main__.TD', {'x'?: builtins.int, 'y'?: TypedDict('__main__.TD', {'x'?: builtins.int, 'y'?: ...})}), None]"
+reveal_type(td.get("y"))  # N: Revealed type is "Union[TypedDict('__main__.TD', {'x'?: builtins.int, 'y'?: ...}), None]"
 s: str = td.get("y")  # E: Incompatible types in assignment (expression has type "Optional[TD]", variable has type "str")
 
 td.update({"x": 0, "y": {"x": 1, "y": {}}})
diff --git a/test-data/unit/check-typeddict.test b/test-data/unit/check-typeddict.test
index 34cae74d7..e1a70efe9 100644
--- a/test-data/unit/check-typeddict.test
+++ b/test-data/unit/check-typeddict.test
@@ -997,26 +997,149 @@ if int():
 
 -- Other TypedDict methods
 
-[case testTypedDictGetMethod]
+
+[case testTypedDictGetMethodOverloads]
 from typing import TypedDict
-class A: pass
-D = TypedDict('D', {'x': int, 'y': str})
+from typing_extensions import Required, NotRequired
+
+class D(TypedDict):
+    a: int
+    b: NotRequired[str]
+
+def test(d: D) -> None:
+    reveal_type(d.get)  # N: Revealed type is "Overload(def (k: builtins.str) -> builtins.object, def (builtins.str, builtins.object) -> builtins.object, def [V] (builtins.str, V`4) -> builtins.object)"
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+
+
+[case testTypedDictGetMethodTotalFalse]
+from typing import TypedDict, Literal
+class Unrelated: pass
+D = TypedDict('D', {'x': int, 'y': str}, total=False)
 d: D
+u: Unrelated
+x: Literal['x']
+y: Literal['y']
+z: Literal['z']
+x_or_y: Literal['x', 'y']
+x_or_z: Literal['x', 'z']
+x_or_y_or_z: Literal['x', 'y', 'z']
+
+# test with literal expression
 reveal_type(d.get('x')) # N: Revealed type is "Union[builtins.int, None]"
 reveal_type(d.get('y')) # N: Revealed type is "Union[builtins.str, None]"
-reveal_type(d.get('x', A())) # N: Revealed type is "Union[builtins.int, __main__.A]"
+reveal_type(d.get('z')) # N: Revealed type is "builtins.object"
+reveal_type(d.get('x', u)) # N: Revealed type is "Union[builtins.int, __main__.Unrelated]"
 reveal_type(d.get('x', 1)) # N: Revealed type is "builtins.int"
 reveal_type(d.get('y', None)) # N: Revealed type is "Union[builtins.str, None]"
+
+# test with literal type / union of literal types with implicit default
+reveal_type(d.get(x)) # N: Revealed type is "Union[builtins.int, None]"
+reveal_type(d.get(y)) # N: Revealed type is "Union[builtins.str, None]"
+reveal_type(d.get(z)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y)) # N: Revealed type is "Union[builtins.int, builtins.str, None]"
+reveal_type(d.get(x_or_z)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y_or_z)) # N: Revealed type is "builtins.object"
+
+# test with literal type / union of literal types with explicit default
+reveal_type(d.get(x, u)) # N: Revealed type is "Union[builtins.int, __main__.Unrelated]"
+reveal_type(d.get(y, u)) # N: Revealed type is "Union[builtins.str, __main__.Unrelated]"
+reveal_type(d.get(z, u)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y, u)) # N: Revealed type is "Union[builtins.int, builtins.str, __main__.Unrelated]"
+reveal_type(d.get(x_or_z, u)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y_or_z, u)) # N: Revealed type is "builtins.object"
 [builtins fixtures/dict.pyi]
 [typing fixtures/typing-typeddict.pyi]
 
+[case testTypedDictGetMethodTotalTrue]
+from typing import TypedDict, Literal
+class Unrelated: pass
+D = TypedDict('D', {'x': int, 'y': str}, total=True)
+d: D
+u: Unrelated
+x: Literal['x']
+y: Literal['y']
+z: Literal['z']
+x_or_y: Literal['x', 'y']
+x_or_z: Literal['x', 'z']
+x_or_y_or_z: Literal['x', 'y', 'z']
+
+# test with literal expression
+reveal_type(d.get('x')) # N: Revealed type is "builtins.int"
+reveal_type(d.get('y')) # N: Revealed type is "builtins.str"
+reveal_type(d.get('z')) # N: Revealed type is "builtins.object"
+reveal_type(d.get('x', u)) # N: Revealed type is "builtins.int"
+reveal_type(d.get('x', 1)) # N: Revealed type is "builtins.int"
+reveal_type(d.get('y', None)) # N: Revealed type is "builtins.str"
+
+# test with literal type / union of literal types with implicit default
+reveal_type(d.get(x)) # N: Revealed type is "builtins.int"
+reveal_type(d.get(y)) # N: Revealed type is "builtins.str"
+reveal_type(d.get(z)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y)) # N: Revealed type is "Union[builtins.int, builtins.str]"
+reveal_type(d.get(x_or_z)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y_or_z)) # N: Revealed type is "builtins.object"
+
+# test with literal type / union of literal types with explicit default
+reveal_type(d.get(x, u)) # N: Revealed type is "builtins.int"
+reveal_type(d.get(y, u)) # N: Revealed type is "builtins.str"
+reveal_type(d.get(z, u)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y, u)) # N: Revealed type is "Union[builtins.int, builtins.str]"
+reveal_type(d.get(x_or_z, u)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y_or_z, u)) # N: Revealed type is "builtins.object"
+
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+
+
+[case testTypedDictGetMethodTotalMixed]
+from typing import TypedDict, Literal
+from typing_extensions import Required, NotRequired
+class Unrelated: pass
+D = TypedDict('D', {'x': Required[int], 'y': NotRequired[str]})
+d: D
+u: Unrelated
+x: Literal['x']
+y: Literal['y']
+z: Literal['z']
+x_or_y: Literal['x', 'y']
+x_or_z: Literal['x', 'z']
+x_or_y_or_z: Literal['x', 'y', 'z']
+
+# test with literal expression
+reveal_type(d.get('x')) # N: Revealed type is "builtins.int"
+reveal_type(d.get('y')) # N: Revealed type is "Union[builtins.str, None]"
+reveal_type(d.get('z')) # N: Revealed type is "builtins.object"
+reveal_type(d.get('x', u)) # N: Revealed type is "builtins.int"
+reveal_type(d.get('x', 1)) # N: Revealed type is "builtins.int"
+reveal_type(d.get('y', None)) # N: Revealed type is "Union[builtins.str, None]"
+
+# test with literal type / union of literal types with implicit default
+reveal_type(d.get(x)) # N: Revealed type is "builtins.int"
+reveal_type(d.get(y)) # N: Revealed type is "Union[builtins.str, None]"
+reveal_type(d.get(z)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y)) # N: Revealed type is "Union[builtins.int, builtins.str, None]"
+reveal_type(d.get(x_or_z)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y_or_z)) # N: Revealed type is "builtins.object"
+
+# test with literal type / union of literal types with explicit default
+reveal_type(d.get(x, u)) # N: Revealed type is "builtins.int"
+reveal_type(d.get(y, u)) # N: Revealed type is "Union[builtins.str, __main__.Unrelated]"
+reveal_type(d.get(z, u)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y, u)) # N: Revealed type is "Union[builtins.int, builtins.str, __main__.Unrelated]"
+reveal_type(d.get(x_or_z, u)) # N: Revealed type is "builtins.object"
+reveal_type(d.get(x_or_y_or_z, u)) # N: Revealed type is "builtins.object"
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+
+
 [case testTypedDictGetMethodTypeContext]
 from typing import List, TypedDict
 class A: pass
-D = TypedDict('D', {'x': List[int], 'y': int})
+D = TypedDict('D', {'x': List[int], 'y': int}, total=False)
 d: D
 reveal_type(d.get('x', [])) # N: Revealed type is "builtins.list[builtins.int]"
-d.get('x', ['x']) # E: List item 0 has incompatible type "str"; expected "int"
+reveal_type(d.get('x', ['x']))  # N: Revealed type is "Union[builtins.list[builtins.int], builtins.list[builtins.str]]"
 a = ['']
 reveal_type(d.get('x', a)) # N: Revealed type is "Union[builtins.list[builtins.int], builtins.list[builtins.str]]"
 [builtins fixtures/dict.pyi]
@@ -1029,11 +1152,13 @@ d: D
 d.get() # E: All overload variants of "get" of "Mapping" require at least one argument \
         # N: Possible overload variants: \
         # N:     def get(self, k: str) -> object \
-        # N:     def [V] get(self, k: str, default: object) -> object
+        # N:     def get(self, str, object, /) -> object \
+        # N:     def [V] get(self, str, V, /) -> object
 d.get('x', 1, 2) # E: No overload variant of "get" of "Mapping" matches argument types "str", "int", "int" \
                  # N: Possible overload variants: \
                  # N:     def get(self, k: str) -> object \
-                 # N:     def [V] get(self, k: str, default: Union[int, V]) -> object
+                 # N:     def get(self, str, object, /) -> object \
+                 # N:     def [V] get(self, str, Union[int, V], /) -> object
 x = d.get('z')
 reveal_type(x) # N: Revealed type is "builtins.object"
 s = ''
@@ -1069,19 +1194,134 @@ p.get('x', 1 + 'y')     # E: Unsupported operand types for + ("int" and "str")
 
 [case testTypedDictChainedGetWithEmptyDictDefault]
 from typing import TypedDict
-C = TypedDict('C', {'a': int})
-D = TypedDict('D', {'x': C, 'y': str})
+C = TypedDict('C', {'a': int}, total=True)
+D = TypedDict('D', {'x': C, 'y': str}, total=False)
 d: D
-reveal_type(d.get('x', {})) \
-    # N: Revealed type is "TypedDict('__main__.C', {'a'?: builtins.int})"
-reveal_type(d.get('x', None)) \
-    # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), None]"
+reveal_type(d.get('x', {})) # N: Revealed type is "TypedDict('__main__.C', {'a'?: builtins.int})"
+reveal_type(d.get('x', None)) # N: Revealed type is "Union[TypedDict('__main__.C', {'a': builtins.int}), None]"
 reveal_type(d.get('x', {}).get('a')) # N: Revealed type is "Union[builtins.int, None]"
 reveal_type(d.get('x', {})['a']) # N: Revealed type is "builtins.int"
 [builtins fixtures/dict.pyi]
 [typing fixtures/typing-typeddict.pyi]
 
 
+[case testTypedDictChainedGetWithEmptyDictDefault2]
+from typing import TypedDict
+C = TypedDict('C', {'a': int}, total=False)
+D = TypedDict('D', {'x': C, 'y': str}, total=True)
+d: D
+reveal_type(d.get('x', {}))  # N: Revealed type is "TypedDict('__main__.C', {'a'?: builtins.int})"
+reveal_type(d.get('x', None))  # N: Revealed type is "TypedDict('__main__.C', {'a'?: builtins.int})"
+reveal_type(d.get('x', {}).get('a')) # N: Revealed type is "Union[builtins.int, None]"
+reveal_type(d.get('x', {})['a']) # N: Revealed type is "builtins.int"
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+
+
+[case testTypedDictChainedGetWithEmptyDictDefault3]
+from typing import TypedDict
+C = TypedDict('C', {'a': int}, total=True)
+D = TypedDict('D', {'x': C, 'y': str}, total=True)
+d: D
+reveal_type(d.get('x', {}))  # N: Revealed type is "TypedDict('__main__.C', {'a': builtins.int})"
+reveal_type(d.get('x', None))  # N: Revealed type is "TypedDict('__main__.C', {'a': builtins.int})"
+reveal_type(d.get('x', {}).get('a')) # N: Revealed type is "builtins.int"
+reveal_type(d.get('x', {})['a']) # N: Revealed type is "builtins.int"
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+
+
+[case testTypedDictChainedGetWithEmptyDictDefault4]
+from typing import TypedDict
+C = TypedDict('C', {'a': int}, total=False)
+D = TypedDict('D', {'x': C, 'y': str}, total=False)
+d: D
+reveal_type(d.get('x', {}))  # N: Revealed type is "TypedDict('__main__.C', {'a'?: builtins.int})"
+reveal_type(d.get('x', None))  # N: Revealed type is "Union[TypedDict('__main__.C', {'a'?: builtins.int}), None]"
+reveal_type(d.get('x', {}).get('a')) # N: Revealed type is "Union[builtins.int, None]"
+reveal_type(d.get('x', {})['a']) # N: Revealed type is "builtins.int"
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+
+
+[case testTypedDictGetMethodChained]
+# check that chaining with get like ``.get(key, {}).get(subkey, {})`` works.
+from typing import TypedDict, Mapping
+from typing_extensions import Required, NotRequired, Never
+
+class Total(TypedDict, total=True):  # no keys optional
+    key_one: int
+    key_two: str
+
+class Maybe(TypedDict, total=False):  # all keys are optional
+    key_one: int
+    key_two: str
+
+class Mixed(TypedDict):  # some keys optional
+    key_one: Required[int]
+    key_two: NotRequired[str]
+
+class Config(TypedDict):
+    required_total: Required[Total]
+    optional_total: NotRequired[Total]
+    required_mixed: Required[Mixed]
+    optional_mixed: NotRequired[Mixed]
+    required_maybe: Required[Maybe]
+    optional_maybe: NotRequired[Maybe]
+
+def test_chaining(d: Config) -> None:
+    reveal_type( d.get("required_total", {}) ) # N: Revealed type is "TypedDict('__main__.Total', {'key_one': builtins.int, 'key_two': builtins.str})"
+    reveal_type( d.get("optional_total", {}) ) # N: Revealed type is "TypedDict('__main__.Total', {'key_one'?: builtins.int, 'key_two'?: builtins.str})"
+    reveal_type( d.get("required_maybe", {}) ) # N: Revealed type is "TypedDict('__main__.Maybe', {'key_one'?: builtins.int, 'key_two'?: builtins.str})"
+    reveal_type( d.get("optional_maybe", {}) ) # N: Revealed type is "TypedDict('__main__.Maybe', {'key_one'?: builtins.int, 'key_two'?: builtins.str})"
+    reveal_type( d.get("required_mixed", {}) ) # N: Revealed type is "TypedDict('__main__.Mixed', {'key_one': builtins.int, 'key_two'?: builtins.str})"
+    reveal_type( d.get("optional_mixed", {}) ) # N: Revealed type is "TypedDict('__main__.Mixed', {'key_one'?: builtins.int, 'key_two'?: builtins.str})"
+
+    reveal_type( d.get("required_total", {}).get("key_one")  )  # N: Revealed type is "builtins.int"
+    reveal_type( d.get("required_total", {}).get("key_two")  )  # N: Revealed type is "builtins.str"
+    reveal_type( d.get("required_total", {}).get("bad_key")  )  # N: Revealed type is "builtins.object"
+    reveal_type( d.get("optional_total", {}).get("key_one")  )  # N: Revealed type is "Union[builtins.int, None]"
+    reveal_type( d.get("optional_total", {}).get("key_two")  )  # N: Revealed type is "Union[builtins.str, None]"
+    reveal_type( d.get("optional_total", {}).get("bad_key")  )  # N: Revealed type is "builtins.object"
+
+    reveal_type( d.get("required_maybe", {}).get("key_one")  )  # N: Revealed type is "Union[builtins.int, None]"
+    reveal_type( d.get("required_maybe", {}).get("key_two")  )  # N: Revealed type is "Union[builtins.str, None]"
+    reveal_type( d.get("required_maybe", {}).get("bad_key")  )  # N: Revealed type is "builtins.object"
+    reveal_type( d.get("optional_maybe", {}).get("key_one")  )  # N: Revealed type is "Union[builtins.int, None]"
+    reveal_type( d.get("optional_maybe", {}).get("key_two")  )  # N: Revealed type is "Union[builtins.str, None]"
+    reveal_type( d.get("optional_maybe", {}).get("bad_key")  )  # N: Revealed type is "builtins.object"
+
+    reveal_type( d.get("required_mixed", {}).get("key_one")  )  # N: Revealed type is "builtins.int"
+    reveal_type( d.get("required_mixed", {}).get("key_two")  )  # N: Revealed type is "Union[builtins.str, None]"
+    reveal_type( d.get("required_mixed", {}).get("bad_key")  )  # N: Revealed type is "builtins.object"
+    reveal_type( d.get("optional_mixed", {}).get("key_one")  )  # N: Revealed type is "Union[builtins.int, None]"
+    reveal_type( d.get("optional_mixed", {}).get("key_two")  )  # N: Revealed type is "Union[builtins.str, None]"
+    reveal_type( d.get("optional_mixed", {}).get("bad_key")  )  # N: Revealed type is "builtins.object"
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+
+
+[case testTypedDictGetWithNestedUnionOfTypedDicts]
+# https://github.com/python/mypy/issues/19902
+from typing import TypedDict, Union
+from typing_extensions import TypeAlias, NotRequired
+class A(TypedDict):
+    key: NotRequired[int]
+
+class B(TypedDict):
+    key: NotRequired[int]
+
+class C(TypedDict):
+    key: NotRequired[int]
+
+A_or_B: TypeAlias = Union[A, B]
+A_or_B_or_C: TypeAlias = Union[A_or_B, C]
+
+def test(d: A_or_B_or_C) -> None:
+    reveal_type(d.get("key"))  # N: Revealed type is "Union[builtins.int, None]"
+[builtins fixtures/dict.pyi]
+[typing fixtures/typing-typeddict.pyi]
+
 -- Totality (the "total" keyword argument)
 
 [case testTypedDictWithTotalTrue]
@@ -1769,8 +2009,8 @@ class TDB(TypedDict):
 
 td: Union[TDA, TDB]
 
-reveal_type(td.get('a'))  # N: Revealed type is "Union[builtins.int, None]"
-reveal_type(td.get('b'))  # N: Revealed type is "Union[builtins.str, None, builtins.int]"
+reveal_type(td.get('a'))  # N: Revealed type is "builtins.int"
+reveal_type(td.get('b'))  # N: Revealed type is "Union[builtins.str, builtins.int]"
 reveal_type(td.get('c'))  # N: Revealed type is "builtins.object"
 
 reveal_type(td['a'])  # N: Revealed type is "builtins.int"
diff --git a/test-data/unit/fixtures/typing-typeddict.pyi b/test-data/unit/fixtures/typing-typeddict.pyi
index 16658c825..29635b651 100644
--- a/test-data/unit/fixtures/typing-typeddict.pyi
+++ b/test-data/unit/fixtures/typing-typeddict.pyi
@@ -56,7 +56,9 @@ class Mapping(Iterable[T], Generic[T, T_co], metaclass=ABCMeta):
     @overload
     def get(self, k: T) -> Optional[T_co]: pass
     @overload
-    def get(self, k: T, default: Union[T_co, V]) -> Union[T_co, V]: pass
+    def get(self, k: T, default: T_co, /) -> Optional[T_co]: pass  # type: ignore[misc]
+    @overload
+    def get(self, k: T, default: V, /) -> Union[T_co, V]: pass
     def values(self) -> Iterable[T_co]: pass  # Approximate return type
     def __len__(self) -> int: ...
     def __contains__(self, arg: object) -> int: pass
diff --git a/test-data/unit/pythoneval.test b/test-data/unit/pythoneval.test
index 93b67bfa8..2069d082d 100644
--- a/test-data/unit/pythoneval.test
+++ b/test-data/unit/pythoneval.test
@@ -1034,24 +1034,43 @@ _program.py:17: note: Revealed type is "builtins.str"
 # Test that TypedDict get plugin works with typeshed stubs
 from typing import TypedDict
 class A: pass
-D = TypedDict('D', {'x': int, 'y': str})
-d: D
-reveal_type(d.get('x'))
-reveal_type(d.get('y'))
-reveal_type(d.get('z'))
-d.get()
-s = ''
-reveal_type(d.get(s))
-[out]
-_testTypedDictGet.py:6: note: Revealed type is "Union[builtins.int, None]"
-_testTypedDictGet.py:7: note: Revealed type is "Union[builtins.str, None]"
-_testTypedDictGet.py:8: note: Revealed type is "builtins.object"
-_testTypedDictGet.py:9: error: All overload variants of "get" of "Mapping" require at least one argument
-_testTypedDictGet.py:9: note: Possible overload variants:
-_testTypedDictGet.py:9: note:     def get(self, str, /) -> object
-_testTypedDictGet.py:9: note:     def get(self, str, /, default: object) -> object
-_testTypedDictGet.py:9: note:     def [_T] get(self, str, /, default: _T) -> object
-_testTypedDictGet.py:11: note: Revealed type is "builtins.object"
+D_total = TypedDict('D_total', {'x': int, 'y': str}, total=True)
+D_not_total = TypedDict('D_not_total', {'x': int, 'y': str}, total=False)
+
+def test_total(d: D_total) -> None:
+    reveal_type(d.get('x'))
+    reveal_type(d.get('y'))
+    reveal_type(d.get('z'))
+    d.get()
+    s = ''
+    reveal_type(d.get(s))
+
+def test_not_total(d: D_not_total) -> None:
+    reveal_type(d.get('x'))
+    reveal_type(d.get('y'))
+    reveal_type(d.get('z'))
+    d.get()
+    s = ''
+    reveal_type(d.get(s))
+[out]
+_testTypedDictGet.py:8: note: Revealed type is "builtins.int"
+_testTypedDictGet.py:9: note: Revealed type is "builtins.str"
+_testTypedDictGet.py:10: note: Revealed type is "builtins.object"
+_testTypedDictGet.py:11: error: All overload variants of "get" of "Mapping" require at least one argument
+_testTypedDictGet.py:11: note: Possible overload variants:
+_testTypedDictGet.py:11: note:     def get(self, str, /) -> object
+_testTypedDictGet.py:11: note:     def get(self, str, /, default: object) -> object
+_testTypedDictGet.py:11: note:     def [_T] get(self, str, /, default: _T) -> object
+_testTypedDictGet.py:13: note: Revealed type is "builtins.object"
+_testTypedDictGet.py:16: note: Revealed type is "Union[builtins.int, None]"
+_testTypedDictGet.py:17: note: Revealed type is "Union[builtins.str, None]"
+_testTypedDictGet.py:18: note: Revealed type is "builtins.object"
+_testTypedDictGet.py:19: error: All overload variants of "get" of "Mapping" require at least one argument
+_testTypedDictGet.py:19: note: Possible overload variants:
+_testTypedDictGet.py:19: note:     def get(self, str, /) -> object
+_testTypedDictGet.py:19: note:     def get(self, str, /, default: object) -> object
+_testTypedDictGet.py:19: note:     def [_T] get(self, str, /, default: _T) -> object
+_testTypedDictGet.py:21: note: Revealed type is "builtins.object"
 
 [case testTypedDictMappingMethods]
 from typing import TypedDict
