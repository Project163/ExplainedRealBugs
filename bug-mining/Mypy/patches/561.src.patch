diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index d59c20c46..ba2d38b6f 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -4096,7 +4096,7 @@ class ExpressionChecker(ExpressionVisitor[Type], ExpressionCheckerSharedApi):
         results = []
         for name, method, obj, arg in variants:
             with self.msg.filter_errors(save_filtered_errors=True) as local_errors:
-                result = self.check_method_call(op_name, obj, method, [arg], [ARG_POS], context)
+                result = self.check_method_call(name, obj, method, [arg], [ARG_POS], context)
             if local_errors.has_new_errors():
                 errors.append(local_errors.filtered_errors())
                 results.append(result)
diff --git a/test-data/unit/check-custom-plugin.test b/test-data/unit/check-custom-plugin.test
index feb135bee..72b60c874 100644
--- a/test-data/unit/check-custom-plugin.test
+++ b/test-data/unit/check-custom-plugin.test
@@ -1110,3 +1110,19 @@ plugins = """
   <ROOT>/test-data/unit/plugins/method_in_decorator.py,
 """
 [out]
+
+
+
+[case magicMethodReverse]
+# flags: --config-file tmp/mypy.ini
+from typing import Literal
+
+op1: Literal[3] = 3
+op2: Literal[4] = 4
+c = op1 + op2
+reveal_type(c) # N: Revealed type is "Literal[7]"
+
+[file mypy.ini]
+\[mypy]
+plugins=<ROOT>/test-data/unit/plugins/magic_method.py
+[builtins fixtures/ops.pyi]
diff --git a/test-data/unit/plugins/magic_method.py b/test-data/unit/plugins/magic_method.py
new file mode 100644
index 000000000..fc220ab44
--- /dev/null
+++ b/test-data/unit/plugins/magic_method.py
@@ -0,0 +1,24 @@
+from mypy.types import LiteralType, AnyType, TypeOfAny, Type
+from mypy.plugin import Plugin, MethodContext
+from typing import Callable, Optional
+
+# If radd exists, there shouldn't be an error. If it doesn't exist, then there will be an error
+def type_add(ctx: MethodContext) -> Type:
+    ctx.api.fail("fail", ctx.context)
+    return AnyType(TypeOfAny.from_error)
+
+def type_radd(ctx: MethodContext) -> Type:
+    return LiteralType(7, fallback=ctx.api.named_generic_type('builtins.int', []))
+
+
+class TestPlugin(Plugin):
+
+    def get_method_hook(self, fullname: str) -> Optional[Callable[[MethodContext], Type]]:
+        if fullname == 'builtins.int.__add__':
+            return type_add
+        if fullname == 'builtins.int.__radd__':
+            return type_radd
+        return None
+
+def plugin(version: str) -> type[TestPlugin]:
+    return TestPlugin
