diff --git a/mypy/checker.py b/mypy/checker.py
index e05523a1a..70d3add74 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -2933,23 +2933,14 @@ class TypeChecker(NodeVisitor[None], TypeCheckerSharedApi):
         ):
             return  # Reasonable exceptions from this check
 
-        metaclasses = [
-            entry.metaclass_type
-            for entry in typ.mro[1:-1]
-            if entry.metaclass_type
-            and not is_named_instance(entry.metaclass_type, "builtins.type")
-        ]
-        if not metaclasses:
-            return
-        if typ.metaclass_type is not None and all(
-            is_subtype(typ.metaclass_type, meta) for meta in metaclasses
+        if typ.metaclass_type is None and any(
+            base.type.metaclass_type is not None for base in typ.bases
         ):
-            return
-        self.fail(
-            "Metaclass conflict: the metaclass of a derived class must be "
-            "a (non-strict) subclass of the metaclasses of all its bases",
-            typ,
-        )
+            self.fail(
+                "Metaclass conflict: the metaclass of a derived class must be "
+                "a (non-strict) subclass of the metaclasses of all its bases",
+                typ,
+            )
 
     def visit_import_from(self, node: ImportFrom) -> None:
         for name, _ in node.names:
diff --git a/mypy/nodes.py b/mypy/nodes.py
index 1b6884f04..d69ff1034 100644
--- a/mypy/nodes.py
+++ b/mypy/nodes.py
@@ -3382,15 +3382,25 @@ class TypeInfo(SymbolNode):
             return declared
         if self._fullname == "builtins.type":
             return mypy.types.Instance(self, [])
-        candidates = [
-            s.declared_metaclass
-            for s in self.mro
-            if s.declared_metaclass is not None and s.declared_metaclass.type is not None
-        ]
-        for c in candidates:
-            if all(other.type in c.type.mro for other in candidates):
-                return c
-        return None
+
+        winner = declared
+        for super_class in self.mro[1:]:
+            super_meta = super_class.declared_metaclass
+            if super_meta is None or super_meta.type is None:
+                continue
+            if winner is None:
+                winner = super_meta
+                continue
+            if winner.type.has_base(super_meta.type.fullname):
+                continue
+            if super_meta.type.has_base(winner.type.fullname):
+                winner = super_meta
+                continue
+            # metaclass conflict
+            winner = None
+            break
+
+        return winner
 
     def is_metaclass(self, *, precise: bool = False) -> bool:
         return (
diff --git a/test-data/unit/check-abstract.test b/test-data/unit/check-abstract.test
index 2fed3425c..7507a31d1 100644
--- a/test-data/unit/check-abstract.test
+++ b/test-data/unit/check-abstract.test
@@ -571,8 +571,12 @@ from abc import abstractmethod, ABCMeta
 import typing
 
 class A(metaclass=ABCMeta): pass
-class B(object, A): pass \
-      # E: Cannot determine consistent method resolution order (MRO) for "B"
+class B(object, A, metaclass=ABCMeta): # E: Cannot determine consistent method resolution order (MRO) for "B"
+    pass
+
+class C(object, A):  # E: Cannot determine consistent method resolution order (MRO) for "C" \
+                     # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+    pass
 
 [case testOverloadedAbstractMethod]
 from foo import *
diff --git a/test-data/unit/check-classes.test b/test-data/unit/check-classes.test
index 1b3de5356..7d2032ef2 100644
--- a/test-data/unit/check-classes.test
+++ b/test-data/unit/check-classes.test
@@ -7292,7 +7292,7 @@ class Conflict1(A1, B, E): ...  # E: Metaclass conflict: the metaclass of a deri
 class Conflict2(A, B): ...  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
 class Conflict3(B, A): ...  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
 
-class ChildOfConflict1(Conflict3): ...  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+class ChildOfConflict1(Conflict3): ...
 class ChildOfConflict2(Conflict3, metaclass=CorrectMeta): ...
 
 class ConflictingMeta(MyMeta1, MyMeta3): ...
@@ -7301,6 +7301,37 @@ class Conflict4(A1, B, E, metaclass=ConflictingMeta): ...  # E: Metaclass confli
 class ChildOfCorrectButWrongMeta(CorrectSubclass1, metaclass=ConflictingMeta):  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
     ...
 
+[case testMetaClassConflictIssue14033]
+class M1(type): pass
+class M2(type): pass
+class Mx(M1, M2): pass
+
+class A1(metaclass=M1): pass
+class A2(A1): pass
+
+class B1(metaclass=M2): pass
+
+class C1(metaclass=Mx): pass
+
+class TestABC(A2, B1, C1): pass  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+class TestBAC(B1, A2, C1): pass  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+
+# should not warn again for children
+class ChildOfTestABC(TestABC): pass
+
+# no metaclass is assumed if super class has a metaclass conflict
+class ChildOfTestABCMetaMx(TestABC, metaclass=Mx): pass
+class ChildOfTestABCMetaM1(TestABC, metaclass=M1): pass
+
+class TestABCMx(A2, B1, C1, metaclass=Mx): pass
+class TestBACMx(B1, A2, C1, metaclass=Mx): pass
+
+class TestACB(A2, C1, B1): pass
+class TestBCA(B1, C1, A2): pass
+
+class TestCAB(C1, A2, B1): pass
+class TestCBA(C1, B1, A2): pass
+
 [case testGenericOverride]
 from typing import Generic, TypeVar, Any
 
