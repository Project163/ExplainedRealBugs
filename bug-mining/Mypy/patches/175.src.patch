diff --git a/mypy/binder.py b/mypy/binder.py
index 8e49f87c2..01373e19d 100644
--- a/mypy/binder.py
+++ b/mypy/binder.py
@@ -8,9 +8,28 @@ from typing_extensions import TypeAlias as _TypeAlias
 from mypy.erasetype import remove_instance_last_known_values
 from mypy.join import join_simple
 from mypy.literals import Key, literal, literal_hash, subkeys
-from mypy.nodes import AssignmentExpr, Expression, IndexExpr, MemberExpr, NameExpr, RefExpr, Var
+from mypy.nodes import (
+    AssignmentExpr,
+    Expression,
+    IndexExpr,
+    MemberExpr,
+    NameExpr,
+    RefExpr,
+    TypeInfo,
+    Var,
+)
 from mypy.subtypes import is_same_type, is_subtype
-from mypy.types import AnyType, NoneType, PartialType, Type, TypeOfAny, UnionType, get_proper_type
+from mypy.types import (
+    AnyType,
+    NoneType,
+    PartialType,
+    Type,
+    TypeOfAny,
+    TypeType,
+    UnionType,
+    get_proper_type,
+)
+from mypy.typevars import fill_typevars_with_any
 
 BindableExpression: _TypeAlias = Union[IndexExpr, MemberExpr, AssignmentExpr, NameExpr]
 
@@ -439,8 +458,11 @@ class ConditionalTypeBinder:
 
 
 def get_declaration(expr: BindableExpression) -> Type | None:
-    if isinstance(expr, RefExpr) and isinstance(expr.node, Var):
-        type = expr.node.type
-        if not isinstance(get_proper_type(type), PartialType):
-            return type
+    if isinstance(expr, RefExpr):
+        if isinstance(expr.node, Var):
+            type = expr.node.type
+            if not isinstance(get_proper_type(type), PartialType):
+                return type
+        elif isinstance(expr.node, TypeInfo):
+            return TypeType(fill_typevars_with_any(expr.node))
     return None
diff --git a/test-data/unit/check-statements.test b/test-data/unit/check-statements.test
index 9768f43d0..c26e96720 100644
--- a/test-data/unit/check-statements.test
+++ b/test-data/unit/check-statements.test
@@ -1073,6 +1073,10 @@ a = A()
 del a.x, a.y # E: "A" has no attribute "y"
 [builtins fixtures/tuple.pyi]
 
+[case testDelStmtWithTypeInfo]
+class Foo: ...
+del Foo
+Foo + 1  # E: Trying to read deleted variable "Foo"
 
 [case testDelStatementWithAssignmentSimple]
 a = 1
