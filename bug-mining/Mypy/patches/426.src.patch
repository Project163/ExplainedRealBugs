diff --git a/mypy/checkmember.py b/mypy/checkmember.py
index 5824b00a3..fa847de2e 100644
--- a/mypy/checkmember.py
+++ b/mypy/checkmember.py
@@ -654,7 +654,7 @@ def analyze_descriptor_access(descriptor_type: Type, mx: MemberContext) -> Type:
                 analyze_descriptor_access(
                     descriptor_type, mx.copy_modified(original_type=original_type)
                 )
-                for original_type in instance_type.items
+                for original_type in instance_type.relevant_items()
             ]
         )
     elif not isinstance(descriptor_type, Instance):
diff --git a/test-data/unit/check-unions.test b/test-data/unit/check-unions.test
index 2e69a96f0..2ca2f1ba9 100644
--- a/test-data/unit/check-unions.test
+++ b/test-data/unit/check-unions.test
@@ -1258,3 +1258,34 @@ reveal_type(mix)  # N: Revealed type is "Union[Type[__main__.A], Type[__main__.B
 reveal_type(mix.field_1)  # N: Revealed type is "builtins.list[builtins.int]"
 reveal_type(mix().field_1)  # N: Revealed type is "builtins.int"
 [builtins fixtures/list.pyi]
+
+
+[case testDescriptorAccessForUnionOfTypesWithNoStrictOptional]
+# mypy: no-strict-optional
+from typing import overload, Generic, Any, TypeVar, List, Optional, Union, Type
+
+class Descriptor:
+    @overload
+    def __get__(
+        self, instance: None, owner: type
+    ) -> str:
+        ...
+
+    @overload
+    def __get__(self, instance: object, owner: type) -> int:
+        ...
+
+    def __get__(
+        self, instance: Optional[object], owner: type
+    ) -> Union[str, int]:
+        ...
+
+class A:
+    field = Descriptor()
+
+a_class_or_none: Optional[Type[A]]
+x: str = a_class_or_none.field
+
+a_or_none: Optional[A]
+y: int = a_or_none.field
+[builtins fixtures/list.pyi]
