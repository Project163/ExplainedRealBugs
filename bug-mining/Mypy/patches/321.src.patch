diff --git a/mypy/applytype.py b/mypy/applytype.py
index bc6ec088b..bbd59d8cf 100644
--- a/mypy/applytype.py
+++ b/mypy/applytype.py
@@ -75,7 +75,6 @@ def apply_generic_arguments(
     report_incompatible_typevar_value: Callable[[CallableType, Type, str, Context], None],
     context: Context,
     skip_unsatisfied: bool = False,
-    allow_erased_callables: bool = False,
 ) -> CallableType:
     """Apply generic type arguments to a callable type.
 
@@ -119,15 +118,9 @@ def apply_generic_arguments(
         star_index = callable.arg_kinds.index(ARG_STAR)
         callable = callable.copy_modified(
             arg_types=(
-                [
-                    expand_type(at, id_to_type, allow_erased_callables)
-                    for at in callable.arg_types[:star_index]
-                ]
+                [expand_type(at, id_to_type) for at in callable.arg_types[:star_index]]
                 + [callable.arg_types[star_index]]
-                + [
-                    expand_type(at, id_to_type, allow_erased_callables)
-                    for at in callable.arg_types[star_index + 1 :]
-                ]
+                + [expand_type(at, id_to_type) for at in callable.arg_types[star_index + 1 :]]
             )
         )
 
@@ -163,14 +156,12 @@ def apply_generic_arguments(
             assert False, "mypy bug: unhandled case applying unpack"
     else:
         callable = callable.copy_modified(
-            arg_types=[
-                expand_type(at, id_to_type, allow_erased_callables) for at in callable.arg_types
-            ]
+            arg_types=[expand_type(at, id_to_type) for at in callable.arg_types]
         )
 
     # Apply arguments to TypeGuard if any.
     if callable.type_guard is not None:
-        type_guard = expand_type(callable.type_guard, id_to_type, allow_erased_callables)
+        type_guard = expand_type(callable.type_guard, id_to_type)
     else:
         type_guard = None
 
@@ -178,7 +169,7 @@ def apply_generic_arguments(
     remaining_tvars = [tv for tv in tvars if tv.id not in id_to_type]
 
     return callable.copy_modified(
-        ret_type=expand_type(callable.ret_type, id_to_type, allow_erased_callables),
+        ret_type=expand_type(callable.ret_type, id_to_type),
         variables=remaining_tvars,
         type_guard=type_guard,
     )
diff --git a/mypy/expandtype.py b/mypy/expandtype.py
index 21c3a5926..fed38b27b 100644
--- a/mypy/expandtype.py
+++ b/mypy/expandtype.py
@@ -48,33 +48,25 @@ from mypy.typevartuples import (
 
 
 @overload
-def expand_type(
-    typ: CallableType, env: Mapping[TypeVarId, Type], allow_erased_callables: bool = ...
-) -> CallableType:
+def expand_type(typ: CallableType, env: Mapping[TypeVarId, Type]) -> CallableType:
     ...
 
 
 @overload
-def expand_type(
-    typ: ProperType, env: Mapping[TypeVarId, Type], allow_erased_callables: bool = ...
-) -> ProperType:
+def expand_type(typ: ProperType, env: Mapping[TypeVarId, Type]) -> ProperType:
     ...
 
 
 @overload
-def expand_type(
-    typ: Type, env: Mapping[TypeVarId, Type], allow_erased_callables: bool = ...
-) -> Type:
+def expand_type(typ: Type, env: Mapping[TypeVarId, Type]) -> Type:
     ...
 
 
-def expand_type(
-    typ: Type, env: Mapping[TypeVarId, Type], allow_erased_callables: bool = False
-) -> Type:
+def expand_type(typ: Type, env: Mapping[TypeVarId, Type]) -> Type:
     """Substitute any type variable references in a type given by a type
     environment.
     """
-    return typ.accept(ExpandTypeVisitor(env, allow_erased_callables))
+    return typ.accept(ExpandTypeVisitor(env))
 
 
 @overload
@@ -195,11 +187,8 @@ class ExpandTypeVisitor(TypeVisitor[Type]):
 
     variables: Mapping[TypeVarId, Type]  # TypeVar id -> TypeVar value
 
-    def __init__(
-        self, variables: Mapping[TypeVarId, Type], allow_erased_callables: bool = False
-    ) -> None:
+    def __init__(self, variables: Mapping[TypeVarId, Type]) -> None:
         self.variables = variables
-        self.allow_erased_callables = allow_erased_callables
 
     def visit_unbound_type(self, t: UnboundType) -> Type:
         return t
@@ -217,13 +206,12 @@ class ExpandTypeVisitor(TypeVisitor[Type]):
         return t
 
     def visit_erased_type(self, t: ErasedType) -> Type:
-        if not self.allow_erased_callables:
-            raise RuntimeError()
         # This may happen during type inference if some function argument
         # type is a generic callable, and its erased form will appear in inferred
         # constraints, then solver may check subtyping between them, which will trigger
-        # unify_generic_callables(), this is why we can get here. In all other cases it
-        # is a sign of a bug, since <Erased> should never appear in any stored types.
+        # unify_generic_callables(), this is why we can get here. Another example is
+        # when inferring type of lambda in generic context, the lambda body contains
+        # a generic method in generic class.
         return t
 
     def visit_instance(self, t: Instance) -> Type:
diff --git a/mypy/subtypes.py b/mypy/subtypes.py
index 94f119144..6f9d6e84c 100644
--- a/mypy/subtypes.py
+++ b/mypy/subtypes.py
@@ -1714,7 +1714,7 @@ def unify_generic_callable(
     # (probably also because solver needs subtyping). See also comment in
     # ExpandTypeVisitor.visit_erased_type().
     applied = mypy.applytype.apply_generic_arguments(
-        type, non_none_inferred_vars, report, context=target, allow_erased_callables=True
+        type, non_none_inferred_vars, report, context=target
     )
     if had_errors:
         return None
diff --git a/test-data/unit/check-generics.test b/test-data/unit/check-generics.test
index a62028ca9..79df350f8 100644
--- a/test-data/unit/check-generics.test
+++ b/test-data/unit/check-generics.test
@@ -2698,3 +2698,16 @@ def func(var: T) -> T:
 reveal_type(func(1))  # N: Revealed type is "builtins.int"
 
 [builtins fixtures/tuple.pyi]
+
+[case testGenericLambdaGenericMethodNoCrash]
+from typing import TypeVar, Union, Callable, Generic
+
+S = TypeVar("S")
+T = TypeVar("T")
+
+def f(x: Callable[[G[T]], int]) -> T: ...
+
+class G(Generic[T]):
+    def g(self, x: S) -> Union[S, T]: ...
+
+f(lambda x: x.g(0))  # E: Cannot infer type argument 1 of "f"
