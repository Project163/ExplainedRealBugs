diff --git a/mypy/checker.py b/mypy/checker.py
index c475748ec..6ddd778b8 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -3859,9 +3859,10 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
         def _get_base_classes(instances_: Tuple[Instance, Instance]) -> List[Instance]:
             base_classes_ = []
             for inst in instances_:
-                expanded = [inst]
                 if inst.type.is_intersection:
                     expanded = inst.type.bases
+                else:
+                    expanded = [inst]
 
                 for expanded_inst in expanded:
                     base_classes_.append(expanded_inst)
diff --git a/mypy/subtypes.py b/mypy/subtypes.py
index 4ac99d3fa..63cebc8aa 100644
--- a/mypy/subtypes.py
+++ b/mypy/subtypes.py
@@ -477,7 +477,13 @@ class SubtypeVisitor(TypeVisitor[bool]):
 
     def visit_partial_type(self, left: PartialType) -> bool:
         # This is indeterminate as we don't really know the complete type yet.
-        raise RuntimeError
+        if left.type is None:
+            # Special case, partial `None`. This might happen when defining
+            # class-level attributes with explicit `None`.
+            # We can still recover from this.
+            # https://github.com/python/mypy/issues/11105
+            return self.visit_none_type(NoneType())
+        raise RuntimeError(f'Partial type "{left}" cannot be checked with "issubtype()"')
 
     def visit_type_type(self, left: TypeType) -> bool:
         right = self.right
diff --git a/test-data/unit/check-protocols.test b/test-data/unit/check-protocols.test
index f13d2bc59..6410427b0 100644
--- a/test-data/unit/check-protocols.test
+++ b/test-data/unit/check-protocols.test
@@ -2124,7 +2124,7 @@ class B(Protocol):
     def execute(self, stmt: Any, *args: Any, **kwargs: Any) -> None: ...
     def cool(self) -> None: ...
 
-def func1(arg: A) -> None: ...        
+def func1(arg: A) -> None: ...
 def func2(arg: Optional[A]) -> None: ...
 
 x: B
@@ -2647,3 +2647,39 @@ class DataArray(ObjectHashable):
     def f(self, x: Hashable) -> None:
         reveal_type([self, x])  # N: Revealed type is "builtins.list[builtins.object*]"
 [builtins fixtures/tuple.pyi]
+
+
+[case testPartialAttributeNoneType]
+# flags: --no-strict-optional
+from typing import Optional, Protocol, runtime_checkable
+
+@runtime_checkable
+class MyProtocol(Protocol):
+    def is_valid(self) -> bool: ...
+    text: Optional[str]
+
+class MyClass:
+    text = None
+    def is_valid(self) -> bool:
+        reveal_type(self.text)  # N: Revealed type is "None"
+        assert isinstance(self, MyProtocol)
+[builtins fixtures/isinstance.pyi]
+[typing fixtures/typing-full.pyi]
+
+
+[case testPartialAttributeNoneTypeStrictOptional]
+# flags: --strict-optional
+from typing import Optional, Protocol, runtime_checkable
+
+@runtime_checkable
+class MyProtocol(Protocol):
+    def is_valid(self) -> bool: ...
+    text: Optional[str]
+
+class MyClass:
+    text = None
+    def is_valid(self) -> bool:
+        reveal_type(self.text)  # N: Revealed type is "None"
+        assert isinstance(self, MyProtocol)
+[builtins fixtures/isinstance.pyi]
+[typing fixtures/typing-full.pyi]
