diff --git a/mypy/build.py b/mypy/build.py
index a7a76a51f..f6272ed80 100644
--- a/mypy/build.py
+++ b/mypy/build.py
@@ -1069,7 +1069,7 @@ def read_plugins_snapshot(manager: BuildManager) -> dict[str, str] | None:
     if snapshot is None:
         return None
     if not isinstance(snapshot, dict):
-        manager.log(f"Could not load plugins snapshot: cache is not a dict: {type(snapshot)}")
+        manager.log(f"Could not load plugins snapshot: cache is not a dict: {type(snapshot)}")  # type: ignore[unreachable]
         return None
     return snapshot
 
@@ -1285,7 +1285,7 @@ def find_cache_meta(id: str, path: str, manager: BuildManager) -> CacheMeta | No
     if meta is None:
         return None
     if not isinstance(meta, dict):
-        manager.log(f"Could not load cache for {id}: meta cache is not a dict: {repr(meta)}")
+        manager.log(f"Could not load cache for {id}: meta cache is not a dict: {repr(meta)}")  # type: ignore[unreachable]
         return None
     m = cache_meta_from_dict(meta, data_json)
     t2 = time.time()
diff --git a/mypy/checker.py b/mypy/checker.py
index 70df15755..04a286bee 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -56,6 +56,7 @@ from mypy.nodes import (
     LITERAL_TYPE,
     MDEF,
     NOT_ABSTRACT,
+    SYMBOL_FUNCBASE_TYPES,
     AssertStmt,
     AssignmentExpr,
     AssignmentStmt,
@@ -2865,7 +2866,7 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
     def determine_type_of_member(self, sym: SymbolTableNode) -> Type | None:
         if sym.type is not None:
             return sym.type
-        if isinstance(sym.node, FuncBase):
+        if isinstance(sym.node, SYMBOL_FUNCBASE_TYPES):
             return self.function_type(sym.node)
         if isinstance(sym.node, TypeInfo):
             if sym.node.typeddict_type:
@@ -4459,7 +4460,9 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
         if isinstance(rvalue, (IntExpr, StrExpr, BytesExpr, FloatExpr, RefExpr)):
             return True
         if isinstance(rvalue, CallExpr):
-            if isinstance(rvalue.callee, RefExpr) and isinstance(rvalue.callee.node, FuncBase):
+            if isinstance(rvalue.callee, RefExpr) and isinstance(
+                rvalue.callee.node, SYMBOL_FUNCBASE_TYPES
+            ):
                 typ = rvalue.callee.node.type
                 if isinstance(typ, CallableType):
                     return not typ.variables
diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index 963667188..4078d447d 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -2580,8 +2580,6 @@ class ExpressionChecker(ExpressionVisitor[Type]):
             for actual, actual_type, actual_kind, callee_arg_type, callee_arg_kind in zip(
                 actuals, actual_types, actual_kinds, callee_arg_types, callee_arg_kinds
             ):
-                if actual_type is None:
-                    continue  # Some kind of error was already reported.
                 # Check that a *arg is valid as varargs.
                 expanded_actual = mapper.expand_actual_type(
                     actual_type,
diff --git a/mypy/checkmember.py b/mypy/checkmember.py
index 206a678a7..0994d0df4 100644
--- a/mypy/checkmember.py
+++ b/mypy/checkmember.py
@@ -1095,10 +1095,10 @@ def analyze_class_attribute_access(
             t = erase_typevars(expand_type_by_instance(t, isuper), {tv.id for tv in def_vars})
 
         is_classmethod = (is_decorated and cast(Decorator, node.node).func.is_class) or (
-            isinstance(node.node, FuncBase) and node.node.is_class
+            isinstance(node.node, SYMBOL_FUNCBASE_TYPES) and node.node.is_class
         )
         is_staticmethod = (is_decorated and cast(Decorator, node.node).func.is_static) or (
-            isinstance(node.node, FuncBase) and node.node.is_static
+            isinstance(node.node, SYMBOL_FUNCBASE_TYPES) and node.node.is_static
         )
         t = get_proper_type(t)
         if isinstance(t, FunctionLike) and is_classmethod:
@@ -1148,7 +1148,7 @@ def analyze_class_attribute_access(
             mx.not_ready_callback(name, mx.context)
             return AnyType(TypeOfAny.from_error)
     else:
-        assert isinstance(node.node, FuncBase)
+        assert isinstance(node.node, SYMBOL_FUNCBASE_TYPES)
         typ = function_type(node.node, mx.named_type("builtins.function"))
         # Note: if we are accessing class method on class object, the cls argument is bound.
         # Annotated and/or explicit class methods go through other code paths above, for
@@ -1427,7 +1427,7 @@ def is_valid_constructor(n: SymbolNode | None) -> bool:
     This includes normal functions, overloaded functions, and decorators
     that return a callable type.
     """
-    if isinstance(n, FuncBase):
+    if isinstance(n, SYMBOL_FUNCBASE_TYPES):
         return True
     if isinstance(n, Decorator):
         return isinstance(get_proper_type(n.type), FunctionLike)
diff --git a/mypy/constraints.py b/mypy/constraints.py
index 3c0d08089..d88b722aa 100644
--- a/mypy/constraints.py
+++ b/mypy/constraints.py
@@ -127,12 +127,12 @@ def infer_constraints_for_callable(
     param_spec_arg_kinds = []
 
     incomplete_star_mapping = False
-    for i, actuals in enumerate(formal_to_actual):
+    for i, actuals in enumerate(formal_to_actual):  # TODO: isn't this `enumerate(arg_types)`?
         for actual in actuals:
-            if actual is None and callee.arg_kinds[i] in (ARG_STAR, ARG_STAR2):
+            if actual is None and callee.arg_kinds[i] in (ARG_STAR, ARG_STAR2):  # type: ignore[unreachable]
                 # We can't use arguments to infer ParamSpec constraint, if only some
                 # are present in the current inference pass.
-                incomplete_star_mapping = True
+                incomplete_star_mapping = True  # type: ignore[unreachable]
                 break
 
     for i, actuals in enumerate(formal_to_actual):
@@ -545,11 +545,7 @@ def any_constraints(options: list[list[Constraint] | None], eager: bool) -> list
             for option in valid_options:
                 if option in trivial_options:
                     continue
-                if option is not None:
-                    merged_option: list[Constraint] | None = [merge_with_any(c) for c in option]
-                else:
-                    merged_option = None
-                merged_options.append(merged_option)
+                merged_options.append([merge_with_any(c) for c in option])
             return any_constraints(list(merged_options), eager)
 
     # If normal logic didn't work, try excluding trivially unsatisfiable constraint (due to
diff --git a/mypy/errors.py b/mypy/errors.py
index f720cb04b..58ef17b69 100644
--- a/mypy/errors.py
+++ b/mypy/errors.py
@@ -11,7 +11,6 @@ from typing_extensions import Literal, TypeAlias as _TypeAlias
 from mypy import errorcodes as codes
 from mypy.error_formatter import ErrorFormatter
 from mypy.errorcodes import IMPORT, IMPORT_NOT_FOUND, IMPORT_UNTYPED, ErrorCode, mypy_error_codes
-from mypy.message_registry import ErrorMessage
 from mypy.options import Options
 from mypy.scope import Scope
 from mypy.util import DEFAULT_SOURCE_OFFSET, is_typeshed_file
@@ -1069,34 +1068,19 @@ class Errors:
                         (file, -1, -1, -1, -1, "note", f'In class "{e.type}":', e.allow_dups, None)
                     )
 
-            if isinstance(e.message, ErrorMessage):
-                result.append(
-                    (
-                        file,
-                        e.line,
-                        e.column,
-                        e.end_line,
-                        e.end_column,
-                        e.severity,
-                        e.message.value,
-                        e.allow_dups,
-                        e.code,
-                    )
-                )
-            else:
-                result.append(
-                    (
-                        file,
-                        e.line,
-                        e.column,
-                        e.end_line,
-                        e.end_column,
-                        e.severity,
-                        e.message,
-                        e.allow_dups,
-                        e.code,
-                    )
+            result.append(
+                (
+                    file,
+                    e.line,
+                    e.column,
+                    e.end_line,
+                    e.end_column,
+                    e.severity,
+                    e.message,
+                    e.allow_dups,
+                    e.code,
                 )
+            )
 
             prev_import_context = e.import_ctx
             prev_function_or_member = e.function_or_member
diff --git a/mypy/messages.py b/mypy/messages.py
index 9315e77df..25c4ed68c 100644
--- a/mypy/messages.py
+++ b/mypy/messages.py
@@ -2151,12 +2151,8 @@ class MessageBuilder:
         is_module = False
         skip = []
         if isinstance(subtype, TupleType):
-            if not isinstance(subtype.partial_fallback, Instance):
-                return
             subtype = subtype.partial_fallback
         elif isinstance(subtype, TypedDictType):
-            if not isinstance(subtype.fallback, Instance):
-                return
             subtype = subtype.fallback
         elif isinstance(subtype, TypeType):
             if not isinstance(subtype.item, Instance):
diff --git a/mypy/nodes.py b/mypy/nodes.py
index 2b6bf2591..5e6fe73a2 100644
--- a/mypy/nodes.py
+++ b/mypy/nodes.py
@@ -176,10 +176,7 @@ class Node(Context):
     __slots__ = ()
 
     def __str__(self) -> str:
-        a = self.accept(mypy.strconv.StrConv(options=Options()))
-        if a is None:
-            return repr(self)
-        return a
+        return self.accept(mypy.strconv.StrConv(options=Options()))
 
     def str_with_options(self, options: Options) -> str:
         a = self.accept(mypy.strconv.StrConv(options=options))
@@ -875,7 +872,9 @@ class FuncDef(FuncItem, SymbolNode, Statement):
 
 # All types that are both SymbolNodes and FuncBases. See the FuncBase
 # docstring for the rationale.
-SYMBOL_FUNCBASE_TYPES = (OverloadedFuncDef, FuncDef)
+# See https://github.com/python/mypy/pull/13607#issuecomment-1236357236
+# TODO: we want to remove this at some point and just use `FuncBase` ideally.
+SYMBOL_FUNCBASE_TYPES: Final = (OverloadedFuncDef, FuncDef)
 
 
 class Decorator(SymbolNode, Statement):
@@ -2575,6 +2574,11 @@ class TypeVarLikeExpr(SymbolNode, Expression):
         return self._fullname
 
 
+# All types that are both SymbolNodes and Expressions.
+# Use when common children of them are needed.
+SYMBOL_NODE_EXPRESSION_TYPES: Final = (TypeVarLikeExpr,)
+
+
 class TypeVarExpr(TypeVarLikeExpr):
     """Type variable expression TypeVar(...).
 
@@ -3273,7 +3277,7 @@ class TypeInfo(SymbolNode):
         for cls in self.mro:
             if name in cls.names:
                 node = cls.names[name].node
-                if isinstance(node, FuncBase):
+                if isinstance(node, SYMBOL_FUNCBASE_TYPES):
                     return node
                 elif isinstance(node, Decorator):  # Two `if`s make `mypyc` happy
                     return node
@@ -4032,7 +4036,8 @@ class SymbolTable(dict[str, SymbolTableNode]):
                 ):
                     a.append("  " + str(key) + " : " + str(value))
             else:
-                a.append("  <invalid item>")
+                # Used in debugging:
+                a.append("  <invalid item>")  # type: ignore[unreachable]
         a = sorted(a)
         a.insert(0, "SymbolTable(")
         a[-1] += ")"
diff --git a/mypy/plugins/functools.py b/mypy/plugins/functools.py
index 6a063174b..c435dde7f 100644
--- a/mypy/plugins/functools.py
+++ b/mypy/plugins/functools.py
@@ -8,7 +8,16 @@ import mypy.checker
 import mypy.plugin
 import mypy.semanal
 from mypy.argmap import map_actuals_to_formals
-from mypy.nodes import ARG_POS, ARG_STAR2, ArgKind, Argument, CallExpr, FuncItem, NameExpr, Var
+from mypy.nodes import (
+    ARG_POS,
+    ARG_STAR2,
+    SYMBOL_FUNCBASE_TYPES,
+    ArgKind,
+    Argument,
+    CallExpr,
+    NameExpr,
+    Var,
+)
 from mypy.plugins.common import add_method_to_class
 from mypy.typeops import get_all_type_vars
 from mypy.types import (
@@ -108,7 +117,7 @@ def _analyze_class(ctx: mypy.plugin.ClassDefContext) -> dict[str, _MethodInfo |
         for name in _ORDERING_METHODS:
             if name in cls.names and name not in comparison_methods:
                 node = cls.names[name].node
-                if isinstance(node, FuncItem) and isinstance(node.type, CallableType):
+                if isinstance(node, SYMBOL_FUNCBASE_TYPES) and isinstance(node.type, CallableType):
                     comparison_methods[name] = _MethodInfo(node.is_static, node.type)
                     continue
 
diff --git a/mypy/semanal.py b/mypy/semanal.py
index b6e534d3c..1a6473105 100644
--- a/mypy/semanal.py
+++ b/mypy/semanal.py
@@ -86,6 +86,7 @@ from mypy.nodes import (
     REVEAL_LOCALS,
     REVEAL_TYPE,
     RUNTIME_PROTOCOL_DECOS,
+    SYMBOL_FUNCBASE_TYPES,
     TYPE_VAR_KIND,
     TYPE_VAR_TUPLE_KIND,
     VARIANCE_NOT_READY,
@@ -3082,8 +3083,6 @@ class SemanticAnalyzer(
             for name, node in m.names.items():
                 fullname = i_id + "." + name
                 self.set_future_import_flags(fullname)
-                if node is None:
-                    continue
                 # if '__all__' exists, all nodes not included have had module_public set to
                 # False, and we can skip checking '_' because it's been explicitly included.
                 if node.module_public and (not name.startswith("_") or "__all__" in m.names):
@@ -5719,7 +5718,7 @@ class SemanticAnalyzer(
             reveal_type_node = self.lookup("reveal_type", expr, suppress_errors=True)
             if (
                 reveal_type_node
-                and isinstance(reveal_type_node.node, FuncBase)
+                and isinstance(reveal_type_node.node, SYMBOL_FUNCBASE_TYPES)
                 and reveal_type_node.fullname in IMPORTED_REVEAL_TYPE_NAMES
             ):
                 reveal_imported = True
diff --git a/mypy/server/astdiff.py b/mypy/server/astdiff.py
index 07bc6333c..1b0cc218e 100644
--- a/mypy/server/astdiff.py
+++ b/mypy/server/astdiff.py
@@ -58,9 +58,9 @@ from typing_extensions import TypeAlias as _TypeAlias
 
 from mypy.expandtype import expand_type
 from mypy.nodes import (
+    SYMBOL_FUNCBASE_TYPES,
     UNBOUND_IMPORTED,
     Decorator,
-    FuncBase,
     FuncDef,
     FuncItem,
     MypyFile,
@@ -234,16 +234,16 @@ def snapshot_definition(node: SymbolNode | None, common: SymbolSnapshot) -> Symb
     The representation is nested tuples and dicts. Only externally
     visible attributes are included.
     """
-    if isinstance(node, FuncBase):
+    if isinstance(node, SYMBOL_FUNCBASE_TYPES):
         # TODO: info
         if node.type:
-            signature = snapshot_type(node.type)
+            signature: tuple[object, ...] = snapshot_type(node.type)
         else:
             signature = snapshot_untyped_signature(node)
         impl: FuncDef | None = None
         if isinstance(node, FuncDef):
             impl = node
-        elif isinstance(node, OverloadedFuncDef) and node.impl:
+        elif node.impl:
             impl = node.impl.func if isinstance(node.impl, Decorator) else node.impl
         setter_type = None
         if isinstance(node, OverloadedFuncDef) and node.items:
diff --git a/mypy/server/astmerge.py b/mypy/server/astmerge.py
index bb5606758..8cd574628 100644
--- a/mypy/server/astmerge.py
+++ b/mypy/server/astmerge.py
@@ -51,6 +51,7 @@ from typing import TypeVar, cast
 
 from mypy.nodes import (
     MDEF,
+    SYMBOL_NODE_EXPRESSION_TYPES,
     AssertTypeExpr,
     AssignmentStmt,
     Block,
@@ -301,7 +302,7 @@ class NodeReplaceVisitor(TraverserVisitor):
 
     def visit_call_expr(self, node: CallExpr) -> None:
         super().visit_call_expr(node)
-        if isinstance(node.analyzed, SymbolNode):
+        if isinstance(node.analyzed, SYMBOL_NODE_EXPRESSION_TYPES):
             node.analyzed = self.fixup(node.analyzed)
 
     def visit_newtype_expr(self, node: NewTypeExpr) -> None:
diff --git a/mypy/server/deps.py b/mypy/server/deps.py
index f4e7b86ab..b994a214f 100644
--- a/mypy/server/deps.py
+++ b/mypy/server/deps.py
@@ -87,6 +87,7 @@ from mypy.nodes import (
     GDEF,
     LDEF,
     MDEF,
+    SYMBOL_FUNCBASE_TYPES,
     AssertTypeExpr,
     AssignmentStmt,
     AwaitExpr,
@@ -501,7 +502,7 @@ class DependencyVisitor(TraverserVisitor):
                 if isinstance(rvalue.callee.node, TypeInfo):
                     # use actual __init__ as a dependency source
                     init = rvalue.callee.node.get("__init__")
-                    if init and isinstance(init.node, FuncBase):
+                    if init and isinstance(init.node, SYMBOL_FUNCBASE_TYPES):
                         fname = init.node.fullname
                 else:
                     fname = rvalue.callee.fullname
diff --git a/mypy/server/mergecheck.py b/mypy/server/mergecheck.py
index 6f044a5ea..11e00213d 100644
--- a/mypy/server/mergecheck.py
+++ b/mypy/server/mergecheck.py
@@ -26,10 +26,11 @@ def check_consistency(o: object) -> None:
             continue
 
         fn = sym.fullname
-        # Skip None names, since they are ambiguous.
+        # Skip None and empty names, since they are ambiguous.
         # TODO: Everything should have a proper full name?
-        if fn is None:
+        if not fn:
             continue
+
         # Skip stuff that should be expected to have duplicate names
         if isinstance(sym, (Var, Decorator)):
             continue
@@ -37,7 +38,7 @@ def check_consistency(o: object) -> None:
             continue
 
         if fn not in m:
-            m[sym.fullname] = sym
+            m[fn] = sym
             continue
 
         # We have trouble and need to decide what to do about it.
diff --git a/mypy/stubgen.py b/mypy/stubgen.py
index 60460ee1e..881686adc 100755
--- a/mypy/stubgen.py
+++ b/mypy/stubgen.py
@@ -1504,9 +1504,7 @@ def is_blacklisted_path(path: str) -> bool:
 
 
 def normalize_path_separators(path: str) -> str:
-    if sys.platform == "win32":
-        return path.replace("\\", "/")
-    return path
+    return path.replace("\\", "/") if sys.platform == "win32" else path
 
 
 def collect_build_targets(
diff --git a/mypy/stubtest.py b/mypy/stubtest.py
index 5d19c4777..e2a6a06f6 100644
--- a/mypy/stubtest.py
+++ b/mypy/stubtest.py
@@ -338,7 +338,8 @@ def verify_mypyfile(
         yield Error(object_path, "is not present at runtime", stub, runtime)
         return
     if not isinstance(runtime, types.ModuleType):
-        yield Error(object_path, "is not a module", stub, runtime)
+        # Can possibly happen:
+        yield Error(object_path, "is not a module", stub, runtime)  # type: ignore[unreachable]
         return
 
     runtime_all_as_set: set[str] | None
@@ -524,7 +525,8 @@ def verify_typeinfo(
         yield Error(object_path, "is not present at runtime", stub, runtime, stub_desc=repr(stub))
         return
     if not isinstance(runtime, type):
-        yield Error(object_path, "is not a type", stub, runtime, stub_desc=repr(stub))
+        # Yes, some runtime objects can be not types, no way to tell mypy about that.
+        yield Error(object_path, "is not a type", stub, runtime, stub_desc=repr(stub))  # type: ignore[unreachable]
         return
 
     yield from _verify_final(stub, runtime, object_path)
diff --git a/mypy/test/data.py b/mypy/test/data.py
index 50e452de4..5b0ad84c0 100644
--- a/mypy/test/data.py
+++ b/mypy/test/data.py
@@ -246,7 +246,7 @@ class DataDrivenTestCase(pytest.Item):
     """Holds parsed data-driven test cases, and handles directory setup and teardown."""
 
     # Override parent member type
-    parent: DataSuiteCollector
+    parent: DataFileCollector
 
     input: list[str]
     output: list[str]  # Output for the first pass
@@ -277,7 +277,7 @@ class DataDrivenTestCase(pytest.Item):
 
     def __init__(
         self,
-        parent: DataSuiteCollector,
+        parent: DataFileCollector,
         suite: DataSuite,
         *,
         file: str,
@@ -291,6 +291,7 @@ class DataDrivenTestCase(pytest.Item):
         data: str,
         line: int,
     ) -> None:
+        assert isinstance(parent, DataFileCollector)
         super().__init__(name, parent)
         self.suite = suite
         self.file = file
diff --git a/mypy/test/testfinegrained.py b/mypy/test/testfinegrained.py
index cb8672dfa..b098c1fb0 100644
--- a/mypy/test/testfinegrained.py
+++ b/mypy/test/testfinegrained.py
@@ -75,7 +75,6 @@ class FineGrainedSuite(DataSuite):
     def run_case(self, testcase: DataDrivenTestCase) -> None:
         if self.should_skip(testcase):
             pytest.skip()
-            return
 
         main_src = "\n".join(testcase.input)
         main_path = os.path.join(test_temp_dir, "main")
diff --git a/mypy/test/testmerge.py b/mypy/test/testmerge.py
index 0582c9ed5..51a4ff39d 100644
--- a/mypy/test/testmerge.py
+++ b/mypy/test/testmerge.py
@@ -13,7 +13,6 @@ from mypy.nodes import (
     UNBOUND_IMPORTED,
     Expression,
     MypyFile,
-    Node,
     SymbolTable,
     SymbolTableNode,
     TypeInfo,
@@ -172,10 +171,7 @@ class ASTMergeSuite(DataSuite):
             if node.kind == UNBOUND_IMPORTED:
                 return "UNBOUND_IMPORTED"
             return "None"
-        if isinstance(node.node, Node):
-            s = f"{str(type(node.node).__name__)}<{self.id_mapper.id(node.node)}>"
-        else:
-            s = f"? ({type(node.node)})"
+        s = f"{str(type(node.node).__name__)}<{self.id_mapper.id(node.node)}>"
         if (
             isinstance(node.node, Var)
             and node.node.type
diff --git a/mypy/test/testpep561.py b/mypy/test/testpep561.py
index 4a5301d2c..e3f729729 100644
--- a/mypy/test/testpep561.py
+++ b/mypy/test/testpep561.py
@@ -173,38 +173,3 @@ def parse_mypy_args(line: str) -> list[str]:
     if not m:
         return []  # No args; mypy will spit out an error.
     return m.group(1).split()
-
-
-def test_mypy_path_is_respected() -> None:
-    assert False
-    packages = "packages"
-    pkg_name = "a"
-    with tempfile.TemporaryDirectory() as temp_dir:
-        old_dir = os.getcwd()
-        os.chdir(temp_dir)
-        try:
-            # Create the pkg for files to go into
-            full_pkg_name = os.path.join(temp_dir, packages, pkg_name)
-            os.makedirs(full_pkg_name)
-
-            # Create the empty __init__ file to declare a package
-            pkg_init_name = os.path.join(temp_dir, packages, pkg_name, "__init__.py")
-            open(pkg_init_name, "w", encoding="utf8").close()
-
-            mypy_config_path = os.path.join(temp_dir, "mypy.ini")
-            with open(mypy_config_path, "w") as mypy_file:
-                mypy_file.write("[mypy]\n")
-                mypy_file.write(f"mypy_path = ./{packages}\n")
-
-            with virtualenv() as venv:
-                venv_dir, python_executable = venv
-
-                cmd_line_args = []
-                if python_executable != sys.executable:
-                    cmd_line_args.append(f"--python-executable={python_executable}")
-                cmd_line_args.extend(["--config-file", mypy_config_path, "--package", pkg_name])
-
-                out, err, returncode = mypy.api.run(cmd_line_args)
-                assert returncode == 0
-        finally:
-            os.chdir(old_dir)
diff --git a/mypy/types.py b/mypy/types.py
index f700be887..f9749945d 100644
--- a/mypy/types.py
+++ b/mypy/types.py
@@ -3320,12 +3320,7 @@ class TypeStrVisitor(SyntheticTypeVisitor[str]):
         return s
 
     def visit_type_var(self, t: TypeVarType, /) -> str:
-        if t.name is None:
-            # Anonymous type variable type (only numeric id).
-            s = f"`{t.id}"
-        else:
-            # Named type variable type.
-            s = f"{t.name}`{t.id}"
+        s = f"{t.name}`{t.id}"
         if self.id_mapper and t.upper_bound:
             s += f"(upper_bound={t.upper_bound.accept(self)})"
         if t.has_default():
@@ -3337,12 +3332,7 @@ class TypeStrVisitor(SyntheticTypeVisitor[str]):
         s = ""
         if t.prefix.arg_types:
             s += f"[{self.list_str(t.prefix.arg_types)}, **"
-        if t.name is None:
-            # Anonymous type variable type (only numeric id).
-            s += f"`{t.id}"
-        else:
-            # Named type variable type.
-            s += f"{t.name_with_suffix()}`{t.id}"
+        s += f"{t.name_with_suffix()}`{t.id}"
         if t.prefix.arg_types:
             s += "]"
         if t.has_default():
@@ -3379,12 +3369,7 @@ class TypeStrVisitor(SyntheticTypeVisitor[str]):
         return f"[{s}]"
 
     def visit_type_var_tuple(self, t: TypeVarTupleType, /) -> str:
-        if t.name is None:
-            # Anonymous type variable type (only numeric id).
-            s = f"`{t.id}"
-        else:
-            # Named type variable type.
-            s = f"{t.name}`{t.id}"
+        s = f"{t.name}`{t.id}"
         if t.has_default():
             s += f" = {t.default.accept(self)}"
         return s
diff --git a/mypy/util.py b/mypy/util.py
index f79d7113c..d3f49f74b 100644
--- a/mypy/util.py
+++ b/mypy/util.py
@@ -571,8 +571,7 @@ def hash_digest(data: bytes) -> str:
 
 def parse_gray_color(cup: bytes) -> str:
     """Reproduce a gray color in ANSI escape sequence"""
-    if sys.platform == "win32":
-        assert False, "curses is not available on Windows"
+    assert sys.platform != "win32", "curses is not available on Windows"
     set_color = "".join([cup[:-1].decode(), "m"])
     gray = curses.tparm(set_color.encode("utf-8"), 1, 9).decode()
     return gray
@@ -639,8 +638,7 @@ class FancyFormatter:
         # Windows ANSI escape sequences are only supported on Threshold 2 and above.
         # we check with an assert at runtime and an if check for mypy, as asserts do not
         # yet narrow platform
-        assert sys.platform == "win32"
-        if sys.platform == "win32":
+        if sys.platform == "win32":  # needed to find win specific sys apis
             winver = sys.getwindowsversion()
             if (
                 winver.major < MINIMUM_WINDOWS_MAJOR_VT100
@@ -662,11 +660,12 @@ class FancyFormatter:
             )
             self.initialize_vt100_colors()
             return True
-        return False
+        assert False, "Running not on Windows"
 
     def initialize_unix_colors(self) -> bool:
         """Return True if initialization was successful and we can use colors, False otherwise"""
-        if sys.platform == "win32" or not CURSES_ENABLED:
+        is_win = sys.platform == "win32"
+        if is_win or not CURSES_ENABLED:
             return False
         try:
             # setupterm wants a fd to potentially write an "initialization sequence".
diff --git a/mypy_self_check.ini b/mypy_self_check.ini
index 8b38cf753..816e6321c 100644
--- a/mypy_self_check.ini
+++ b/mypy_self_check.ini
@@ -13,3 +13,7 @@ exclude = mypy/typeshed/|mypyc/test-data/|mypyc/lib-rt/
 enable_error_code = ignore-without-code,redundant-expr
 enable_incomplete_feature = PreciseTupleTypes
 show_error_code_links = True
+
+[mypy-mypy.*]
+# TODO: enable for `mypyc` and other files as well
+warn_unreachable = True
