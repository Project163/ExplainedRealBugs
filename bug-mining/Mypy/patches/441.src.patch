diff --git a/mypy/stubtest.py b/mypy/stubtest.py
index ca17ccfe2..c54f83f33 100644
--- a/mypy/stubtest.py
+++ b/mypy/stubtest.py
@@ -1224,6 +1224,9 @@ def _verify_readonly_property(stub: nodes.Decorator, runtime: Any) -> Iterator[s
     if isinstance(runtime, property):
         yield from _verify_final_method(stub.func, runtime.fget, MISSING)
         return
+    if isinstance(runtime, functools.cached_property):
+        yield from _verify_final_method(stub.func, runtime.func, MISSING)
+        return
     if inspect.isdatadescriptor(runtime):
         # It's enough like a property...
         return
diff --git a/mypy/test/teststubtest.py b/mypy/test/teststubtest.py
index c10c683ff..c6e92258e 100644
--- a/mypy/test/teststubtest.py
+++ b/mypy/test/teststubtest.py
@@ -893,6 +893,106 @@ class StubtestUnit(unittest.TestCase):
             error=None,
         )
 
+    @collect_cases
+    def test_cached_property(self) -> Iterator[Case]:
+        yield Case(
+            stub="""
+            from functools import cached_property
+            class Good:
+                @cached_property
+                def read_only_attr(self) -> int: ...
+                @cached_property
+                def read_only_attr2(self) -> int: ...
+            """,
+            runtime="""
+            import functools as ft
+            from functools import cached_property
+            class Good:
+                @cached_property
+                def read_only_attr(self): return 1
+                @ft.cached_property
+                def read_only_attr2(self): return 1
+            """,
+            error=None,
+        )
+        yield Case(
+            stub="""
+            from functools import cached_property
+            class Bad:
+                @cached_property
+                def f(self) -> int: ...
+            """,
+            runtime="""
+            class Bad:
+                def f(self) -> int: return 1
+            """,
+            error="Bad.f",
+        )
+        yield Case(
+            stub="""
+            from functools import cached_property
+            class GoodCachedAttr:
+                @cached_property
+                def f(self) -> int: ...
+            """,
+            runtime="""
+            class GoodCachedAttr:
+                f = 1
+            """,
+            error=None,
+        )
+        yield Case(
+            stub="""
+            from functools import cached_property
+            class BadCachedAttr:
+                @cached_property
+                def f(self) -> str: ...
+            """,
+            runtime="""
+            class BadCachedAttr:
+                f = 1
+            """,
+            error="BadCachedAttr.f",
+        )
+        yield Case(
+            stub="""
+            from functools import cached_property
+            from typing import final
+            class FinalGood:
+                @cached_property
+                @final
+                def attr(self) -> int: ...
+            """,
+            runtime="""
+            from functools import cached_property
+            from typing import final
+            class FinalGood:
+                @cached_property
+                @final
+                def attr(self):
+                    return 1
+            """,
+            error=None,
+        )
+        yield Case(
+            stub="""
+            from functools import cached_property
+            class FinalBad:
+                @cached_property
+                def attr(self) -> int: ...
+            """,
+            runtime="""
+            from functools import cached_property
+            from typing_extensions import final
+            class FinalBad:
+                @cached_property
+                @final
+                def attr(self):
+                    return 1
+            """,
+            error="FinalBad.attr",
+        )
+
     @collect_cases
     def test_var(self) -> Iterator[Case]:
         yield Case(stub="x1: int", runtime="x1 = 5", error=None)
