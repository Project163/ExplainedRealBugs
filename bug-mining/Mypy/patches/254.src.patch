diff --git a/mypy/join.py b/mypy/join.py
index 84aa03f8e..62d256f44 100644
--- a/mypy/join.py
+++ b/mypy/join.py
@@ -9,6 +9,7 @@ from mypy.maptype import map_instance_to_supertype
 from mypy.nodes import CONTRAVARIANT, COVARIANT, INVARIANT
 from mypy.state import state
 from mypy.subtypes import (
+    SubtypeContext,
     find_member,
     is_equivalent,
     is_proper_subtype,
@@ -101,7 +102,9 @@ class InstanceJoiner:
                 assert new_type is not None
                 args.append(new_type)
             result: ProperType = Instance(t.type, args)
-        elif t.type.bases and is_subtype(t, s, ignore_type_params=True):
+        elif t.type.bases and is_proper_subtype(
+            t, s, subtype_context=SubtypeContext(ignore_type_params=True)
+        ):
             result = self.join_instances_via_supertype(t, s)
         else:
             # Now t is not a subtype of s, and t != s. Now s could be a subtype
diff --git a/mypy/subtypes.py b/mypy/subtypes.py
index 83cb22d48..0214e7ae3 100644
--- a/mypy/subtypes.py
+++ b/mypy/subtypes.py
@@ -103,11 +103,7 @@ class SubtypeContext:
         # Historically proper and non-proper subtypes were defined using different helpers
         # and different visitors. Check if flag values are such that we definitely support.
         if proper_subtype:
-            assert (
-                not self.ignore_type_params
-                and not self.ignore_pos_arg_names
-                and not self.ignore_declared_variance
-            )
+            assert not self.ignore_pos_arg_names and not self.ignore_declared_variance
         else:
             assert not self.erase_instances and not self.keep_erased_types
 
diff --git a/test-data/unit/check-inference.test b/test-data/unit/check-inference.test
index 41fe942b8..331b110fd 100644
--- a/test-data/unit/check-inference.test
+++ b/test-data/unit/check-inference.test
@@ -3380,3 +3380,15 @@ class A:
 T = TypeVar("T")
 def type_or_callable(value: T, tp: Union[Type[T], Callable[[int], T]]) -> T: ...
 reveal_type(type_or_callable(A("test"), A))  # N: Revealed type is "__main__.A"
+
+[case testJoinWithAnyFallback]
+from unknown import X  # type: ignore[import]
+
+class A: ...
+class B(X, A): ...
+class C(B): ...
+class D(C): ...
+class E(D): ...
+
+reveal_type([E(), D()])  # N: Revealed type is "builtins.list[__main__.D]"
+reveal_type([D(), E()])  # N: Revealed type is "builtins.list[__main__.D]"
