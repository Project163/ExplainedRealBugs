diff --git a/mypy/errorcodes.py b/mypy/errorcodes.py
index 3594458fa..70b8cffe9 100644
--- a/mypy/errorcodes.py
+++ b/mypy/errorcodes.py
@@ -261,3 +261,10 @@ del error_codes[FILE.code]
 
 # This is a catch-all for remaining uncategorized errors.
 MISC: Final = ErrorCode("misc", "Miscellaneous other checks", "General")
+
+UNSAFE_OVERLOAD: Final[ErrorCode] = ErrorCode(
+    "unsafe-overload",
+    "Warn if multiple @overload variants overlap in unsafe ways",
+    "General",
+    sub_code_of=MISC,
+)
diff --git a/mypy/messages.py b/mypy/messages.py
index bba9c3c3c..a58c5f91c 100644
--- a/mypy/messages.py
+++ b/mypy/messages.py
@@ -1604,6 +1604,7 @@ class MessageBuilder:
             "Overloaded function signatures {} and {} overlap with "
             "incompatible return types".format(index1, index2),
             context,
+            code=codes.UNSAFE_OVERLOAD,
         )
 
     def overloaded_signature_will_never_match(
diff --git a/mypy/types.py b/mypy/types.py
index f974157ce..cee4595b6 100644
--- a/mypy/types.py
+++ b/mypy/types.py
@@ -3019,7 +3019,7 @@ def get_proper_type(typ: Type | None) -> ProperType | None:
 
 
 @overload
-def get_proper_types(types: list[Type] | tuple[Type, ...]) -> list[ProperType]:  # type: ignore[misc]
+def get_proper_types(types: list[Type] | tuple[Type, ...]) -> list[ProperType]:  # type: ignore[unsafe-overload]
     ...
 
 
diff --git a/test-data/unit/check-errorcodes.test b/test-data/unit/check-errorcodes.test
index df14e328e..72edf2f22 100644
--- a/test-data/unit/check-errorcodes.test
+++ b/test-data/unit/check-errorcodes.test
@@ -1072,3 +1072,17 @@ A.f = h  # type: ignore[assignment]  # E: Unused "type: ignore" comment, use nar
 [case testUnusedIgnoreEnableCode]
 # flags: --enable-error-code=unused-ignore
 x = 1  # type: ignore  # E: Unused "type: ignore" comment  [unused-ignore]
+
+[case testErrorCodeUnsafeOverloadError]
+from typing import overload, Union
+
+@overload
+def unsafe_func(x: int) -> int: ...  # E: Overloaded function signatures 1 and 2 overlap with incompatible return types  [unsafe-overload]
+@overload
+def unsafe_func(x: object) -> str: ...
+def unsafe_func(x: object) -> Union[int, str]:
+    if isinstance(x, int):
+        return 42
+    else:
+        return "some string"
+[builtins fixtures/isinstancelist.pyi]
