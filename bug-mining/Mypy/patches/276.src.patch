diff --git a/mypy/checker.py b/mypy/checker.py
index c9d2d3ede..8e1de9a07 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -192,7 +192,6 @@ from mypy.types import (
     Overloaded,
     PartialType,
     ProperType,
-    StarType,
     TupleType,
     Type,
     TypeAliasType,
@@ -3288,7 +3287,7 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
             last_idx: int | None = None
             for idx_rval, rval in enumerate(rvalue.items):
                 if isinstance(rval, StarExpr):
-                    typs = get_proper_type(self.expr_checker.visit_star_expr(rval).type)
+                    typs = get_proper_type(self.expr_checker.accept(rval.expr))
                     if isinstance(typs, TupleType):
                         rvalues.extend([TempNode(typ) for typ in typs.items])
                     elif self.type_is_iterable(typs) and isinstance(typs, Instance):
@@ -3311,7 +3310,7 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
             iterable_end: int | None = None
             for i, rval in enumerate(rvalues):
                 if isinstance(rval, StarExpr):
-                    typs = get_proper_type(self.expr_checker.visit_star_expr(rval).type)
+                    typs = get_proper_type(self.expr_checker.accept(rval.expr))
                     if self.type_is_iterable(typs) and isinstance(typs, Instance):
                         if iterable_start is None:
                             iterable_start = i
@@ -3674,8 +3673,7 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
             ]
             lvalue_type = TupleType(types, self.named_type("builtins.tuple"))
         elif isinstance(lvalue, StarExpr):
-            typ, _, _ = self.check_lvalue(lvalue.expr)
-            lvalue_type = StarType(typ) if typ else None
+            lvalue_type, _, _ = self.check_lvalue(lvalue.expr)
         else:
             lvalue_type = self.expr_checker.accept(lvalue)
 
diff --git a/mypy/checkexpr.py b/mypy/checkexpr.py
index 9992821f1..4cfbd0811 100644
--- a/mypy/checkexpr.py
+++ b/mypy/checkexpr.py
@@ -140,7 +140,6 @@ from mypy.types import (
     ParamSpecType,
     PartialType,
     ProperType,
-    StarType,
     TupleType,
     Type,
     TypeAliasType,
@@ -5160,8 +5159,9 @@ class ExpressionChecker(ExpressionVisitor[Type]):
     def visit__promote_expr(self, e: PromoteExpr) -> Type:
         return e.type
 
-    def visit_star_expr(self, e: StarExpr) -> StarType:
-        return StarType(self.accept(e.expr))
+    def visit_star_expr(self, e: StarExpr) -> Type:
+        # TODO: should this ever be called (see e.g. mypyc visitor)?
+        return self.accept(e.expr)
 
     def object_type(self) -> Instance:
         """Return instance type 'object'."""
diff --git a/mypy/semanal.py b/mypy/semanal.py
index 1256133cb..ba5a6bc67 100644
--- a/mypy/semanal.py
+++ b/mypy/semanal.py
@@ -257,7 +257,6 @@ from mypy.types import (
     ParamSpecType,
     PlaceholderType,
     ProperType,
-    StarType,
     TrivialSyntheticTypeTranslator,
     TupleType,
     Type,
@@ -3873,8 +3872,6 @@ class SemanticAnalyzer(
             self.fail(message_registry.CANNOT_ASSIGN_TO_TYPE, ctx)
 
     def store_declared_types(self, lvalue: Lvalue, typ: Type) -> None:
-        if isinstance(typ, StarType) and not isinstance(lvalue, StarExpr):
-            self.fail("Star type only allowed for starred expressions", lvalue)
         if isinstance(lvalue, RefExpr):
             lvalue.is_inferred_def = False
             if isinstance(lvalue.node, Var):
@@ -3902,10 +3899,7 @@ class SemanticAnalyzer(
                 self.fail("Tuple type expected for multiple variables", lvalue)
         elif isinstance(lvalue, StarExpr):
             # Historical behavior for the old parser
-            if isinstance(typ, StarType):
-                self.store_declared_types(lvalue.expr, typ.type)
-            else:
-                self.store_declared_types(lvalue.expr, typ)
+            self.store_declared_types(lvalue.expr, typ)
         else:
             # This has been flagged elsewhere as an error, so just ignore here.
             pass
diff --git a/mypy/server/astmerge.py b/mypy/server/astmerge.py
index 6ce737c42..1ec6d572a 100644
--- a/mypy/server/astmerge.py
+++ b/mypy/server/astmerge.py
@@ -95,7 +95,6 @@ from mypy.types import (
     PartialType,
     PlaceholderType,
     RawExpressionType,
-    StarType,
     SyntheticTypeVisitor,
     TupleType,
     Type,
@@ -519,9 +518,6 @@ class TypeReplaceVisitor(SyntheticTypeVisitor[None]):
     def visit_ellipsis_type(self, typ: EllipsisType) -> None:
         pass
 
-    def visit_star_type(self, typ: StarType) -> None:
-        typ.type.accept(self)
-
     def visit_uninhabited_type(self, typ: UninhabitedType) -> None:
         pass
 
diff --git a/mypy/test/testpythoneval.py b/mypy/test/testpythoneval.py
index 6f937fee6..02dd11655 100644
--- a/mypy/test/testpythoneval.py
+++ b/mypy/test/testpythoneval.py
@@ -81,6 +81,10 @@ def test_python_evaluation(testcase: DataDrivenTestCase, cache_dir: str) -> None
             # Normalize paths so that the output is the same on Windows and Linux/macOS.
             line = line.replace(test_temp_dir + os.sep, test_temp_dir + "/")
             output.append(line.rstrip("\r\n"))
+    if returncode > 1 and not testcase.output:
+        # Either api.run() doesn't work well in case of a crash, or pytest interferes with it.
+        # Tweak output to prevent tests with empty expected output to pass in case of a crash.
+        output.append("!!! Mypy crashed !!!")
     if returncode == 0 and not output:
         # Execute the program.
         proc = subprocess.run(
diff --git a/mypy/type_visitor.py b/mypy/type_visitor.py
index c53243571..5a5643f35 100644
--- a/mypy/type_visitor.py
+++ b/mypy/type_visitor.py
@@ -35,7 +35,6 @@ from mypy.types import (
     PartialType,
     PlaceholderType,
     RawExpressionType,
-    StarType,
     TupleType,
     Type,
     TypeAliasType,
@@ -153,11 +152,8 @@ class TypeVisitor(Generic[T]):
 class SyntheticTypeVisitor(TypeVisitor[T]):
     """A TypeVisitor that also knows how to visit synthetic AST constructs.
 
-    Not just real types."""
-
-    @abstractmethod
-    def visit_star_type(self, t: StarType) -> T:
-        pass
+    Not just real types.
+    """
 
     @abstractmethod
     def visit_type_list(self, t: TypeList) -> T:
@@ -386,9 +382,6 @@ class TypeQuery(SyntheticTypeVisitor[T]):
     def visit_literal_type(self, t: LiteralType) -> T:
         return self.strategy([])
 
-    def visit_star_type(self, t: StarType) -> T:
-        return t.type.accept(self)
-
     def visit_union_type(self, t: UnionType) -> T:
         return self.query_types(t.items)
 
@@ -529,9 +522,6 @@ class BoolTypeQuery(SyntheticTypeVisitor[bool]):
     def visit_literal_type(self, t: LiteralType) -> bool:
         return self.default
 
-    def visit_star_type(self, t: StarType) -> bool:
-        return t.type.accept(self)
-
     def visit_union_type(self, t: UnionType) -> bool:
         return self.query_types(t.items)
 
diff --git a/mypy/typeanal.py b/mypy/typeanal.py
index 2cd136e53..f3329af62 100644
--- a/mypy/typeanal.py
+++ b/mypy/typeanal.py
@@ -64,7 +64,6 @@ from mypy.types import (
     PlaceholderType,
     RawExpressionType,
     RequiredType,
-    StarType,
     SyntheticTypeVisitor,
     TrivialSyntheticTypeTranslator,
     TupleType,
@@ -1031,17 +1030,7 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
                     code=codes.SYNTAX,
                 )
             return AnyType(TypeOfAny.from_error)
-        star_count = sum(1 for item in t.items if isinstance(item, StarType))
-        if star_count > 1:
-            self.fail("At most one star type allowed in a tuple", t)
-            if t.implicit:
-                return TupleType(
-                    [AnyType(TypeOfAny.from_error) for _ in t.items],
-                    self.named_type("builtins.tuple"),
-                    t.line,
-                )
-            else:
-                return AnyType(TypeOfAny.from_error)
+
         any_type = AnyType(TypeOfAny.special_form)
         # If the fallback isn't filled in yet, its type will be the falsey FakeInfo
         fallback = (
@@ -1093,9 +1082,6 @@ class TypeAnalyser(SyntheticTypeVisitor[Type], TypeAnalyzerPluginInterface):
     def visit_literal_type(self, t: LiteralType) -> Type:
         return t
 
-    def visit_star_type(self, t: StarType) -> Type:
-        return StarType(self.anal_type(t.type), t.line)
-
     def visit_union_type(self, t: UnionType) -> Type:
         if (
             t.uses_pep604_syntax is True
diff --git a/mypy/types.py b/mypy/types.py
index 90d33839c..6c036ccac 100644
--- a/mypy/types.py
+++ b/mypy/types.py
@@ -2592,28 +2592,6 @@ class LiteralType(ProperType):
         return self.is_enum_literal() or isinstance(self.value, bool)
 
 
-class StarType(ProperType):
-    """The star type *type_parameter.
-
-    This is not a real type but a syntactic AST construct.
-    """
-
-    __slots__ = ("type",)
-
-    type: Type
-
-    def __init__(self, type: Type, line: int = -1, column: int = -1) -> None:
-        super().__init__(line, column)
-        self.type = type
-
-    def accept(self, visitor: TypeVisitor[T]) -> T:
-        assert isinstance(visitor, SyntheticTypeVisitor)
-        return cast(T, visitor.visit_star_type(self))
-
-    def serialize(self) -> JsonDict:
-        assert False, "Synthetic types don't serialize"
-
-
 class UnionType(ProperType):
     """The union type Union[T1, ..., Tn] (at least one type argument)."""
 
@@ -3185,10 +3163,6 @@ class TypeStrVisitor(SyntheticTypeVisitor[str]):
     def visit_literal_type(self, t: LiteralType) -> str:
         return f"Literal[{t.value_repr()}]"
 
-    def visit_star_type(self, t: StarType) -> str:
-        s = t.type.accept(self)
-        return f"*{s}"
-
     def visit_union_type(self, t: UnionType) -> str:
         s = self.list_str(t.items)
         return f"Union[{s}]"
@@ -3245,9 +3219,6 @@ class TrivialSyntheticTypeTranslator(TypeTranslator, SyntheticTypeVisitor[Type])
     def visit_raw_expression_type(self, t: RawExpressionType) -> Type:
         return t
 
-    def visit_star_type(self, t: StarType) -> Type:
-        return t
-
     def visit_type_list(self, t: TypeList) -> Type:
         return t
 
diff --git a/mypy/typetraverser.py b/mypy/typetraverser.py
index 9c4a9157a..d9ab54871 100644
--- a/mypy/typetraverser.py
+++ b/mypy/typetraverser.py
@@ -20,7 +20,6 @@ from mypy.types import (
     PartialType,
     PlaceholderType,
     RawExpressionType,
-    StarType,
     SyntheticTypeVisitor,
     TupleType,
     Type,
@@ -115,9 +114,6 @@ class TypeTraverserVisitor(SyntheticTypeVisitor[None]):
     def visit_type_list(self, t: TypeList) -> None:
         self.traverse_types(t.items)
 
-    def visit_star_type(self, t: StarType) -> None:
-        t.type.accept(self)
-
     def visit_ellipsis_type(self, t: EllipsisType) -> None:
         pass
 
diff --git a/test-data/unit/pythoneval.test b/test-data/unit/pythoneval.test
index 9197e2f97..fbbaecbba 100644
--- a/test-data/unit/pythoneval.test
+++ b/test-data/unit/pythoneval.test
@@ -1901,3 +1901,26 @@ a[x]
 _testNativeIntTypes.py:14: error: Unsupported operand types for + ("i64" and "i32")
 _testNativeIntTypes.py:15: note: Revealed type is "mypy_extensions.i64"
 _testNativeIntTypes.py:16: note: Revealed type is "mypy_extensions.i64"
+
+[case testStarUnpackNestedUnderscore]
+from typing import Tuple, Dict, List
+
+def crash() -> None:
+    d: Dict[int, Tuple[str, int, str]] = {}
+    k, (v1, *_) = next(iter(d.items()))
+
+def test1() -> None:
+    vs: List[str]
+    d: Dict[int, Tuple[str, int, int]] = {}
+    k, (v1, *vs) = next(iter(d.items()))
+    reveal_type(vs)
+
+def test2() -> None:
+    d: Dict[int, Tuple[str, int, str]] = {}
+    k, (v1, *vs) = next(iter(d.items()))
+    reveal_type(vs)
+[out]
+_testStarUnpackNestedUnderscore.py:10: error: List item 0 has incompatible type "int"; expected "str"
+_testStarUnpackNestedUnderscore.py:10: error: List item 1 has incompatible type "int"; expected "str"
+_testStarUnpackNestedUnderscore.py:11: note: Revealed type is "builtins.list[builtins.str]"
+_testStarUnpackNestedUnderscore.py:16: note: Revealed type is "builtins.list[builtins.object]"
