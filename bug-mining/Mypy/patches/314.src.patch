diff --git a/mypy/message_registry.py b/mypy/message_registry.py
index 964ad62e4..b5c868f3f 100644
--- a/mypy/message_registry.py
+++ b/mypy/message_registry.py
@@ -268,6 +268,7 @@ CLASS_PATTERN_KEYWORD_MATCHES_POSITIONAL: Final = (
 )
 CLASS_PATTERN_DUPLICATE_KEYWORD_PATTERN: Final = 'Duplicate keyword pattern "{}"'
 CLASS_PATTERN_UNKNOWN_KEYWORD: Final = 'Class "{}" has no attribute "{}"'
+CLASS_PATTERN_CLASS_OR_STATIC_METHOD: Final = "Cannot have both classmethod and staticmethod"
 MULTIPLE_ASSIGNMENTS_IN_PATTERN: Final = 'Multiple assignments to name "{}" in pattern'
 CANNOT_MODIFY_MATCH_ARGS: Final = 'Cannot assign to "__match_args__"'
 
diff --git a/mypy/semanal.py b/mypy/semanal.py
index ad470fbfd..c712b506c 100644
--- a/mypy/semanal.py
+++ b/mypy/semanal.py
@@ -1548,6 +1548,8 @@ class SemanticAnalyzer(
             self.fail("Only instance methods can be decorated with @property", dec)
         if dec.func.abstract_status == IS_ABSTRACT and dec.func.is_final:
             self.fail(f"Method {dec.func.name} is both abstract and final", dec)
+        if dec.func.is_static and dec.func.is_class:
+            self.fail(message_registry.CLASS_PATTERN_CLASS_OR_STATIC_METHOD, dec)
 
     def check_decorated_function_is_method(self, decorator: str, context: Context) -> None:
         if not self.type or self.is_func_scope():
diff --git a/test-data/unit/check-classes.test b/test-data/unit/check-classes.test
index 9e45da717..a33f8b0e6 100644
--- a/test-data/unit/check-classes.test
+++ b/test-data/unit/check-classes.test
@@ -1395,6 +1395,13 @@ main:8: note:          def f(cls) -> None
 main:8: note:      Subclass:
 main:8: note:          def f(self) -> None
 
+[case testClassMethodAndStaticMethod]
+class C:
+  @classmethod  # E: Cannot have both classmethod and staticmethod
+  @staticmethod
+  def foo(cls) -> None: pass
+[builtins fixtures/classmethod.pyi]
+
 -- Properties
 -- ----------
 
