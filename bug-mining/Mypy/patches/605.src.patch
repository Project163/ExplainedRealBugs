diff --git a/mypy/meet.py b/mypy/meet.py
index 7a44feabc..2e238be77 100644
--- a/mypy/meet.py
+++ b/mypy/meet.py
@@ -128,18 +128,28 @@ def narrow_declared_type(declared: Type, narrowed: Type) -> Type:
     if declared == narrowed:
         return original_declared
     if isinstance(declared, UnionType):
+        declared_items = declared.relevant_items()
+        if isinstance(narrowed, UnionType):
+            narrowed_items = narrowed.relevant_items()
+        else:
+            narrowed_items = [narrowed]
         return make_simplified_union(
             [
-                narrow_declared_type(x, narrowed)
-                for x in declared.relevant_items()
+                narrow_declared_type(d, n)
+                for d in declared_items
+                for n in narrowed_items
                 # This (ugly) special-casing is needed to support checking
                 # branches like this:
                 # x: Union[float, complex]
                 # if isinstance(x, int):
                 #     ...
+                # And assignments like this:
+                # x: float | None
+                # y: int | None
+                # x = y
                 if (
-                    is_overlapping_types(x, narrowed, ignore_promotions=True)
-                    or is_subtype(narrowed, x, ignore_promotions=False)
+                    is_overlapping_types(d, n, ignore_promotions=True)
+                    or is_subtype(n, d, ignore_promotions=False)
                 )
             ]
         )
diff --git a/test-data/unit/check-narrowing.test b/test-data/unit/check-narrowing.test
index e322bd7a3..7fffd3ce9 100644
--- a/test-data/unit/check-narrowing.test
+++ b/test-data/unit/check-narrowing.test
@@ -2446,6 +2446,39 @@ while x is not None and b():
     x = f()
 [builtins fixtures/primitives.pyi]
 
+[case testNarrowPromotionsInsideUnions1]
+
+from typing import Union
+
+x: Union[str, float, None]
+y: Union[int, str]
+x = y
+reveal_type(x)  # N: Revealed type is "Union[builtins.str, builtins.int]"
+z: Union[complex, str]
+z = x
+reveal_type(z)  # N: Revealed type is "Union[builtins.int, builtins.str]"
+
+[builtins fixtures/primitives.pyi]
+
+[case testNarrowPromotionsInsideUnions2]
+# flags: --warn-unreachable
+
+from typing import Optional
+
+def b() -> bool: ...
+def i() -> int: ...
+x: Optional[float]
+
+while b():
+    x = None
+    while b():
+        reveal_type(x)  # N: Revealed type is "Union[None, builtins.int]"
+        if x is None or b():
+            x = i()
+            reveal_type(x)  # N: Revealed type is "builtins.int"
+
+[builtins fixtures/bool.pyi]
+
 [case testAvoidFalseUnreachableInFinally]
 # flags: --allow-redefinition-new --local-partial-types --warn-unreachable
 def f() -> None:
