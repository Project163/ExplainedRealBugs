diff --git a/docs/source/metaclasses.rst b/docs/source/metaclasses.rst
index a5d16aa72..396d7dbb4 100644
--- a/docs/source/metaclasses.rst
+++ b/docs/source/metaclasses.rst
@@ -72,12 +72,15 @@ so it's better not to combine metaclasses and class hierarchies:
     class A1(metaclass=M1): pass
     class A2(metaclass=M2): pass
 
-    class B1(A1, metaclass=M2): pass  # Mypy Error: Inconsistent metaclass structure for "B1"
+    class B1(A1, metaclass=M2): pass  # Mypy Error: metaclass conflict
     # At runtime the above definition raises an exception
     # TypeError: metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
 
-    # Same runtime error as in B1, but mypy does not catch it yet
-    class B12(A1, A2): pass
+    class B12(A1, A2): pass  # Mypy Error: metaclass conflict
+
+    # This can be solved via a common metaclass subtype:
+    class CorrectMeta(M1, M2): pass
+    class B2(A1, A2, metaclass=CorrectMeta): pass  # OK, runtime is also OK
 
 * Mypy does not understand dynamically-computed metaclasses,
   such as ``class A(metaclass=f()): ...``
diff --git a/mypy/checker.py b/mypy/checker.py
index 1c5b834c1..7eb58f5b3 100644
--- a/mypy/checker.py
+++ b/mypy/checker.py
@@ -2044,6 +2044,7 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
             if not defn.has_incompatible_baseclass:
                 # Otherwise we've already found errors; more errors are not useful
                 self.check_multiple_inheritance(typ)
+            self.check_metaclass_compatibility(typ)
             self.check_final_deletable(typ)
 
             if defn.decorators:
@@ -2383,6 +2384,35 @@ class TypeChecker(NodeVisitor[None], CheckerPluginInterface):
         if not ok:
             self.msg.base_class_definitions_incompatible(name, base1, base2, ctx)
 
+    def check_metaclass_compatibility(self, typ: TypeInfo) -> None:
+        """Ensures that metaclasses of all parent types are compatible."""
+        if (
+            typ.is_metaclass()
+            or typ.is_protocol
+            or typ.is_named_tuple
+            or typ.is_enum
+            or typ.typeddict_type is not None
+        ):
+            return  # Reasonable exceptions from this check
+
+        metaclasses = [
+            entry.metaclass_type
+            for entry in typ.mro[1:-1]
+            if entry.metaclass_type
+            and not is_named_instance(entry.metaclass_type, "builtins.type")
+        ]
+        if not metaclasses:
+            return
+        if typ.metaclass_type is not None and all(
+            is_subtype(typ.metaclass_type, meta) for meta in metaclasses
+        ):
+            return
+        self.fail(
+            "Metaclass conflict: the metaclass of a derived class must be "
+            "a (non-strict) subclass of the metaclasses of all its bases",
+            typ,
+        )
+
     def visit_import_from(self, node: ImportFrom) -> None:
         self.check_import(node)
 
diff --git a/mypy/semanal.py b/mypy/semanal.py
index 7e428f06e..4a9cb290b 100644
--- a/mypy/semanal.py
+++ b/mypy/semanal.py
@@ -2120,18 +2120,10 @@ class SemanticAnalyzer(
                 abc_meta = self.named_type_or_none("abc.ABCMeta", [])
                 if abc_meta is not None:  # May be None in tests with incomplete lib-stub.
                     defn.info.metaclass_type = abc_meta
-        if declared_metaclass is not None and defn.info.metaclass_type is None:
-            # Inconsistency may happen due to multiple baseclasses even in classes that
-            # do not declare explicit metaclass, but it's harder to catch at this stage
-            if defn.metaclass is not None:
-                self.fail(f'Inconsistent metaclass structure for "{defn.name}"', defn)
-        else:
-            if defn.info.metaclass_type and defn.info.metaclass_type.type.has_base(
-                "enum.EnumMeta"
-            ):
-                defn.info.is_enum = True
-                if defn.type_vars:
-                    self.fail("Enum class cannot be generic", defn)
+        if defn.info.metaclass_type and defn.info.metaclass_type.type.has_base("enum.EnumMeta"):
+            defn.info.is_enum = True
+            if defn.type_vars:
+                self.fail("Enum class cannot be generic", defn)
 
     #
     # Imports
diff --git a/test-data/unit/check-classes.test b/test-data/unit/check-classes.test
index 9bf2bbd83..a3c0b79e0 100644
--- a/test-data/unit/check-classes.test
+++ b/test-data/unit/check-classes.test
@@ -4351,7 +4351,7 @@ class C(B):
 class X(type): pass
 class Y(type): pass
 class A(metaclass=X): pass
-class B(A, metaclass=Y): pass  # E: Inconsistent metaclass structure for "B"
+class B(A, metaclass=Y): pass  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
 
 [case testMetaclassNoTypeReveal]
 class M:
@@ -5213,8 +5213,8 @@ class CD(six.with_metaclass(M)): pass  # E: Multiple metaclass definitions
 class M1(type): pass
 class Q1(metaclass=M1): pass
 @six.add_metaclass(M)
-class CQA(Q1): pass  # E: Inconsistent metaclass structure for "CQA"
-class CQW(six.with_metaclass(M, Q1)): pass  # E: Inconsistent metaclass structure for "CQW"
+class CQA(Q1): pass  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+class CQW(six.with_metaclass(M, Q1)): pass  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
 [builtins fixtures/tuple.pyi]
 
 [case testSixMetaclassAny]
@@ -5319,7 +5319,7 @@ class C5(future.utils.with_metaclass(f())): pass  # E: Dynamic metaclass not sup
 
 class M1(type): pass
 class Q1(metaclass=M1): pass
-class CQW(future.utils.with_metaclass(M, Q1)): pass  # E: Inconsistent metaclass structure for "CQW"
+class CQW(future.utils.with_metaclass(M, Q1)): pass  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
 [builtins fixtures/tuple.pyi]
 
 [case testFutureMetaclassAny]
@@ -6718,6 +6718,39 @@ class Meta(A): pass
 from m import Meta
 class A(metaclass=Meta): pass
 
+[case testMetaclassConflict]
+class MyMeta1(type): ...
+class MyMeta2(type): ...
+class MyMeta3(type): ...
+class A(metaclass=MyMeta1): ...
+class B(metaclass=MyMeta2): ...
+class C(metaclass=type): ...
+class A1(A): ...
+class E: ...
+
+class CorrectMeta(MyMeta1, MyMeta2): ...
+class CorrectSubclass1(A1, B, E, metaclass=CorrectMeta): ...
+class CorrectSubclass2(A, B, E, metaclass=CorrectMeta): ...
+class CorrectSubclass3(B, A, metaclass=CorrectMeta): ...
+
+class ChildOfCorrectSubclass1(CorrectSubclass1): ...
+
+class CorrectWithType1(C, A1): ...
+class CorrectWithType2(B, C): ...
+
+class Conflict1(A1, B, E): ...  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+class Conflict2(A, B): ...  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+class Conflict3(B, A): ...  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+
+class ChildOfConflict1(Conflict3): ...  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+class ChildOfConflict2(Conflict3, metaclass=CorrectMeta): ...
+
+class ConflictingMeta(MyMeta1, MyMeta3): ...
+class Conflict4(A1, B, E, metaclass=ConflictingMeta): ...  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+
+class ChildOfCorrectButWrongMeta(CorrectSubclass1, metaclass=ConflictingMeta):  # E: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
+    ...
+
 [case testGenericOverride]
 from typing import Generic, TypeVar, Any
 
diff --git a/test-data/unit/fine-grained.test b/test-data/unit/fine-grained.test
index 8e07deb8c..9d8857301 100644
--- a/test-data/unit/fine-grained.test
+++ b/test-data/unit/fine-grained.test
@@ -2968,7 +2968,7 @@ class M(type):
     pass
 [out]
 ==
-a.py:3: error: Inconsistent metaclass structure for "D"
+a.py:3: error: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
 
 [case testFineMetaclassDeclaredUpdate]
 import a
@@ -2984,7 +2984,7 @@ class M(type): pass
 class M2(type): pass
 [out]
 ==
-a.py:3: error: Inconsistent metaclass structure for "D"
+a.py:3: error: Metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of the metaclasses of all its bases
 
 [case testFineMetaclassRemoveFromClass]
 import a
