diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/FileUploadCleaner.java b/wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaner.java
similarity index 82%
rename from wicket-util/src/main/java/org/apache/wicket/util/file/FileUploadCleaner.java
rename to wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaner.java
index c5bace59d0..e5c35c0c3f 100644
--- a/wicket-util/src/main/java/org/apache/wicket/util/file/FileUploadCleaner.java
+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaner.java
@@ -19,35 +19,34 @@ package org.apache.wicket.util.file;
 import java.io.File;
 
 /**
- * Default implementation of {@link IFileUploadCleaner} that uses Apache commons-io
+ * Default implementation of {@link IFileCleaner} that uses Apache commons-io
  * {@link FileCleaningTracker} to track and clean the temporary created files.
  * <p>
  * Note: this implementation starts a daemon thread to do the actual work, so it may not be used in
  * some environments like Google AppEngine.
  */
-public class FileUploadCleaner implements IFileUploadCleaner
+public class FileCleaner implements IFileCleaner
 {
 	private final FileCleaningTracker cleaner;
 
 	/**
 	 * Construct.
 	 */
-	public FileUploadCleaner()
+	public FileCleaner()
 	{
 		cleaner = new FileCleaningTracker();
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
 	public void track(final File file, final Object marker)
 	{
 		cleaner.track(file, marker);
 	}
 
-	/**
-	 * {@inheritDoc}
-	 */
+	public void track(final File file, final Object marker, FileDeleteStrategy deleteStrategy)
+	{
+		cleaner.track(file, marker, deleteStrategy);
+	}
+
 	public void destroy()
 	{
 		cleaner.exitWhenFinished();
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java b/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java
index b4ec001e83..3b5b97ce66 100644
--- a/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java
+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/Files.java
@@ -103,49 +103,42 @@ public class Files
 	}
 
 	/**
-	 * Deletes a file.
+	 * Deletes a normal file.
 	 * <p>
-	 * If the file cannot be deleted for any reason then at most 10 retries are attempted with delay
-	 * of 100ms. If the file still cannot be deleted then it is scheduled to be deleted at JVM exit
-	 * time.
+	 * If the file cannot be deleted for any reason then at most 50 retries are attempted with delay
+	 * of 100ms at each 10th attempt.
 	 * 
 	 * @param file
-	 *            File to delete
-	 * @return {@code true} if file was deleted, {@code false} if the file didn't exist or it cannot
-	 *         be removed for some reason
+	 *            the file to delete
+	 * @return {@code true} if file was deleted, {@code false} if the file don't exist, is a folder
+	 *         or cannot be removed for some reason
 	 */
 	public static boolean remove(final java.io.File file)
 	{
-		if (file == null || file.exists() == false || file.isDirectory())
+		if (file != null && file.isFile())
 		{
-			return false;
-		}
-
-		int retries = 10;
-
-		boolean deleted = false;
-
-		while ((deleted = file.delete()) == false && retries > 0)
-		{
-			retries--;
-			try
+			for (int j = 0; j < 5; ++j)
 			{
-				Thread.sleep(100);
-			}
-			catch (InterruptedException ignored)
-			{
-			}
-		}
+				for (int i = 0; i < 10; ++i)
+				{
+					if (file.delete())
+					{
+						return true;
+					}
 
-		if (deleted == false && logger.isWarnEnabled())
-		{
-			logger.warn(
-				"Cannot delete file '{}' for unknown reason. The file will be scheduled for deletion at JVM exit time.",
-				file);
-			file.deleteOnExit();
+					try
+					{
+						Thread.sleep(100);
+					}
+					catch (InterruptedException ix)
+					{
+						Thread.currentThread().interrupt();
+					}
+				}
+			}
 		}
 
-		return deleted;
+		return false;
 	}
 
 	/**
@@ -186,6 +179,55 @@ public class Files
 		return folder.delete();
 	}
 
+	/**
+	 * Schedules a file for removal asynchronously.
+	 * 
+	 * @param file
+	 *            the file to be removed
+	 * @param fileCleaner
+	 *            the file cleaner that will be used to remove the file
+	 * @return {@code false} if the {@code file} is <em>null</em> or a folder, {@code true} -
+	 *         otherwise (i.e. if it is scheduled)
+	 */
+	public static final boolean removeAsync(final File file, final IFileCleaner fileCleaner)
+	{
+		if (file == null || file.isDirectory())
+		{
+			return false;
+		}
+
+		Args.notNull(fileCleaner, "fileCleaner");
+
+		fileCleaner.track(file, new Object());
+
+		return true;
+	}
+
+
+	/**
+	 * Schedules a folder and all files inside it for asynchronous removal.
+	 * 
+	 * @param folder
+	 *            the folder to be removed
+	 * @param fileCleaner
+	 *            the file cleaner that will be used to remove the file
+	 * @return {@code false} if the {@code folder} is <em>null</em> or a normal file, {@code true} -
+	 *         otherwise (i.e. if it is scheduled)
+	 */
+	public static final boolean removeFolderAsync(final File folder, final IFileCleaner fileCleaner)
+	{
+		if (folder == null || folder.isFile())
+		{
+			return false;
+		}
+
+		Args.notNull(fileCleaner, "fileCleaner");
+
+		fileCleaner.track(folder, new Object(), new FolderDeleteStrategy());
+
+		return true;
+	}
+
 	/**
 	 * Writes the given input stream to the given file
 	 * 
@@ -386,30 +428,35 @@ public class Files
 	}
 
 	/**
-	 * Utility method for creating a directory
+	 * Utility method for creating a directory. If the creation didn't succeed for some reason then
+	 * at most 50 attempts are made with delay of 100ms at every 10th attempt.
 	 * 
-	 * @param file
+	 * @param folder
+	 *            the folder to create
+	 * @return {@code true} if the creation is successful, {@code false} - otherwise
 	 */
-	public static void mkdirs(File file)
+	public static boolean mkdirs(File folder)
 	{
 		// for some reason, simple file.mkdirs sometimes fails under heavy load
 		for (int j = 0; j < 5; ++j)
 		{
 			for (int i = 0; i < 10; ++i)
 			{
-				if (file.mkdirs())
+				if (folder.mkdirs())
 				{
-					return;
+					return true;
 				}
 			}
 			try
 			{
 				Thread.sleep(100);
 			}
-			catch (InterruptedException ignore)
+			catch (InterruptedException ix)
 			{
+				Thread.currentThread().interrupt();
 			}
 		}
-		logger.error("Failed to make directory " + file);
+		logger.error("Failed to create directory: " + folder);
+		return false;
 	}
 }
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/FolderDeleteStrategy.java b/wicket-util/src/main/java/org/apache/wicket/util/file/FolderDeleteStrategy.java
new file mode 100644
index 0000000000..88f067f406
--- /dev/null
+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/FolderDeleteStrategy.java
@@ -0,0 +1,83 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.wicket.util.file;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * A {@link FileDeleteStrategy} that can delete folders.
+ */
+public class FolderDeleteStrategy extends FileDeleteStrategy
+{
+	/**
+	 * Construct.
+	 * 
+	 * @param name
+	 */
+	protected FolderDeleteStrategy()
+	{
+		super("folder");
+	}
+
+	@Override
+	public boolean deleteQuietly(final File folder)
+	{
+		if (folder == null || folder.isFile())
+		{
+			return false;
+		}
+
+		File[] files = folder.listFiles();
+		if (files != null)
+		{
+			for (File file : files)
+			{
+				if (file.isDirectory())
+				{
+					deleteQuietly(file);
+				}
+				else
+				{
+					super.deleteQuietly(file);
+				}
+			}
+		}
+
+		return super.deleteQuietly(folder);
+	}
+
+	@Override
+	public void delete(final File folder) throws IOException
+	{
+		if (folder == null || folder.isFile())
+		{
+			return;
+		}
+
+		File[] files = folder.listFiles();
+		if (files != null)
+		{
+			for (File file : files)
+			{
+				super.delete(file);
+			}
+		}
+	}
+
+
+}
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/IFileUploadCleaner.java b/wicket-util/src/main/java/org/apache/wicket/util/file/IFileCleaner.java
similarity index 71%
rename from wicket-util/src/main/java/org/apache/wicket/util/file/IFileUploadCleaner.java
rename to wicket-util/src/main/java/org/apache/wicket/util/file/IFileCleaner.java
index 224a33cd9f..4da6633874 100644
--- a/wicket-util/src/main/java/org/apache/wicket/util/file/IFileUploadCleaner.java
+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/IFileCleaner.java
@@ -25,7 +25,7 @@ import java.io.File;
  * <p>
  * Needed to remove files created temporarily for the needs of FileUpload functionality.
  */
-public interface IFileUploadCleaner
+public interface IFileCleaner
 {
 
 	/**
@@ -41,6 +41,22 @@ public interface IFileUploadCleaner
 	 */
 	void track(File file, Object marker);
 
+	/**
+	 * Track the specified file, using the provided marker, deleting the file when the marker
+	 * instance is garbage collected.
+	 * 
+	 * @param file
+	 *            the file to be tracked, not null
+	 * @param marker
+	 *            the marker object used to track the file, not null
+	 * @param deleteStrategy
+	 *            the strategy that actually deletes the file. E.g. to delete a non-empty folder the
+	 *            strategy should delete all children first
+	 * @throws NullPointerException
+	 *             if the file is null
+	 */
+	void track(File file, Object marker, FileDeleteStrategy deleteStrategy);
+
 	/**
 	 * Call this method to stop the cleaner and to free all allocated resources by it
 	 */
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java b/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java
index 286b941fdc..b70371cff1 100644
--- a/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java
+++ b/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java
@@ -33,7 +33,7 @@ import java.util.Random;
 import java.util.UUID;
 
 import org.apache.wicket.util.file.Files;
-import org.apache.wicket.util.file.IFileUploadCleaner;
+import org.apache.wicket.util.file.IFileCleaner;
 import org.apache.wicket.util.io.DeferredFileOutputStream;
 import org.apache.wicket.util.io.IOUtils;
 import org.apache.wicket.util.io.Streams;
@@ -167,7 +167,7 @@ public class DiskFileItem implements FileItem, FileItemHeadersSupport
 	 * This is transient because it is needed only for the upload request lifetime to add this file
 	 * item in the tracker. After that the cleaner is not needed anymore.
 	 */
-	private transient final IFileUploadCleaner fileUploadCleaner;
+	private transient final IFileCleaner fileUploadCleaner;
 
 	/**
 	 * Constructs a new <code>DiskFileItem</code> instance.
@@ -191,7 +191,7 @@ public class DiskFileItem implements FileItem, FileItemHeadersSupport
 	 */
 	public DiskFileItem(final String fieldName, final String contentType,
 		final boolean isFormField, final String fileName, final int sizeThreshold,
-		final File repository, final IFileUploadCleaner fileUploadCleaner)
+		final File repository, final IFileCleaner fileUploadCleaner)
 	{
 		this.fieldName = fieldName;
 		this.contentType = contentType;
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java b/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java
index 2dc940050e..1e580c6caf 100644
--- a/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java
+++ b/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java
@@ -19,7 +19,7 @@ package org.apache.wicket.util.upload;
 import java.io.File;
 
 import org.apache.wicket.util.file.FileCleaningTracker;
-import org.apache.wicket.util.file.IFileUploadCleaner;
+import org.apache.wicket.util.file.IFileCleaner;
 
 
 /**
@@ -78,7 +78,7 @@ public class DiskFileItemFactory implements FileItemFactory
 	 */
 	private int sizeThreshold = DEFAULT_SIZE_THRESHOLD;
 
-	private final IFileUploadCleaner fileUploadCleaner;
+	private final IFileCleaner fileUploadCleaner;
 
 	// ----------------------------------------------------------- Constructors
 
@@ -89,7 +89,7 @@ public class DiskFileItemFactory implements FileItemFactory
 	 * 
 	 * @param fileUploadCleaner
 	 */
-	public DiskFileItemFactory(final IFileUploadCleaner fileUploadCleaner)
+	public DiskFileItemFactory(final IFileCleaner fileUploadCleaner)
 	{
 		this(DEFAULT_SIZE_THRESHOLD, null, fileUploadCleaner);
 	}
@@ -107,7 +107,7 @@ public class DiskFileItemFactory implements FileItemFactory
 	 * @param fileUploadCleaner
 	 */
 	public DiskFileItemFactory(final int sizeThreshold, final File repository,
-		final IFileUploadCleaner fileUploadCleaner)
+		final IFileCleaner fileUploadCleaner)
 	{
 		this.sizeThreshold = sizeThreshold;
 		this.repository = repository;
diff --git a/wicket-util/src/test/java/org/apache/wicket/util/file/FilesTest.java b/wicket-util/src/test/java/org/apache/wicket/util/file/FilesTest.java
index 2e69f44426..3f6e034f57 100644
--- a/wicket-util/src/test/java/org/apache/wicket/util/file/FilesTest.java
+++ b/wicket-util/src/test/java/org/apache/wicket/util/file/FilesTest.java
@@ -41,7 +41,7 @@ public class FilesTest extends Assert
 			"/somethingThatDoesntExistsOnMostMachines-111111111111111111111111111111")));
 
 		java.io.File file = java.io.File.createTempFile("wicket-test--", ".tmp");
-		assertTrue("The just created file should exist!", file.exists());
+		assertTrue("The just created file should exist!", file.isFile());
 
 		boolean removed = Files.remove(file);
 		assertFalse("The just removed file should not exist!", file.exists());
@@ -68,9 +68,9 @@ public class FilesTest extends Assert
 	@Test
 	public void removeFolder() throws Exception
 	{
-		assertFalse("'null' folders are not deleted.", Files.remove(null));
+		assertFalse("'null' folders are not deleted.", Files.removeFolder(null));
 
-		assertFalse("Non existing files are not deleted.", Files.removeFolder(new File(
+		assertFalse("Non existing folders are not deleted.", Files.removeFolder(new File(
 			"/somethingThatDoesntExistsOnMostMachines-111111111111111111111111111111")));
 
 		java.io.File folder = new File(System.getProperty("java.io.tmpdir"), "wicket-test-folder");
@@ -82,4 +82,68 @@ public class FilesTest extends Assert
 
 		assertTrue("Should be able to delete a folder.", Files.removeFolder(folder));
 	}
+
+	/**
+	 * Tests for {@link Files#removeAsync(java.io.File, IFileCleaner)}
+	 * 
+	 * @throws Exception
+	 */
+	@Test
+	public void removeAsync() throws Exception
+	{
+
+		IFileCleaner fileCleaner = new FileCleaner();
+
+		assertFalse("'null' files are not deleted.", Files.removeAsync(null, fileCleaner));
+
+		File nonExistingFile = new File(
+			"/somethingThatDoesntExistsOnMostMachines-111111111111111111111111111111");
+		assertTrue("Even non existing file are scheduled for deletion.",
+			Files.removeFolderAsync(nonExistingFile, fileCleaner));
+		assertFalse(nonExistingFile.exists());
+
+		java.io.File file = java.io.File.createTempFile("wicket-test--", ".tmp");
+		assertTrue("The just created file should exist!", file.exists());
+		file.createNewFile();
+		assertTrue(file.isFile());
+
+		assertTrue("The file is scheduled for deletion.", Files.removeAsync(file, fileCleaner));
+		// give chance to the file cleaner to run and delete the folder
+		System.gc();
+		Thread.sleep(5);
+		assertFalse("", file.exists());
+	}
+
+	/**
+	 * Tests for {@link Files#removeFolderAsync(java.io.File, IFileCleaner)}
+	 * 
+	 * @throws Exception
+	 */
+	@Test
+	public void removeFolderAsync() throws Exception
+	{
+		assertFalse("'null' folders are not deleted.", Files.removeFolderAsync(null, null));
+
+		IFileCleaner fileCleaner = new FileCleaner();
+
+		File nonExistingFolder = new File(
+			"/somethingThatDoesntExistsOnMostMachines-111111111111111111111111111111");
+		assertTrue("Even non existing folders are scheduled for deletion.",
+			Files.removeFolderAsync(nonExistingFolder, fileCleaner));
+		assertFalse(nonExistingFolder.exists());
+
+		java.io.File folder = new File(System.getProperty("java.io.tmpdir"), "wicket-test-folder");
+		Files.mkdirs(folder);
+		assertTrue(folder.isDirectory());
+		File file = new File(folder, "child");
+		file.createNewFile();
+		assertTrue(file.exists());
+
+		assertTrue("The folder is scheduled for deletion.",
+			Files.removeFolderAsync(folder, fileCleaner));
+		// give chance to the file cleaner to run and delete the folder
+		System.gc();
+		Thread.sleep(5);
+		assertFalse("", folder.exists());
+	}
 }
