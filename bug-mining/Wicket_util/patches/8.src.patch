diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaner.java b/wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaner.java
deleted file mode 100644
index 8656fe61fb..0000000000
--- a/wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaner.java
+++ /dev/null
@@ -1,196 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.wicket.util.file;
-
-import java.io.File;
-import java.lang.ref.PhantomReference;
-import java.lang.ref.ReferenceQueue;
-import java.util.Collection;
-import java.util.Vector;
-
-/**
- * Keeps track of files awaiting deletion, and deletes them when an associated marker object is
- * reclaimed by the garbage collector.
- * 
- * @author Noel Bergman
- * @author Martin Cooper
- */
-public class FileCleaner
-{
-	/**
-	 * Queue of <code>Tracker</code> instances being watched.
-	 */
-	private static final ReferenceQueue /* Tracker */q = new ReferenceQueue();
-
-	/**
-	 * Collection of <code>Tracker</code> instances in existence.
-	 */
-	private static Collection /* Tracker */trackers = new Vector();
-
-	/**
-	 * The thread that will clean up registered files.
-	 */
-	private static Thread reaper = new Thread("File Reaper")
-	{
-		/**
-		 * Run the reaper thread that will delete files as their associated marker objects are
-		 * reclaimed by the garbage collector.
-		 */
-		@Override
-		public void run()
-		{
-			// Though q is final, it happens while hot deploying that Wicket runs into an infinite
-			// loop because q == null (NullPointerException). To prevent that happening ...
-			while (q != null)
-			{
-				Tracker tracker = null;
-				try
-				{
-					// Wait for a tracker to remove.
-					tracker = (Tracker)q.remove();
-				}
-				catch (InterruptedException e)
-				{
-					break;
-				}
-				catch (Exception e)
-				{
-					continue;
-				}
-
-				tracker.delete();
-				tracker.clear();
-				trackers.remove(tracker);
-			}
-		}
-	};
-
-	/**
-	 * The static initializer that starts the reaper thread.
-	 */
-	static
-	{
-		reaper.setPriority(Thread.MAX_PRIORITY);
-		reaper.setDaemon(true);
-		reaper.start();
-	}
-
-	/**
-	 * Stop the daemon thread
-	 */
-	public static void destroy()
-	{
-		if (reaper != null)
-		{
-			reaper.interrupt();
-
-			// TODO Do we need to manually remove the temp files now?
-		}
-	}
-
-	/**
-	 * Track the specified file, using the provided marker, deleting the file when the marker
-	 * instance is garbage collected.
-	 * 
-	 * @param file
-	 *            The file to be tracked.
-	 * @param marker
-	 *            The marker object used to track the file.
-	 */
-	public static void track(final File file, final Object marker)
-	{
-		trackers.add(new Tracker(file, marker, q));
-	}
-
-	/**
-	 * Track the specified file, using the provided marker, deleting the file when the marker
-	 * instance is garbage collected.
-	 * 
-	 * @param path
-	 *            The full path to the file to be tracked.
-	 * @param marker
-	 *            The marker object used to track the file.
-	 */
-	public static void track(final String path, final Object marker)
-	{
-		trackers.add(new Tracker(path, marker, q));
-	}
-
-	/**
-	 * Retrieve the number of files currently being tracked, and therefore awaiting deletion.
-	 * 
-	 * @return the number of files being tracked.
-	 */
-	public static int getTrackCount()
-	{
-		return trackers.size();
-	}
-
-	/**
-	 * Inner class which acts as the reference for a file pending deletion.
-	 */
-	private static class Tracker extends PhantomReference
-	{
-
-		/**
-		 * The full path to the file being tracked.
-		 */
-		private final String path;
-
-		/**
-		 * Constructs an instance of this class from the supplied parameters.
-		 * 
-		 * @param file
-		 *            The file to be tracked.
-		 * @param marker
-		 *            The marker object used to track the file.
-		 * @param queue
-		 *            The queue on to which the tracker will be pushed.
-		 */
-		public Tracker(final File file, final Object marker, final ReferenceQueue queue)
-		{
-			this(file.getPath(), marker, queue);
-		}
-
-		/**
-		 * Constructs an instance of this class from the supplied parameters.
-		 * 
-		 * @param path
-		 *            The full path to the file to be tracked.
-		 * @param marker
-		 *            The marker object used to track the file.
-		 * @param queue
-		 *            The queue on to which the tracker will be pushed.
-		 */
-		public Tracker(final String path, final Object marker, final ReferenceQueue queue)
-		{
-			super(marker, queue);
-			this.path = path;
-		}
-
-		/**
-		 * Deletes the file associated with this tracker instance.
-		 * 
-		 * @return <code>true</code> if the file was deleted successfully; <code>false</code>
-		 *         otherwise.
-		 */
-		public boolean delete()
-		{
-			return new File(path).delete();
-		}
-	}
-}
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaningTracker.java b/wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaningTracker.java
new file mode 100644
index 0000000000..5661ff3886
--- /dev/null
+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/FileCleaningTracker.java
@@ -0,0 +1,331 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.wicket.util.file;
+
+import java.io.File;
+import java.lang.ref.PhantomReference;
+import java.lang.ref.ReferenceQueue;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.List;
+
+/**
+ * Keeps track of files awaiting deletion, and deletes them when an associated marker object is
+ * reclaimed by the garbage collector.
+ * <p>
+ * This utility creates a background thread to handle file deletion. Each file to be deleted is
+ * registered with a handler object. When the handler object is garbage collected, the file is
+ * deleted.
+ * <p>
+ * In an environment with multiple class loaders (a servlet container, for example), you should
+ * consider stopping the background thread if it is no longer needed. This is done by invoking the
+ * method {@link #exitWhenFinished}, typically in
+ * {@link javax.servlet.ServletContextListener#contextDestroyed} or similar.
+ * 
+ * @author Noel Bergman
+ * @author Martin Cooper
+ * @version $Id$
+ */
+public class FileCleaningTracker
+{
+	/**
+	 * Queue of <code>Tracker</code> instances being watched.
+	 */
+	ReferenceQueue<Object> q = new ReferenceQueue<Object>();
+	/**
+	 * Collection of <code>Tracker</code> instances in existence.
+	 */
+	final Collection<Tracker> trackers = Collections.synchronizedSet(new HashSet<Tracker>()); // synchronized
+	/**
+	 * Collection of File paths that failed to delete.
+	 */
+	final List<String> deleteFailures = Collections.synchronizedList(new ArrayList<String>());
+	/**
+	 * Whether to terminate the thread when the tracking is complete.
+	 */
+	volatile boolean exitWhenFinished = false;
+	/**
+	 * The thread that will clean up registered files.
+	 */
+	Thread reaper;
+
+	// -----------------------------------------------------------------------
+	/**
+	 * Track the specified file, using the provided marker, deleting the file when the marker
+	 * instance is garbage collected. The {@link FileDeleteStrategy#NORMAL normal} deletion strategy
+	 * will be used.
+	 * 
+	 * @param file
+	 *            the file to be tracked, not null
+	 * @param marker
+	 *            the marker object used to track the file, not null
+	 * @throws NullPointerException
+	 *             if the file is null
+	 */
+	public void track(File file, Object marker)
+	{
+		track(file, marker, (FileDeleteStrategy)null);
+	}
+
+	/**
+	 * Track the specified file, using the provided marker, deleting the file when the marker
+	 * instance is garbage collected. The speified deletion strategy is used.
+	 * 
+	 * @param file
+	 *            the file to be tracked, not null
+	 * @param marker
+	 *            the marker object used to track the file, not null
+	 * @param deleteStrategy
+	 *            the strategy to delete the file, null means normal
+	 * @throws NullPointerException
+	 *             if the file is null
+	 */
+	public void track(File file, Object marker, FileDeleteStrategy deleteStrategy)
+	{
+		if (file == null)
+		{
+			throw new NullPointerException("The file must not be null");
+		}
+		addTracker(file.getPath(), marker, deleteStrategy);
+	}
+
+	/**
+	 * Track the specified file, using the provided marker, deleting the file when the marker
+	 * instance is garbage collected. The {@link FileDeleteStrategy#NORMAL normal} deletion strategy
+	 * will be used.
+	 * 
+	 * @param path
+	 *            the full path to the file to be tracked, not null
+	 * @param marker
+	 *            the marker object used to track the file, not null
+	 * @throws NullPointerException
+	 *             if the path is null
+	 */
+	public void track(String path, Object marker)
+	{
+		track(path, marker, (FileDeleteStrategy)null);
+	}
+
+	/**
+	 * Track the specified file, using the provided marker, deleting the file when the marker
+	 * instance is garbage collected. The speified deletion strategy is used.
+	 * 
+	 * @param path
+	 *            the full path to the file to be tracked, not null
+	 * @param marker
+	 *            the marker object used to track the file, not null
+	 * @param deleteStrategy
+	 *            the strategy to delete the file, null means normal
+	 * @throws NullPointerException
+	 *             if the path is null
+	 */
+	public void track(String path, Object marker, FileDeleteStrategy deleteStrategy)
+	{
+		if (path == null)
+		{
+			throw new NullPointerException("The path must not be null");
+		}
+		addTracker(path, marker, deleteStrategy);
+	}
+
+	/**
+	 * Adds a tracker to the list of trackers.
+	 * 
+	 * @param path
+	 *            the full path to the file to be tracked, not null
+	 * @param marker
+	 *            the marker object used to track the file, not null
+	 * @param deleteStrategy
+	 *            the strategy to delete the file, null means normal
+	 */
+	private synchronized void addTracker(String path, Object marker,
+		FileDeleteStrategy deleteStrategy)
+	{
+		// synchronized block protects reaper
+		if (exitWhenFinished)
+		{
+			throw new IllegalStateException(
+				"No new trackers can be added once exitWhenFinished() is called");
+		}
+		if (reaper == null)
+		{
+			reaper = new Reaper();
+			reaper.start();
+		}
+		trackers.add(new Tracker(path, deleteStrategy, marker, q));
+	}
+
+	// -----------------------------------------------------------------------
+	/**
+	 * Retrieve the number of files currently being tracked, and therefore awaiting deletion.
+	 * 
+	 * @return the number of files being tracked
+	 */
+	public int getTrackCount()
+	{
+		return trackers.size();
+	}
+
+	/**
+	 * Return the file paths that failed to delete.
+	 * 
+	 * @return the file paths that failed to delete
+	 * @since Commons IO 2.0
+	 */
+	public List<String> getDeleteFailures()
+	{
+		return deleteFailures;
+	}
+
+	/**
+	 * Call this method to cause the file cleaner thread to terminate when there are no more objects
+	 * being tracked for deletion.
+	 * <p>
+	 * In a simple environment, you don't need this method as the file cleaner thread will simply
+	 * exit when the JVM exits. In a more complex environment, with multiple class loaders (such as
+	 * an application server), you should be aware that the file cleaner thread will continue
+	 * running even if the class loader it was started from terminates. This can consitute a memory
+	 * leak.
+	 * <p>
+	 * For example, suppose that you have developed a web application, which contains the commons-io
+	 * jar file in your WEB-INF/lib directory. In other words, the FileCleaner class is loaded
+	 * through the class loader of your web application. If the web application is terminated, but
+	 * the servlet container is still running, then the file cleaner thread will still exist, posing
+	 * a memory leak.
+	 * <p>
+	 * This method allows the thread to be terminated. Simply call this method in the resource
+	 * cleanup code, such as {@link javax.servlet.ServletContextListener#contextDestroyed}. Once
+	 * called, no new objects can be tracked by the file cleaner.
+	 */
+	public synchronized void exitWhenFinished()
+	{
+		// synchronized block protects reaper
+		exitWhenFinished = true;
+		if (reaper != null)
+		{
+			synchronized (reaper)
+			{
+				reaper.interrupt();
+			}
+		}
+	}
+
+	// -----------------------------------------------------------------------
+	/**
+	 * The reaper thread.
+	 */
+	private final class Reaper extends Thread
+	{
+		/** Construct a new Reaper */
+		Reaper()
+		{
+			super("File Reaper");
+			setPriority(Thread.MAX_PRIORITY);
+			setDaemon(true);
+		}
+
+		/**
+		 * Run the reaper thread that will delete files as their associated marker objects are
+		 * reclaimed by the garbage collector.
+		 */
+		@Override
+		public void run()
+		{
+			// thread exits when exitWhenFinished is true and there are no more tracked objects
+			while (exitWhenFinished == false || trackers.size() > 0)
+			{
+				try
+				{
+					// Wait for a tracker to remove.
+					Tracker tracker = (Tracker)q.remove(); // cannot return null
+					trackers.remove(tracker);
+					if (!tracker.delete())
+					{
+						deleteFailures.add(tracker.getPath());
+					}
+					tracker.clear();
+				}
+				catch (InterruptedException e)
+				{
+					continue;
+				}
+			}
+		}
+	}
+
+	// -----------------------------------------------------------------------
+	/**
+	 * Inner class which acts as the reference for a file pending deletion.
+	 */
+	private static final class Tracker extends PhantomReference<Object>
+	{
+
+		/**
+		 * The full path to the file being tracked.
+		 */
+		private final String path;
+		/**
+		 * The strategy for deleting files.
+		 */
+		private final FileDeleteStrategy deleteStrategy;
+
+		/**
+		 * Constructs an instance of this class from the supplied parameters.
+		 * 
+		 * @param path
+		 *            the full path to the file to be tracked, not null
+		 * @param deleteStrategy
+		 *            the strategy to delete the file, null means normal
+		 * @param marker
+		 *            the marker object used to track the file, not null
+		 * @param queue
+		 *            the queue on to which the tracker will be pushed, not null
+		 */
+		Tracker(String path, FileDeleteStrategy deleteStrategy, Object marker,
+			ReferenceQueue<? super Object> queue)
+		{
+			super(marker, queue);
+			this.path = path;
+			this.deleteStrategy = (deleteStrategy == null ? FileDeleteStrategy.NORMAL
+				: deleteStrategy);
+		}
+
+		/**
+		 * Return the path.
+		 * 
+		 * @return the path
+		 */
+		public String getPath()
+		{
+			return path;
+		}
+
+		/**
+		 * Deletes the file associated with this tracker instance.
+		 * 
+		 * @return <code>true</code> if the file was deleted successfully; <code>false</code>
+		 *         otherwise.
+		 */
+		public boolean delete()
+		{
+			return deleteStrategy.deleteQuietly(new File(path));
+		}
+	}
+
+}
\ No newline at end of file
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/FileDeleteStrategy.java b/wicket-util/src/main/java/org/apache/wicket/util/file/FileDeleteStrategy.java
new file mode 100644
index 0000000000..ab784915eb
--- /dev/null
+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/FileDeleteStrategy.java
@@ -0,0 +1,142 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.wicket.util.file;
+
+import java.io.File;
+import java.io.IOException;
+
+/**
+ * Strategy for deleting files.
+ * <p>
+ * There is more than one way to delete a file. You may want to limit access to certain directories,
+ * to only delete directories if they are empty, or maybe to force deletion.
+ * <p>
+ * This class captures the strategy to use and is designed for user subclassing.
+ * 
+ * @author Stephen Colebourne
+ * @version $Id$
+ * @since Commons IO 1.3
+ */
+public class FileDeleteStrategy
+{
+
+	/**
+	 * The singleton instance for normal file deletion, which does not permit the deletion of
+	 * directories that are not empty.
+	 */
+	public static final FileDeleteStrategy NORMAL = new FileDeleteStrategy("Normal");
+
+	/** The name of the strategy. */
+	private final String name;
+
+	// -----------------------------------------------------------------------
+	/**
+	 * Restricted constructor.
+	 * 
+	 * @param name
+	 *            the name by which the strategy is known
+	 */
+	protected FileDeleteStrategy(String name)
+	{
+		this.name = name;
+	}
+
+	// -----------------------------------------------------------------------
+	/**
+	 * Deletes the file object, which may be a file or a directory. All <code>IOException</code>s
+	 * are caught and false returned instead. If the file does not exist or is null, true is
+	 * returned.
+	 * <p>
+	 * Subclass writers should override {@link #doDelete(File)}, not this method.
+	 * 
+	 * @param fileToDelete
+	 *            the file to delete, null returns true
+	 * @return true if the file was deleted, or there was no such file
+	 */
+	public boolean deleteQuietly(File fileToDelete)
+	{
+		if (fileToDelete == null || fileToDelete.exists() == false)
+		{
+			return true;
+		}
+		try
+		{
+			return doDelete(fileToDelete);
+		}
+		catch (IOException ex)
+		{
+			return false;
+		}
+	}
+
+	/**
+	 * Deletes the file object, which may be a file or a directory. If the file does not exist, the
+	 * method just returns.
+	 * <p>
+	 * Subclass writers should override {@link #doDelete(File)}, not this method.
+	 * 
+	 * @param fileToDelete
+	 *            the file to delete, not null
+	 * @throws NullPointerException
+	 *             if the file is null
+	 * @throws IOException
+	 *             if an error occurs during file deletion
+	 */
+	public void delete(File fileToDelete) throws IOException
+	{
+		if (fileToDelete.exists() && doDelete(fileToDelete) == false)
+		{
+			throw new IOException("Deletion failed: " + fileToDelete);
+		}
+	}
+
+	/**
+	 * Actually deletes the file object, which may be a file or a directory.
+	 * <p>
+	 * This method is designed for subclasses to override. The implementation may return either
+	 * false or an <code>IOException</code> when deletion fails. The {@link #delete(File)} and
+	 * {@link #deleteQuietly(File)} methods will handle either response appropriately. A check has
+	 * been made to ensure that the file will exist.
+	 * <p>
+	 * This implementation uses {@link File#delete()}.
+	 * 
+	 * @param fileToDelete
+	 *            the file to delete, exists, not null
+	 * @return true if the file was deleteds
+	 * @throws NullPointerException
+	 *             if the file is null
+	 * @throws IOException
+	 *             if an error occurs during file deletion
+	 */
+	protected boolean doDelete(File fileToDelete) throws IOException
+	{
+		return fileToDelete.delete();
+	}
+
+	// -----------------------------------------------------------------------
+	/**
+	 * Gets a string describing the delete strategy.
+	 * 
+	 * @return a string describing the delete strategy
+	 */
+	@Override
+	public String toString()
+	{
+		return "FileDeleteStrategy[" + name + "]";
+	}
+
+}
\ No newline at end of file
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/FileUploadCleaner.java b/wicket-util/src/main/java/org/apache/wicket/util/file/FileUploadCleaner.java
new file mode 100644
index 0000000000..e61f6f0186
--- /dev/null
+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/FileUploadCleaner.java
@@ -0,0 +1,49 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.wicket.util.file;
+
+import java.io.File;
+
+/**
+ * Default implementation of {@link IFileUploadCleaner} that uses Apache commons-io
+ * {@link FileCleaningTracker} to track and clean the temporary created files.
+ * 
+ * <p>
+ * Note: this implementation starts a daemon thread to do the actual work, so it may not be used in
+ * some environments like Google AppEngine.
+ */
+public class FileUploadCleaner implements IFileUploadCleaner
+{
+	private final FileCleaningTracker cleaner;
+
+	/***/
+	public FileUploadCleaner()
+	{
+		cleaner = new FileCleaningTracker();
+	}
+
+	public void track(File file, Object marker)
+	{
+		cleaner.track(file, marker);
+	}
+
+	public void destroy()
+	{
+		cleaner.exitWhenFinished();
+	}
+
+}
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/file/IFileUploadCleaner.java b/wicket-util/src/main/java/org/apache/wicket/util/file/IFileUploadCleaner.java
new file mode 100644
index 0000000000..224a33cd9f
--- /dev/null
+++ b/wicket-util/src/main/java/org/apache/wicket/util/file/IFileUploadCleaner.java
@@ -0,0 +1,48 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.wicket.util.file;
+
+import java.io.File;
+
+/**
+ * Keeps track of files awaiting deletion, and deletes them when an associated marker object is
+ * reclaimed by the garbage collector.
+ * 
+ * <p>
+ * Needed to remove files created temporarily for the needs of FileUpload functionality.
+ */
+public interface IFileUploadCleaner
+{
+
+	/**
+	 * Track the specified file, using the provided marker, deleting the file when the marker
+	 * instance is garbage collected.
+	 * 
+	 * @param file
+	 *            the file to be tracked, not null
+	 * @param marker
+	 *            the marker object used to track the file, not null
+	 * @throws NullPointerException
+	 *             if the file is null
+	 */
+	void track(File file, Object marker);
+
+	/**
+	 * Call this method to stop the cleaner and to free all allocated resources by it
+	 */
+	void destroy();
+}
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java b/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java
index 562b03b0df..d2dca3d854 100644
--- a/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java
+++ b/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java
@@ -32,8 +32,8 @@ import java.util.Map;
 import java.util.Random;
 import java.util.UUID;
 
-import org.apache.wicket.util.file.FileCleaner;
 import org.apache.wicket.util.file.Files;
+import org.apache.wicket.util.file.IFileUploadCleaner;
 import org.apache.wicket.util.io.DeferredFileOutputStream;
 import org.apache.wicket.util.io.IOUtils;
 import org.apache.wicket.util.io.Streams;
@@ -172,6 +172,8 @@ public class DiskFileItem implements FileItem, FileItemHeadersSupport
 	 */
 	private FileItemHeaders headers;
 
+	private final IFileUploadCleaner fileUploadCleaner;
+
 	// ----------------------------------------------------------- Constructors
 
 
@@ -196,7 +198,7 @@ public class DiskFileItem implements FileItem, FileItemHeadersSupport
 	 */
 	public DiskFileItem(final String fieldName, final String contentType,
 		final boolean isFormField, final String fileName, final int sizeThreshold,
-		final File repository)
+		final File repository, final IFileUploadCleaner fileUploadCleaner)
 	{
 		this.fieldName = fieldName;
 		this.contentType = contentType;
@@ -204,6 +206,7 @@ public class DiskFileItem implements FileItem, FileItemHeadersSupport
 		this.fileName = fileName;
 		this.sizeThreshold = sizeThreshold;
 		this.repository = repository;
+		this.fileUploadCleaner = fileUploadCleaner;
 	}
 
 
@@ -655,7 +658,10 @@ public class DiskFileItem implements FileItem, FileItemHeadersSupport
 				throw new RuntimeException("Could not create the temp file for upload", e);
 			}
 
-			FileCleaner.track(tempFile, this);
+			if (fileUploadCleaner != null)
+			{
+				fileUploadCleaner.track(tempFile, this);
+			}
 		}
 		return tempFile;
 	}
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java b/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java
index 9364a792f5..6e5dd5364f 100644
--- a/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java
+++ b/wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java
@@ -18,6 +18,9 @@ package org.apache.wicket.util.upload;
 
 import java.io.File;
 
+import org.apache.wicket.util.file.FileCleaningTracker;
+import org.apache.wicket.util.file.IFileUploadCleaner;
+
 
 /**
  * <p>
@@ -75,6 +78,7 @@ public class DiskFileItemFactory implements FileItemFactory
 	 */
 	private int sizeThreshold = DEFAULT_SIZE_THRESHOLD;
 
+	private final IFileUploadCleaner fileUploadCleaner;
 
 	// ----------------------------------------------------------- Constructors
 
@@ -83,9 +87,9 @@ public class DiskFileItemFactory implements FileItemFactory
 	 * Constructs an unconfigured instance of this class. The resulting factory may be configured by
 	 * calling the appropriate setter methods.
 	 */
-	public DiskFileItemFactory()
+	public DiskFileItemFactory(final IFileUploadCleaner fileUploadCleaner)
 	{
-		this(DEFAULT_SIZE_THRESHOLD, null);
+		this(DEFAULT_SIZE_THRESHOLD, null, fileUploadCleaner);
 	}
 
 
@@ -99,10 +103,12 @@ public class DiskFileItemFactory implements FileItemFactory
 	 *            The data repository, which is the directory in which files will be created, should
 	 *            the item size exceed the threshold.
 	 */
-	public DiskFileItemFactory(final int sizeThreshold, final File repository)
+	public DiskFileItemFactory(final int sizeThreshold, final File repository,
+		final IFileUploadCleaner fileUploadCleaner)
 	{
 		this.sizeThreshold = sizeThreshold;
 		this.repository = repository;
+		this.fileUploadCleaner = fileUploadCleaner;
 	}
 
 	// ------------------------------------------------------------- Properties
@@ -171,8 +177,8 @@ public class DiskFileItemFactory implements FileItemFactory
 	// --------------------------------------------------------- Public Methods
 
 	/**
-	 * Create a new {@link org.apache.wicket.util.upload.DiskFileItem} instance from the
-	 * supplied parameters and the local factory configuration.
+	 * Create a new {@link org.apache.wicket.util.upload.DiskFileItem} instance from the supplied
+	 * parameters and the local factory configuration.
 	 * 
 	 * @param fieldName
 	 *            The name of the form field.
@@ -189,7 +195,7 @@ public class DiskFileItemFactory implements FileItemFactory
 		final boolean isFormField, final String fileName)
 	{
 		return new DiskFileItem(fieldName, contentType, isFormField, fileName, sizeThreshold,
-			repository);
+			repository, fileUploadCleaner);
 	}
 
 }
