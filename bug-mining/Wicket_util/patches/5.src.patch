diff --git a/wicket-util/src/main/java/org/apache/wicket/util/lang/Checks.java b/wicket-util/src/main/java/org/apache/wicket/util/lang/Checks.java
new file mode 100644
index 0000000000..9a32aebf6b
--- /dev/null
+++ b/wicket-util/src/main/java/org/apache/wicket/util/lang/Checks.java
@@ -0,0 +1,117 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.wicket.util.lang;
+
+import org.apache.wicket.util.string.Strings;
+
+/**
+ * 
+ */
+public class Checks
+{
+	/**
+	 * Checks value is not null
+	 * 
+	 * @param argument
+	 * @param name
+	 * @throws IllegalStateException
+	 */
+	public static void notNull(final Object argument, final String message)
+	{
+		if (argument == null)
+		{
+			throw new IllegalStateException(message);
+		}
+	}
+
+	/**
+	 * Checks argument is not empty (not null and has a non-whitespace character)
+	 * 
+	 * @param argument
+	 * @param name
+	 * @throws IllegalStateException
+	 */
+	public static void notEmpty(final String argument, final String message)
+	{
+		if (Strings.isEmpty(argument))
+		{
+			throw new IllegalStateException(message);
+		}
+	}
+
+	/**
+	 * Checks if argument is within a range
+	 * 
+	 * @param <T>
+	 * @param min
+	 * @param max
+	 * @param value
+	 * @param name
+	 * @throws IllegalStateException
+	 */
+	public static <T extends Comparable<T>> void withinRange(T min, T max, T value, String message)
+	{
+		notNull(min, message);
+		notNull(max, message);
+		if (value.compareTo(min) < 0 || value.compareTo(max) > 0)
+		{
+			throw new IllegalStateException(message);
+		}
+
+		return;
+	}
+
+	/**
+	 * Checks value is not null
+	 * 
+	 * @param argument
+	 * @param name
+	 * @throws IllegalStateException
+	 */
+	public static void notNullShort(final Object argument, final String name)
+	{
+		notNull(argument, name + " may not be null.");
+	}
+
+	/**
+	 * Checks argument is not empty (not null and has a non-whitespace character)
+	 * 
+	 * @param argument
+	 * @param name
+	 * @throws IllegalStateException
+	 */
+	public static void notEmptyShort(final String argument, final String name)
+	{
+		notEmpty(argument, name + " may not be null or empty string.");
+	}
+
+	/**
+	 * Checks if argument is within a range
+	 * 
+	 * @param <T>
+	 * @param min
+	 * @param max
+	 * @param value
+	 * @param name
+	 * @throws IllegalStateException
+	 */
+	public static <T extends Comparable<T>> void withinRangeShort(T min, T max, T value, String name)
+	{
+		withinRange(min, max, value,
+			String.format("%s must have a value within [%s,%s], but was %s", name, min, max, value));
+	}
+}
diff --git a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java
index a30fe287f7..daca212e1e 100755
--- a/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java
+++ b/wicket-util/src/main/java/org/apache/wicket/util/string/Strings.java
@@ -639,21 +639,26 @@ public final class Strings
 			}
 			for (int i = 1; i < fragments.length; i++)
 			{
-				if ((fragments[i - 1] != null) || (fragments[i] != null))
+				String fragment = fragments[i];
+				if ((fragments[i - 1] != null) || (fragment != null))
 				{
 					boolean lhsClosed = fragments[i - 1].endsWith(separator);
-					boolean rhsClosed = fragments[i].startsWith(separator);
+					boolean rhsClosed = fragment.startsWith(separator);
 					if (lhsClosed && rhsClosed)
 					{
-						buff.append(fragments[i].substring(1));
+						buff.append(fragment.substring(1));
 					}
 					else if (!lhsClosed && !rhsClosed)
 					{
-						buff.append(separator).append(fragments[i]);
+						if (!Strings.isEmpty(fragment))
+						{
+							buff.append(separator);
+						}
+						buff.append(fragment);
 					}
 					else
 					{
-						buff.append(fragments[i]);
+						buff.append(fragment);
 					}
 				}
 			}
