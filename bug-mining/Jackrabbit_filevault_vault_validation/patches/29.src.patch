diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaData.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaData.java
index d0f23692..9ee992db 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaData.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaData.java
@@ -38,7 +38,6 @@ import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
 import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
 
 public interface JcrNodeTypeMetaData {
 
@@ -66,8 +65,8 @@ public interface JcrNodeTypeMetaData {
             @NotNull ValidationMessageSeverity severityForDefaultNodeTypeViolations, @NotNull WorkspaceFilter filter) throws NamespaceException;
     @NotNull Name getPrimaryNodeType();
     String getQualifiedPath(NamePathResolver resolver) throws NamespaceException;
-    void setNodeTypes(@NotNull NameResolver nameResolver, @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
-           @Nullable String primaryType, String... mixinTypes)
+    void setNodeTypes(@NotNull NameResolver nameResolver, @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,  boolean isFallbackPrimaryType,
+           @NotNull String primaryType, String... mixinTypes)
             throws IllegalNameException, ConstraintViolationException, NoSuchNodeTypeException, NamespaceException;
     void setUnknownNodeTypes();
     
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java
index bc4b98f3..23837b65 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java
@@ -145,10 +145,11 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
 
     @Override
     public void setNodeTypes(@NotNull NameResolver nameResolver,
-            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider, @NotNull String primaryType, String... mixinTypes)
+            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider, boolean isFallbackPrimaryType, @NotNull String primaryType, String... mixinTypes)
             throws IllegalNameException, ConstraintViolationException, NoSuchNodeTypeException, NamespaceException {
         List<Name> types = getTypes(nameResolver, primaryType, mixinTypes);
-        if (effectiveNodeType == null || !effectiveNodeType.includesNodeTypes(types.toArray(new Name[0]))) {
+        if (effectiveNodeType == null || (!isFallbackPrimaryType && !effectiveNodeType.includesNodeTypes(types.toArray(new Name[0])))) {
+            // only override if not a default node type
             this.primaryNodeType = types.get(0);
             this.effectiveNodeType = effectiveNodeTypeProvider.getEffectiveNodeType(types.toArray(new Name[0]));
             if (!isAuthenticationOrAuthorizationContext) {
@@ -242,7 +243,7 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
         return childNode;
     }
 
-    private static List<Name> getTypes(NameResolver nameResolver, String primaryType, String... mixinTypes)
+    private static List<Name> getTypes(@NotNull NameResolver nameResolver, @NotNull String primaryType, String... mixinTypes)
             throws IllegalNameException, NamespaceException {
         List<Name> types = new ArrayList<>();
         types.add(getQName(nameResolver, primaryType, NameType.PRIMARY_TYPE));
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
index 8d3d02fd..2ff9ceb7 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
@@ -123,7 +123,7 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
             }
         }
         Collection<ValidationMessage> messages = new LinkedList<>();
-        messages.addAll(getOrCreateNewNode(nodeContext, false, isImplicit(nodeContext.getNodePath()), node.primary, node.mixins));
+        messages.addAll(getOrCreateNewNode(nodeContext, false, isImplicit(nodeContext.getNodePath()), false, node.primary, node.mixins));
 
         for (DocViewProperty property : node.props.values()) {
             try {
@@ -171,13 +171,13 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
         }
     }
 
-    private @NotNull Collection<ValidationMessage> getOrCreateNewNode(NodeContext nodeContext, boolean isFolder, boolean isImplicit, String primaryType,
+    private @NotNull Collection<ValidationMessage> getOrCreateNewNode(NodeContext nodeContext, boolean isFolder, boolean isImplicit, boolean isFallbackPrimaryType, String primaryType,
             String... mixinTypes) {
         Optional<JcrNodeTypeMetaData> node = getNode(nodeContext.getNodePath());
         if (node.isPresent()) {
             currentNodeTypeMetaData = node.get();
             try {
-                currentNodeTypeMetaData.setNodeTypes(ntManagerProvider.getNameResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                currentNodeTypeMetaData.setNodeTypes(ntManagerProvider.getNameResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(), isFallbackPrimaryType,
                         primaryType, mixinTypes);
             } catch (NoSuchNodeTypeException | NamespaceException e) {
                 currentNodeTypeMetaData.setUnknownNodeTypes();
@@ -302,7 +302,7 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
         List<ValidationMessage> messages = new ArrayList<>();
         boolean isImplicit = isImplicit(nodeContext.getNodePath());
         if (isFolder) {
-            messages.addAll(getOrCreateNewNode(nodeContext, isFolder, isImplicit, JcrConstants.NT_FOLDER));
+            messages.addAll(getOrCreateNewNode(nodeContext, isFolder, isImplicit, true, JcrConstants.NT_FOLDER));
             //
             if (!nodeContext.getNodePath().equals("/")) {
                 messages.addAll(finalizeValidationForSiblings(nodeContext));
@@ -314,19 +314,19 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
                 // https://jackrabbit.apache.org/filevault/vaultfs.html#Binary_Properties
                 if (fileName.endsWith(ValidationExecutor.EXTENSION_BINARY)) {
                     // create parent if it does not exist yet
-                    messages.addAll(getOrCreateNewNode(nodeContext, isFolder, isImplicit, JcrConstants.NT_FOLDER));
+                    messages.addAll(getOrCreateNewNode(nodeContext, isFolder, isImplicit, true, JcrConstants.NT_FOLDER));
                     String propertyName = fileName.substring(0, fileName.length() - ValidationExecutor.EXTENSION_BINARY.length());
                     messages.addAll(addProperty(nodeContext, propertyName, false, DUMMY_BINARY_VALUE));
                 } else {
                     // if binary node is not yet there
-                    messages.addAll(getOrCreateNewNode(nodeContext, isFolder, isImplicit, JcrConstants.NT_FILE));
+                    messages.addAll(getOrCreateNewNode(nodeContext, isFolder, isImplicit, true, JcrConstants.NT_FILE));
                     // if a NT_FILE create a jcr:content sub node of type NT_RESOURCE
                     if (currentNodeTypeMetaData.getPrimaryNodeType().equals(NameConstants.NT_FILE)) {
                         // create new node context
                         nodeContext = new NodeContextImpl(nodeContext.getNodePath() + "/" + JcrConstants.JCR_CONTENT,
                                 nodeContext.getFilePath(), nodeContext.getBasePath());
                         messages.addAll(
-                                getOrCreateNewNode(nodeContext, isFolder, isImplicit(nodeContext.getNodePath()), JcrConstants.NT_RESOURCE));
+                                getOrCreateNewNode(nodeContext, isFolder, isImplicit(nodeContext.getNodePath()), true, JcrConstants.NT_RESOURCE));
                     }
                     messages.addAll(addProperty(nodeContext, JcrConstants.JCR_DATA, false, DUMMY_BINARY_VALUE));
                     messages.addAll(addProperty(nodeContext, JcrConstants.JCR_MIMETYPE, false, DUMMY_STRING_VALUE));
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java
index 81afbb10..c0102893 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java
@@ -377,4 +377,45 @@ public class NodeTypeValidatorTest {
                 AnyValidationMessageMatcher.noValidationInCollection());
         MatcherAssert.assertThat(validator.done(), AnyValidationMessageMatcher.noValidationInCollection());
     }
+
+    // JCRVLT-539
+    @Test
+    public void testFolderAfterDocviewNotOverwritingPrimaryType() {
+        NodeContext nodeContext = new NodeContextImpl("/apps/test", Paths.get("apps", "test", ".content.xml"), Paths.get(""));
+        // first process docview xml with three nodes
+        
+        // 1. "test" (root)
+        MatcherAssert.assertThat(validator.validateJcrPath(nodeContext, false, true),
+                AnyValidationMessageMatcher.noValidationInCollection());
+        Map<String, DocViewProperty> props = new HashMap<>();
+        props.put(NameConstants.JCR_PRIMARYTYPE.toString(), new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(),
+                new String[] { "nt:unstructured" }, false, PropertyType.STRING));
+        DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, props, new String[] { }, "nt:unstructured");
+        MatcherAssert.assertThat(validator.validate(node, nodeContext, true),
+                AnyValidationMessageMatcher.noValidationInCollection());
+        
+        // and 2. "test/child"
+        nodeContext = new NodeContextImpl("/apps/test/child", Paths.get("apps", "test", ".content.xml"), Paths.get(""));
+        node = new DocViewNode("child", "child", null, props, new String[] { }, "nt:unstructured");
+        MatcherAssert.assertThat(validator.validateJcrPath(nodeContext, false, true),
+                AnyValidationMessageMatcher.noValidationInCollection());
+        MatcherAssert.assertThat(validator.validate(node, nodeContext, false),
+                AnyValidationMessageMatcher.noValidationInCollection());
+        
+        // and 3. "test/child/grandchild"
+        nodeContext = new NodeContextImpl("/apps/test/child/grandchild", Paths.get("apps", "test", ".content.xml"), Paths.get(""));
+        node = new DocViewNode("grandchild", "grandchild", null, props, new String[] { }, "nt:unstructured");
+        MatcherAssert.assertThat(validator.validateJcrPath(nodeContext, false, true),
+                AnyValidationMessageMatcher.noValidationInCollection());
+        MatcherAssert.assertThat(validator.validate(node, nodeContext, false),
+                AnyValidationMessageMatcher.noValidationInCollection());
+        
+        // then process folder "test/child"
+        nodeContext = new NodeContextImpl("/apps/test/child", Paths.get("apps", "test", "child"), Paths.get(""));
+        MatcherAssert.assertThat(validator.validateJcrPath(nodeContext, true, false),
+                AnyValidationMessageMatcher.noValidationInCollection());
+        
+        // make sure that grandchild is valid (as parent is nt:unstructured and not nt:folder)
+        MatcherAssert.assertThat(validator.done(), AnyValidationMessageMatcher.noValidationInCollection());
+    }
 }
