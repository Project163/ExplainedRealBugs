diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
index 81173546..35254d9c 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
@@ -30,6 +30,7 @@ import java.util.stream.Collectors;
 import org.apache.commons.io.FilenameUtils;
 import org.apache.jackrabbit.vault.util.Constants;
 import org.apache.jackrabbit.vault.util.PlatformNameFormat;
+import org.apache.jackrabbit.vault.util.Text;
 import org.apache.jackrabbit.vault.validation.impl.util.EnhancedBufferedInputStream;
 import org.apache.jackrabbit.vault.validation.impl.util.ResettableInputStream;
 import org.apache.jackrabbit.vault.validation.impl.util.ValidatorException;
@@ -63,6 +64,7 @@ import org.slf4j.LoggerFactory;
  */
 public final class ValidationExecutor {
 
+    public static final String EXTENSION_BINARY = ".binary";
     private final Map<String, DocumentViewXmlValidator> documentViewXmlValidators;
     private final Map<String, NodePathValidator> nodePathValidators;
     private final Map<String, GenericJcrDataValidator> genericJcrDataValidators;
@@ -270,6 +272,7 @@ public final class ValidationExecutor {
         Map<String, Integer> nodePathsAndLineNumbers = new LinkedHashMap<>();
         Collection<ValidationViolation> enrichedMessages = new LinkedList<>();
         
+        boolean isDocViewXml = true;
         if (input != null) {
             InputStream currentInput = input;
             ResettableInputStream resettableInputStream = null;
@@ -299,6 +302,7 @@ public final class ValidationExecutor {
                             // convert file name to node path
                             String nodePath = filePathToNodePath(filePath);
                             log.debug("Found non-docview node '{}'", nodePath);
+                            isDocViewXml = false;
                             nodePathsAndLineNumbers.put(nodePath, 0);
                         }
                     } catch (RuntimeException e) {
@@ -322,7 +326,7 @@ public final class ValidationExecutor {
         // generate node context
         NodeContext nodeContext = new NodeContextImpl(nodePathsAndLineNumbers.keySet().iterator().next(), filePath, basePath);
         for (Map.Entry<String, JcrPathValidator> entry : jcrPathValidators.entrySet()) {
-            Collection<ValidationMessage> messages = entry.getValue().validateJcrPath(nodeContext, input == null);
+            Collection<ValidationMessage> messages = entry.getValue().validateJcrPath(nodeContext, input == null, isDocViewXml);
             if (messages != null && !messages.isEmpty()) {
                 enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
             }
@@ -338,10 +342,16 @@ public final class ValidationExecutor {
      */
     public static @NotNull String filePathToNodePath(@NotNull Path filePath) {
         String platformPath = FilenameUtils.separatorsToUnix(filePath.toString());
+        // treat https://jackrabbit.apache.org/filevault/vaultfs.html#Binary_Properties specially
+        if (platformPath.endsWith(EXTENSION_BINARY)) {
+            platformPath = Text.getRelativeParent(platformPath, 1);
+        }
         String repositoryPath = PlatformNameFormat.getRepositoryPath(platformPath, true);
         if (!repositoryPath.isEmpty()) {
             // make repository path absolute by prefixing it with "/" in case it is not the root node path itself
             repositoryPath = "/" + repositoryPath;
+        } else {
+            repositoryPath = "/";
         }
         return repositoryPath;
     }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
index 6521ca24..0d765233 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
@@ -17,7 +17,7 @@
 /**
  * The FileVault validation framework API. Provides classes to execute validations on FileVault packages.
  */
-@Version("2.0.0")
+@Version("2.1.0")
 package org.apache.jackrabbit.vault.validation;
 
 import org.osgi.annotation.versioning.Version;
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
index 6a2cd9fa..1ca824b7 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
@@ -25,9 +25,8 @@ import org.osgi.annotation.versioning.ProviderType;
 
 
 /**
- * Validator interface for validating file paths for files and folders
- * below jcr_root.
- * Called after {@link GenericJcrDataValidator}.
+ * Validator interface for validating file paths for files and folders below {@code jcr_root}.
+ * Called after {@link GenericJcrDataValidator} and after {@link DocumentViewXmlValidator}.
  * In contrast to {@link NodePathValidator} only called once per file and folder (even if those are covering multiple node paths).
  */
 @ProviderType
@@ -37,7 +36,7 @@ public interface JcrPathValidator extends Validator {
      * 
      * @param filePath the relative file/folder path to the jcr_root directory
      * @return validation messages or {@code null}
-     * @deprecated Use {@link #validateJcrPath(NodeContext, boolean)} instead.
+     * @deprecated Use {@link #validateJcrPath(NodeContext, boolean, boolean)} instead.
      */
     @Deprecated 
     default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath) { 
@@ -50,9 +49,22 @@ public interface JcrPathValidator extends Validator {
      * @param nodeContext the meta information about the node given through this file/folder
      * @param isFolder {@code true} in case it is a folder, otherwise {@code false}
      * @return validation messages or {@code null}
+     * @deprecated Use {@link #validateJcrPath(NodeContext, boolean, boolean)} instead.
      */
+    @Deprecated
     default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext, boolean isFolder) { 
         return validateJcrPath(nodeContext.getFilePath()); 
     }
    
+    /**
+     * Called for each file/folder below jcr_root.
+     * 
+     * @param nodeContext the meta information about the node given through this file/folder
+     * @param isFolder {@code true} in case it is a folder, otherwise {@code false}
+     * @param isDocViewXml {@code true} in case {@code isFolder} is {@code false} and the file is a Document View XML file, otherwise {@code false}
+     * @return validation messages or {@code null}
+     */
+    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext, boolean isFolder, boolean isDocViewXml) { 
+        return validateJcrPath(nodeContext, isFolder); 
+    }
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/ValidationMessage.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/ValidationMessage.java
index 32674426..aaa32540 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/ValidationMessage.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/ValidationMessage.java
@@ -55,6 +55,14 @@ public class ValidationMessage {
         this(severity, message, nodePath, filePath, basePath, 0, 0, throwable);
     }
 
+    public ValidationMessage(@NotNull ValidationMessageSeverity severity, @NotNull String message, @NotNull NodeContext nodeContext) {
+        this(severity, message, nodeContext.getNodePath(), nodeContext.getFilePath(), nodeContext.getBasePath(), 0, 0, null);
+    }
+
+    public ValidationMessage(@NotNull ValidationMessageSeverity severity, @NotNull String message, @NotNull NodeContext nodeContext, Throwable throwable) {
+        this(severity, message, nodeContext.getNodePath(), nodeContext.getFilePath(), nodeContext.getBasePath(), 0, 0, throwable);
+    }
+
     public ValidationMessage(@NotNull ValidationMessageSeverity severity, @NotNull String message, Path filePath, Path basePath, int line, int column, Throwable throwable) {
         this(severity, message, null, filePath, basePath, line, column, throwable);
     }
@@ -183,6 +191,4 @@ public class ValidationMessage {
                 + (throwable != null ? "throwable=" + throwable + ", " : "") + (nodePath != null ? "nodePath=" + nodePath + ", " : "")
                 + (filePath != null ? "filePath=" + filePath + ", " : "") + (basePath != null ? "basePath=" + basePath : "") + "]";
     }
-
-
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/DocViewPropertyValueFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/DocViewPropertyValueFactory.java
index a9704ba0..f8495a8b 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/DocViewPropertyValueFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/DocViewPropertyValueFactory.java
@@ -27,6 +27,7 @@ import javax.jcr.ValueFormatException;
 import org.apache.jackrabbit.value.ValueFactoryImpl;
 import org.apache.jackrabbit.vault.util.DocViewProperty;
 
+/** Creates JCR values from DocViewProperties */
 public class DocViewPropertyValueFactory {
 
     private final ValueFactory valueFactory;
@@ -36,6 +37,7 @@ public class DocViewPropertyValueFactory {
     
     private Value getValue(String value, int type) throws ValueFormatException {
         if (type == PropertyType.UNDEFINED) {
+            // simulate behaviour of DocViewProperty.apply(...) which leverages setProperty(String name, String value)
             type = PropertyType.STRING;
         }
         return valueFactory.createValue(value, type);
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaData.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaData.java
new file mode 100644
index 00000000..ea412126
--- /dev/null
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaData.java
@@ -0,0 +1,75 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.validation.spi.impl.nodetype;
+
+import java.util.Collection;
+import java.util.Optional;
+
+import javax.jcr.ItemNotFoundException;
+import javax.jcr.NamespaceException;
+import javax.jcr.RepositoryException;
+import javax.jcr.Value;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+
+import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeTypeProvider;
+import org.apache.jackrabbit.jcr2spi.nodetype.ItemDefinitionProvider;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeDefinitionProvider;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
+import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
+import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
+import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
+import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+public interface JcrNodeTypeMetaData {
+
+    void addProperty(@NotNull NodeContext nodeContext, @NotNull NamePathResolver namePathResolver, @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
+            @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider, @NotNull ItemDefinitionProvider itemDefinitionProvider,
+            @NotNull ValidationMessageSeverity severity, String name, boolean isMultiValue, Value... values) throws RepositoryException;
+    @NotNull JcrNodeTypeMetaData addImplicitChildNode(@NotNull NameResolver nameResolver,
+            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider, @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider,
+            @NotNull ItemDefinitionProvider itemDefinitionProvider, @NotNull NodeContext nodeContext, @NotNull Name implicitNodeType)
+            throws RepositoryException;
+    @NotNull JcrNodeTypeMetaData addChildNode(@NotNull NameResolver nameResolver, @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
+            @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider, @NotNull ItemDefinitionProvider itemDefinitionProvider,
+            @NotNull ValidationMessageSeverity severity, @NotNull NodeContext nodeContext, @NotNull String primaryType, String... mixinTypes)
+                    throws RepositoryException, NamespaceExceptionInNodeName;
+    @NotNull JcrNodeTypeMetaData addUnknownChildNode(@NotNull NameResolver nameResolver, @NotNull String name) throws IllegalNameException, NamespaceException;
+    
+    // navigate
+    @NotNull Collection<@NotNull ? extends JcrNodeTypeMetaData> getChildren();
+    Optional<JcrNodeTypeMetaData> getNode(NamePathResolver nameResolver, String path)
+            throws ItemNotFoundException, RepositoryException;
+    @NotNull JcrNodeTypeMetaData getOrCreateNode(NamePathResolver nameResolver, String path) throws RepositoryException;
+    
+    @NotNull Collection<ValidationMessage> finalizeValidation(@NotNull NamePathResolver nameResolver,
+            @NotNull ValidationMessageSeverity severity, @NotNull WorkspaceFilter filter) throws NamespaceException;
+    void fetchAndClearValidationMessages(Collection<ValidationMessage> messages);
+    @NotNull Name getPrimaryNodeType();
+    String getQualifiedPath(NamePathResolver resolver) throws NamespaceException;
+    void setNodeTypes(@NotNull NameResolver nameResolver, @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
+           @Nullable String primaryType, String... mixinTypes)
+            throws IllegalNameException, ConstraintViolationException, NoSuchNodeTypeException, NamespaceException;
+    void setUnknownNodeTypes();
+    
+
+}
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java
new file mode 100644
index 00000000..ab3835a0
--- /dev/null
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java
@@ -0,0 +1,648 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.validation.spi.impl.nodetype;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Optional;
+
+import javax.jcr.NamespaceException;
+import javax.jcr.PropertyType;
+import javax.jcr.RepositoryException;
+import javax.jcr.Value;
+import javax.jcr.nodetype.ConstraintViolationException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+
+import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
+import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeTypeProvider;
+import org.apache.jackrabbit.jcr2spi.nodetype.ItemDefinitionProvider;
+import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeDefinitionProvider;
+import org.apache.jackrabbit.spi.Name;
+import org.apache.jackrabbit.spi.Path;
+import org.apache.jackrabbit.spi.Path.Element;
+import org.apache.jackrabbit.spi.QNodeDefinition;
+import org.apache.jackrabbit.spi.QNodeTypeDefinition;
+import org.apache.jackrabbit.spi.QPropertyDefinition;
+import org.apache.jackrabbit.spi.QValue;
+import org.apache.jackrabbit.spi.QValueFactory;
+import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
+import org.apache.jackrabbit.spi.commons.name.NameConstants;
+import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
+import org.apache.jackrabbit.spi.commons.name.PathBuilder;
+import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
+import org.apache.jackrabbit.spi.commons.nodetype.constraint.ValueConstraint;
+import org.apache.jackrabbit.spi.commons.value.QValueFactoryImpl;
+import org.apache.jackrabbit.spi.commons.value.ValueFormat;
+import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
+import org.apache.jackrabbit.vault.util.Text;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
+import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
+import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+/** This class encapsulates node type related data of a node. It uses expanded names/paths internally. */
+public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
+
+    static final String EXCEPTION_MESSAGE_INVALID_NAME = "Invalid %s '%s': %s";
+    static final String CONSTRAINT_PROPERTY_VALUE = "Value constraint violation: %s";
+    static final String CONSTRAINT_PROPERTY_PROTECTED = "Property is protected!";
+    static final String CONSTRAINT_PROPERTY_AUTO_CREATED = "Property is auto-created and can not be manually added";
+    static final String CONSTRAINT_PROPERTY_NOT_ALLOWED = "No applicable property definition found for name and type!";
+    static final String CONSTRAINT_CHILD_NODE_AUTO_CREATED = "Node is auto-created and can not be manually added";
+    static final String CONSTRAINT_CHILD_NODE_PROTECTED = "Node is protected and can not be manually added";
+    static final String CONSTRAINT_MIXIN_TYPE_AS_PRIMARY_TYPE = "Given node type is a mixin and cannot be used as primary node type.";
+    static final String CONSTRAINT_ABSTRACT_TYPE_AS_PRIMARY_TYPE = "Given node type is abstract and cannot be used as primary node type.";
+    static final String CONSTRAINT_CHILD_NODE_NOT_ALLOWED = "Node type does not allow arbitrary child nodes and does not allow this specific name and node type either!";
+
+    static final String MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED = "Node '%s [%s]' is not allowed as child of not contained node with potential default types '[%s]': %s";
+    static final String MESSAGE_CHILD_NODE_NOT_ALLOWED = "Node '%s [%s]' is not allowed as child of node with types [%s]: %s";
+    static final String MESSAGE_PROPERTY_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED = null;
+    static final String MESSAGE_PROPERTY_NOT_ALLOWED = "Property '%s' [%s] is not allowed in node with potential default types [%s]: %s";
+    static final String MESSAGE_MANDATORY_CHILD_NODE_MISSING = "Mandatory child node missing: %s inside node with types [%s] at %s";
+    static final String MESSAGE_MANDATORY_UNCONTAINED_CHILD_NODE_MISSING = "Mandatory child node missing: %s inside node with types [%s] at %s (outside of filter rules)";
+    static final String MESSAGE_MANDATORY_PROPERTY_MISSING = "Mandatory property '%s' missing in node with types [%s] at %s";
+    static final String MESSAGE_MANDATORY_PROPERTY_WITH_WRONG_TYPE = "Mandatory property '%s' has type '%s' while it should have '%s' in node with types [%s] at %s";
+
+    private static final Collection<Name> ALLOWED_PROTECTED_PROPERTIES = Arrays.asList(NameConstants.JCR_PRIMARYTYPE,
+            NameConstants.JCR_MIXINTYPES);
+
+    private static final Name NT_REP_POLICY = NameFactoryImpl.getInstance().create(Name.NS_REP_URI, "Policy");
+    private static final Name NT_REP_AUTHORIZABLE = NameFactoryImpl.getInstance().create(Name.NS_REP_URI, "Authorizable");
+    private static final QValueFactory QVALUE_FACTORY = QValueFactoryImpl.getInstance();
+
+    private final @NotNull Name name;
+    private @Nullable Name primaryNodeType; // the effectiveNodeType does not remember which one was the primary one!
+    private @Nullable EffectiveNodeType effectiveNodeType;
+    private final @NotNull Map<Name, Integer> propertyTypesByName;
+    private final @NotNull Map<Name, JcrNodeTypeMetaDataImpl> childNodesByName;
+    private final @Nullable JcrNodeTypeMetaDataImpl parentNode;
+    private final Collection<ValidationMessage> messages;
+    private final boolean isAuthenticationOrAuthorizationContext;
+    private final boolean isImplicit; // if this is true, the node type is set implicitly (not explicitly set in package, used as is in the
+                                      // repository)
+    private boolean isValidationDone;
+
+    private JcrNodeTypeMetaDataImpl(@NotNull Name name, @Nullable Name primaryNodeType, @Nullable EffectiveNodeType effectiveNodeType,
+            JcrNodeTypeMetaDataImpl parentNode, boolean isAuthenticationOrAuthorizationContext, boolean isImplicit) {
+        super();
+        this.name = name; // fully namespaced (taking into account local namespace declaration for Docview XML)
+        this.primaryNodeType = primaryNodeType;
+        this.effectiveNodeType = effectiveNodeType;
+        this.parentNode = parentNode;
+        this.propertyTypesByName = new HashMap<>();
+        this.childNodesByName = new HashMap<>();
+        this.messages = new ArrayList<>();
+        this.isAuthenticationOrAuthorizationContext = isAuthenticationOrAuthorizationContext;
+        this.isImplicit = isImplicit;
+        this.isValidationDone = false;
+    }
+
+    @Override
+    public String toString() {
+        return "JcrNodeTypeMetaDataImpl [" + "name=" + name + ", "
+                + "effectiveNodeType=" + effectiveNodeType + ", "
+                + "propertyTypesByName=" + propertyTypesByName + ", "
+                + "childNodes=" + childNodesByName.keySet() + ", "
+                // + "parentNode path="+(parentNode != null ? + parentNode.getPath() + ", " : "")
+                + (messages != null ? "messages=" + messages + ", " : "")
+                + "isAuthenticationOrAuthorizationContext=" + isAuthenticationOrAuthorizationContext + "]";
+    }
+
+    @Override
+    public void setUnknownNodeTypes() {
+        this.primaryNodeType = null;
+        this.effectiveNodeType = null;
+    }
+
+    @Override
+    public void setNodeTypes(@NotNull NameResolver nameResolver,
+            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider, @NotNull String primaryType, String... mixinTypes)
+            throws IllegalNameException, ConstraintViolationException, NoSuchNodeTypeException, NamespaceException {
+        List<Name> types = getTypes(nameResolver, primaryType, mixinTypes);
+        if (effectiveNodeType == null || !effectiveNodeType.includesNodeTypes(types.toArray(new Name[0]))) {
+            this.primaryNodeType = types.get(0);
+            this.effectiveNodeType = effectiveNodeTypeProvider.getEffectiveNodeType(types.toArray(new Name[0]));
+        }
+    }
+
+    @Override
+    public Name getPrimaryNodeType() {
+        return primaryNodeType;
+    }
+
+    private static boolean isAclOrAuthorizableNodeType(EffectiveNodeType effectiveNodeType) {
+        return effectiveNodeType.includesNodeType(NT_REP_AUTHORIZABLE) || effectiveNodeType.includesNodeType(NT_REP_POLICY);
+    }
+
+    private enum NameType {
+        NODE_NAME("node name"), PRIMARY_TYPE("primary type"), MIXIN_TYPE("mixin type");
+
+        private final String label;
+
+        NameType(String label) {
+            this.label = label;
+        }
+
+        public String getLabel() {
+            return label;
+        }
+    }
+
+    private static @NotNull Name getQName(@NotNull NameResolver nameResolver, @NotNull String name, @NotNull NameType type)
+            throws IllegalNameException, NamespaceException {
+        try {
+            Name qName = nameResolver.getQName(name);
+            // was it a namespace which has been generated on demand before?
+            if (type != NameType.NODE_NAME
+                    && qName.getNamespaceURI().startsWith(OnDemandRegisterNamespaceResolverWrapper.UNDECLARED_NAMESPACE_URI_PREFIX)) {
+                int posColon = name.indexOf(':');
+                // extract prefix
+                String prefix = name.substring(0, posColon);
+                throw new NamespaceException(prefix + ": is not a registered namespace prefix.");
+            }
+            return qName;
+        } catch (NamespaceException e) {
+            if (type == NameType.NODE_NAME) {
+                throw new NamespaceExceptionInNodeName(
+                        String.format(EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()), e);
+            }
+            throw new NamespaceException(String.format(EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()), e);
+        } catch (IllegalNameException e) {
+            throw new IllegalNameException(String.format(EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()),
+                    e);
+        }
+    }
+
+    @Override
+    public @NotNull JcrNodeTypeMetaData addImplicitChildNode(@NotNull NameResolver nameResolver,
+            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
+            @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider, @NotNull ItemDefinitionProvider itemDefinitionProvider,
+            @NotNull NodeContext nodeContext, @Nullable Name implicitNodeType) throws RepositoryException {
+        JcrNodeTypeMetaDataImpl childNode = addChildNode(nameResolver, effectiveNodeTypeProvider, nodeTypeDefinitionProvider,
+                itemDefinitionProvider, true, Text.getName(nodeContext.getNodePath()), implicitNodeType);
+        // now validate for validity
+        Optional<String> constraintViolation = childNode.validateAgainstParentNodeType(effectiveNodeType, nodeTypeDefinitionProvider,
+                itemDefinitionProvider);
+        if (constraintViolation.isPresent()) {
+            throw new IllegalArgumentException("The implicit node type is invalid here: " + constraintViolation.get());
+        }
+        return childNode;
+    }
+
+    @Override
+    public @NotNull JcrNodeTypeMetaData addUnknownChildNode(@NotNull NameResolver nameResolver, @NotNull String name)
+            throws IllegalNameException, NamespaceException {
+        return addUnknownChildNode(getQName(nameResolver, name, NameType.NODE_NAME));
+    }
+
+    private @NotNull JcrNodeTypeMetaDataImpl addUnknownChildNode(@NotNull Name name) throws IllegalNameException {
+        JcrNodeTypeMetaDataImpl childNode = new JcrNodeTypeMetaDataImpl(name, null, null, this, false, false);
+        childNodesByName.put(name, childNode);
+        return childNode;
+    }
+
+    @Override
+    public @NotNull JcrNodeTypeMetaData addChildNode(@NotNull NameResolver nameResolver,
+            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
+            @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider, @NotNull ItemDefinitionProvider itemDefinitionProvider,
+            @NotNull ValidationMessageSeverity severity, @NotNull NodeContext nodeContext, @NotNull String primaryType,
+            String... mixinTypes)
+            throws IllegalNameException, NoSuchNodeTypeException, RepositoryException, NamespaceExceptionInNodeName {
+
+        List<Name> types = getTypes(nameResolver, primaryType, mixinTypes);
+        String nodeName = Text.getName(nodeContext.getNodePath());
+        JcrNodeTypeMetaDataImpl childNode = addChildNode(nameResolver, effectiveNodeTypeProvider, nodeTypeDefinitionProvider,
+                itemDefinitionProvider, false, nodeName, types.toArray(new Name[0]));
+        // now validate for validity
+        Optional<String> constraintViolation = childNode.validateAgainstParentNodeType(effectiveNodeType, nodeTypeDefinitionProvider,
+                itemDefinitionProvider);
+        if (constraintViolation.isPresent()) {
+            childNode.messages.add(new ValidationMessage(severity,
+                    String.format(
+                            isImplicit ? MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED
+                                    : MESSAGE_CHILD_NODE_NOT_ALLOWED,
+                            nodeName, primaryType,
+                            getEffectiveNodeTypeLabel(nameResolver, effectiveNodeType),
+                            constraintViolation.get()),
+                    nodeContext));
+
+        }
+        return childNode;
+    }
+
+    private static List<Name> getTypes(NameResolver nameResolver, String primaryType, String... mixinTypes)
+            throws IllegalNameException, NamespaceException {
+        List<Name> types = new ArrayList<>();
+        types.add(getQName(nameResolver, primaryType, NameType.PRIMARY_TYPE));
+        if (mixinTypes != null) {
+            for (String mixinType : mixinTypes) {
+                types.add(getQName(nameResolver, mixinType, NameType.MIXIN_TYPE));
+            }
+        }
+        return types;
+    }
+
+    private @NotNull JcrNodeTypeMetaDataImpl addChildNode(@NotNull NameResolver nameResolver,
+            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
+            @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider, @NotNull ItemDefinitionProvider itemDefinitionProvider,
+            boolean isImplicit, @NotNull String name, @Nullable Name... nodeTypes)
+            throws ConstraintViolationException, NoSuchNodeTypeException, NamespaceExceptionInNodeName, NamespaceException,
+            IllegalNameException {
+
+        final Name qName = getQName(nameResolver, name, NameType.NODE_NAME);
+
+        // special handling for users and acls
+        boolean isAuthenticationOrAuthorizationContext = false;
+        final EffectiveNodeType newEffectiveNodeType;
+        final Name newPrimaryNodeType;
+        if (nodeTypes != null) {
+            newEffectiveNodeType = effectiveNodeTypeProvider.getEffectiveNodeType(nodeTypes);
+            newPrimaryNodeType = nodeTypes[0];
+            isAuthenticationOrAuthorizationContext = isAclOrAuthorizableNodeType(newEffectiveNodeType);
+        } else {
+            newEffectiveNodeType = null;
+            newPrimaryNodeType = null;
+        }
+        // special handling for users and acls
+        if (!isAuthenticationOrAuthorizationContext) {
+            isAuthenticationOrAuthorizationContext = this.isAuthenticationOrAuthorizationContext;
+        }
+        JcrNodeTypeMetaDataImpl newNode = new JcrNodeTypeMetaDataImpl(qName, newPrimaryNodeType, newEffectiveNodeType, this,
+                isAuthenticationOrAuthorizationContext, isImplicit);
+        childNodesByName.put(qName, newNode);
+        return newNode;
+    }
+
+    /** Similar to
+     * {@link EffectiveNodeType#checkAddNodeConstraints(Name, org.apache.jackrabbit.spi.QNodeTypeDefinition, ItemDefinitionProvider)}
+     * 
+     * @param parentEffectiveNodeType
+     * @return constraints violation message
+     * @throws RepositoryException */
+    private Optional<String> validateAgainstParentNodeType(@Nullable EffectiveNodeType parentEffectiveNodeType,
+            @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider,
+            @NotNull ItemDefinitionProvider itemDefinitionProvider) throws RepositoryException {
+        // except for ACL node types (for which the mixin rep:AccessControllable is transparently added) everything must comply with the
+        // parent node rules
+        if (effectiveNodeType.includesNodeType(NT_REP_POLICY)) {
+            return Optional.empty();
+        }
+
+        if (parentEffectiveNodeType == null) {
+            return Optional.empty();
+        }
+        QNodeTypeDefinition primaryNodeTypeDefinition = nodeTypeDefinitionProvider.getNodeTypeDefinition(primaryNodeType);
+        if (primaryNodeTypeDefinition.isAbstract()) {
+            return Optional.of(CONSTRAINT_ABSTRACT_TYPE_AS_PRIMARY_TYPE);
+        } else if (primaryNodeTypeDefinition.isMixin()) {
+            return Optional.of(CONSTRAINT_MIXIN_TYPE_AS_PRIMARY_TYPE);
+        }
+        try {
+            // get applicable node type from parent
+            QNodeDefinition applicableParentNodeDefinition = itemDefinitionProvider.getQNodeDefinition(parentEffectiveNodeType, this.name,
+                    primaryNodeType);
+            if (!isAuthenticationOrAuthorizationContext && applicableParentNodeDefinition.isProtected()) {
+                return Optional.of(CONSTRAINT_CHILD_NODE_PROTECTED);
+            }
+            if (applicableParentNodeDefinition.isAutoCreated()) {
+                return Optional.of(CONSTRAINT_CHILD_NODE_AUTO_CREATED);
+            }
+        } catch (ConstraintViolationException e) {
+            return Optional.of(CONSTRAINT_CHILD_NODE_NOT_ALLOWED);
+        }
+        return Optional.empty();
+    }
+
+    @Override
+    public @NotNull Collection<ValidationMessage> finalizeValidation(@NotNull NamePathResolver namePathResolver,
+            @NotNull ValidationMessageSeverity severity, @NotNull WorkspaceFilter filter) throws NamespaceException {
+        if (!isValidationDone) {
+            Collection<ValidationMessage> messages = new LinkedList<>();
+            messages.add(new ValidationMessage(ValidationMessageSeverity.DEBUG,
+                    "Validate mandatory children and properties of " + getQualifiedPath(namePathResolver)));
+            messages.addAll(validateMandatoryChildNodes(namePathResolver, severity, filter));
+            messages.addAll(validateMandatoryProperties(namePathResolver, severity));
+            // only remove child nodes on 2nd level to be able to validate mandatory properties of parent
+            childNodesByName.clear();
+            isValidationDone = true;
+            messages.add(new ValidationMessage(ValidationMessageSeverity.DEBUG,
+                    "Remove node information of children of " + getQualifiedPath(namePathResolver)));
+            return messages;
+        } else {
+            return Collections.singletonList(new ValidationMessage(ValidationMessageSeverity.DEBUG,
+                    "Already finalized validation of " + getQualifiedPath(namePathResolver)));
+        }
+    }
+
+    private Collection<ValidationMessage> validateMandatoryChildNodes(@NotNull NamePathResolver namePathResolver,
+            @NotNull ValidationMessageSeverity severity, @NotNull WorkspaceFilter filter) {
+        if (effectiveNodeType == null) {
+            return Collections.emptyList();
+        }
+
+        // validate mandatory child nodes of children
+        Collection<ValidationMessage> messages = new LinkedList<>();
+        for (QNodeDefinition mandatoryNodeType : effectiveNodeType.getMandatoryQNodeDefinitions()) {
+            // skip auto created ones
+            if (mandatoryNodeType.isAutoCreated()) {
+                continue;
+            }
+            boolean foundRequiredChildNode = false;
+            for (JcrNodeTypeMetaDataImpl child : childNodesByName.values()) {
+                foundRequiredChildNode = child.fulfillsNodeDefinition(mandatoryNodeType);
+            }
+
+            if (!foundRequiredChildNode && !mandatoryNodeType.getName().equals(NameConstants.ANY_NAME)) {
+                PathBuilder pathBuilder = new PathBuilder(this.getPath());
+                pathBuilder.addLast(mandatoryNodeType.getName());
+                try {
+                    if (filter.contains(namePathResolver.getJCRPath(pathBuilder.getPath()))) {
+                        messages.add(new ValidationMessage(severity, String.format(MESSAGE_MANDATORY_CHILD_NODE_MISSING,
+                                getNodeDefinitionLabel(namePathResolver, mandatoryNodeType),
+                                getEffectiveNodeTypeLabel(namePathResolver, effectiveNodeType), getQualifiedPath(namePathResolver))));
+                    } else {
+                        messages.add(new ValidationMessage(severity, String.format(MESSAGE_MANDATORY_UNCONTAINED_CHILD_NODE_MISSING,
+                                getNodeDefinitionLabel(namePathResolver, mandatoryNodeType),
+                                getEffectiveNodeTypeLabel(namePathResolver, effectiveNodeType), getQualifiedPath(namePathResolver))));
+                    }
+                } catch (NamespaceException | MalformedPathException e) {
+                    throw new IllegalStateException("Could not give out node types and name for " + mandatoryNodeType, e);
+                }
+            }
+        }
+
+        return messages;
+    }
+
+    private static String getEffectiveNodeTypeLabel(NameResolver nameResolver, EffectiveNodeType nodeType) throws NamespaceException {
+        return joinAsQualifiedJcrName(nameResolver, nodeType.getMergedNodeTypes());
+    }
+
+    private static String getNodeDefinitionLabel(NameResolver nameResolver, QNodeDefinition nodeDefinition) throws NamespaceException {
+        return nameResolver.getJCRName(nodeDefinition.getName()) + " ["
+                + joinAsQualifiedJcrName(nameResolver, nodeDefinition.getRequiredPrimaryTypes()) + "]";
+    }
+
+    private static String joinAsQualifiedJcrName(NameResolver nameResolver, Name[] names) throws NamespaceException {
+        StringBuilder types = new StringBuilder();
+        String delimiter = "";
+        for (Name name : names) {
+            types.append(delimiter).append(nameResolver.getJCRName(name));
+            delimiter = ", ";
+        }
+        return types.toString();
+    }
+
+    @Override
+    public @NotNull Collection<@NotNull ? extends JcrNodeTypeMetaData> getChildren() {
+        return childNodesByName.values();
+    }
+
+    @Override
+    public @NotNull JcrNodeTypeMetaData getOrCreateNode(NamePathResolver nameResolver, String path) throws RepositoryException {
+        return getNode(nameResolver, path, true).get();
+    }
+
+    @Override
+    public Optional<JcrNodeTypeMetaData> getNode(NamePathResolver nameResolver, String path) throws RepositoryException {
+        return getNode(nameResolver, path, false);
+    }
+
+    private Optional<JcrNodeTypeMetaData> getNode(NamePathResolver nameResolver, String path, boolean shouldCreateIfMissing)
+            throws RepositoryException {
+        // convert to fully namespaced path
+        Path qPath = nameResolver.getQPath(path);
+
+        // navigate there
+        Path qRelativePath = getPath().computeRelativePath(qPath);
+
+        // first go up until you reach a common parent
+        @NotNull
+        JcrNodeTypeMetaDataImpl currentNode = this;
+        for (Element element : qRelativePath.getElements()) {
+            if (!element.denotesParent()) {
+                break;
+            } else {
+                currentNode = currentNode.parentNode;
+            }
+        }
+        qRelativePath = currentNode.getPath().computeRelativePath(qPath);
+
+        // then go down until you match the path
+        for (Element element : qRelativePath.getElements()) {
+            if (element.denotesCurrent()) {
+                continue;
+            }
+            JcrNodeTypeMetaDataImpl childNode = currentNode.childNodesByName.get(element.getName());
+            if (childNode == null) {
+                if (shouldCreateIfMissing) {
+                    childNode = currentNode.addUnknownChildNode(element.getName());
+                } else {
+                    return Optional.empty();
+                }
+            }
+            currentNode = childNode;
+        }
+        return Optional.of(currentNode);
+    }
+
+    private Collection<ValidationMessage> validateMandatoryProperties(@NotNull NamePathResolver nameResolver,
+            @NotNull ValidationMessageSeverity severity) {
+
+        if (effectiveNodeType == null) {
+            return Collections.emptyList();
+        }
+        Collection<ValidationMessage> messages = new ArrayList<>();
+        // are all mandatory properties covered?
+        for (QPropertyDefinition mandatoryPropertyDefinition : effectiveNodeType.getMandatoryQPropertyDefinitions()) {
+            // ignore auto-created properties as they are created on-demand
+            if (mandatoryPropertyDefinition.isAutoCreated()) {
+                continue;
+            }
+            try {
+                if (!propertyTypesByName.containsKey(mandatoryPropertyDefinition.getName())) {
+                    messages.add(new ValidationMessage(severity,
+                            String.format(MESSAGE_MANDATORY_PROPERTY_MISSING,
+                                    nameResolver.getJCRName(mandatoryPropertyDefinition.getName()),
+                                    getEffectiveNodeTypeLabel(nameResolver, effectiveNodeType), getQualifiedPath(nameResolver))));
+                } else {
+                    // check type
+                    int actualPropertyType = propertyTypesByName.get(mandatoryPropertyDefinition.getName());
+                    if (mandatoryPropertyDefinition.getRequiredType() != actualPropertyType) {
+                        // check type
+                        messages.add(new ValidationMessage(severity,
+                                String.format(MESSAGE_MANDATORY_PROPERTY_WITH_WRONG_TYPE,
+                                        nameResolver.getJCRName(mandatoryPropertyDefinition.getName()),
+                                        PropertyType.nameFromValue(actualPropertyType),
+                                        PropertyType.nameFromValue(mandatoryPropertyDefinition.getRequiredType()),
+                                        getEffectiveNodeTypeLabel(nameResolver, effectiveNodeType), getQualifiedPath(nameResolver))));
+                    }
+                }
+            } catch (NamespaceException e) {
+                throw new IllegalStateException("Could not give out parent node types or property names for " + mandatoryPropertyDefinition,
+                        e);
+            }
+        }
+        return messages;
+    }
+
+    @Override
+    public void addProperty(@NotNull NodeContext nodeContext, @NotNull NamePathResolver namePathResolver,
+            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
+            @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider, @NotNull ItemDefinitionProvider itemDefinitionProvider,
+            @NotNull ValidationMessageSeverity severity, String name, boolean isMultiValue, Value... values) throws RepositoryException {
+        // some sanity checks on multivalue
+        if (!isMultiValue && values.length > 1) {
+            throw new IllegalArgumentException("isMultiValue is only supposed to be false if exactly one value is passed but "
+                    + values.length + " values were passed!");
+        }
+
+        Name qName;
+        try {
+            qName = namePathResolver.getQName(name);
+        } catch (IllegalNameException | NamespaceException e) {
+            throw new IllegalNameException("Invalid property name " + name, e);
+        }
+        propertyTypesByName.put(qName, values[0].getType());
+
+        // now check for validity
+        Optional<String> constraintViolation = validatePropertyConstraints(namePathResolver, effectiveNodeTypeProvider,
+                nodeTypeDefinitionProvider, itemDefinitionProvider, qName, values, isAuthenticationOrAuthorizationContext,
+                isMultiValue);
+        if (constraintViolation.isPresent()) {
+            messages.add(new ValidationMessage(severity,
+                    String.format(
+                            isImplicit ? MESSAGE_PROPERTY_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED
+                                    : MESSAGE_PROPERTY_NOT_ALLOWED,
+                            namePathResolver.getJCRName(qName), PropertyType.nameFromValue(values[0].getType()),
+                            getEffectiveNodeTypeLabel(namePathResolver, effectiveNodeType),
+                            constraintViolation.get()),
+                    nodeContext));
+        }
+    }
+
+    private @NotNull Optional<String> validatePropertyConstraints(@NotNull NamePathResolver namePathResolver,
+            @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider,
+            @NotNull NodeTypeDefinitionProvider nodeTypeDefinitionProvider, @NotNull ItemDefinitionProvider itemDefinitionProvider,
+            Name name, Value[] values, boolean allowProtected, boolean isMultiValue) throws RepositoryException {
+        if (effectiveNodeType == null) {
+            return Optional.empty();
+        }
+        QPropertyDefinition applicablePropertyDefinition;
+        try {
+            applicablePropertyDefinition = getPropertyDefinition(name, values[0].getType(), effectiveNodeType, itemDefinitionProvider,
+                    isMultiValue);
+        } catch (ConstraintViolationException t) {
+            return Optional.of(CONSTRAINT_PROPERTY_NOT_ALLOWED);
+        }
+        if (applicablePropertyDefinition.isAutoCreated() && !ALLOWED_PROTECTED_PROPERTIES.contains(name)) {
+            return Optional.of(CONSTRAINT_PROPERTY_AUTO_CREATED);
+        }
+        if (applicablePropertyDefinition.isProtected() && !allowProtected && !ALLOWED_PROTECTED_PROPERTIES.contains(name)) {
+            return Optional.of(CONSTRAINT_PROPERTY_PROTECTED);
+        }
+
+        for (Value value : values) {
+            try {
+                QValue qValue = ValueFormat.getQValue(value, namePathResolver, QVALUE_FACTORY);
+                ValueConstraint.checkValueConstraints(applicablePropertyDefinition, new QValue[] { qValue });
+            } catch (ConstraintViolationException e) {
+                return Optional.of(String.format(CONSTRAINT_PROPERTY_VALUE, e.getLocalizedMessage()));
+            }
+        }
+        return Optional.empty();
+    }
+
+    private static QPropertyDefinition getPropertyDefinition(Name name, int type, EffectiveNodeType effectiveNodeType,
+            ItemDefinitionProvider itemDefinitionProvider, boolean isMultiValue)
+            throws NoSuchNodeTypeException, ConstraintViolationException {
+        QPropertyDefinition def;
+        try {
+            def = itemDefinitionProvider.getQPropertyDefinition(effectiveNodeType.getAllNodeTypes(), name, type,
+                    isMultiValue);
+        } catch (ConstraintViolationException e) {
+            if (type != PropertyType.UNDEFINED) {
+                def = itemDefinitionProvider.getQPropertyDefinition(effectiveNodeType.getAllNodeTypes(), name, PropertyType.UNDEFINED,
+                        isMultiValue);
+            } else {
+                throw e;
+            }
+        }
+        return def;
+    }
+
+    private boolean fulfillsNodeDefinition(QNodeDefinition nodeDefinition) {
+        // name must match
+        if (!nodeDefinition.getName().equals(NameConstants.ANY_NAME) && !nodeDefinition.getName().equals(name)) {
+            return false;
+        }
+
+        for (Name requiredType : nodeDefinition.getRequiredPrimaryTypes()) {
+            // type must match all of the given types
+            if (!effectiveNodeType.includesNodeType(requiredType)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    public static @NotNull JcrNodeTypeMetaDataImpl createRoot(@NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider)
+            throws ConstraintViolationException, NoSuchNodeTypeException {
+        return new JcrNodeTypeMetaDataImpl(NameConstants.ROOT, NameConstants.REP_ROOT, effectiveNodeTypeProvider.getEffectiveNodeType(
+                new Name[] {
+                        NameConstants.REP_ROOT,
+                        NameConstants.REP_ACCESS_CONTROLLABLE,
+                        NameConstants.REP_REPO_ACCESS_CONTROLLABLE }),
+                null, false, false);
+    }
+
+    @Override
+    public void fetchAndClearValidationMessages(Collection<ValidationMessage> messages) {
+        messages.addAll(this.messages);
+        this.messages.clear();
+    }
+
+    private Path getPath() {
+        if (parentNode == null) {
+            return PathFactoryImpl.getInstance().getRootPath();
+        } else {
+            PathBuilder pathBuilder = new PathBuilder(parentNode.getPath());
+            pathBuilder.addLast(name);
+            try {
+                return pathBuilder.getPath();
+            } catch (MalformedPathException e) {
+                throw new IllegalStateException("Could not create path from parent and name", e);
+            }
+        }
+    }
+
+    @Override
+    public String getQualifiedPath(NamePathResolver resolver) throws NamespaceException {
+        return resolver.getJCRPath(getPath());
+    }
+
+}
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NamespaceExceptionInNodeName.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NamespaceExceptionInNodeName.java
new file mode 100644
index 00000000..410dd991
--- /dev/null
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NamespaceExceptionInNodeName.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.validation.spi.impl.nodetype;
+
+import javax.jcr.NamespaceException;
+
+public class NamespaceExceptionInNodeName extends NamespaceException {
+
+    /**
+     * 
+     */
+    private static final long serialVersionUID = 1L;
+
+    public NamespaceExceptionInNodeName(String message, Throwable rootCause) {
+        super(message, rootCause);
+    }
+
+    public NamespaceExceptionInNodeName(NamespaceException e) {
+        super(e.getLocalizedMessage(), e);
+    }
+}
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeNameAndType.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeNameAndType.java
deleted file mode 100644
index 0bec3a22..00000000
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeNameAndType.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package org.apache.jackrabbit.vault.validation.spi.impl.nodetype;
-
-import java.util.Collection;
-import java.util.LinkedList;
-
-import javax.jcr.NamespaceException;
-import javax.jcr.nodetype.ConstraintViolationException;
-import javax.jcr.nodetype.NoSuchNodeTypeException;
-
-import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
-import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeTypeProvider;
-import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.QNodeDefinition;
-import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
-import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
-import org.apache.jackrabbit.spi.commons.name.NameConstants;
-import org.apache.jackrabbit.vault.util.DocViewNode;
-import org.jetbrains.annotations.NotNull;
-import org.jetbrains.annotations.Nullable;
-
-/** 
- * Encapsulates the expanded name and its underlying effective node type.
- * In addition stores references to the child node names and types.
- */
-final class NodeNameAndType {
-    private final Name name;
-    private final EffectiveNodeType effectiveNodeType;
-
-    public static NodeNameAndType createUnknownNodeNameAndType(@Nullable NodeNameAndType parent) {
-        return new NodeNameAndType(parent);
-    }
-
-    private NodeNameAndType(@Nullable NodeNameAndType parent) {
-        this.effectiveNodeType = null;
-        this.name = null;
-    }
-
-    public NodeNameAndType(@NotNull NameResolver nameResolver, @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider, @NotNull DocViewNode node) throws IllegalNameException, NamespaceException, ConstraintViolationException, NoSuchNodeTypeException {
-        this(nameResolver, effectiveNodeTypeProvider, node.name, node.primary, node.mixins);
-    }
-
-    public  NodeNameAndType(@NotNull NameResolver nameResolver, @NotNull EffectiveNodeTypeProvider effectiveNodeTypeProvider, @NotNull String name, @NotNull String primaryType, String... mixinTypes) throws IllegalNameException, NamespaceException, ConstraintViolationException, NoSuchNodeTypeException {
-        try {
-            // special handling for root node (https://issues.apache.org/jira/browse/JCR-4625)
-            if (name.isEmpty()) {
-                this.name = NameConstants.ROOT;
-            } else {
-                this.name = nameResolver.getQName(name);
-            }
-        } catch (IllegalNameException|NamespaceException e) {
-            throw new IllegalNameException("Invalid node name " + name + ": '" + e.getMessage() + "'", e);
-        }
-        Collection<Name> types = new LinkedList<>();
-        try {
-            types.add(nameResolver.getQName(primaryType));
-        } catch (IllegalNameException|NamespaceException e) {
-            throw new IllegalNameException("Invalid primary type " + primaryType + ": '" + e.getMessage() + "'", e);
-        }
-        if (mixinTypes != null) {
-            for (String mixin : mixinTypes) {
-                try {
-                    types.add(nameResolver.getQName(mixin));
-                } catch (IllegalNameException|NamespaceException e) { 
-                    throw new IllegalNameException("Invalid mixin type " + mixin + ": '" + e.getMessage() + "'", e);
-                }
-            }
-        }
-        effectiveNodeType = effectiveNodeTypeProvider.getEffectiveNodeType(types.toArray(new Name[0]));
-    }
-
-    public boolean isUnknown() {
-        return this.effectiveNodeType == null && this.name == null;
-    }
-
-    public boolean fulfillsNodeDefinition(QNodeDefinition nodeDefinition) {
-        // name must match
-        if (!nodeDefinition.getName().equals(NameConstants.ANY_NAME) && !nodeDefinition.getName().equals(name)) {
-            return false;
-        }
-
-        for (Name requiredType : nodeDefinition.getRequiredPrimaryTypes()) {
-            // type must match one of the given types
-            if (!effectiveNodeType.includesNodeType(requiredType)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    public EffectiveNodeType getEffectiveNodeType() {
-        return effectiveNodeType;
-    }
-
-    @Override
-    public String toString() {
-        return "NodeNameAndType [" + (name != null ? "name=" + name + ", " : "")
-                + (effectiveNodeType != null ? "effectiveNodeType=" + effectiveNodeType : "") + "]";
-    }
-
-    
-}
\ No newline at end of file
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeManagerProvider.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeManagerProvider.java
index 1cc04aff..05146d89 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeManagerProvider.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeManagerProvider.java
@@ -60,22 +60,22 @@ import org.apache.jackrabbit.spi.commons.nodetype.NodeTypeStorage;
 import org.apache.jackrabbit.spi.commons.nodetype.NodeTypeStorageImpl;
 import org.apache.jackrabbit.spi.commons.value.QValueFactoryImpl;
 import org.apache.jackrabbit.value.ValueFactoryImpl;
+import org.jetbrains.annotations.NotNull;
 
 public class NodeTypeManagerProvider implements ManagerProvider, NamespaceStorage {
 
-    
     // namespace related helpers
-    private final NamespaceMapping namespaceMapping;
-    private final NamespaceRegistry namespaceRegistry;
-    private final NamespaceResolver namespaceResolver;
-    private final NamePathResolver npResolver;
+    private final @NotNull NamespaceMapping namespaceMapping;
+    private final @NotNull NamespaceRegistry namespaceRegistry;
+    private final @NotNull NamespaceResolver namespaceResolver;
+    private final @NotNull NamePathResolver npResolver;
     
     // nodetype related helpers
-    private final NodeTypeStorage nodeTypeStorage;
-    private final NodeTypeRegistryImpl nodeTypeRegistry;
-    private final NodeTypeManagerImpl nodeTypeManager;
+    private final @NotNull NodeTypeStorage nodeTypeStorage;
+    private final @NotNull NodeTypeRegistryImpl nodeTypeRegistry;
+    private final @NotNull NodeTypeManagerImpl nodeTypeManager;
     
-    private final ItemDefinitionProvider itemDefinitionProvider;
+    private final @NotNull ItemDefinitionProvider itemDefinitionProvider;
 
     public NodeTypeManagerProvider() throws IOException, RepositoryException, ParseException {
         namespaceMapping = new NamespaceMapping();
@@ -88,7 +88,7 @@ public class NodeTypeManagerProvider implements ManagerProvider, NamespaceStorag
         nodeTypeRegistry = NodeTypeRegistryImpl.create(nodeTypeStorage, namespaceRegistry);
         nodeTypeManager = new NodeTypeManagerImpl(nodeTypeRegistry, this);
         itemDefinitionProvider = new ItemDefinitionProviderImpl(nodeTypeRegistry, null, null);
-        // always provide default
+        // always provide default nodetypes
         try (Reader reader = new InputStreamReader(
                 this.getClass().getResourceAsStream("/default-nodetypes.cnd"),
                 StandardCharsets.US_ASCII)) {
@@ -101,26 +101,26 @@ public class NodeTypeManagerProvider implements ManagerProvider, NamespaceStorag
     }
 
     @Override
-    public NamePathResolver getNamePathResolver() {
+    public @NotNull NamePathResolver getNamePathResolver() {
         return npResolver;
     }
 
     @Override
-    public NameResolver getNameResolver() {
+    public @NotNull NameResolver getNameResolver() {
         return npResolver;
     }
 
     @Override
-    public PathResolver getPathResolver() {
+    public @NotNull PathResolver getPathResolver() {
         return npResolver;
     }
 
     @Override
-    public NamespaceResolver getNamespaceResolver() {
+    public @NotNull NamespaceResolver getNamespaceResolver() {
         return namespaceResolver;
     }
 
-    public NodeTypeManager getNodeTypeManager() {
+    public @NotNull NodeTypeManager getNodeTypeManager() {
         return nodeTypeManager;
     }
 
@@ -145,27 +145,27 @@ public class NodeTypeManagerProvider implements ManagerProvider, NamespaceStorag
     }
 
     @Override
-    public ItemDefinitionProvider getItemDefinitionProvider() {
+    public @NotNull ItemDefinitionProvider getItemDefinitionProvider() {
         return itemDefinitionProvider;
     }
 
     @Override
-    public NodeTypeDefinitionProvider getNodeTypeDefinitionProvider() {
+    public @NotNull NodeTypeDefinitionProvider getNodeTypeDefinitionProvider() {
         return nodeTypeManager;
     }
 
     @Override
-    public EffectiveNodeTypeProvider getEffectiveNodeTypeProvider() {
+    public @NotNull EffectiveNodeTypeProvider getEffectiveNodeTypeProvider() {
         return nodeTypeRegistry;
     }
 
     @Override
-    public ValueFactory getJcrValueFactory() throws RepositoryException {
+    public @NotNull ValueFactory getJcrValueFactory() throws RepositoryException {
         return ValueFactoryImpl.getInstance();
     }
 
     @Override
-    public QValueFactory getQValueFactory() throws RepositoryException {
+    public @NotNull QValueFactory getQValueFactory() throws RepositoryException {
         return QValueFactoryImpl.getInstance();
     }
 
@@ -200,5 +200,4 @@ public class NodeTypeManagerProvider implements ManagerProvider, NamespaceStorag
             throws NamespaceException, UnsupportedRepositoryOperationException, AccessDeniedException, RepositoryException {
         namespaceMapping.removeMapping(uri);
     }
-
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
index f3af76c7..8d0d3de6 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
@@ -16,74 +16,61 @@
  */
 package org.apache.jackrabbit.vault.validation.spi.impl.nodetype;
 
-import java.util.AbstractMap.SimpleEntry;
+import java.nio.file.Paths;
 import java.util.ArrayList;
-import java.util.Arrays;
+import java.util.Calendar;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
-import java.util.Map;
+import java.util.Optional;
 import java.util.Set;
-import java.util.TreeMap;
-import java.util.stream.Collectors;
-import java.util.stream.Stream;
 
 import javax.jcr.NamespaceException;
-import javax.jcr.PropertyType;
+import javax.jcr.PathNotFoundException;
 import javax.jcr.RepositoryException;
 import javax.jcr.Value;
-import javax.jcr.ValueFactory;
 import javax.jcr.ValueFormatException;
 import javax.jcr.nodetype.ConstraintViolationException;
 import javax.jcr.nodetype.NoSuchNodeTypeException;
-import javax.jcr.nodetype.NodeType;
 
 import org.apache.commons.lang3.StringUtils;
-import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
-import org.apache.jackrabbit.jcr2spi.nodetype.ItemDefinitionProvider;
-import org.apache.jackrabbit.jcr2spi.nodetype.NodeTypeDefinitionProvider;
+import org.apache.jackrabbit.JcrConstants;
+import org.apache.jackrabbit.oak.spi.nodetype.NodeTypeConstants;
 import org.apache.jackrabbit.spi.Name;
-import org.apache.jackrabbit.spi.QNodeDefinition;
-import org.apache.jackrabbit.spi.QNodeTypeDefinition;
-import org.apache.jackrabbit.spi.QPropertyDefinition;
-import org.apache.jackrabbit.spi.QValue;
-import org.apache.jackrabbit.spi.QValueFactory;
 import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
-import org.apache.jackrabbit.spi.commons.conversion.NamePathResolver;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.spi.commons.conversion.NameParser;
 import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
 import org.apache.jackrabbit.spi.commons.name.NameConstants;
 import org.apache.jackrabbit.spi.commons.name.NameFactoryImpl;
-import org.apache.jackrabbit.spi.commons.nodetype.constraint.ValueConstraint;
-import org.apache.jackrabbit.spi.commons.value.ValueFormat;
-import org.apache.jackrabbit.value.ValueHelper;
+import org.apache.jackrabbit.value.BinaryValue;
+import org.apache.jackrabbit.value.DateValue;
+import org.apache.jackrabbit.value.StringValue;
 import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
-import org.apache.jackrabbit.vault.fs.spi.ACLManagement;
-import org.apache.jackrabbit.vault.fs.spi.UserManagement;
-import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.JackrabbitUserManagement;
-import org.apache.jackrabbit.vault.fs.spi.impl.jcr20.JcrACLManagement;
 import org.apache.jackrabbit.vault.util.DocViewNode;
 import org.apache.jackrabbit.vault.util.DocViewProperty;
 import org.apache.jackrabbit.vault.util.Text;
+import org.apache.jackrabbit.vault.validation.ValidationExecutor;
 import org.apache.jackrabbit.vault.validation.spi.DocumentViewXmlValidator;
 import org.apache.jackrabbit.vault.validation.spi.JcrPathValidator;
 import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValidator {
-
-    static final String MESSAGE_MANDATORY_CHILD_NODE_MISSING = "Mandatory child node missing: %s";
-    static final String MESSAGE_PROPERTY_ERROR = "Error while retrieving property '%s': %s";
-    static final String MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE = "%s. Skip validation of nodes with that type/name";
+    static final String MESSAGE_INVALID_PROPERTY_VALUE = "Property %s does not have a valid value: %s";
+    static final String MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE = "%s Skip validation of nodes with that type/name";
     static final String MESSAGE_MISSING_PRIMARY_TYPE = "Mandatory jcr:primaryType missing on node '%s'";
-    static final String MESSAGE_PROPERTY_NOT_ALLOWED = "Property '%s' is not allowed in node with types '[%s]': %s";
-    static final String MESSAGE_MANDATORY_PROPERTY_MISSING = "Mandatory property '%s' missing in node with types [%s]";
-    static final String MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED = "Node '%s' is not allowed as child of not contained node with potential default types '[%s]': %s";
-    static final String MESSAGE_CHILD_NODE_NOT_ALLOWED = "Node '%s' is not allowed as child of node with types '[%s]': %s";
+
+    static final Value DUMMY_BINARY_VALUE = new BinaryValue("dummy binary");
+    static final Value DUMMY_DATE_VALUE = new DateValue(Calendar.getInstance());
+    static final Value DUMMY_STRING_VALUE = new StringValue("dummy string");
+
     private final WorkspaceFilter filter;
     private final ValidationMessageSeverity defaultSeverity;
     private final ValidationMessageSeverity severityForUnknownNodeTypes;
@@ -91,35 +78,22 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
     private final NodeTypeManagerProvider ntManagerProvider;
     private final Set<String> loggedUnknownNodeTypeMessages;
 
-    private final EffectiveNodeType defaultType;
-    private final UserManagement userManagement;
-    private final ACLManagement aclManagement;
-    private NodeContext protectedNodeContext;
-    /** The context of the current node */
-    private Map<String, NodeNameAndType> nodeTypePerPath;
-
-    private static final Collection<Name> ALLOWED_PROTECTED_PROPERTIES = Arrays.asList(NameConstants.JCR_PRIMARYTYPE,
-            NameConstants.JCR_MIXINTYPES);
-
-    // properties being set by the {@link FileArtifactHandler} (they are part of another file) are ignored
-    private static final Map<Name, List<Name>> IGNORED_MANDATORY_PROPERTIES_PER_NODE_TYPE = Stream.of(
-            new SimpleEntry<>(NameConstants.NT_RESOURCE,
-                    Arrays.asList(NameConstants.JCR_DATA)))
-            .collect(Collectors.toMap(SimpleEntry::getKey, SimpleEntry::getValue));
+    private final @NotNull Name defaultType;
+    private JcrNodeTypeMetaData currentNodeTypeMetaData;
 
     public NodeTypeValidator(@NotNull WorkspaceFilter filter, @NotNull NodeTypeManagerProvider ntManagerProvider,
-            @NotNull EffectiveNodeType defaultEffectiveNodeType, @NotNull ValidationMessageSeverity defaultSeverity,
-            @NotNull ValidationMessageSeverity severityForUnknownNodeTypes) {
+            @NotNull Name defaultPrimaryNodeType, @NotNull ValidationMessageSeverity defaultSeverity,
+            @NotNull ValidationMessageSeverity severityForUnknownNodeTypes)
+            throws IllegalNameException, ConstraintViolationException, NoSuchNodeTypeException {
         this.filter = filter;
         this.ntManagerProvider = ntManagerProvider;
-        this.defaultType = defaultEffectiveNodeType;
+        this.defaultType = defaultPrimaryNodeType;
         this.defaultSeverity = defaultSeverity;
         this.severityForUnknownNodeTypes = severityForUnknownNodeTypes;
         this.docViewPropertyValueFactory = new DocViewPropertyValueFactory();
-        this.userManagement = new JackrabbitUserManagement();
-        this.aclManagement = new JcrACLManagement();
         this.loggedUnknownNodeTypeMessages = new HashSet<>();
-        this.nodeTypePerPath = new TreeMap<>();
+
+        this.currentNodeTypeMetaData = JcrNodeTypeMetaDataImpl.createRoot(ntManagerProvider.getEffectiveNodeTypeProvider());
     }
 
     static String getDocViewNodeLabel(DocViewNode node) {
@@ -147,327 +121,240 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
                 return null;
             }
         }
-
-        // special handling for users and acls
-        if (aclManagement.isACLNodeType(node.primary) || userManagement.isAuthorizableNodeType(node.primary)) {
-            protectedNodeContext = nodeContext;
-        }
-
-        boolean allowProtectedSubNodesAndProperties = protectedNodeContext != null;
         Collection<ValidationMessage> messages = new LinkedList<>();
-        String parentNodePath = Text.getRelativeParent(nodeContext.getNodePath(), 1);
-        NodeNameAndType parentNodeNameAndType = nodeTypePerPath.get(parentNodePath);
-        NodeNameAndType newNodeNameAndType = null;
-        try {
-            // check node itself against parent node type
-            if (!aclManagement.isACLNodeType(node.primary)) {
-                final EffectiveNodeType parentNodeType;
-                final boolean useDefaultNodeType;
-
-                if (parentNodeNameAndType == null || !filter.contains(parentNodePath)) {
-                    parentNodeType = defaultType;
-                    useDefaultNodeType = true;
-                } else if (!parentNodeNameAndType.isUnknown()) {
-                    parentNodeType = parentNodeNameAndType.getEffectiveNodeType();
-                    useDefaultNodeType = false;
-                } else {
-                    parentNodeType = null;
-                    useDefaultNodeType = false;
-                }
+        messages.addAll(getOrCreateNewNode(nodeContext, isImplicit(nodeContext.getNodePath()), node.primary, node.mixins));
 
-                if (parentNodeType != null) {
-                    String constraintViolation = getChildNodeConstraintViolation(node, parentNodeType,
-                            ntManagerProvider.getNodeTypeDefinitionProvider(),
-                            ntManagerProvider.getNameResolver(), ntManagerProvider.getItemDefinitionProvider(),
-                            allowProtectedSubNodesAndProperties);
-                    if (constraintViolation != null) {
-                        messages.add(new ValidationMessage(defaultSeverity,
-                                String.format(
-                                        useDefaultNodeType ? MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED
-                                                : MESSAGE_CHILD_NODE_NOT_ALLOWED,
-                                        getDocViewNodeLabel(node),
-                                        effectiveNodeTypeToString(ntManagerProvider.getNameResolver(), parentNodeType),
-                                        constraintViolation)));
-
-                    }
-                }
+        for (DocViewProperty property : node.props.values()) {
+            try {
+                messages.addAll(addProperty(nodeContext, property.name, property.isMulti, docViewPropertyValueFactory.getValues(property)));
+            } catch (ValueFormatException e) {
+                messages.add(new ValidationMessage(defaultSeverity,
+                        String.format(MESSAGE_INVALID_PROPERTY_VALUE, property.name, e.getLocalizedMessage())));
             }
+        }
+        // emit messages
+        currentNodeTypeMetaData.fetchAndClearValidationMessages(messages);
 
-            // get current node's node type and name and register in tree
-            newNodeNameAndType = new NodeNameAndType(ntManagerProvider.getNameResolver(),
-                    ntManagerProvider.getEffectiveNodeTypeProvider(), node);
-            nodeTypePerPath.put(nodeContext.getNodePath(), newNodeNameAndType);
-
-            // check all properties
-            Collection<Name> foundProperties = new ArrayList<>(node.props.size());
-            for (DocViewProperty property : node.props.values()) {
-                String constraintViolation = getPropertyConstraintViolation(property, newNodeNameAndType.getEffectiveNodeType(),
-                        allowProtectedSubNodesAndProperties);
-                if (constraintViolation != null) {
-                    messages.add(new ValidationMessage(defaultSeverity, String.format(MESSAGE_PROPERTY_NOT_ALLOWED, property,
-                            effectiveNodeTypeToString(ntManagerProvider.getNameResolver(), newNodeNameAndType.getEffectiveNodeType()),
-                            constraintViolation)));
-                }
-                foundProperties.add(NameFactoryImpl.getInstance().create(property.name));
-            }
-            // are all mandatory properties covered?
-            for (QPropertyDefinition mandatoryPropertyDefinition : newNodeNameAndType.getEffectiveNodeType()
-                    .getMandatoryQPropertyDefinitions()) {
-                // ignore auto-created properties as they are created on-demand
-                if (!mandatoryPropertyDefinition.isAutoCreated() && !foundProperties.contains(mandatoryPropertyDefinition.getName())) {
+        // defer checking for missing mandatory properties (as those might be added by some other files)
+        return messages;
+    }
 
-                    // ignore propertes which may be provided by the {@link FileArtifactHandler} (they are part of another file)
-                    List<Name> ignoredProperties = IGNORED_MANDATORY_PROPERTIES_PER_NODE_TYPE
-                            .get(mandatoryPropertyDefinition.getDeclaringNodeType());
-                    if (ignoredProperties != null && ignoredProperties.contains(mandatoryPropertyDefinition.getName())) {
-                        // TODO: skipping for now as validating those from other files requires major effort
-                        continue;
-                    }
-                    messages.add(new ValidationMessage(defaultSeverity,
-                            String.format(MESSAGE_MANDATORY_PROPERTY_MISSING, mandatoryPropertyDefinition.getName(),
-                                    effectiveNodeTypeToString(ntManagerProvider.getNameResolver(),
-                                            newNodeNameAndType.getEffectiveNodeType()))));
-                }
-            }
+    private boolean isImplicit(String path) {
+        return !filter.contains(path);
+    }
 
-        } catch (NoSuchNodeTypeException | IllegalNameException | NamespaceException e) {
+    private Collection<ValidationMessage> addProperty(NodeContext nodeContext, String propertyName, boolean isMultiValue, Value... values) {
+        Collection<ValidationMessage> messages = new ArrayList<>();
+        try {
+            currentNodeTypeMetaData.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(),
+                    ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                    ntManagerProvider.getItemDefinitionProvider(), defaultSeverity, propertyName, isMultiValue, values);
+        } catch (NoSuchNodeTypeException | NamespaceException e) {
             // log each unknown node type/namespace only once!
             if (!loggedUnknownNodeTypeMessages.contains(e.getMessage())) {
                 messages.add(new ValidationMessage(severityForUnknownNodeTypes,
-                        String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), e));
+                        String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), nodeContext, e));
                 loggedUnknownNodeTypeMessages.add(e.getMessage());
             }
-            if (newNodeNameAndType == null) {
-                nodeTypePerPath.put(nodeContext.getNodePath(), NodeNameAndType.createUnknownNodeNameAndType(parentNodeNameAndType));
-            }
         } catch (RepositoryException e) {
-            throw new IllegalStateException("Could not validate nodes/properties against node types: " + e.getMessage(), e);
+            throw new IllegalStateException("Could not validate property against node types: " + e.getMessage(), e);
         }
         return messages;
     }
 
-    @Override
-    public @Nullable Collection<ValidationMessage> validateEnd(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,
-            boolean isRoot) {
-
-        if (nodeContext.equals(protectedNodeContext)) {
-            protectedNodeContext = null;
-        }
-
-        // validate mandatory child nodes
-        NodeNameAndType currentNodeNameAndType = nodeTypePerPath.get(nodeContext.getNodePath());
-        if (currentNodeNameAndType != null && !currentNodeNameAndType.isUnknown()) {
-            Collection<ValidationMessage> messages = new LinkedList<>();
-            for (QNodeDefinition mandatoryNodeType : currentNodeNameAndType.getEffectiveNodeType().getMandatoryQNodeDefinitions()) {
-                NodeNameAndType childNodeType;
-                try {
-                    childNodeType = nodeTypePerPath.get(nodeContext.getNodePath() + "/" + ntManagerProvider.getNameResolver().getJCRName(mandatoryNodeType.getName()));
-                } catch (NamespaceException e1) {
-                    throw new IllegalStateException("Could not find namespace for mandatory child node" + mandatoryNodeType.getName());
-                }
-                boolean foundRequiredChildNode = childNodeType != null && childNodeType.fulfillsNodeDefinition(mandatoryNodeType);
-                if (!foundRequiredChildNode) {
-                    try {
-                        messages.add(new ValidationMessage(defaultSeverity, String.format(MESSAGE_MANDATORY_CHILD_NODE_MISSING,
-                                nodeDefinitionToString(ntManagerProvider.getNameResolver(), mandatoryNodeType))));
-                    } catch (NamespaceException e) {
-                        throw new IllegalStateException("Could not give out node types and name for " + mandatoryNodeType, e);
-                    }
-                }
-            }
-            return messages;
-        } else {
-            return null;
+    private Optional<JcrNodeTypeMetaData> getNode(String nodePath) {
+        try {
+            return currentNodeTypeMetaData.getNode(ntManagerProvider.getNamePathResolver(), nodePath);
+        } catch (NamespaceException e) {
+            return Optional.empty();
+        } catch (RepositoryException e) {
+            throw new IllegalStateException("Could not get node types for path '" + nodePath + "': " + e.getMessage(), e);
         }
-
     }
 
-    @Override
-    public @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext, boolean isFolder) {
-        if (isFolder && !nodeTypePerPath.containsKey(nodeContext.getNodePath())) {
+    private @NotNull Collection<ValidationMessage> getOrCreateNewNode(NodeContext nodeContext, boolean isImplicit, String primaryType,
+            String... mixinTypes) {
+        Optional<JcrNodeTypeMetaData> node = getNode(nodeContext.getNodePath());
+        if (node.isPresent()) {
+            currentNodeTypeMetaData = node.get();
             try {
-                NodeNameAndType nodeNameAndType = new NodeNameAndType(ntManagerProvider.getNameResolver(),
-                        ntManagerProvider.getEffectiveNodeTypeProvider(), Text.getName(nodeContext.getNodePath()), NodeType.NT_FOLDER);
-                nodeTypePerPath.put(nodeContext.getNodePath(), nodeNameAndType);
-            } catch (NoSuchNodeTypeException | IllegalNameException | NamespaceException e) {
+                currentNodeTypeMetaData.setNodeTypes(ntManagerProvider.getNameResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                        primaryType, mixinTypes);
+            } catch (NoSuchNodeTypeException | NamespaceException e) {
+                currentNodeTypeMetaData.setUnknownNodeTypes();
                 // log each unknown node type/namespace only once!
                 if (!loggedUnknownNodeTypeMessages.contains(e.getMessage())) {
                     loggedUnknownNodeTypeMessages.add(e.getMessage());
                     return Collections.singleton(new ValidationMessage(severityForUnknownNodeTypes,
-                            String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), e));
+                            String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage(), nodeContext)));
                 }
             } catch (RepositoryException e) {
-                throw new IllegalStateException("Could not validate nodes/properties against node types: " + e.getMessage(), e);
+                throw new IllegalStateException(
+                        "Could not create node type information for path '" + nodeContext.getNodePath() + "': " + e.getMessage(), e);
             }
-        }
-        return null;
-    }
-
-    static String effectiveNodeTypeToString(NameResolver nameResolver, EffectiveNodeType nodeType) throws NamespaceException {
-        return joinAsQualifiedJcrName(nameResolver, nodeType.getMergedNodeTypes());
-    }
-
-    static String nodeDefinitionToString(NameResolver nameResolver, QNodeDefinition nodeDefinition) throws NamespaceException {
-        return nameResolver.getJCRName(nodeDefinition.getName()) + " ["
-                + joinAsQualifiedJcrName(nameResolver, nodeDefinition.getRequiredPrimaryTypes()) + "]";
-    }
-
-    private static String joinAsQualifiedJcrName(NameResolver nameResolver, Name[] names) throws NamespaceException {
-        StringBuilder types = new StringBuilder();
-        String delimiter = "";
-        for (Name name : names) {
-            types.append(delimiter).append(nameResolver.getJCRName(name));
-            delimiter = ", ";
-        }
-        return types.toString();
-    }
-
-    private static QPropertyDefinition getPropertyDefinition(Name name, int type, EffectiveNodeType effectiveNodeType,
-            ItemDefinitionProvider itemDefinitionProvider, boolean multiValued)
-            throws NoSuchNodeTypeException, ConstraintViolationException {
-        QPropertyDefinition def;
-        try {
-            def = itemDefinitionProvider.getQPropertyDefinition(effectiveNodeType.getAllNodeTypes(), name, type,
-                    multiValued);
-        } catch (ConstraintViolationException e) {
-            if (type != PropertyType.UNDEFINED) {
-                def = itemDefinitionProvider.getQPropertyDefinition(effectiveNodeType.getAllNodeTypes(), name, PropertyType.UNDEFINED,
-                        multiValued);
-            } else {
-                throw e;
-            }
-        }
-        return def;
-    }
-
-    private static void validateValueConstraints(Value value, QPropertyDefinition def, ValueFactory valueFactory,
-            QValueFactory qValueFactory, NamePathResolver namePathResolver) throws RepositoryException {
-        final Value v;
-        if (def.getRequiredType() != 0 && def.getRequiredType() != value.getType()) {
-            v = ValueHelper.convert(value, def.getRequiredType(), valueFactory);
+            return Collections.emptyList();
         } else {
-            v = value;
+            return createNewNode(nodeContext, isImplicit, primaryType, mixinTypes);
         }
-        QValue qValue = ValueFormat.getQValue(v, namePathResolver, qValueFactory);
-        ValueConstraint.checkValueConstraints(def, new QValue[] { qValue });
     }
 
-    String getPropertyConstraintViolation(DocViewProperty property, EffectiveNodeType effectiveNodeType, boolean allowProtected)
-            throws RepositoryException {
-        Name name = ntManagerProvider.getNameResolver().getQName(property.name);
-
+    private @NotNull Collection<ValidationMessage> createNewNode(NodeContext nodeContext, boolean isImplicit, String primaryType,
+            String... mixinTypes) {
+        Collection<ValidationMessage> messages = new ArrayList<>();
+        String nodePath = nodeContext.getNodePath();
+        if (nodePath.equals("/") && !isImplicit) {
+            throw new IllegalStateException("Can not create non implicit root node with path \"/\"");
+        }
+        String parentNodePath = Text.getRelativeParent(nodePath, 1);
+        String nodeName = Text.getName(nodePath);
         try {
-            if (property.isMulti) {
-                return getPropertyConstraintViolation(name, docViewPropertyValueFactory.getValues(property), effectiveNodeType,
-                        ntManagerProvider.getItemDefinitionProvider(), ntManagerProvider.getJcrValueFactory(),
-                        ntManagerProvider.getQValueFactory(), ntManagerProvider.getNamePathResolver(), allowProtected);
-            } else {
-                return getPropertyConstraintViolation(name, docViewPropertyValueFactory.getValue(property), effectiveNodeType,
-                        ntManagerProvider.getItemDefinitionProvider(), ntManagerProvider.getJcrValueFactory(),
-                        ntManagerProvider.getQValueFactory(), ntManagerProvider.getNamePathResolver(), allowProtected);
+            //
+            JcrNodeTypeMetaData parentNode = currentNodeTypeMetaData.getOrCreateNode(ntManagerProvider.getNamePathResolver(),
+                    parentNodePath);
+            try {
+                if (isImplicit) {
+                    if (!nodePath.equals("/")) {
+                        currentNodeTypeMetaData = parentNode.addImplicitChildNode(ntManagerProvider.getNameResolver(),
+                                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                                ntManagerProvider.getItemDefinitionProvider(), nodeContext, defaultType);
+                    } else {
+                        // root node cannot be replaced
+                        currentNodeTypeMetaData = parentNode;
+                    }
+                } else {
+                    currentNodeTypeMetaData = parentNode.addChildNode(ntManagerProvider.getNameResolver(),
+                            ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                            ntManagerProvider.getItemDefinitionProvider(), defaultSeverity, nodeContext, primaryType, mixinTypes);
+                }
+            } catch (NoSuchNodeTypeException | NamespaceException e) {
+                // TODO: NoSuchNodeTypeException might be thrown due to previous registration of the namespace for a node name
+                
+                // log each unknown node type/namespace only once!
+                if (!loggedUnknownNodeTypeMessages.contains(e.getMessage())) {
+                    messages.add(new ValidationMessage(severityForUnknownNodeTypes,
+                            String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), nodeContext, e));
+                    loggedUnknownNodeTypeMessages.add(e.getMessage());
+                }
+                if (e instanceof NamespaceExceptionInNodeName) {
+                    // now register namespace with an arbitrary namespace url
+                    NameParser.parse(nodeName, new OnDemandRegisterNamespaceResolverWrapper(ntManagerProvider),
+                            NameFactoryImpl.getInstance());
+                    messages.addAll(createNewNode(nodeContext, isImplicit, primaryType, mixinTypes));
+                } else {
+                    currentNodeTypeMetaData = parentNode.addUnknownChildNode(ntManagerProvider.getNameResolver(), nodeName);
+                }
             }
-        } catch (NamespaceException e) {
-            throw new NamespaceException(String.format(MESSAGE_PROPERTY_ERROR, property.name, e.getMessage()), e);
         } catch (RepositoryException e) {
-            throw new RepositoryException(String.format(MESSAGE_PROPERTY_ERROR, property.name, e.getMessage()), e);
-        }
-    }
-
-    static String getPropertyConstraintViolation(Name name, Value value, EffectiveNodeType effectiveNodeType,
-            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,
-            NamePathResolver namePathResolver, boolean allowProtected) throws RepositoryException {
-        QPropertyDefinition def;
-        try {
-            def = getPropertyDefinition(name, value.getType(), effectiveNodeType, itemDefinitionProvider, false);
-        } catch (ConstraintViolationException t) {
-            return "No property definition found for name!";
-        }
-
-        if (def.isProtected() && !allowProtected && !ALLOWED_PROTECTED_PROPERTIES.contains(name)) {
-            return "Property is protected!";
+            throw new IllegalStateException("Could not create node type information for path '" + nodePath + "': " + e.getMessage(), e);
         }
-
-        // single values are valid for multi and single value
-        try {
-            validateValueConstraints(value, def, valueFactory, qValueFactory, namePathResolver);
-        } catch (ConstraintViolationException e) {
-            return "Property value does not satisfy constraints: " + e.getLocalizedMessage();
-        } catch (ValueFormatException e) {
-            return "Cannot convert property into type '" + def.getRequiredType() + "': " + e.getLocalizedMessage();
-        }
-        return null;
+        return messages;
     }
 
-    static String getPropertyConstraintViolation(Name name, Value[] values, EffectiveNodeType effectiveNodeType,
-            ItemDefinitionProvider itemDefinitionProvider, ValueFactory valueFactory, QValueFactory qValueFactory,
-            NamePathResolver namePathResolver, boolean allowProtected) throws RepositoryException {
-        QPropertyDefinition def;
-        int type = values.length > 0 ? values[0].getType() : PropertyType.UNDEFINED;
-        try {
-            def = getPropertyDefinition(name, type, effectiveNodeType, itemDefinitionProvider, true);
-        } catch (ConstraintViolationException t) {
-            return "No property definition found for name!";
-        }
-        if (def.isProtected() && !allowProtected && !ALLOWED_PROTECTED_PROPERTIES.contains(name)) {
-            return "Property is protected!";
-        }
-        if (!def.isMultiple()) {
-            return "Property must be single-value!";
+    /** Called whenever some subtree was fully visited
+     * 
+     * @param nodePath
+     * @return
+     * @throws RepositoryException
+     * @throws PathNotFoundException
+     * @throws IllegalArgumentException
+     * @throws NamespaceException
+     * @throws IllegalNameException
+     * @throws MalformedPathException */
+    private @Nullable Collection<ValidationMessage> finalizeValidationForSiblings(NodeContext nodeContext) {
+        String parentNodePath = Text.getRelativeParent(nodeContext.getNodePath(), 1);
+        String nodeName = Text.getName(nodeContext.getNodePath());
+        Collection<ValidationMessage> messages = new ArrayList<>();
+        Optional<JcrNodeTypeMetaData> parentNode = getNode(parentNodePath);
+        if (!parentNode.isPresent()) {
+            throw new IllegalArgumentException("Could not find parent node definition at " + parentNodePath);
         }
-        for (Value value : values) {
+        String path = parentNodePath + "/" + nodeName;
+        for (JcrNodeTypeMetaData sibling : parentNode.get().getChildren()) {
             try {
-                validateValueConstraints(value, def, valueFactory, qValueFactory, namePathResolver);
-            } catch (ConstraintViolationException e) {
-                return "Property value does not satisfy constraints: " + e.getLocalizedMessage();
-            } catch (ValueFormatException e) {
-                return "Cannot convert property into type '" + def.getRequiredType() + "': " + e.getLocalizedMessage();
+                if (sibling.getQualifiedPath(ntManagerProvider.getNamePathResolver()).equals(path)) {
+                    continue;
+                }
+                for (JcrNodeTypeMetaData siblingChild : sibling.getChildren()) {
+                    messages.addAll(finalizeValidationForSubtree(siblingChild, nodeContext));
+                }
+            } catch (NamespaceException e) {
+                throw new IllegalStateException("Can not print qualified path for " + path, e);
             }
         }
-        return null;
+        return messages;
     }
 
-    static String getChildNodeConstraintViolation(DocViewNode node, EffectiveNodeType nodeType,
-            NodeTypeDefinitionProvider nodeTypeDefinitionProvider,
-            NameResolver nameResolver, ItemDefinitionProvider itemDefinitionProvider, boolean allowProtected)
-            throws RepositoryException {
-        final Name nodeName;
-        try {
-            nodeName = nameResolver.getQName(node.name);
-        } catch (IllegalNameException | NamespaceException e) {
-            throw new IllegalNameException("Invalid node name " + node.name + ": '" + e.getMessage() + "'", e);
-        }
-        QNodeTypeDefinition nodeTypeDefinition;
-        try {
-            nodeTypeDefinition = nodeTypeDefinitionProvider.getNodeTypeDefinition(nameResolver.getQName(node.primary));
-        } catch (IllegalNameException | NamespaceException e) {
-            throw new IllegalNameException("Invalid primary type " + node.primary + ": '" + e.getMessage() + "'", e);
-        }
-        if (nodeTypeDefinition.isAbstract()) {
-            return "Not allowed to add node with abstract node type as primary type";
+    private @Nullable Collection<ValidationMessage> finalizeValidationForSubtree(JcrNodeTypeMetaData node, NodeContext nodeContext) throws NamespaceException {
+        Collection<ValidationMessage> messages = new ArrayList<>();
+        for (JcrNodeTypeMetaData child : node.getChildren()) {
+            messages.addAll(finalizeValidationForSubtree(child, nodeContext));
+            messages.addAll(child.finalizeValidation(ntManagerProvider.getNamePathResolver(), defaultSeverity, filter));
         }
-        if (nodeTypeDefinition.isMixin()) {
-            return "Not allowed to add node with a mixin as primary node type";
-        }
-        try {
-            QNodeDefinition nd = itemDefinitionProvider.getQNodeDefinition(nodeType, nodeName, nodeTypeDefinition.getName());
+        return messages;
+    }
 
-            if (!allowProtected && nd.isProtected()) {
-                return "Node is protected and can not be manually added";
+    @Override
+    public @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext, boolean isFolder,
+            boolean isDocViewXml) {
+        // track folders
+        List<ValidationMessage> messages = new ArrayList<>();
+        boolean isImplicit = isImplicit(nodeContext.getNodePath());
+        if (isFolder) {
+            messages.addAll(getOrCreateNewNode(nodeContext, isImplicit, NodeTypeConstants.NT_FOLDER));
+            //
+            if (!nodeContext.getNodePath().equals("/")) {
+                messages.addAll(finalizeValidationForSiblings(nodeContext));
             }
-
-            if (nd.isAutoCreated()) {
-                return "Node is auto-created and can not be manually added";
+        } else {
+            // for all files which are not docview
+            if (!isDocViewXml) {
+                String fileName = nodeContext.getFilePath().getFileName().toString();
+                // https://jackrabbit.apache.org/filevault/vaultfs.html#Binary_Properties
+                if (fileName.endsWith(ValidationExecutor.EXTENSION_BINARY)) {
+                    // create parent if it does not exist yet
+                    messages.addAll(getOrCreateNewNode(nodeContext, isImplicit, NodeTypeConstants.NT_FOLDER));
+                    String propertyName = fileName.substring(0, fileName.length() - ValidationExecutor.EXTENSION_BINARY.length());
+                    messages.addAll(addProperty(nodeContext, propertyName, false, DUMMY_BINARY_VALUE));
+                } else {
+                    // if binary node is not yet there
+                    messages.addAll(getOrCreateNewNode(nodeContext, isImplicit, NodeTypeConstants.NT_FILE));
+                    // if a NT_FILE create a jcr:content sub node of type NT_RESOURCE
+                    if (currentNodeTypeMetaData.getPrimaryNodeType().equals(NameConstants.NT_FILE)) {
+                        // create new node context
+                        nodeContext = new NodeContextImpl(nodeContext.getNodePath() + "/" + JcrConstants.JCR_CONTENT,
+                                nodeContext.getFilePath(), nodeContext.getBasePath());
+                        messages.addAll(
+                                getOrCreateNewNode(nodeContext, isImplicit(nodeContext.getNodePath()), NodeTypeConstants.NT_RESOURCE));
+                    }
+                    messages.addAll(addProperty(nodeContext, JcrConstants.JCR_DATA, false, DUMMY_BINARY_VALUE));
+                    messages.addAll(addProperty(nodeContext, JcrConstants.JCR_MIMETYPE, false, DUMMY_STRING_VALUE));
+                    messages.addAll(addProperty(nodeContext, JcrConstants.JCR_LASTMODIFIED, false, DUMMY_DATE_VALUE));
+                }
             }
-        } catch (ConstraintViolationException e) {
-            return "Could not find matching child node definition in parent's node type";
         }
 
-        return null;
+        return messages;
+    }
+
+    static String joinAsQualifiedJcrName(NameResolver nameResolver, Name[] names) throws NamespaceException {
+        StringBuilder types = new StringBuilder();
+        String delimiter = "";
+        for (Name name : names) {
+            types.append(delimiter).append(nameResolver.getJCRName(name));
+            delimiter = ", ";
+        }
+        return types.toString();
     }
 
     @Override
     public @Nullable Collection<ValidationMessage> done() {
-        return null;
+        // validate any outstanding nodes
+        // TODO: use correct node context impl
+        try {
+            return finalizeValidationForSubtree(getNode("/").get(), new NodeContextImpl("/", Paths.get("/"), Paths.get("/")));
+        } catch (NamespaceException e) {
+            throw new IllegalStateException("Can not print qualified path", e);
+        }
     }
 
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorFactory.java
index f3a7f0e8..7b3c8752 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorFactory.java
@@ -31,7 +31,6 @@ import javax.jcr.RepositoryException;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.jackrabbit.JcrConstants;
 import org.apache.jackrabbit.commons.cnd.ParseException;
-import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
 import org.apache.jackrabbit.vault.validation.spi.ValidationContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
 import org.apache.jackrabbit.vault.validation.spi.Validator;
@@ -65,7 +64,7 @@ public class NodeTypeValidatorFactory implements ValidatorFactory {
         // either load map from classloader, from filesystem or from generic url
         if (StringUtils.isBlank(cndUrls)) {
             cndUrls = this.getClass().getClassLoader().getResource("default-nodetypes.cnd").toString();
-            LOGGER.warn("Using default nodetypes, consider specifying the nodetypes from the distribution you use!");
+            LOGGER.warn("Using default nodetypes, consider specifying the nodetypes from the repository you use!");
         }
 
         final String defaultNodeType;
@@ -94,9 +93,7 @@ public class NodeTypeValidatorFactory implements ValidatorFactory {
                     throw new IllegalArgumentException("Error loading node types from CND at " + cndUrl, e);
                 }
             }
-            EffectiveNodeType defaultEffectiveNodeType = ntManagerProvider.getEffectiveNodeTypeProvider()
-                    .getEffectiveNodeType(ntManagerProvider.getNameResolver().getQName(defaultNodeType));
-            return new NodeTypeValidator(context.getFilter(), ntManagerProvider, defaultEffectiveNodeType, settings.getDefaultSeverity(),
+            return new NodeTypeValidator(context.getFilter(), ntManagerProvider, ntManagerProvider.getNameResolver().getQName(defaultNodeType), settings.getDefaultSeverity(),
                     severityForUnknownNodetypes);
         } catch (IOException | RepositoryException | ParseException e) {
             throw new IllegalArgumentException("Error loading default node type " + defaultNodeType, e);
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/OnDemandRegisterNamespaceResolverWrapper.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/OnDemandRegisterNamespaceResolverWrapper.java
new file mode 100644
index 00000000..03464c65
--- /dev/null
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/OnDemandRegisterNamespaceResolverWrapper.java
@@ -0,0 +1,61 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.validation.spi.impl.nodetype;
+
+import javax.jcr.NamespaceException;
+import javax.jcr.RepositoryException;
+
+import org.apache.jackrabbit.jcr2spi.NamespaceStorage;
+import org.apache.jackrabbit.spi.commons.namespace.NamespaceResolver;
+
+
+public class OnDemandRegisterNamespaceResolverWrapper implements NamespaceResolver {
+
+    private final NamespaceStorage nsStorage;
+    static final String UNDECLARED_NAMESPACE_URI_PREFIX = "http://unknown.prefix.";
+    
+    
+    public OnDemandRegisterNamespaceResolverWrapper(NamespaceStorage nsStorage) {
+        super();
+        this.nsStorage = nsStorage;
+    }
+
+    @Override
+    public String getPrefix(String uri) throws NamespaceException {
+        try {
+            return nsStorage.getPrefix(uri);
+        } catch (RepositoryException e) {
+            throw new NamespaceException(e);
+        }
+    }
+
+    @Override
+    public String getURI(String prefix) throws NamespaceException {
+        try {
+            try {
+                return nsStorage.getURI(prefix);
+            } catch (NamespaceException e) {
+                String newNamespaceUri = UNDECLARED_NAMESPACE_URI_PREFIX + prefix;
+                nsStorage.registerNamespace(prefix, newNamespaceUri);
+                return newNamespaceUri;
+            }
+        } catch (RepositoryException e)  {
+            throw new NamespaceException("Could not register prefix " + prefix + " on demand", e);
+        }
+    }
+
+}
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/package-info.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/package-info.java
index 5a644457..0dfdeaea 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/package-info.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/package-info.java
@@ -18,7 +18,7 @@
 /**
  * The FileVault validation framework SPI. Provides classes/interfaces to implement validators on FileVault packages.
  */
-@Version("1.2.0")
+@Version("1.3.0")
 package org.apache.jackrabbit.vault.validation.spi;
 
 import org.osgi.annotation.versioning.Version;
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
index 4477a3ff..51942203 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
@@ -170,7 +170,7 @@ public class ValidationExecutorTest {
         CapturingInputStreamFromArgumentAnswer<Void> answer2 = new CapturingInputStreamFromArgumentAnswer<>(StandardCharsets.US_ASCII, 0, null);
         Mockito.when(genericJcrDataValidator2.shouldValidateJcrData(Mockito.any(), Mockito.any())).thenReturn(true);
         Mockito.when(genericJcrDataValidator2.validateJcrData(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer2);
-        Mockito.when(jcrPathValidator.validateJcrPath(Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
+        Mockito.when(jcrPathValidator.validateJcrPath(Mockito.any(), Mockito.anyBoolean(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/genericfile.xml")) {
             Collection<ValidationViolation> messages = validate(input, executor, Paths.get(""), "apps/genericfile.xml", false);
             assertViolation(messages, 
@@ -180,7 +180,7 @@ public class ValidationExecutorTest {
             Assert.assertEquals("Test", answer2.getValue());
             Path expectedPath = Paths.get("apps/genericfile.xml");
             NodeContext expectedNodeContext = new NodeContextImpl("/apps/genericfile.xml", expectedPath,  Paths.get(""));
-            Mockito.verify(jcrPathValidator).validateJcrPath(expectedNodeContext, false);
+            Mockito.verify(jcrPathValidator).validateJcrPath(expectedNodeContext, false, false);
             Mockito.verify(genericJcrDataValidator, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath, Paths.get(""));
             Mockito.verify(genericJcrDataValidator).validateJcrData(Mockito.any(), Mockito.eq(expectedPath), Mockito.eq(Paths.get("")), Mockito.any());
             Mockito.verify(genericJcrDataValidator2, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath, Paths.get(""));
@@ -203,7 +203,7 @@ public class ValidationExecutorTest {
         Collection<ValidationViolation> messages = validateFolder(executor, Paths.get(""), "apps.dir", false);
         Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
         NodeContext expectedNodeContext = new NodeContextImpl("/apps", Paths.get("apps.dir"), Paths.get(""));
-        Mockito.verify(jcrPathValidator).validateJcrPath(expectedNodeContext, true);
+        Mockito.verify(jcrPathValidator).validateJcrPath(expectedNodeContext, true, true);
         Mockito.verify(nodePathValidator).validate(expectedNodeContext);
     }
 
@@ -244,6 +244,8 @@ public class ValidationExecutorTest {
     public void testFilePathToNodePath() {
         Assert.assertEquals("/apps/test", ValidationExecutor.filePathToNodePath(Paths.get("apps", "test")));
         Assert.assertEquals("/some/other/path", ValidationExecutor.filePathToNodePath(Paths.get("some", "other", "path")));
+        Assert.assertEquals("/apps/test", ValidationExecutor.filePathToNodePath(Paths.get("apps", "test", "property.binary")));
+        Assert.assertEquals("/", ValidationExecutor.filePathToNodePath(Paths.get("")));
     }
 
     public static void assertViolation(Collection<? extends ValidationMessage> messages, ValidationMessageSeverity thresholdSeverity, ValidationMessage... violations) {
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImplTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImplTest.java
new file mode 100644
index 00000000..eb9c1430
--- /dev/null
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImplTest.java
@@ -0,0 +1,411 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.validation.spi.impl.nodetype;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.nio.charset.StandardCharsets;
+import java.nio.file.Paths;
+import java.util.ArrayList;
+import java.util.Collection;
+
+import javax.jcr.NamespaceException;
+import javax.jcr.PathNotFoundException;
+import javax.jcr.RepositoryException;
+import javax.jcr.UnsupportedRepositoryOperationException;
+import javax.jcr.nodetype.InvalidNodeTypeDefinitionException;
+import javax.jcr.nodetype.NoSuchNodeTypeException;
+import javax.jcr.nodetype.NodeType;
+import javax.jcr.nodetype.NodeTypeExistsException;
+
+import org.apache.jackrabbit.commons.cnd.ParseException;
+import org.apache.jackrabbit.oak.spi.nodetype.NodeTypeConstants;
+import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
+import org.apache.jackrabbit.value.ValueFactoryImpl;
+import org.apache.jackrabbit.vault.fs.api.PathFilterSet;
+import org.apache.jackrabbit.vault.fs.config.DefaultWorkspaceFilter;
+import org.apache.jackrabbit.vault.validation.AnyValidationMessageMatcher;
+import org.apache.jackrabbit.vault.validation.ValidationExecutorTest;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
+import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
+import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
+import org.hamcrest.Matchers;
+import org.junit.Assert;
+import org.junit.Before;
+import org.junit.Test;
+
+public class JcrNodeTypeMetaDataImplTest {
+
+    private NodeTypeManagerProvider ntManagerProvider;
+
+    private JcrNodeTypeMetaDataImpl root;
+
+    private static final String ROOT_NODE_TYPES = "rep:AccessControllable, rep:RepoAccessControllable, rep:root"; // alphabetical order
+    // (i.e. primary type // last)
+
+    @Before
+    public void setUp() throws IOException, RepositoryException, ParseException {
+        ntManagerProvider = new NodeTypeManagerProvider();
+        root = JcrNodeTypeMetaDataImpl.createRoot(ntManagerProvider.getEffectiveNodeTypeProvider());
+    }
+
+    static NodeContext createSimpleNodeContext(String nodePath) {
+        return new NodeContextImpl(nodePath, Paths.get(""), Paths.get(""));
+    }
+
+    @Test
+    public void testGetNode() throws RepositoryException {
+        ValidationMessageSeverity severity = ValidationMessageSeverity.ERROR;
+        JcrNodeTypeMetaData child = root.addChildNode(ntManagerProvider.getNameResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(), severity,
+                createSimpleNodeContext("my"),
+                NodeType.NT_FOLDER);
+        assertNoValidationErrors(child);
+        JcrNodeTypeMetaData grandChild = child.addChildNode(ntManagerProvider.getNameResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(), severity,
+                createSimpleNodeContext("test"),
+                NodeType.NT_FOLDER);
+        assertNoValidationErrors(grandChild);
+        JcrNodeTypeMetaData child2 = root.addChildNode(ntManagerProvider.getNameResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(), severity,
+                createSimpleNodeContext("test2"),
+                NodeType.NT_FOLDER);
+        assertNoValidationErrors(child2);
+        Assert.assertEquals(child2,
+                grandChild.getNode(ntManagerProvider.getNamePathResolver(), "/test2").get());
+    }
+
+    public void testGetNodeWithNonExistingPath() throws MalformedPathException, NamespaceException, IllegalArgumentException,
+            PathNotFoundException, RepositoryException {
+
+        ValidationMessageSeverity severity = ValidationMessageSeverity.ERROR;
+        JcrNodeTypeMetaData child = root.addChildNode(ntManagerProvider.getNameResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(), severity,
+                createSimpleNodeContext("my"),
+                NodeType.NT_FOLDER);
+        JcrNodeTypeMetaData grandChild = child.addChildNode(ntManagerProvider.getNameResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), severity, createSimpleNodeContext("test"), NodeType.NT_FOLDER);
+        Assert.assertFalse(grandChild.getNode(ntManagerProvider.getNamePathResolver(), "/test2").isPresent());
+    }
+
+    @Test(expected = NamespaceExceptionInNodeName.class)
+    public void testAddChildNodeWithUndeclaredNamespaceInName() throws RepositoryException {
+        root.addChildNode(ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                createSimpleNodeContext("invalid:name"), NodeTypeConstants.NT_FOLDER);
+    }
+
+    @Test(expected = NamespaceException.class)
+    public void testAddChildNodeWithUndeclaredNamespaceInType() throws RepositoryException {
+        root.addChildNode(ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                createSimpleNodeContext("myname"), "my:nodeType1");
+    }
+
+    @Test(expected = NoSuchNodeTypeException.class)
+    public void testAddChildNodeWithUndeclaredType() throws RepositoryException {
+        root.addChildNode(ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                createSimpleNodeContext("myname"), "jcr:nodeType1");
+    }
+
+    @Test
+    public void testAddChildNode() throws IOException, InvalidNodeTypeDefinitionException, NodeTypeExistsException,
+            UnsupportedRepositoryOperationException, ParseException, RepositoryException {
+        try (InputStream input = this.getClass().getResourceAsStream("/simple-restricted-nodetypes.cnd");
+                Reader reader = new InputStreamReader(input,
+                        StandardCharsets.US_ASCII)) {
+            ntManagerProvider.registerNodeTypes(reader);
+        }
+
+        // add child node with mixin type as primary
+        NodeContext nodeContext = createSimpleNodeContext("name");
+        JcrNodeTypeMetaData node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, nodeContext,
+                "mix:mimeType");
+        assertValidationMessage(node, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_CHILD_NODE_NOT_ALLOWED, "name", "mix:mimeType", ROOT_NODE_TYPES,
+                        JcrNodeTypeMetaDataImpl.CONSTRAINT_MIXIN_TYPE_AS_PRIMARY_TYPE),
+                nodeContext));
+
+        // add child node with abstract type
+        node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, nodeContext,
+                "nt:hierarchyNode");
+        assertValidationMessage(node, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_CHILD_NODE_NOT_ALLOWED, "name", "nt:hierarchyNode", ROOT_NODE_TYPES,
+                        JcrNodeTypeMetaDataImpl.CONSTRAINT_ABSTRACT_TYPE_AS_PRIMARY_TYPE),
+                nodeContext));
+
+        node = root.addChildNode(ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                createSimpleNodeContext("versionedNode"), "rep:versionStorage");
+        assertNoValidationErrors(node);
+
+        // add child node with protected node which is ACL (i.e. accepted)
+        JcrNodeTypeMetaData childNode = node.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                createSimpleNodeContext("rep:policy"), "rep:Policy");
+        assertNoValidationErrors(childNode);
+
+        // add child node with protected node which is not ACL (i.e. accepted)
+        childNode = node.addChildNode(ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                nodeContext, "nt:versionHistory");
+        assertValidationMessage(childNode, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_CHILD_NODE_NOT_ALLOWED, "name", "nt:versionHistory", "rep:versionStorage",
+                        JcrNodeTypeMetaDataImpl.CONSTRAINT_CHILD_NODE_PROTECTED),
+                nodeContext));
+
+        // add valid child node
+        node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, createSimpleNodeContext("name"),
+                "my:nodeType1");
+        assertNoValidationErrors(node);
+
+        // add auto-created child node
+        nodeContext = createSimpleNodeContext("my:autoCreatedChild1");
+        childNode = node.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR,
+                nodeContext, "my:nodeType2");
+        assertValidationMessage(childNode, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_CHILD_NODE_NOT_ALLOWED, "my:autoCreatedChild1", "my:nodeType2",
+                        "my:nodeType1",
+                        JcrNodeTypeMetaDataImpl.CONSTRAINT_CHILD_NODE_AUTO_CREATED),
+                nodeContext));
+
+        // below that add child node which is not allowed
+        nodeContext = createSimpleNodeContext("name2");
+        childNode = node.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, nodeContext,
+                "my:nodeType1");
+        assertValidationMessage(childNode, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_CHILD_NODE_NOT_ALLOWED, "name2", "my:nodeType1", "my:nodeType1",
+                        JcrNodeTypeMetaDataImpl.CONSTRAINT_CHILD_NODE_NOT_ALLOWED),
+                nodeContext));
+    }
+
+    @Test
+    public void testValidateMandatoryChildNode() throws IllegalNameException, NoSuchNodeTypeException, RepositoryException,
+            IOException, ParseException {
+        try (InputStream input = this.getClass().getResourceAsStream("/simple-restricted-nodetypes.cnd");
+                Reader reader = new InputStreamReader(input, StandardCharsets.US_ASCII)) {
+            ntManagerProvider.registerNodeTypes(reader);
+        }
+
+        // add valid node
+        JcrNodeTypeMetaData node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, createSimpleNodeContext("name"),
+                "my:nodeType1");
+        assertNoValidationErrors(node);
+
+        DefaultWorkspaceFilter filter = new DefaultWorkspaceFilter();
+
+        // mandatory child node missing outside filter
+        Collection<ValidationMessage> messages = node.finalizeValidation(ntManagerProvider.getNamePathResolver(),
+                ValidationMessageSeverity.ERROR, filter);
+        ValidationExecutorTest.assertViolation(messages, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_MANDATORY_UNCONTAINED_CHILD_NODE_MISSING, "my:namedChild1 [my:nodeType1]", "my:nodeType1",
+                        "/name")));
+
+        node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, createSimpleNodeContext("name2"),
+                "my:nodeType1");
+        
+        // mandatory child node missing inside filter
+        filter.add(new PathFilterSet("/"));
+        messages = node.finalizeValidation(ntManagerProvider.getNamePathResolver(), ValidationMessageSeverity.ERROR, filter);
+        ValidationExecutorTest.assertViolation(messages, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_MANDATORY_CHILD_NODE_MISSING, "my:namedChild1 [my:nodeType1]", "my:nodeType1",
+                        "/name2")));
+
+        // calling a second time will not lead to anything
+        messages = node.finalizeValidation(ntManagerProvider.getNamePathResolver(), ValidationMessageSeverity.ERROR, filter);
+        Assert.assertThat(messages, AnyValidationMessageMatcher.noValidationInCollection());
+        
+        // now add mandatory child node
+        node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, createSimpleNodeContext("name3"),
+                "my:nodeType1");
+        
+        node.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, createSimpleNodeContext("my:namedChild1"),
+                "my:nodeType1");
+        messages = node.finalizeValidation(ntManagerProvider.getNamePathResolver(), ValidationMessageSeverity.ERROR,
+                new DefaultWorkspaceFilter());
+        Assert.assertThat(messages, AnyValidationMessageMatcher.noValidationInCollection());
+
+        // add arbitrary property to root
+        root.addProperty(createSimpleNodeContext("/"), ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, "property", false,
+                ValueFactoryImpl.getInstance().createValue("foo"));
+        assertNoValidationErrors(root);
+
+        NodeContext nodeContext = createSimpleNodeContext("nodeForMandatoryProperties");
+        node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, nodeContext, "my:nodeType2");
+        assertNoValidationErrors(node);
+        messages = node.finalizeValidation(ntManagerProvider.getNamePathResolver(), ValidationMessageSeverity.ERROR, filter);
+        ValidationExecutorTest.assertViolation(messages, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_MANDATORY_PROPERTY_MISSING, "my:mandatoryProperty", "my:nodeType2",
+                        "/nodeForMandatoryProperties")));
+
+        nodeContext = createSimpleNodeContext("nodeForMandatoryProperties2");
+        node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, nodeContext, "my:nodeType2");
+        assertNoValidationErrors(node);
+        node.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                "my:mandatoryProperty", false, ValueFactoryImpl.getInstance().createValue("foo"));
+        messages = node.finalizeValidation(ntManagerProvider.getNamePathResolver(), ValidationMessageSeverity.ERROR, filter);
+        ValidationExecutorTest.assertViolation(messages, new ValidationMessage(ValidationMessageSeverity.ERROR,
+                String.format(JcrNodeTypeMetaDataImpl.MESSAGE_MANDATORY_PROPERTY_WITH_WRONG_TYPE, "my:mandatoryProperty", "String", "Date",
+                        "my:nodeType2", "/nodeForMandatoryProperties2")));
+    }
+
+    @Test(expected = IllegalNameException.class)
+    public void testAddPropertyWithUndeclaredNamespace() throws RepositoryException {
+        root.addProperty(createSimpleNodeContext("/"), ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                "invalid:property", false, ValueFactoryImpl.getInstance().createValue("foo"));
+    }
+
+    @Test
+    public void testAddProperty() throws RepositoryException, ParseException, IOException {
+        try (InputStream input = this.getClass().getResourceAsStream("/simple-restricted-nodetypes.cnd");
+                Reader reader = new InputStreamReader(input,
+                        StandardCharsets.US_ASCII)) {
+            ntManagerProvider.registerNodeTypes(reader);
+        }
+
+        NodeContext nodeContext = createSimpleNodeContext("/");
+        // add arbitrary property to root
+        root.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, "property", false,
+                ValueFactoryImpl.getInstance().createValue("foo"));
+        assertNoValidationErrors(root);
+
+        JcrNodeTypeMetaData node = root.addChildNode(ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, createSimpleNodeContext("child"),
+                "my:nodeType3");
+        assertNoValidationErrors(node);
+
+        // not allowed (wrong type)
+        node.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, "property", false,
+                ValueFactoryImpl.getInstance().createValue("foo"));
+        assertValidationMessage(node,
+                new ValidationMessage(ValidationMessageSeverity.ERROR,
+                        String.format(JcrNodeTypeMetaDataImpl.MESSAGE_PROPERTY_NOT_ALLOWED, "property",
+                                "String", "my:nodeType3", JcrNodeTypeMetaDataImpl.CONSTRAINT_PROPERTY_NOT_ALLOWED),
+                        nodeContext));
+
+        // protected but nevertheless allowed
+        node.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, "jcr:primaryType", false,
+                ValueFactoryImpl.getInstance().createValue("foo"));
+        assertNoValidationErrors(node);
+
+        // protected
+        node.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                "my:protected", false, ValueFactoryImpl.getInstance().createValue("foo"));
+        assertValidationMessage(node,
+                new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(JcrNodeTypeMetaDataImpl.MESSAGE_PROPERTY_NOT_ALLOWED,
+                        "my:protected", "String", "my:nodeType3", JcrNodeTypeMetaDataImpl.CONSTRAINT_PROPERTY_PROTECTED), nodeContext));
+
+        // multi value where single value is required
+        node.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(),
+                ntManagerProvider.getEffectiveNodeTypeProvider(), ntManagerProvider.getNodeTypeDefinitionProvider(),
+                ntManagerProvider.getItemDefinitionProvider(), ValidationMessageSeverity.ERROR, "my:property1", true,
+                ValueFactoryImpl.getInstance().createValue("foo"), ValueFactoryImpl.getInstance().createValue("bar"));
+        assertValidationMessage(node,
+                new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(JcrNodeTypeMetaDataImpl.MESSAGE_PROPERTY_NOT_ALLOWED,
+                        "my:property1", "String", "my:nodeType3", JcrNodeTypeMetaDataImpl.CONSTRAINT_PROPERTY_NOT_ALLOWED), nodeContext));
+
+        // constrained property
+        node.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                "my:constrainedStringProperty", false, ValueFactoryImpl.getInstance().createValue("prefix1foo"));
+        assertNoValidationErrors(root);
+
+        node.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                "my:constrainedStringProperty", false, ValueFactoryImpl.getInstance().createValue("foosuffix1"));
+        assertNoValidationErrors(root);
+
+        node.addProperty(nodeContext, ntManagerProvider.getNamePathResolver(), ntManagerProvider.getEffectiveNodeTypeProvider(),
+                ntManagerProvider.getNodeTypeDefinitionProvider(), ntManagerProvider.getItemDefinitionProvider(),
+                ValidationMessageSeverity.ERROR,
+                "my:constrainedStringProperty", false, ValueFactoryImpl.getInstance().createValue("foo"));
+        assertValidationMessage(node,
+                new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(JcrNodeTypeMetaDataImpl.MESSAGE_PROPERTY_NOT_ALLOWED,
+                        "my:constrainedStringProperty", "String", "my:nodeType3",
+                        String.format(JcrNodeTypeMetaDataImpl.CONSTRAINT_PROPERTY_VALUE,
+                                "'foo' does not satisfy the constraint '.*suffix1'")),
+                        nodeContext));
+    }
+
+    private static void assertNoValidationErrors(JcrNodeTypeMetaData node) {
+        Collection<ValidationMessage> messages = new ArrayList<>();
+        node.fetchAndClearValidationMessages(messages);
+        Assert.assertThat(messages, Matchers.empty());
+    }
+
+    private static void assertValidationMessage(JcrNodeTypeMetaData node, ValidationMessage... expectedMessages) {
+        Collection<ValidationMessage> actualMessages = new ArrayList<>();
+        node.fetchAndClearValidationMessages(actualMessages);
+        Assert.assertThat(actualMessages, Matchers.contains(expectedMessages));
+    }
+
+}
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java
index fb5af863..3b6197fb 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorTest.java
@@ -30,7 +30,6 @@ import javax.jcr.nodetype.NodeType;
 
 import org.apache.jackrabbit.JcrConstants;
 import org.apache.jackrabbit.commons.cnd.ParseException;
-import org.apache.jackrabbit.jcr2spi.nodetype.EffectiveNodeType;
 import org.apache.jackrabbit.spi.commons.name.NameConstants;
 import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
 import org.apache.jackrabbit.vault.fs.config.ConfigurationException;
@@ -65,9 +64,7 @@ public class NodeTypeValidatorTest {
     static NodeTypeValidator createValidator(WorkspaceFilter filter, String defaultNodeType)
             throws IOException, RepositoryException, ParseException {
         NodeTypeManagerProvider ntManagerProvider = new NodeTypeManagerProvider();
-        EffectiveNodeType defaultEffectiveNodeType = ntManagerProvider.getEffectiveNodeTypeProvider()
-                .getEffectiveNodeType(ntManagerProvider.getNameResolver().getQName(defaultNodeType));
-        return new NodeTypeValidator(filter, ntManagerProvider, defaultEffectiveNodeType, ValidationMessageSeverity.ERROR,
+        return new NodeTypeValidator(filter, ntManagerProvider, NameConstants.NT_FOLDER, ValidationMessageSeverity.ERROR,
                 ValidationMessageSeverity.WARN);
     }
 
@@ -91,24 +88,44 @@ public class NodeTypeValidatorTest {
         node = new DocViewNode("test", "test", null, props, null, "nt:folder");
         ValidationExecutorTest.assertViolation(validator.validate(node, nodeContext, false),
                 new ValidationMessage(ValidationMessageSeverity.ERROR,
-                        String.format(NodeTypeValidator.MESSAGE_PROPERTY_NOT_ALLOWED, property, "nt:folder",
+                        String.format(JcrNodeTypeMetaDataImpl.MESSAGE_PROPERTY_NOT_ALLOWED, property, "nt:folder",
                                 "No property definition found for name!")));
     }
 
+    @Test
+    public void testUncontainedRootNode() {
+        NodeContext nodeContext = new NodeContextImpl("/", Paths.get("jcr_root"), Paths.get(""));
+
+        Map<String, DocViewProperty> props = new HashMap<>();
+        props.put(NameConstants.JCR_PRIMARYTYPE.toString(), 
+                new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(),
+                new String[] { "rep:root" }, false, PropertyType.STRING));
+        props.put(NameConstants.JCR_MIXINTYPES.toString(),
+                new DocViewProperty(NameConstants.JCR_MIXINTYPES.toString(),
+                new String[] { "rep:AccessControllable", "rep:RepoAccessControllable" }, true, PropertyType.STRING));
+        DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, props, null, "rep:root");
+        
+        Assert.assertThat(validator.validate(node, nodeContext, true), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validateEnd(node, nodeContext, true), AnyValidationMessageMatcher.noValidationInCollection());
+    }
+
     @Test
     public void testInvalidChildNodeTypeBelowDefault() {
-        NodeContext nodeContext = new NodeContextImpl("/apps/test/node4", Paths.get("node4"), Paths.get(""));
+        NodeContext nodeContext = new NodeContextImpl("/apps", Paths.get("apps"), Paths.get(""));
+        Assert.assertThat(validator.validateJcrPath(nodeContext, true, false), AnyValidationMessageMatcher.noValidationInCollection());
+        nodeContext = new NodeContextImpl("/apps/test", Paths.get("apps", "test"), Paths.get(""));
 
         Map<String, DocViewProperty> props = new HashMap<>();
         props.put(NameConstants.JCR_PRIMARYTYPE.toString(), new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(),
                 new String[] { JcrConstants.NT_UNSTRUCTURED }, false, PropertyType.STRING));
+        
         // nt:unstructured below nt:folder is not allowed
         DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, props, null, JcrConstants.NT_UNSTRUCTURED);
         ValidationExecutorTest.assertViolation(validator.validate(node, nodeContext, false),
                 new ValidationMessage(ValidationMessageSeverity.ERROR,
-                        String.format(NodeTypeValidator.MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED,
-                                "jcr:root [nt:unstructured]", JcrConstants.NT_FOLDER,
-                                "Could not find matching child node definition in parent's node type")));
+                        String.format(JcrNodeTypeMetaDataImpl.MESSAGE_CHILD_NODE_OF_NOT_CONTAINED_PARENT_POTENTIALLY_NOT_ALLOWED,
+                                "test", "nt:unstructured", JcrConstants.NT_FOLDER,
+                                "Node type does not allow arbitrary child nodes and does not allow this specific name and node type either!"), nodeContext));
     }
 
     @Test
@@ -121,10 +138,10 @@ public class NodeTypeValidatorTest {
         DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, props, null, JcrConstants.NT_FILE);
         Assert.assertThat(validator.validate(node, nodeContext, false), AnyValidationMessageMatcher.noValidationInCollection());
 
-        ValidationExecutorTest.assertViolation(validator.validateEnd(node, nodeContext, false),
+        ValidationExecutorTest.assertViolation(validator.done(),
                 new ValidationMessage(ValidationMessageSeverity.ERROR,
-                        String.format(NodeTypeValidator.MESSAGE_MANDATORY_CHILD_NODE_MISSING,
-                                "jcr:content [nt:base]")));
+                        String.format(JcrNodeTypeMetaDataImpl.MESSAGE_MANDATORY_CHILD_NODE_MISSING,
+                                "jcr:content [nt:base]", "nt:file", "/apps/test/node4")));
     }
 
     @Test
@@ -140,11 +157,11 @@ public class NodeTypeValidatorTest {
         DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, props, null, JcrConstants.NT_FILE);
         ValidationExecutorTest.assertViolation(validator.validate(node, nodeContext, false),
                 new ValidationMessage(ValidationMessageSeverity.ERROR,
-                        String.format(NodeTypeValidator.MESSAGE_PROPERTY_NOT_ALLOWED, prop, JcrConstants.NT_FILE,
-                                "No property definition found for name!")));
+                        String.format(JcrNodeTypeMetaDataImpl.MESSAGE_PROPERTY_NOT_ALLOWED, "invalid-prop", "String", JcrConstants.NT_FILE,
+                                "No applicable property definition found for name and type!"), nodeContext));
     }
 
-    @Test(expected = IllegalStateException.class)
+    @Test
     public void testPropertyWitInconvertibleValue() {
         NodeContext nodeContext = new NodeContextImpl("/apps/test/node4", Paths.get("node4"), Paths.get(""));
 
@@ -155,11 +172,14 @@ public class NodeTypeValidatorTest {
                 new String[] { JcrConstants.NT_FILE }, false, PropertyType.STRING));
         // nt:file is only supposed to have jcr:created property
         DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, props, null, JcrConstants.NT_FILE);
-        validator.validate(node, nodeContext, false);
+        ValidationExecutorTest.assertViolation(validator.validate(node, nodeContext, false),
+                new ValidationMessage(ValidationMessageSeverity.ERROR,
+                        String.format(NodeTypeValidator.MESSAGE_INVALID_PROPERTY_VALUE, Property.JCR_CREATED,
+                                "not a valid date format: some-invalid-value")));
     }
 
     @Test
-    public void testUnknownNamespace() {
+    public void testUnknownNamespaceInType() {
         NodeContext nodeContext = new NodeContextImpl("/apps/test/node4", Paths.get("node4"), Paths.get(""));
 
         Map<String, DocViewProperty> props = new HashMap<>();
@@ -172,9 +192,23 @@ public class NodeTypeValidatorTest {
         ValidationExecutorTest.assertViolation(validator.validate(node, nodeContext, false),
                 new ValidationMessage(ValidationMessageSeverity.WARN,
                         String.format(NodeTypeValidator.MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE,
-                                "Invalid primary type sling:Folder: 'sling: is not a registered namespace prefix.'")));
+                                "Invalid primary type 'sling:Folder': sling: is not a registered namespace prefix."), nodeContext));
+    }
+
+    @Test
+    public void testUnknownNamespaceInName() {
+        NodeContext nodeContext = new NodeContextImpl("/apps/test/cq:dialog", Paths.get("_cq_dialog"), Paths.get(""));
+        Map<String, DocViewProperty> props = new HashMap<>();
+        props.put(NameConstants.JCR_PRIMARYTYPE.toString(), new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(),
+                new String[] { "nt:Folder" }, false, PropertyType.STRING));
+        DocViewNode node = new DocViewNode("cq:dialog", "cq:dialog", null, props, null, "nt:folder");
+        ValidationExecutorTest.assertViolation(validator.validate(node, nodeContext, false),
+                new ValidationMessage(ValidationMessageSeverity.WARN,
+                        String.format(NodeTypeValidator.MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE,
+                                "Invalid node name 'cq:dialog': cq: is not a registered namespace prefix."), nodeContext));
     }
 
+    
     @Test
     public void testExistenceOfPrimaryNodeTypes() throws IOException, ConfigurationException, RepositoryException, ParseException {
         validator = createValidator(filter, NodeType.NT_UNSTRUCTURED);
diff --git a/vault-validation/src/test/resources/simple-restricted-nodetypes.cnd b/vault-validation/src/test/resources/simple-restricted-nodetypes.cnd
new file mode 100644
index 00000000..278b3706
--- /dev/null
+++ b/vault-validation/src/test/resources/simple-restricted-nodetypes.cnd
@@ -0,0 +1,38 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+// https://jackrabbit.apache.org/jcr/node-type-notation.html
+<'my'='http://example.com/mynamespace2'>
+
+
+[my:nodeType1]
+  + my:namedChild1 (my:nodeType1) mandatory
+  + my:autoCreatedChild1 (my:nodeType2) = my:nodeType2 autocreated mandatory
+  + * (my:nodeType2) mandatory
+
+[my:nodeType2]
+  - my:property2 (String)
+  - my:mandatoryProperty (Date) mandatory
+  - *
+
+[my:nodeType3]
+  - my:property1 (String)
+  // https://docs.adobe.com/docs/en/spec/jcr/2.0/3_Repository_Model.html#3.7.3.6%20Value%20Constraints
+  - my:constrainedStringProperty (String) < "prefix1.*",".*suffix1"
+  - my:protected (String) protected
+  - my:dateProperty (Date)
+  - my:mandatoryProperty (String) mandatory
+  - my:autoCreatedProperty (String) autocreated
\ No newline at end of file
