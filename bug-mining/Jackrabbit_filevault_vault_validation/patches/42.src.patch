diff --git a/vault-validation/pom.xml b/vault-validation/pom.xml
index 34174eb3..9e0a396d 100644
--- a/vault-validation/pom.xml
+++ b/vault-validation/pom.xml
@@ -111,6 +111,16 @@
                 <groupId>biz.aQute.bnd</groupId>
                 <artifactId>bnd-resolver-maven-plugin</artifactId>
             </plugin>
+            <plugin>
+                <groupId>de.thetaphi</groupId>
+                <artifactId>forbiddenapis</artifactId>
+                <configuration>
+                    <excludes>
+                        <!-- excluded embedded 3rd party libraries -->
+                        <exclude>org/apache/jackrabbit/jcr2spi/**/*.class</exclude>
+                    </excludes>
+                </configuration>
+            </plugin>
         </plugins>
     </build>
 
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
index 87df059c..508bad66 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
@@ -25,6 +25,7 @@ import java.util.HashSet;
 import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.stream.Collectors;
@@ -390,7 +391,7 @@ public final class ValidationExecutor {
                     Map.Entry::getKey, 
                     x -> type.cast(x.getValue()), 
                     (u, v) -> {
-                        throw new IllegalStateException(String.format("Duplicate key %s", u));
+                        throw new IllegalStateException(String.format(Locale.ENGLISH, "Duplicate key %s", u));
                     }, 
                     LinkedHashMap::new
                 ));
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/impl/util/ValidatorDocViewParserHandler.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/impl/util/ValidatorDocViewParserHandler.java
index 3990bb54..744bc115 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/impl/util/ValidatorDocViewParserHandler.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/impl/util/ValidatorDocViewParserHandler.java
@@ -22,6 +22,7 @@ import java.util.Collection;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 
@@ -115,9 +116,9 @@ public class ValidatorDocViewParserHandler implements DocViewParserHandler {
                     } catch (ValueFormatException e) {
                         String message;
                         try {
-                            message = String.format(MESSAGE_INVALID_STRING_SERIALIZATION, PropertyType.nameFromValue(property.getType()), nameResolver.getJCRName(property.getName()), value);
+                            message = String.format(Locale.ENGLISH, MESSAGE_INVALID_STRING_SERIALIZATION, PropertyType.nameFromValue(property.getType()), nameResolver.getJCRName(property.getName()), value);
                         } catch (NamespaceException e1) {
-                            message = String.format(MESSAGE_INVALID_STRING_SERIALIZATION, PropertyType.nameFromValue(property.getType()), property.getName(), value);
+                            message = String.format(Locale.ENGLISH, MESSAGE_INVALID_STRING_SERIALIZATION, PropertyType.nameFromValue(property.getType()), property.getName(), value);
                         }
                         violations.add(new ValidationViolation(DocumentViewParserValidatorFactory.ID, severity, message, filePath, basePath, nodePath, lineNumber, columnNumber, null));
                     }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AccessControlValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AccessControlValidator.java
index a70b9134..74c36377 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AccessControlValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AccessControlValidator.java
@@ -18,6 +18,7 @@ package org.apache.jackrabbit.vault.validation.spi.impl;
 
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Locale;
 
 import org.apache.jackrabbit.vault.fs.io.AccessControlHandling;
 import org.apache.jackrabbit.vault.fs.spi.ACLManagement;
@@ -56,7 +57,7 @@ public class AccessControlValidator implements DocumentViewXmlValidator {
         if (!isIncremental) {
             // make sure that at least one rep:Policy node is contained
             if (!hasFoundACLNode && accessControlHandling != AccessControlHandling.IGNORE && accessControlHandling != AccessControlHandling.CLEAR) {
-                return Collections.singleton(new ValidationMessage(severity, String.format(MESSAGE_INEFFECTIVE_ACCESS_CONTROL_LIST, accessControlHandling)));
+                return Collections.singleton(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_INEFFECTIVE_ACCESS_CONTROL_LIST, accessControlHandling)));
             }
         }
         return null;
@@ -68,7 +69,7 @@ public class AccessControlValidator implements DocumentViewXmlValidator {
         if (ACL_MANAGEMENT.isACLNodeType(node.getPrimaryType().orElse(""))) {
             hasFoundACLNode = true;
             if (accessControlHandling == AccessControlHandling.IGNORE || accessControlHandling == AccessControlHandling.CLEAR) {
-                return Collections.singleton(new ValidationMessage(severity, String.format(MESSAGE_IGNORED_ACCESS_CONTROL_LIST, accessControlHandling)));
+                return Collections.singleton(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_IGNORED_ACCESS_CONTROL_LIST, accessControlHandling)));
             }
         }
         return null;
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
index 65dea029..e8d4fc4c 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
@@ -28,6 +28,7 @@ import java.util.LinkedHashMap;
 import java.util.LinkedHashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Set;
 import java.util.regex.Matcher;
@@ -151,7 +152,7 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
             }
         }
         if (orphanEntries.length() > 0) {
-            return Collections.singleton(new ValidationMessage(severityForOrphanedFilterEntries, String.format(MESSAGE_ORPHANED_FILTER_ENTRIES, orphanEntries.toString())));
+            return Collections.singleton(new ValidationMessage(severityForOrphanedFilterEntries, String.format(Locale.ENGLISH, MESSAGE_ORPHANED_FILTER_ENTRIES, orphanEntries.toString())));
         } else {
             return null;
         }
@@ -200,9 +201,9 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
             if (!isContained) {
                 String msg;
                 if (coveringPackageId == null) {
-                    msg = String.format(MESSAGE_FILTER_ROOT_ANCESTOR_UNDEFINED, root);
+                    msg = String.format(Locale.ENGLISH, MESSAGE_FILTER_ROOT_ANCESTOR_UNDEFINED, root);
                 } else {
-                    msg = String.format(MESSAGE_FILTER_ROOT_ANCESTOR_COVERED_BUT_EXCLUDED, root, coveringPackageId);
+                    msg = String.format(Locale.ENGLISH, MESSAGE_FILTER_ROOT_ANCESTOR_COVERED_BUT_EXCLUDED, root, coveringPackageId);
                 }
                 messages.add(new ValidationMessage(severityForUndefinedFilterRootAncestors, msg));
             }
@@ -216,7 +217,7 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
             // check for validity of root path
             if (checkRoots && !pathFilterSet.getRoot().startsWith("/")) {
                 messages.add(new ValidationMessage(defaultSeverity,
-                        String.format(MESSAGE_ROOT_PATH_NOT_ABSOLUTE, pathFilterSet.getRoot())));
+                        String.format(Locale.ENGLISH, MESSAGE_ROOT_PATH_NOT_ABSOLUTE, pathFilterSet.getRoot())));
             }
             for (Entry<PathFilter> pathFilterEntry : pathFilterSet.getEntries()) {
                 if (!(pathFilterEntry.getFilter() instanceof DefaultPathFilter)) {
@@ -227,7 +228,7 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
                 defaultPathFilter.getPattern();
                 if (!isRegexValidForRootPath(defaultPathFilter.getPattern(), pathFilterSet.getRoot())) {
                     messages.add(new ValidationMessage(defaultSeverity,
-                            String.format(MESSAGE_INVALID_PATTERN, defaultPathFilter.getPattern(), pathFilterSet.getRoot())));
+                            String.format(Locale.ENGLISH, MESSAGE_INVALID_PATTERN, defaultPathFilter.getPattern(), pathFilterSet.getRoot())));
                 }
             }
         }
@@ -247,16 +248,16 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
                 if (validRoots.contains(nodePath)) {
                     return Collections.singleton(
                             new ValidationMessage(severityForUncoveredAncestorNode,
-                                    String.format(MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT, nodePath)));
+                                    String.format(Locale.ENGLISH, MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT, nodePath)));
                 } else {
                     // is this a folder only, then you cannot delete it!
                     return Collections.singleton(
                                 new ValidationMessage(severityForUncoveredAncestorNode,
-                                        String.format(MESSAGE_ANCESTOR_NODE_NOT_COVERED, nodePath)));
+                                        String.format(Locale.ENGLISH, MESSAGE_ANCESTOR_NODE_NOT_COVERED, nodePath)));
                 }
             } else {
                 return Collections
-                        .singleton(new ValidationMessage(defaultSeverity, String.format(MESSAGE_NODE_NOT_CONTAINED, nodePath)));
+                        .singleton(new ValidationMessage(defaultSeverity, String.format(Locale.ENGLISH, MESSAGE_NODE_NOT_CONTAINED, nodePath)));
             }
         } else {
             // is it a cleanup filter?
@@ -264,7 +265,7 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
             if (pathFilterSet != null) {
                 if (PathFilterSet.TYPE_CLEANUP.equals(pathFilterSet.getType())) {
                     return Collections
-                            .singleton(new ValidationMessage(defaultSeverity, String.format(MESSAGE_NODE_BELOW_CLEANUP_FILTER, nodePath)));
+                            .singleton(new ValidationMessage(defaultSeverity, String.format(Locale.ENGLISH, MESSAGE_NODE_BELOW_CLEANUP_FILTER, nodePath)));
                 }
             }
         }
@@ -272,7 +273,7 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
         String danglingNodePath = getDanglingAncestorNodePath(nodePath, filter);
         if (danglingNodePath != null) {
             return Collections.singleton(
-                    new ValidationMessage(severityForUncoveredAncestorNode,  String.format(MESSAGE_ANCESTOR_NODE_NOT_COVERED, danglingNodePath)));
+                    new ValidationMessage(severityForUncoveredAncestorNode,  String.format(Locale.ENGLISH, MESSAGE_ANCESTOR_NODE_NOT_COVERED, danglingNodePath)));
         }
         return null;
     }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorFactory.java
index 789e02e7..9e614753 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorFactory.java
@@ -101,7 +101,7 @@ public final class AdvancedFilterValidatorFactory implements ValidatorFactory {
         final ValidationMessageSeverity severityForUncoveredAncestorNode;
         if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_UNCOVERED_ANCESTOR_NODES)) {
             String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_UNCOVERED_ANCESTOR_NODES);
-            severityForUncoveredAncestorNode = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+            severityForUncoveredAncestorNode = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
         } else {
             severityForUncoveredAncestorNode = DEFAULT_SEVERITY_FOR_UNCOVERED_ANCESTOR_NODES;
         }
@@ -109,7 +109,7 @@ public final class AdvancedFilterValidatorFactory implements ValidatorFactory {
         final ValidationMessageSeverity severityForUndefinedFilterRootAncestors;
         if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_UNDEFINED_FILTER_ROOT_ANCESTORS)) {
             String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_UNDEFINED_FILTER_ROOT_ANCESTORS);
-            severityForUndefinedFilterRootAncestors = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+            severityForUndefinedFilterRootAncestors = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
         } else {
             // application packages must define every ancestor via package dependencies according to https://issues.apache.org/jira/browse/JCRVLT-170
             if (PackageType.APPLICATION.equals(context.getProperties().getPackageType())) {
@@ -118,7 +118,7 @@ public final class AdvancedFilterValidatorFactory implements ValidatorFactory {
             } else if(settings.getOptions().containsKey(OPTION_SEVERITY_FOR_UNCOVERED_FILTER_ROOT_ANCESTORS)) {
                 log.warn("Using deprecated option " + OPTION_SEVERITY_FOR_UNCOVERED_FILTER_ROOT_ANCESTORS + ". Please switch to " + OPTION_SEVERITY_FOR_UNDEFINED_FILTER_ROOT_ANCESTORS + " instead!");
                 String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_UNCOVERED_FILTER_ROOT_ANCESTORS);
-                severityForUndefinedFilterRootAncestors = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+                severityForUndefinedFilterRootAncestors = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
             } else {
                 severityForUndefinedFilterRootAncestors = DEFAULT_SEVERITY_FOR_UNDEFINED_FILTER_ROOT_ANCESTORS;
             }
@@ -131,7 +131,7 @@ public final class AdvancedFilterValidatorFactory implements ValidatorFactory {
         } else {
             if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_ORPHANED_FILTER_RULES)) {
                 String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_ORPHANED_FILTER_RULES);
-                severityForOrphanedFilterRules = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+                severityForOrphanedFilterRules = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
             } else {
                 severityForOrphanedFilterRules = DEFAULT_SEVERITY_FOR_ORPHANED_FILTER_RULES;
             }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DependencyValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DependencyValidator.java
index 9ce79f9f..61ac4667 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DependencyValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DependencyValidator.java
@@ -19,6 +19,7 @@ package org.apache.jackrabbit.vault.validation.spi.impl;
 import java.util.Collection;
 import java.util.HashMap;
 import java.util.LinkedList;
+import java.util.Locale;
 import java.util.Map;
 
 import org.apache.jackrabbit.vault.fs.api.PathFilterSet;
@@ -66,7 +67,7 @@ public final class DependencyValidator implements PropertiesValidator {
                         String root = set.getRoot();
                         PackageInfo existing = roots.get(root);
                         if (existing != null) {
-                            String msg = String.format(MESSAGE_DEPENDENCIES_WITH_OVERLAPPING_FILTERS,
+                            String msg = String.format(Locale.ENGLISH, MESSAGE_DEPENDENCIES_WITH_OVERLAPPING_FILTERS,
                                     resolvedDependency.getId(), root, existing.getId());
                             messages.add(new ValidationMessage(severity, msg));
                         }
@@ -77,7 +78,7 @@ public final class DependencyValidator implements PropertiesValidator {
                 }
             }
             if (!isDependencyResolved) {
-                String msg = String.format(MESSAGE_UNRESOLVED_DEPENDENCY, dependency);
+                String msg = String.format(Locale.ENGLISH, MESSAGE_UNRESOLVED_DEPENDENCY, dependency);
                 messages.add(new ValidationMessage(severityForUnresolvedDependencies, msg));
                 continue;
             }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DependencyValidatorFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DependencyValidatorFactory.java
index f33de969..b3c3baf7 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DependencyValidatorFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DependencyValidatorFactory.java
@@ -16,6 +16,8 @@
  */
 package org.apache.jackrabbit.vault.validation.spi.impl;
 
+import java.util.Locale;
+
 import org.apache.jackrabbit.vault.validation.spi.ValidationContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
 import org.apache.jackrabbit.vault.validation.spi.Validator;
@@ -37,7 +39,7 @@ public final class DependencyValidatorFactory implements ValidatorFactory {
         final ValidationMessageSeverity severityForUnresolvedDependencies;
         if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_UNRESOLVED_DEPENDENCIES)) {
             String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_UNRESOLVED_DEPENDENCIES);
-            severityForUnresolvedDependencies = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+            severityForUnresolvedDependencies = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
         } else {
             severityForUnresolvedDependencies = DEFAULT_SEVERITY_FOR_UNRESOLVED_DEPENDENCIES;
         }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DuplicateUuidValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DuplicateUuidValidator.java
index dacf7b71..b5206155 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DuplicateUuidValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DuplicateUuidValidator.java
@@ -19,6 +19,7 @@ package org.apache.jackrabbit.vault.validation.spi.impl;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 
@@ -55,7 +56,7 @@ public class DuplicateUuidValidator implements DocumentViewXmlValidator {
         if (identifier.isPresent() && filter.contains(nodeContext.getNodePath())) {
             String duplicateUuidPath = uuidsAndPaths.put(identifier.get(), nodeContext.getNodePath());
             if (duplicateUuidPath != null) {
-                return Collections.singleton(new ValidationMessage(severity, String.format(MESSAGE_DUPLICATE_UUID, identifier.get(), duplicateUuidPath, nodeContext.getNodePath())));
+                return Collections.singleton(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_DUPLICATE_UUID, identifier.get(), duplicateUuidPath, nodeContext.getNodePath())));
             }
         }
         return null;
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/MergeLimitationsValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/MergeLimitationsValidator.java
index 7765e3f2..4015e731 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/MergeLimitationsValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/MergeLimitationsValidator.java
@@ -19,6 +19,7 @@ package org.apache.jackrabbit.vault.validation.spi.impl;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedList;
+import java.util.Locale;
 
 import org.apache.jackrabbit.vault.fs.api.ImportMode;
 import org.apache.jackrabbit.vault.fs.api.PathFilterSet;
@@ -62,7 +63,7 @@ public class MergeLimitationsValidator implements DocumentViewXmlValidator {
     public Collection<ValidationMessage> validate(@NotNull DocViewNode2 node, @NotNull NodeContext nodeContext, boolean isRoot) {
         // find out if one of the filter roots is pointing to any of the aggregator's non-root nodes
         if (!isRoot && !node.getProperties().isEmpty() && rootNodePathsOfMergeRules.contains(nodeContext.getNodePath())) {
-            return Collections.singleton(new ValidationMessage(severity, String.format(PACKAGE_NON_ROOT_NODE_MERGED, nodeContext.getNodePath())));
+            return Collections.singleton(new ValidationMessage(severity, String.format(Locale.ENGLISH, PACKAGE_NON_ROOT_NODE_MERGED, nodeContext.getNodePath())));
         }
         return null;
     }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OakIndexDefinitionValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OakIndexDefinitionValidator.java
index b7c9fea2..6402404f 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OakIndexDefinitionValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OakIndexDefinitionValidator.java
@@ -21,6 +21,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 
 import org.apache.jackrabbit.oak.plugins.index.IndexConstants;
 import org.apache.jackrabbit.oak.spi.security.authorization.accesscontrol.AccessControlConstants;
@@ -67,7 +68,7 @@ public final class OakIndexDefinitionValidator implements FilterValidator, Docum
                 if (pathFilter.getRoot().contains("/" + AccessControlConstants.REP_POLICY)) {
                     violations.add(new ValidationMessage(ValidationMessageSeverity.DEBUG, "Ignoring filter entry " + pathFilter  + " as it is referring to an ACL"));
                 } else {
-                    violations.add(new ValidationMessage(defaultMessageSeverity, String.format(MESSAGE_POTENTIAL_INDEX_IN_FILTER, packageRootPathOfNotAllowedIndexDefinition, pathFilter.getRoot())));
+                    violations.add(new ValidationMessage(defaultMessageSeverity, String.format(Locale.ENGLISH, MESSAGE_POTENTIAL_INDEX_IN_FILTER, packageRootPathOfNotAllowedIndexDefinition, pathFilter.getRoot())));
                 }
             }
         }
@@ -78,7 +79,7 @@ public final class OakIndexDefinitionValidator implements FilterValidator, Docum
     public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode2 node, @NotNull NodeContext nodeContext, boolean isRoot) {
         ValidationMessage violation = null;
         if (IndexConstants.INDEX_DEFINITIONS_NODE_TYPE.equals(node.getPrimaryType().orElse(""))) {
-            violation = new ValidationMessage(defaultMessageSeverity, String.format(MESSAGE_INDEX_AT_NODE, packageRootPathOfNotAllowedIndexDefinition));
+            violation = new ValidationMessage(defaultMessageSeverity, String.format(Locale.ENGLISH, MESSAGE_INDEX_AT_NODE, packageRootPathOfNotAllowedIndexDefinition));
         }
         return violation != null ? Collections.singleton(violation) : null;
     }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OverlappingFilterValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OverlappingFilterValidator.java
index 31ef2638..bf112410 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OverlappingFilterValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OverlappingFilterValidator.java
@@ -21,6 +21,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.NavigableMap;
 import java.util.Optional;
@@ -99,7 +100,7 @@ public class OverlappingFilterValidator implements FilterValidator {
                 if (set2.isPresent()) {
                     validationMessages.add(
                             new ValidationMessage(ValidationMessageSeverity.DEBUG,
-                                    String.format(MESSAGE_OVERLAPPING_FILTER_ROOTS,
+                                    String.format(Locale.ENGLISH, MESSAGE_OVERLAPPING_FILTER_ROOTS,
                                             set1.getRoot(), packagePath, set2.get().getRoot(), otherPackageFiltersPerPackage.getKey())
                                             + " (prior checking includes/excludes)"));
                     // 2. only allow if the canonical includes are excludes in the other rule
@@ -153,7 +154,7 @@ public class OverlappingFilterValidator implements FilterValidator {
                 ValidationMessageSeverity severity =  isSingleNodeFilterPattern ? severityForOverlappingSingleNodePatterns : defaultSeverity;
                 messages.add(
                         new ValidationMessage(severity,
-                                String.format(MESSAGE_OVERLAPPING_FILTERS,
+                                String.format(Locale.ENGLISH, MESSAGE_OVERLAPPING_FILTERS,
                                         includeFilterSet.getRoot(), getPatternLabel(includeFilter), packagePathIncludeFilterSet, excludeFilterSet, packagePathExcludeFilterSet)));
             }
         }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OverlappingFilterValidatorFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OverlappingFilterValidatorFactory.java
index f0c3c9e6..d32b958b 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OverlappingFilterValidatorFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/OverlappingFilterValidatorFactory.java
@@ -18,6 +18,7 @@ package org.apache.jackrabbit.vault.validation.spi.impl;
 
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.util.Locale;
 
 import org.apache.jackrabbit.vault.validation.spi.ValidationContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
@@ -46,7 +47,7 @@ public final class OverlappingFilterValidatorFactory implements ValidatorFactory
             final ValidationMessageSeverity severityForOverlappingSingleNodePatterns;
             if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_OVERLAPPING_SINGLE_NODE_PATTERNS)) {
                 String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_OVERLAPPING_SINGLE_NODE_PATTERNS);
-                severityForOverlappingSingleNodePatterns = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+                severityForOverlappingSingleNodePatterns = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
             } else {
                 severityForOverlappingSingleNodePatterns = ValidationMessageSeverity.WARN;
             }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java
index d887aea0..f546c632 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java
@@ -22,6 +22,7 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Set;
 import java.util.regex.Pattern;
 import java.util.stream.Collectors;
@@ -132,7 +133,7 @@ public final class PackageTypeValidator implements NodePathValidator, DocumentVi
                 .collect(Collectors.toList());
         if (!invalidNodes.isEmpty()) {
             return invalidNodes.stream().map(
-                    e -> new ValidationMessage(severity, String.format(MESSAGE_ONLY_OSGI_BUNDLE_OR_CONFIG_OR_SUBPACKAGE_ALLOWED, type), e.getNodePath(), e.getFilePath(), e.getBasePath(), null))
+                    e -> new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_ONLY_OSGI_BUNDLE_OR_CONFIG_OR_SUBPACKAGE_ALLOWED, type), e.getNodePath(), e.getFilePath(), e.getBasePath(), null))
                     .collect(Collectors.toList());
         }
         return null;
@@ -148,18 +149,18 @@ public final class PackageTypeValidator implements NodePathValidator, DocumentVi
         switch (type) {
         case CONTENT:
             if (isImmutableContent(nodeContext.getNodePath())) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_APP_CONTENT, type, immutableRootNodeNames.stream().collect(Collectors.joining("' or '", "'", "'")))));
+                messages.add(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_APP_CONTENT, type, immutableRootNodeNames.stream().collect(Collectors.joining("' or '", "'", "'")))));
             }
             if (isOsgiBundleOrConfigurationNode(nodeContext.getNodePath(), true)) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_ALLOWED, type)));
+                messages.add(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_ALLOWED, type)));
             }
             break;
         case APPLICATION:
             if (!isImmutableContent(nodeContext.getNodePath())) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_NO_APP_CONTENT_FOUND, type, immutableRootNodeNames.stream().collect(Collectors.joining("' or '", "'", "'")))));
+                messages.add(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_NO_APP_CONTENT_FOUND, type, immutableRootNodeNames.stream().collect(Collectors.joining("' or '", "'", "'")))));
             }
             if (isOsgiBundleOrConfigurationNode(nodeContext.getNodePath(), true)) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_ALLOWED, type)));
+                messages.add(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_ALLOWED, type)));
             }
             // sub packages are detected via validate(Properties) on the sub package
             break;
@@ -187,7 +188,7 @@ public final class PackageTypeValidator implements NodePathValidator, DocumentVi
         switch (type) {
         case APPLICATION:
             if (!allowComplexFilterRulesInApplicationPackages && hasIncludesOrExcludes(filter)) {
-                return Collections.singleton(new ValidationMessage(severity, String.format(MESSAGE_FILTER_HAS_INCLUDE_EXCLUDES, type)));
+                return Collections.singleton(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_FILTER_HAS_INCLUDE_EXCLUDES, type)));
             }
             break;
         case CONTENT:
@@ -221,40 +222,40 @@ public final class PackageTypeValidator implements NodePathValidator, DocumentVi
             // must not contain hooks (this detects external hooks)
             if (!properties.getExternalHooks().isEmpty() && !allowInstallHooksInApplicationPackages) {
                 messages.add(new ValidationMessage(severity,
-                        String.format(MESSAGE_PACKAGE_HOOKS, properties.getPackageType(), properties.getExternalHooks())));
+                        String.format(Locale.ENGLISH, MESSAGE_PACKAGE_HOOKS, properties.getPackageType(), properties.getExternalHooks())));
             }
             if (prohibitImmutableContent) {
                 messages.add(new ValidationMessage(severity,
-                        String.format(MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE, properties.getPackageType())));
+                        String.format(Locale.ENGLISH, MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE, properties.getPackageType())));
             }
             break;
         case CONTENT:
             if (prohibitMutableContent) {
                 messages.add(new ValidationMessage(severity,
-                        String.format(MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE, properties.getPackageType())));
+                        String.format(Locale.ENGLISH, MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE, properties.getPackageType())));
             }
             break;
         case CONTAINER:
             // no dependencies
             if (properties.getDependencies() != null && properties.getDependencies().length > 0) {
                 messages.add(new ValidationMessage(severity,
-                        String.format(MESSAGE_DEPENDENCY, properties.getPackageType(), StringUtils.join(properties.getDependencies()))));
+                        String.format(Locale.ENGLISH, MESSAGE_DEPENDENCY, properties.getPackageType(), StringUtils.join(properties.getDependencies()))));
             }
             if (prohibitImmutableContent) {
                 messages.add(new ValidationMessage(ValidationMessageSeverity.ERROR,
-                        String.format(MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE, properties.getPackageType())));
+                        String.format(Locale.ENGLISH, MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE, properties.getPackageType())));
             }
             break;
         case MIXED:
             messages.add(
-                    new ValidationMessage(severityForLegacyType, String.format(MESSAGE_LEGACY_TYPE, properties.getPackageType())));
+                    new ValidationMessage(severityForLegacyType, String.format(Locale.ENGLISH, MESSAGE_LEGACY_TYPE, properties.getPackageType())));
             if (prohibitImmutableContent) {
                 messages.add(new ValidationMessage(ValidationMessageSeverity.ERROR,
-                        String.format(MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE, properties.getPackageType())));
+                        String.format(Locale.ENGLISH, MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE, properties.getPackageType())));
             }
             if (prohibitMutableContent) {
                 messages.add(new ValidationMessage(ValidationMessageSeverity.ERROR,
-                        String.format(MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE, properties.getPackageType())));
+                        String.format(Locale.ENGLISH, MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE, properties.getPackageType())));
             }
             break;
         }
@@ -271,7 +272,7 @@ public final class PackageTypeValidator implements NodePathValidator, DocumentVi
         case APPLICATION:
             // is it sling:OsgiConfig node?
             if (node.getPrimaryType().isPresent() && NODETYPE_SLING_OSGI_CONFIG.equals(node.getPrimaryType().orElse("")) && isOsgiBundleOrConfigurationNode(nodeContext.getNodePath(), false)) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_ALLOWED, type)));
+                messages.add(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_ALLOWED, type)));
             }
             break;
         case CONTAINER:
@@ -303,17 +304,17 @@ public final class PackageTypeValidator implements NodePathValidator, DocumentVi
         switch (containerPackageType) {
         case APPLICATION:
             // no sub packages allowed
-            message = new ValidationMessage(severity, String.format(MESSAGE_UNSUPPORTED_SUB_PACKAGE, containerPackageType));
+            message = new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_UNSUPPORTED_SUB_PACKAGE, containerPackageType));
             break;
         case CONTENT:
             if (packageType != PackageType.CONTENT) {
-                message = new ValidationMessage(severity, String.format(MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE, containerPackageType,
+                message = new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE, containerPackageType,
                         PackageType.CONTENT.toString(), packageType));
             }
             break;
         case CONTAINER:
             if (packageType == PackageType.MIXED) {
-                message = new ValidationMessage(severityForLegacyType, String.format(MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE, containerPackageType,
+                message = new ValidationMessage(severityForLegacyType, String.format(Locale.ENGLISH, MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE, containerPackageType,
                         StringUtils.join(new String[] { PackageType.APPLICATION.toString(), PackageType.CONTENT.toString(),
                                 PackageType.CONTAINER.toString() }, ", "),
                         packageType));
@@ -331,7 +332,7 @@ public final class PackageTypeValidator implements NodePathValidator, DocumentVi
         case APPLICATION:
             if (filePath.startsWith(PATH_HOOKS) && !allowInstallHooksInApplicationPackages)
                 // must not contain hooks (this detects internal hooks)
-                return Collections.singleton(new ValidationMessage(severity, String.format(MESSAGE_PACKAGE_HOOKS, type, filePath)));
+                return Collections.singleton(new ValidationMessage(severity, String.format(Locale.ENGLISH, MESSAGE_PACKAGE_HOOKS, type, filePath)));
         default:
             break;
         }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorFactory.java
index bbafc62d..64b475e5 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorFactory.java
@@ -17,6 +17,7 @@
 package org.apache.jackrabbit.vault.validation.spi.impl;
 
 import java.util.Arrays;
+import java.util.Locale;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.regex.Pattern;
@@ -50,7 +51,6 @@ public final class PackageTypeValidatorFactory implements ValidatorFactory {
      */
     public static final String OPTION_JCR_INSTALLER_ADDITIONAL_FILE_NODE_PATH_REGEX = "additionalJcrInstallerFileNodePathRegex";
 
-
     public static final String OPTION_SEVERITY_FOR_LEGACY_TYPE = "legacyTypeSeverity";
 
     public static final String OPTION_SEVERITY_FOR_NO_TYPE = "noTypeSeverity";
@@ -94,14 +94,14 @@ public final class PackageTypeValidatorFactory implements ValidatorFactory {
         final ValidationMessageSeverity severityForNoType;
         if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_NO_TYPE)) {
             String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_NO_TYPE);
-            severityForNoType = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+            severityForNoType = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
         } else {
             severityForNoType = DEFAULT_SEVERITY_FOR_NO_TYPE;
         }
         final ValidationMessageSeverity severityForLegacyType;
         if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_LEGACY_TYPE)) {
             String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_LEGACY_TYPE);
-            severityForLegacyType = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+            severityForLegacyType = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
         } else {
             severityForLegacyType = DEFAULT_SEVERITY_FOR_LEGACY_TYPE;
         }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java
index e770ef1d..6d68c95e 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/JcrNodeTypeMetaDataImpl.java
@@ -24,6 +24,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Map;
 import java.util.Optional;
 
@@ -57,8 +58,8 @@ import org.apache.jackrabbit.spi.commons.name.PathFactoryImpl;
 import org.apache.jackrabbit.spi.commons.nodetype.constraint.ValueConstraint;
 import org.apache.jackrabbit.spi.commons.value.QValueFactoryImpl;
 import org.apache.jackrabbit.spi.commons.value.ValueFormat;
-import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
 import org.apache.jackrabbit.util.Text;
+import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
 import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
@@ -198,11 +199,11 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
         } catch (NamespaceException e) {
             if (type == NameType.NODE_NAME) {
                 throw new NamespaceExceptionInNodeName(
-                        String.format(EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()), e);
+                        String.format(Locale.ENGLISH, EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()), e);
             }
-            throw new NamespaceException(String.format(EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()), e);
+            throw new NamespaceException(String.format(Locale.ENGLISH, EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()), e);
         } catch (IllegalNameException e) {
-            throw new IllegalNameException(String.format(EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()),
+            throw new IllegalNameException(String.format(Locale.ENGLISH, EXCEPTION_MESSAGE_INVALID_NAME, type.getLabel(), name, e.getLocalizedMessage()),
                     e);
         }
     }
@@ -366,7 +367,7 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
                         itemDefinitionProvider);
                 if (constraintViolation.isPresent()) {
                     messages.add(new ValidationMessage(isImplicit ? severityForDefaultNodeTypeViolations : severity,
-                            String.format(
+                            String.format(Locale.ENGLISH, 
                                     MESSAGE_CHILD_NODE_NOT_ALLOWED,
                                     namePathResolver.getJCRName(childNode.name), namePathResolver.getJCRName(childNode.primaryNodeType),
                                     getEffectiveNodeTypeLabel(namePathResolver, effectiveNodeType),
@@ -396,12 +397,12 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
                 try {
                     if (filter.contains(namePathResolver.getJCRPath(pathBuilder.getPath()))) {
                         messages.add(new ValidationMessage(isImplicit ? severityForDefaultNodeTypeViolations : severity,
-                                String.format(MESSAGE_MANDATORY_CHILD_NODE_MISSING,
+                                String.format(Locale.ENGLISH, MESSAGE_MANDATORY_CHILD_NODE_MISSING,
                                 getNodeDefinitionLabel(namePathResolver, mandatoryNodeType),
                                 getEffectiveNodeTypeLabel(namePathResolver, effectiveNodeType)), context));
                     } else {
                         // if mandatory child nodes are missing outside filter rules, this is not an issue
-                        messages.add(new ValidationMessage(ValidationMessageSeverity.DEBUG, String.format(MESSAGE_MANDATORY_UNCONTAINED_CHILD_NODE_MISSING,
+                        messages.add(new ValidationMessage(ValidationMessageSeverity.DEBUG, String.format(Locale.ENGLISH, MESSAGE_MANDATORY_UNCONTAINED_CHILD_NODE_MISSING,
                                 getNodeDefinitionLabel(namePathResolver, mandatoryNodeType),
                                 getEffectiveNodeTypeLabel(namePathResolver, effectiveNodeType)), context));
                     }
@@ -418,9 +419,9 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
         String label;
         String types = joinAsQualifiedJcrName(nameResolver, nodeType.getMergedNodeTypes());
         if (isImplicit) 
-            label = String.format("potential default types [%s]", types);
+            label = String.format(Locale.ENGLISH, "potential default types [%s]", types);
         else {
-            label =  String.format("types [%s]", types);
+            label =  String.format(Locale.ENGLISH, "types [%s]", types);
         }
         return label;
     }
@@ -516,7 +517,7 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
             try {
                 if (!propertyTypesByName.containsKey(mandatoryPropertyDefinition.getName())) {
                     messages.add(new ValidationMessage(isImplicit ? severityForDefaultNodeTypeViolations : severity,
-                            String.format(MESSAGE_MANDATORY_PROPERTY_MISSING,
+                            String.format(Locale.ENGLISH, MESSAGE_MANDATORY_PROPERTY_MISSING,
                                     nameResolver.getJCRName(mandatoryPropertyDefinition.getName()),
                                     getEffectiveNodeTypeLabel(nameResolver, effectiveNodeType)), context));
                 } else {
@@ -525,7 +526,7 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
                     if (mandatoryPropertyDefinition.getRequiredType() != actualPropertyType) {
                         // check type
                         messages.add(new ValidationMessage(isImplicit ? severityForDefaultNodeTypeViolations : severity,
-                                String.format(MESSAGE_MANDATORY_PROPERTY_WITH_WRONG_TYPE,
+                                String.format(Locale.ENGLISH, MESSAGE_MANDATORY_PROPERTY_WITH_WRONG_TYPE,
                                         nameResolver.getJCRName(mandatoryPropertyDefinition.getName()),
                                         PropertyType.nameFromValue(actualPropertyType),
                                         PropertyType.nameFromValue(mandatoryPropertyDefinition.getRequiredType()),
@@ -571,7 +572,7 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
                 isMultiValue);
         if (constraintViolation.isPresent()) {
             messages.add(new ValidationMessage(isImplicit ? severityForDefaultNodeTypeViolations : severity,
-                    String.format(
+                    String.format(Locale.ENGLISH, 
                             MESSAGE_PROPERTY_NOT_ALLOWED,
                             namePathResolver.getJCRName(qName), PropertyType.nameFromValue(values[0].getType()),
                             getEffectiveNodeTypeLabel(namePathResolver, effectiveNodeType),
@@ -604,7 +605,7 @@ public class JcrNodeTypeMetaDataImpl implements JcrNodeTypeMetaData {
                 QValue qValue = ValueFormat.getQValue(value, namePathResolver, QVALUE_FACTORY);
                 ValueConstraint.checkValueConstraints(applicablePropertyDefinition, new QValue[] { qValue });
             } catch (ConstraintViolationException e) {
-                return Optional.of(String.format(CONSTRAINT_PROPERTY_VALUE, e.getLocalizedMessage()));
+                return Optional.of(String.format(Locale.ENGLISH, CONSTRAINT_PROPERTY_VALUE, e.getLocalizedMessage()));
             }
         }
         return Optional.empty();
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
index 645060c5..7e8f2d62 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidator.java
@@ -22,6 +22,7 @@ import java.io.InputStreamReader;
 import java.nio.charset.StandardCharsets;
 import java.nio.file.Path;
 import java.nio.file.Paths;
+import java.time.ZoneOffset;
 import java.util.ArrayList;
 import java.util.Calendar;
 import java.util.Collection;
@@ -29,8 +30,10 @@ import java.util.Collections;
 import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Locale;
 import java.util.Optional;
 import java.util.Set;
+import java.util.TimeZone;
 
 import javax.jcr.NamespaceException;
 import javax.jcr.PathNotFoundException;
@@ -45,6 +48,7 @@ import org.apache.jackrabbit.JcrConstants;
 import org.apache.jackrabbit.commons.cnd.ParseException;
 import org.apache.jackrabbit.spi.Name;
 import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
+import org.apache.jackrabbit.spi.commons.conversion.MalformedPathException;
 import org.apache.jackrabbit.spi.commons.conversion.NameParser;
 import org.apache.jackrabbit.spi.commons.conversion.NameResolver;
 import org.apache.jackrabbit.spi.commons.name.NameConstants;
@@ -76,7 +80,7 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
     static final String MESSAGE_MISSING_PRIMARY_TYPE = "Mandatory jcr:primaryType missing on node '%s'";
 
     static final Value DUMMY_BINARY_VALUE = new BinaryValue("dummy binary");
-    static final Value DUMMY_DATE_VALUE = new DateValue(Calendar.getInstance());
+    static final Value DUMMY_DATE_VALUE = new DateValue(Calendar.getInstance(TimeZone.getTimeZone(ZoneOffset.UTC), Locale.ROOT));
     static final Value DUMMY_STRING_VALUE = new StringValue("dummy string");
 
     private final WorkspaceFilter filter;
@@ -121,10 +125,10 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
         try (InputStreamReader reader = new InputStreamReader(input, StandardCharsets.UTF_8)) {
             ntManagerProvider.registerNodeTypes(reader);
             return Collections.singleton(
-                    new ValidationMessage(ValidationMessageSeverity.INFO, String.format(MESSAGE_REGISTERED_CND_IN_PACKAGE, filePath)));
+                    new ValidationMessage(ValidationMessageSeverity.INFO, String.format(Locale.ENGLISH, MESSAGE_REGISTERED_CND_IN_PACKAGE, filePath)));
         } catch (RepositoryException | ParseException e) {
             return Collections.singleton(
-                    new ValidationMessage(defaultSeverity, String.format(MESSAGE_INVALID_CND_IN_PACKAGE, filePath, e.getMessage()), filePath, basePath, 0, 0, e));
+                    new ValidationMessage(defaultSeverity, String.format(Locale.ENGLISH, MESSAGE_INVALID_CND_IN_PACKAGE, filePath, e.getMessage()), filePath, basePath, 0, 0, e));
         }
     }
 
@@ -146,7 +150,7 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
             // if other properties are set this node is not only used for ordering purposes
             if (filter.contains(nodeContext.getNodePath()) && !node.getProperties().isEmpty()) {
                 return Collections.singleton(
-                        new ValidationMessage(defaultSeverity, String.format(MESSAGE_MISSING_PRIMARY_TYPE, nodeContext.getNodePath())));
+                        new ValidationMessage(defaultSeverity, String.format(Locale.ENGLISH, MESSAGE_MISSING_PRIMARY_TYPE, nodeContext.getNodePath())));
             } else {
                 // order node only or outside filter
                 return null;
@@ -160,7 +164,7 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
                 messages.addAll(addProperty(nodeContext, property.getName().toString(), property.isMultiValue(), docViewPropertyValueFactory.getValues(property)));
             } catch (ValueFormatException e) {
                 messages.add(new ValidationMessage(defaultSeverity,
-                        String.format(MESSAGE_INVALID_PROPERTY_VALUE, property.getName(), e.getLocalizedMessage())));
+                        String.format(Locale.ENGLISH, MESSAGE_INVALID_PROPERTY_VALUE, property.getName(), e.getLocalizedMessage())));
             }
         }
 
@@ -182,7 +186,7 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
             // log each unknown node type/namespace only once!
             if (!loggedUnknownNodeTypeMessages.contains(e.getMessage())) {
                 messages.add(new ValidationMessage(severityForUnknownNodeTypes,
-                        String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), nodeContext, e));
+                        String.format(Locale.ENGLISH, MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), nodeContext, e));
                 loggedUnknownNodeTypeMessages.add(e.getMessage());
             }
         } catch (RepositoryException e) {
@@ -215,7 +219,7 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
                 if (!loggedUnknownNodeTypeMessages.contains(e.getMessage())) {
                     loggedUnknownNodeTypeMessages.add(e.getMessage());
                     return Collections.singleton(new ValidationMessage(severityForUnknownNodeTypes,
-                            String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage(), nodeContext)));
+                            String.format(Locale.ENGLISH, MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage(), nodeContext)));
                 }
             } catch (RepositoryException e) {
                 throw new IllegalStateException(
@@ -262,7 +266,7 @@ public class NodeTypeValidator implements DocumentViewXmlValidator, JcrPathValid
                 // log each unknown node type/namespace only once!
                 if (!loggedUnknownNodeTypeMessages.contains(e.getMessage())) {
                     messages.add(new ValidationMessage(severityForUnknownNodeTypes,
-                            String.format(MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), nodeContext, e));
+                            String.format(Locale.ENGLISH, MESSAGE_UNKNOWN_NODE_TYPE_OR_NAMESPACE, e.getMessage()), nodeContext, e));
                     loggedUnknownNodeTypeMessages.add(e.getMessage());
                 }
                 if (e instanceof NamespaceExceptionInNodeName) {
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorFactory.java
index 99c75b05..2ae62250 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/nodetype/NodeTypeValidatorFactory.java
@@ -21,6 +21,7 @@ import java.io.UncheckedIOException;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.HashMap;
+import java.util.Locale;
 import java.util.Map;
 
 import javax.jcr.RepositoryException;
@@ -81,7 +82,7 @@ public class NodeTypeValidatorFactory implements ValidatorFactory {
         final @NotNull ValidationMessageSeverity severityForUnknownNodetypes;
         if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_UNKNOWN_NODETYPES)) {
             String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_UNKNOWN_NODETYPES);
-            severityForUnknownNodetypes = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+            severityForUnknownNodetypes = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
         } else {
             severityForUnknownNodetypes = DEFAULT_SEVERITY_FOR_UNKNOWN_NODETYPE;
         }
@@ -89,7 +90,7 @@ public class NodeTypeValidatorFactory implements ValidatorFactory {
         final @NotNull ValidationMessageSeverity severityForDefaultNodeTypeViolations;
         if (settings.getOptions().containsKey(OPTION_SEVERITY_FOR_DEFAULT_NODE_TYPE_VIOLATIONS)) {
             String optionValue = settings.getOptions().get(OPTION_SEVERITY_FOR_DEFAULT_NODE_TYPE_VIOLATIONS);
-            severityForDefaultNodeTypeViolations = ValidationMessageSeverity.valueOf(optionValue.toUpperCase());
+            severityForDefaultNodeTypeViolations = ValidationMessageSeverity.valueOf(optionValue.toUpperCase(Locale.ROOT));
         } else {
             severityForDefaultNodeTypeViolations = DEFAULT_SEVERITY_FOR_DEFAULT_NODE_TYPE_VIOLATIONS;
         }
