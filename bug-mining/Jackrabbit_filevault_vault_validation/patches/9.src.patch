diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
index f6915e90..3dcfa1f3 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
@@ -38,6 +38,7 @@ import org.apache.jackrabbit.vault.validation.spi.GenericJcrDataValidator;
 import org.apache.jackrabbit.vault.validation.spi.GenericMetaInfDataValidator;
 import org.apache.jackrabbit.vault.validation.spi.JcrPathValidator;
 import org.apache.jackrabbit.vault.validation.spi.MetaInfPathValidator;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.NodePathValidator;
 import org.apache.jackrabbit.vault.validation.spi.PropertiesValidator;
 import org.apache.jackrabbit.vault.validation.spi.ValidationContext;
@@ -267,12 +268,7 @@ public final class ValidationExecutor {
     private Collection<ValidationViolation> validateGenericJcrData(@Nullable InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {
         Map<String, Integer> nodePathsAndLineNumbers = new HashMap<>();
         Collection<ValidationViolation> enrichedMessages = new LinkedList<>();
-        for (Map.Entry<String, JcrPathValidator> entry : jcrPathValidators.entrySet()) {
-            Collection<ValidationMessage> messages = entry.getValue().validateJcrPath(filePath, basePath, input == null);
-            if (messages != null && !messages.isEmpty()) {
-                enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
-            }
-        }
+        
         if (input != null) {
             InputStream currentInput = input;
             ResettableInputStream resettableInputStream = null;
@@ -319,6 +315,14 @@ public final class ValidationExecutor {
             // collect node path for folder only
             nodePathsAndLineNumbers.put(filePathToNodePath(filePath), 0);
         }
+        // generate node context
+        NodeContext nodeContext = new NodeContextImpl(filePathToNodePath(filePath), filePath, basePath);
+        for (Map.Entry<String, JcrPathValidator> entry : jcrPathValidators.entrySet()) {
+            Collection<ValidationMessage> messages = entry.getValue().validateJcrPath(nodeContext, input == null);
+            if (messages != null && !messages.isEmpty()) {
+                enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
+            }
+        }
         enrichedMessages.addAll(validateNodePaths(filePath, basePath, nodePathsAndLineNumbers));
         return enrichedMessages;
     }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
index 7acff296..06e730f0 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
@@ -27,6 +27,7 @@ import org.osgi.annotation.versioning.ProviderType;
 /**
  * Validator interface for validating file paths for files and folders
  * below jcr_root.
+ * Called after {@link GenericJcrDataValidator}.
  */
 @ProviderType
 public interface JcrPathValidator extends Validator {
@@ -35,7 +36,7 @@ public interface JcrPathValidator extends Validator {
      * 
      * @param filePath the relative file/folder path to the jcr_root directory
      * @return validation messages or {@code null}
-     * @deprecated Use {@link #validateJcrPath(Path, Path, boolean)} instead.
+     * @deprecated Use {@link #validateJcrPath(NodeContext, boolean)} instead.
      */
     @Deprecated 
     default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath) { 
@@ -45,13 +46,12 @@ public interface JcrPathValidator extends Validator {
     /**
      * Called for each file/folder below jcr_root.
      * 
-     * @param filePath the relative file/folder path to the jcr_root directory (given in {@code basePath})
-     * @param basePath the absolute path to the jcr_root directory to which {@code filePath} is relative
+     * @param nodeContext the meta information about the node given through this file/folder
      * @param isFolder {@code true} in case it is a folder, otherwise {@code false}
      * @return validation messages or {@code null}
      */
-    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath, @NotNull Path basePath, boolean isFolder) { 
-        return validateJcrPath(filePath); 
+    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext, boolean isFolder) { 
+        return validateJcrPath(nodeContext.getFilePath()); 
     }
    
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodePathValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodePathValidator.java
index 70cc0620..6beb9879 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodePathValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodePathValidator.java
@@ -50,7 +50,7 @@ public interface NodePathValidator extends Validator {
      * @param nodeContext the information about the node context
      * @return validation messages or {@code null}
      */
-    default @Nullable Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext ) {
+    default @Nullable Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext) {
         return validate(nodeContext.getNodePath());
     }
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
index d90a1534..1b47463c 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
@@ -54,11 +54,15 @@ import org.apache.jackrabbit.vault.fs.config.DefaultWorkspaceFilter;
 import org.apache.jackrabbit.vault.fs.filter.DefaultPathFilter;
 import org.apache.jackrabbit.vault.packaging.PackageInfo;
 import org.apache.jackrabbit.vault.util.Constants;
+import org.apache.jackrabbit.vault.util.DocViewNode;
 import org.apache.jackrabbit.vault.util.Text;
 import org.apache.jackrabbit.vault.validation.ValidationViolation;
 import org.apache.jackrabbit.vault.validation.impl.util.ValidationMessageErrorHandler;
+import org.apache.jackrabbit.vault.validation.spi.DocumentViewXmlValidator;
 import org.apache.jackrabbit.vault.validation.spi.FilterValidator;
 import org.apache.jackrabbit.vault.validation.spi.GenericMetaInfDataValidator;
+import org.apache.jackrabbit.vault.validation.spi.JcrPathValidator;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.NodePathValidator;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
@@ -67,7 +71,7 @@ import org.jetbrains.annotations.Nullable;
 import org.w3c.dom.Document;
 import org.xml.sax.SAXException;
 
-public final class AdvancedFilterValidator implements GenericMetaInfDataValidator, FilterValidator, NodePathValidator {
+public final class AdvancedFilterValidator implements GenericMetaInfDataValidator, FilterValidator, DocumentViewXmlValidator, JcrPathValidator {
 
     protected static final String MESSAGE_ORPHANED_FILTER_ENTRIES = "Found orphaned filter entries: %s";
     protected static final String MESSAGE_INVALID_PATTERN = "Invalid pattern given ('%s') which will never match for any descendants of the root path '%s'.";
@@ -235,6 +239,70 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
         return messages;
     }
 
+    private Collection<ValidationMessage> validateFileNodePath(@NotNull String nodePath) {
+        if (isSubPackage) {
+            return null; // not relevant for sub packages
+        }
+        // remove from orphaned list
+        removeFromOrphanedFilterEntries(nodePath);
+        
+        // now go through all includes
+        if (!filter.contains(nodePath)) {
+            if (filter.isAncestor(nodePath)) {
+                // consider valid roots
+                if (validRoots.contains(nodePath)) {
+                    return Collections.singleton(
+                            new ValidationMessage(severityForUncoveredAncestorNode,
+                                    String.format(MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT, nodePath)));
+                } else {
+                    // is this a folder only, then you cannot delete it!
+                    return Collections.singleton(
+                                new ValidationMessage(severityForUncoveredAncestorNode,
+                                        String.format(MESSAGE_ANCESTOR_NODE_NOT_COVERED, nodePath)));
+                }
+            } else {
+                return Collections
+                        .singleton(new ValidationMessage(defaultSeverity, String.format(MESSAGE_NODE_NOT_CONTAINED, nodePath)));
+            }
+        } else {
+            // is it a cleanup filter?
+            PathFilterSet pathFilterSet = filter.getCoveringFilterSet(nodePath);
+            if (pathFilterSet != null) {
+                if (PathFilterSet.TYPE_CLEANUP.equals(pathFilterSet.getType())) {
+                    return Collections
+                            .singleton(new ValidationMessage(defaultSeverity, String.format(MESSAGE_NODE_BELOW_CLEANUP_FILTER, nodePath)));
+                }
+            }
+        }
+        // check that all ancestor nodes till the root node are contained as well
+        String danglingNodePath = getDanglingAncestorNodePath(nodePath, filter);
+        if (danglingNodePath != null) {
+            return Collections.singleton(
+                    new ValidationMessage(defaultSeverity, "Ancestor node (" + danglingNodePath + ") of Node '" + nodePath +"' which is contained in a filter include element is not included!"));
+        }
+        return null;
+    }
+
+    @Override
+    public @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull NodeContext nodeContext,
+            boolean isFolder) {
+        if (!isFolder) {
+            return validateFileNodePath(nodeContext.getNodePath());
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext,
+            boolean isRoot) {
+        if (!isRoot) {
+            // root has been validated already with validateJcrPath(...)
+            validateFileNodePath(nodeContext.getNodePath());
+        }
+        return DocumentViewXmlValidator.super.validate(node, nodeContext, isRoot);
+    }
+
     /** Checks if the regex would at least have the chance to match if the matching path starts with root path.
      * 
      * @param regex
@@ -323,50 +391,6 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
         }
     }
 
-    @Override
-    public Collection<ValidationMessage> validate(@NotNull String nodePath) {
-        if (isSubPackage) {
-            return null; // not relevant for sub packages
-        }
-        // remove from orphaned list
-        removeFromOrphanedFilterEntries(nodePath);
-        
-        // now go through all includes
-        if (!filter.contains(nodePath)) {
-            if (filter.isAncestor(nodePath)) {
-                // consider valid roots
-                if (validRoots.contains(nodePath)) {
-                    return Collections.singleton(
-                            new ValidationMessage(severityForUncoveredAncestorNode,
-                                    String.format(MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT, nodePath)));
-                } else {
-                    return Collections.singleton(
-                                new ValidationMessage(severityForUncoveredAncestorNode,
-                                        String.format(MESSAGE_ANCESTOR_NODE_NOT_COVERED, nodePath)));
-                }
-            } else {
-                return Collections
-                        .singleton(new ValidationMessage(defaultSeverity, String.format(MESSAGE_NODE_NOT_CONTAINED, nodePath)));
-            }
-        } else {
-            // is it a cleanup filter?
-            PathFilterSet pathFilterSet = filter.getCoveringFilterSet(nodePath);
-            if (pathFilterSet != null) {
-                if (PathFilterSet.TYPE_CLEANUP.equals(pathFilterSet.getType())) {
-                    return Collections
-                            .singleton(new ValidationMessage(defaultSeverity, String.format(MESSAGE_NODE_BELOW_CLEANUP_FILTER, nodePath)));
-                }
-            }
-        }
-        // check that all ancestor nodes till the root node are contained as well
-        String danglingNodePath = getDanglingAncestorNodePath(nodePath, filter);
-        if (danglingNodePath != null) {
-            return Collections.singleton(
-                    new ValidationMessage(defaultSeverity, "Ancestor node (" + danglingNodePath + ") of Node '" + nodePath +"' which is contained in a filter include element is not included!"));
-        }
-        return null;
-    }
-
     /**
      * 
      * @param nodePath
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DocumentViewParserValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DocumentViewParserValidator.java
index b2a61a30..e65167bd 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DocumentViewParserValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DocumentViewParserValidator.java
@@ -50,9 +50,9 @@ public class DocumentViewParserValidator implements GenericJcrDataValidator {
 
     private final Map<String, DocumentViewXmlValidator> docViewValidators;
     private final SAXParser saxParser;
-    private final ValidationMessageSeverity severity;
+    private final @NotNull ValidationMessageSeverity severity;
     
-    public DocumentViewParserValidator(SAXParser saxParser, ValidationMessageSeverity severity) {
+    public DocumentViewParserValidator(SAXParser saxParser, @NotNull ValidationMessageSeverity severity) {
         super();
         this.docViewValidators = new HashMap<>();
         this.saxParser = saxParser;
@@ -68,6 +68,12 @@ public class DocumentViewParserValidator implements GenericJcrDataValidator {
         return null;
     }
 
+    @Override
+    public boolean shouldValidateJcrData(@NotNull Path filePath, @NotNull Path basePath) {
+        // support upper case extensions?
+        return filePath.toString().endsWith(".xml");
+    }
+
     @Override
     public Collection<ValidationMessage> validateJcrData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath, @NotNull Map<String, Integer> nodePathsAndLineNumbers) throws IOException {
         Collection<ValidationMessage> messages = new LinkedList<>();
@@ -136,7 +142,7 @@ public class DocumentViewParserValidator implements GenericJcrDataValidator {
         return rootPath;
     }
 
-    protected Collection<ValidationMessage> validateDocumentViewXml(InputStream input, Path filePath, Path basePath, String rootNodePath,
+    protected Collection<ValidationMessage> validateDocumentViewXml(InputStream input, @NotNull Path filePath, @NotNull Path basePath, String rootNodePath,
             Map<String, Integer> nodePathsAndLineNumbers) throws IOException, SAXException {
         List<ValidationMessage> enrichedMessages = new LinkedList<>();
         XMLReader xr = saxParser.getXMLReader();
@@ -154,11 +160,5 @@ public class DocumentViewParserValidator implements GenericJcrDataValidator {
         return enrichedMessages;
     }
 
-    // support upper case extensions?
-    @Override
-    public boolean shouldValidateJcrData(@NotNull Path filePath) {
-        return filePath.toString().endsWith(".xml");
-    }
-
 
 }
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/DocumentViewParserValidatorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/DocumentViewParserValidatorTest.java
index 507d0107..f6e4ac60 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/DocumentViewParserValidatorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/DocumentViewParserValidatorTest.java
@@ -79,8 +79,8 @@ public class DocumentViewParserValidatorTest {
 
     @Test
     public void testShouldValidate() {
-        Assert.assertTrue(validator.shouldValidateJcrData(Paths.get("some", "file.xml")));
-        Assert.assertFalse(validator.shouldValidateJcrData(Paths.get("some", "other", "file.json")));
+        Assert.assertTrue(validator.shouldValidateJcrData(Paths.get("some", "file.xml"), Paths.get("")));
+        Assert.assertFalse(validator.shouldValidateJcrData(Paths.get("some", "other", "file.json"), Paths.get("")));
     }
 
     @Test
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
index 9afb874e..606456f5 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
@@ -39,6 +39,7 @@ import org.apache.jackrabbit.vault.validation.spi.GenericJcrDataValidator;
 import org.apache.jackrabbit.vault.validation.spi.GenericMetaInfDataValidator;
 import org.apache.jackrabbit.vault.validation.spi.JcrPathValidator;
 import org.apache.jackrabbit.vault.validation.spi.MetaInfPathValidator;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.NodePathValidator;
 import org.apache.jackrabbit.vault.validation.spi.PropertiesValidator;
 import org.apache.jackrabbit.vault.validation.spi.ValidationContext;
@@ -169,16 +170,17 @@ public class ValidationExecutorTest {
         CapturingInputStreamFromArgumentAnswer<Void> answer2 = new CapturingInputStreamFromArgumentAnswer<>(StandardCharsets.US_ASCII, 0, null);
         Mockito.when(genericJcrDataValidator2.shouldValidateJcrData(Mockito.any(), Mockito.any())).thenReturn(true);
         Mockito.when(genericJcrDataValidator2.validateJcrData(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer2);
-        Mockito.when(jcrPathValidator.validateJcrPath(Mockito.any(), Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
+        Mockito.when(jcrPathValidator.validateJcrPath(Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/genericfile.xml")) {
             Collection<ValidationViolation> messages = validate(input, executor, Paths.get(""), "apps/genericfile.xml", false);
             assertViolation(messages, 
-                    new ValidationViolation("jcrpathid", ValidationMessageSeverity.ERROR, "patherror", Paths.get("apps","genericfile.xml"), Paths.get(""), null, 0, 0, null),
-                    new ValidationViolation("genericjcrdataid", ValidationMessageSeverity.WARN, "error1", Paths.get("apps","genericfile.xml"), Paths.get(""), null, 0, 0, null));
+                    new ValidationViolation("genericjcrdataid", ValidationMessageSeverity.WARN, "error1", Paths.get("apps","genericfile.xml"), Paths.get(""), null, 0, 0, null),
+                    new ValidationViolation("jcrpathid", ValidationMessageSeverity.ERROR, "patherror", Paths.get("apps","genericfile.xml"), Paths.get(""), null, 0, 0, null));
             Assert.assertEquals("Test", answer.getValue());
             Assert.assertEquals("Test", answer2.getValue());
             Path expectedPath = Paths.get("apps/genericfile.xml");
-            Mockito.verify(jcrPathValidator).validateJcrPath(expectedPath, Paths.get(""), false);
+            NodeContext expectedNodeContext = new NodeContextImpl("/apps/genericfile.xml", expectedPath,  Paths.get(""));
+            Mockito.verify(jcrPathValidator).validateJcrPath(expectedNodeContext, false);
             Mockito.verify(genericJcrDataValidator, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath, Paths.get(""));
             Mockito.verify(genericJcrDataValidator).validateJcrData(Mockito.any(), Mockito.eq(expectedPath), Mockito.eq(Paths.get("")), Mockito.any());
             Mockito.verify(genericJcrDataValidator2, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath, Paths.get(""));
@@ -192,7 +194,7 @@ public class ValidationExecutorTest {
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/genericfile.xml")) {
             Collection<ValidationViolation> messages = validate(input, executor, Paths.get(""), "apps/genericfile.xml", false);
             Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
-            Mockito.verify(genericJcrDataValidator, Mockito.never()).validateJcrData(Mockito.any(), Mockito.any(), Mockito.any());
+            Mockito.verify(genericJcrDataValidator, Mockito.never()).validateJcrData(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any());
         }
     }
 
@@ -200,8 +202,9 @@ public class ValidationExecutorTest {
     public void testJcrRootFolder() throws URISyntaxException, IOException, SAXException {
         Collection<ValidationViolation> messages = validateFolder(executor, Paths.get(""), "apps.dir", false);
         Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
-        Mockito.verify(jcrPathValidator).validateJcrPath(Paths.get("apps.dir"), Paths.get(""), true);
-        Mockito.verify(nodePathValidator).validate(new NodeContextImpl("/apps", Paths.get("apps.dir"), Paths.get("")));
+        NodeContext expectedNodeContext = new NodeContextImpl("/apps", Paths.get("apps.dir"), Paths.get(""));
+        Mockito.verify(jcrPathValidator).validateJcrPath(expectedNodeContext, true);
+        Mockito.verify(nodePathValidator).validate(expectedNodeContext);
     }
 
     @Test
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorTest.java
index 68b6c0bf..b801ddbf 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidatorTest.java
@@ -43,10 +43,12 @@ import org.apache.jackrabbit.vault.validation.AnyValidationViolationMatcher;
 import org.apache.jackrabbit.vault.validation.ValidationExecutorTest;
 import org.apache.jackrabbit.vault.validation.ValidationViolation;
 import org.apache.jackrabbit.vault.validation.spi.FilterValidator;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
 import org.apache.jackrabbit.vault.validation.spi.impl.AdvancedFilterValidator;
 import org.apache.jackrabbit.vault.validation.spi.impl.AdvancedFilterValidatorFactory;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
@@ -84,6 +86,10 @@ public class AdvancedFilterValidatorTest {
         validRoots.addAll(AdvancedFilterValidatorFactory.DEFAULT_VALID_ROOTS);
     }
 
+    private NodeContext getStandardNodeContext(String nodePath) {
+        return new NodeContextImpl(nodePath, Paths.get("somefile"), Paths.get(""));
+    }
+
     @Test
     public void testValidFilter()
             throws URISyntaxException, IOException, SAXException, ParserConfigurationException, ConfigurationException {
@@ -142,11 +148,11 @@ public class AdvancedFilterValidatorTest {
                 dependenciesMetaInfo,
                 filter, // this is per test
                 validRoots);
-        Assert.assertThat(validator.validate("/apps/test/huhu"), AnyValidationViolationMatcher.noValidationInCollection());
-        Assert.assertThat(validator.validate("/apps/test"), AnyValidationViolationMatcher.noValidationInCollection());
-        Assert.assertThat(validator.validate("/apps/test2/valid"), AnyValidationViolationMatcher.noValidationInCollection());
-        Assert.assertThat(validator.validate("/apps/test3/valid"), AnyValidationViolationMatcher.noValidationInCollection());
-        Assert.assertThat(validator.validate("/apps/test4/test/valid"), AnyValidationViolationMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validateJcrPath(getStandardNodeContext("/apps/test/huhu"), false), AnyValidationViolationMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validateJcrPath(getStandardNodeContext("/apps/test"), false), AnyValidationViolationMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validateJcrPath(getStandardNodeContext("/apps/test2/valid"), false), AnyValidationViolationMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validateJcrPath(getStandardNodeContext("/apps/test3/valid"), false), AnyValidationViolationMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validateJcrPath(getStandardNodeContext("/apps/test4/test/valid"), false), AnyValidationViolationMatcher.noValidationInCollection());
     }
 
     @Test
@@ -165,10 +171,11 @@ public class AdvancedFilterValidatorTest {
                 filter, // this is per test
                 validRoots);
 
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/notcontained"),
+        Assert.assertThat(validator.validateJcrPath(getStandardNodeContext("/apps"), true), AnyValidationViolationMatcher.noValidationInCollection());
+        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext("/apps/notcontained"), false),
                 new ValidationMessage(ValidationMessageSeverity.WARN,
                         String.format(AdvancedFilterValidator.MESSAGE_NODE_NOT_CONTAINED, "/apps/notcontained")));
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/test3/invalid"),
+        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext("/apps/test3/invalid"), false),
                 new ValidationMessage(ValidationMessageSeverity.WARN,
                         String.format(AdvancedFilterValidator.MESSAGE_NODE_NOT_CONTAINED, "/apps/test3/invalid")));
     }
@@ -190,10 +197,10 @@ public class AdvancedFilterValidatorTest {
                 validRoots);
 
         // default severity INFO
-        ValidationExecutorTest.assertViolation(validator.validate("/apps"), ValidationMessageSeverity.INFO,
+        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext("/apps"), false), ValidationMessageSeverity.INFO,
                 new ValidationMessage(ValidationMessageSeverity.INFO,
                         String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED_BUT_VALID_ROOT, "/apps")));
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/test4"), ValidationMessageSeverity.INFO,
+        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext("/apps/test4"), false), ValidationMessageSeverity.INFO,
                 new ValidationMessage(ValidationMessageSeverity.INFO,
                         String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, "/apps/test4")));
 
@@ -208,7 +215,7 @@ public class AdvancedFilterValidatorTest {
                 filter, // this is per test
                 validRoots);
 
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/test4"), ValidationMessageSeverity.INFO,
+        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext("/apps/test4"), false), ValidationMessageSeverity.INFO,
                 new ValidationMessage(ValidationMessageSeverity.ERROR,
                         String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, "/apps/test4")));
 
@@ -224,7 +231,7 @@ public class AdvancedFilterValidatorTest {
                 dependenciesMetaInfo,
                 filter, // this is per test
                 Collections.emptyList());
-        ValidationExecutorTest.assertViolation(validator.validate("/apps"), ValidationMessageSeverity.WARN,
+        ValidationExecutorTest.assertViolation(validator.validateJcrPath(getStandardNodeContext("/apps"), false), ValidationMessageSeverity.WARN,
                 new ValidationMessage(ValidationMessageSeverity.WARN,
                         String.format(AdvancedFilterValidator.MESSAGE_ANCESTOR_NODE_NOT_COVERED, "/apps")));
     }
@@ -278,11 +285,11 @@ public class AdvancedFilterValidatorTest {
                 validRoots);
         Collection<ValidationMessage> messages = validator.validate(filter);
 
-        messages = validator.validate("/apps/test3");
+        messages = validator.validateJcrPath(getStandardNodeContext("/apps/test3"), false);
         ValidationExecutorTest.assertViolation(messages, ValidationMessageSeverity.INFO,
                 new ValidationMessage(ValidationMessageSeverity.INFO,
                         String.format(AdvancedFilterValidator.MESSAGE_NODE_BELOW_CLEANUP_FILTER, "/apps/test3")));
-        Assert.assertThat(validator.validate("/apps/test2/something/anothervalid"), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validateJcrPath(getStandardNodeContext("/apps/test2/something/anothervalid"), false), AnyValidationMessageMatcher.noValidationInCollection());
         messages = validator.done();
         ValidationExecutorTest.assertViolation(messages, ValidationMessageSeverity.INFO,
                 new ValidationMessage(ValidationMessageSeverity.ERROR,
