diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
index 155967e0..c79e85bf 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
@@ -49,6 +49,7 @@ import org.apache.jackrabbit.vault.validation.spi.impl.AdvancedFilterValidator;
 import org.apache.jackrabbit.vault.validation.spi.impl.AdvancedPropertiesValidator;
 import org.apache.jackrabbit.vault.validation.spi.impl.DocumentViewParserValidator;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -136,49 +137,43 @@ public class ValidationExecutor {
     /** 
      * Validates a package META-INF input stream  with all relevant validators.
      * 
-     * @param input the input stream (it is not closed during processing, this is obligation of the caller). Should not be buffered as buffering is done internally!
+     * @param input the input stream if it is a file or {@code null} in case it is called for a folder. It is not closed during processing, this is obligation of the caller. Should not be buffered as buffering is done internally! 
      * @param filePath should be relative to the META-INF directory (i.e. should not start with {@code META-INF})
      * @param basePath the path to which the file path is relative
      * @return the list of validation messages 
      * @throws IOException in case the input stream could not be accessed */
-    public @NotNull Collection<ValidationViolation> validateMetaInf(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {
+    public @NotNull Collection<ValidationViolation> validateMetaInf(@Nullable InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {
         if (filePath.isAbsolute()) {
             throw new IllegalArgumentException("Given file path must not be absolute");
         }
         if (filePath.startsWith(Constants.META_INF)) {
             throw new IllegalArgumentException("Given file path must not start with META-INF but rather on the level below");
         }
-        if (input == null) {
-            throw new IllegalArgumentException("Given input stream must not be null!");
-        }
         List<ValidationViolation> messages = new LinkedList<>();
         messages.add(new ValidationViolation(ValidationMessageSeverity.DEBUG, "Validating meta inf file '" + filePath + "'..."));
-        messages.addAll(validateGenericMetaInfData(new EnhancedBufferedInputStream(input), filePath, basePath));
+        messages.addAll(validateGenericMetaInfData(input != null ? new EnhancedBufferedInputStream(input) : null, filePath, basePath));
         return messages;
     }
 
     /** 
      * Validates a package jcr_root input stream  with all relevant validators.
      * 
-     * @param input the input stream (it is not closed during processing, this is obligation of the caller). Should not be buffered as buffering is done internally!
+     * @param input the input stream if it is a file or {@code null} in case it is called for a folder. It is not closed during processing, this is obligation of the caller. Should not be buffered as buffering is done internally! 
      * @param filePath file path relative to the content package jcr root (i.e. the folder named "jcr_root")
      * @param basePath the path to which the file path is relative
      * @return the list of validation messages 
      * @throws IOException in case the input stream could not be accessed
      */
-    public @NotNull Collection<ValidationViolation> validateJcrRoot(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {
+    public @NotNull Collection<ValidationViolation> validateJcrRoot(@Nullable InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {
         if (filePath.isAbsolute()) {
             throw new IllegalArgumentException("Given path is not relative " + filePath);
         }
         if (filePath.startsWith(Constants.ROOT_DIR)) {
             throw new IllegalArgumentException("Given file path must not start with jcr_root but rather on the level below");
         }
-        if (input == null) {
-            throw new IllegalArgumentException("Given input stream must not be null!");
-        }
         List<ValidationViolation> messages = new LinkedList<>();
         messages.add(new ValidationViolation(ValidationMessageSeverity.DEBUG, "Validating jcr file '" + filePath + "'..."));
-        messages.addAll(validateGenericJcrData(new EnhancedBufferedInputStream(input), filePath, basePath));
+        messages.addAll(validateGenericJcrData(input != null ? new EnhancedBufferedInputStream(input) : null, filePath, basePath));
         return messages;
     }
 
@@ -224,96 +219,103 @@ public class ValidationExecutor {
         return enrichedMessages;
     }
 
-    private Collection<ValidationViolation> validateGenericMetaInfData(InputStream input, Path filePath, Path basePath) throws IOException {
+    private Collection<ValidationViolation> validateGenericMetaInfData(@Nullable InputStream input, @NotNull Path filePath, Path basePath) throws IOException {
         Collection<ValidationViolation> enrichedMessages = new LinkedList<>();
-        ResettableInputStream resettableInputStream = null;
-        InputStream currentInput = input;
         for (Map.Entry<String, MetaInfPathValidator> entry : metaInfPathValidators.entrySet()) {
-            Collection<ValidationMessage> messages = entry.getValue().validateMetaInfPath(filePath);
+            Collection<ValidationMessage> messages = entry.getValue().validateMetaInfPath(filePath, input == null);
             if (messages != null && !messages.isEmpty()) {
                 enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
             }
         }
-        try {
-            for (Map.Entry<String, GenericMetaInfDataValidator> entry : genericMetaInfDataValidators.entrySet()) {
-                try {
-                    GenericMetaInfDataValidator validator = entry.getValue();
-                    if (validator.shouldValidateMetaInfData(filePath)) {
-                        if (resettableInputStream == null) {
-                            if (isAnotherValidatorFulfillingPathPredicate(genericMetaInfDataValidators.values(), GenericMetaInfDataValidator::shouldValidateMetaInfData, validator, filePath)) {
-                                currentInput = resettableInputStream = new ResettableInputStream(input);
+        if (input != null) {
+            InputStream currentInput = input;
+            ResettableInputStream resettableInputStream = null;
+            try {
+                for (Map.Entry<String, GenericMetaInfDataValidator> entry : genericMetaInfDataValidators.entrySet()) {
+                    try {
+                        GenericMetaInfDataValidator validator = entry.getValue();
+                        if (validator.shouldValidateMetaInfData(filePath)) {
+                            if (resettableInputStream == null) {
+                                if (isAnotherValidatorFulfillingPathPredicate(genericMetaInfDataValidators.values(), GenericMetaInfDataValidator::shouldValidateMetaInfData, validator, filePath)) {
+                                    currentInput = resettableInputStream = new ResettableInputStream(input);
+                                }
+                            } else {
+                                resettableInputStream.reset();
+                            }
+                            enrichedMessages.add(new ValidationViolation(entry.getKey(), ValidationMessageSeverity.DEBUG, "Validate..."));
+                            Collection<ValidationMessage> messages = validator.validateMetaInfData(currentInput, filePath);
+                            if (messages != null && !messages.isEmpty()) {
+                                enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
                             }
-                        } else {
-                            resettableInputStream.reset();
                         }
-                        enrichedMessages.add(new ValidationViolation(entry.getKey(), ValidationMessageSeverity.DEBUG, "Validate..."));
-                        Collection<ValidationMessage> messages = validator.validateMetaInfData(currentInput, filePath);
-                        if (messages != null && !messages.isEmpty()) {
-                            enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
+                    } catch (RuntimeException e) {
+                        if (!(e instanceof ValidatorException)) {
+                            throw new ValidatorException(entry.getKey(), filePath, e);
                         }
                     }
-                } catch (RuntimeException e) {
-                    if (!(e instanceof ValidatorException)) {
-                        throw new ValidatorException(entry.getKey(), filePath, e);
-                    }
                 }
-            }
-        } finally {
-            if (resettableInputStream != null) {
-                resettableInputStream.close();
+            } finally {
+                if (resettableInputStream != null) {
+                    resettableInputStream.close();
+                }
             }
         }
         return enrichedMessages;
     }
 
-    private Collection<ValidationViolation> validateGenericJcrData(InputStream input, Path filePath, Path basePath) throws IOException {
+    private Collection<ValidationViolation> validateGenericJcrData(@Nullable InputStream input, @NotNull Path filePath, Path basePath) throws IOException {
         Map<String, Integer> nodePathsAndLineNumbers = new HashMap<>();
         Collection<ValidationViolation> enrichedMessages = new LinkedList<>();
-        ResettableInputStream resettableInputStream = null;
-        InputStream currentInput = input;
         for (Map.Entry<String, JcrPathValidator> entry : jcrPathValidators.entrySet()) {
-            Collection<ValidationMessage> messages = entry.getValue().validateJcrPath(filePath);
+            Collection<ValidationMessage> messages = entry.getValue().validateJcrPath(filePath, input == null);
             if (messages != null && !messages.isEmpty()) {
                 enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
             }
         }
-        try {
-            // make sure the docviewparser always comes first
-            for (Map.Entry<String, GenericJcrDataValidator> entry : genericJcrDataValidators.entrySet()) {
-                try {
-                    GenericJcrDataValidator validator = entry.getValue();
-                    if (validator.shouldValidateJcrData(filePath)) {
-                        if (resettableInputStream == null) {
-                            if (isAnotherValidatorFulfillingPathPredicate(genericJcrDataValidators.values(), GenericJcrDataValidator::shouldValidateJcrData, validator, filePath)) {
-                                currentInput = resettableInputStream = new ResettableInputStream(input);
+        if (input != null) {
+            InputStream currentInput = input;
+            ResettableInputStream resettableInputStream = null;
+            try {
+                // make sure the docviewparser always comes first
+                for (Map.Entry<String, GenericJcrDataValidator> entry : genericJcrDataValidators.entrySet()) {
+                    try {
+                        GenericJcrDataValidator validator = entry.getValue();
+                        if (validator.shouldValidateJcrData(filePath)) {
+                            if (resettableInputStream == null) {
+                                if (isAnotherValidatorFulfillingPathPredicate(genericJcrDataValidators.values(), GenericJcrDataValidator::shouldValidateJcrData, validator, filePath)) {
+                                    currentInput = resettableInputStream = new ResettableInputStream(input);
+                                }
+                            } else {
+                                resettableInputStream.reset();
+                            }
+                            enrichedMessages.add(new ValidationViolation(entry.getKey(), ValidationMessageSeverity.DEBUG, "Validate..."));
+                            Collection<ValidationMessage> messages = validator.validateJcrData(currentInput, filePath, nodePathsAndLineNumbers);
+                            if (messages != null && !messages.isEmpty()) {
+                                enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
                             }
                         } else {
-                            resettableInputStream.reset();
-                        }
-                        enrichedMessages.add(new ValidationViolation(entry.getKey(), ValidationMessageSeverity.DEBUG, "Validate..."));
-                        Collection<ValidationMessage> messages = validator.validateJcrData(currentInput, filePath, nodePathsAndLineNumbers);
-                        if (messages != null && !messages.isEmpty()) {
-                            enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
+                            // only do it if we haven't collected node paths from a previous run
+                            if (nodePathsAndLineNumbers.isEmpty()) {
+                                // convert file name to node path
+                                String nodePath = filePathToNodePath(filePath);
+                                log.debug("Found non-docview node '{}'", nodePath);
+                                nodePathsAndLineNumbers.put(nodePath, 0);
+                            }
                         }
-                    } else {
-                        // only do it if we haven't collected node paths from a previous run
-                        if (nodePathsAndLineNumbers.isEmpty()) {
-                            // convert file name to node path
-                            String nodePath = filePathToNodePath(filePath);
-                            log.debug("Found non-docview node '{}'", nodePath);
-                            nodePathsAndLineNumbers.put(nodePath, 0);
+                    } catch (RuntimeException e) {
+                        if (!(e instanceof ValidatorException)) {
+                            throw new ValidatorException(entry.getKey(), filePath, e);
                         }
                     }
-                } catch (RuntimeException e) {
-                    if (!(e instanceof ValidatorException)) {
-                        throw new ValidatorException(entry.getKey(), filePath, e);
-                    }
+                }
+            } finally {
+                if (resettableInputStream != null) {
+                    resettableInputStream.close();
                 }
             }
-        } finally {
-            if (resettableInputStream != null) {
-                resettableInputStream.close();
-            }
+        } else {
+            // collect node path for folder only
+            nodePathsAndLineNumbers.put(filePathToNodePath(filePath), 0);
         }
         enrichedMessages.addAll(validateNodePaths(filePath, basePath, nodePathsAndLineNumbers));
         return enrichedMessages;
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
index 6970a070..166f23ba 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
@@ -17,7 +17,7 @@
 /**
  * The FileVault validation framework API. Provides classes to execute validations on FileVault packages.
  */
-@Version("1.0.0")
+@Version("1.0.1")
 package org.apache.jackrabbit.vault.validation;
 
 import org.osgi.annotation.versioning.Version;
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericJcrDataValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericJcrDataValidator.java
index baab58b7..4827bf12 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericJcrDataValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericJcrDataValidator.java
@@ -28,7 +28,7 @@ import org.osgi.annotation.versioning.ProviderType;
 /**
  * Low-level validator interface for all files below jcr_root.
  * For Document View XML files rather use {@link DocumentViewXmlValidator}.
- * For validators only considering file name or node name use {@link JcrPathValidator} or {@link NodePathValidator} instead.
+ * For validators only considering file/folder name or node name use {@link JcrPathValidator} or {@link NodePathValidator} instead.
  */
 @ProviderType
 public interface GenericJcrDataValidator extends Validator {
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericMetaInfDataValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericMetaInfDataValidator.java
index 57bd342d..9ccf9e6f 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericMetaInfDataValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericMetaInfDataValidator.java
@@ -29,7 +29,7 @@ import org.osgi.annotation.versioning.ProviderType;
  * Low-level validator interface for all files below META-INF (including {@code vault/filter.xml} and {@code vault/properties.xml}).
  * 
  * For validating properties and filter rather use the high-level validators {@link PropertiesValidator} or {@link FilterValidator}.
- * For validators only considering the file name use {@link MetaInfPathValidator} instead.
+ * For validators only considering the file/folder name use {@link MetaInfPathValidator} instead.
  
  */
 @ProviderType
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
index cd1e1a77..534239b7 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
@@ -25,17 +25,28 @@ import org.osgi.annotation.versioning.ProviderType;
 
 
 /**
- * Validator interface for validating file paths for files
+ * Validator interface for validating file paths for files and folders
  * below jcr_root.
  */
 @ProviderType
 public interface JcrPathValidator extends Validator {
     /**
-     * Called for each file below jcr_root.
+     * Called for each file/folder below jcr_root.
      * 
-     * @param filePath the relative file path to the jcr_root directory
+     * @param filePath the relative file/folder path to the jcr_root directory
      * @return validation messages or {@code null}
+     * @deprecated Use {@link #validateJcrPath(Path, boolean)} instead.
      */
-    @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath);
+    @Deprecated 
+    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath) { return null; };
+    
+    /**
+     * Called for each file/folder below jcr_root.
+     * 
+     * @param filePath the relative file/folder path to the jcr_root directory
+     * @param isFolder {@code true} in case it is a folder, otherwise {@code false}
+     * @return validation messages or {@code null}
+     */
+    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath, boolean isFolder) { return validateJcrPath(filePath); }
    
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/MetaInfPathValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/MetaInfPathValidator.java
index f80baaa3..9abf1bd5 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/MetaInfPathValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/MetaInfPathValidator.java
@@ -25,17 +25,29 @@ import org.osgi.annotation.versioning.ProviderType;
 
 
 /**
- * Validator interface for validating file paths for files
+ * Validator interface for validating file paths for files and folders
  * below META-INF.
  */
 @ProviderType
 public interface MetaInfPathValidator extends Validator {
     /**
-     * Called for each file below META-INF.
-     *
-     * @param filePath the relative file path to the META-INF directory
+     * Called for each file/folder below META-INF.
+     * 
+     * @param filePath the relative file/folder path to the META-INF directory
      * @return validation messages or {@code null}
+     * @deprecated Use {@link #validateMetaInfPath(Path, boolean)} instead.
      */
-    @Nullable Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath);
+    @Deprecated 
+    default @Nullable Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath) { return null; };
+    
+    /**
+     * Called for each file/folder below META-INF.
+     * 
+     * @param filePath the relative file/folder path to the META-INF directory
+     * @param isFolder {@code true} in case it is a folder, otherwise {@code false}
+     * @return validation messages or {@code null}
+     */
+    default @Nullable Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath, boolean isFolder) { return validateMetaInfPath(filePath); }
+   
    
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidator.java
index 0ff48692..a0912ba6 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidator.java
@@ -16,7 +16,6 @@
  */
 package org.apache.jackrabbit.vault.validation.spi.impl;
 
-import java.io.InputStream;
 import java.nio.file.Path;
 import java.util.Collection;
 import java.util.Collections;
@@ -29,21 +28,21 @@ import org.apache.jackrabbit.vault.fs.api.ImportMode;
 import org.apache.jackrabbit.vault.fs.api.PathFilterSet;
 import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
 import org.apache.jackrabbit.vault.util.DocViewNode;
-import org.apache.jackrabbit.vault.validation.ValidationExecutor;
 import org.apache.jackrabbit.vault.validation.spi.DocumentViewXmlValidator;
-import org.apache.jackrabbit.vault.validation.spi.GenericJcrDataValidator;
+import org.apache.jackrabbit.vault.validation.spi.NodePathValidator;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 /**
  *  Check for empty elements (used for ordering purposes)
  *  which are included in the filter with import=replace as those are actually not replaced!
  *  @see <a href="https://issues.apache.org/jira/browse/JCRVLT-251">JCRVLT-251</a>
  */
-public class EmptyElementsValidator implements DocumentViewXmlValidator, GenericJcrDataValidator {
+public class EmptyElementsValidator implements DocumentViewXmlValidator, NodePathValidator {
 
-    protected static final String MESSAGE_EMPTY_NODES = "Found empty nodes: %s (used for ordering only) which are included in the filter with mode=replace. Either remove the empty node or add at least the 'jcr:primaryType' attribute to make this node really get replaced.";
+    protected static final String MESSAGE_EMPTY_NODES = "Found empty nodes: %s (used for ordering only) without an accompanying folder which are included in the filter with mode=replace. Either remove the empty node or add at least the 'jcr:primaryType' attribute to make this node really get replaced.";
     private final ValidationMessageSeverity severity;
     private final Map<String, Path> emptyNodePathsAndFiles;
     private final Collection<String> nonEmptyNodePaths;
@@ -92,13 +91,6 @@ public class EmptyElementsValidator implements DocumentViewXmlValidator, Generic
         return null;
     }
 
-    @Override
-    public Collection<ValidationMessage> validateJcrData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Map<String, Integer> nodePathsAndLineNumbers) {
-        // never validate actual input
-        // this should never be called
-        return null;
-    }
-
     private boolean isBelowAffectedFilterRoots(String nodePath) {
         for (String affectedFilterRoot : affectedFilterRoots) {
             if (nodePath.startsWith(affectedFilterRoot)) {
@@ -109,12 +101,11 @@ public class EmptyElementsValidator implements DocumentViewXmlValidator, Generic
     }
 
     @Override
-    public boolean shouldValidateJcrData(@NotNull Path filePath) {
-        String nodePath = ValidationExecutor.filePathToNodePath(filePath);
+    public @Nullable Collection<ValidationMessage> validate(@NotNull String nodePath) {
         if (isBelowAffectedFilterRoots(nodePath)) {
             nonEmptyNodePaths.add(nodePath);
         }
-        return false;
+        return null;
     }
 
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/package-info.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/package-info.java
index f7ad5dfb..c72bdef3 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/package-info.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/package-info.java
@@ -18,7 +18,7 @@
 /**
  * The FileVault validation framework SPI. Provides classes/interfaces to implement validators on FileVault packages.
  */
-@Version("1.0.1")
+@Version("1.1.0")
 package org.apache.jackrabbit.vault.validation.spi;
 
 import org.osgi.annotation.versioning.Version;
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
index f8ea9d24..5b97c93f 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
@@ -125,7 +125,7 @@ public class ValidationExecutorTest {
         Mockito.when(genericMetaInfDataValidator.validateMetaInfData(Mockito.any(), Mockito.any())).thenAnswer(answer);
         CapturingInputStreamFromArgumentAnswer<Collection<ValidationMessage>> answer2 = new CapturingInputStreamFromArgumentAnswer<>(StandardCharsets.US_ASCII, 0, Collections.singleton(new ValidationMessage(ValidationMessageSeverity.WARN, "error1")));
         Mockito.when(genericMetaInfDataValidator2.validateMetaInfData(Mockito.any(), Mockito.any())).thenAnswer(answer2);
-        Mockito.when(metaInfPathValidator.validateMetaInfPath(Mockito.any())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
+        Mockito.when(metaInfPathValidator.validateMetaInfPath(Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/META-INF/vault/genericfile.txt")) {
             Collection<ValidationViolation> messages = validate(input, executor, Paths.get(""), "vault/genericfile.txt", true);
             assertViolation(messages, 
@@ -134,7 +134,7 @@ public class ValidationExecutorTest {
             Assert.assertEquals("Test", answer.getValue());
             Assert.assertEquals("Test", answer2.getValue());
             Path expectedPath = Paths.get("vault/genericfile.txt");
-            Mockito.verify(metaInfPathValidator).validateMetaInfPath(expectedPath);
+            Mockito.verify(metaInfPathValidator).validateMetaInfPath(expectedPath, false);
             Mockito.verify(genericMetaInfDataValidator, Mockito.atLeastOnce()).shouldValidateMetaInfData(expectedPath);
             Mockito.verify(genericMetaInfDataValidator).validateMetaInfData(Mockito.any(), Mockito.eq(expectedPath));
             Mockito.verify(genericMetaInfDataValidator2, Mockito.atLeastOnce()).shouldValidateMetaInfData(expectedPath);
@@ -152,6 +152,13 @@ public class ValidationExecutorTest {
         }
     }
 
+    @Test
+    public void testMetaInfFolder() throws URISyntaxException, IOException, SAXException {
+        Collection<ValidationViolation> messages = validateFolder(executor, Paths.get(""), "vault/genericfile.txt", true);
+        Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
+        Mockito.verify(metaInfPathValidator).validateMetaInfPath(Paths.get("vault", "genericfile.txt"), true);
+    }
+
     @Test
     public void testGenericJcrData()
             throws URISyntaxException, IOException, SAXException, ParserConfigurationException, ConfigurationException {
@@ -161,7 +168,7 @@ public class ValidationExecutorTest {
         CapturingInputStreamFromArgumentAnswer<Void> answer2 = new CapturingInputStreamFromArgumentAnswer<>(StandardCharsets.US_ASCII, 0, null);
         Mockito.when(genericJcrDataValidator2.shouldValidateJcrData(Mockito.any())).thenReturn(true);
         Mockito.when(genericJcrDataValidator2.validateJcrData(Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer2);
-        Mockito.when(jcrPathValidator.validateJcrPath(Mockito.any())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
+        Mockito.when(jcrPathValidator.validateJcrPath(Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/genericfile.xml")) {
             Collection<ValidationViolation> messages = validate(input, executor, Paths.get(""), "apps/genericfile.xml", false);
             assertViolation(messages, 
@@ -170,7 +177,7 @@ public class ValidationExecutorTest {
             Assert.assertEquals("Test", answer.getValue());
             Assert.assertEquals("Test", answer2.getValue());
             Path expectedPath = Paths.get("apps/genericfile.xml");
-            Mockito.verify(jcrPathValidator).validateJcrPath(expectedPath);
+            Mockito.verify(jcrPathValidator).validateJcrPath(expectedPath, false);
             Mockito.verify(genericJcrDataValidator, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath);
             Mockito.verify(genericJcrDataValidator).validateJcrData(Mockito.any(), Mockito.eq(expectedPath), Mockito.any());
             Mockito.verify(genericJcrDataValidator2, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath);
@@ -188,6 +195,14 @@ public class ValidationExecutorTest {
         }
     }
 
+    @Test
+    public void testJcrRootFolder() throws URISyntaxException, IOException, SAXException {
+        Collection<ValidationViolation> messages = validateFolder(executor, Paths.get(""), "apps.dir", false);
+        Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
+        Mockito.verify(jcrPathValidator).validateJcrPath(Paths.get("apps.dir"), true);
+        Mockito.verify(nodePathValidator).validate("/apps");
+    }
+
     @Test
     public void testDone() {
         Mockito.when(genericJcrDataValidator.done()).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "test1")));
@@ -210,6 +225,16 @@ public class ValidationExecutorTest {
         return messages;
     }
     
+    private Collection<ValidationViolation> validateFolder(ValidationExecutor executor, Path basePath, String resourcePath,
+            boolean isMetaInf) throws URISyntaxException, IOException, SAXException {
+        final Collection<ValidationViolation> messages;
+        if (isMetaInf) {
+            messages = executor.validateMetaInf(null, Paths.get(resourcePath), basePath);
+        } else {
+            messages = executor.validateJcrRoot(null, Paths.get(resourcePath), basePath);
+        }
+        return messages;
+    }
 
     @Test
     public void testFilePathToNodePath() {
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidatorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidatorTest.java
index 9008b25b..1ec3d879 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidatorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidatorTest.java
@@ -76,7 +76,7 @@ public class EmptyElementsValidatorTest {
         node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, "nt:unstructed");
         Assert.assertThat(validator.validate(node, "/apps/test/node5", Paths.get("node45"), false), AnyValidationMessageMatcher.noValidationInCollection());
         //
-        Assert.assertFalse(validator.shouldValidateJcrData(Paths.get("apps", "test", "node2")));
+        Assert.assertNull(validator.validate("/apps/test/node2"));
         ValidationExecutorTest.assertViolation(validator.done(), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(EmptyElementsValidator.MESSAGE_EMPTY_NODES, "'/apps/test/node1' (in 'node1'), '/apps/test/node3' (in 'node3')")));
     }
 
@@ -85,7 +85,7 @@ public class EmptyElementsValidatorTest {
         Map<String, DocViewProperty> props = new HashMap<>();
         props.put("prop1", new DocViewProperty("prop1", new String[] { "value1" } , false, PropertyType.STRING));
 
-        // order node only (no other property)
+        // primary node type set as well
         DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, "nt:unstructured");
         Assert.assertThat(validator.validate(node, "somepath1", Paths.get("/some/path"), false), AnyValidationMessageMatcher.noValidationInCollection());
         
@@ -94,4 +94,18 @@ public class EmptyElementsValidatorTest {
         Assert.assertThat(validator.validate(node, "somepath2", Paths.get("/some/path"), false), AnyValidationMessageMatcher.noValidationInCollection());
         Assert.assertNull(validator.done());
     }
+    
+    @Test
+    public void testWithEmptyElementsAndFolders() {
+        Map<String, DocViewProperty> props = new HashMap<>();
+        props.put("prop1", new DocViewProperty("prop1", new String[] { "value1" } , false, PropertyType.STRING));
+
+        // order node only (no other property)
+        DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, null);
+        Assert.assertThat(validator.validate(node, "/apps/test/node1", Paths.get("node1"), false), AnyValidationMessageMatcher.noValidationInCollection());
+        
+        // folder below 
+        Assert.assertThat(validator.validate("/apps/test/node1"), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertNull(validator.done());
+    }
 }
