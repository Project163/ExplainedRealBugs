diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
index c79e85bf..f6915e90 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutor.java
@@ -24,7 +24,6 @@ import java.util.HashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
-import java.util.function.BiPredicate;
 import java.util.stream.Collectors;
 
 import org.apache.commons.io.FilenameUtils;
@@ -48,6 +47,7 @@ import org.apache.jackrabbit.vault.validation.spi.Validator;
 import org.apache.jackrabbit.vault.validation.spi.impl.AdvancedFilterValidator;
 import org.apache.jackrabbit.vault.validation.spi.impl.AdvancedPropertiesValidator;
 import org.apache.jackrabbit.vault.validation.spi.impl.DocumentViewParserValidator;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 import org.slf4j.Logger;
@@ -59,7 +59,7 @@ import org.slf4j.LoggerFactory;
  * This class is thread-safe (i.e. methods can be used from different threads on the same instance). 
  * @see ValidationExecutorFactory
  */
-public class ValidationExecutor {
+public final class ValidationExecutor {
 
     private final Map<String, DocumentViewXmlValidator> documentViewXmlValidators;
     private final Map<String, NodePathValidator> nodePathValidators;
@@ -69,7 +69,7 @@ public class ValidationExecutor {
     private final Map<String, JcrPathValidator> jcrPathValidators;
     private final Map<String, FilterValidator> filterValidators;
     private final Map<String, PropertiesValidator> propertiesValidators;
-    private final Map<String, Validator> validatorsById;
+    private final @NotNull Map<String, Validator> validatorsById;
 
     /**
      * the default logger
@@ -206,7 +206,7 @@ public class ValidationExecutor {
             for (Map.Entry<String, NodePathValidator> entry : nodePathValidators.entrySet()) {
                 enrichedMessages.add(new ValidationViolation(entry.getKey(), ValidationMessageSeverity.DEBUG, "Validate..."));
                 try {
-                    Collection<ValidationMessage> messages = entry.getValue().validate(nodePathAndLineNumber.getKey());
+                    Collection<ValidationMessage> messages = entry.getValue().validate(new NodeContextImpl(nodePathAndLineNumber.getKey(), filePath, basePath));
                     if (messages != null && !messages.isEmpty()) {
                         enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, nodePathAndLineNumber.getKey(),
                                 nodePathAndLineNumber.getValue().intValue(), 0));
@@ -219,10 +219,10 @@ public class ValidationExecutor {
         return enrichedMessages;
     }
 
-    private Collection<ValidationViolation> validateGenericMetaInfData(@Nullable InputStream input, @NotNull Path filePath, Path basePath) throws IOException {
+    private Collection<ValidationViolation> validateGenericMetaInfData(@Nullable InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {
         Collection<ValidationViolation> enrichedMessages = new LinkedList<>();
         for (Map.Entry<String, MetaInfPathValidator> entry : metaInfPathValidators.entrySet()) {
-            Collection<ValidationMessage> messages = entry.getValue().validateMetaInfPath(filePath, input == null);
+            Collection<ValidationMessage> messages = entry.getValue().validateMetaInfPath(filePath, basePath, input == null);
             if (messages != null && !messages.isEmpty()) {
                 enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
             }
@@ -234,16 +234,17 @@ public class ValidationExecutor {
                 for (Map.Entry<String, GenericMetaInfDataValidator> entry : genericMetaInfDataValidators.entrySet()) {
                     try {
                         GenericMetaInfDataValidator validator = entry.getValue();
-                        if (validator.shouldValidateMetaInfData(filePath)) {
+                        if (validator.shouldValidateMetaInfData(filePath, basePath)) {
                             if (resettableInputStream == null) {
-                                if (isAnotherValidatorFulfillingPathPredicate(genericMetaInfDataValidators.values(), GenericMetaInfDataValidator::shouldValidateMetaInfData, validator, filePath)) {
+                                boolean isAnotherValidatorInterested = genericMetaInfDataValidators.values().stream().filter(t-> !t.equals(validator)).anyMatch(x -> x.shouldValidateMetaInfData(filePath, basePath));
+                                if (isAnotherValidatorInterested) {
                                     currentInput = resettableInputStream = new ResettableInputStream(input);
                                 }
                             } else {
                                 resettableInputStream.reset();
                             }
                             enrichedMessages.add(new ValidationViolation(entry.getKey(), ValidationMessageSeverity.DEBUG, "Validate..."));
-                            Collection<ValidationMessage> messages = validator.validateMetaInfData(currentInput, filePath);
+                            Collection<ValidationMessage> messages = validator.validateMetaInfData(currentInput, filePath, basePath);
                             if (messages != null && !messages.isEmpty()) {
                                 enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
                             }
@@ -263,11 +264,11 @@ public class ValidationExecutor {
         return enrichedMessages;
     }
 
-    private Collection<ValidationViolation> validateGenericJcrData(@Nullable InputStream input, @NotNull Path filePath, Path basePath) throws IOException {
+    private Collection<ValidationViolation> validateGenericJcrData(@Nullable InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {
         Map<String, Integer> nodePathsAndLineNumbers = new HashMap<>();
         Collection<ValidationViolation> enrichedMessages = new LinkedList<>();
         for (Map.Entry<String, JcrPathValidator> entry : jcrPathValidators.entrySet()) {
-            Collection<ValidationMessage> messages = entry.getValue().validateJcrPath(filePath, input == null);
+            Collection<ValidationMessage> messages = entry.getValue().validateJcrPath(filePath, basePath, input == null);
             if (messages != null && !messages.isEmpty()) {
                 enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
             }
@@ -280,16 +281,17 @@ public class ValidationExecutor {
                 for (Map.Entry<String, GenericJcrDataValidator> entry : genericJcrDataValidators.entrySet()) {
                     try {
                         GenericJcrDataValidator validator = entry.getValue();
-                        if (validator.shouldValidateJcrData(filePath)) {
+                        if (validator.shouldValidateJcrData(filePath, basePath)) {
                             if (resettableInputStream == null) {
-                                if (isAnotherValidatorFulfillingPathPredicate(genericJcrDataValidators.values(), GenericJcrDataValidator::shouldValidateJcrData, validator, filePath)) {
+                                boolean isAnotherValidatorInterested = genericJcrDataValidators.values().stream().filter(t-> !t.equals(validator)).anyMatch(x -> x.shouldValidateJcrData(filePath, basePath));
+                                if (isAnotherValidatorInterested) {
                                     currentInput = resettableInputStream = new ResettableInputStream(input);
                                 }
                             } else {
                                 resettableInputStream.reset();
                             }
                             enrichedMessages.add(new ValidationViolation(entry.getKey(), ValidationMessageSeverity.DEBUG, "Validate..."));
-                            Collection<ValidationMessage> messages = validator.validateJcrData(currentInput, filePath, nodePathsAndLineNumbers);
+                            Collection<ValidationMessage> messages = validator.validateJcrData(currentInput, filePath, basePath, nodePathsAndLineNumbers);
                             if (messages != null && !messages.isEmpty()) {
                                 enrichedMessages.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, basePath, null, 0, 0));
                             }
@@ -332,10 +334,6 @@ public class ValidationExecutor {
         return PlatformNameFormat.getRepositoryPath(platformPath, true);
     }
 
-    private static <T extends Validator> boolean isAnotherValidatorFulfillingPathPredicate(Collection<T> validators, BiPredicate<T,Path> predicate, T currentValidator, Path filePath) {
-        return validators.stream().filter(t -> !t.equals(currentValidator)).anyMatch(x -> predicate.test(x, filePath));
-    }
-
     static <T> Map<String, T> filterValidatorsByClass(Map<String, Validator> allValidators, Class<T> type) {
         return allValidators.entrySet().stream()
                 .filter(x -> type.isInstance(x.getValue()))
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutorFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutorFactory.java
index 6d284901..f7293684 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutorFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationExecutorFactory.java
@@ -40,7 +40,7 @@ import org.slf4j.LoggerFactory;
 /**
  * Creates {@link ValidationExecutor}s. Holds a number of {@link ValidatorFactory} instances.
  */
-public class ValidationExecutorFactory {
+public final class ValidationExecutorFactory {
 
     /** All registered ValidatorFactories in the correct order (sorted by their ranking) */
     final List<ValidatorFactory> validatorFactories;
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationViolation.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationViolation.java
index c29f38c2..776117fa 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationViolation.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/ValidationViolation.java
@@ -20,21 +20,19 @@ import java.nio.file.Path;
 import java.util.Collection;
 import java.util.LinkedList;
 
-import org.apache.jackrabbit.vault.validation.spi.ValidatorFactory;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
+import org.apache.jackrabbit.vault.validation.spi.ValidatorFactory;
+import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
 /**
  * A ValidationViolation is a {@link ValidationMessage} enriched with additional meta information like
- * validator id, file path and node path.
+ * validator id
  */
-public class ValidationViolation extends ValidationMessage {
+public final class ValidationViolation extends ValidationMessage {
 
     private final String validatorId; // may only be null if message was not bound to a validator
-    private final Path filePath; // may be null
-    private final Path basePath; // may be null
-    private final String nodePath; // may be null
 
     public static final Collection<ValidationViolation> wrapMessages(String validatorId, Collection<? extends ValidationMessage> messages, Path filePath, Path basePath, String nodePath, int line, int column) {
         Collection<ValidationViolation> violations = new LinkedList<>();
@@ -51,9 +49,9 @@ public class ValidationViolation extends ValidationMessage {
             // take parameters from underlying violation and only overwrite if not set in delegate
             return new ValidationViolation(delegate.validatorId != null ? delegate.validatorId : validatorId, 
                     delegate,
-                    delegate.filePath != null ? delegate.filePath : filePath,
-                    delegate.basePath != null ? delegate.basePath : basePath,
-                    delegate.nodePath != null ? delegate.nodePath : nodePath, 
+                    delegate.getFilePath()!= null ? delegate.getFilePath() : filePath,
+                    delegate.getBasePath() != null ? delegate.getBasePath() : basePath,
+                    delegate.getNodePath() != null ? delegate.getNodePath() : nodePath, 
                     delegate.getLine() != 0 ? delegate.getLine() : line,
                     delegate.getColumn() != 0 ? delegate.getColumn() : column,
                     delegate.getThrowable());
@@ -64,31 +62,28 @@ public class ValidationViolation extends ValidationMessage {
 
     ValidationViolation(String validatorId, ValidationMessage message, Path filePath, Path basePath, String nodePath, int line, int column, Throwable t) {
         // potentially overwrite line, column and throwable from wrapped message (but only if not yet set there)
-        super(message.getSeverity(), message.getMessage(), message.getLine() != 0 ?  message.getLine() : line, message.getColumn() != 0 ? message.getColumn() : column, message.getThrowable() != null ? message.getThrowable() : t);
+        super(message.getSeverity(), message.getMessage(), message.getNodePath() != null ? message.getNodePath() : nodePath, message.getFilePath() != null ? message.getFilePath() : filePath, message.getBasePath() != null ? message.getBasePath() : basePath, message.getLine() != 0 ?  message.getLine() : line, message.getColumn() != 0 ? message.getColumn() : column, message.getThrowable() != null ? message.getThrowable() : t);
         
         this.validatorId = validatorId;
-        this.filePath = filePath;
-        this.basePath = basePath;
-        this.nodePath = nodePath;
     }
 
     private ValidationViolation(String validatorId, ValidationMessage message) {
         this(validatorId, message, null, null, null, 0, 0, null);
     }
 
-    public ValidationViolation(String validatorId, ValidationMessageSeverity severity, String message) {
+    public ValidationViolation(String validatorId, @NotNull ValidationMessageSeverity severity, @NotNull String message) {
         this(validatorId, new ValidationMessage(severity, message));
     }
 
-    public ValidationViolation(ValidationMessageSeverity severity, String message) {
+    public ValidationViolation(@NotNull ValidationMessageSeverity severity, @NotNull String message) {
         this(null, new ValidationMessage(severity, message));
     }
 
-    public ValidationViolation(ValidationMessageSeverity severity, String message, Path filePath, Path basePath, String nodePath, int line, int column, Throwable t) {
+    public ValidationViolation(@NotNull ValidationMessageSeverity severity, @NotNull String message, Path filePath, Path basePath, String nodePath, int line, int column, Throwable t) {
         this(null, new ValidationMessage(severity, message), filePath, basePath, nodePath, line, column, t);
     }
 
-    public ValidationViolation(String validatorId, ValidationMessageSeverity severity, String message, Path filePath, Path basePath, String nodePath, int line, int column, Throwable t) {
+    public ValidationViolation(String validatorId, @NotNull ValidationMessageSeverity severity, @NotNull String message, Path filePath, Path basePath, String nodePath, int line, int column, Throwable t) {
         this(validatorId, new ValidationMessage(severity, message), filePath, basePath, nodePath, line, column, t);
     }
 
@@ -96,19 +91,12 @@ public class ValidationViolation extends ValidationMessage {
      * Returns the file path bound to this message.
      * @return the absolute file path or {@code null} if the message does not belong to a file
      */
-    public @Nullable Path getFilePath() {
-        if (basePath != null && filePath != null) {
-            return basePath.resolve(filePath);
+    public @Nullable Path getAbsoluteFilePath() {
+        Path basePath = getBasePath();
+        if (basePath != null && getFilePath() != null) {
+            return basePath.resolve(getFilePath());
         }
-        return filePath;
-    }
-
-    /**
-     * Returns the node path bound to this message.
-     * @return the node path or {@code null} if the message does not belong to a specific node
-     */
-    public @Nullable String getNodePath() {
-        return nodePath;
+        return getFilePath();
     }
 
     /**
@@ -119,12 +107,11 @@ public class ValidationViolation extends ValidationMessage {
         return validatorId;
     }
 
+    
     @Override
     public int hashCode() {
         final int prime = 31;
         int result = super.hashCode();
-        result = prime * result + ((filePath == null) ? 0 : filePath.hashCode());
-        result = prime * result + ((nodePath == null) ? 0 : nodePath.hashCode());
         result = prime * result + ((validatorId == null) ? 0 : validatorId.hashCode());
         return result;
     }
@@ -138,16 +125,6 @@ public class ValidationViolation extends ValidationMessage {
         if (getClass() != obj.getClass())
             return false;
         ValidationViolation other = (ValidationViolation) obj;
-        if (filePath == null) {
-            if (other.filePath != null)
-                return false;
-        } else if (!filePath.equals(other.filePath))
-            return false;
-        if (nodePath == null) {
-            if (other.nodePath != null)
-                return false;
-        } else if (!nodePath.equals(other.nodePath))
-            return false;
         if (validatorId == null) {
             if (other.validatorId != null)
                 return false;
@@ -158,8 +135,8 @@ public class ValidationViolation extends ValidationMessage {
 
     @Override
     public String toString() {
-        return "ValidationViolation [" + (filePath != null ? "filePath=" + filePath + ", " : "")
-                + (nodePath != null ? "nodePath=" + nodePath + ", " : "") + (validatorId != null ? "validatorId=" + validatorId + ", " : "")
+        return "ValidationViolation [" 
+                + (validatorId != null ? "validatorId=" + validatorId + ", " : "")
                 + "super=" + super.toString() + "]";
     }
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/impl/util/DocumentViewXmlContentHandler.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/impl/util/DocumentViewXmlContentHandler.java
index 94f53182..d2a4731c 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/impl/util/DocumentViewXmlContentHandler.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/impl/util/DocumentViewXmlContentHandler.java
@@ -26,7 +26,6 @@ import java.util.List;
 import java.util.Map;
 
 import javax.jcr.NamespaceException;
-import javax.xml.namespace.QName;
 
 import org.apache.jackrabbit.spi.Name;
 import org.apache.jackrabbit.spi.commons.conversion.IllegalNameException;
@@ -42,6 +41,7 @@ import org.apache.jackrabbit.vault.validation.ValidationViolation;
 import org.apache.jackrabbit.vault.validation.spi.DocumentViewXmlValidator;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
 import org.jetbrains.annotations.NotNull;
 import org.xml.sax.Attributes;
 import org.xml.sax.Locator;
@@ -51,10 +51,11 @@ import org.xml.sax.helpers.DefaultHandler;
 /** TODO: reuse more logic from DocViewSAXImporter (https://issues.apache.org/jira/browse/JCRVLT-357) */
 public class DocumentViewXmlContentHandler extends DefaultHandler implements NamespaceResolver {
 
-    private final @NotNull Map<String, Integer> nodePathsAndLineNumbers;
+    private final @NotNull Map<@NotNull String, @NotNull Integer> nodePathsAndLineNumbers;
     private String rootNodeName;
     private String rootNodeParentPath; // must not end with "/"
-    private final Path filePath;
+    private final @NotNull Path filePath;
+    private final @NotNull Path basePath;
     private Locator locator;
     private Deque<String> elementNameStack;
     private Deque<DocViewNode> nodeStack;
@@ -77,11 +78,13 @@ public class DocumentViewXmlContentHandler extends DefaultHandler implements Nam
     /**
      * 
      * @param filePath the relative file to the docview file (relative to the jcr_root folder)
+     * @param basePath the absolute file path of the the jcr_root folder (to which {@code filePath} is relative)
      * @param rootNodePath the node path of the root node covered by this docview file
      * @param documentViewXmlValidators the validators to call for this docview file
      */
-    public DocumentViewXmlContentHandler(Path filePath, String rootNodePath, Map<String, DocumentViewXmlValidator> documentViewXmlValidators) {
+    public DocumentViewXmlContentHandler(@NotNull Path filePath, @NotNull Path basePath, String rootNodePath, Map<String, DocumentViewXmlValidator> documentViewXmlValidators) {
         this.filePath = filePath;
+        this.basePath = basePath;
         if (rootNodePath.equals("/")) {
             rootNodePath = "";
         }
@@ -193,7 +196,7 @@ public class DocumentViewXmlContentHandler extends DefaultHandler implements Nam
             violations.add(new ValidationViolation(ValidationMessageSeverity.DEBUG, "Validate node '" + node + "' start"));
             for (Map.Entry<String, DocumentViewXmlValidator> entry : validators.entrySet()) {
                 try {
-                    Collection<ValidationMessage> messages = entry.getValue().validate(node, nodePath.toString(), filePath, elementNameStack.size() <= 1);
+                    Collection<ValidationMessage> messages = entry.getValue().validate(node, new NodeContextImpl(nodePath.toString(), filePath, basePath), elementNameStack.size() <= 1);
                     if (messages != null && !messages.isEmpty()) {
                         violations.addAll(ValidationViolation.wrapMessages(entry.getKey(), messages, filePath, null, nodePath.toString(),
                                 locator.getLineNumber(), locator.getColumnNumber()));
@@ -211,7 +214,7 @@ public class DocumentViewXmlContentHandler extends DefaultHandler implements Nam
         }
     }
 
-    private DocViewNode getDocViewNode(Name name, String label, Attributes attributes) {
+    private @NotNull DocViewNode getDocViewNode(Name name, String label, Attributes attributes) {
         Map<String, DocViewProperty> propertyMap = new HashMap<>();
         
         String uuid = null;
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
index 166f23ba..6521ca24 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/package-info.java
@@ -17,7 +17,7 @@
 /**
  * The FileVault validation framework API. Provides classes to execute validations on FileVault packages.
  */
-@Version("1.0.1")
+@Version("2.0.0")
 package org.apache.jackrabbit.vault.validation;
 
 import org.osgi.annotation.versioning.Version;
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/DocumentViewXmlValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/DocumentViewXmlValidator.java
index 80a5e03f..f14a1d99 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/DocumentViewXmlValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/DocumentViewXmlValidator.java
@@ -49,6 +49,27 @@ public interface DocumentViewXmlValidator extends Validator {
      * @param filePath the relative file path of the docview file containing this node
      * @param isRoot {@code true} in case this is the root node of the docview file otherwise {@code false}
      * @return validation messages or {@code null}
+     * @deprecated Use {@link #validate(DocViewNode, NodeContext, boolean)} instead
      */
-    @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull String nodePath, @NotNull Path filePath, boolean isRoot);
+    @Deprecated
+    default @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull String nodePath, @NotNull Path filePath, boolean isRoot) {
+        throw new UnsupportedOperationException();
+    }
+    
+    /**
+     * Called for the beginning of each new JCR document view node.
+     * Deserialization of the node information was already done when this method is called!
+     * The node and attribute names have the string representation outlined in {@link Name} (i.e. including the namespace uri in the format <code>{namespaceURI}localPart</code>).
+     * This is also referred to as <a href="https://docs.adobe.com/docs/en/spec/jcr/2.0/3_Repository_Model.html#3.2.5.1%20Expanded%20Form">JCR name expanded form</a>.
+     * To construct such names either use {@link NameUtil} or use the constants from {@link NameConstants}.
+     * 
+     * The node's label refers to the XML element name specifying the node. There shouldn't be any checks derived from it, but only from the expanded name.
+     * @param node the node which should be validated
+     * @param nodeContext the information about the node context (like path)
+     * @param isRoot {@code true} in case this is the root node of the docview file otherwise {@code false}
+     * @return validation messages or {@code null}
+     */
+    default @Nullable Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext, boolean isRoot) {
+        return validate(node, nodeContext.getNodePath(), nodeContext.getFilePath(), isRoot);
+    }
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericJcrDataValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericJcrDataValidator.java
index 4827bf12..30e86f04 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericJcrDataValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericJcrDataValidator.java
@@ -23,6 +23,7 @@ import java.util.Collection;
 import java.util.Map;
 
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 import org.osgi.annotation.versioning.ProviderType;
 
 /**
@@ -42,14 +43,47 @@ public interface GenericJcrDataValidator extends Validator {
      * @param nodePathsAndLineNumbers a map which should be filled with all node path and their according line numbers if nodes are detected in the given input
      * @return a collection of validation messages or {@code null}
      * @throws IOException in case the input stream could not be accessed
+     * @deprecated Use {@link #validateJcrData(InputStream, Path, Path, Map)} instead.
      */
-    Collection<ValidationMessage> validateJcrData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Map<String, Integer> nodePathsAndLineNumbers) throws IOException;
+    @Deprecated
+    default @Nullable Collection<ValidationMessage> validateJcrData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Map<String, Integer> nodePathsAndLineNumbers) throws IOException {
+        throw new UnsupportedOperationException();
+    }
 
+    /**
+     * Called for each file below jcr_root.
+     * Only called in case {@link #shouldValidateJcrData(Path)} returned {@code true} for the given path.
+     * 
+     * @param input the input stream of the file which ends up below jcr_root in the package located at filePath
+     * @param filePath file path relative to the jcr_root directory (i.e. does not start with {@code jcr_root})
+     * @param basePath the absolute file path of jcr_root (base for {@code filePath)})
+     * @param nodePathsAndLineNumbers a map which should be filled with all node path and their according line numbers if nodes are detected in the given input
+     * @return a collection of validation messages or {@code null}
+     * @throws IOException in case the input stream could not be accessed
+     */
+    default @Nullable Collection<ValidationMessage> validateJcrData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath, @NotNull Map<String, Integer> nodePathsAndLineNumbers) throws IOException {
+        return validateJcrData(input, filePath, nodePathsAndLineNumbers);
+    }
+
+    /**
+     * Called for each file below jcr_root.
+     * 
+     * @param filePath file path relative to the jcr_root directory (i.e. does not start with {@code jcr_root})
+     * @return {@code true} in case the file should be validated, otherwise {@code false}
+     */
+    @Deprecated
+    default boolean shouldValidateJcrData(@NotNull Path filePath) {
+        throw new UnsupportedOperationException();
+    }
+    
     /**
      * Called for each file below jcr_root.
      * 
      * @param filePath file path relative to the jcr_root directory (i.e. does not start with {@code jcr_root})
+     * @param basePath the absolute file path of jcr_root (base for {@code filePath)})
      * @return {@code true} in case the file should be validated, otherwise {@code false}
      */
-    boolean shouldValidateJcrData(@NotNull Path filePath);
+    default boolean shouldValidateJcrData(@NotNull Path filePath, @NotNull Path basePath) {
+        return shouldValidateJcrData(filePath);
+    }
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericMetaInfDataValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericMetaInfDataValidator.java
index 9ccf9e6f..dc3e7787 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericMetaInfDataValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/GenericMetaInfDataValidator.java
@@ -18,8 +18,10 @@ package org.apache.jackrabbit.vault.validation.spi;
 
 import java.io.IOException;
 import java.io.InputStream;
+import java.nio.channels.ShutdownChannelGroupException;
 import java.nio.file.Path;
 import java.util.Collection;
+import java.util.Map;
 
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
@@ -37,22 +39,53 @@ public interface GenericMetaInfDataValidator extends Validator {
 
     /**
      * Called for each file below META-INF.
-     * Only called in case {@link #shouldValidateMetaInfData(Path)} returned true for the given path.
+     * Only called in case {@link #shouldValidateMetaInfData(Path, Path)} returned {@code true} for the given path.
      *
      * @param input the input stream of the META-INF file located at filePath
      * @param filePath file path relative to the META-INF directory (i.e. does not start with {@code META-INF})
      * @return a collection of validation messages or {@code null}
      * @throws IOException in case the input stream could not be accessed
+     * @deprecated Use {@link #validateMetaInfData(InputStream, Path, Path)} instead
      */
-    @Nullable Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath) throws IOException;
+    @Deprecated
+    default @Nullable Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath) throws IOException {
+        throw new UnsupportedOperationException();
+    }
 
+    /**
+     * Called for each file below META-INF.
+     * Only called in case {@link #shouldValidateMetaInfData(Path, Path)} returned {@code true} for the given path.
+     * 
+     * @param input the input stream of the file which ends up below jcr_root in the package located at filePath
+     * @param filePath file path relative to the META-INF directory (i.e. does not start with {@code META-INF})
+     * @param basePath the absolute file path of the META-INF directory (base for {@code filePath)})
+     * @return a collection of validation messages or {@code null}
+     * @throws IOException in case the input stream could not be accessed
+     */
+    default @Nullable Collection<ValidationMessage> validateMetaInfData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath) throws IOException {
+        return validateMetaInfData(input, filePath);
+    }
+    
     /**
      * Called for each file below META-INF.
      * 
      * @param filePath file path relative to the META-INF directory (i.e. does not start with {@code META-INF})
      * @return {@code true} in case the file should be validated, otherwise {@code false}
      */
-    boolean shouldValidateMetaInfData(@NotNull Path filePath);
-
+    @Deprecated
+    default boolean shouldValidateMetaInfData(@NotNull Path filePath) {
+        throw new UnsupportedOperationException();
+    }
     
+    /**
+     * Called for each file below META-INF.
+     * 
+     * @param filePath file path relative to the META-INF directory (i.e. does not start with {@code META-INF})
+     * @param basePath the absolute file path of the META-INF directory (base for {@code filePath)})
+     * @return {@code true} in case the file should be validated, otherwise {@code false}
+     */
+    default boolean shouldValidateMetaInfData(@NotNull Path filePath, @NotNull Path basePath) {
+        return shouldValidateMetaInfData(filePath);
+    }
+
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
index 534239b7..7acff296 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/JcrPathValidator.java
@@ -35,18 +35,23 @@ public interface JcrPathValidator extends Validator {
      * 
      * @param filePath the relative file/folder path to the jcr_root directory
      * @return validation messages or {@code null}
-     * @deprecated Use {@link #validateJcrPath(Path, boolean)} instead.
+     * @deprecated Use {@link #validateJcrPath(Path, Path, boolean)} instead.
      */
     @Deprecated 
-    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath) { return null; };
-    
+    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath) { 
+        throw new UnsupportedOperationException();
+    }
+
     /**
      * Called for each file/folder below jcr_root.
      * 
-     * @param filePath the relative file/folder path to the jcr_root directory
+     * @param filePath the relative file/folder path to the jcr_root directory (given in {@code basePath})
+     * @param basePath the absolute path to the jcr_root directory to which {@code filePath} is relative
      * @param isFolder {@code true} in case it is a folder, otherwise {@code false}
      * @return validation messages or {@code null}
      */
-    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath, boolean isFolder) { return validateJcrPath(filePath); }
+    default @Nullable Collection<ValidationMessage> validateJcrPath(@NotNull Path filePath, @NotNull Path basePath, boolean isFolder) { 
+        return validateJcrPath(filePath); 
+    }
    
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/MetaInfPathValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/MetaInfPathValidator.java
index 9abf1bd5..fe4c5415 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/MetaInfPathValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/MetaInfPathValidator.java
@@ -35,19 +35,22 @@ public interface MetaInfPathValidator extends Validator {
      * 
      * @param filePath the relative file/folder path to the META-INF directory
      * @return validation messages or {@code null}
-     * @deprecated Use {@link #validateMetaInfPath(Path, boolean)} instead.
+     * @deprecated Use {@link #validateMetaInfPath(Path, Path, boolean)} instead.
      */
     @Deprecated 
-    default @Nullable Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath) { return null; };
+    default @Nullable Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath) { 
+        throw new UnsupportedOperationException();
+    }
     
     /**
      * Called for each file/folder below META-INF.
      * 
-     * @param filePath the relative file/folder path to the META-INF directory
+     * @param filePath the relative file/folder path to the META-INF directory (given in {@code basePath})
+     * @param basePath the absolute path to the META-INF directory to which {@code filePath} is relative
      * @param isFolder {@code true} in case it is a folder, otherwise {@code false}
      * @return validation messages or {@code null}
      */
-    default @Nullable Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath, boolean isFolder) { return validateMetaInfPath(filePath); }
+    default @Nullable Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath, @NotNull Path basePath, boolean isFolder) { return validateMetaInfPath(filePath); }
    
    
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodeContext.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodeContext.java
new file mode 100644
index 00000000..c808367c
--- /dev/null
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodeContext.java
@@ -0,0 +1,50 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.validation.spi;
+
+import java.nio.file.Path;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Meta information about a node:
+ * <ul>
+ * <li>jcr path</li>
+ * <li>file path of the file which defined the node</li>
+ * </ul>
+ */
+public interface NodeContext {
+
+    /**
+     * 
+     * @return the JCR node path
+     */
+    @NotNull String getNodePath();
+
+    /**
+     * 
+     * @return the file path relative to jcr_root
+     */
+    @NotNull Path getFilePath();
+
+    /**
+     * 
+     * @return the absolute file path of jcr_root (base for {@link #getFilePath()})
+     */
+    @NotNull Path getBasePath();
+
+}
\ No newline at end of file
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodePathValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodePathValidator.java
index e7b95cf4..70cc0620 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodePathValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/NodePathValidator.java
@@ -36,7 +36,21 @@ public interface NodePathValidator extends Validator {
      * 
      * @param nodePath the absolute node path
      * @return validation messages or {@code null}
+     * @deprecated Use {@link #validate(NodeContext)} instead!
      */
-    @Nullable Collection<ValidationMessage> validate(@NotNull String nodePath);
-   
+    @Deprecated
+    default @Nullable Collection<ValidationMessage> validate(@NotNull String nodePath) { 
+        throw new UnsupportedOperationException(); 
+    }
+    
+    /**
+     * Called for each node being found in a package.
+     * Empty node elements (in DocView files) are not included as they are only used for ordering purposes.
+     * 
+     * @param nodeContext the information about the node context
+     * @return validation messages or {@code null}
+     */
+    default @Nullable Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext ) {
+        return validate(nodeContext.getNodePath());
+    }
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/ValidationMessage.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/ValidationMessage.java
index bc2c2bf0..32674426 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/ValidationMessage.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/ValidationMessage.java
@@ -16,6 +16,8 @@
  */
 package org.apache.jackrabbit.vault.validation.spi;
 
+import java.nio.file.Path;
+
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -33,6 +35,10 @@ public class ValidationMessage {
     /** the underlying exception if there was any, may be null */
     private final Throwable throwable;
     
+    private final String nodePath; // may be null
+    private final Path filePath; // may be null
+    private final Path basePath; // may be null
+    
     public ValidationMessage(@NotNull ValidationMessageSeverity severity, @NotNull String message) {
         this(severity, message, 0, 0, null);
     }
@@ -42,15 +48,28 @@ public class ValidationMessage {
     }
 
     public ValidationMessage(@NotNull ValidationMessageSeverity severity, @NotNull String message, int line, int column, Throwable throwable) {
+        this(severity, message, null, null, line, column, throwable);
+    }
+
+    public ValidationMessage(@NotNull ValidationMessageSeverity severity, @NotNull String message, @NotNull String nodePath, @NotNull Path filePath, @NotNull Path basePath, Throwable throwable) {
+        this(severity, message, nodePath, filePath, basePath, 0, 0, throwable);
+    }
+
+    public ValidationMessage(@NotNull ValidationMessageSeverity severity, @NotNull String message, Path filePath, Path basePath, int line, int column, Throwable throwable) {
+        this(severity, message, null, filePath, basePath, line, column, throwable);
+    }
+
+    public ValidationMessage(@NotNull ValidationMessageSeverity severity, @NotNull String message, String nodePath, Path filePath, Path basePath, int line, int column, Throwable throwable) {
         this.severity = severity;
         this.message = message;
         this.line = line;
         this.column = column;
         this.throwable = throwable;
+        this.filePath = filePath;
+        this.basePath = basePath;
+        this.nodePath = nodePath;
     }
     
-    
-    
     /**
      * Returns the severity of this message.
      * @return the severity of this message
@@ -91,13 +110,33 @@ public class ValidationMessage {
         return throwable;
     }
 
+    
+    public @Nullable Path getFilePath() {
+        return filePath;
+    }
+
+    public @Nullable Path getBasePath() {
+        return basePath;
+    }
+
+    /**
+     * Returns the node path bound to this message.
+     * @return the node path or {@code null} if the message does not belong to a specific node
+     */
+    public @Nullable String getNodePath() {
+        return nodePath;
+    }
+
     @Override
     public int hashCode() {
         final int prime = 31;
         int result = 1;
+        result = prime * result + ((basePath == null) ? 0 : basePath.hashCode());
         result = prime * result + column;
+        result = prime * result + ((filePath == null) ? 0 : filePath.hashCode());
         result = prime * result + line;
         result = prime * result + ((message == null) ? 0 : message.hashCode());
+        result = prime * result + ((nodePath == null) ? 0 : nodePath.hashCode());
         result = prime * result + ((severity == null) ? 0 : severity.hashCode());
         return result;
     }
@@ -111,12 +150,27 @@ public class ValidationMessage {
         if (getClass() != obj.getClass())
             return false;
         ValidationMessage other = (ValidationMessage) obj;
+        if (basePath == null) {
+            if (other.basePath != null)
+                return false;
+        } else if (!basePath.equals(other.basePath))
+            return false;
         if (column != other.column)
             return false;
+        if (filePath == null) {
+            if (other.filePath != null)
+                return false;
+        } else if (!filePath.equals(other.filePath))
+            return false;
         if (line != other.line)
             return false;
         if (!message.equals(other.message))
             return false;
+        if (nodePath == null) {
+            if (other.nodePath != null)
+                return false;
+        } else if (!nodePath.equals(other.nodePath))
+            return false;
         if (severity != other.severity)
             return false;
         return true;
@@ -126,7 +180,9 @@ public class ValidationMessage {
     public String toString() {
         return "ValidationMessage [" + (severity != null ? "severity=" + severity + ", " : "")
                 + (message != null ? "message=" + message + ", " : "") + "line=" + line + ", column=" + column + ", "
-                + (throwable != null ? "throwable=" + throwable : "") + "]";
+                + (throwable != null ? "throwable=" + throwable + ", " : "") + (nodePath != null ? "nodePath=" + nodePath + ", " : "")
+                + (filePath != null ? "filePath=" + filePath + ", " : "") + (basePath != null ? "basePath=" + basePath : "") + "]";
     }
 
+
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
index 4872dacd..d90a1534 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/AdvancedFilterValidator.java
@@ -84,10 +84,10 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
 
     private final boolean isSubPackage;
     private final Collection<String> validRoots;
-    private final ValidationMessageSeverity defaultSeverity;
-    private final ValidationMessageSeverity severityForUncoveredAncestorNode;
-    private final ValidationMessageSeverity severityForUncoveredFilterRootAncestors;
-    private final ValidationMessageSeverity severityForOrphanedFilterEntries;
+    private final @NotNull ValidationMessageSeverity defaultSeverity;
+    private final @NotNull ValidationMessageSeverity severityForUncoveredAncestorNode;
+    private final @NotNull ValidationMessageSeverity severityForUncoveredFilterRootAncestors;
+    private final @NotNull ValidationMessageSeverity severityForOrphanedFilterEntries;
     private final Collection<PackageInfo> dependenciesMetaInfo;
     private final WorkspaceFilter filter;
     private Map<String, FilterValidator> filterValidators;
@@ -300,7 +300,7 @@ public final class AdvancedFilterValidator implements GenericMetaInfDataValidato
         return FILTER_XML_PATH.equals(filePath);
     }
 
-    private void removeFromOrphanedFilterEntries(String nodePath) {
+    private void removeFromOrphanedFilterEntries(@NotNull String nodePath) {
         // find all filter roots which match
         Iterator<java.util.Map.Entry<PathFilterSet, List<Entry<PathFilter>>>> iter = orphanedFilterSets.entrySet().iterator();
         while (iter.hasNext()) {
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DocumentViewParserValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DocumentViewParserValidator.java
index e3dfd61b..b2a61a30 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DocumentViewParserValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/DocumentViewParserValidator.java
@@ -69,7 +69,7 @@ public class DocumentViewParserValidator implements GenericJcrDataValidator {
     }
 
     @Override
-    public Collection<ValidationMessage> validateJcrData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Map<String, Integer> nodePathsAndLineNumbers) throws IOException {
+    public Collection<ValidationMessage> validateJcrData(@NotNull InputStream input, @NotNull Path filePath, @NotNull Path basePath, @NotNull Map<String, Integer> nodePathsAndLineNumbers) throws IOException {
         Collection<ValidationMessage> messages = new LinkedList<>();
         // TODO: support other formats like sysview xml or generic xml
         // (https://jackrabbit.apache.org/filevault/vaultfs.html#Deserialization)
@@ -80,7 +80,7 @@ public class DocumentViewParserValidator implements GenericJcrDataValidator {
         Path documentViewXmlRootPath = getDocumentViewXmlRootPath(bufferedInput, filePath);
         if (documentViewXmlRootPath != null) {
             try {
-                messages.addAll(validateDocumentViewXml(bufferedInput, filePath, ValidationExecutor.filePathToNodePath(documentViewXmlRootPath),
+                messages.addAll(validateDocumentViewXml(bufferedInput, filePath, basePath, ValidationExecutor.filePathToNodePath(documentViewXmlRootPath),
                             nodePathsAndLineNumbers));
             } catch (SAXException e) {
                 throw new IOException("Could not parse xml", e);
@@ -136,11 +136,11 @@ public class DocumentViewParserValidator implements GenericJcrDataValidator {
         return rootPath;
     }
 
-    protected Collection<ValidationMessage> validateDocumentViewXml(InputStream input, Path filePath, String rootNodePath,
+    protected Collection<ValidationMessage> validateDocumentViewXml(InputStream input, Path filePath, Path basePath, String rootNodePath,
             Map<String, Integer> nodePathsAndLineNumbers) throws IOException, SAXException {
         List<ValidationMessage> enrichedMessages = new LinkedList<>();
         XMLReader xr = saxParser.getXMLReader();
-        final DocumentViewXmlContentHandler handler = new DocumentViewXmlContentHandler(filePath, rootNodePath,
+        final DocumentViewXmlContentHandler handler = new DocumentViewXmlContentHandler(filePath, basePath, rootNodePath,
                 docViewValidators);
         enrichedMessages.add(new ValidationMessage(ValidationMessageSeverity.DEBUG, "Detected DocView..."));
         xr.setContentHandler(handler);
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidator.java
index a0912ba6..9d7afc68 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidator.java
@@ -16,12 +16,9 @@
  */
 package org.apache.jackrabbit.vault.validation.spi.impl;
 
-import java.nio.file.Path;
 import java.util.Collection;
-import java.util.Collections;
-import java.util.LinkedHashMap;
 import java.util.LinkedList;
-import java.util.Map;
+import java.util.List;
 import java.util.stream.Collectors;
 
 import org.apache.jackrabbit.vault.fs.api.ImportMode;
@@ -29,6 +26,7 @@ import org.apache.jackrabbit.vault.fs.api.PathFilterSet;
 import org.apache.jackrabbit.vault.fs.api.WorkspaceFilter;
 import org.apache.jackrabbit.vault.util.DocViewNode;
 import org.apache.jackrabbit.vault.validation.spi.DocumentViewXmlValidator;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.NodePathValidator;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
@@ -42,10 +40,10 @@ import org.jetbrains.annotations.Nullable;
  */
 public class EmptyElementsValidator implements DocumentViewXmlValidator, NodePathValidator {
 
-    protected static final String MESSAGE_EMPTY_NODES = "Found empty nodes: %s (used for ordering only) without an accompanying folder which are included in the filter with mode=replace. Either remove the empty node or add at least the 'jcr:primaryType' attribute to make this node really get replaced.";
+    protected static final String MESSAGE_EMPTY_NODES = "Found empty node (used for ordering only) without an accompanying folder which are included in the filter with mode=replace. Either remove the empty node or add at least the 'jcr:primaryType' attribute to make this node really get replaced.";
     private final ValidationMessageSeverity severity;
-    private final Map<String, Path> emptyNodePathsAndFiles;
-    private final Collection<String> nonEmptyNodePaths;
+    private final List<NodeContext> emptyNodes;
+    private final List<String> nonEmptyNodePaths;
     private final WorkspaceFilter filter;
     
     private Collection<String> affectedFilterRoots;
@@ -53,7 +51,7 @@ public class EmptyElementsValidator implements DocumentViewXmlValidator, NodePat
     
     public EmptyElementsValidator(ValidationMessageSeverity severity, WorkspaceFilter filter) {
         this.severity = severity;
-        this.emptyNodePathsAndFiles = new LinkedHashMap<>();
+        this.emptyNodes = new LinkedList<>();
         this.nonEmptyNodePaths = new LinkedList<>();
         this.filter = filter;
         // collect all filter roots with import mode == replace
@@ -67,25 +65,23 @@ public class EmptyElementsValidator implements DocumentViewXmlValidator, NodePat
 
     @Override
     public Collection<ValidationMessage> done() {
-        emptyNodePathsAndFiles.keySet().removeAll(nonEmptyNodePaths);
-        if (!emptyNodePathsAndFiles.isEmpty()) {
-            String nodes = emptyNodePathsAndFiles.entrySet()
-                    .stream()
-                    .map(e -> "'" + e.getKey() + "' (in '" + e.getValue() + "')")
-                    .collect(Collectors.joining(", "));
-            return Collections.singleton(new ValidationMessage(severity, String.format(MESSAGE_EMPTY_NODES, nodes)));
-        }
-        return null;
+        return emptyNodes.stream()
+            .filter(e -> nonEmptyNodePaths.stream().noneMatch(n -> n.equals(e.getNodePath())))
+            .map(e -> new ValidationMessage(severity, MESSAGE_EMPTY_NODES, e.getNodePath(), e.getFilePath(), e.getBasePath(), null))
+            .collect(Collectors.toList());
     }
 
     @Override
-    public Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull String nodePath, @NotNull Path filePath, boolean isRoot) {
-        if (isBelowAffectedFilterRoots(nodePath)) {
-            if (node.primary == null && node.mixins == null && node.props.isEmpty() && filter.contains(nodePath) && filter.getImportMode(nodePath) == ImportMode.REPLACE) {
+    public Collection<ValidationMessage> validate(@NotNull DocViewNode node, @NotNull NodeContext nodeContext, boolean isRoot) {
+        if (isBelowAffectedFilterRoots(nodeContext.getNodePath())) {
+            if (node.primary == null && node.mixins == null && node.props.isEmpty() && filter.contains(nodeContext.getNodePath()) && filter.getImportMode(nodeContext.getNodePath()) == ImportMode.REPLACE) {
                 // only relevant if no other merge mode
-                emptyNodePathsAndFiles.put(nodePath, filePath);
+                // ignore rep:policy nodes
+                if (!node.name.equals("rep:policy")) {
+                    emptyNodes.add(nodeContext);
+                }
             } else {
-                nonEmptyNodePaths.add(nodePath);
+                nonEmptyNodePaths.add(nodeContext.getNodePath());
             }
         }
         return null;
@@ -101,9 +97,9 @@ public class EmptyElementsValidator implements DocumentViewXmlValidator, NodePat
     }
 
     @Override
-    public @Nullable Collection<ValidationMessage> validate(@NotNull String nodePath) {
-        if (isBelowAffectedFilterRoots(nodePath)) {
-            nonEmptyNodePaths.add(nodePath);
+    public @Nullable Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext) {
+        if (isBelowAffectedFilterRoots(nodeContext.getNodePath())) {
+            nonEmptyNodePaths.add(nodeContext.getNodePath());
         }
         return null;
     }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java
index 5b78c1f2..f019a5d3 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidator.java
@@ -21,7 +21,9 @@ import java.nio.file.Paths;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.LinkedList;
+import java.util.List;
 import java.util.regex.Pattern;
+import java.util.stream.Collectors;
 
 import org.apache.commons.lang3.StringUtils;
 import org.apache.jackrabbit.vault.fs.api.PathFilterSet;
@@ -33,6 +35,7 @@ import org.apache.jackrabbit.vault.util.DocViewNode;
 import org.apache.jackrabbit.vault.validation.spi.DocumentViewXmlValidator;
 import org.apache.jackrabbit.vault.validation.spi.FilterValidator;
 import org.apache.jackrabbit.vault.validation.spi.MetaInfPathValidator;
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
 import org.apache.jackrabbit.vault.validation.spi.NodePathValidator;
 import org.apache.jackrabbit.vault.validation.spi.PropertiesValidator;
 import org.apache.jackrabbit.vault.validation.spi.ValidationContext;
@@ -53,10 +56,10 @@ public final class PackageTypeValidator implements NodePathValidator, FilterVali
     protected static final String MESSAGE_LEGACY_TYPE = "Package of type '%s' is legacy. Use one of the other types instead!";
     protected static final String MESSAGE_PACKAGE_HOOKS = "Package of type '%s' must not contain package hooks but has '%s'!";
     protected static final String MESSAGE_NO_PACKAGE_TYPE_SET = "No package type set, make sure that property 'packageType' is set in the properties.xml!";
-    protected static final String MESSAGE_OSGI_BUNDLE_OR_CONFIG = "Package of type '%s' is not supposed to contain OSGi bundles or configurations but has '%s'!";
-    protected static final String MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE = "Package of type '%s' is not supposed to contain anything but OSGi bundles/configurations and sub packages but has '%s'!";
-    protected static final String MESSAGE_APP_CONTENT = "Package of type '%s' is not supposed to contain content inside '/libs' and '/apps' but has '%s'!";
-    protected static final String MESSAGE_NO_APP_CONTENT_FOUND = "Package of type '%s' is not supposed to contain content outside '/libs' and '/apps' but has '%s'!";
+    protected static final String MESSAGE_OSGI_BUNDLE_OR_CONFIG = "Package of type '%s' is not supposed to contain OSGi bundles or configurations!";
+    protected static final String MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE = "Package of type '%s' is not supposed to contain anything but OSGi bundles/configurations and sub packages!";
+    protected static final String MESSAGE_APP_CONTENT = "Package of type '%s' is not supposed to contain content inside '/libs' and '/apps'!";
+    protected static final String MESSAGE_NO_APP_CONTENT_FOUND = "Package of type '%s' is not supposed to contain content outside '/libs' and '/apps'!";
     protected static final String MESSAGE_INDEX_DEFINITIONS = "Package of type '%s' is not supposed to contain Oak index definitions but has 'allowIndexDefinitions' set to true.";
     protected static final String MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE = "All mutable package types are prohibited and this package is of mutable type '%s'";
     protected static final String MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE = "All mutable package types are prohibited and this package is of mutable type '%s'";
@@ -72,10 +75,13 @@ public final class PackageTypeValidator implements NodePathValidator, FilterVali
     private final boolean prohibitMutableContent;
     private final boolean prohibitImmutableContent;
     private final boolean allowComplexFilterRulesInApplicationPackages;
+    private final @NotNull WorkspaceFilter filter;
+    private List<String> validContainerNodePaths;
+    private List<NodeContext> potentiallyDisallowedContainerNodes;
 
-    public PackageTypeValidator(@NotNull ValidationMessageSeverity severity, @NotNull ValidationMessageSeverity severityForNoPackageType, @NotNull ValidationMessageSeverity severityForLegacyType,
+    public PackageTypeValidator(@NotNull WorkspaceFilter workspaceFilter, @NotNull ValidationMessageSeverity severity, @NotNull ValidationMessageSeverity severityForNoPackageType, @NotNull ValidationMessageSeverity severityForLegacyType,
             boolean prohibitMutableContent, boolean prohibitImmutableContent, boolean allowComplexFilterRulesInApplicationPackages, PackageType type, @NotNull Pattern jcrInstallerNodePathRegex, @NotNull Pattern additionalJcrInstallerFileNodePathRegex,
-            ValidationContext containerValidationContext) {
+            @Nullable ValidationContext containerValidationContext) {
         this.type = type;
         this.severity = severity;
         this.severityForNoPackageType = severityForNoPackageType;
@@ -86,6 +92,9 @@ public final class PackageTypeValidator implements NodePathValidator, FilterVali
         this.jcrInstallerNodePathRegex = jcrInstallerNodePathRegex;
         this.additionalJcrInstallerFileNodePathRegex = additionalJcrInstallerFileNodePathRegex;
         this.containerValidationContext = containerValidationContext;
+        this.filter = workspaceFilter;
+        this.validContainerNodePaths = new LinkedList<>();
+        this.potentiallyDisallowedContainerNodes = new LinkedList<>();
     }
 
     boolean isOsgiBundleOrConfiguration(String nodePath, boolean onlyFile) {
@@ -109,40 +118,58 @@ public final class PackageTypeValidator implements NodePathValidator, FilterVali
 
     @Override
     public @Nullable Collection<ValidationMessage> done() {
+        // check if questionable nodes are parents of valid nodes
+        List<NodeContext> invalidNodes = potentiallyDisallowedContainerNodes.stream().filter(
+                s -> validContainerNodePaths.stream().noneMatch(
+                        p -> p.startsWith(s.getNodePath() + "/")))
+                .collect(Collectors.toList());
+        if (!invalidNodes.isEmpty()) {
+            return invalidNodes.stream().map(
+                    e -> new ValidationMessage(severity, String.format(MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, type), e.getNodePath(), e.getFilePath(), e.getBasePath(), null))
+                    .collect(Collectors.toList());
+        }
         return null;
     }
 
     @Override
-    public @Nullable Collection<ValidationMessage> validate(@NotNull String nodePath) {
+    public @Nullable Collection<ValidationMessage> validate(@NotNull NodeContext nodeContext) {
         if (type == null) {
             return null;
         }
+        // ignore uncovered nodePaths
+        if (!filter.covers(nodeContext.getNodePath())) {
+            return null;
+        }
         Collection<ValidationMessage> messages = new LinkedList<>();
         switch (type) {
         case CONTENT:
-            if (isAppContent(nodePath)) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_APP_CONTENT, type, nodePath)));
+            if (isAppContent(nodeContext.getNodePath())) {
+                messages.add(new ValidationMessage(severity, String.format(MESSAGE_APP_CONTENT, type)));
             }
-            if (isOsgiBundleOrConfiguration(nodePath, true)) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_OSGI_BUNDLE_OR_CONFIG, type, nodePath)));
+            if (isOsgiBundleOrConfiguration(nodeContext.getNodePath(), true)) {
+                messages.add(new ValidationMessage(severity, String.format(MESSAGE_OSGI_BUNDLE_OR_CONFIG, type)));
             }
             break;
         case APPLICATION:
-            if (!isAppContent(nodePath)) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_NO_APP_CONTENT_FOUND, type, nodePath)));
+            if (!isAppContent(nodeContext.getNodePath())) {
+                messages.add(new ValidationMessage(severity, String.format(MESSAGE_NO_APP_CONTENT_FOUND, type)));
             }
-            if (isOsgiBundleOrConfiguration(nodePath, true)) {
-                messages.add(new ValidationMessage(severity, String.format(MESSAGE_OSGI_BUNDLE_OR_CONFIG, type, nodePath)));
+            if (isOsgiBundleOrConfiguration(nodeContext.getNodePath(), true)) {
+                messages.add(new ValidationMessage(severity, String.format(MESSAGE_OSGI_BUNDLE_OR_CONFIG, type)));
             }
             // sub packages are detected via validate(Properties) on the sub package
             break;
         case CONTAINER:
             // sling:OsgiConfig
-            if (!isOsgiBundleOrConfiguration(nodePath, false) && !isSubPackage(nodePath)) {
-                messages.add(
-                        new ValidationMessage(severity, String.format(MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, type, nodePath)));
+            if (isOsgiBundleOrConfiguration(nodeContext.getNodePath(), false)) {
+                validContainerNodePaths.add(nodeContext.getNodePath());
+            }
+            else if (isSubPackage(nodeContext.getNodePath())) {
+                validContainerNodePaths.add(nodeContext.getNodePath());
+            } else {
+                // only potentially disallowed, as the node may be a parent of a sub package or osgi bundle, which is allowed as well
+                potentiallyDisallowedContainerNodes.add(nodeContext);
             }
-
             break;
         case MIXED:
             // no validations currently as most relaxed type
@@ -271,7 +298,7 @@ public final class PackageTypeValidator implements NodePathValidator, FilterVali
 
     
     @Override
-    public Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath) {
+    public Collection<ValidationMessage> validateMetaInfPath(@NotNull Path filePath, @NotNull Path basePath, boolean isFolder) {
         if (type == null) {
             return null;
         }
@@ -304,5 +331,4 @@ public final class PackageTypeValidator implements NodePathValidator, FilterVali
         }
         return null;
     }
-
 }
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorFactory.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorFactory.java
index a0e08bde..cfb3c322 100644
--- a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorFactory.java
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorFactory.java
@@ -113,7 +113,7 @@ public final class PackageTypeValidatorFactory implements ValidatorFactory {
         } else {
             allowComplexFilterRulesInApplicationPackages = false;
         }
-        return new PackageTypeValidator(settings.getDefaultSeverity(), severityForNoType, severityForLegacyType, prohibitMutableContent, prohibitImmutableContent, allowComplexFilterRulesInApplicationPackages, context.getProperties().getPackageType(), jcrInstallerNodePathRegex, additionalJcrInstallerFileNodePathRegex, context.getContainerValidationContext());
+        return new PackageTypeValidator(context.getFilter(), settings.getDefaultSeverity(), severityForNoType, severityForLegacyType, prohibitMutableContent, prohibitImmutableContent, allowComplexFilterRulesInApplicationPackages, context.getProperties().getPackageType(), jcrInstallerNodePathRegex, additionalJcrInstallerFileNodePathRegex, context.getContainerValidationContext());
     }
 
     @Override
diff --git a/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/util/NodeContextImpl.java b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/util/NodeContextImpl.java
new file mode 100644
index 00000000..c075d1d1
--- /dev/null
+++ b/vault-validation/src/main/java/org/apache/jackrabbit/vault/validation/spi/util/NodeContextImpl.java
@@ -0,0 +1,93 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.validation.spi.util;
+
+import java.nio.file.Path;
+
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
+import org.jetbrains.annotations.NotNull;
+
+public final class NodeContextImpl implements NodeContext {
+    private final @NotNull String nodePath;
+    private final @NotNull Path filePath;
+    private final @NotNull Path basePath;
+
+    public NodeContextImpl(@NotNull String nodePath, @NotNull Path filePath, @NotNull Path basePath) {
+        super();
+        this.nodePath = nodePath;
+        this.filePath = filePath;
+        this.basePath = basePath;
+    }
+
+    @Override
+    public @NotNull String getNodePath() {
+        return nodePath;
+    }
+
+    @Override
+    public @NotNull Path getFilePath() {
+        return filePath;
+    }
+
+    @Override
+    public @NotNull Path getBasePath() {
+        return basePath;
+    }
+
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((basePath == null) ? 0 : basePath.hashCode());
+        result = prime * result + ((filePath == null) ? 0 : filePath.hashCode());
+        result = prime * result + ((nodePath == null) ? 0 : nodePath.hashCode());
+        return result;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj)
+            return true;
+        if (obj == null)
+            return false;
+        if (getClass() != obj.getClass())
+            return false;
+        NodeContextImpl other = (NodeContextImpl) obj;
+        if (basePath == null) {
+            if (other.basePath != null)
+                return false;
+        } else if (!basePath.equals(other.basePath))
+            return false;
+        if (filePath == null) {
+            if (other.filePath != null)
+                return false;
+        } else if (!filePath.equals(other.filePath))
+            return false;
+        if (nodePath == null) {
+            if (other.nodePath != null)
+                return false;
+        } else if (!nodePath.equals(other.nodePath))
+            return false;
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "NodeContextImpl [" + (nodePath != null ? "nodePath=" + nodePath + ", " : "")
+                + (filePath != null ? "filePath=" + filePath + ", " : "") + (basePath != null ? "basePath=" + basePath : "") + "]";
+    }
+}
\ No newline at end of file
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/DocumentViewParserValidatorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/DocumentViewParserValidatorTest.java
index 1d5d7b73..507d0107 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/DocumentViewParserValidatorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/DocumentViewParserValidatorTest.java
@@ -43,6 +43,7 @@ import org.apache.jackrabbit.vault.validation.spi.DocumentViewXmlValidator;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
 import org.apache.jackrabbit.vault.validation.spi.impl.DocumentViewParserValidator;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
 import org.apache.sling.api.SlingConstants;
 import org.apache.sling.jcr.resource.JcrResourceConstants;
 import org.junit.Assert;
@@ -85,17 +86,17 @@ public class DocumentViewParserValidatorTest {
     @Test
     public void testDocViewDotContentXml()
             throws ParserConfigurationException, SAXException, URISyntaxException, IOException, NamespaceException {
-        Mockito.when(docViewXmlValidator.validate(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "startDocView")));
+        Mockito.when(docViewXmlValidator.validate(Mockito.any(), Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "startDocView")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/.content.xml")) {
-            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", ".content.xml"), nodePathsAndLineNumbers);
+            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", ".content.xml"), Paths.get(""), nodePathsAndLineNumbers);
             // filter
             ValidationExecutorTest.assertViolation(messages,
-                    new ValidationViolation("docviewid", ValidationMessageSeverity.ERROR, "startDocView", Paths.get("apps/.content.xml"), Paths.get(""), "/apps", 19, 35, null
+                    new ValidationViolation("docviewid", ValidationMessageSeverity.ERROR, "startDocView", Paths.get("apps/.content.xml"), null, "/apps", 19, 35, null
                             ),
                     new ValidationViolation("docviewid", ValidationMessageSeverity.ERROR,
-                            "startDocView", Paths.get("apps/.content.xml"), Paths.get(""), "/apps/somepath", 21, 29, null),
+                            "startDocView", Paths.get("apps/.content.xml"), null, "/apps/somepath", 21, 29, null),
                     new ValidationViolation("docviewid", ValidationMessageSeverity.ERROR,
-                            "startDocView", Paths.get("apps/.content.xml"), Paths.get(""), "/apps/somepath/jc:content", 22, 54, null));
+                            "startDocView", Paths.get("apps/.content.xml"), null, "/apps/somepath/jc:content", 22, 54, null));
 
             // verify node names
             Map<String, Integer> expectedNodePathsAndLineNumber = new HashMap<>();
@@ -108,7 +109,7 @@ public class DocumentViewParserValidatorTest {
                     new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(), new String[] { "sling:Folder" }, false,
                             PropertyType.UNDEFINED));
             DocViewNode node = new DocViewNode("{}apps", "jc:root", null, properties, null, "sling:Folder");
-            Mockito.verify(docViewXmlValidator).validate(node, "/apps", Paths.get("apps", ".content.xml"), true);
+            Mockito.verify(docViewXmlValidator).validate(node, new NodeContextImpl("/apps", Paths.get("apps", ".content.xml"), Paths.get("")), true);
 
             properties = new HashMap<>();
             properties.put(NameConstants.JCR_PRIMARYTYPE.toString(),
@@ -116,26 +117,26 @@ public class DocumentViewParserValidatorTest {
                             PropertyType.UNDEFINED));
             properties.put("{}attribute1", new DocViewProperty("{}attribute1", new String[] { "value1" }, false, PropertyType.UNDEFINED));
             node = new DocViewNode("{}somepath", "somepath", null, properties, null, JcrConstants.NT_UNSTRUCTURED);
-            Mockito.verify(docViewXmlValidator).validate(node, "/apps/somepath", Paths.get("apps", ".content.xml"), false);
+            Mockito.verify(docViewXmlValidator).validate(node, new NodeContextImpl("/apps/somepath", Paths.get("apps", ".content.xml"), Paths.get("")), false);
             
             properties = new HashMap<>();
             properties.put(NameConstants.JCR_PRIMARYTYPE.toString(),
                     new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(), new String[] { JcrConstants.NT_UNSTRUCTURED }, false,
                             PropertyType.UNDEFINED));
             node = new DocViewNode("{http://www.jcp.org/jcr/1.0}content", "jc:content", null, properties, null, JcrConstants.NT_UNSTRUCTURED);
-            Mockito.verify(docViewXmlValidator).validate(node, "/apps/somepath/jc:content", Paths.get("apps", ".content.xml"), false);
+            Mockito.verify(docViewXmlValidator).validate(node, new NodeContextImpl("/apps/somepath/jc:content", Paths.get("apps", ".content.xml"), Paths.get("")), false);
         }
     }
 
     @Test
     public void testDocViewDotContentXmlOnRootLevel()
             throws ParserConfigurationException, SAXException, URISyntaxException, IOException, NamespaceException {
-        Mockito.when(docViewXmlValidator.validate(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "startDocView")));
+        Mockito.when(docViewXmlValidator.validate(Mockito.any(), Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "startDocView")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/.content.xml")) {
-            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get(".content.xml"), nodePathsAndLineNumbers);
+            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get(".content.xml"), Paths.get(""), nodePathsAndLineNumbers);
             // filter
             ValidationExecutorTest.assertViolation(messages,
-                    new ValidationViolation("docviewid", ValidationMessageSeverity.ERROR, "startDocView", Paths.get(".content.xml"), Paths.get(""), "/", 6, 32, null
+                    new ValidationViolation("docviewid", ValidationMessageSeverity.ERROR, "startDocView", Paths.get(".content.xml"), null, "/", 6, 32, null
                             ));
 
             // verify node names
@@ -151,14 +152,14 @@ public class DocumentViewParserValidatorTest {
             properties.put(NAME_SLING_TARGET.toString(), new DocViewProperty(NAME_SLING_TARGET.toString(), new String[] { "/index.html" }, false, PropertyType.UNDEFINED));
             
             DocViewNode node = new DocViewNode(NameConstants.JCR_ROOT.toString(), "jcr:root", null, properties, new String[] { "rep:AccessControllable" ,"rep:RepoAccessControllable" }, "rep:root");
-            Mockito.verify(docViewXmlValidator).validate(node, "/", Paths.get(".content.xml"), true);
+            Mockito.verify(docViewXmlValidator).validate(node, new NodeContextImpl("/", Paths.get(".content.xml"), Paths.get("")), true);
         }
     }
     
     @Test
     public void testDocViewWithEmptyElements() throws IOException {
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/emptyelements/.content.xml")) {
-            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "emptyelements", ".content.xml"), nodePathsAndLineNumbers);
+            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "emptyelements", ".content.xml"), Paths.get(""), nodePathsAndLineNumbers);
             Assert.assertThat(messages, AnyValidationMessageMatcher.noValidationInCollection());
 
             // verify node names
@@ -174,7 +175,7 @@ public class DocumentViewParserValidatorTest {
             throws ParserConfigurationException, SAXException, URISyntaxException, IOException, NamespaceException {
 
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/child1.xml")) {
-            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "child1.xml"), nodePathsAndLineNumbers);
+            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "child1.xml"), Paths.get(""), nodePathsAndLineNumbers);
             Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
 
             Map<String, DocViewProperty> properties = new HashMap<>();
@@ -182,7 +183,7 @@ public class DocumentViewParserValidatorTest {
                     new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(), new String[] { "sling:Folder" }, false,
                             PropertyType.UNDEFINED));
             DocViewNode node = new DocViewNode("{}child1", "jcr:root", null, properties, null, "sling:Folder");
-            Mockito.verify(docViewXmlValidator).validate(node, "/apps/child1", Paths.get("apps", "child1.xml"), true);
+            Mockito.verify(docViewXmlValidator).validate(node, new NodeContextImpl("/apps/child1", Paths.get("apps", "child1.xml"), Paths.get("")), true);
 
             properties = new HashMap<>();
             properties.put(NameConstants.JCR_PRIMARYTYPE.toString(),
@@ -190,7 +191,7 @@ public class DocumentViewParserValidatorTest {
                             PropertyType.UNDEFINED));
             properties.put("{}attribute1", new DocViewProperty("{}attribute1", new String[] { "value1" }, false, PropertyType.UNDEFINED));
             node = new DocViewNode("{}somepath", "somepath", null, properties, null, JcrConstants.NT_UNSTRUCTURED);
-            Mockito.verify(docViewXmlValidator).validate(node, "/apps/child1/somepath", Paths.get("apps", "child1.xml"), false);
+            Mockito.verify(docViewXmlValidator).validate(node, new NodeContextImpl("/apps/child1/somepath", Paths.get("apps", "child1.xml"), Paths.get("")), false);
 
             // verify node names
             Map<String, Integer> expectedNodePathsAndLineNumber = new HashMap<>();
@@ -204,7 +205,7 @@ public class DocumentViewParserValidatorTest {
     public void testDocViewDotContentXmlWithRootElementDifferentThanJcrRoot()
             throws ParserConfigurationException, SAXException, URISyntaxException, IOException, NamespaceException {
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/child2/.content.xml")) {
-            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "child2", ".content.xml"), nodePathsAndLineNumbers);
+            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "child2", ".content.xml"), Paths.get(""), nodePathsAndLineNumbers);
             Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
 
             Map<String, DocViewProperty> properties = new HashMap<>();
@@ -212,7 +213,7 @@ public class DocumentViewParserValidatorTest {
                     new DocViewProperty(NameConstants.JCR_PRIMARYTYPE.toString(), new String[] { "sling:Folder" }, false,
                             PropertyType.UNDEFINED));
             DocViewNode node = new DocViewNode("{}child3", "child3", null, properties, null, "sling:Folder");
-            Mockito.verify(docViewXmlValidator).validate(node, "/apps/child3", Paths.get("apps", "child2", ".content.xml"), true);
+            Mockito.verify(docViewXmlValidator).validate(node, new NodeContextImpl("/apps/child3", Paths.get("apps", "child2", ".content.xml"), Paths.get("")), true);
 
             properties = new HashMap<>();
             properties.put(NameConstants.JCR_PRIMARYTYPE.toString(),
@@ -220,7 +221,7 @@ public class DocumentViewParserValidatorTest {
                             PropertyType.UNDEFINED));
             properties.put("{}attribute1", new DocViewProperty("{}attribute1", new String[] { "value1" }, false, PropertyType.UNDEFINED));
             node = new DocViewNode("{}somepath", "somepath", null, properties, null, JcrConstants.NT_UNSTRUCTURED);
-            Mockito.verify(docViewXmlValidator).validate(node, "/apps/child3/somepath", Paths.get("apps", "child2", ".content.xml"), false);
+            Mockito.verify(docViewXmlValidator).validate(node, new NodeContextImpl("/apps/child3/somepath", Paths.get("apps", "child2", ".content.xml"), Paths.get("")), false);
 
             // verify node names
             Map<String, Integer> expectedNodePathsAndLineNumber = new HashMap<>();
@@ -234,10 +235,10 @@ public class DocumentViewParserValidatorTest {
     public void testDocViewWithRegularFileNameWithRootElementDifferentThanJcrRoot() throws IOException {
         // https://issues.apache.org/jira/browse/JCRVLT-358"
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/child2/child1.xml")) {
-            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "child2", "child1.xml"), nodePathsAndLineNumbers);
+            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "child2", "child1.xml"), Paths.get(""), nodePathsAndLineNumbers);
             Assert.assertThat(messages, AnyValidationMessageMatcher.noValidationInCollection());
 
-            Mockito.verifyZeroInteractions(docViewXmlValidator);
+            Mockito.verifyNoMoreInteractions(docViewXmlValidator);
 
             // verify node names
             Map<String, Integer> expectedNodePathsAndLineNumber = new HashMap<>();
@@ -249,12 +250,12 @@ public class DocumentViewParserValidatorTest {
     @Test
     public void testDocViewWithInvalidType() throws ParserConfigurationException, SAXException, URISyntaxException, IOException {
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/invalid/wrongtype.xml")) {
-            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "invalid","wrongtype.xml"), nodePathsAndLineNumbers);
+            Collection<ValidationMessage> messages = validator.validateJcrData(input, Paths.get("apps", "invalid","wrongtype.xml"), Paths.get(""), nodePathsAndLineNumbers);
 
            ValidationExecutorTest.assertViolation(messages,
                     new ValidationViolation(ValidationMessageSeverity.ERROR,
                             String.format(DocumentViewXmlContentHandler.PARSE_VIOLATION_MESSAGE_STRING, "somepath",
-                                    "unknown type: Invalid"), Paths.get("apps/invalid/wrongtype.xml"), Paths.get(""), "/apps/invalid/wrongtype/somepath", 24, 6,
+                                    "unknown type: Invalid"), Paths.get("apps/invalid/wrongtype.xml"), null, "/apps/invalid/wrongtype/somepath", 24, 6,
                             new IllegalArgumentException("unknown type: Invalid")));
         }
     }
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/NodeContextNodePathMatcher.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/NodeContextNodePathMatcher.java
new file mode 100644
index 00000000..4483fb8c
--- /dev/null
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/NodeContextNodePathMatcher.java
@@ -0,0 +1,35 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.jackrabbit.vault.validation;
+
+import org.apache.jackrabbit.vault.validation.spi.NodeContext;
+import org.jetbrains.annotations.NotNull;
+import org.mockito.ArgumentMatcher;
+
+public class NodeContextNodePathMatcher implements ArgumentMatcher<@NotNull NodeContext> {
+
+    private final String expectedNodePath;
+    public NodeContextNodePathMatcher(String expectedNodePath) {
+        this.expectedNodePath = expectedNodePath;
+    }
+
+    @Override
+    public boolean matches(@NotNull NodeContext nodeContext) {
+        return nodeContext.getNodePath().equals(expectedNodePath);
+    }
+
+}
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
index 5b97c93f..9afb874e 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationExecutorTest.java
@@ -45,6 +45,7 @@ import org.apache.jackrabbit.vault.validation.spi.ValidationContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
 import org.apache.jackrabbit.vault.validation.spi.Validator;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
 import org.hamcrest.Matchers;
 import org.junit.Assert;
 import org.junit.Before;
@@ -107,7 +108,7 @@ public class ValidationExecutorTest {
 
     @Test
     public void testValidateNodePath() throws ParserConfigurationException, SAXException, IOException, URISyntaxException {
-        Mockito.when(nodePathValidator.validate("/apps/invalid/wrongtype.xml")).thenReturn(Collections.singletonList(new ValidationMessage(ValidationMessageSeverity.ERROR, "Invalid node path")));
+        Mockito.when(nodePathValidator.validate(Mockito.argThat(new NodeContextNodePathMatcher("/apps/invalid/wrongtype.xml")))).thenReturn(Collections.singletonList(new ValidationMessage(ValidationMessageSeverity.ERROR, "Invalid node path")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/invalid/wrongtype.xml")) {
             Collection<ValidationViolation> messages = validate(input, executor, Paths.get(""), "apps/invalid/wrongtype.xml", false);
 
@@ -119,13 +120,13 @@ public class ValidationExecutorTest {
     @Test
     public void testGenericMetaInfData()
             throws URISyntaxException, IOException, SAXException, ParserConfigurationException, ConfigurationException {
-        Mockito.when(genericMetaInfDataValidator.shouldValidateMetaInfData(Mockito.any())).thenReturn(true);
-        Mockito.when(genericMetaInfDataValidator2.shouldValidateMetaInfData(Mockito.any())).thenReturn(true);
+        Mockito.when(genericMetaInfDataValidator.shouldValidateMetaInfData(Mockito.any(), Mockito.any())).thenReturn(true);
+        Mockito.when(genericMetaInfDataValidator2.shouldValidateMetaInfData(Mockito.any(), Mockito.any())).thenReturn(true);
         CapturingInputStreamFromArgumentAnswer<Void> answer = new CapturingInputStreamFromArgumentAnswer<>(StandardCharsets.US_ASCII, 0, null);
-        Mockito.when(genericMetaInfDataValidator.validateMetaInfData(Mockito.any(), Mockito.any())).thenAnswer(answer);
+        Mockito.when(genericMetaInfDataValidator.validateMetaInfData(Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer);
         CapturingInputStreamFromArgumentAnswer<Collection<ValidationMessage>> answer2 = new CapturingInputStreamFromArgumentAnswer<>(StandardCharsets.US_ASCII, 0, Collections.singleton(new ValidationMessage(ValidationMessageSeverity.WARN, "error1")));
-        Mockito.when(genericMetaInfDataValidator2.validateMetaInfData(Mockito.any(), Mockito.any())).thenAnswer(answer2);
-        Mockito.when(metaInfPathValidator.validateMetaInfPath(Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
+        Mockito.when(genericMetaInfDataValidator2.validateMetaInfData(Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer2);
+        Mockito.when(metaInfPathValidator.validateMetaInfPath(Mockito.any(), Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/META-INF/vault/genericfile.txt")) {
             Collection<ValidationViolation> messages = validate(input, executor, Paths.get(""), "vault/genericfile.txt", true);
             assertViolation(messages, 
@@ -134,11 +135,11 @@ public class ValidationExecutorTest {
             Assert.assertEquals("Test", answer.getValue());
             Assert.assertEquals("Test", answer2.getValue());
             Path expectedPath = Paths.get("vault/genericfile.txt");
-            Mockito.verify(metaInfPathValidator).validateMetaInfPath(expectedPath, false);
-            Mockito.verify(genericMetaInfDataValidator, Mockito.atLeastOnce()).shouldValidateMetaInfData(expectedPath);
-            Mockito.verify(genericMetaInfDataValidator).validateMetaInfData(Mockito.any(), Mockito.eq(expectedPath));
-            Mockito.verify(genericMetaInfDataValidator2, Mockito.atLeastOnce()).shouldValidateMetaInfData(expectedPath);
-            Mockito.verify(genericMetaInfDataValidator2).validateMetaInfData(Mockito.any(), Mockito.eq(expectedPath));
+            Mockito.verify(metaInfPathValidator).validateMetaInfPath(expectedPath, Paths.get(""), false);
+            Mockito.verify(genericMetaInfDataValidator, Mockito.atLeastOnce()).shouldValidateMetaInfData(expectedPath, Paths.get(""));
+            Mockito.verify(genericMetaInfDataValidator).validateMetaInfData(Mockito.any(), Mockito.eq(expectedPath), Mockito.eq(Paths.get("")));
+            Mockito.verify(genericMetaInfDataValidator2, Mockito.atLeastOnce()).shouldValidateMetaInfData(expectedPath, Paths.get(""));
+            Mockito.verify(genericMetaInfDataValidator2).validateMetaInfData(Mockito.any(), Mockito.eq(expectedPath), Mockito.eq(Paths.get("")));
         }
     }
 
@@ -156,19 +157,19 @@ public class ValidationExecutorTest {
     public void testMetaInfFolder() throws URISyntaxException, IOException, SAXException {
         Collection<ValidationViolation> messages = validateFolder(executor, Paths.get(""), "vault/genericfile.txt", true);
         Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
-        Mockito.verify(metaInfPathValidator).validateMetaInfPath(Paths.get("vault", "genericfile.txt"), true);
+        Mockito.verify(metaInfPathValidator).validateMetaInfPath(Paths.get("vault", "genericfile.txt"), Paths.get(""), true);
     }
 
     @Test
     public void testGenericJcrData()
             throws URISyntaxException, IOException, SAXException, ParserConfigurationException, ConfigurationException {
-        Mockito.when(genericJcrDataValidator.shouldValidateJcrData(Mockito.any())).thenReturn(true);
+        Mockito.when(genericJcrDataValidator.shouldValidateJcrData(Mockito.any(), Mockito.any())).thenReturn(true);
         CapturingInputStreamFromArgumentAnswer<Collection<ValidationMessage>> answer = new CapturingInputStreamFromArgumentAnswer<>(StandardCharsets.US_ASCII, 0, Collections.singleton(new ValidationMessage(ValidationMessageSeverity.WARN, "error1")));
-        Mockito.when(genericJcrDataValidator.validateJcrData(Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer);
+        Mockito.when(genericJcrDataValidator.validateJcrData(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer);
         CapturingInputStreamFromArgumentAnswer<Void> answer2 = new CapturingInputStreamFromArgumentAnswer<>(StandardCharsets.US_ASCII, 0, null);
-        Mockito.when(genericJcrDataValidator2.shouldValidateJcrData(Mockito.any())).thenReturn(true);
-        Mockito.when(genericJcrDataValidator2.validateJcrData(Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer2);
-        Mockito.when(jcrPathValidator.validateJcrPath(Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
+        Mockito.when(genericJcrDataValidator2.shouldValidateJcrData(Mockito.any(), Mockito.any())).thenReturn(true);
+        Mockito.when(genericJcrDataValidator2.validateJcrData(Mockito.any(), Mockito.any(), Mockito.any(), Mockito.any())).thenAnswer(answer2);
+        Mockito.when(jcrPathValidator.validateJcrPath(Mockito.any(), Mockito.any(), Mockito.anyBoolean())).thenReturn(Collections.singleton(new ValidationMessage(ValidationMessageSeverity.ERROR, "patherror")));
         try (InputStream input = this.getClass().getResourceAsStream("/simple-package/jcr_root/apps/genericfile.xml")) {
             Collection<ValidationViolation> messages = validate(input, executor, Paths.get(""), "apps/genericfile.xml", false);
             assertViolation(messages, 
@@ -177,11 +178,11 @@ public class ValidationExecutorTest {
             Assert.assertEquals("Test", answer.getValue());
             Assert.assertEquals("Test", answer2.getValue());
             Path expectedPath = Paths.get("apps/genericfile.xml");
-            Mockito.verify(jcrPathValidator).validateJcrPath(expectedPath, false);
-            Mockito.verify(genericJcrDataValidator, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath);
-            Mockito.verify(genericJcrDataValidator).validateJcrData(Mockito.any(), Mockito.eq(expectedPath), Mockito.any());
-            Mockito.verify(genericJcrDataValidator2, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath);
-            Mockito.verify(genericJcrDataValidator2).validateJcrData(Mockito.any(), Mockito.eq(expectedPath), Mockito.any());
+            Mockito.verify(jcrPathValidator).validateJcrPath(expectedPath, Paths.get(""), false);
+            Mockito.verify(genericJcrDataValidator, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath, Paths.get(""));
+            Mockito.verify(genericJcrDataValidator).validateJcrData(Mockito.any(), Mockito.eq(expectedPath), Mockito.eq(Paths.get("")), Mockito.any());
+            Mockito.verify(genericJcrDataValidator2, Mockito.atLeastOnce()).shouldValidateJcrData(expectedPath, Paths.get(""));
+            Mockito.verify(genericJcrDataValidator2).validateJcrData(Mockito.any(), Mockito.eq(expectedPath), Mockito.eq(Paths.get("")), Mockito.any());
         }
     }
 
@@ -199,8 +200,8 @@ public class ValidationExecutorTest {
     public void testJcrRootFolder() throws URISyntaxException, IOException, SAXException {
         Collection<ValidationViolation> messages = validateFolder(executor, Paths.get(""), "apps.dir", false);
         Assert.assertThat(messages, AnyValidationViolationMatcher.noValidationInCollection());
-        Mockito.verify(jcrPathValidator).validateJcrPath(Paths.get("apps.dir"), true);
-        Mockito.verify(nodePathValidator).validate("/apps");
+        Mockito.verify(jcrPathValidator).validateJcrPath(Paths.get("apps.dir"), Paths.get(""), true);
+        Mockito.verify(nodePathValidator).validate(new NodeContextImpl("/apps", Paths.get("apps.dir"), Paths.get("")));
     }
 
     @Test
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationViolationTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationViolationTest.java
index 4bdc973a..277951a6 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationViolationTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/ValidationViolationTest.java
@@ -72,7 +72,7 @@ public class ValidationViolationTest {
         Assert.assertEquals("myid2", violation.getValidatorId());
         Assert.assertEquals(ValidationMessageSeverity.DEBUG, violation.getSeverity());
         Assert.assertEquals("message1", violation.getMessage());
-        Assert.assertEquals(Paths.get("base1","child1"), violation.getFilePath());
+        Assert.assertEquals(Paths.get("base1","child1"), violation.getAbsoluteFilePath());
         Assert.assertEquals("nodepath2", violation.getNodePath());
         Assert.assertEquals(10, violation.getLine());
         Assert.assertEquals(20, violation.getColumn());
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidatorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidatorTest.java
index 1ec3d879..886d0b9c 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidatorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/EmptyElementsValidatorTest.java
@@ -34,6 +34,7 @@ import org.apache.jackrabbit.vault.validation.ValidationExecutorTest;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
 import org.apache.jackrabbit.vault.validation.spi.impl.EmptyElementsValidator;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
@@ -58,26 +59,34 @@ public class EmptyElementsValidatorTest {
 
         // order node only (no other property)
         DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, null);
-        Assert.assertThat(validator.validate(node, "/apps/test/node1", Paths.get("node1"), false), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("/apps/test/node1", Paths.get("node1"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
         
         // another order node (to be covered by another file)
         node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, null);
-        Assert.assertThat(validator.validate(node, "/apps/test/node2", Paths.get("node2"), false), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("/apps/test/node2", Paths.get("node2"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
         
         // another order node only
         node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, null);
-        Assert.assertThat(validator.validate(node, "/apps/test/node3", Paths.get("node3"), false), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("/apps/test/node3", Paths.get("node3"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
         
         // no order node (due to props)
         node = new DocViewNode("jcr:root", "jcr:root", null, props, null, null);
-        Assert.assertThat(validator.validate(node, "/apps/test/node4", Paths.get("node4"), false), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("/apps/test/node4", Paths.get("node4"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
         
         // no order node (due to primary type)
         node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, "nt:unstructed");
-        Assert.assertThat(validator.validate(node, "/apps/test/node5", Paths.get("node45"), false), AnyValidationMessageMatcher.noValidationInCollection());
-        //
-        Assert.assertNull(validator.validate("/apps/test/node2"));
-        ValidationExecutorTest.assertViolation(validator.done(), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(EmptyElementsValidator.MESSAGE_EMPTY_NODES, "'/apps/test/node1' (in 'node1'), '/apps/test/node3' (in 'node3')")));
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("/apps/test/node5", Paths.get("node5"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
+        
+        // overwritten node 2 (plain file/folder)
+        Assert.assertNull(validator.validate(new NodeContextImpl("/apps/test/node2", Paths.get("apps", "test", "node.xml"), Paths.get("base"))));
+        
+        // empty node with name rep:policy (doesn't do any harm and is included in standard packages from exporter as well)
+        node = new DocViewNode("rep:policy", "rep:polucy", null, Collections.emptyMap(), null, null);
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("/apps/test/node6", Paths.get("node6"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
+        
+        ValidationExecutorTest.assertViolation(validator.done(), 
+                new ValidationMessage(ValidationMessageSeverity.ERROR, EmptyElementsValidator.MESSAGE_EMPTY_NODES, "/apps/test/node1", Paths.get("node1"), Paths.get(""), null),
+                new ValidationMessage(ValidationMessageSeverity.ERROR, EmptyElementsValidator.MESSAGE_EMPTY_NODES, "/apps/test/node3", Paths.get("node3"), Paths.get(""), null));
     }
 
     @Test
@@ -87,14 +96,14 @@ public class EmptyElementsValidatorTest {
 
         // primary node type set as well
         DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, "nt:unstructured");
-        Assert.assertThat(validator.validate(node, "somepath1", Paths.get("/some/path"), false), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("somepath1", Paths.get("/some/path"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
         
         // primary node type set with additional properties
         node = new DocViewNode("jcr:root", "jcr:root", null, props, null, "nt:unstructured");
-        Assert.assertThat(validator.validate(node, "somepath2", Paths.get("/some/path"), false), AnyValidationMessageMatcher.noValidationInCollection());
-        Assert.assertNull(validator.done());
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("somepath2", Paths.get("/some/path"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.done(), AnyValidationMessageMatcher.noValidationInCollection());
     }
-    
+
     @Test
     public void testWithEmptyElementsAndFolders() {
         Map<String, DocViewProperty> props = new HashMap<>();
@@ -102,10 +111,10 @@ public class EmptyElementsValidatorTest {
 
         // order node only (no other property)
         DocViewNode node = new DocViewNode("jcr:root", "jcr:root", null, Collections.emptyMap(), null, null);
-        Assert.assertThat(validator.validate(node, "/apps/test/node1", Paths.get("node1"), false), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(node, new NodeContextImpl("/apps/test/node1", Paths.get("node1"), Paths.get("")), false), AnyValidationMessageMatcher.noValidationInCollection());
         
         // folder below 
-        Assert.assertThat(validator.validate("/apps/test/node1"), AnyValidationMessageMatcher.noValidationInCollection());
-        Assert.assertNull(validator.done());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/test/node1", Paths.get("test"), Paths.get("base"))), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.done(), AnyValidationMessageMatcher.noValidationInCollection());;
     }
 }
diff --git a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorTest.java b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorTest.java
index eddbacf3..ce77ae53 100644
--- a/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorTest.java
+++ b/vault-validation/src/test/java/org/apache/jackrabbit/vault/validation/spi/impl/PackageTypeValidatorTest.java
@@ -34,12 +34,12 @@ import org.apache.jackrabbit.vault.validation.ValidationExecutorTest;
 import org.apache.jackrabbit.vault.validation.spi.ValidationContext;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessage;
 import org.apache.jackrabbit.vault.validation.spi.ValidationMessageSeverity;
-import org.apache.jackrabbit.vault.validation.spi.impl.PackageTypeValidator;
-import org.apache.jackrabbit.vault.validation.spi.impl.PackageTypeValidatorFactory;
+import org.apache.jackrabbit.vault.validation.spi.util.NodeContextImpl;
 import org.junit.Assert;
 import org.junit.Before;
 import org.junit.Test;
 import org.junit.runner.RunWith;
+import org.mockito.ArgumentMatchers;
 import org.mockito.Mock;
 import org.mockito.Mockito;
 import org.mockito.junit.MockitoJUnitRunner;
@@ -67,31 +67,32 @@ public class PackageTypeValidatorTest {
     @Before
     public void setUp() {
         Mockito.when(parentContainerContext.getProperties()).thenReturn(parentContainerProperties);
+        Mockito.when(filter.covers(ArgumentMatchers.anyString())).thenReturn(Boolean.TRUE);
     }
 
     @Test
     public void testNullPackageType() {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, null, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
-        Assert.assertThat(validator.validate("/apps/some/node"), AnyValidationMessageMatcher.noValidationInCollection());
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, null, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/some/node", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
         Assert.assertThat(validator.validate(filter), AnyValidationMessageMatcher.noValidationInCollection());
         ValidationExecutorTest.assertViolation(validator.validate(properties), new ValidationMessage(ValidationMessageSeverity.WARN, PackageTypeValidator.MESSAGE_NO_PACKAGE_TYPE_SET));
         // validate sub packages of type Content
-        PackageTypeValidator subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false,PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        PackageTypeValidator subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false,PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         ValidationExecutorTest.assertViolation(validator.validate(properties), new ValidationMessage(ValidationMessageSeverity.WARN, PackageTypeValidator.MESSAGE_NO_PACKAGE_TYPE_SET));
         // validate sub packages of type null
-        subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, null, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, null, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.CONTENT);
         Assert.assertThat(subPackageValidator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());
         // validate sub packages of type Application
-        subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.APPLICATION);
         Assert.assertThat(subPackageValidator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());
     }
 
     @Test
     public void testMixedPackageType() {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.ERROR, false, false, false,PackageType.MIXED, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
-        Assert.assertThat(validator.validate("/apps/some/node"), AnyValidationMessageMatcher.noValidationInCollection());
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.ERROR, false, false, false,PackageType.MIXED, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/some/node", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
         Assert.assertThat(validator.validate(filter), AnyValidationMessageMatcher.noValidationInCollection());
         ValidationExecutorTest.assertViolation(validator.validate(properties), new ValidationMessage(ValidationMessageSeverity.WARN, PackageTypeValidator.MESSAGE_NO_PACKAGE_TYPE_SET));
         // test mixed package type
@@ -99,31 +100,31 @@ public class PackageTypeValidatorTest {
         ValidationExecutorTest.assertViolation(validator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_LEGACY_TYPE, PackageType.MIXED.toString())));
         // validate sling:OsgiConfig node
         DocViewNode node = new DocViewNode("someconfigpid", "someconfigpid", null, Collections.emptyMap(), null, "sling:OsgiConfig");
-        Assert.assertThat(validator.validate("/apps/config/someconfigpid"), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/config/someconfigpid", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
         Assert.assertThat(validator.validate(node, "/apps/config/someconfigpid", Paths.get(""), true), AnyValidationMessageMatcher.noValidationInCollection());
         
         // validate sub packages of type Content
         Mockito.when(parentContainerProperties.getPackageType()).thenReturn(PackageType.MIXED);
-        PackageTypeValidator subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        PackageTypeValidator subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.CONTENT);
         Assert.assertThat(subPackageValidator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());
         // validate sub packages of type Application
-        subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.APPLICATION);
         Assert.assertThat(subPackageValidator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());
     }
 
     @Test
     public void testContentPackageType() {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/some/node"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/apps/some/node")));
-        ValidationExecutorTest.assertViolation(validator.validate("/apps"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/apps")));
-        ValidationExecutorTest.assertViolation(validator.validate("/libs/some/node"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/libs/some/node")));
-        ValidationExecutorTest.assertViolation(validator.validate("/libs"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/libs")));
-        Assert.assertThat(validator.validate("/content/is/allowed"), AnyValidationMessageMatcher.noValidationInCollection());
-        Assert.assertThat(validator.validate("/etc/packages/some/sub/package.zip"), AnyValidationMessageMatcher.noValidationInCollection());
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/apps/some/node", Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/apps/some/node")));
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/apps", Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/apps")));
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/libs/some/node", Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/libs/some/node")));
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/libs",  Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/libs")));
+        Assert.assertThat(validator.validate(new NodeContextImpl("/content/is/allowed", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/etc/packages/some/sub/package.zip", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
         
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/install/muybundle-123.jar"), 
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/apps/install/muybundle-123.jar", Paths.get(""), Paths.get(""))), 
                 new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_APP_CONTENT, PackageType.CONTENT, "/apps/install/muybundle-123.jar")),
                 new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.CONTENT, "/apps/install/muybundle-123.jar"))
                 );
@@ -132,47 +133,59 @@ public class PackageTypeValidatorTest {
         Assert.assertThat(validator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());
         Mockito.when(parentContainerProperties.getPackageType()).thenReturn(PackageType.CONTENT);
         // validate sub packages of type Content
-        PackageTypeValidator subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        PackageTypeValidator subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         Assert.assertThat(subPackageValidator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());
         // validate sling:OsgiConfig node
         DocViewNode node = new DocViewNode("someconfigpid", "someconfigpid", null, Collections.emptyMap(), null, "sling:OsgiConfig");
-        Assert.assertThat(validator.validate("/content/config/someconfigpid"), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/content/config/someconfigpid", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
         ValidationExecutorTest.assertViolation(
                 validator.validate(node, "/content/config/someconfigpid", Paths.get(""), true),
                 new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.CONTENT, "/content/config/someconfigpid")));
         
         // validate sub packages of type Application
-        subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.APPLICATION);
         ValidationExecutorTest.assertViolation(subPackageValidator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE, PackageType.CONTENT, PackageType.CONTENT, PackageType.APPLICATION)));
     }
 
     @Test
     public void testContainerPackageType() {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTAINER, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/some/node"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, PackageType.CONTAINER, "/apps/some/node")));
-        ValidationExecutorTest.assertViolation(validator.validate("/libs/some/node"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, PackageType.CONTAINER, "/libs/some/node")));
-        ValidationExecutorTest.assertViolation(validator.validate("/content/some/node"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, PackageType.CONTAINER, "/content/some/node")));
-        
-        Assert.assertThat(validator.validate("/apps/install.runmode/somebundle.jar"), AnyValidationMessageMatcher.noValidationInCollection());
-        Assert.assertThat(validator.validate("/etc/packages/some/sub/package.zip"), AnyValidationMessageMatcher.noValidationInCollection());
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTAINER, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/some/node", Paths.get("some", "file1"), Paths.get("base"))), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/libs/some/node", Paths.get("some", "file2"), Paths.get("base"))), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/content/some/node", Paths.get("some", "file3"), Paths.get("base"))), AnyValidationMessageMatcher.noValidationInCollection());
+        ValidationExecutorTest.assertViolation(validator.done(), 
+                new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, PackageType.CONTAINER), "/apps/some/node", Paths.get("some", "file1"), Paths.get("base"), null),
+                new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, PackageType.CONTAINER), "/libs/some/node", Paths.get("some", "file2"), Paths.get("base"), null),
+                new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, PackageType.CONTAINER), "/content/some/node", Paths.get("some", "file3"), Paths.get("base"), null)
+                );
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTAINER, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/install.runmode", Paths.get("runmode"), Paths.get("base"))), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/install.runmode/somebundle.jar", Paths.get("runmode", "somebundle.jar"), Paths.get("base"))), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/etc/packages/some/sub/package.zip", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
+        // this node is outside the allowed parents
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/install.runmode2", Paths.get("apps", "install", "runmode2"), Paths.get("base"))), AnyValidationMessageMatcher.noValidationInCollection());
         Assert.assertThat(validator.validate(filter), AnyValidationMessageMatcher.noValidationInCollection());
+        ValidationExecutorTest.assertViolation(validator.done(), 
+                new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_OSGI_BUNDLE_OR_CONFIG_OR_SUB_PACKAGE, PackageType.CONTAINER), "/apps/install.runmode2", Paths.get("apps", "install", "runmode2"), Paths.get("base"), null)
+        );
         
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTAINER, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.CONTAINER);
         Assert.assertThat(validator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());
         // validate sub packages of type Content
         Mockito.when(parentContainerProperties.getPackageType()).thenReturn(PackageType.CONTAINER);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.CONTENT);
-        PackageTypeValidator subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        PackageTypeValidator subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         ValidationExecutorTest.assertViolation(subPackageValidator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_UNSUPPORTED_SUB_PACKAGE_OF_TYPE, PackageType.CONTAINER, PackageType.APPLICATION, PackageType.CONTENT)));
         // validate sub packages of type Application
-        subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.APPLICATION);
         Assert.assertThat(subPackageValidator.validate(properties), AnyValidationMessageMatcher.noValidationInCollection());
     
         // validate sling:OsgiConfig node
         DocViewNode node = new DocViewNode("someconfigpid", "someconfigpid", null, Collections.emptyMap(), null, "sling:OsgiConfig");
-        Assert.assertThat(validator.validate("/apps/config/someconfigpid"), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/config/someconfigpid", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
         Assert.assertThat(validator.validate(node, "/apps/config/someconfigpid", Paths.get(""), true), AnyValidationMessageMatcher.noValidationInCollection());
         
         // make sure no dependencies
@@ -183,17 +196,17 @@ public class PackageTypeValidatorTest {
 
     @Test
     public void testApplicationPackageType() throws IOException, ConfigurationException {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
-        Assert.assertThat(validator.validate("/apps/some/script"), AnyValidationMessageMatcher.noValidationInCollection());
-        Assert.assertThat(validator.validate("/libs"), AnyValidationMessageMatcher.noValidationInCollection());
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/some/script", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/libs",  Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
         
-        ValidationExecutorTest.assertViolation(validator.validate("/content/some/node"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, "/content/some/node")));
-        ValidationExecutorTest.assertViolation(validator.validate("/etc/something"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, "/etc/something")));
-        ValidationExecutorTest.assertViolation(validator.validate("/conf/something"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, "/conf/something")));
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/content/some/node",  Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, "/content/some/node")));
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/etc/something",  Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, "/etc/something")));
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/conf/something",  Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_NO_APP_CONTENT_FOUND, PackageType.APPLICATION, "/conf/something")));
         
         // no bundles/sub packages
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/install/mybundle.jar"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.APPLICATION, "/apps/install/mybundle.jar")));
-        ValidationExecutorTest.assertViolation(validator.validate("/apps/install/config.cfg"), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.APPLICATION, "/apps/install/config.cfg")));
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/apps/install/mybundle.jar", Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.APPLICATION, "/apps/install/mybundle.jar")));
+        ValidationExecutorTest.assertViolation(validator.validate(new NodeContextImpl("/apps/install/config.cfg", Paths.get(""), Paths.get(""))), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.APPLICATION, "/apps/install/config.cfg")));
         
         // no hooks
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.APPLICATION);
@@ -217,7 +230,7 @@ public class PackageTypeValidatorTest {
         
         // validate sling:OsgiConfig node
         DocViewNode node = new DocViewNode("someconfigpid", "someconfigpid", null, Collections.emptyMap(), null, "sling:OsgiConfig");
-        Assert.assertThat(validator.validate("/apps/config/someconfigpid"), AnyValidationMessageMatcher.noValidationInCollection());
+        Assert.assertThat(validator.validate(new NodeContextImpl("/apps/config/someconfigpid", Paths.get(""), Paths.get(""))), AnyValidationMessageMatcher.noValidationInCollection());
         ValidationExecutorTest.assertViolation(
                 validator.validate(node, "/apps/config/someconfigpid", Paths.get(""), true),
                 new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_OSGI_BUNDLE_OR_CONFIG, PackageType.APPLICATION, "/apps/config/someconfigpid")));
@@ -225,10 +238,10 @@ public class PackageTypeValidatorTest {
         // validate sub packages of type Content
         Mockito.when(parentContainerProperties.getPackageType()).thenReturn(PackageType.APPLICATION);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.CONTENT);
-        PackageTypeValidator subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        PackageTypeValidator subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         ValidationExecutorTest.assertViolation(subPackageValidator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_UNSUPPORTED_SUB_PACKAGE, PackageType.APPLICATION)));
         // validate sub packages of type Application
-        subPackageValidator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
+        subPackageValidator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, parentContainerContext);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.APPLICATION);
         Mockito.when(properties.getExternalHooks()).thenReturn(Collections.emptyMap());
         ValidationExecutorTest.assertViolation(subPackageValidator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_UNSUPPORTED_SUB_PACKAGE, PackageType.APPLICATION)));
@@ -236,7 +249,7 @@ public class PackageTypeValidatorTest {
 
     @Test
     public void testApplicationPackageTypeWithAllowedComplexFilters() throws IOException, ConfigurationException {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, true, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, true, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
         DefaultWorkspaceFilter filter = new DefaultWorkspaceFilter();
         // with filters with include/exclude
         try (InputStream input = this.getClass().getResourceAsStream("/filter.xml")) {
@@ -247,7 +260,7 @@ public class PackageTypeValidatorTest {
 
     @Test
     public void testMutableContentProhibited() {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.INFO, ValidationMessageSeverity.INFO, true, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.INFO, ValidationMessageSeverity.INFO, true, false, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.MIXED);
         ValidationExecutorTest.assertViolation(validator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_PROHIBITED_MUTABLE_PACKAGE_TYPE, PackageType.MIXED)));
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.CONTENT);
@@ -260,7 +273,7 @@ public class PackageTypeValidatorTest {
 
     @Test
     public void testImmutableContentProhibited() {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.INFO, ValidationMessageSeverity.INFO, false, true, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.INFO, ValidationMessageSeverity.INFO, false, true, false, PackageType.APPLICATION, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.MIXED);
         ValidationExecutorTest.assertViolation(validator.validate(properties), new ValidationMessage(ValidationMessageSeverity.ERROR, String.format(PackageTypeValidator.MESSAGE_PROHIBITED_IMMUTABLE_PACKAGE_TYPE, PackageType.MIXED)));
         Mockito.when(properties.getPackageType()).thenReturn(PackageType.CONTENT);
@@ -273,7 +286,7 @@ public class PackageTypeValidatorTest {
 
     @Test
     public void testIsOsgiBundleOrConfigurationFile() {
-        validator = new PackageTypeValidator(ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
+        validator = new PackageTypeValidator(filter, ValidationMessageSeverity.ERROR, ValidationMessageSeverity.WARN, ValidationMessageSeverity.INFO, false, false, false, PackageType.CONTENT, PackageTypeValidatorFactory.DEFAULT_JCR_INSTALLER_NODE_PATH_REGEX, PackageTypeValidatorFactory.DEFAULT_ADDITIONAL_JCR_INSTALLER_FILE_NODE_PATH_REGEX, null);
         Assert.assertTrue(validator.isOsgiBundleOrConfiguration("/apps/install/mybundle-123.jar", true));
         Assert.assertTrue(validator.isOsgiBundleOrConfiguration("/apps/config/mmyconfig-123.cfg.json", true));
         Assert.assertTrue(validator.isOsgiBundleOrConfiguration("/apps/config/mmyconfig-123.cfg", true));
