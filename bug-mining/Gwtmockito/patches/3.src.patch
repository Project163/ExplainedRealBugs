diff --git a/gwtmockito/src/main/java/com/google/gwtmockito/GwtMockito.java b/gwtmockito/src/main/java/com/google/gwtmockito/GwtMockito.java
index 8c85320..08e337e 100644
--- a/gwtmockito/src/main/java/com/google/gwtmockito/GwtMockito.java
+++ b/gwtmockito/src/main/java/com/google/gwtmockito/GwtMockito.java
@@ -288,36 +288,27 @@ public class GwtMockito {
 
     @Override
     @SuppressWarnings("unchecked") // safe since we check whether the type is assignable
-    public <T> T create(Class<?> type) {
-      // Handle RemoteServices specially - GWT.create'ing them should return the Async version
-      if (RemoteService.class.isAssignableFrom(type)) {
-        Class<?> asyncType;
-        try {
-          asyncType = Class.forName(type.getCanonicalName() + "Async");
-        } catch (ClassNotFoundException e) {
-          throw new IllegalArgumentException(
-              type.getCanonicalName() + " does not have a corresponding async interface", e);
-        }
-        if (registeredMocks.containsKey(asyncType)) {
-          return (T) registeredMocks.get(asyncType);
-        } else {
-          return (T) mock(asyncType);
-        }
-      }
+    public <T> T create(Class<?> createdType) {
+      // If we're creating a RemoteService, assume that the result of GWT.create is being assigned
+      // to the async version of that service. Otherwise, assume it's being assigned to the same
+      // type we're creating.
+      Class<?> assignedType = RemoteService.class.isAssignableFrom(createdType)
+          ? getAsyncType((Class<? extends RemoteService>) createdType)
+          : createdType;
 
-      // Otherwise, first check if we have a GwtMock for this exact type and use it if so.
-      if (registeredMocks.containsKey(type)) {
-        return (T) registeredMocks.get(type);
+      // First check if we have a GwtMock for this exact being assigned to and use it if so.
+      if (registeredMocks.containsKey(assignedType)) {
+        return (T) registeredMocks.get(assignedType);
       }
 
-      // Next check if we have a fake provider that can provide a fake for this type.
-      T fake = (T) getFakeFromProviderMap(type, registeredProviders);
+      // Next check if we have a fake provider that can provide a fake for the type being created.
+      T fake = (T) getFakeFromProviderMap(createdType, registeredProviders);
       if (fake != null) {
         return fake;
       }
 
-      // If nothing has been registered, just return a new mock object to avoid NPEs.
-      return (T) mock(type, new ReturnsCustomMocks());
+      // If nothing has been registered, just return a new mock for the type being assigned.
+      return (T) mock(assignedType, new ReturnsCustomMocks());
     }
 
     @Override
@@ -337,5 +328,18 @@ public class GwtMockito {
         e.printStackTrace();
       }
     }
+
+    /** Returns the corresponding async service type for the given remote service type. */
+    private Class<?> getAsyncType(Class<? extends RemoteService> type) {
+      Class<?> asyncType;
+      try {
+        asyncType = Class.forName(type.getCanonicalName() + "Async");
+      } catch (ClassNotFoundException e) {
+        throw new IllegalArgumentException(
+            type.getCanonicalName() + " does not have a corresponding async interface", e);
+      }
+      return asyncType;
+    }
+
   }
 }
diff --git a/gwtmockito/src/test/java/com/google/gwtmockito/rpc/GwtMockitoRpcTest.java b/gwtmockito/src/test/java/com/google/gwtmockito/rpc/GwtMockitoRpcTest.java
index 4c6f5e6..0e80562 100644
--- a/gwtmockito/src/test/java/com/google/gwtmockito/rpc/GwtMockitoRpcTest.java
+++ b/gwtmockito/src/test/java/com/google/gwtmockito/rpc/GwtMockitoRpcTest.java
@@ -19,6 +19,7 @@ import static com.google.gwtmockito.AsyncAnswers.returnFailure;
 import static com.google.gwtmockito.AsyncAnswers.returnSuccess;
 import static org.mockito.Matchers.any;
 import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
 import static org.mockito.Mockito.verify;
 
 import com.google.gwt.core.shared.GWT;
@@ -27,7 +28,9 @@ import com.google.gwt.user.client.rpc.AsyncCallback;
 import com.google.gwt.user.client.ui.HasText;
 import com.google.gwt.user.client.ui.Label;
 import com.google.gwtmockito.GwtMock;
+import com.google.gwtmockito.GwtMockito;
 import com.google.gwtmockito.GwtMockitoTestRunner;
+import com.google.gwtmockito.fakes.FakeProvider;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
@@ -78,10 +81,8 @@ public class GwtMockitoRpcTest {
   @GwtMock TestRemoteServiceAsync service;
 
   @Test
-  @SuppressWarnings("unchecked")
   public void shouldAllowStubbedRpcSuccess() throws Exception {
-    doAnswer(returnSuccess("success!"))
-        .when(service).doRpc(any(String.class), any(AsyncCallback.class));
+    doAnswer(returnSuccess("success!")).when(service).doRpc(any(String.class), anyAsyncCallback());
 
     MyWidget widget = new MyWidget();
 
@@ -89,10 +90,9 @@ public class GwtMockitoRpcTest {
   }
 
   @Test
-  @SuppressWarnings("unchecked")
   public void shouldAllowStubbedRpcFailure() throws Exception {
     doAnswer(returnFailure(new IllegalArgumentException("error!")))
-        .when(service).doRpc(any(String.class), any(AsyncCallback.class));
+        .when(service).doRpc(any(String.class), anyAsyncCallback());
 
     MyWidget widget = new MyWidget();
 
@@ -100,10 +100,8 @@ public class GwtMockitoRpcTest {
   }
 
   @Test
-  @SuppressWarnings("unchecked")
   public void shouldAllowStubbedRpcSuccessWithoutArgs() throws Exception {
-    doAnswer(returnSuccess("success!"))
-        .when(service).doRpcWithoutArgs(any(AsyncCallback.class));
+    doAnswer(returnSuccess("success!")).when(service).doRpcWithoutArgs(anyAsyncCallback());
 
     MyWidgetWithoutArgs widget = new MyWidgetWithoutArgs();
 
@@ -111,13 +109,36 @@ public class GwtMockitoRpcTest {
   }
 
   @Test
-  @SuppressWarnings("unchecked")
   public void shouldAllowStubbedRpcFailureWithoutArgs() throws Exception {
     doAnswer(returnFailure(new IllegalArgumentException("error!")))
-        .when(service).doRpcWithoutArgs(any(AsyncCallback.class));
+        .when(service).doRpcWithoutArgs(anyAsyncCallback());
 
     MyWidgetWithoutArgs widget = new MyWidgetWithoutArgs();
 
     verify(widget.message).setText("error!");
   }
+
+  @Test
+  public void gwtMockShouldTakePriorityOverFakes() {
+    doAnswer(returnSuccess("mocked")).when(service).doRpcWithoutArgs(anyAsyncCallback());
+
+    GwtMockito.useProviderForType(
+        TestRemoteService.class,
+        new FakeProvider<TestRemoteServiceAsync>() {
+          @Override
+          public TestRemoteServiceAsync getFake(Class<?> type) {
+            TestRemoteServiceAsync mock = mock(TestRemoteServiceAsync.class);
+            doAnswer(returnSuccess("faked")).when(mock).doRpcWithoutArgs(anyAsyncCallback());
+            return mock;
+          }
+        });
+    MyWidgetWithoutArgs widget = new MyWidgetWithoutArgs();
+
+    verify(widget.message).setText("mocked");
+  }
+
+  @SuppressWarnings("unchecked")
+  private AsyncCallback<String> anyAsyncCallback() {
+    return any(AsyncCallback.class);
+  }
 }
diff --git a/gwtmockito/src/test/java/com/google/gwtmockito/rpc/GwtMockitoRpcWithoutGwtMockTest.java b/gwtmockito/src/test/java/com/google/gwtmockito/rpc/GwtMockitoRpcWithoutGwtMockTest.java
new file mode 100644
index 0000000..8cdc1bd
--- /dev/null
+++ b/gwtmockito/src/test/java/com/google/gwtmockito/rpc/GwtMockitoRpcWithoutGwtMockTest.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright 2013 Google Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License"); you may not
+ * use this file except in compliance with the License. You may obtain a copy of
+ * the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations under
+ * the License.
+ */
+package com.google.gwtmockito.rpc;
+
+import static com.google.gwtmockito.AsyncAnswers.returnSuccess;
+import static org.mockito.Matchers.any;
+import static org.mockito.Matchers.anyString;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.verify;
+
+import com.google.gwt.core.shared.GWT;
+import com.google.gwt.uibinder.client.UiField;
+import com.google.gwt.user.client.rpc.AsyncCallback;
+import com.google.gwt.user.client.ui.HasText;
+import com.google.gwt.user.client.ui.Label;
+import com.google.gwtmockito.GwtMockito;
+import com.google.gwtmockito.GwtMockitoTestRunner;
+import com.google.gwtmockito.fakes.FakeProvider;
+
+import org.junit.Test;
+import org.junit.runner.RunWith;
+
+/**
+ * Tests that GwtMockito works when mocking gwt-rpc RemoteServices without a corresponding
+ * GwtMock-annoted field.
+ */
+@RunWith(GwtMockitoTestRunner.class)
+public class GwtMockitoRpcWithoutGwtMockTest {
+
+  private static class MyWidget {
+    @UiField HasText message = GWT.create(Label.class);
+    private final TestRemoteServiceAsync service = GWT.create(TestRemoteService.class);
+
+    MyWidget() {
+      service.doRpcWithoutArgs(new AsyncCallback<String>() {
+        @Override
+        public void onSuccess(String result) {
+          message.setText(result);
+        }
+
+        @Override
+        public void onFailure(Throwable caught) {
+          message.setText(caught.getMessage());
+        }
+      });
+    }
+  }
+
+  @Test
+  public void shouldNeverCallBackIfNoFake() throws Exception {
+    MyWidget widget = new MyWidget();
+
+    verify(widget.message, never()).setText(anyString());
+  }
+
+  @Test
+  public void shouldUseFakeIfProvided() {
+    GwtMockito.useProviderForType(
+        TestRemoteService.class,
+        new FakeProvider<TestRemoteServiceAsync>() {
+          @Override
+          public TestRemoteServiceAsync getFake(Class<?> type) {
+            TestRemoteServiceAsync mock = mock(TestRemoteServiceAsync.class);
+            doAnswer(returnSuccess("faked")).when(mock).doRpcWithoutArgs(anyAsyncCallback());
+            return mock;
+          }
+        });
+    MyWidget widget = new MyWidget();
+
+    verify(widget.message).setText("faked");
+  }
+
+  @SuppressWarnings("unchecked")
+  private AsyncCallback<String> anyAsyncCallback() {
+    return any(AsyncCallback.class);
+  }
+}
