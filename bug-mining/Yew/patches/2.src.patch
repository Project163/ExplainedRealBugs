diff --git a/examples/showcase/Cargo.toml b/examples/showcase/Cargo.toml
index a1d82282..7bfa9a82 100644
--- a/examples/showcase/Cargo.toml
+++ b/examples/showcase/Cargo.toml
@@ -11,6 +11,7 @@ custom_components = { path = "sub/custom_components" }
 dashboard = { path = "sub/dashboard" }
 fragments = { path = "sub/fragments" }
 game_of_life = { path = "sub/game_of_life" }
+inner_html = { path = "sub/inner_html" }
 large_table = { path = "sub/large_table" }
 mount_point = { path = "sub/mount_point" }
 npm_and_rest = { path = "sub/npm_and_rest" }
diff --git a/examples/showcase/src/main.rs b/examples/showcase/src/main.rs
index 12c1114b..5a70c4a6 100644
--- a/examples/showcase/src/main.rs
+++ b/examples/showcase/src/main.rs
@@ -8,6 +8,7 @@ extern crate custom_components;
 extern crate dashboard;
 extern crate fragments;
 extern crate game_of_life;
+extern crate inner_html;
 extern crate large_table;
 extern crate mount_point;
 extern crate npm_and_rest;
@@ -30,6 +31,7 @@ use custom_components::Model as CustomComponents;
 use dashboard::Model as Dashboard;
 use fragments::Model as Fragments;
 use game_of_life::GameOfLife;
+use inner_html::Model as InnerHtml;
 use large_table::Model as LargeTable;
 use mount_point::Model as MountPoint;
 use npm_and_rest::Model as NpmAndRest;
@@ -127,6 +129,7 @@ enum Scene {
     Dashboard,
     Fragments,
     GameOfLife,
+    InnerHtml,
     LargeTable,
     MountPoint,
     NpmAndRest,
@@ -169,6 +172,7 @@ impl Renderable<Context, Scene> for Scene {
             <button onclick=|_| Msg::SwitchTo(Scene::Dashboard),>{ "Dashboard" }</button>
             <button onclick=|_| Msg::SwitchTo(Scene::Fragments),>{ "Fragments" }</button>
             <button onclick=|_| Msg::SwitchTo(Scene::GameOfLife),>{ "GameOfLife" }</button>
+            <button onclick=|_| Msg::SwitchTo(Scene::InnerHtml),>{ "InnerHtml" }</button>
             <button onclick=|_| Msg::SwitchTo(Scene::LargeTable),>{ "LargeTable" }</button>
             <button onclick=|_| Msg::SwitchTo(Scene::MountPoint),>{ "MountPoint" }</button>
             <button onclick=|_| Msg::SwitchTo(Scene::NpmAndRest),>{ "NpmAndRest" }</button>
@@ -219,6 +223,11 @@ impl Scene {
                     <GameOfLife: />
                 }
             }
+            Scene::InnerHtml => {
+                html! {
+                    <InnerHtml: />
+                }
+            }
             Scene::LargeTable => {
                 html! {
                     <LargeTable: />
diff --git a/examples/showcase/sub/inner_html/Cargo.toml b/examples/showcase/sub/inner_html/Cargo.toml
new file mode 100644
index 00000000..91e54b6c
--- /dev/null
+++ b/examples/showcase/sub/inner_html/Cargo.toml
@@ -0,0 +1,8 @@
+[package]
+name = "inner_html"
+version = "0.1.0"
+authors = ["Garrett Berg <vitiral@gmail.com>"]
+
+[dependencies]
+stdweb = "0.4.2"
+yew = { path = "../../../.." }
diff --git a/examples/showcase/sub/inner_html/src/lib.rs b/examples/showcase/sub/inner_html/src/lib.rs
new file mode 100644
index 00000000..364ed4e5
--- /dev/null
+++ b/examples/showcase/sub/inner_html/src/lib.rs
@@ -0,0 +1,87 @@
+#![recursion_limit="512"]
+#[macro_use]
+extern crate stdweb;
+extern crate yew;
+
+use yew::prelude::*;
+use yew::services::console::ConsoleService;
+
+use stdweb::web::Node;
+use stdweb::unstable::TryFrom;
+use yew::virtual_dom::VNode;
+
+pub struct Model {
+    pub value: i64,
+}
+
+pub enum Msg {
+    Increment,
+    Decrement,
+    None,
+    Bulk(Vec<Msg>),
+}
+
+impl<CTX> Component<CTX> for Model
+where
+    CTX: AsMut<ConsoleService>,
+{
+    type Msg = Msg;
+    type Properties = ();
+
+    fn create(_: Self::Properties, _context: &mut Env<CTX, Self>) -> Self {
+        Model {
+            value: 0,
+        }
+    }
+
+    fn update(&mut self, msg: Self::Msg, context: &mut Env<CTX, Self>) -> ShouldRender {
+        match msg {
+            Msg::Increment => {
+                self.value = self.value + 1;
+                context.as_mut().log("plus one");
+            }
+            Msg::Decrement => {
+                self.value = self.value - 1;
+                context.as_mut().log("minus one");
+            }
+            Msg::Bulk(list) => for msg in list {
+                self.update(msg, context);
+                context.as_mut().log("Bulk action");
+            },
+            Msg::None => {
+                context.as_mut().log("No action");
+                return false;
+            }
+        }
+        true
+    }
+}
+
+
+const SVG: &str = r#"
+<h2>Inline SVG or <i>any</i> HTML:</h2>
+<svg height="250" width="500">
+  <polygon points="220,10 300,210 170,250 123,234" style="fill:lime;stroke:purple;stroke-width:1" />
+    Sorry, your browser does not support inline SVG.
+</svg>
+"#;
+
+impl<CTX> Renderable<CTX, Model> for Model
+where
+    CTX: AsMut<ConsoleService> + 'static,
+
+{
+    fn view(&self) -> Html<CTX, Self> {
+        let js_svg = js! {
+            var div = document.createElement("div");
+            div.innerHTML = @{SVG.to_string()};
+            console.log(div);
+            return div;
+        };
+        eprintln!("js_svg: {:?}", js_svg);
+        let node = Node::try_from(js_svg).expect("convert js_svg");
+        let vnode = VNode::VRef(node);
+        eprintln!("svg: {:?}", vnode);
+        vnode
+    }
+}
diff --git a/examples/showcase/sub/inner_html/src/main.rs b/examples/showcase/sub/inner_html/src/main.rs
new file mode 100644
index 00000000..ba4d729b
--- /dev/null
+++ b/examples/showcase/sub/inner_html/src/main.rs
@@ -0,0 +1,29 @@
+#![recursion_limit="512"]
+extern crate stdweb;
+extern crate yew;
+extern crate inner_html;
+
+use yew::prelude::*;
+use yew::services::console::ConsoleService;
+
+use inner_html::Model;
+
+pub struct Context {
+    console: ConsoleService,
+}
+
+impl AsMut<ConsoleService> for Context {
+    fn as_mut(&mut self) -> &mut ConsoleService {
+        &mut self.console
+    }
+}
+
+fn main() {
+    yew::initialize();
+    let context = Context {
+        console: ConsoleService,
+    };
+    let app: App<_, Model> = App::new(context);
+    app.mount_to_body();
+    yew::run_loop();
+}
diff --git a/src/virtual_dom/mod.rs b/src/virtual_dom/mod.rs
index 1d261522..b7832278 100644
--- a/src/virtual_dom/mod.rs
+++ b/src/virtual_dom/mod.rs
@@ -82,16 +82,30 @@ pub trait VDiff {
 
     /// Scoped diff apply to other tree.
     ///
+    /// Virtual rendering for the node. It uses parent node and existing children (virtual and DOM)
+    /// to check the difference and apply patches to the actual DOM represenatation.
+    ///
+    /// Parameters:
+    /// - `parent`: the parent node in the DOM.
+    /// - `precursor`: the "previous node" in a list of nodes, used to efficiently
+    ///   find where to put the node.
+    /// - `ancestor`: the node that this node will be replacing in the DOM.
+    ///   This method will _always_ remove the `ancestor` from the `parent`.
+    /// - `env`: the `ScopeEnv`.
+    ///
     /// ### Internal Behavior Notice:
     ///
     /// Note that these modify the DOM by modifying the reference that _already_ exists
-    /// on the `ancestor`. If `self.reference` exists (which it _shouldn't_) it will be
-    /// **completely ignored**.
+    /// on the `ancestor`. If `self.reference` exists (which it _shouldn't_) this method
+    /// will panic.
+    ///
+    /// The exception to this is obviously `VRef` which simply uses the inner `Node` directly
+    /// (always removes the `Node` that exists).
     fn apply(
         &mut self,
         parent: &Node,
         precursor: Option<&Node>,
-        opposite: Option<VNode<Self::Context, Self::Component>>,
+        ancestor: Option<VNode<Self::Context, Self::Component>>,
         scope: ScopeEnv<Self::Context, Self::Component>,
     ) -> Option<Node>;
 }
diff --git a/src/virtual_dom/vnode.rs b/src/virtual_dom/vnode.rs
index a327c6f3..fbf2eaa3 100644
--- a/src/virtual_dom/vnode.rs
+++ b/src/virtual_dom/vnode.rs
@@ -41,23 +41,32 @@ impl<CTX: 'static, COMP: Component<CTX>> VDiff for VNode<CTX, COMP> {
         }
     }
 
-    /// Virtual rendering for the node. It uses parent node and existend children (virtual and DOM)
-    /// to check the difference and apply patches to the actual DOM represenatation.
     fn apply(
         &mut self,
         parent: &Node,
         precursor: Option<&Node>,
-        opposite: Option<VNode<Self::Context, Self::Component>>,
+        ancestor: Option<VNode<Self::Context, Self::Component>>,
         env: ScopeEnv<Self::Context, Self::Component>,
     ) -> Option<Node> {
         match *self {
-            VNode::VTag(ref mut vtag) => vtag.apply(parent, precursor, opposite, env),
-            VNode::VText(ref mut vtext) => vtext.apply(parent, precursor, opposite, env),
-            VNode::VComp(ref mut vcomp) => vcomp.apply(parent, precursor, opposite, env),
-            VNode::VList(ref mut vlist) => vlist.apply(parent, precursor, opposite, env),
-            VNode::VRef(_) => {
-                // TODO use it for rendering any tag
-                unimplemented!("node can't be rendered now");
+            VNode::VTag(ref mut vtag) => vtag.apply(parent, precursor, ancestor, env),
+            VNode::VText(ref mut vtext) => vtext.apply(parent, precursor, ancestor, env),
+            VNode::VComp(ref mut vcomp) => vcomp.apply(parent, precursor, ancestor, env),
+            VNode::VList(ref mut vlist) => vlist.apply(parent, precursor, ancestor, env),
+            VNode::VRef(ref mut node) => {
+                let sibling = match ancestor {
+                    Some(n) => n.remove(parent),
+                    None => None,
+                };
+                if let Some(sibling) = sibling {
+                    parent
+                        .insert_before(node, &sibling)
+                        .expect("can't insert element before sibling");
+                } else {
+                    parent.append_child(node);
+                }
+
+                Some(node.to_owned())
             }
         }
     }
