diff --git a/packages/yew-agent/src/scope_ext.rs b/packages/yew-agent/src/scope_ext.rs
index 6120062f..eb36dc34 100644
--- a/packages/yew-agent/src/scope_ext.rs
+++ b/packages/yew-agent/src/scope_ext.rs
@@ -99,7 +99,7 @@ where
         W: Worker + 'static,
     {
         let inner = self
-            .context::<WorkerProviderState<W>>((|_| {}).into())
+            .context::<Rc<WorkerProviderState<W>>>((|_| {}).into())
             .expect_throw("failed to bridge to agent.")
             .0
             .create_bridge(callback);
diff --git a/packages/yew-agent/src/worker/hooks.rs b/packages/yew-agent/src/worker/hooks.rs
index 19745e64..fbe7d309 100644
--- a/packages/yew-agent/src/worker/hooks.rs
+++ b/packages/yew-agent/src/worker/hooks.rs
@@ -15,7 +15,7 @@ pub struct UseWorkerBridgeHandle<T>
 where
     T: Worker,
 {
-    inner: WorkerBridge<T>,
+    inner: Rc<WorkerBridge<T>>,
     ctr: UseReducerDispatcher<BridgeIdState>,
 }
 
@@ -84,7 +84,7 @@ where
 {
     let ctr = use_reducer(BridgeIdState::default);
 
-    let worker_state = use_context::<WorkerProviderState<T>>()
+    let worker_state = use_context::<Rc<WorkerProviderState<T>>>()
         .expect_throw("cannot find a provider for current agent.");
 
     let on_output = Rc::new(on_output);
@@ -106,7 +106,7 @@ where
     });
 
     UseWorkerBridgeHandle {
-        inner: (*bridge).clone(),
+        inner: bridge,
         ctr: ctr.dispatcher(),
     }
 }
diff --git a/packages/yew-agent/src/worker/provider.rs b/packages/yew-agent/src/worker/provider.rs
index b452729d..229acc24 100644
--- a/packages/yew-agent/src/worker/provider.rs
+++ b/packages/yew-agent/src/worker/provider.rs
@@ -46,7 +46,7 @@ where
     id: usize,
     spawn_bridge_fn: Rc<dyn Fn() -> WorkerBridge<W>>,
     reach: Reach,
-    held_bridge: Rc<RefCell<Option<WorkerBridge<W>>>>,
+    held_bridge: RefCell<Option<Rc<WorkerBridge<W>>>>,
 }
 
 impl<W> fmt::Debug for WorkerProviderState<W>
@@ -63,13 +63,13 @@ where
     W: Worker,
     W::Output: 'static,
 {
-    fn get_held_bridge(&self) -> WorkerBridge<W> {
+    fn get_held_bridge(&self) -> Rc<WorkerBridge<W>> {
         let mut held_bridge = self.held_bridge.borrow_mut();
 
         match held_bridge.as_mut() {
             Some(m) => m.clone(),
             None => {
-                let bridge = (self.spawn_bridge_fn)();
+                let bridge = Rc::new((self.spawn_bridge_fn)());
                 *held_bridge = Some(bridge.clone());
                 bridge
             }
@@ -88,20 +88,6 @@ where
     }
 }
 
-impl<W> Clone for WorkerProviderState<W>
-where
-    W: Worker,
-{
-    fn clone(&self) -> Self {
-        Self {
-            id: self.id,
-            spawn_bridge_fn: self.spawn_bridge_fn.clone(),
-            reach: self.reach,
-            held_bridge: self.held_bridge.clone(),
-        }
-    }
-}
-
 impl<W> PartialEq for WorkerProviderState<W>
 where
     W: Worker,
@@ -141,7 +127,7 @@ where
                 id: get_next_id(),
                 spawn_bridge_fn,
                 reach: *reach,
-                held_bridge: Rc::default(),
+                held_bridge: Default::default(),
             };
 
             if *reach == Reach::Public && !*lazy {
@@ -152,8 +138,8 @@ where
     };
 
     html! {
-        <ContextProvider<WorkerProviderState<W>> context={(*state).clone()}>
+        <ContextProvider<Rc<WorkerProviderState<W>>> context={state.clone()}>
             {children}
-        </ContextProvider<WorkerProviderState<W>>>
+        </ContextProvider<Rc<WorkerProviderState<W>>>>
     }
 }
