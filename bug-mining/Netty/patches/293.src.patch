diff --git a/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
index 6ad3da0bf4..99eec5f3cb 100644
--- a/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
+++ b/codec/src/main/java/io/netty/handler/codec/compression/Snappy.java
@@ -16,7 +16,14 @@
 package io.netty.handler.codec.compression;
 
 import io.netty.buffer.ByteBuf;
+import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.internal.MathUtil;
+import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.util.Arrays;
+import java.util.Locale;
 
 /**
  * Uncompresses an input {@link ByteBuf} encoded with Snappy compression into an
@@ -26,6 +33,8 @@ import io.netty.util.internal.MathUtil;
  */
 public final class Snappy {
 
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(Snappy.class);
+
     private static final int MAX_HT_SIZE = 1 << 14;
     private static final int MIN_COMPRESSIBLE_BYTES = 15;
 
@@ -39,6 +48,25 @@ public final class Snappy {
     private static final int COPY_2_BYTE_OFFSET = 2;
     private static final int COPY_4_BYTE_OFFSET = 3;
 
+    // Hash table used to compress, shared between subsequent call to .encode()
+    private static final FastThreadLocal<short[]> HASH_TABLE = new FastThreadLocal<short[]>();
+
+    private static final boolean DEFAULT_REUSE_HASHTABLE =
+            SystemPropertyUtil.getBoolean("io.netty.handler.codec.compression.snappy.reuseHashTable", false);
+
+    public Snappy() {
+        this(DEFAULT_REUSE_HASHTABLE);
+    }
+
+    Snappy(boolean reuseHashtable) {
+        this.reuseHashtable = reuseHashtable;
+    }
+
+    public static Snappy withHashTableReuse() {
+        return new Snappy(true);
+    }
+
+    private final boolean reuseHashtable;
     private State state = State.READING_PREAMBLE;
     private byte tag;
     private int written;
@@ -71,8 +99,10 @@ public final class Snappy {
         int inIndex = in.readerIndex();
         final int baseIndex = inIndex;
 
-        final short[] table = getHashTable(length);
-        final int shift = Integer.numberOfLeadingZeros(table.length) + 1;
+        int hashTableSize = MathUtil.findNextPositivePowerOfTwo(length);
+        hashTableSize = Math.min(hashTableSize, MAX_HT_SIZE);
+        final short[] table = getHashTable(hashTableSize);
+        final int shift = Integer.numberOfLeadingZeros(hashTableSize) + 1;
 
         int nextEmit = inIndex;
 
@@ -154,14 +184,35 @@ public final class Snappy {
     }
 
     /**
-     * Creates an appropriately sized hashtable for the given input size
+     * Returns a short[] to be used as a hashtable
      *
-     * @param inputSize The size of our input, ie. the number of bytes we need to encode
+     * @param hashTableSize the size for the hashtable
      * @return An appropriately sized empty hashtable
      */
-    private static short[] getHashTable(int inputSize) {
-        int hashTableSize = MathUtil.findNextPositivePowerOfTwo(inputSize);
-        return new short[Math.min(hashTableSize, MAX_HT_SIZE)];
+    private short[] getHashTable(int hashTableSize) {
+        if (reuseHashtable) {
+            return getHashTableFastThreadLocalArrayFill(hashTableSize);
+        }
+        return new short[hashTableSize];
+    }
+
+    /**
+     * Returns a short[] from a FastThreadLocal, zeroing for correctness
+     * creating a new one and resizing it if necessary
+     *
+     * @return An appropriately sized empty hashtable
+     * @param hashTableSize
+     */
+    public static short[] getHashTableFastThreadLocalArrayFill(int hashTableSize) {
+        short[] hashTable = HASH_TABLE.get();
+        if (hashTable == null || hashTable.length < hashTableSize) {
+            hashTable = new short[hashTableSize];
+            HASH_TABLE.set(hashTable);
+            return hashTable;
+        }
+
+        Arrays.fill(hashTable, 0, hashTableSize, (short) 0);
+        return hashTable;
     }
 
     /**
diff --git a/microbench/src/main/java/io/netty/microbench/snappy/SnappyDirectBenchmark.java b/microbench/src/main/java/io/netty/microbench/snappy/SnappyDirectBenchmark.java
new file mode 100644
index 0000000000..db3b7e8fe0
--- /dev/null
+++ b/microbench/src/main/java/io/netty/microbench/snappy/SnappyDirectBenchmark.java
@@ -0,0 +1,108 @@
+/*
+ * Copyright 2024 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.microbench.snappy;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.Unpooled;
+import io.netty.buffer.UnpooledByteBufAllocator;
+import io.netty.handler.codec.compression.Snappy;
+import io.netty.microbench.util.AbstractMicrobenchmark;
+import org.openjdk.jmh.annotations.AuxCounters;
+import org.openjdk.jmh.annotations.AuxCounters.Type;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.Fork;
+import org.openjdk.jmh.annotations.Level;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Param;
+import org.openjdk.jmh.annotations.Scope;
+import org.openjdk.jmh.annotations.Setup;
+import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.annotations.TearDown;
+import org.openjdk.jmh.annotations.Threads;
+import org.openjdk.jmh.annotations.Warmup;
+
+import java.io.UnsupportedEncodingException;
+import java.util.Arrays;
+
+@State(Scope.Benchmark)
+@Fork(1)
+@Threads(1)
+@Warmup(iterations = 5)
+@Measurement(iterations = 3)
+public class SnappyDirectBenchmark extends AbstractMicrobenchmark {
+
+    @Param({ "true", "false" })
+    public boolean reuseHashTable;
+    private ByteBuf buffer;
+    private Snappy snappy;
+    private ByteBuf in;
+    private ByteBuf out;
+
+    @Param({ "4096", "2048", "1024", "512", "256", "128" })
+    private int bufferSizeInBytes;
+
+    @AuxCounters(value = Type.OPERATIONS)
+    @State(Scope.Thread)
+    public static class AllocationMetrics {
+        private long inputSize;
+
+        private long outputSize;
+
+        public long compressedRatio() {
+            return inputSize / outputSize;
+        }
+    }
+
+    @Setup
+    public void setup() throws UnsupportedEncodingException {
+        ByteBufAllocator allocator = UnpooledByteBufAllocator.DEFAULT;
+        buffer = allocator.buffer(bufferSizeInBytes);
+
+        if (reuseHashTable) {
+            snappy = Snappy.withHashTableReuse();
+        } else {
+            snappy = new Snappy();
+        }
+
+        byte[] compressibleByteArray = new byte[buffer.writableBytes()];
+        Arrays.fill(compressibleByteArray, (byte) 1);
+        buffer.writeBytes(compressibleByteArray);
+
+        in = Unpooled.wrappedBuffer(compressibleByteArray);
+        out = Unpooled.directBuffer();
+    }
+
+    @Benchmark
+    public ByteBuf encode(AllocationMetrics allocationMetrics) {
+        int length = in.readableBytes();
+        snappy.encode(in, out, length);
+        in.resetReaderIndex();
+        allocationMetrics.inputSize += length;
+        allocationMetrics.outputSize += out.readableBytes();
+        out.setIndex(0, 0);
+
+        return out;
+    }
+
+    @TearDown(Level.Trial)
+    public void teardown() {
+        buffer.release();
+        buffer = null;
+        out.release();
+        out = null;
+    }
+}
diff --git a/microbench/src/main/java/io/netty/microbench/snappy/package-info.java b/microbench/src/main/java/io/netty/microbench/snappy/package-info.java
new file mode 100644
index 0000000000..ffd1a6ee17
--- /dev/null
+++ b/microbench/src/main/java/io/netty/microbench/snappy/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2024 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/**
+ * Benchmarks for Snappy ({@link io.netty.handler.codec.compression.Snappy}).
+ */
+package io.netty.microbench.snappy;
