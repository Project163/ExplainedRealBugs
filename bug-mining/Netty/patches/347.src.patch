diff --git a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
index 5870fb17de..ea4e1507a1 100644
--- a/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
+++ b/codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java
@@ -314,14 +314,21 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
     private MqttConnectVariableHeader decodeConnectionVariableHeader(
             ChannelHandlerContext ctx,
             ByteBuf buffer) {
-        final String protoString = decodeStringAndDecreaseBytesRemaining(buffer);
+        final Result<String> protoString = decodeString(buffer);
+        int numberOfBytesConsumed = protoString.numberOfBytesConsumed;
 
         final byte protocolLevel = buffer.readByte();
-        MqttVersion version = MqttVersion.fromProtocolNameAndLevel(protoString, protocolLevel);
+        numberOfBytesConsumed += 1;
+
+        MqttVersion version = MqttVersion.fromProtocolNameAndLevel(protoString.value, protocolLevel);
         MqttCodecUtil.setMqttVersion(ctx, version);
 
         final int b1 = buffer.readUnsignedByte();
+        numberOfBytesConsumed += 1;
+
         final int keepAlive = decodeMsbLsb(buffer);
+        numberOfBytesConsumed += 2;
+
         final boolean hasUserName = (b1 & 0x80) == 0x80;
         final boolean hasPassword = (b1 & 0x40) == 0x40;
         final boolean willRetain = (b1 & 0x20) == 0x20;
@@ -338,11 +345,16 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
             }
         }
 
-        final MqttProperties properties = version == MqttVersion.MQTT_5
-                ? decodeProperties(buffer)
-                : MqttProperties.NO_PROPERTIES;
+        final MqttProperties properties;
+        if (version == MqttVersion.MQTT_5) {
+            final Result<MqttProperties> propertiesResult = decodeProperties(buffer);
+            properties = propertiesResult.value;
+            numberOfBytesConsumed += propertiesResult.numberOfBytesConsumed;
+        } else {
+            properties = MqttProperties.NO_PROPERTIES;
+        }
 
-        bytesRemainingInVariablePart -= 4;
+        bytesRemainingInVariablePart -= numberOfBytesConsumed;
         return new MqttConnectVariableHeader(
                 version.protocolName(),
                 version.protocolLevel(),
@@ -363,10 +375,15 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
         final boolean sessionPresent = (buffer.readUnsignedByte() & 0x01) == 0x01;
         byte returnCode = buffer.readByte();
 
-        bytesRemainingInVariablePart -= 2;
-        final MqttProperties properties = mqttVersion == MqttVersion.MQTT_5
-                ? decodeProperties(buffer)
-                : MqttProperties.NO_PROPERTIES;
+        final MqttProperties properties;
+        if (mqttVersion == MqttVersion.MQTT_5) {
+            final Result<MqttProperties> propertiesResult = decodeProperties(buffer);
+            properties = propertiesResult.value;
+            bytesRemainingInVariablePart -= 2 + propertiesResult.numberOfBytesConsumed;
+        } else {
+            properties = MqttProperties.NO_PROPERTIES;
+            bytesRemainingInVariablePart -= 2;
+        }
 
         return new MqttConnAckVariableHeader(MqttConnectReturnCode.valueOf(returnCode), sessionPresent, properties);
     }
@@ -377,11 +394,15 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
         final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);
         final int packetId = decodeMessageId(buffer);
 
-        bytesRemainingInVariablePart -= 2;
-        MqttProperties properties = mqttVersion == MqttVersion.MQTT_5
-                ? decodeProperties(buffer)
-                : MqttProperties.NO_PROPERTIES;
-        return new MqttMessageIdAndPropertiesVariableHeader(packetId, properties);
+        if (mqttVersion == MqttVersion.MQTT_5) {
+            final Result<MqttProperties> properties = decodeProperties(buffer);
+            bytesRemainingInVariablePart -= 2 + properties.numberOfBytesConsumed;
+            return new MqttMessageIdAndPropertiesVariableHeader(packetId, properties.value);
+        } else {
+            bytesRemainingInVariablePart -= 2;
+            return new MqttMessageIdAndPropertiesVariableHeader(packetId,
+                                                                MqttProperties.NO_PROPERTIES);
+        }
     }
 
     private MqttPubReplyMessageVariableHeader decodePubReplyMessage(ByteBuf buffer) {
@@ -390,11 +411,11 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
         final int packetIdNumberOfBytesConsumed = 2;
         if (bytesRemainingInVariablePart > 3) {
             final byte reasonCode = buffer.readByte();
-            final MqttProperties properties = decodeProperties(buffer);
-            bytesRemainingInVariablePart -= packetIdNumberOfBytesConsumed + 1;
+            final Result<MqttProperties> properties = decodeProperties(buffer);
+            bytesRemainingInVariablePart -= packetIdNumberOfBytesConsumed + 1 + properties.numberOfBytesConsumed;
             return new MqttPubReplyMessageVariableHeader(packetId,
                     reasonCode,
-                    properties);
+                    properties.value);
         } else if (bytesRemainingInVariablePart > 2) {
             final byte reasonCode = buffer.readByte();
             bytesRemainingInVariablePart -= packetIdNumberOfBytesConsumed + 1;
@@ -415,8 +436,9 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
         final MqttProperties properties;
         if (bytesRemainingInVariablePart > 1) {
             reasonCode = buffer.readByte();
-            properties = decodeProperties(buffer);
-            --bytesRemainingInVariablePart;
+            final Result<MqttProperties> propertiesResult = decodeProperties(buffer);
+            properties = propertiesResult.value;
+            bytesRemainingInVariablePart -= 1 + propertiesResult.numberOfBytesConsumed;
         } else if (bytesRemainingInVariablePart > 0) {
             reasonCode = buffer.readByte();
             properties = MqttProperties.NO_PROPERTIES;
@@ -434,22 +456,29 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
             ByteBuf buffer,
             MqttFixedHeader mqttFixedHeader) {
         final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);
-        final String decodedTopic = decodeStringAndDecreaseBytesRemaining(buffer);
-        if (!isValidPublishTopicName(decodedTopic)) {
-            throw new DecoderException("invalid publish topic name: " + decodedTopic + " (contains wildcards)");
+        final Result<String> decodedTopic = decodeString(buffer);
+        if (!isValidPublishTopicName(decodedTopic.value)) {
+            throw new DecoderException("invalid publish topic name: " + decodedTopic.value + " (contains wildcards)");
         }
+        int numberOfBytesConsumed = decodedTopic.numberOfBytesConsumed;
 
         int messageId = -1;
         if (mqttFixedHeader.qosLevel().value() > 0) {
             messageId = decodeMessageId(buffer);
-            bytesRemainingInVariablePart -= 2;
+            numberOfBytesConsumed += 2;
         }
 
-        final MqttProperties properties = mqttVersion == MqttVersion.MQTT_5
-                ? decodeProperties(buffer)
-                : MqttProperties.NO_PROPERTIES;
+        final MqttProperties properties;
+        if (mqttVersion == MqttVersion.MQTT_5) {
+            final Result<MqttProperties> propertiesResult = decodeProperties(buffer);
+            properties = propertiesResult.value;
+            numberOfBytesConsumed += propertiesResult.numberOfBytesConsumed;
+        } else {
+            properties = MqttProperties.NO_PROPERTIES;
+        }
 
-        return new MqttPublishVariableHeader(decodedTopic, messageId, properties);
+        bytesRemainingInVariablePart -= numberOfBytesConsumed;
+        return new MqttPublishVariableHeader(decodedTopic.value, messageId, properties);
     }
 
     /**
@@ -506,42 +535,39 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
             ByteBuf buffer,
             int maxClientIdLength,
             MqttConnectVariableHeader mqttConnectVariableHeader) {
-        String decodedClientId = decodeStringAndDecreaseBytesRemaining(buffer);
+        final Result<String> decodedClientId = decodeString(buffer);
+        final String decodedClientIdValue = decodedClientId.value;
         final MqttVersion mqttVersion = MqttVersion.fromProtocolNameAndLevel(mqttConnectVariableHeader.name(),
                 (byte) mqttConnectVariableHeader.version());
-        if (!isValidClientId(mqttVersion, maxClientIdLength, decodedClientId)) {
-            throw new MqttIdentifierRejectedException("invalid clientIdentifier: " + decodedClientId);
+        if (!isValidClientId(mqttVersion, maxClientIdLength, decodedClientIdValue)) {
+            throw new MqttIdentifierRejectedException("invalid clientIdentifier: " + decodedClientIdValue);
         }
+        int numberOfBytesConsumed = decodedClientId.numberOfBytesConsumed;
 
-        String decodedWillTopic = null;
+        Result<String> decodedWillTopic = null;
         byte[] decodedWillMessage = null;
 
-        int numberOfBytesConsumed = 0;
         final MqttProperties willProperties;
         if (mqttConnectVariableHeader.isWillFlag()) {
             if (mqttVersion == MqttVersion.MQTT_5) {
-                willProperties = decodeProperties(buffer);
+                final Result<MqttProperties> propertiesResult = decodeProperties(buffer);
+                willProperties = propertiesResult.value;
+                numberOfBytesConsumed += propertiesResult.numberOfBytesConsumed;
             } else {
                 willProperties = MqttProperties.NO_PROPERTIES;
             }
-
-            int willTopicSize = decodeMsbLsb(buffer);
-            numberOfBytesConsumed += 2 + willTopicSize;
-            if (willTopicSize <= 32767) {
-                decodedWillTopic = buffer.readString(willTopicSize, CharsetUtil.UTF_8);
-            } else {
-                buffer.skipBytes(willTopicSize);
-            }
-
+            decodedWillTopic = decodeString(buffer, 0, 32767);
+            numberOfBytesConsumed += decodedWillTopic.numberOfBytesConsumed;
             decodedWillMessage = decodeByteArray(buffer);
             numberOfBytesConsumed += decodedWillMessage.length + 2;
         } else {
             willProperties = MqttProperties.NO_PROPERTIES;
         }
-        String decodedUserName = null;
+        Result<String> decodedUserName = null;
         byte[] decodedPassword = null;
         if (mqttConnectVariableHeader.hasUserName()) {
-            decodedUserName = decodeStringAndDecreaseBytesRemaining(buffer);
+            decodedUserName = decodeString(buffer);
+            numberOfBytesConsumed += decodedUserName.numberOfBytesConsumed;
         }
         if (mqttConnectVariableHeader.hasPassword()) {
             decodedPassword = decodeByteArray(buffer);
@@ -550,11 +576,11 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
 
         validateNoBytesRemain(numberOfBytesConsumed);
         return new MqttConnectPayload(
-                        decodedClientId,
+                        decodedClientId.value,
                         willProperties,
-                        decodedWillTopic,
+                        decodedWillTopic != null ? decodedWillTopic.value : null,
                         decodedWillMessage,
-                        decodedUserName,
+                        decodedUserName != null ? decodedUserName.value : null,
                         decodedPassword);
     }
 
@@ -563,10 +589,8 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
         final List<MqttTopicSubscription> subscribeTopics = new ArrayList<MqttTopicSubscription>();
         int numberOfBytesConsumed = 0;
         while (numberOfBytesConsumed < bytesRemainingInVariablePart) {
-            int topicNameSize = decodeMsbLsb(buffer);
-            String decodedTopicName = buffer.readString(topicNameSize, CharsetUtil.UTF_8);
-            numberOfBytesConsumed += 2 + topicNameSize;
-
+            final Result<String> decodedTopicName = decodeString(buffer);
+            numberOfBytesConsumed += decodedTopicName.numberOfBytesConsumed;
             //See 3.8.3.1 Subscription Options of MQTT 5.0 specification for optionByte details
             final short optionByte = buffer.readUnsignedByte();
 
@@ -581,7 +605,7 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
                     retainHandling);
 
             numberOfBytesConsumed++;
-            subscribeTopics.add(new MqttTopicSubscription(decodedTopicName, subscriptionOption));
+            subscribeTopics.add(new MqttTopicSubscription(decodedTopicName.value, subscriptionOption));
         }
         validateNoBytesRemain(numberOfBytesConsumed);
         return new MqttSubscribePayload(subscribeTopics);
@@ -619,10 +643,13 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
     private MqttUnsubscribePayload decodeUnsubscribePayload(
             ByteBuf buffer) {
         final List<String> unsubscribeTopics = new ArrayList<String>();
-        while (bytesRemainingInVariablePart > 0) {
-            final String decodedTopicName = decodeStringAndDecreaseBytesRemaining(buffer);
-            unsubscribeTopics.add(decodedTopicName);
+        int numberOfBytesConsumed = 0;
+        while (numberOfBytesConsumed < bytesRemainingInVariablePart) {
+            final Result<String> decodedTopicName = decodeString(buffer);
+            numberOfBytesConsumed += decodedTopicName.numberOfBytesConsumed;
+            unsubscribeTopics.add(decodedTopicName.value);
         }
+        validateNoBytesRemain(numberOfBytesConsumed);
         return new MqttUnsubscribePayload(unsubscribeTopics);
     }
 
@@ -639,10 +666,21 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
         }
     }
 
-    private String decodeStringAndDecreaseBytesRemaining(ByteBuf buffer) {
+    private static Result<String> decodeString(ByteBuf buffer) {
+        return decodeString(buffer, 0, Integer.MAX_VALUE);
+    }
+
+    private static Result<String> decodeString(ByteBuf buffer, int minBytes, int maxBytes) {
         int size = decodeMsbLsb(buffer);
-        bytesRemainingInVariablePart -= 2 + size;
-        return buffer.readString(size, CharsetUtil.UTF_8);
+        int numberOfBytesConsumed = 2;
+        if (size < minBytes || size > maxBytes) {
+            buffer.skipBytes(size);
+            numberOfBytesConsumed += size;
+            return new Result<String>(null, numberOfBytesConsumed);
+        }
+        String s = buffer.readString(size, CharsetUtil.UTF_8);
+        numberOfBytesConsumed += size;
+        return new Result<String>(s, numberOfBytesConsumed);
     }
 
     /**
@@ -709,7 +747,18 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
         throw new DecoderException("MQTT protocol limits Remaining Length to 4 bytes");
     }
 
-    private MqttProperties decodeProperties(ByteBuf buffer) {
+    private static final class Result<T> {
+
+        private final T value;
+        private final int numberOfBytesConsumed;
+
+        Result(T value, int numberOfBytesConsumed) {
+            this.value = value;
+            this.numberOfBytesConsumed = numberOfBytesConsumed;
+        }
+    }
+
+    private static Result<MqttProperties> decodeProperties(ByteBuf buffer) {
         final long propertiesLength = decodeVariableByteInteger(buffer);
         int totalPropertiesLength = unpackA(propertiesLength);
         int numberOfBytesConsumed = unpackB(propertiesLength);
@@ -760,21 +809,16 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
                 case RESPONSE_INFORMATION:
                 case SERVER_REFERENCE:
                 case REASON_STRING:
-                    int size = decodeMsbLsb(buffer);
-                    numberOfBytesConsumed += 2 + size;
-                    String string = buffer.readString(size, CharsetUtil.UTF_8);
-
-                    decodedProperties.add(new MqttProperties.StringProperty(propertyIdValue, string));
+                    final Result<String> stringResult = decodeString(buffer);
+                    numberOfBytesConsumed += stringResult.numberOfBytesConsumed;
+                    decodedProperties.add(new MqttProperties.StringProperty(propertyIdValue, stringResult.value));
                     break;
                 case USER_PROPERTY:
-                    int keySize = decodeMsbLsb(buffer);
-                    String key = buffer.readString(keySize, CharsetUtil.UTF_8);
-
-                    int valueSize = decodeMsbLsb(buffer);
-                    String value = buffer.readString(valueSize, CharsetUtil.UTF_8);
-
-                    numberOfBytesConsumed += 4 + keySize + valueSize;
-                    decodedProperties.add(new MqttProperties.UserProperty(key, value));
+                    final Result<String> keyResult = decodeString(buffer);
+                    final Result<String> valueResult = decodeString(buffer);
+                    numberOfBytesConsumed += keyResult.numberOfBytesConsumed;
+                    numberOfBytesConsumed += valueResult.numberOfBytesConsumed;
+                    decodedProperties.add(new MqttProperties.UserProperty(keyResult.value, valueResult.value));
                     break;
                 case CORRELATION_DATA:
                 case AUTHENTICATION_DATA:
@@ -788,7 +832,6 @@ public final class MqttDecoder extends ReplayingDecoder<DecoderState> {
             }
         }
 
-        bytesRemainingInVariablePart -= numberOfBytesConsumed;
-        return decodedProperties;
+        return new Result<MqttProperties>(decodedProperties, numberOfBytesConsumed);
     }
 }
