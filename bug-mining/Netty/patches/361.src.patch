diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index 384f357761..bdcfbc6e16 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -27,9 +27,11 @@ import org.jctools.queues.MessagePassingQueue;
 import org.jetbrains.annotations.VisibleForTesting;
 
 import java.util.ArrayDeque;
+import java.util.Objects;
 import java.util.Queue;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
+import static io.netty.util.internal.PlatformDependent.newFixedMpmcQueue;
 import static io.netty.util.internal.PlatformDependent.newMpscQueue;
 import static java.lang.Math.max;
 import static java.lang.Math.min;
@@ -41,22 +43,37 @@ import static java.lang.Math.min;
  */
 public abstract class Recycler<T> {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(Recycler.class);
-    private static final EnhancedHandle<?> NOOP_HANDLE = new EnhancedHandle<Object>() {
-        @Override
-        public void recycle(Object object) {
-            // NOOP
+
+    /**
+     * We created this handle to avoid having more than 2 concrete implementations of {@link EnhancedHandle}
+     * i.e. NOOP_HANDLE, {@link DefaultHandle} and the one used in the LocalPool.
+     */
+    private static final class LocalPoolHandle<T> extends EnhancedHandle<T> {
+        private final UnguardedLocalPool<T> pool;
+
+        private LocalPoolHandle(UnguardedLocalPool<T> pool) {
+            this.pool = pool;
         }
 
         @Override
-        public void unguardedRecycle(final Object object) {
-            // NOOP
+        public void recycle(T object) {
+            UnguardedLocalPool<T> pool = this.pool;
+            if (pool != null) {
+                pool.release(object);
+            }
         }
 
         @Override
-        public String toString() {
-            return "NOOP_HANDLE";
+        public void unguardedRecycle(final Object object) {
+            UnguardedLocalPool<T> pool = this.pool;
+            if (pool != null) {
+                pool.release((T) object);
+            }
         }
-    };
+    }
+
+    private static final EnhancedHandle<?> NOOP_HANDLE = new LocalPoolHandle<>(null);
+    private static final UnguardedLocalPool<?> NOOP_LOCAL_POOL = new UnguardedLocalPool<>(0);
     private static final int DEFAULT_INITIAL_MAX_CAPACITY_PER_THREAD = 4 * 1024; // Use 4k instances as default.
     private static final int DEFAULT_MAX_CAPACITY_PER_THREAD;
     private static final int RATIO;
@@ -102,33 +119,88 @@ public abstract class Recycler<T> {
         }
     }
 
-    private final int maxCapacityPerThread;
-    private final int interval;
-    private final int chunkSize;
-    private final FastThreadLocal<LocalPool<T>> threadLocal = new FastThreadLocal<LocalPool<T>>() {
-        @Override
-        protected LocalPool<T> initialValue() {
-            return new LocalPool<T>(maxCapacityPerThread, interval, chunkSize);
-        }
+    private final LocalPool<?, T> localPool;
+    private final FastThreadLocal<LocalPool<?, T>> threadLocalPool;
 
-        @Override
-        protected void onRemoval(LocalPool<T> value) throws Exception {
-            super.onRemoval(value);
-            MessagePassingQueue<DefaultHandle<T>> handles = value.pooledHandles;
-            value.pooledHandles = null;
-            value.owner = null;
-            handles.clear();
+    /**
+     * USE IT CAREFULLY!<br>
+     * This is creating a shareable {@link Recycler} which {@code get()} can be called concurrently from different
+     * {@link Thread}s.<br>
+     * Usually {@link Recycler}s uses some form of thread-local storage, but this constructor is disabling it
+     * and using a single pool of instances instead, sized as {@code maxCapacity}<br>
+     * This is NOT enforcing pooled instances states to be validated if {@code unguarded = true}:
+     * it means that {@link Handle#recycle(Object)} is not checking that {@code object} is the same which was
+     * recycled and assume no other recycling happens concurrently
+     * (similar to what {@link EnhancedHandle#unguardedRecycle(Object)} does).<br>
+     */
+    protected Recycler(int maxCapacity, boolean unguarded) {
+        if (maxCapacity <= 0) {
+            maxCapacity = 0;
+        } else {
+            maxCapacity = max(4, maxCapacity);
+        }
+        threadLocalPool = null;
+        if (maxCapacity == 0) {
+            localPool = (LocalPool<?, T>) NOOP_LOCAL_POOL;
+        } else {
+            localPool = unguarded? new UnguardedLocalPool<>(maxCapacity) : new GuardedLocalPool<>(maxCapacity);
         }
-    };
+    }
 
-    protected Recycler() {
-        this(DEFAULT_MAX_CAPACITY_PER_THREAD);
+    /**
+     * USE IT CAREFULLY!<br>
+     * This is NOT enforcing pooled instances states to be validated if {@code unguarded = true}:
+     * it means that {@link Handle#recycle(Object)} is not checking that {@code object} is the same which was
+     * recycled and assume no other recycling happens concurrently
+     * (similar to what {@link EnhancedHandle#unguardedRecycle(Object)} does).<br>
+     */
+    protected Recycler(boolean unguarded) {
+        this(DEFAULT_MAX_CAPACITY_PER_THREAD, RATIO, DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD, unguarded);
+    }
+
+    /**
+     * USE IT CAREFULLY!<br>
+     * This is NOT enforcing pooled instances states to be validated if {@code unguarded = true} as stated by
+     * {@link #Recycler(boolean)} and allows to pin the recycler to a specific {@link Thread}, if {@code owner}
+     * is not {@code null}.
+     * <p>
+     * Since this method has been introduced for performance-sensitive cases it doesn't validate if {@link #get()} is
+     * called from the {@code owner} {@link Thread}: it assumes {@link #get()} to never happen concurrently.
+     * <p>
+     */
+    protected Recycler(Thread owner, boolean unguarded) {
+        this(DEFAULT_MAX_CAPACITY_PER_THREAD, RATIO, DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD, owner, unguarded);
     }
 
     protected Recycler(int maxCapacityPerThread) {
         this(maxCapacityPerThread, RATIO, DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD);
     }
 
+    protected Recycler() {
+        this(DEFAULT_MAX_CAPACITY_PER_THREAD);
+    }
+
+    /**
+     * USE IT CAREFULLY!<br>
+     * This is NOT enforcing pooled instances states to be validated if {@code unguarded = true} as stated by
+     * {@link #Recycler(boolean)}, but it allows to tune the chunk size used for local pooling.
+     */
+    protected Recycler(int chunksSize, int maxCapacityPerThread, boolean unguarded) {
+        this(maxCapacityPerThread, RATIO, chunksSize, unguarded);
+    }
+
+    /**
+     * USE IT CAREFULLY!<br>
+     * This is NOT enforcing pooled instances states to be validated if {@code unguarded = true} and allows pinning
+     * the recycler to a specific {@link Thread}, as stated by {@link #Recycler(Thread, boolean)}.<br>
+     * It also allows tuning the chunk size used for local pooling and the max capacity per thread.
+     *
+     * @throws IllegalArgumentException if {@code owner} is {@code null}.
+     */
+    protected Recycler(int chunkSize, int maxCapacityPerThread, Thread owner, boolean unguarded) {
+        this(maxCapacityPerThread, RATIO, chunkSize, owner, unguarded);
+    }
+
     /**
      * @deprecated Use one of the following instead:
      * {@link #Recycler()}, {@link #Recycler(int)}, {@link #Recycler(int, int, int)}.
@@ -161,40 +233,98 @@ public abstract class Recycler<T> {
         this(maxCapacityPerThread, ratio, DEFAULT_QUEUE_CHUNK_SIZE_PER_THREAD);
     }
 
-    protected Recycler(int maxCapacityPerThread, int ratio, int chunkSize) {
-        interval = max(0, ratio);
+    protected Recycler(int maxCapacityPerThread, int interval, int chunkSize) {
+        this(maxCapacityPerThread, interval, chunkSize, true, null, false);
+    }
+
+    /**
+     * USE IT CAREFULLY!<br>
+     * This is NOT enforcing pooled instances states to be validated if {@code unguarded =true}
+     * as stated by {@link #Recycler(boolean)}.
+     */
+    protected Recycler(int maxCapacityPerThread, int interval, int chunkSize, boolean unguarded) {
+        this(maxCapacityPerThread, interval, chunkSize, true, null, unguarded);
+    }
+
+    /**
+     * USE IT CAREFULLY!<br>
+     * This is NOT enforcing pooled instances states to be validated if {@code unguarded =true}
+     * as stated by {@link #Recycler(boolean)}.
+     */
+    protected Recycler(int maxCapacityPerThread, int interval, int chunkSize, Thread owner, boolean unguarded) {
+        this(maxCapacityPerThread, interval, chunkSize, false, owner, unguarded);
+    }
+
+    @SuppressWarnings("unchecked")
+    private Recycler(int maxCapacityPerThread, int ratio, int chunkSize, boolean useThreadLocalStorage,
+                     Thread owner, boolean unguarded) {
+        final int interval = max(0, ratio);
         if (maxCapacityPerThread <= 0) {
-            this.maxCapacityPerThread = 0;
-            this.chunkSize = 0;
+            maxCapacityPerThread = 0;
+            chunkSize = 0;
+        } else {
+            maxCapacityPerThread = max(4, maxCapacityPerThread);
+            chunkSize = max(2, min(chunkSize, maxCapacityPerThread >> 1));
+        }
+        if (maxCapacityPerThread > 0 && useThreadLocalStorage) {
+            final int finalMaxCapacityPerThread = maxCapacityPerThread;
+            final int finalChunkSize = chunkSize;
+            threadLocalPool = new FastThreadLocal<LocalPool<?, T>>() {
+                @Override
+                protected LocalPool<?, T> initialValue() {
+                    return unguarded? new UnguardedLocalPool<>(finalMaxCapacityPerThread, interval, finalChunkSize) :
+                            new GuardedLocalPool<>(finalMaxCapacityPerThread, interval, finalChunkSize);
+                }
+
+                @Override
+                protected void onRemoval(LocalPool<?, T> value) throws Exception {
+                    super.onRemoval(value);
+                    MessagePassingQueue<?> handles = value.pooledHandles;
+                    value.pooledHandles = null;
+                    value.owner = null;
+                    if (handles != null) {
+                        handles.clear();
+                    }
+                }
+            };
+            localPool = null;
         } else {
-            this.maxCapacityPerThread = max(4, maxCapacityPerThread);
-            this.chunkSize = max(2, min(chunkSize, this.maxCapacityPerThread >> 1));
+            threadLocalPool = null;
+            if (maxCapacityPerThread == 0) {
+                localPool = (LocalPool<?, T>) NOOP_LOCAL_POOL;
+            } else {
+                Objects.requireNonNull(owner, "owner");
+                localPool = unguarded? new UnguardedLocalPool<>(owner, maxCapacityPerThread, interval, chunkSize) :
+                        new GuardedLocalPool<>(owner, maxCapacityPerThread, interval, chunkSize);
+            }
         }
     }
 
     @SuppressWarnings("unchecked")
     public final T get() {
-        if (maxCapacityPerThread == 0 ||
-                (PlatformDependent.isVirtualThread(Thread.currentThread()) &&
-                        !FastThreadLocalThread.currentThreadHasFastThreadLocal())) {
-            return newObject((Handle<T>) NOOP_HANDLE);
-        }
-        LocalPool<T> localPool = threadLocal.get();
-        DefaultHandle<T> handle = localPool.claim();
-        T obj;
-        if (handle == null) {
-            handle = localPool.newHandle();
-            if (handle != null) {
-                obj = newObject(handle);
-                handle.set(obj);
-            } else {
-                obj = newObject((Handle<T>) NOOP_HANDLE);
-            }
+        if (localPool != null) {
+            return localPool.getWith(this);
         } else {
-            obj = handle.get();
+            if (PlatformDependent.isVirtualThread(Thread.currentThread()) &&
+                !FastThreadLocalThread.currentThreadHasFastThreadLocal()) {
+                return newObject((Handle<T>) NOOP_HANDLE);
+            }
+            return threadLocalPool.get().getWith(this);
         }
+    }
 
-        return obj;
+    /**
+     * Disassociates the {@link Recycler} from the current {@link Thread} if it was pinned,
+     * see {@link #Recycler(Thread, boolean)}.
+     * <p>
+     * Be aware that this method is not thread-safe: it's necessary to allow a {@link Thread} to
+     * be garbage collected even if {@link Handle}s are still referenced by other objects.
+     * <p>
+     */
+    public static void unpinOwner(Recycler<?> recycler) {
+        if (recycler.localPool != null) {
+            recycler.localPool.owner = null;
+        }
     }
 
     /**
@@ -212,12 +342,19 @@ public abstract class Recycler<T> {
 
     @VisibleForTesting
     final int threadLocalSize() {
-        if (PlatformDependent.isVirtualThread(Thread.currentThread()) &&
+        if (localPool != null) {
+            return localPool.size();
+        } else {
+            if (PlatformDependent.isVirtualThread(Thread.currentThread()) &&
                 !FastThreadLocalThread.currentThreadHasFastThreadLocal()) {
-            return 0;
+                return 0;
+            }
+            final LocalPool<?, T> pool = threadLocalPool.getIfExists();
+            if (pool == null) {
+                return 0;
+            }
+            return pool.size();
         }
-        LocalPool<T> localPool = threadLocal.getIfExists();
-        return localPool == null ? 0 : localPool.pooledHandles.size() + localPool.batch.size();
     }
 
     /**
@@ -248,10 +385,10 @@ public abstract class Recycler<T> {
         }
 
         private volatile int state; // State is initialised to STATE_CLAIMED (aka. 0) so they can be released.
-        private final LocalPool<T> localPool;
+        private final GuardedLocalPool<T> localPool;
         private T value;
 
-        DefaultHandle(LocalPool<T> localPool) {
+        DefaultHandle(GuardedLocalPool<T> localPool) {
             this.localPool = localPool;
         }
 
@@ -260,7 +397,8 @@ public abstract class Recycler<T> {
             if (object != value) {
                 throw new IllegalArgumentException("object does not belong to handle");
             }
-            localPool.release(this, true);
+            toAvailable();
+            localPool.release(this);
         }
 
         @Override
@@ -268,10 +406,13 @@ public abstract class Recycler<T> {
             if (object != value) {
                 throw new IllegalArgumentException("object does not belong to handle");
             }
-            localPool.release(this, false);
+            unguardedToAvailable();
+            localPool.release(this);
         }
 
-        T get() {
+        T claim() {
+            assert state == STATE_AVAILABLE;
+            STATE_UPDATER.lazySet(this, STATE_CLAIMED);
             return value;
         }
 
@@ -279,19 +420,14 @@ public abstract class Recycler<T> {
             this.value = value;
         }
 
-        void toClaimed() {
-            assert state == STATE_AVAILABLE;
-            STATE_UPDATER.lazySet(this, STATE_CLAIMED);
-        }
-
-        void toAvailable() {
+        private void toAvailable() {
             int prev = STATE_UPDATER.getAndSet(this, STATE_AVAILABLE);
             if (prev == STATE_AVAILABLE) {
                 throw new IllegalStateException("Object has been recycled already.");
             }
         }
 
-        void unguardedToAvailable() {
+        private void unguardedToAvailable() {
             int prev = state;
             if (prev == STATE_AVAILABLE) {
                 throw new IllegalStateException("Object has been recycled already.");
@@ -300,59 +436,149 @@ public abstract class Recycler<T> {
         }
     }
 
-    private static final class LocalPool<T> implements MessagePassingQueue.Consumer<DefaultHandle<T>> {
+    private static final class GuardedLocalPool<T> extends LocalPool<DefaultHandle<T>, T> {
+
+        GuardedLocalPool(int maxCapacity) {
+            super(maxCapacity);
+        }
+
+        GuardedLocalPool(Thread owner, int maxCapacity, int ratioInterval, int chunkSize) {
+            super(owner, maxCapacity, ratioInterval, chunkSize);
+        }
+
+        GuardedLocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
+            super(maxCapacity, ratioInterval, chunkSize);
+        }
+
+        @Override
+        public T getWith(Recycler<T> recycler) {
+            DefaultHandle<T> handle = acquire();
+            T obj;
+            if (handle == null) {
+                handle = canAllocatePooled()? new DefaultHandle<>(this) : null;
+                if (handle != null) {
+                    obj = recycler.newObject(handle);
+                    handle.set(obj);
+                } else {
+                    obj = recycler.newObject((Handle<T>) NOOP_HANDLE);
+                }
+            } else {
+                obj = handle.claim();
+            }
+            return obj;
+        }
+    }
+
+    private static final class UnguardedLocalPool<T> extends LocalPool<T, T> {
+        private final EnhancedHandle<T> handle;
+
+        UnguardedLocalPool(int maxCapacity) {
+            super(maxCapacity);
+            handle = maxCapacity == 0? null : new LocalPoolHandle<>(this);
+        }
+
+        UnguardedLocalPool(Thread owner, int maxCapacity, int ratioInterval, int chunkSize) {
+            super(owner, maxCapacity, ratioInterval, chunkSize);
+            handle = new LocalPoolHandle<>(this);
+        }
+
+        UnguardedLocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
+            super(maxCapacity, ratioInterval, chunkSize);
+            handle = new LocalPoolHandle<>(this);
+        }
+
+        @Override
+        public T getWith(Recycler<T> recycler) {
+            T obj = acquire();
+            if (obj == null) {
+                obj = recycler.newObject(canAllocatePooled()? handle : (Handle<T>) NOOP_HANDLE);
+            }
+            return obj;
+        }
+    }
+
+    private abstract static class LocalPool<H, T> {
         private final int ratioInterval;
-        private final int chunkSize;
-        private final ArrayDeque<DefaultHandle<T>> batch;
-        private volatile Thread owner;
-        private volatile MessagePassingQueue<DefaultHandle<T>> pooledHandles;
+        private final H[] batch;
+        private int batchSize;
+        private Thread owner;
+        private MessagePassingQueue<H> pooledHandles;
         private int ratioCounter;
 
+        LocalPool(int maxCapacity) {
+            // if there's no capacity, we need to never allocate pooled objects.
+            // if there's capacity, because there is a shared pool, we always pool them, since we cannot trust the
+            // thread unsafe ratio counter.
+            this.ratioInterval = maxCapacity == 0? -1 : 0;
+            this.owner = null;
+            batch = null;
+            batchSize = 0;
+            pooledHandles = createExternalMcPool(maxCapacity);
+            ratioCounter = 0;
+        }
+
         @SuppressWarnings("unchecked")
-        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
+        LocalPool(Thread owner, int maxCapacity, int ratioInterval, int chunkSize) {
             this.ratioInterval = ratioInterval;
-            this.chunkSize = chunkSize;
-            batch = new ArrayDeque<DefaultHandle<T>>(chunkSize);
-            Thread currentThread = Thread.currentThread();
-            owner = !BATCH_FAST_TL_ONLY || FastThreadLocalThread.currentThreadHasFastThreadLocal()
-                    ? currentThread : null;
-            if (BLOCKING_POOL) {
-                pooledHandles = new BlockingMessageQueue<DefaultHandle<T>>(maxCapacity);
-            } else {
-                pooledHandles = (MessagePassingQueue<DefaultHandle<T>>) newMpscQueue(chunkSize, maxCapacity);
-            }
+            this.owner = owner;
+            batch = owner != null? (H[]) new Object[chunkSize] : null;
+            batchSize = 0;
+            pooledHandles = createExternalScPool(chunkSize, maxCapacity);
             ratioCounter = ratioInterval; // Start at interval so the first one will be recycled.
         }
 
-        DefaultHandle<T> claim() {
-            MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
-            if (handles == null) {
+        private static <H> MessagePassingQueue<H> createExternalMcPool(int maxCapacity) {
+            if (maxCapacity == 0) {
                 return null;
             }
-            if (batch.isEmpty()) {
-                handles.drain(this, chunkSize);
+            if (BLOCKING_POOL) {
+                return new BlockingMessageQueue<>(maxCapacity);
+            }
+            return (MessagePassingQueue<H>) newFixedMpmcQueue(maxCapacity);
+        }
+
+        private static <H> MessagePassingQueue<H> createExternalScPool(int chunkSize, int maxCapacity) {
+            if (maxCapacity == 0) {
+                return null;
             }
-            DefaultHandle<T> handle = batch.pollLast();
-            if (null != handle) {
-                handle.toClaimed();
+            if (BLOCKING_POOL) {
+                return new BlockingMessageQueue<>(maxCapacity);
             }
-            return handle;
+            return (MessagePassingQueue<H>) newMpscQueue(chunkSize, maxCapacity);
         }
 
-        void release(DefaultHandle<T> handle, boolean guarded) {
-            if (guarded) {
-                handle.toAvailable();
-            } else {
-                handle.unguardedToAvailable();
+        LocalPool(int maxCapacity, int ratioInterval, int chunkSize) {
+            this(!BATCH_FAST_TL_ONLY || FastThreadLocalThread.currentThreadHasFastThreadLocal()
+                         ? Thread.currentThread() : null, maxCapacity, ratioInterval, chunkSize);
+        }
+
+        protected final H acquire() {
+            int size = batchSize;
+            if (size == 0) {
+                // it's ok to be racy; at worst we reuse something that won't return back to the pool
+                final MessagePassingQueue<H> handles = pooledHandles;
+                if (handles == null) {
+                    return null;
+                }
+                return handles.relaxedPoll();
             }
+            int top = size - 1;
+            final H h = batch[top];
+            batchSize = top;
+            batch[top] = null;
+            return h;
+        }
+
+        protected final void release(H handle) {
             Thread owner = this.owner;
-            if (owner != null && Thread.currentThread() == owner && batch.size() < chunkSize) {
-                accept(handle);
+            if (owner != null && Thread.currentThread() == owner && batchSize < batch.length) {
+                batch[batchSize] = handle;
+                batchSize++;
             } else if (owner != null && isTerminated(owner)) {
-                this.owner = null;
                 pooledHandles = null;
+                this.owner = null;
             } else {
-                MessagePassingQueue<DefaultHandle<T>> handles = pooledHandles;
+                MessagePassingQueue<H> handles = pooledHandles;
                 if (handles != null) {
                     handles.relaxedOffer(handle);
                 }
@@ -362,20 +588,29 @@ public abstract class Recycler<T> {
         private static boolean isTerminated(Thread owner) {
             // Do not use `Thread.getState()` in J9 JVM because it's known to have a performance issue.
             // See: https://github.com/netty/netty/issues/13347#issuecomment-1518537895
-            return PlatformDependent.isJ9Jvm() ? !owner.isAlive() : owner.getState() == Thread.State.TERMINATED;
+            return PlatformDependent.isJ9Jvm()? !owner.isAlive() : owner.getState() == Thread.State.TERMINATED;
         }
 
-        DefaultHandle<T> newHandle() {
+        boolean canAllocatePooled() {
+            if (ratioInterval < 0) {
+                return false;
+            }
+            if (ratioInterval == 0) {
+                return true;
+            }
             if (++ratioCounter >= ratioInterval) {
                 ratioCounter = 0;
-                return new DefaultHandle<T>(this);
+                return true;
             }
-            return null;
+            return false;
         }
 
-        @Override
-        public void accept(DefaultHandle<T> e) {
-            batch.addLast(e);
+        abstract T getWith(Recycler<T> recycler);
+
+        int size() {
+            MessagePassingQueue<H> handles = pooledHandles;
+            final int externalSize = handles != null? handles.size() : 0;
+            return externalSize + (batch != null? batchSize : 0);
         }
     }
 
diff --git a/common/src/test/java/io/netty/util/RecyclerFastThreadLocalTest.java b/common/src/test/java/io/netty/util/RecyclerFastThreadLocalTest.java
index 7c8d4da113..41c7b33d8e 100644
--- a/common/src/test/java/io/netty/util/RecyclerFastThreadLocalTest.java
+++ b/common/src/test/java/io/netty/util/RecyclerFastThreadLocalTest.java
@@ -17,9 +17,10 @@ package io.netty.util;
 
 import io.netty.util.concurrent.FastThreadLocalThread;
 import org.jetbrains.annotations.NotNull;
-import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 import org.junit.jupiter.api.extension.ExtendWith;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.MethodSource;
 
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
@@ -36,18 +37,21 @@ public class RecyclerFastThreadLocalTest extends RecyclerTest {
     }
 
     @Override
-    @Test
+    @ParameterizedTest
     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
-    public void testThreadCanBeCollectedEvenIfHandledObjectIsReferenced() throws Exception {
-        final Recycler<HandledObject> recycler = newRecycler(1024);
+    @MethodSource("ownerTypeAndUnguarded")
+    public void testThreadCanBeCollectedEvenIfHandledObjectIsReferenced(OwnerType ownerType, boolean unguarded)
+            throws Exception {
         final AtomicBoolean collected = new AtomicBoolean();
         final AtomicReference<HandledObject> reference = new AtomicReference<HandledObject>();
         Thread thread = new FastThreadLocalThread(new Runnable() {
             @Override
             public void run() {
+                final Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, 1024);
                 HandledObject object = recycler.get();
                 // Store a reference to the HandledObject to ensure it is not collected when the run method finish.
                 reference.set(object);
+                Recycler.unpinOwner(recycler);
             }
         }) {
             @Override
@@ -71,6 +75,8 @@ public class RecyclerFastThreadLocalTest extends RecyclerTest {
         }
 
         // Now call recycle after the Thread was collected to ensure this still works...
-        reference.getAndSet(null).recycle();
+        if (reference.get() != null) {
+            reference.getAndSet(null).recycle();
+        }
     }
 }
diff --git a/common/src/test/java/io/netty/util/RecyclerTest.java b/common/src/test/java/io/netty/util/RecyclerTest.java
index 49359ff962..c6fdbfaf0d 100644
--- a/common/src/test/java/io/netty/util/RecyclerTest.java
+++ b/common/src/test/java/io/netty/util/RecyclerTest.java
@@ -15,11 +15,17 @@
 */
 package io.netty.util;
 
+import io.netty.util.internal.MathUtil;
 import org.jetbrains.annotations.NotNull;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 import org.junit.jupiter.api.function.Executable;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.Arguments;
+import org.junit.jupiter.params.provider.EnumSource;
+import org.junit.jupiter.params.provider.MethodSource;
 
+import java.util.Arrays;
 import java.util.Random;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.ExecutorService;
@@ -29,6 +35,8 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicReference;
+import java.util.function.Consumer;
+import java.util.stream.Stream;
 
 import static org.assertj.core.api.Assertions.assertThat;
 import static org.junit.jupiter.api.Assertions.assertEquals;
@@ -41,12 +49,73 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class RecyclerTest {
 
-    protected static Recycler<HandledObject> newRecycler(int maxCapacityPerThread) {
-        return newRecycler(maxCapacityPerThread, 8, maxCapacityPerThread >> 1);
+    public enum OwnerType {
+        NONE,
+        PINNED,
+        FAST_THREAD_LOCAL,
+    }
+
+    public static Stream<Arguments> ownerTypeAndUnguarded() {
+        return Arrays.stream(OwnerType.values())
+                     .flatMap(owner -> Stream.of(true, false)
+                                             .map(unguarded -> Arguments.of(owner, unguarded)));
+    }
+
+    public static Stream<Arguments> notNoneOwnerAndUnguarded() {
+        return ownerTypeAndUnguarded().filter(args -> args.get()[0] != OwnerType.NONE);
+    }
+
+    protected static Recycler<HandledObject> newRecycler(OwnerType ownerType, boolean unguarded,
+                                                         int maxCapacityPerThread) {
+        return newRecycler(ownerType, unguarded, maxCapacityPerThread, null);
+    }
+
+    protected static Recycler<HandledObject> newRecycler(OwnerType ownerType, boolean unguarded,
+                                                         int maxCapacityPerThread,
+                                                         Consumer<HandledObject> onNewObject) {
+        switch (ownerType) {
+        case NONE:
+            return new Recycler<HandledObject>(maxCapacityPerThread, unguarded) {
+                @Override
+                protected HandledObject newObject(Handle<HandledObject> handle) {
+                    HandledObject newObj = new HandledObject(handle);
+                    if (onNewObject != null) {
+                        onNewObject.accept(newObj);
+                    }
+                    return newObj;
+                }
+            };
+        case PINNED:
+            return new Recycler<HandledObject>(maxCapacityPerThread >> 1, maxCapacityPerThread, Thread.currentThread(),
+                                               unguarded) {
+                @Override
+                protected HandledObject newObject(
+                        Recycler.Handle<HandledObject> handle) {
+                    HandledObject newObj = new HandledObject(handle);
+                    if (onNewObject != null) {
+                        onNewObject.accept(newObj);
+                    }
+                    return newObj;
+                }
+            };
+        case FAST_THREAD_LOCAL:
+            return new Recycler<HandledObject>(maxCapacityPerThread >> 1, maxCapacityPerThread, unguarded) {
+                @Override
+                protected HandledObject newObject(Handle<HandledObject> handle) {
+                    HandledObject newObj = new HandledObject(handle);
+                    if (onNewObject != null) {
+                        onNewObject.accept(newObj);
+                    }
+                    return newObj;
+                }
+            };
+        default:
+            throw new Error();
+        }
     }
 
-    protected static Recycler<HandledObject> newRecycler(int maxCapacityPerThread, int ratio, int chunkSize) {
-        return new Recycler<HandledObject>(maxCapacityPerThread, ratio, chunkSize) {
+    protected static Recycler<HandledObject> newRecycler(boolean unguarded, int maxCapacityPerThread) {
+        return new Recycler<HandledObject>(maxCapacityPerThread >> 1, maxCapacityPerThread, unguarded) {
             @Override
             protected HandledObject newObject(
                     Recycler.Handle<HandledObject> handle) {
@@ -55,23 +124,63 @@ public class RecyclerTest {
         };
     }
 
+    protected static Recycler<HandledObject> newRecycler(int maxCapacityPerThread) {
+        return newRecycler(OwnerType.FAST_THREAD_LOCAL, false, maxCapacityPerThread, 8, maxCapacityPerThread >> 1);
+    }
+
+    protected static Recycler<HandledObject> newRecycler(OwnerType ownerType, boolean unguarded,
+                                                         int maxCapacityPerThread, int ratio, int chunkSize) {
+        // NOTE: ratio and chunk size will be ignored for NONE owner type!
+        switch (ownerType) {
+        case NONE:
+            return new Recycler<HandledObject>(maxCapacityPerThread, unguarded) {
+                @Override
+                protected HandledObject newObject(Handle<HandledObject> handle) {
+                    return new HandledObject(handle);
+                }
+            };
+        case PINNED:
+            return new Recycler<HandledObject>(maxCapacityPerThread, ratio, chunkSize, Thread.currentThread(),
+                                               unguarded) {
+                @Override
+                protected HandledObject newObject(
+                        Recycler.Handle<HandledObject> handle) {
+                    return new HandledObject(handle);
+                }
+            };
+        case FAST_THREAD_LOCAL:
+            return new Recycler<HandledObject>(maxCapacityPerThread, ratio, chunkSize, unguarded) {
+                @Override
+                protected HandledObject newObject(
+                        Recycler.Handle<HandledObject> handle) {
+                    return new HandledObject(handle);
+                }
+            };
+        default:
+            throw new Error();
+        }
+    }
+
     @NotNull
     protected Thread newThread(Runnable runnable) {
         return new Thread(runnable);
     }
 
-    @Test
+    @ParameterizedTest
     @Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
-    public void testThreadCanBeCollectedEvenIfHandledObjectIsReferenced() throws Exception {
-        final Recycler<HandledObject> recycler = newRecycler(1024);
+    @MethodSource("ownerTypeAndUnguarded")
+    public void testThreadCanBeCollectedEvenIfHandledObjectIsReferenced(OwnerType ownerType, boolean unguarded)
+            throws Exception {
         final AtomicBoolean collected = new AtomicBoolean();
         final AtomicReference<HandledObject> reference = new AtomicReference<HandledObject>();
         Thread thread = new Thread(new Runnable() {
             @Override
             public void run() {
+                final Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, 1024);
                 HandledObject object = recycler.get();
                 // Store a reference to the HandledObject to ensure it is not collected when the run method finish.
                 reference.set(object);
+                Recycler.unpinOwner(recycler);
             }
         }) {
             @Override
@@ -95,17 +204,22 @@ public class RecyclerTest {
         }
 
         // Now call recycle after the Thread was collected to ensure this still works...
-        reference.getAndSet(null).recycle();
+        if (reference.get() != null) {
+            reference.getAndSet(null).recycle();
+        }
     }
 
-    @Test
-    public void verySmallRecycer() {
-        newRecycler(2, 0, 1).get();
+    @ParameterizedTest
+    @MethodSource("ownerTypeAndUnguarded")
+    public void verySmallRecycer(OwnerType ownerType, boolean unguarded) {
+        newRecycler(ownerType, unguarded, 2, 0, 1).get();
     }
 
-    @Test
-    public void testMultipleRecycle() {
-        Recycler<HandledObject> recycler = newRecycler(1024);
+    @ParameterizedTest
+    @EnumSource(OwnerType.class)
+    public void testMultipleRecycle(OwnerType ownerType) {
+        // This test makes only sense for guarded recyclers
+        Recycler<HandledObject> recycler = newRecycler(ownerType, false, 1024);
         final HandledObject object = recycler.get();
         object.recycle();
         assertThrows(IllegalStateException.class, new Executable() {
@@ -117,8 +231,19 @@ public class RecyclerTest {
     }
 
     @Test
-    public void testMultipleRecycleAtDifferentThread() throws InterruptedException {
-        Recycler<HandledObject> recycler = newRecycler(1024);
+    public void testUnguardedMultipleRecycle() {
+        Recycler<HandledObject> recycler = newRecycler(true, 1024);
+        final HandledObject object = recycler.get();
+        object.recycle();
+        object.recycle();
+    }
+
+    @ParameterizedTest
+    @EnumSource(OwnerType.class)
+    public void testMultipleRecycleAtDifferentThread(OwnerType ownerType)
+            throws InterruptedException {
+        // This test makes only sense for guarded recyclers
+        Recycler<HandledObject> recycler = newRecycler(ownerType, false, 1024);
         final HandledObject object = recycler.get();
         final AtomicReference<IllegalStateException> exceptionStore = new AtomicReference<IllegalStateException>();
         final Thread thread1 = newThread(new Runnable() {
@@ -149,9 +274,12 @@ public class RecyclerTest {
         assertNotNull(exception);
     }
 
-    @Test
-    public void testMultipleRecycleAtDifferentThreadRacing() throws InterruptedException {
-        Recycler<HandledObject> recycler = newRecycler(1024);
+    @ParameterizedTest
+    @EnumSource(OwnerType.class)
+    public void testMultipleRecycleAtDifferentThreadRacing(OwnerType ownerType)
+            throws InterruptedException {
+        // This test makes only sense for guarded recyclers
+        Recycler<HandledObject> recycler = newRecycler(ownerType, false, 1024);
         final HandledObject object = recycler.get();
         final AtomicReference<IllegalStateException> exceptionStore = new AtomicReference<IllegalStateException>();
 
@@ -206,9 +334,11 @@ public class RecyclerTest {
         }
     }
 
-    @Test
-    public void testMultipleRecycleRacing() throws InterruptedException {
-        Recycler<HandledObject> recycler = newRecycler(1024);
+    @ParameterizedTest
+    @EnumSource(OwnerType.class)
+    public void testMultipleRecycleRacing(OwnerType ownerType) throws InterruptedException {
+        // This test makes only sense for guarded recyclers
+        Recycler<HandledObject> recycler = newRecycler(ownerType, false, 1024);
         final HandledObject object = recycler.get();
         final AtomicReference<IllegalStateException> exceptionStore = new AtomicReference<IllegalStateException>();
 
@@ -251,9 +381,10 @@ public class RecyclerTest {
         }
     }
 
-    @Test
-    public void testRecycle() {
-        Recycler<HandledObject> recycler = newRecycler(1024);
+    @ParameterizedTest
+    @MethodSource("ownerTypeAndUnguarded")
+    public void testRecycle(OwnerType ownerType, boolean unguarded) {
+        Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, 1024);
         HandledObject object = recycler.get();
         object.recycle();
         HandledObject object2 = recycler.get();
@@ -261,9 +392,10 @@ public class RecyclerTest {
         object2.recycle();
     }
 
-    @Test
-    public void testRecycleDisable() {
-        Recycler<HandledObject> recycler = newRecycler(-1);
+    @ParameterizedTest
+    @MethodSource("ownerTypeAndUnguarded")
+    public void testRecycleDisable(OwnerType ownerType, boolean unguarded) {
+        Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, -1);
         HandledObject object = recycler.get();
         object.recycle();
         HandledObject object2 = recycler.get();
@@ -271,9 +403,10 @@ public class RecyclerTest {
         object2.recycle();
     }
 
-    @Test
-    public void testRecycleDisableDrop() {
-        Recycler<HandledObject> recycler = newRecycler(1024, 0, 16);
+    @ParameterizedTest
+    @MethodSource("ownerTypeAndUnguarded")
+    public void testRecycleDisableDrop(OwnerType ownerType, boolean unguarded) {
+        Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, 1024, 0, 16);
         HandledObject object = recycler.get();
         object.recycle();
         HandledObject object2 = recycler.get();
@@ -288,17 +421,18 @@ public class RecyclerTest {
      * Test to make sure bug #2848 never happens again
      * https://github.com/netty/netty/issues/2848
      */
-    @Test
-    public void testMaxCapacity() {
-        testMaxCapacity(300);
+    @ParameterizedTest
+    @MethodSource("ownerTypeAndUnguarded")
+    public void testMaxCapacity(OwnerType ownerType, boolean unguarded) {
+        testMaxCapacity(ownerType, unguarded, 300);
         Random rand = new Random();
         for (int i = 0; i < 50; i++) {
-            testMaxCapacity(rand.nextInt(1000) + 256); // 256 - 1256
+            testMaxCapacity(ownerType, unguarded, rand.nextInt(1000) + 256); // 256 - 1256
         }
     }
 
-    private static void testMaxCapacity(int maxCapacity) {
-        Recycler<HandledObject> recycler = newRecycler(maxCapacity);
+    private static void testMaxCapacity(OwnerType ownerType, boolean unguarded, int maxCapacity) {
+        Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, maxCapacity);
         HandledObject[] objects = new HandledObject[maxCapacity * 3];
         for (int i = 0; i < objects.length; i++) {
             objects[i] = recycler.get();
@@ -309,14 +443,15 @@ public class RecyclerTest {
             objects[i] = null;
         }
 
-        assertTrue(maxCapacity >= recycler.threadLocalSize(),
+        assertTrue(MathUtil.findNextPositivePowerOfTwo(maxCapacity) >= recycler.threadLocalSize(),
                 "The threadLocalSize (" + recycler.threadLocalSize() + ") must be <= maxCapacity ("
                 + maxCapacity + ") as we not pool all new handles internally");
     }
 
-    @Test
-    public void testRecycleAtDifferentThread() throws Exception {
-        final Recycler<HandledObject> recycler = newRecycler(256, 2, 16);
+    @ParameterizedTest
+    @MethodSource("notNoneOwnerAndUnguarded")
+    public void testRecycleAtDifferentThread(OwnerType ownerType, boolean unguarded) throws Exception {
+        final Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, 256, 2, 16);
         final HandledObject o = recycler.get();
         final HandledObject o2 = recycler.get();
 
@@ -334,9 +469,10 @@ public class RecyclerTest {
         assertNotSame(recycler.get(), o2);
     }
 
-    @Test
-    public void testRecycleAtTwoThreadsMulti() throws Exception {
-        final Recycler<HandledObject> recycler = newRecycler(256);
+    @ParameterizedTest
+    @MethodSource("ownerTypeAndUnguarded")
+    public void testRecycleAtTwoThreadsMulti(OwnerType ownerType, boolean unguarded) throws Exception {
+        final Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, 256);
         final HandledObject o = recycler.get();
 
         ExecutorService single = Executors.newSingleThreadExecutor(new ThreadFactory() {
@@ -376,10 +512,11 @@ public class RecyclerTest {
         single.shutdown();
     }
 
-    @Test
-    public void testMaxCapacityWithRecycleAtDifferentThread() throws Exception {
+    @ParameterizedTest
+    @MethodSource("notNoneOwnerAndUnguarded")
+    public void testMaxCapacityWithRecycleAtDifferentThread(OwnerType ownerType, boolean unguarded) throws Exception {
         final int maxCapacity = 4;
-        final Recycler<HandledObject> recycler = newRecycler(maxCapacity, 4, 4);
+        final Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, maxCapacity, 4, 4);
 
         // Borrow 2 * maxCapacity objects.
         // Return the half from the same thread.
@@ -414,18 +551,15 @@ public class RecyclerTest {
         assertEquals(0, recycler.threadLocalSize());
     }
 
-    @Test
-    public void testDiscardingExceedingElementsWithRecycleAtDifferentThread() throws Exception {
+    @ParameterizedTest
+    @MethodSource("notNoneOwnerAndUnguarded")
+    public void testDiscardingExceedingElementsWithRecycleAtDifferentThread(OwnerType ownerType, boolean unguarded)
+            throws Exception {
         final int maxCapacity = 32;
         final AtomicInteger instancesCount = new AtomicInteger(0);
 
-        final Recycler<HandledObject> recycler = new Recycler<HandledObject>(maxCapacity) {
-            @Override
-            protected HandledObject newObject(Recycler.Handle<HandledObject> handle) {
-                instancesCount.incrementAndGet();
-                return new HandledObject(handle);
-            }
-        };
+        final Recycler<HandledObject> recycler = newRecycler(ownerType, unguarded, maxCapacity, ignore ->
+                instancesCount.incrementAndGet());
 
         // Borrow 2 * maxCapacity objects.
         final HandledObject[] array = new HandledObject[maxCapacity * 2];
diff --git a/microbench/src/main/java/io/netty/microbench/util/RecyclerBenchmark.java b/microbench/src/main/java/io/netty/microbench/util/RecyclerBenchmark.java
index 2a3235c502..5fe62f6538 100644
--- a/microbench/src/main/java/io/netty/microbench/util/RecyclerBenchmark.java
+++ b/microbench/src/main/java/io/netty/microbench/util/RecyclerBenchmark.java
@@ -18,18 +18,21 @@ package io.netty.microbench.util;
 import io.netty.util.Recycler;
 import io.netty.util.Recycler.EnhancedHandle;
 import io.netty.util.internal.PlatformDependent;
-import org.jctools.queues.MpmcArrayQueue;
-import org.jctools.queues.atomic.MpmcAtomicArrayQueue;
+import org.jctools.queues.SpscArrayQueue;
+import org.jctools.queues.atomic.SpscAtomicArrayQueue;
+import org.openjdk.jmh.annotations.AuxCounters;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Group;
 import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
 import org.openjdk.jmh.annotations.OutputTimeUnit;
+import org.openjdk.jmh.annotations.Param;
 import org.openjdk.jmh.annotations.Scope;
 import org.openjdk.jmh.annotations.Setup;
 import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.Warmup;
+import org.openjdk.jmh.infra.BenchmarkParams;
 import org.openjdk.jmh.infra.Control;
 import org.openjdk.jmh.runner.options.ChainedOptionsBuilder;
 
@@ -73,39 +76,76 @@ public class RecyclerBenchmark extends AbstractMicrobenchmark {
 
     @State(Scope.Benchmark)
     public static class ProducerConsumerState {
+
+        @Param({ "false", "true" })
+        boolean unguarded;
+
+        @Param({ "false", "true" })
+        boolean fastThreadLocal;
+
         Queue<DummyObject> queue;
 
         Recycler<DummyObject> recycler;
 
         @Setup
-        public void init() {
-            queue = PlatformDependent.hasUnsafe()? new MpmcArrayQueue<DummyObject>(100) :
-                    new MpmcAtomicArrayQueue<DummyObject>(100);
-            recycler = new Recycler<DummyObject>() {
-                @Override
-                protected DummyObject newObject(Recycler.Handle<DummyObject> handle) {
-                    return new DummyObject((EnhancedHandle<DummyObject>) handle);
+        public void init(BenchmarkParams params) {
+            if (params.getBenchmark().endsWith("roducerConsumer")) {
+                final int threads = params.getThreads();
+                if (threads != 2) {
+                    throw new IllegalStateException("ProducerConsumerState only supports exactly 2 threads");
                 }
-            };
+            }
+            queue = PlatformDependent.hasUnsafe()?
+                    new SpscArrayQueue<>(100) : new SpscAtomicArrayQueue<>(100);
+            recycler = !fastThreadLocal?
+                    new Recycler<DummyObject>(Thread.currentThread(), unguarded) {
+                        @Override
+                        protected DummyObject newObject(Recycler.Handle<DummyObject> handle) {
+                            return new DummyObject((EnhancedHandle<DummyObject>) handle);
+                        }
+                    } :
+                    new Recycler<DummyObject>(unguarded) {
+                        @Override
+                        protected DummyObject newObject(Recycler.Handle<DummyObject> handle) {
+                            return new DummyObject((EnhancedHandle<DummyObject>) handle);
+                        }
+                    };
         }
     }
 
+    @AuxCounters
+    @State(Scope.Thread)
+    public static class ProducerStats {
+        public long fullQ;
+    }
+
     // The allocation stats are the main thing interesting about this benchmark
     @Benchmark
     @Group("producerConsumer")
-    public void producer(ProducerConsumerState state, Control control) throws Exception {
+    @BenchmarkMode(Mode.Throughput)
+    @OutputTimeUnit(TimeUnit.MICROSECONDS)
+    public void producer(ProducerConsumerState state, Control control, ProducerStats stats) throws Exception {
         Queue<DummyObject> queue = state.queue;
         DummyObject object = state.recycler.get();
         while (!control.stopMeasurement) {
             if (queue.offer(object)) {
                 break;
             }
+            stats.fullQ++;
         }
     }
 
+    @AuxCounters
+    @State(Scope.Thread)
+    public static class ConsumerStats {
+        public long emptyQ;
+    }
+
     @Benchmark
     @Group("producerConsumer")
-    public void consumer(ProducerConsumerState state, Control control) throws Exception {
+    @BenchmarkMode(Mode.Throughput)
+    @OutputTimeUnit(TimeUnit.MICROSECONDS)
+    public void consumer(ProducerConsumerState state, Control control, ConsumerStats stats) throws Exception {
         Queue<DummyObject> queue = state.queue;
         DummyObject object;
         do {
@@ -114,25 +154,27 @@ public class RecyclerBenchmark extends AbstractMicrobenchmark {
                 object.recycle();
                 return;
             }
+            stats.emptyQ++;
         } while (!control.stopMeasurement);
     }
 
     // The allocation stats are the main thing interesting about this benchmark
     @Benchmark
     @Group("unguardedProducerConsumer")
-    public void unguardedProducer(ProducerConsumerState state, Control control) throws Exception {
+    public void unguardedProducer(ProducerConsumerState state, Control control, ProducerStats stats) throws Exception {
         Queue<DummyObject> queue = state.queue;
         DummyObject object = state.recycler.get();
         while (!control.stopMeasurement) {
             if (queue.offer(object)) {
                 break;
             }
+            stats.fullQ++;
         }
     }
 
     @Benchmark
     @Group("unguardedProducerConsumer")
-    public void unguardedConsumer(ProducerConsumerState state, Control control) throws Exception {
+    public void unguardedConsumer(ProducerConsumerState state, Control control, ConsumerStats stats) throws Exception {
         Queue<DummyObject> queue = state.queue;
         DummyObject object;
         do {
@@ -141,6 +183,7 @@ public class RecyclerBenchmark extends AbstractMicrobenchmark {
                 object.unguardedRecycle();
                 return;
             }
+            stats.emptyQ++;
         } while (!control.stopMeasurement);
     }
 
