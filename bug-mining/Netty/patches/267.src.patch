diff --git a/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java
index c143dde072..3086fd76f5 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java
@@ -16,6 +16,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.Recycler.EnhancedHandle;
 import io.netty.util.internal.ObjectPool.Handle;
 
 import java.nio.ByteBuffer;
@@ -26,7 +27,7 @@ import java.nio.ByteOrder;
  */
 abstract class AbstractPooledDerivedByteBuf extends AbstractReferenceCountedByteBuf {
 
-    private final Handle<AbstractPooledDerivedByteBuf> recyclerHandle;
+    private final EnhancedHandle<AbstractPooledDerivedByteBuf> recyclerHandle;
     private AbstractByteBuf rootParent;
     /**
      * Deallocations of a pooled derived buffer should always propagate through the entire chain of derived buffers.
@@ -39,7 +40,7 @@ abstract class AbstractPooledDerivedByteBuf extends AbstractReferenceCountedByte
     @SuppressWarnings("unchecked")
     AbstractPooledDerivedByteBuf(Handle<? extends AbstractPooledDerivedByteBuf> recyclerHandle) {
         super(0);
-        this.recyclerHandle = (Handle<AbstractPooledDerivedByteBuf>) recyclerHandle;
+        this.recyclerHandle = (EnhancedHandle<AbstractPooledDerivedByteBuf>) recyclerHandle;
     }
 
     // Called from within SimpleLeakAwareByteBuf and AdvancedLeakAwareByteBuf.
@@ -82,7 +83,7 @@ abstract class AbstractPooledDerivedByteBuf extends AbstractReferenceCountedByte
         // otherwise it is possible that the same AbstractPooledDerivedByteBuf is again obtained and init(...) is
         // called before we actually have a chance to call release(). This leads to call release() on the wrong parent.
         ByteBuf parent = this.parent;
-        recyclerHandle.recycle(this);
+        recyclerHandle.unguardedRecycle(this);
         parent.release();
     }
 
diff --git a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
index 3a2c9994a8..61a93cb91a 100644
--- a/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
+++ b/buffer/src/main/java/io/netty/buffer/ByteBufUtil.java
@@ -19,6 +19,7 @@ import io.netty.util.AsciiString;
 import io.netty.util.ByteProcessor;
 import io.netty.util.CharsetUtil;
 import io.netty.util.IllegalReferenceCountException;
+import io.netty.util.Recycler.EnhancedHandle;
 import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.internal.MathUtil;
 import io.netty.util.internal.ObjectPool;
@@ -1632,11 +1633,11 @@ public final class ByteBufUtil {
             return buf;
         }
 
-        private final Handle<ThreadLocalUnsafeDirectByteBuf> handle;
+        private final EnhancedHandle<ThreadLocalUnsafeDirectByteBuf> handle;
 
         private ThreadLocalUnsafeDirectByteBuf(Handle<ThreadLocalUnsafeDirectByteBuf> handle) {
             super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);
-            this.handle = handle;
+            this.handle = (EnhancedHandle<ThreadLocalUnsafeDirectByteBuf>) handle;
         }
 
         @Override
@@ -1645,7 +1646,7 @@ public final class ByteBufUtil {
                 super.deallocate();
             } else {
                 clear();
-                handle.recycle(this);
+                handle.unguardedRecycle(this);
             }
         }
     }
@@ -1666,11 +1667,11 @@ public final class ByteBufUtil {
             return buf;
         }
 
-        private final Handle<ThreadLocalDirectByteBuf> handle;
+        private final EnhancedHandle<ThreadLocalDirectByteBuf> handle;
 
         private ThreadLocalDirectByteBuf(Handle<ThreadLocalDirectByteBuf> handle) {
             super(UnpooledByteBufAllocator.DEFAULT, 256, Integer.MAX_VALUE);
-            this.handle = handle;
+            this.handle = (EnhancedHandle<ThreadLocalDirectByteBuf>) handle;
         }
 
         @Override
@@ -1679,7 +1680,7 @@ public final class ByteBufUtil {
                 super.deallocate();
             } else {
                 clear();
-                handle.recycle(this);
+                handle.unguardedRecycle(this);
             }
         }
     }
diff --git a/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
index cbaa7a485b..fc4f8062e8 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolThreadCache.java
@@ -20,6 +20,7 @@ package io.netty.buffer;
 import static io.netty.util.internal.ObjectUtil.checkPositiveOrZero;
 
 import io.netty.buffer.PoolArena.SizeClass;
+import io.netty.util.Recycler.EnhancedHandle;
 import io.netty.util.internal.MathUtil;
 import io.netty.util.internal.ObjectPool;
 import io.netty.util.internal.ObjectPool.Handle;
@@ -377,7 +378,7 @@ final class PoolThreadCache {
             boolean queued = queue.offer(entry);
             if (!queued) {
                 // If it was not possible to cache the chunk, immediately recycle the entry
-                entry.recycle();
+                entry.unguardedRecycle();
             }
 
             return queued;
@@ -392,7 +393,7 @@ final class PoolThreadCache {
                 return false;
             }
             initBuf(entry.chunk, entry.nioBuffer, entry.handle, buf, reqCapacity, threadCache);
-            entry.recycle();
+            entry.unguardedRecycle();
 
             // allocations is not thread-safe which is fine as this is only called from the same thread all time.
             ++ allocations;
@@ -451,14 +452,14 @@ final class PoolThreadCache {
         }
 
         static final class Entry<T> {
-            final Handle<Entry<?>> recyclerHandle;
+            final EnhancedHandle<Entry<?>> recyclerHandle;
             PoolChunk<T> chunk;
             ByteBuffer nioBuffer;
             long handle = -1;
             int normCapacity;
 
             Entry(Handle<Entry<?>> recyclerHandle) {
-                this.recyclerHandle = recyclerHandle;
+                this.recyclerHandle = (EnhancedHandle<Entry<?>>) recyclerHandle;
             }
 
             void recycle() {
@@ -467,6 +468,13 @@ final class PoolThreadCache {
                 handle = -1;
                 recyclerHandle.recycle(this);
             }
+
+            void unguardedRecycle() {
+                chunk = null;
+                nioBuffer = null;
+                handle = -1;
+                recyclerHandle.unguardedRecycle(this);
+            }
         }
 
         @SuppressWarnings("rawtypes")
diff --git a/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
index a072bb3e63..7e970f6917 100644
--- a/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/PooledByteBuf.java
@@ -16,6 +16,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.Recycler.EnhancedHandle;
 import io.netty.util.internal.ObjectPool.Handle;
 
 import java.io.IOException;
@@ -28,7 +29,7 @@ import java.nio.channels.ScatteringByteChannel;
 
 abstract class PooledByteBuf<T> extends AbstractReferenceCountedByteBuf {
 
-    private final Handle<PooledByteBuf<T>> recyclerHandle;
+    private final EnhancedHandle<PooledByteBuf<T>> recyclerHandle;
 
     protected PoolChunk<T> chunk;
     protected long handle;
@@ -43,7 +44,7 @@ abstract class PooledByteBuf<T> extends AbstractReferenceCountedByteBuf {
     @SuppressWarnings("unchecked")
     protected PooledByteBuf(Handle<? extends PooledByteBuf<T>> recyclerHandle, int maxCapacity) {
         super(maxCapacity);
-        this.recyclerHandle = (Handle<PooledByteBuf<T>>) recyclerHandle;
+        this.recyclerHandle = (EnhancedHandle<PooledByteBuf<T>>) recyclerHandle;
     }
 
     void init(PoolChunk<T> chunk, ByteBuffer nioBuffer,
@@ -177,14 +178,10 @@ abstract class PooledByteBuf<T> extends AbstractReferenceCountedByteBuf {
             tmpNioBuf = null;
             chunk = null;
             cache = null;
-            recycle();
+            this.recyclerHandle.unguardedRecycle(this);
         }
     }
 
-    private void recycle() {
-        recyclerHandle.recycle(this);
-    }
-
     protected final int idx(int index) {
         return offset + index;
     }
diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index 6f5b01eaa5..3f78aecd44 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -20,6 +20,7 @@ import io.netty.util.concurrent.FastThreadLocalThread;
 import io.netty.util.internal.ObjectPool;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.UnstableApi;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 import org.jctools.queues.MessagePassingQueue;
@@ -40,12 +41,17 @@ import static java.lang.Math.min;
  */
 public abstract class Recycler<T> {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(Recycler.class);
-    private static final Handle<?> NOOP_HANDLE = new Handle<Object>() {
+    private static final EnhancedHandle<?> NOOP_HANDLE = new EnhancedHandle<Object>() {
         @Override
         public void recycle(Object object) {
             // NOOP
         }
 
+        @Override
+        public void unguardedRecycle(final Object object) {
+            // NOOP
+        }
+
         @Override
         public String toString() {
             return "NOOP_HANDLE";
@@ -216,7 +222,16 @@ public abstract class Recycler<T> {
     @SuppressWarnings("ClassNameSameAsAncestorName") // Can't change this due to compatibility.
     public interface Handle<T> extends ObjectPool.Handle<T>  { }
 
-    private static final class DefaultHandle<T> implements Handle<T> {
+    @UnstableApi
+    public abstract static class EnhancedHandle<T> implements Handle<T> {
+
+        public abstract void unguardedRecycle(Object object);
+
+        private EnhancedHandle() {
+        }
+    }
+
+    private static final class DefaultHandle<T> extends EnhancedHandle<T> {
         private static final int STATE_CLAIMED = 0;
         private static final int STATE_AVAILABLE = 1;
         private static final AtomicIntegerFieldUpdater<DefaultHandle<?>> STATE_UPDATER;
@@ -239,7 +254,15 @@ public abstract class Recycler<T> {
             if (object != value) {
                 throw new IllegalArgumentException("object does not belong to handle");
             }
-            localPool.release(this);
+            localPool.release(this, true);
+        }
+
+        @Override
+        public void unguardedRecycle(Object object) {
+            if (object != value) {
+                throw new IllegalArgumentException("object does not belong to handle");
+            }
+            localPool.release(this, false);
         }
 
         T get() {
@@ -252,7 +275,7 @@ public abstract class Recycler<T> {
 
         void toClaimed() {
             assert state == STATE_AVAILABLE;
-            state = STATE_CLAIMED;
+            STATE_UPDATER.lazySet(this, STATE_CLAIMED);
         }
 
         void toAvailable() {
@@ -261,6 +284,14 @@ public abstract class Recycler<T> {
                 throw new IllegalStateException("Object has been recycled already.");
             }
         }
+
+        void unguardedToAvailable() {
+            int prev = state;
+            if (prev == STATE_AVAILABLE) {
+                throw new IllegalStateException("Object has been recycled already.");
+            }
+            STATE_UPDATER.lazySet(this, STATE_AVAILABLE);
+        }
     }
 
     private static final class LocalPool<T> implements MessagePassingQueue.Consumer<DefaultHandle<T>> {
@@ -301,8 +332,12 @@ public abstract class Recycler<T> {
             return handle;
         }
 
-        void release(DefaultHandle<T> handle) {
-            handle.toAvailable();
+        void release(DefaultHandle<T> handle, boolean guarded) {
+            if (guarded) {
+                handle.toAvailable();
+            } else {
+                handle.unguardedToAvailable();
+            }
             Thread owner = this.owner;
             if (owner != null && Thread.currentThread() == owner && batch.size() < chunkSize) {
                 accept(handle);
diff --git a/common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java b/common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java
index 8e4abd8ff6..760b95d3f3 100644
--- a/common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java
+++ b/common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java
@@ -112,7 +112,8 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
      * Resets the reference count to 1
      */
     public final void resetRefCnt(T instance) {
-        updater().set(instance, initialValue());
+        // no need of a volatile set, it should happen in a quiescent state
+        updater().lazySet(instance, initialValue());
     }
 
     public final T retain(T instance) {
diff --git a/microbench/src/main/java/io/netty/microbench/util/RecyclerBenchmark.java b/microbench/src/main/java/io/netty/microbench/util/RecyclerBenchmark.java
index eb02774dbb..2a3235c502 100644
--- a/microbench/src/main/java/io/netty/microbench/util/RecyclerBenchmark.java
+++ b/microbench/src/main/java/io/netty/microbench/util/RecyclerBenchmark.java
@@ -16,6 +16,10 @@
 package io.netty.microbench.util;
 
 import io.netty.util.Recycler;
+import io.netty.util.Recycler.EnhancedHandle;
+import io.netty.util.internal.PlatformDependent;
+import org.jctools.queues.MpmcArrayQueue;
+import org.jctools.queues.atomic.MpmcAtomicArrayQueue;
 import org.openjdk.jmh.annotations.Benchmark;
 import org.openjdk.jmh.annotations.BenchmarkMode;
 import org.openjdk.jmh.annotations.Group;
@@ -23,12 +27,13 @@ import org.openjdk.jmh.annotations.Measurement;
 import org.openjdk.jmh.annotations.Mode;
 import org.openjdk.jmh.annotations.OutputTimeUnit;
 import org.openjdk.jmh.annotations.Scope;
+import org.openjdk.jmh.annotations.Setup;
 import org.openjdk.jmh.annotations.State;
 import org.openjdk.jmh.annotations.Warmup;
 import org.openjdk.jmh.infra.Control;
 import org.openjdk.jmh.runner.options.ChainedOptionsBuilder;
 
-import java.util.concurrent.ArrayBlockingQueue;
+import java.util.Queue;
 import java.util.concurrent.TimeUnit;
 
 @Warmup(iterations = AbstractMicrobenchmarkBase.DEFAULT_WARMUP_ITERATIONS, time = 1)
@@ -36,12 +41,6 @@ import java.util.concurrent.TimeUnit;
 @BenchmarkMode(Mode.AverageTime)
 @OutputTimeUnit(TimeUnit.NANOSECONDS)
 public class RecyclerBenchmark extends AbstractMicrobenchmark {
-    private Recycler<DummyObject> recycler = new Recycler<DummyObject>() {
-        @Override
-        protected DummyObject newObject(Recycler.Handle<DummyObject> handle) {
-            return new DummyObject(handle);
-        }
-    };
 
     @Override
     protected ChainedOptionsBuilder newOptionsBuilder() throws Exception {
@@ -54,28 +53,49 @@ public class RecyclerBenchmark extends AbstractMicrobenchmark {
     }
 
     @Benchmark
-    public DummyObject recyclerGetAndOrphan() {
-        return recycler.get();
+    public DummyObject recyclerGetAndOrphan(ProducerConsumerState state) {
+        return state.recycler.get();
     }
 
     @Benchmark
-    public DummyObject recyclerGetAndRecycle() {
-        DummyObject o = recycler.get();
+    public DummyObject recyclerGetAndRecycle(ProducerConsumerState state) {
+        DummyObject o = state.recycler.get();
         o.recycle();
         return o;
     }
 
+    @Benchmark
+    public DummyObject recyclerGetAndUnguardedRecycle(ProducerConsumerState state) {
+        DummyObject o = state.recycler.get();
+        o.unguardedRecycle();
+        return o;
+    }
+
     @State(Scope.Benchmark)
     public static class ProducerConsumerState {
-        final ArrayBlockingQueue<DummyObject> queue = new ArrayBlockingQueue<DummyObject>(100);
+        Queue<DummyObject> queue;
+
+        Recycler<DummyObject> recycler;
+
+        @Setup
+        public void init() {
+            queue = PlatformDependent.hasUnsafe()? new MpmcArrayQueue<DummyObject>(100) :
+                    new MpmcAtomicArrayQueue<DummyObject>(100);
+            recycler = new Recycler<DummyObject>() {
+                @Override
+                protected DummyObject newObject(Recycler.Handle<DummyObject> handle) {
+                    return new DummyObject((EnhancedHandle<DummyObject>) handle);
+                }
+            };
+        }
     }
 
     // The allocation stats are the main thing interesting about this benchmark
     @Benchmark
     @Group("producerConsumer")
     public void producer(ProducerConsumerState state, Control control) throws Exception {
-        ArrayBlockingQueue<DummyObject> queue = state.queue;
-        DummyObject object = recycler.get();
+        Queue<DummyObject> queue = state.queue;
+        DummyObject object = state.recycler.get();
         while (!control.stopMeasurement) {
             if (queue.offer(object)) {
                 break;
@@ -86,9 +106,10 @@ public class RecyclerBenchmark extends AbstractMicrobenchmark {
     @Benchmark
     @Group("producerConsumer")
     public void consumer(ProducerConsumerState state, Control control) throws Exception {
+        Queue<DummyObject> queue = state.queue;
         DummyObject object;
         do {
-            object = state.queue.poll();
+            object = queue.poll();
             if (object != null) {
                 object.recycle();
                 return;
@@ -96,9 +117,36 @@ public class RecyclerBenchmark extends AbstractMicrobenchmark {
         } while (!control.stopMeasurement);
     }
 
+    // The allocation stats are the main thing interesting about this benchmark
+    @Benchmark
+    @Group("unguardedProducerConsumer")
+    public void unguardedProducer(ProducerConsumerState state, Control control) throws Exception {
+        Queue<DummyObject> queue = state.queue;
+        DummyObject object = state.recycler.get();
+        while (!control.stopMeasurement) {
+            if (queue.offer(object)) {
+                break;
+            }
+        }
+    }
+
+    @Benchmark
+    @Group("unguardedProducerConsumer")
+    public void unguardedConsumer(ProducerConsumerState state, Control control) throws Exception {
+        Queue<DummyObject> queue = state.queue;
+        DummyObject object;
+        do {
+            object = queue.poll();
+            if (object != null) {
+                object.unguardedRecycle();
+                return;
+            }
+        } while (!control.stopMeasurement);
+    }
+
     @SuppressWarnings("unused")
     private static final class DummyObject {
-        private final Recycler.Handle<DummyObject> handle;
+        private final EnhancedHandle<DummyObject> handle;
         private long l1;
         private long l2;
         private long l3;
@@ -114,12 +162,16 @@ public class RecyclerBenchmark extends AbstractMicrobenchmark {
             this(null);
         }
 
-        DummyObject(Recycler.Handle<DummyObject> handle) {
+        DummyObject(EnhancedHandle<DummyObject> handle) {
             this.handle = handle;
         }
 
         public void recycle() {
             handle.recycle(this);
         }
+
+        public void unguardedRecycle() {
+            handle.unguardedRecycle(this);
+        }
     }
 }
diff --git a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
index 4facd2751a..eb0f5fa718 100644
--- a/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
+++ b/transport/src/main/java/io/netty/channel/ChannelOutboundBuffer.java
@@ -19,6 +19,7 @@ import io.netty.buffer.ByteBuf;
 import io.netty.buffer.ByteBufHolder;
 import io.netty.buffer.Unpooled;
 import io.netty.channel.socket.nio.NioSocketChannel;
+import io.netty.util.Recycler.EnhancedHandle;
 import io.netty.util.ReferenceCountUtil;
 import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.internal.InternalThreadLocalMap;
@@ -283,7 +284,7 @@ public final class ChannelOutboundBuffer {
         }
 
         // recycle the entry
-        e.recycle();
+        e.unguardedRecycle();
 
         return true;
     }
@@ -319,7 +320,7 @@ public final class ChannelOutboundBuffer {
         }
 
         // recycle the entry
-        e.recycle();
+        e.unguardedRecycle();
 
         return true;
     }
@@ -708,7 +709,7 @@ public final class ChannelOutboundBuffer {
                     ReferenceCountUtil.safeRelease(e.msg);
                     safeFail(e.promise, cause);
                 }
-                e = e.recycleAndGetNext();
+                e = e.unguardedRecycleAndGetNext();
             }
         } finally {
             inFail = false;
@@ -814,7 +815,7 @@ public final class ChannelOutboundBuffer {
             }
         });
 
-        private final Handle<Entry> handle;
+        private final EnhancedHandle<Entry> handle;
         Entry next;
         Object msg;
         ByteBuffer[] bufs;
@@ -827,7 +828,7 @@ public final class ChannelOutboundBuffer {
         boolean cancelled;
 
         private Entry(Handle<Entry> handle) {
-            this.handle = handle;
+            this.handle = (EnhancedHandle<Entry>) handle;
         }
 
         static Entry newInstance(Object msg, int size, long total, ChannelPromise promise) {
@@ -858,7 +859,7 @@ public final class ChannelOutboundBuffer {
             return 0;
         }
 
-        void recycle() {
+        void unguardedRecycle() {
             next = null;
             bufs = null;
             buf = null;
@@ -869,12 +870,12 @@ public final class ChannelOutboundBuffer {
             pendingSize = 0;
             count = -1;
             cancelled = false;
-            handle.recycle(this);
+            handle.unguardedRecycle(this);
         }
 
-        Entry recycleAndGetNext() {
+        Entry unguardedRecycleAndGetNext() {
             Entry next = this.next;
-            recycle();
+            unguardedRecycle();
             return next;
         }
     }
