diff --git a/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
index 1dab719553..b568d17690 100644
--- a/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
+++ b/common/src/main/java/io/netty/util/concurrent/SingleThreadEventExecutor.java
@@ -874,6 +874,8 @@ public abstract class SingleThreadEventExecutor extends AbstractScheduledEventEx
             if (STATE_UPDATER.compareAndSet(this, ST_STARTED, ST_SUSPENDING)) {
                 wakeup(inEventLoop());
                 return true;
+            } else if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_SUSPENDED)) {
+                return true;
             }
             int currentState = state;
             return currentState == ST_SUSPENDED || currentState == ST_SUSPENDING;
diff --git a/common/src/test/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactoryTest.java b/common/src/test/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactoryTest.java
index a238f58229..82236bec48 100644
--- a/common/src/test/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactoryTest.java
+++ b/common/src/test/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactoryTest.java
@@ -168,6 +168,19 @@ public class AutoScalingEventExecutorChooserFactoryTest {
         }
     }
 
+    @Test
+    @Timeout(30)
+    void testScaleDownWhenExecutorIsNotStarted() throws InterruptedException {
+        TestEventExecutorGroup group = new TestEventExecutorGroup(2, 4, 50, TimeUnit.MILLISECONDS);
+        try {
+            // Do not start executors
+            Thread.sleep(200);
+            assertEquals(2, group.activeExecutorCount(), "Should not scale below minThreads");
+        } finally {
+            group.shutdownGracefully().syncUninterruptibly();
+        }
+    }
+
     @Test
     @Timeout(30)
     void testScaleDownDoesNotGoBelowMinThreads() throws InterruptedException {
diff --git a/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java b/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java
index d21ae0afb9..a9889179fa 100644
--- a/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java
+++ b/common/src/test/java/io/netty/util/concurrent/SingleThreadEventExecutorTest.java
@@ -142,6 +142,32 @@ public class SingleThreadEventExecutorTest {
         }
     }
 
+    @Test
+    void testSuspensionWhenExecutorIsNotStarted() throws Exception {
+        TestThreadFactory threadFactory = new TestThreadFactory();
+        final SingleThreadEventExecutor executor = new SuspendingSingleThreadEventExecutor(threadFactory);
+        // suspend when executor is not started yet
+        assertTrue(executor.trySuspend());
+        assertTrue(executor.isSuspended());
+
+        // recover from suspension by executing a task
+        LatchTask task1 = new LatchTask();
+        executor.execute(task1);
+        Thread currentThread = threadFactory.threads.take();
+        assertFalse(executor.isSuspended());
+        task1.await();
+
+        executor.shutdownGracefully(0, 0, TimeUnit.MILLISECONDS).syncUninterruptibly();
+        currentThread.join();
+        assertFalse(executor.isSuspended());
+        assertTrue(executor.isShutdown());
+
+        // Guarantee that all threads were able to die...
+        while ((currentThread = threadFactory.threads.poll()) != null) {
+            currentThread.join();
+        }
+    }
+
     @Test
     @Timeout(value = 10, unit = TimeUnit.SECONDS)
     void testNotSuspendedUntilScheduledTaskIsCancelled() throws Exception {
