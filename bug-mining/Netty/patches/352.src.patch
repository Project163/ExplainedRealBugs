diff --git a/buffer/src/main/java/io/netty/buffer/PoolChunk.java b/buffer/src/main/java/io/netty/buffer/PoolChunk.java
index 319f7b7ea8..8dcc01b455 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolChunk.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java
@@ -16,6 +16,7 @@
 package io.netty.buffer;
 
 import io.netty.util.internal.CleanableDirectBuffer;
+import io.netty.util.internal.LongLongHashMap;
 import io.netty.util.internal.SystemPropertyUtil;
 
 import java.nio.ByteBuffer;
diff --git a/common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java b/common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java
index f4cb251373..e5761c859c 100644
--- a/common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java
+++ b/common/src/main/java/io/netty/util/concurrent/FastThreadLocalThread.java
@@ -16,10 +16,10 @@
 package io.netty.util.concurrent;
 
 import io.netty.util.internal.InternalThreadLocalMap;
+import io.netty.util.internal.LongLongHashMap;
 import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
-import java.util.Arrays;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -30,9 +30,10 @@ public class FastThreadLocalThread extends Thread {
     private static final InternalLogger logger = InternalLoggerFactory.getInstance(FastThreadLocalThread.class);
 
     /**
-     * Sorted array of thread IDs that are treated like {@link FastThreadLocalThread}.
+     * Set of thread IDs that are treated like {@link FastThreadLocalThread}.
      */
-    private static final AtomicReference<long[]> fallbackThreads = new AtomicReference<>(null);
+    private static final AtomicReference<FallbackThreadSet> fallbackThreads =
+            new AtomicReference<>(FallbackThreadSet.EMPTY);
 
     // This will be set to true if we have a chance to wrap the Runnable.
     private final boolean cleanupFastThreadLocals;
@@ -144,11 +145,7 @@ public class FastThreadLocalThread extends Thread {
     }
 
     private static boolean isFastThreadLocalVirtualThread() {
-        long[] arr = fallbackThreads.get();
-        if (arr == null) {
-            return false;
-        }
-        return Arrays.binarySearch(arr, Thread.currentThread().getId()) >= 0;
+        return fallbackThreads.get().contains(currentThread().getId());
     }
 
     /**
@@ -169,37 +166,17 @@ public class FastThreadLocalThread extends Thread {
             throw new IllegalStateException("Caller is a real FastThreadLocalThread");
         }
         long id = current.getId();
-        fallbackThreads.updateAndGet(arr -> {
-            if (arr == null) {
-                return new long[] { id };
-            }
-            int index = Arrays.binarySearch(arr, id);
-            if (index >= 0) {
+        fallbackThreads.updateAndGet(set -> {
+            if (set.contains(id)) {
                 throw new IllegalStateException("Reentrant call to run()");
             }
-            index = ~index; // same as -(index + 1)
-            long[] next = new long[arr.length + 1];
-            System.arraycopy(arr, 0, next, 0, index);
-            next[index] = id;
-            System.arraycopy(arr, index, next, index + 1, arr.length - index);
-            return next;
+            return set.add(id);
         });
+
         try {
             runnable.run();
         } finally {
-            fallbackThreads.getAndUpdate(arr -> {
-                if (arr == null || (arr.length == 1 && arr[0] == id)) {
-                    return null;
-                }
-                int index = Arrays.binarySearch(arr, id);
-                if (index < 0) {
-                    return arr;
-                }
-                long[] next = new long[arr.length - 1];
-                System.arraycopy(arr, 0, next, 0, index);
-                System.arraycopy(arr, index + 1, next, index, arr.length - index - 1);
-                return next;
-            });
+            fallbackThreads.getAndUpdate(set -> set.remove(id));
             FastThreadLocal.removeAll();
         }
     }
@@ -217,4 +194,63 @@ public class FastThreadLocalThread extends Thread {
     public boolean permitBlockingCalls() {
         return false;
     }
+
+    /**
+     * Immutable, thread-safe helper class that wraps {@link LongLongHashMap}
+     */
+    private static final class FallbackThreadSet {
+        static final FallbackThreadSet EMPTY = new FallbackThreadSet();
+        private static final long EMPTY_VALUE = 0L;
+
+        private final LongLongHashMap map;
+
+        private FallbackThreadSet() {
+            this.map = new LongLongHashMap(EMPTY_VALUE);
+        }
+
+        private FallbackThreadSet(LongLongHashMap map) {
+            this.map = map;
+        }
+
+        public boolean contains(long threadId) {
+            long key = threadId >>> 6;
+            long bit = 1L << (threadId & 63);
+
+            long bitmap = map.get(key);
+            return (bitmap & bit) != 0;
+        }
+
+        public FallbackThreadSet add(long threadId) {
+            long key = threadId >>> 6;
+            long bit = 1L << (threadId & 63);
+
+            LongLongHashMap newMap = new LongLongHashMap(map);
+            long oldBitmap = newMap.get(key);
+            long newBitmap = oldBitmap | bit;
+            newMap.put(key, newBitmap);
+
+            return new FallbackThreadSet(newMap);
+        }
+
+        public FallbackThreadSet remove(long threadId) {
+            long key = threadId >>> 6;
+            long bit = 1L << (threadId & 63);
+
+            long oldBitmap = map.get(key);
+            if ((oldBitmap & bit) == 0) {
+                return this;
+            }
+
+            LongLongHashMap newMap = new LongLongHashMap(map);
+            long newBitmap = oldBitmap & ~bit;
+
+            if (newBitmap != EMPTY_VALUE) {
+                newMap.put(key, newBitmap);
+            } else {
+                newMap.remove(key);
+            }
+
+            return new FallbackThreadSet(newMap);
+        }
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/LongLongHashMap.java b/common/src/main/java/io/netty/util/internal/LongLongHashMap.java
similarity index 88%
rename from buffer/src/main/java/io/netty/buffer/LongLongHashMap.java
rename to common/src/main/java/io/netty/util/internal/LongLongHashMap.java
index e962840e32..4baad956a6 100644
--- a/buffer/src/main/java/io/netty/buffer/LongLongHashMap.java
+++ b/common/src/main/java/io/netty/util/internal/LongLongHashMap.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 The Netty Project
+ * Copyright 2025 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -13,13 +13,11 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.buffer;
+package io.netty.util.internal;
 
-/**
- * Internal primitive map implementation that is specifically optimised for the runs availability map use case in {@link
- * PoolChunk}.
- */
-final class LongLongHashMap {
+import java.util.Arrays;
+
+public final class LongLongHashMap {
     private static final int MASK_TEMPLATE = ~1;
     private int mask;
     private long[] array;
@@ -27,7 +25,7 @@ final class LongLongHashMap {
     private long zeroVal;
     private final long emptyVal;
 
-    LongLongHashMap(long emptyVal) {
+    public LongLongHashMap(long emptyVal) {
         this.emptyVal = emptyVal;
         zeroVal = emptyVal;
         int initialSize = 32;
@@ -36,6 +34,14 @@ final class LongLongHashMap {
         computeMaskAndProbe();
     }
 
+    public LongLongHashMap(LongLongHashMap other) {
+        this.mask = other.mask;
+        this.array = Arrays.copyOf(other.array, other.array.length);
+        this.maxProbe = other.maxProbe;
+        this.zeroVal = other.zeroVal;
+        this.emptyVal = other.emptyVal;
+    }
+
     public long put(long key, long value) {
         if (key == 0) {
             long prev = zeroVal;
diff --git a/buffer/src/test/java/io/netty/buffer/LongLongHashMapTest.java b/common/src/test/java/io/netty/util/internal/LongLongHashMapTest.java
similarity index 94%
rename from buffer/src/test/java/io/netty/buffer/LongLongHashMapTest.java
rename to common/src/test/java/io/netty/util/internal/LongLongHashMapTest.java
index 255fb68c03..4d4a926c31 100644
--- a/buffer/src/test/java/io/netty/buffer/LongLongHashMapTest.java
+++ b/common/src/test/java/io/netty/util/internal/LongLongHashMapTest.java
@@ -1,5 +1,5 @@
 /*
- * Copyright 2020 The Netty Project
+ * Copyright 2025 The Netty Project
  *
  * The Netty Project licenses this file to you under the Apache License,
  * version 2.0 (the "License"); you may not use this file except in compliance
@@ -13,7 +13,7 @@
  * License for the specific language governing permissions and limitations
  * under the License.
  */
-package io.netty.buffer;
+package io.netty.util.internal;
 
 import org.junit.jupiter.api.Test;
 
@@ -26,7 +26,7 @@ import java.util.concurrent.ThreadLocalRandom;
 
 import static org.assertj.core.api.Assertions.assertThat;
 
-class LongLongHashMapTest {
+public class LongLongHashMapTest {
     @Test
     public void zeroPutGetAndRemove() {
         LongLongHashMap map = new LongLongHashMap(-1);
@@ -60,7 +60,7 @@ class LongLongHashMapTest {
     @Test
     public void randomOperations() {
         int operations = 6000;
-        ThreadLocalRandom tlr = ThreadLocalRandom.current();
+        java.util.concurrent.ThreadLocalRandom tlr = ThreadLocalRandom.current();
         Map<Long, Long> expected = new HashMap<Long, Long>();
         LongLongHashMap actual = new LongLongHashMap(-1);
         OfLong itr = tlr.longs(0, operations).limit(operations * 50).iterator();
diff --git a/microbench/src/main/java/io/netty/microbench/concurrent/FastThreadLocalCheckBenchmark.java b/microbench/src/main/java/io/netty/microbench/concurrent/FastThreadLocalCheckBenchmark.java
new file mode 100644
index 0000000000..9507a33b45
--- /dev/null
+++ b/microbench/src/main/java/io/netty/microbench/concurrent/FastThreadLocalCheckBenchmark.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.microbench.concurrent;
+
+import io.netty.microbench.util.AbstractMicrobenchmark;
+import io.netty.util.concurrent.FastThreadLocalThread;
+import org.openjdk.jmh.annotations.Benchmark;
+import org.openjdk.jmh.annotations.BenchmarkMode;
+import org.openjdk.jmh.annotations.Measurement;
+import org.openjdk.jmh.annotations.Mode;
+import org.openjdk.jmh.annotations.OutputTimeUnit;
+import org.openjdk.jmh.annotations.Param;
+import org.openjdk.jmh.annotations.Scope;
+import org.openjdk.jmh.annotations.Setup;
+import org.openjdk.jmh.annotations.State;
+import org.openjdk.jmh.annotations.TearDown;
+import org.openjdk.jmh.annotations.Warmup;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+@Measurement(iterations = 10)
+@Warmup(iterations = 10)
+@BenchmarkMode(Mode.AverageTime)
+@State(Scope.Thread)
+@OutputTimeUnit(TimeUnit.NANOSECONDS)
+public class FastThreadLocalCheckBenchmark extends AbstractMicrobenchmark {
+
+    @Param({ "8", "16", "32", "64", "128", "256"})
+    public int eventLoops;
+    private Thread[] eventLoopThreads;
+    private CountDownLatch eventLoopControl;
+
+    public FastThreadLocalCheckBenchmark() {
+        super(true, true);
+    }
+
+    @Setup
+    public void setup() {
+        if (Thread.currentThread() instanceof FastThreadLocalThread) {
+            throw new IllegalStateException("This benchmark must not be run in a FastThreadLocalThread");
+        }
+
+        long benchmarkThreadId = Thread.currentThread().getId();
+        // create an ordered array of thread IDs which cause the maximum number of branches
+        // but still making it fairly predictable for the CPU.
+        long[] eventLoopIds = new long[eventLoops];
+        for (int i = 0; i < eventLoops; i++) {
+            eventLoopIds[i] = benchmarkThreadId + i + 1;
+        }
+
+        eventLoopControl = new CountDownLatch(1);
+        CountDownLatch eventLoopsRegistered = new CountDownLatch(eventLoops);
+        eventLoopThreads = new Thread[eventLoops];
+
+        class FastThreadLocalThread extends Thread {
+            private final long id;
+
+            FastThreadLocalThread(long id) {
+                this.id = id;
+            }
+
+            @Override
+            public long getId() {
+                return id;
+            }
+
+            @Override
+            public void run() {
+                io.netty.util.concurrent.FastThreadLocalThread.runWithFastThreadLocal(() -> {
+                    try {
+                        eventLoopsRegistered.countDown();
+                        eventLoopControl.await();
+                    } catch (InterruptedException e) {
+                        // ignore
+                    }
+                });
+            }
+        }
+
+        int i = 0;
+        for (long eventLoopId : eventLoopIds) {
+            FastThreadLocalThread thread = new FastThreadLocalThread(eventLoopId);
+            thread.start();
+            eventLoopThreads[i++] = thread;
+        }
+
+        try {
+            eventLoopsRegistered.await();
+        } catch (InterruptedException e) {
+            // wait till all event loops are registered.
+        }
+    }
+
+    @Benchmark
+    public boolean isFastThreadLocalThread() {
+        return FastThreadLocalThread.currentThreadHasFastThreadLocal();
+    }
+
+    @TearDown
+    public void tearDown() {
+        eventLoopControl.countDown();
+        for (Thread thread : eventLoopThreads) {
+            try {
+                thread.join();
+            } catch (InterruptedException e) {
+                // ignore
+            }
+        }
+    }
+}
