diff --git a/buffer/src/main/java/io/netty/buffer/PoolArena.java b/buffer/src/main/java/io/netty/buffer/PoolArena.java
index 20cbcac759..e4a3e27b18 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolArena.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolArena.java
@@ -25,6 +25,7 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.atomic.AtomicInteger;
+import java.util.concurrent.locks.ReentrantLock;
 
 import static io.netty.buffer.PoolChunk.isSubpage;
 import static java.lang.Math.max;
@@ -71,6 +72,8 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     // TODO: Test if adding padding helps under contention
     //private long pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;
 
+    private final ReentrantLock lock = new ReentrantLock();
+
     protected PoolArena(PooledByteBufAllocator parent, int pageSize,
           int pageShifts, int chunkSize, int cacheAlignment) {
         super(pageSize, pageShifts, chunkSize, cacheAlignment);
@@ -156,7 +159,8 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
          */
         final PoolSubpage<T> head = smallSubpagePools[sizeIdx];
         final boolean needsNormalAllocation;
-        synchronized (head) {
+        head.lock();
+        try {
             final PoolSubpage<T> s = head.next;
             needsNormalAllocation = s == head;
             if (!needsNormalAllocation) {
@@ -166,11 +170,16 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
                 assert handle >= 0;
                 s.chunk.initBufWithSubpage(buf, null, handle, reqCapacity, cache);
             }
+        } finally {
+            head.unlock();
         }
 
         if (needsNormalAllocation) {
-            synchronized (this) {
+            lock();
+            try {
                 allocateNormal(buf, reqCapacity, sizeIdx, cache);
+            } finally {
+                unlock();
             }
         }
 
@@ -183,14 +192,17 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
             // was able to allocate out of the cache so move on
             return;
         }
-        synchronized (this) {
+        lock();
+        try {
             allocateNormal(buf, reqCapacity, sizeIdx, cache);
             ++allocationsNormal;
+        } finally {
+            unlock();
         }
     }
 
-    // Method must be called inside synchronized(this) { ... } block
     private void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int sizeIdx, PoolThreadCache threadCache) {
+        assert lock.isHeldByCurrentThread();
         if (q050.allocate(buf, reqCapacity, sizeIdx, threadCache) ||
             q025.allocate(buf, reqCapacity, sizeIdx, threadCache) ||
             q000.allocate(buf, reqCapacity, sizeIdx, threadCache) ||
@@ -241,7 +253,8 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     void freeChunk(PoolChunk<T> chunk, long handle, int normCapacity, SizeClass sizeClass, ByteBuffer nioBuffer,
                    boolean finalizer) {
         final boolean destroyChunk;
-        synchronized (this) {
+        lock();
+        try {
             // We only call this if freeChunk is not called because of the PoolThreadCache finalizer as otherwise this
             // may fail due lazy class-loading in for example tomcat.
             if (!finalizer) {
@@ -257,6 +270,8 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
                 }
             }
             destroyChunk = !chunk.parent.free(chunk, handle, normCapacity, nioBuffer);
+        } finally {
+            unlock();
         }
         if (destroyChunk) {
             // destroyChunk not need to be called while holding the synchronized lock.
@@ -354,8 +369,11 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     @Override
     public long numAllocations() {
         final long allocsNormal;
-        synchronized (this) {
+        lock();
+        try {
             allocsNormal = allocationsNormal;
+        } finally {
+            unlock();
         }
         return allocationsSmall.value() + allocsNormal + allocationsHuge.value();
     }
@@ -371,15 +389,23 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     }
 
     @Override
-    public synchronized long numNormalAllocations() {
-        return allocationsNormal;
+    public long numNormalAllocations() {
+        lock();
+        try {
+            return allocationsNormal;
+        } finally {
+            unlock();
+        }
     }
 
     @Override
     public long numDeallocations() {
         final long deallocs;
-        synchronized (this) {
+        lock();
+        try {
             deallocs = deallocationsSmall + deallocationsNormal;
+        } finally {
+            unlock();
         }
         return deallocs + deallocationsHuge.value();
     }
@@ -390,13 +416,23 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     }
 
     @Override
-    public synchronized long numSmallDeallocations() {
-        return deallocationsSmall;
+    public long numSmallDeallocations() {
+        lock();
+        try {
+            return deallocationsSmall;
+        } finally {
+            unlock();
+        }
     }
 
     @Override
-    public synchronized long numNormalDeallocations() {
-        return deallocationsNormal;
+    public long numNormalDeallocations() {
+        lock();
+        try {
+            return deallocationsNormal;
+        } finally {
+            unlock();
+        }
     }
 
     @Override
@@ -413,8 +449,11 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     public  long numActiveAllocations() {
         long val = allocationsSmall.value() + allocationsHuge.value()
                 - deallocationsHuge.value();
-        synchronized (this) {
+        lock();
+        try {
             val += allocationsNormal - (deallocationsSmall + deallocationsNormal);
+        } finally {
+            unlock();
         }
         return max(val, 0);
     }
@@ -432,8 +471,11 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     @Override
     public long numActiveNormalAllocations() {
         final long val;
-        synchronized (this) {
+        lock();
+        try {
             val = allocationsNormal - deallocationsNormal;
+        } finally {
+            unlock();
         }
         return max(val, 0);
     }
@@ -446,12 +488,15 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     @Override
     public long numActiveBytes() {
         long val = activeBytesHuge.value();
-        synchronized (this) {
+        lock();
+        try {
             for (int i = 0; i < chunkListMetrics.size(); i++) {
                 for (PoolChunkMetric m: chunkListMetrics.get(i)) {
                     val += m.chunkSize();
                 }
             }
+        } finally {
+            unlock();
         }
         return max(0, val);
     }
@@ -462,12 +507,15 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
      */
     public long numPinnedBytes() {
         long val = activeBytesHuge.value(); // Huge chunks are exact-sized for the buffers they were allocated to.
-        synchronized (this) {
+        lock();
+        try {
             for (int i = 0; i < chunkListMetrics.size(); i++) {
                 for (PoolChunkMetric m: chunkListMetrics.get(i)) {
                     val += ((PoolChunk<?>) m).pinnedBytes();
                 }
             }
+        } finally {
+            unlock();
         }
         return max(0, val);
     }
@@ -479,37 +527,41 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
     protected abstract void destroyChunk(PoolChunk<T> chunk);
 
     @Override
-    public synchronized String toString() {
-        StringBuilder buf = new StringBuilder()
-            .append("Chunk(s) at 0~25%:")
-            .append(StringUtil.NEWLINE)
-            .append(qInit)
-            .append(StringUtil.NEWLINE)
-            .append("Chunk(s) at 0~50%:")
-            .append(StringUtil.NEWLINE)
-            .append(q000)
-            .append(StringUtil.NEWLINE)
-            .append("Chunk(s) at 25~75%:")
-            .append(StringUtil.NEWLINE)
-            .append(q025)
-            .append(StringUtil.NEWLINE)
-            .append("Chunk(s) at 50~100%:")
-            .append(StringUtil.NEWLINE)
-            .append(q050)
-            .append(StringUtil.NEWLINE)
-            .append("Chunk(s) at 75~100%:")
-            .append(StringUtil.NEWLINE)
-            .append(q075)
-            .append(StringUtil.NEWLINE)
-            .append("Chunk(s) at 100%:")
-            .append(StringUtil.NEWLINE)
-            .append(q100)
-            .append(StringUtil.NEWLINE)
-            .append("small subpages:");
-        appendPoolSubPages(buf, smallSubpagePools);
-        buf.append(StringUtil.NEWLINE);
-
-        return buf.toString();
+    public String toString() {
+        lock();
+        try {
+            StringBuilder buf = new StringBuilder()
+                    .append("Chunk(s) at 0~25%:")
+                    .append(StringUtil.NEWLINE)
+                    .append(qInit)
+                    .append(StringUtil.NEWLINE)
+                    .append("Chunk(s) at 0~50%:")
+                    .append(StringUtil.NEWLINE)
+                    .append(q000)
+                    .append(StringUtil.NEWLINE)
+                    .append("Chunk(s) at 25~75%:")
+                    .append(StringUtil.NEWLINE)
+                    .append(q025)
+                    .append(StringUtil.NEWLINE)
+                    .append("Chunk(s) at 50~100%:")
+                    .append(StringUtil.NEWLINE)
+                    .append(q050)
+                    .append(StringUtil.NEWLINE)
+                    .append("Chunk(s) at 75~100%:")
+                    .append(StringUtil.NEWLINE)
+                    .append(q075)
+                    .append(StringUtil.NEWLINE)
+                    .append("Chunk(s) at 100%:")
+                    .append(StringUtil.NEWLINE)
+                    .append(q100)
+                    .append(StringUtil.NEWLINE)
+                    .append("small subpages:");
+            appendPoolSubPages(buf, smallSubpagePools);
+            buf.append(StringUtil.NEWLINE);
+            return buf.toString();
+        } finally {
+            unlock();
+        }
     }
 
     private static void appendPoolSubPages(StringBuilder buf, PoolSubpage<?>[] subpages) {
@@ -687,4 +739,12 @@ abstract class PoolArena<T> extends SizeClasses implements PoolArenaMetric {
             }
         }
     }
+
+    void lock() {
+        lock.lock();
+    }
+
+    void unlock() {
+        lock.unlock();
+    }
 }
diff --git a/buffer/src/main/java/io/netty/buffer/PoolChunk.java b/buffer/src/main/java/io/netty/buffer/PoolChunk.java
index e25c260b6a..c7a0ffc22b 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolChunk.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolChunk.java
@@ -22,6 +22,7 @@ import java.nio.ByteBuffer;
 import java.util.ArrayDeque;
 import java.util.Deque;
 import java.util.PriorityQueue;
+import java.util.concurrent.locks.ReentrantLock;
 
 /**
  * Description of algorithm for PageRun/PoolSubpage allocation from PoolChunk
@@ -158,6 +159,8 @@ final class PoolChunk<T> implements PoolChunkMetric {
      */
     private final LongPriorityQueue[] runsAvail;
 
+    private final ReentrantLock runsAvailLock;
+
     /**
      * manage all subpages in this chunk
      */
@@ -200,6 +203,7 @@ final class PoolChunk<T> implements PoolChunkMetric {
         freeBytes = chunkSize;
 
         runsAvail = newRunsAvailqueueArray(maxPageIdx);
+        runsAvailLock = new ReentrantLock();
         runsAvailMap = new LongLongHashMap(-1);
         subpages = new PoolSubpage[chunkSize >> pageShifts];
 
@@ -221,6 +225,7 @@ final class PoolChunk<T> implements PoolChunkMetric {
         pageShifts = 0;
         runsAvailMap = null;
         runsAvail = null;
+        runsAvailLock = null;
         subpages = null;
         chunkSize = size;
         cachedNioBuffers = null;
@@ -282,8 +287,11 @@ final class PoolChunk<T> implements PoolChunkMetric {
     @Override
     public int usage() {
         final int freeBytes;
-        synchronized (arena) {
+        arena.lock();
+        try {
             freeBytes = this.freeBytes;
+        } finally {
+            arena.unlock();
         }
         return usage(freeBytes);
     }
@@ -329,7 +337,8 @@ final class PoolChunk<T> implements PoolChunkMetric {
         int pages = runSize >> pageShifts;
         int pageIdx = arena.pages2pageIdx(pages);
 
-        synchronized (runsAvail) {
+        runsAvailLock.lock();
+        try {
             //find first queue which has at least one big enough run
             int queueIdx = runFirstBestFit(pageIdx);
             if (queueIdx == -1) {
@@ -351,6 +360,8 @@ final class PoolChunk<T> implements PoolChunkMetric {
             int pinnedSize = runSize(pageShifts, handle);
             freeBytes -= pinnedSize;
             return handle;
+        } finally {
+            runsAvailLock.unlock();
         }
     }
 
@@ -429,7 +440,8 @@ final class PoolChunk<T> implements PoolChunkMetric {
         // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.
         // This is need as we may add it back and so alter the linked-list structure.
         PoolSubpage<T> head = arena.findSubpagePoolHead(sizeIdx);
-        synchronized (head) {
+        head.lock();
+        try {
             //allocate a new run
             int runSize = calculateRunSize(sizeIdx);
             //runSize must be multiples of pageSize
@@ -447,6 +459,8 @@ final class PoolChunk<T> implements PoolChunkMetric {
 
             subpages[runOffset] = subpage;
             return subpage.allocate();
+        } finally {
+            head.unlock();
         }
     }
 
@@ -469,7 +483,8 @@ final class PoolChunk<T> implements PoolChunkMetric {
 
             // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.
             // This is need as we may add it back and so alter the linked-list structure.
-            synchronized (head) {
+            head.lock();
+            try {
                 if (subpage.free(head, bitmapIdx(handle))) {
                     //the subpage is still used, do not free it
                     return;
@@ -477,11 +492,14 @@ final class PoolChunk<T> implements PoolChunkMetric {
                 assert !subpage.doNotDestroy;
                 // Null out slot in the array as it was freed and we should not use it anymore.
                 subpages[sIdx] = null;
+            } finally {
+                head.unlock();
             }
         }
 
         //start free run
-        synchronized (runsAvail) {
+        runsAvailLock.lock();
+        try {
             // collapse continuous runs, successfully collapsed runs
             // will be removed from runsAvail and runsAvailMap
             long finalRun = collapseRuns(handle);
@@ -493,6 +511,8 @@ final class PoolChunk<T> implements PoolChunkMetric {
 
             insertAvailRun(runOffset(finalRun), runPages(finalRun), finalRun);
             freeBytes += runSize;
+        } finally {
+            runsAvailLock.unlock();
         }
 
         if (nioBuffer != null && cachedNioBuffers != null &&
@@ -600,8 +620,11 @@ final class PoolChunk<T> implements PoolChunkMetric {
 
     @Override
     public int freeBytes() {
-        synchronized (arena) {
+        arena.lock();
+        try {
             return freeBytes;
+        } finally {
+            arena.unlock();
         }
     }
 
@@ -612,8 +635,11 @@ final class PoolChunk<T> implements PoolChunkMetric {
     @Override
     public String toString() {
         final int freeBytes;
-        synchronized (arena) {
+        arena.lock();
+        try {
             freeBytes = this.freeBytes;
+        } finally {
+            arena.unlock();
         }
 
         return new StringBuilder()
diff --git a/buffer/src/main/java/io/netty/buffer/PoolChunkList.java b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java
index cecc6e0127..aa28448d64 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolChunkList.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolChunkList.java
@@ -209,7 +209,8 @@ final class PoolChunkList<T> implements PoolChunkListMetric {
 
     @Override
     public Iterator<PoolChunkMetric> iterator() {
-        synchronized (arena) {
+        arena.lock();
+        try {
             if (head == null) {
                 return EMPTY_METRICS;
             }
@@ -222,13 +223,16 @@ final class PoolChunkList<T> implements PoolChunkListMetric {
                 }
             }
             return metrics.iterator();
+        } finally {
+            arena.unlock();
         }
     }
 
     @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
-        synchronized (arena) {
+        arena.lock();
+        try {
             if (head == null) {
                 return "none";
             }
@@ -241,6 +245,8 @@ final class PoolChunkList<T> implements PoolChunkListMetric {
                 }
                 buf.append(StringUtil.NEWLINE);
             }
+        } finally {
+            arena.unlock();
         }
         return buf.toString();
     }
diff --git a/buffer/src/main/java/io/netty/buffer/PoolSubpage.java b/buffer/src/main/java/io/netty/buffer/PoolSubpage.java
index ef7009e6d4..f9cf53fd01 100644
--- a/buffer/src/main/java/io/netty/buffer/PoolSubpage.java
+++ b/buffer/src/main/java/io/netty/buffer/PoolSubpage.java
@@ -16,6 +16,8 @@
 
 package io.netty.buffer;
 
+import java.util.concurrent.locks.ReentrantLock;
+
 import static io.netty.buffer.PoolChunk.RUN_OFFSET_SHIFT;
 import static io.netty.buffer.PoolChunk.SIZE_SHIFT;
 import static io.netty.buffer.PoolChunk.IS_USED_SHIFT;
@@ -40,6 +42,8 @@ final class PoolSubpage<T> implements PoolSubpageMetric {
     private int nextAvail;
     private int numAvail;
 
+    private final ReentrantLock lock = new ReentrantLock();
+
     // TODO: Test if adding padding helps under contention
     //private long pad0, pad1, pad2, pad3, pad4, pad5, pad6, pad7;
 
@@ -221,7 +225,8 @@ final class PoolSubpage<T> implements PoolSubpageMetric {
             numAvail = 0;
             elemSize = -1;
         } else {
-            synchronized (chunk.arena) {
+            chunk.arena.lock();
+            try {
                 if (!this.doNotDestroy) {
                     doNotDestroy = false;
                     // Not used for creating the String.
@@ -232,6 +237,8 @@ final class PoolSubpage<T> implements PoolSubpageMetric {
                     numAvail = this.numAvail;
                     elemSize = this.elemSize;
                 }
+            } finally {
+                chunk.arena.unlock();
             }
         }
 
@@ -249,9 +256,11 @@ final class PoolSubpage<T> implements PoolSubpageMetric {
             // It's the head.
             return 0;
         }
-
-        synchronized (chunk.arena) {
+        chunk.arena.lock();
+        try {
             return maxNumElems;
+        } finally {
+            chunk.arena.unlock();
         }
     }
 
@@ -262,8 +271,11 @@ final class PoolSubpage<T> implements PoolSubpageMetric {
             return 0;
         }
 
-        synchronized (chunk.arena) {
+        chunk.arena.lock();
+        try {
             return numAvail;
+        } finally {
+            chunk.arena.unlock();
         }
     }
 
@@ -274,8 +286,11 @@ final class PoolSubpage<T> implements PoolSubpageMetric {
             return -1;
         }
 
-        synchronized (chunk.arena) {
+        chunk.arena.lock();
+        try {
             return elemSize;
+        } finally {
+            chunk.arena.unlock();
         }
     }
 
@@ -289,4 +304,12 @@ final class PoolSubpage<T> implements PoolSubpageMetric {
             chunk.destroy();
         }
     }
+
+    void lock() {
+        lock.lock();
+    }
+
+    void unlock() {
+        lock.unlock();
+    }
 }
