diff --git a/common/src/main/java/io/netty/util/Recycler.java b/common/src/main/java/io/netty/util/Recycler.java
index c434874bff..a9ce337751 100644
--- a/common/src/main/java/io/netty/util/Recycler.java
+++ b/common/src/main/java/io/netty/util/Recycler.java
@@ -174,7 +174,7 @@ public abstract class Recycler<T> {
 
     @SuppressWarnings("unchecked")
     public final T get() {
-        if (maxCapacityPerThread == 0) {
+        if (maxCapacityPerThread == 0 || PlatformDependent.isVirtualThread(Thread.currentThread())) {
             return newObject((Handle<T>) NOOP_HANDLE);
         }
         LocalPool<T> localPool = threadLocal.get();
@@ -210,6 +210,9 @@ public abstract class Recycler<T> {
 
     @VisibleForTesting
     final int threadLocalSize() {
+        if (PlatformDependent.isVirtualThread(Thread.currentThread())) {
+            return 0;
+        }
         LocalPool<T> localPool = threadLocal.getIfExists();
         return localPool == null ? 0 : localPool.pooledHandles.size() + localPool.batch.size();
     }
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index d954ed674a..690b284ba3 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -336,6 +336,14 @@ public final class PlatformDependent {
         return PlatformDependent0.javaVersion();
     }
 
+    /**
+     * @param thread The thread to be checked.
+     * @return {@code true} if this {@link Thread} is a virtual thread, {@code false} otherwise.
+     */
+    public static boolean isVirtualThread(Thread thread) {
+        return PlatformDependent0.isVirtualThread(thread);
+    }
+
     /**
      * Returns {@code true} if and only if it is fine to enable TCP_NODELAY socket option by default.
      */
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index 7050918a2c..eabb7485ae 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -61,6 +61,9 @@ final class PlatformDependent0 {
 
     private static final boolean IS_EXPLICIT_TRY_REFLECTION_SET_ACCESSIBLE = explicitTryReflectionSetAccessible0();
 
+    // Package-private for testing.
+    static final MethodHandle IS_VIRTUAL_THREAD_METHOD_HANDLE = getIsVirtualThreadMethodHandle();
+
     static final Unsafe UNSAFE;
 
     // constants borrowed from murmur3
@@ -498,6 +501,42 @@ final class PlatformDependent0 {
                 DIRECT_BUFFER_CONSTRUCTOR != null ? "available" : "unavailable");
     }
 
+    private static MethodHandle getIsVirtualThreadMethodHandle() {
+        try {
+            MethodHandle methodHandle = MethodHandles.publicLookup().findVirtual(Thread.class, "isVirtual",
+                    methodType(boolean.class));
+            // Call once to make sure the invocation works.
+            boolean isVirtual = (boolean) methodHandle.invokeExact(Thread.currentThread());
+            return methodHandle;
+        } catch (Throwable e) {
+            if (logger.isTraceEnabled()) {
+                logger.debug("Thread.isVirtual() is not available: ", e);
+            } else {
+                logger.debug("Thread.isVirtual() is not available: ", e.getMessage());
+            }
+            return null;
+        }
+    }
+
+    /**
+     * @param thread The thread to be checked.
+     * @return {@code true} if this {@link Thread} is a virtual thread, {@code false} otherwise.
+     */
+    static boolean isVirtualThread(Thread thread) {
+        if (thread == null || IS_VIRTUAL_THREAD_METHOD_HANDLE == null) {
+            return false;
+        }
+        try {
+            return (boolean) IS_VIRTUAL_THREAD_METHOD_HANDLE.invokeExact(thread);
+        } catch (Throwable t) {
+            // Should not happen.
+            if (t instanceof Error) {
+                throw (Error) t;
+            }
+            throw new Error(t);
+        }
+    }
+
     private static boolean unsafeStaticFieldOffsetSupported() {
         return !RUNNING_IN_NATIVE_IMAGE;
     }
diff --git a/common/src/test/java/io/netty/util/internal/VirtualThreadCheckTest.java b/common/src/test/java/io/netty/util/internal/VirtualThreadCheckTest.java
new file mode 100644
index 0000000000..773076ee48
--- /dev/null
+++ b/common/src/test/java/io/netty/util/internal/VirtualThreadCheckTest.java
@@ -0,0 +1,111 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.internal;
+
+import io.netty.util.concurrent.FastThreadLocalThread;
+import org.junit.jupiter.api.Test;
+
+import java.lang.reflect.Method;
+import java.util.concurrent.atomic.AtomicReference;
+
+import static io.netty.util.internal.PlatformDependent0.IS_VIRTUAL_THREAD_METHOD_HANDLE;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertNull;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
+
+public class VirtualThreadCheckTest {
+
+    @Test
+    public void testCheckVirtualThread() throws Exception {
+        assertFalse(PlatformDependent.isVirtualThread(null));
+        assertFalse(PlatformDependent.isVirtualThread(Thread.currentThread()));
+        FastThreadLocalThread fastThreadLocalThread = new FastThreadLocalThread();
+        assertFalse(PlatformDependent.isVirtualThread(fastThreadLocalThread));
+        final AtomicReference<Boolean> atomicRes = new AtomicReference<Boolean>();
+        Thread subThread = new Thread() {
+            @Override
+            public void run() {
+                atomicRes.set(PlatformDependent.isVirtualThread(Thread.currentThread()));
+            }
+        };
+        subThread.start();
+        subThread.join();
+        assertFalse(atomicRes.get());
+
+        Thread subOfSubThread = new SubThread() {
+            @Override
+            public void run() {
+                atomicRes.set(PlatformDependent.isVirtualThread(Thread.currentThread()));
+            }
+        };
+        subOfSubThread.start();
+        subOfSubThread.join();
+        assertFalse(atomicRes.get());
+
+        Thread subOfSubOfSubThread = new SubOfSubThread() {
+            @Override
+            public void run() {
+                atomicRes.set(PlatformDependent.isVirtualThread(Thread.currentThread()));
+            }
+        };
+        subOfSubOfSubThread.start();
+        subOfSubOfSubThread.join();
+        assertFalse(atomicRes.get());
+
+        assumeTrue(PlatformDependent.javaVersion() >= 21);
+        Method startVirtualThread = getStartVirtualThreadMethod();
+        Thread virtualThread = (Thread) startVirtualThread.invoke(null, new Runnable() {
+            @Override
+            public void run() {
+            }
+        });
+        assertTrue(PlatformDependent.isVirtualThread(virtualThread));
+    }
+
+    @Test
+    public void testGetVirtualThreadCheckMethod() throws Throwable {
+        if (PlatformDependent.javaVersion() < 19) {
+            assertNull(IS_VIRTUAL_THREAD_METHOD_HANDLE);
+        } else {
+            assumeTrue(PlatformDependent.javaVersion() >= 21);
+            assumeTrue(IS_VIRTUAL_THREAD_METHOD_HANDLE != null);
+            boolean isVirtual = (boolean) IS_VIRTUAL_THREAD_METHOD_HANDLE.invokeExact(Thread.currentThread());
+            assertFalse(isVirtual);
+
+            Method startVirtualThread = getStartVirtualThreadMethod();
+            Thread virtualThread = (Thread) startVirtualThread.invoke(null, new Runnable() {
+                @Override
+                public void run() {
+                }
+            });
+            isVirtual = (boolean) IS_VIRTUAL_THREAD_METHOD_HANDLE.invokeExact(virtualThread);
+            assertTrue(isVirtual);
+        }
+    }
+
+    private Method getStartVirtualThreadMethod() throws NoSuchMethodException {
+        return Thread.class.getMethod("startVirtualThread", Runnable.class);
+    }
+
+    private static class SubThread extends Thread {
+        // For test
+    }
+
+    private static class SubOfSubThread extends SubThread {
+        // For test
+    }
+}
