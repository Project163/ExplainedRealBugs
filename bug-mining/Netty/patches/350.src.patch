diff --git a/buffer/pom.xml b/buffer/pom.xml
index 387776153e..037162a6fc 100644
--- a/buffer/pom.xml
+++ b/buffer/pom.xml
@@ -44,6 +44,12 @@
       <version>${project.version}</version>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>${project.groupId}</groupId>
+      <artifactId>netty-varhandle-stub</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
     <dependency>
       <groupId>org.graalvm.nativeimage</groupId>
       <artifactId>svm</artifactId>
diff --git a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
index bb15579d04..014a804e37 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractReferenceCountedByteBuf.java
@@ -16,30 +16,68 @@
 
 package io.netty.buffer;
 
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
+import io.netty.util.internal.AtomicReferenceCountUpdater;
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.ReferenceCountUpdater;
+import io.netty.util.internal.UnsafeReferenceCountUpdater;
+import io.netty.util.internal.VarHandleReferenceCountUpdater;
+
+import static io.netty.util.internal.ReferenceCountUpdater.getUnsafeOffset;
+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;
 
 /**
  * Abstract base class for {@link ByteBuf} implementations that count references.
  */
 public abstract class AbstractReferenceCountedByteBuf extends AbstractByteBuf {
-    private static final long REFCNT_FIELD_OFFSET =
-            ReferenceCountUpdater.getUnsafeOffset(AbstractReferenceCountedByteBuf.class, "refCnt");
-    private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> AIF_UPDATER =
-            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");
-
-    private static final ReferenceCountUpdater<AbstractReferenceCountedByteBuf> updater =
-            new ReferenceCountUpdater<AbstractReferenceCountedByteBuf>() {
-        @Override
-        protected AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> updater() {
-            return AIF_UPDATER;
-        }
-        @Override
-        protected long unsafeOffset() {
-            return REFCNT_FIELD_OFFSET;
+    private static final long REFCNT_FIELD_OFFSET;
+    private static final AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> AIF_UPDATER;
+    private static final Object REFCNT_FIELD_VH;
+    private static final ReferenceCountUpdater<AbstractReferenceCountedByteBuf> updater;
+
+    static {
+        switch (ReferenceCountUpdater.updaterTypeOf(AbstractReferenceCountedByteBuf.class, "refCnt")) {
+            case Atomic:
+                AIF_UPDATER = newUpdater(AbstractReferenceCountedByteBuf.class, "refCnt");
+                REFCNT_FIELD_OFFSET = -1;
+                REFCNT_FIELD_VH = null;
+                updater = new AtomicReferenceCountUpdater<AbstractReferenceCountedByteBuf>() {
+                    @Override
+                    protected AtomicIntegerFieldUpdater<AbstractReferenceCountedByteBuf> updater() {
+                        return AIF_UPDATER;
+                    }
+                };
+                break;
+            case Unsafe:
+                AIF_UPDATER = null;
+                REFCNT_FIELD_OFFSET = getUnsafeOffset(AbstractReferenceCountedByteBuf.class, "refCnt");
+                REFCNT_FIELD_VH = null;
+                updater = new UnsafeReferenceCountUpdater<AbstractReferenceCountedByteBuf>() {
+                    @Override
+                    protected long refCntFieldOffset() {
+                        return REFCNT_FIELD_OFFSET;
+                    }
+                };
+                break;
+            case VarHandle:
+                AIF_UPDATER = null;
+                REFCNT_FIELD_OFFSET = -1;
+                REFCNT_FIELD_VH = PlatformDependent.findVarHandleOfIntField(MethodHandles.lookup(),
+                        AbstractReferenceCountedByteBuf.class, "refCnt");
+                updater = new VarHandleReferenceCountUpdater<AbstractReferenceCountedByteBuf>() {
+                    @Override
+                    protected VarHandle varHandle() {
+                        return (VarHandle) REFCNT_FIELD_VH;
+                    }
+                };
+                break;
+            default:
+                throw new Error("Unknown updater type for AbstractReferenceCountedByteBuf");
         }
-    };
+    }
 
     // Value might not equal "real" reference count, all access should be via the updater
     @SuppressWarnings({"unused", "FieldMayBeFinal"})
diff --git a/buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java b/buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java
index 7f645d8e98..573c6d3306 100644
--- a/buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java
+++ b/buffer/src/main/java/io/netty/buffer/AdaptivePoolingAllocator.java
@@ -25,17 +25,22 @@ import io.netty.util.ReferenceCounted;
 import io.netty.util.concurrent.FastThreadLocal;
 import io.netty.util.concurrent.FastThreadLocalThread;
 import io.netty.util.concurrent.MpscIntQueue;
+import io.netty.util.internal.AtomicReferenceCountUpdater;
 import io.netty.util.internal.ObjectPool;
 import io.netty.util.internal.ObjectUtil;
 import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.ReferenceCountUpdater;
 import io.netty.util.internal.SystemPropertyUtil;
 import io.netty.util.internal.ThreadExecutorMap;
+import io.netty.util.internal.UnsafeReferenceCountUpdater;
 import io.netty.util.internal.UnstableApi;
+import io.netty.util.internal.VarHandleReferenceCountUpdater;
 
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
 import java.nio.channels.ClosedChannelException;
@@ -55,6 +60,9 @@ import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;
 import java.util.concurrent.locks.StampedLock;
 import java.util.function.IntSupplier;
 
+import static io.netty.util.internal.ReferenceCountUpdater.getUnsafeOffset;
+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;
+
 /**
  * An auto-tuning pooling allocator, that follows an anti-generational hypothesis.
  * <p>
@@ -1078,10 +1086,51 @@ final class AdaptivePoolingAllocator {
     }
 
     private static class Chunk implements ReferenceCounted, ChunkInfo {
-        private static final long REFCNT_FIELD_OFFSET =
-                ReferenceCountUpdater.getUnsafeOffset(Chunk.class, "refCnt");
-        private static final AtomicIntegerFieldUpdater<Chunk> AIF_UPDATER =
-                AtomicIntegerFieldUpdater.newUpdater(Chunk.class, "refCnt");
+        private static final long REFCNT_FIELD_OFFSET;
+        private static final AtomicIntegerFieldUpdater<Chunk> AIF_UPDATER;
+        private static final Object REFCNT_FIELD_VH;
+        private static final ReferenceCountUpdater<Chunk> updater;
+
+        static {
+            switch (ReferenceCountUpdater.updaterTypeOf(Chunk.class, "refCnt")) {
+                case Atomic:
+                    AIF_UPDATER = newUpdater(Chunk.class, "refCnt");
+                    REFCNT_FIELD_OFFSET = -1;
+                    REFCNT_FIELD_VH = null;
+                    updater = new AtomicReferenceCountUpdater<Chunk>() {
+                        @Override
+                        protected AtomicIntegerFieldUpdater<Chunk> updater() {
+                            return AIF_UPDATER;
+                        }
+                    };
+                    break;
+                case Unsafe:
+                    AIF_UPDATER = null;
+                    REFCNT_FIELD_OFFSET = getUnsafeOffset(Chunk.class, "refCnt");
+                    REFCNT_FIELD_VH = null;
+                    updater = new UnsafeReferenceCountUpdater<Chunk>() {
+                        @Override
+                        protected long refCntFieldOffset() {
+                            return REFCNT_FIELD_OFFSET;
+                        }
+                    };
+                    break;
+                case VarHandle:
+                    AIF_UPDATER = null;
+                    REFCNT_FIELD_OFFSET = -1;
+                    REFCNT_FIELD_VH = PlatformDependent.findVarHandleOfIntField(MethodHandles.lookup(),
+                            Chunk.class, "refCnt");
+                    updater = new VarHandleReferenceCountUpdater<Chunk>() {
+                        @Override
+                        protected VarHandle varHandle() {
+                            return (VarHandle) REFCNT_FIELD_VH;
+                        }
+                    };
+                    break;
+                default:
+                    throw new Error("Unknown updater type for Chunk");
+            }
+        }
 
         protected final AbstractByteBuf delegate;
         protected Magazine magazine;
@@ -1091,20 +1140,6 @@ final class AdaptivePoolingAllocator {
         private final boolean pooled;
         protected int allocatedBytes;
 
-        private static final ReferenceCountUpdater<Chunk> updater =
-                new ReferenceCountUpdater<Chunk>() {
-                    @Override
-                    protected AtomicIntegerFieldUpdater<Chunk> updater() {
-                        return AIF_UPDATER;
-                    }
-                    @Override
-                    protected long unsafeOffset() {
-                        // on native image, REFCNT_FIELD_OFFSET can be recomputed even with Unsafe unavailable, so we
-                        // need to guard here
-                        return PlatformDependent.hasUnsafe() ? REFCNT_FIELD_OFFSET : -1;
-                    }
-                };
-
         // Value might not equal "real" reference count, all access should be via the updater
         @SuppressWarnings({"unused", "FieldMayBeFinal"})
         private volatile int refCnt;
diff --git a/buffer/src/main/java/io/netty/buffer/HeapByteBufUtil.java b/buffer/src/main/java/io/netty/buffer/HeapByteBufUtil.java
index 9f7972a273..1784e3ef30 100644
--- a/buffer/src/main/java/io/netty/buffer/HeapByteBufUtil.java
+++ b/buffer/src/main/java/io/netty/buffer/HeapByteBufUtil.java
@@ -15,6 +15,10 @@
  */
 package io.netty.buffer;
 
+import io.netty.util.internal.PlatformDependent;
+
+import java.lang.invoke.VarHandle;
+
 /**
  * Utility class for heap buffers.
  */
@@ -25,10 +29,22 @@ final class HeapByteBufUtil {
     }
 
     static short getShort(byte[] memory, int index) {
+        VarHandle shortBeArrayView = PlatformDependent.shortBeArrayView();
+        if (shortBeArrayView != null) {
+            return (short) shortBeArrayView.get(memory, index);
+        }
+        return getShort0(memory, index);
+    }
+
+    private static short getShort0(byte[] memory, int index) {
         return (short) (memory[index] << 8 | memory[index + 1] & 0xFF);
     }
 
     static short getShortLE(byte[] memory, int index) {
+        VarHandle shortLeArrayView = PlatformDependent.shortLeArrayView();
+        if (shortLeArrayView != null) {
+            return (short) shortLeArrayView.get(memory, index);
+        }
         return (short) (memory[index] & 0xff | memory[index + 1] << 8);
     }
 
@@ -45,39 +61,71 @@ final class HeapByteBufUtil {
     }
 
     static int getInt(byte[] memory, int index) {
-        return  (memory[index]     & 0xff) << 24 |
-                (memory[index + 1] & 0xff) << 16 |
-                (memory[index + 2] & 0xff) <<  8 |
-                memory[index + 3] & 0xff;
+        VarHandle intBeArrayView  = PlatformDependent.intBeArrayView();
+        if (intBeArrayView != null) {
+            return (int) intBeArrayView.get(memory, index);
+        }
+        return getInt0(memory, index);
+    }
+
+    private static int getInt0(byte[] memory, int index) {
+        return (memory[index] & 0xFF) << 24 |
+               (memory[index + 1] & 0xFF) << 16 |
+               (memory[index + 2] & 0xFF) << 8 |
+               (memory[index + 3] & 0xFF);
     }
 
     static int getIntLE(byte[] memory, int index) {
-        return  memory[index]      & 0xff        |
-                (memory[index + 1] & 0xff) << 8  |
-                (memory[index + 2] & 0xff) << 16 |
-                (memory[index + 3] & 0xff) << 24;
+        VarHandle intLeArrayView = PlatformDependent.intLeArrayView();
+        if (intLeArrayView != null) {
+            return (int) intLeArrayView.get(memory, index);
+        }
+        return getIntLE0(memory, index);
+    }
+
+    private static int getIntLE0(byte[] memory, int index) {
+        return (memory[index] & 0xFF) |
+               (memory[index + 1] & 0xFF) << 8 |
+               (memory[index + 2] & 0xFF) << 16 |
+               (memory[index + 3] & 0xFF) << 24;
     }
 
     static long getLong(byte[] memory, int index) {
-        return  ((long) memory[index]     & 0xff) << 56 |
-                ((long) memory[index + 1] & 0xff) << 48 |
-                ((long) memory[index + 2] & 0xff) << 40 |
-                ((long) memory[index + 3] & 0xff) << 32 |
-                ((long) memory[index + 4] & 0xff) << 24 |
-                ((long) memory[index + 5] & 0xff) << 16 |
-                ((long) memory[index + 6] & 0xff) <<  8 |
-                (long) memory[index + 7] & 0xff;
+        VarHandle longBeArrayView = PlatformDependent.longBeArrayView();
+        if (longBeArrayView != null) {
+            return (long) longBeArrayView.get(memory, index);
+        }
+        return getLong0(memory, index);
+    }
+
+    private static long getLong0(byte[] memory, int index) {
+        return ((long) memory[index] & 0xFF) << 56 |
+               ((long) memory[index + 1] & 0xFF) << 48 |
+               ((long) memory[index + 2] & 0xFF) << 40 |
+               ((long) memory[index + 3] & 0xFF) << 32 |
+               ((long) memory[index + 4] & 0xFF) << 24 |
+               ((long) memory[index + 5] & 0xFF) << 16 |
+               ((long) memory[index + 6] & 0xFF) << 8 |
+               ((long) memory[index + 7] & 0xFF);
     }
 
     static long getLongLE(byte[] memory, int index) {
-        return  (long) memory[index]      & 0xff        |
-                ((long) memory[index + 1] & 0xff) <<  8 |
-                ((long) memory[index + 2] & 0xff) << 16 |
-                ((long) memory[index + 3] & 0xff) << 24 |
-                ((long) memory[index + 4] & 0xff) << 32 |
-                ((long) memory[index + 5] & 0xff) << 40 |
-                ((long) memory[index + 6] & 0xff) << 48 |
-                ((long) memory[index + 7] & 0xff) << 56;
+        VarHandle longLeArrayView = PlatformDependent.longLeArrayView();
+        if (longLeArrayView != null) {
+            return (long) longLeArrayView.get(memory, index);
+        }
+        return getLongLE0(memory, index);
+    }
+
+    private static long getLongLE0(byte[] memory, int index) {
+        return ((long) memory[index] & 0xFF) |
+               ((long) memory[index + 1] & 0xFF) << 8 |
+               ((long) memory[index + 2] & 0xFF) << 16 |
+               ((long) memory[index + 3] & 0xFF) << 24 |
+               ((long) memory[index + 4] & 0xFF) << 32 |
+               ((long) memory[index + 5] & 0xFF) << 40 |
+               ((long) memory[index + 6] & 0xFF) << 48 |
+               ((long) memory[index + 7] & 0xFF) << 56;
     }
 
     static void setByte(byte[] memory, int index, int value) {
@@ -85,11 +133,21 @@ final class HeapByteBufUtil {
     }
 
     static void setShort(byte[] memory, int index, int value) {
+        VarHandle shortBeArrayView = PlatformDependent.shortBeArrayView();
+        if (shortBeArrayView != null) {
+            shortBeArrayView.set(memory, index, (short) value);
+            return;
+        }
         memory[index]     = (byte) (value >>> 8);
         memory[index + 1] = (byte) value;
     }
 
     static void setShortLE(byte[] memory, int index, int value) {
+        VarHandle shortLeArrayView = PlatformDependent.shortLeArrayView();
+        if (shortLeArrayView != null) {
+            shortLeArrayView.set(memory, index, (short) value);
+            return;
+        }
         memory[index]     = (byte) value;
         memory[index + 1] = (byte) (value >>> 8);
     }
@@ -107,6 +165,15 @@ final class HeapByteBufUtil {
     }
 
     static void setInt(byte[] memory, int index, int value) {
+        VarHandle intBeArrayView = PlatformDependent.intBeArrayView();
+        if (intBeArrayView != null) {
+            intBeArrayView.set(memory, index, value);
+            return;
+        }
+        setInt0(memory, index, value);
+    }
+
+    private static void setInt0(byte[] memory, int index, int value) {
         memory[index]     = (byte) (value >>> 24);
         memory[index + 1] = (byte) (value >>> 16);
         memory[index + 2] = (byte) (value >>> 8);
@@ -114,6 +181,15 @@ final class HeapByteBufUtil {
     }
 
     static void setIntLE(byte[] memory, int index, int value) {
+        VarHandle intLeArrayView = PlatformDependent.intLeArrayView();
+        if (intLeArrayView != null) {
+            intLeArrayView.set(memory, index, value);
+            return;
+        }
+        setIntLE0(memory, index, value);
+    }
+
+    private static void setIntLE0(byte[] memory, int index, int value) {
         memory[index]     = (byte) value;
         memory[index + 1] = (byte) (value >>> 8);
         memory[index + 2] = (byte) (value >>> 16);
@@ -121,6 +197,15 @@ final class HeapByteBufUtil {
     }
 
     static void setLong(byte[] memory, int index, long value) {
+        VarHandle longBeArrayView = PlatformDependent.longBeArrayView();
+        if (longBeArrayView != null) {
+            longBeArrayView.set(memory, index, value);
+            return;
+        }
+        setLong0(memory, index, value);
+    }
+
+    private static void setLong0(byte[] memory, int index, long value) {
         memory[index]     = (byte) (value >>> 56);
         memory[index + 1] = (byte) (value >>> 48);
         memory[index + 2] = (byte) (value >>> 40);
@@ -132,6 +217,15 @@ final class HeapByteBufUtil {
     }
 
     static void setLongLE(byte[] memory, int index, long value) {
+        VarHandle longLeArrayView = PlatformDependent.longLeArrayView();
+        if (longLeArrayView != null) {
+            longLeArrayView.set(memory, index, value);
+            return;
+        }
+        setLongLE0(memory, index, value);
+    }
+
+    private static void setLongLE0(byte[] memory, int index, long value) {
         memory[index]     = (byte) value;
         memory[index + 1] = (byte) (value >>> 8);
         memory[index + 2] = (byte) (value >>> 16);
diff --git a/common/pom.xml b/common/pom.xml
index 0273d6fffc..25db1f7eaa 100644
--- a/common/pom.xml
+++ b/common/pom.xml
@@ -101,6 +101,12 @@
       <version>${project.version}</version>
       <scope>provided</scope>
     </dependency>
+    <dependency>
+      <groupId>io.netty</groupId>
+      <artifactId>netty-varhandle-stub</artifactId>
+      <version>${project.version}</version>
+      <scope>provided</scope>
+    </dependency>
     <!-- Add dependency on dev-tools as otherwise the build will fail if not installed first manually -->
     <!-- See https://github.com/netty/netty/issues/7842 -->
     <dependency>
diff --git a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
index 364b980979..7a08bc4697 100644
--- a/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
+++ b/common/src/main/java/io/netty/util/AbstractReferenceCounted.java
@@ -15,30 +15,68 @@
  */
 package io.netty.util;
 
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
 import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
 
+import io.netty.util.internal.AtomicReferenceCountUpdater;
+import io.netty.util.internal.PlatformDependent;
 import io.netty.util.internal.ReferenceCountUpdater;
+import io.netty.util.internal.UnsafeReferenceCountUpdater;
+import io.netty.util.internal.VarHandleReferenceCountUpdater;
+
+import static io.netty.util.internal.ReferenceCountUpdater.getUnsafeOffset;
+import static java.util.concurrent.atomic.AtomicIntegerFieldUpdater.newUpdater;
 
 /**
  * Abstract base class for classes wants to implement {@link ReferenceCounted}.
  */
 public abstract class AbstractReferenceCounted implements ReferenceCounted {
-    private static final long REFCNT_FIELD_OFFSET =
-            ReferenceCountUpdater.getUnsafeOffset(AbstractReferenceCounted.class, "refCnt");
-    private static final AtomicIntegerFieldUpdater<AbstractReferenceCounted> AIF_UPDATER =
-            AtomicIntegerFieldUpdater.newUpdater(AbstractReferenceCounted.class, "refCnt");
+    private static final long REFCNT_FIELD_OFFSET;
+    private static final AtomicIntegerFieldUpdater<AbstractReferenceCounted> AIF_UPDATER;
+    private static final Object REFCNT_FIELD_VH;
+    private static final ReferenceCountUpdater<AbstractReferenceCounted> updater;
 
-    private static final ReferenceCountUpdater<AbstractReferenceCounted> updater =
-            new ReferenceCountUpdater<AbstractReferenceCounted>() {
-        @Override
-        protected AtomicIntegerFieldUpdater<AbstractReferenceCounted> updater() {
-            return AIF_UPDATER;
-        }
-        @Override
-        protected long unsafeOffset() {
-            return REFCNT_FIELD_OFFSET;
+    static {
+        switch (ReferenceCountUpdater.updaterTypeOf(AbstractReferenceCounted.class, "refCnt")) {
+            case Atomic:
+                AIF_UPDATER = newUpdater(AbstractReferenceCounted.class, "refCnt");
+                REFCNT_FIELD_OFFSET = -1;
+                REFCNT_FIELD_VH = null;
+                updater = new AtomicReferenceCountUpdater<AbstractReferenceCounted>() {
+                    @Override
+                    protected AtomicIntegerFieldUpdater<AbstractReferenceCounted> updater() {
+                        return AIF_UPDATER;
+                    }
+                };
+                break;
+            case Unsafe:
+                AIF_UPDATER = null;
+                REFCNT_FIELD_OFFSET = getUnsafeOffset(AbstractReferenceCounted.class, "refCnt");
+                REFCNT_FIELD_VH = null;
+                updater = new UnsafeReferenceCountUpdater<AbstractReferenceCounted>() {
+                    @Override
+                    protected long refCntFieldOffset() {
+                        return REFCNT_FIELD_OFFSET;
+                    }
+                };
+                break;
+            case VarHandle:
+                AIF_UPDATER = null;
+                REFCNT_FIELD_OFFSET = -1;
+                REFCNT_FIELD_VH = PlatformDependent.findVarHandleOfIntField(MethodHandles.lookup(),
+                        AbstractReferenceCounted.class, "refCnt");
+                updater = new VarHandleReferenceCountUpdater<AbstractReferenceCounted>() {
+                    @Override
+                    protected VarHandle varHandle() {
+                        return (VarHandle) REFCNT_FIELD_VH;
+                    }
+                };
+                break;
+            default:
+                throw new Error("Unknown updater type for AbstractReferenceCounted");
         }
-    };
+    }
 
     // Value might not equal "real" reference count, all access should be via the updater
     @SuppressWarnings({"unused", "FieldMayBeFinal"})
diff --git a/common/src/main/java/io/netty/util/internal/AtomicReferenceCountUpdater.java b/common/src/main/java/io/netty/util/internal/AtomicReferenceCountUpdater.java
new file mode 100644
index 0000000000..742bfef906
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/AtomicReferenceCountUpdater.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.internal;
+
+import io.netty.util.ReferenceCounted;
+
+import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
+
+public abstract class AtomicReferenceCountUpdater<T extends ReferenceCounted> extends ReferenceCountUpdater<T> {
+
+    protected AtomicReferenceCountUpdater() {
+    }
+
+    protected abstract AtomicIntegerFieldUpdater<T> updater();
+
+    @Override
+    protected final void safeInitializeRawRefCnt(T refCntObj, int value) {
+        updater().set(refCntObj, value);
+    }
+
+    @Override
+    protected final int getAndAddRawRefCnt(T refCntObj, int increment) {
+        return updater().getAndAdd(refCntObj, increment);
+    }
+
+    @Override
+    protected final int getRawRefCnt(T refCnt) {
+        return updater().get(refCnt);
+    }
+
+    @Override
+    protected final int getAcquireRawRefCnt(T refCnt) {
+        return updater().get(refCnt);
+    }
+
+    @Override
+    protected final void setReleaseRawRefCnt(T refCnt, int value) {
+        updater().lazySet(refCnt, value);
+    }
+
+    @Override
+    protected final boolean casRawRefCnt(T refCnt, int expected, int value) {
+        return updater().compareAndSet(refCnt, expected, value);
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index 257bf2e445..3e994af662 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -39,6 +39,7 @@ import java.io.IOException;
 import java.io.InputStreamReader;
 import java.lang.invoke.MethodHandle;
 import java.lang.invoke.MethodHandles;
+import java.lang.invoke.VarHandle;
 import java.lang.reflect.Field;
 import java.nio.ByteBuffer;
 import java.nio.ByteOrder;
@@ -129,6 +130,7 @@ public final class PlatformDependent {
     public static final boolean BIG_ENDIAN_NATIVE_ORDER = ByteOrder.nativeOrder() == ByteOrder.BIG_ENDIAN;
 
     private static final boolean JFR;
+    private static final boolean VAR_HANDLE;
 
     private static final Cleaner NOOP = new Cleaner() {
         @Override
@@ -258,6 +260,37 @@ public final class PlatformDependent {
         } else if (logger.isDebugEnabled()) {
             logger.debug("-Dio.netty.jfr.enabled: {}", JFR);
         }
+        VAR_HANDLE = initializeVarHandle();
+    }
+
+    private static boolean initializeVarHandle() {
+        if (UNSAFE_UNAVAILABILITY_CAUSE == null || javaVersion() < 9 ||
+                PlatformDependent0.isNativeImage()) {
+            return false;
+        }
+        boolean varHandleAvailable = false;
+        Throwable varHandleFailure;
+        try {
+            VarHandle.storeStoreFence();
+            varHandleAvailable = VarHandleFactory.isSupported();
+            varHandleFailure = VarHandleFactory.unavailableCause();
+        } catch (Throwable t) {
+            // no-op
+            varHandleFailure = t;
+        }
+        if (varHandleFailure != null) {
+            logger.debug("java.lang.invoke.VarHandle: unavailable, reason: {}", varHandleFailure.toString());
+        } else {
+            logger.debug("java.lang.invoke.VarHandle: available");
+        }
+        boolean varHandleEnabled = varHandleAvailable &&
+                SystemPropertyUtil.getBoolean("io.netty.varHandle.enabled", varHandleAvailable);
+        if (logger.isTraceEnabled() && varHandleFailure != null) {
+            logger.debug("-Dio.netty.varHandle.enabled: {}", varHandleEnabled, varHandleFailure);
+        } else if (logger.isDebugEnabled()) {
+            logger.debug("-Dio.netty.varHandle.enabled: {}", varHandleEnabled);
+        }
+        return varHandleEnabled;
     }
 
     // For specifications, see https://www.freedesktop.org/software/systemd/man/os-release.html
@@ -592,28 +625,85 @@ public final class PlatformDependent {
                 "sun.misc.Unsafe or java.nio.DirectByteBuffer.<init>(long, int) not available");
     }
 
+    public static boolean hasVarHandle() {
+        return VAR_HANDLE;
+    }
+
+    public static VarHandle findVarHandleOfIntField(MethodHandles.Lookup lookup, Class<?> type, String fieldName) {
+        if (VAR_HANDLE) {
+            return VarHandleFactory.privateFindVarHandle(lookup, type, fieldName, int.class);
+        }
+        return null;
+    }
+
+    public static VarHandle intBeArrayView() {
+        if (VAR_HANDLE) {
+            return VarHandleFactory.intBeArrayView();
+        }
+        return null;
+    }
+
+    public static VarHandle intLeArrayView() {
+        if (VAR_HANDLE) {
+            return VarHandleFactory.intLeArrayView();
+        }
+        return null;
+    }
+
+    public static VarHandle longBeArrayView() {
+        if (VAR_HANDLE) {
+            return VarHandleFactory.longBeArrayView();
+        }
+        return null;
+    }
+
+    public static VarHandle longLeArrayView() {
+        if (VAR_HANDLE) {
+            return VarHandleFactory.longLeArrayView();
+        }
+        return null;
+    }
+
+    public static VarHandle shortBeArrayView() {
+        if (VAR_HANDLE) {
+            return VarHandleFactory.shortBeArrayView();
+        }
+        return null;
+    }
+
+    public static VarHandle shortLeArrayView() {
+        if (VAR_HANDLE) {
+            return VarHandleFactory.shortLeArrayView();
+        }
+        return null;
+    }
+
     public static Object getObject(Object object, long fieldOffset) {
         return PlatformDependent0.getObject(object, fieldOffset);
     }
 
+    public static int getVolatileInt(Object object, long fieldOffset) {
+        return PlatformDependent0.getIntVolatile(object, fieldOffset);
+    }
+
     public static int getInt(Object object, long fieldOffset) {
         return PlatformDependent0.getInt(object, fieldOffset);
     }
 
-    static void safeConstructPutInt(Object object, long fieldOffset, int value) {
-        PlatformDependent0.safeConstructPutInt(object, fieldOffset, value);
+    public static void putOrderedInt(Object object, long fieldOffset, int value) {
+        PlatformDependent0.putOrderedInt(object, fieldOffset, value);
     }
 
-    public static void putShortOrdered(long adddress, short newValue) {
-        PlatformDependent0.putShortOrdered(adddress, newValue);
+    public static int getAndAddInt(Object object, long fieldOffset, int delta) {
+        return PlatformDependent0.getAndAddInt(object, fieldOffset, delta);
     }
 
-    public static int getIntVolatile(long address) {
-        return PlatformDependent0.getIntVolatile(address);
+    public static boolean compareAndSwapInt(Object object, long fieldOffset, int expected, int value) {
+        return PlatformDependent0.compareAndSwapInt(object, fieldOffset, expected, value);
     }
 
-    public static void putIntOrdered(long adddress, int newValue) {
-        PlatformDependent0.putIntOrdered(adddress, newValue);
+    static void safeConstructPutInt(Object object, long fieldOffset, int value) {
+        PlatformDependent0.safeConstructPutInt(object, fieldOffset, value);
     }
 
     public static byte getByte(long address) {
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index f65b441d4a..e060efa0f8 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -341,7 +341,7 @@ final class PlatformDependent0 {
                         Class<?> bitsClass =
                                 Class.forName("java.nio.Bits", false, getSystemClassLoader());
                         int version = javaVersion();
-                        if (unsafeStaticFieldOffsetSupported() && version >= 9) {
+                        if (!isNativeImage() && version >= 9) {
                             // Java9/10 use all lowercase and later versions all uppercase.
                             String fieldName = version >= 11? "MAX_MEMORY" : "maxMemory";
                             // On Java9 and later we try to directly access the field as we can do this without
@@ -519,8 +519,8 @@ final class PlatformDependent0 {
         }
     }
 
-    private static boolean unsafeStaticFieldOffsetSupported() {
-        return !RUNNING_IN_NATIVE_IMAGE;
+    static boolean isNativeImage() {
+        return RUNNING_IN_NATIVE_IMAGE;
     }
 
     static boolean isExplicitNoUnsafe() {
@@ -679,6 +679,22 @@ final class PlatformDependent0 {
         return UNSAFE.getInt(object, fieldOffset);
     }
 
+    static int getIntVolatile(Object object, long fieldOffset) {
+        return UNSAFE.getIntVolatile(object, fieldOffset);
+    }
+
+    static void putOrderedInt(Object object, long fieldOffset, int value) {
+        UNSAFE.putOrderedInt(object, fieldOffset, value);
+    }
+
+    static int getAndAddInt(Object object, long fieldOffset, int value) {
+        return UNSAFE.getAndAddInt(object, fieldOffset, value);
+    }
+
+    static boolean compareAndSwapInt(Object object, long fieldOffset, int expected, int value) {
+        return UNSAFE.compareAndSwapInt(object, fieldOffset, expected, value);
+    }
+
     static void safeConstructPutInt(Object object, long fieldOffset, int value) {
         UNSAFE.putInt(object, fieldOffset, value);
         UNSAFE.storeFence();
@@ -728,14 +744,6 @@ final class PlatformDependent0 {
         return UNSAFE.getInt(data, INT_ARRAY_BASE_OFFSET + INT_ARRAY_INDEX_SCALE * index);
     }
 
-    static int getIntVolatile(long address) {
-        return UNSAFE.getIntVolatile(null, address);
-    }
-
-    static void putIntOrdered(long address, int newValue) {
-        UNSAFE.putOrderedInt(null, address, newValue);
-    }
-
     static long getLong(byte[] data, int index) {
         return UNSAFE.getLong(data, BYTE_ARRAY_BASE_OFFSET + index);
     }
diff --git a/common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java b/common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java
index 760b95d3f3..3ad09ab204 100644
--- a/common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java
+++ b/common/src/main/java/io/netty/util/internal/ReferenceCountUpdater.java
@@ -17,8 +17,6 @@ package io.netty.util.internal;
 
 import static io.netty.util.internal.ObjectUtil.checkPositive;
 
-import java.util.concurrent.atomic.AtomicIntegerFieldUpdater;
-
 import io.netty.util.IllegalReferenceCountException;
 import io.netty.util.ReferenceCounted;
 
@@ -38,34 +36,27 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
      * for example: if (rawCnt == 2 || rawCnt == 4 || (rawCnt & 1) == 0) { ...
      */
 
-    protected ReferenceCountUpdater() { }
-
-    public static long getUnsafeOffset(Class<? extends ReferenceCounted> clz, String fieldName) {
-        try {
-            if (PlatformDependent.hasUnsafe()) {
-                return PlatformDependent.objectFieldOffset(clz.getDeclaredField(fieldName));
-            }
-        } catch (Throwable ignore) {
-            // fall-back
-        }
-        return -1;
+    protected ReferenceCountUpdater() {
     }
 
-    protected abstract AtomicIntegerFieldUpdater<T> updater();
+    protected abstract void safeInitializeRawRefCnt(T refCntObj, int value);
+
+    protected abstract int getAndAddRawRefCnt(T refCntObj, int increment);
+
+    protected abstract int getRawRefCnt(T refCnt);
+
+    protected abstract int getAcquireRawRefCnt(T refCnt);
 
-    protected abstract long unsafeOffset();
+    protected abstract void setReleaseRawRefCnt(T refCnt, int value);
+
+    protected abstract boolean casRawRefCnt(T refCnt, int expected, int value);
 
     public final int initialValue() {
         return 2;
     }
 
-    public void setInitialValue(T instance) {
-        final long offset = unsafeOffset();
-        if (offset == -1) {
-            updater().set(instance, initialValue());
-        } else {
-            PlatformDependent.safeConstructPutInt(instance, offset, initialValue());
-        }
+    public final void setInitialValue(T instance) {
+        safeInitializeRawRefCnt(instance, initialValue());
     }
 
     private static int realRefCnt(int rawCnt) {
@@ -83,20 +74,12 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
         throw new IllegalReferenceCountException(0, -decrement);
     }
 
-    private int nonVolatileRawCnt(T instance) {
-        // TODO: Once we compile against later versions of Java we can replace the Unsafe usage here by varhandles.
-        final long offset = unsafeOffset();
-        return offset != -1 ? PlatformDependent.getInt(instance, offset) : updater().get(instance);
-    }
-
     public final int refCnt(T instance) {
-        return realRefCnt(updater().get(instance));
+        return realRefCnt(getAcquireRawRefCnt(instance));
     }
 
     public final boolean isLiveNonVolatile(T instance) {
-        final long offset = unsafeOffset();
-        final int rawCnt = offset != -1 ? PlatformDependent.getInt(instance, offset) : updater().get(instance);
-
+        final int rawCnt = getRawRefCnt(instance);
         // The "real" ref count is > 0 if the rawCnt is even.
         return rawCnt == 2 || rawCnt == 4 || rawCnt == 6 || rawCnt == 8 || (rawCnt & 1) == 0;
     }
@@ -105,7 +88,8 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
      * An unsafe operation that sets the reference count directly
      */
     public final void setRefCnt(T instance, int refCnt) {
-        updater().set(instance, refCnt > 0 ? refCnt << 1 : 1); // overflow OK here
+        int rawRefCnt = refCnt > 0 ? refCnt << 1 : 1; // overflow OK here
+        setReleaseRawRefCnt(instance, rawRefCnt);
     }
 
     /**
@@ -113,7 +97,7 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
      */
     public final void resetRefCnt(T instance) {
         // no need of a volatile set, it should happen in a quiescent state
-        updater().lazySet(instance, initialValue());
+        setReleaseRawRefCnt(instance, initialValue());
     }
 
     public final T retain(T instance) {
@@ -128,7 +112,7 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
 
     // rawIncrement == increment << 1
     private T retain0(T instance, final int increment, final int rawIncrement) {
-        int oldRef = updater().getAndAdd(instance, rawIncrement);
+        int oldRef = getAndAddRawRefCnt(instance, rawIncrement);
         if (oldRef != 2 && oldRef != 4 && (oldRef & 1) != 0) {
             throw new IllegalReferenceCountException(0, increment);
         }
@@ -136,33 +120,33 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
         if ((oldRef <= 0 && oldRef + rawIncrement >= 0)
                 || (oldRef >= 0 && oldRef + rawIncrement < oldRef)) {
             // overflow case
-            updater().getAndAdd(instance, -rawIncrement);
+            getAndAddRawRefCnt(instance, -rawIncrement);
             throw new IllegalReferenceCountException(realRefCnt(oldRef), increment);
         }
         return instance;
     }
 
     public final boolean release(T instance) {
-        int rawCnt = nonVolatileRawCnt(instance);
+        int rawCnt = getRawRefCnt(instance);
         return rawCnt == 2 ? tryFinalRelease0(instance, 2) || retryRelease0(instance, 1)
                 : nonFinalRelease0(instance, 1, rawCnt, toLiveRealRefCnt(rawCnt, 1));
     }
 
     public final boolean release(T instance, int decrement) {
-        int rawCnt = nonVolatileRawCnt(instance);
+        int rawCnt = getRawRefCnt(instance);
         int realCnt = toLiveRealRefCnt(rawCnt, checkPositive(decrement, "decrement"));
         return decrement == realCnt ? tryFinalRelease0(instance, rawCnt) || retryRelease0(instance, decrement)
                 : nonFinalRelease0(instance, decrement, rawCnt, realCnt);
     }
 
     private boolean tryFinalRelease0(T instance, int expectRawCnt) {
-        return updater().compareAndSet(instance, expectRawCnt, 1); // any odd number will work
+        return casRawRefCnt(instance, expectRawCnt, 1); // any odd number will work
     }
 
     private boolean nonFinalRelease0(T instance, int decrement, int rawCnt, int realCnt) {
         if (decrement < realCnt
                 // all changes to the raw count are 2x the "real" change - overflow is OK
-                && updater().compareAndSet(instance, rawCnt, rawCnt - (decrement << 1))) {
+                && casRawRefCnt(instance, rawCnt, rawCnt - (decrement << 1))) {
             return false;
         }
         return retryRelease0(instance, decrement);
@@ -170,14 +154,14 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
 
     private boolean retryRelease0(T instance, int decrement) {
         for (;;) {
-            int rawCnt = updater().get(instance), realCnt = toLiveRealRefCnt(rawCnt, decrement);
+            int rawCnt = getRawRefCnt(instance), realCnt = toLiveRealRefCnt(rawCnt, decrement);
             if (decrement == realCnt) {
                 if (tryFinalRelease0(instance, rawCnt)) {
                     return true;
                 }
             } else if (decrement < realCnt) {
                 // all changes to the raw count are 2x the "real" change
-                if (updater().compareAndSet(instance, rawCnt, rawCnt - (decrement << 1))) {
+                if (casRawRefCnt(instance, rawCnt, rawCnt - (decrement << 1))) {
                     return false;
                 }
             } else {
@@ -186,4 +170,32 @@ public abstract class ReferenceCountUpdater<T extends ReferenceCounted> {
             Thread.yield(); // this benefits throughput under high contention
         }
     }
+
+    public enum UpdaterType {
+        Unsafe,
+        VarHandle,
+        Atomic
+    }
+
+    public static <T extends ReferenceCounted> UpdaterType updaterTypeOf(Class<T> clz, String fieldName) {
+        long fieldOffset = getUnsafeOffset(clz, fieldName);
+        if (fieldOffset >= 0) {
+            return UpdaterType.Unsafe;
+        }
+        if (PlatformDependent.hasVarHandle()) {
+            return UpdaterType.VarHandle;
+        }
+        return UpdaterType.Atomic;
+    }
+
+    public static long getUnsafeOffset(Class<? extends ReferenceCounted> clz, String fieldName) {
+        try {
+            if (PlatformDependent.hasUnsafe()) {
+                return PlatformDependent.objectFieldOffset(clz.getDeclaredField(fieldName));
+            }
+        } catch (Throwable ignore) {
+            // fall-back
+        }
+        return -1;
+    }
 }
diff --git a/common/src/main/java/io/netty/util/internal/UnsafeReferenceCountUpdater.java b/common/src/main/java/io/netty/util/internal/UnsafeReferenceCountUpdater.java
new file mode 100644
index 0000000000..e4d952b6a3
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/UnsafeReferenceCountUpdater.java
@@ -0,0 +1,56 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.internal;
+
+import io.netty.util.ReferenceCounted;
+
+public abstract class UnsafeReferenceCountUpdater<T extends ReferenceCounted> extends ReferenceCountUpdater<T> {
+
+    protected UnsafeReferenceCountUpdater() {
+    }
+
+    protected abstract long refCntFieldOffset();
+
+    @Override
+    protected final void safeInitializeRawRefCnt(T refCntObj, int value) {
+        PlatformDependent.safeConstructPutInt(refCntObj, refCntFieldOffset(), value);
+    }
+
+    @Override
+    protected final int getAndAddRawRefCnt(T refCntObj, int increment) {
+        return PlatformDependent.getAndAddInt(refCntObj, refCntFieldOffset(), increment);
+    }
+
+    @Override
+    protected final int getRawRefCnt(T refCnt) {
+        return PlatformDependent.getInt(refCnt, refCntFieldOffset());
+    }
+
+    @Override
+    protected final int getAcquireRawRefCnt(T refCnt) {
+        return PlatformDependent.getVolatileInt(refCnt, refCntFieldOffset());
+    }
+
+    @Override
+    protected final void setReleaseRawRefCnt(T refCnt, int value) {
+        PlatformDependent.putOrderedInt(refCnt, refCntFieldOffset(), value);
+    }
+
+    @Override
+    protected final boolean casRawRefCnt(T refCnt, int expected, int value) {
+        return PlatformDependent.compareAndSwapInt(refCnt, refCntFieldOffset(), expected, value);
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/VarHandleFactory.java b/common/src/main/java/io/netty/util/internal/VarHandleFactory.java
new file mode 100644
index 0000000000..077d15e91d
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/VarHandleFactory.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+
+package io.netty.util.internal;
+
+import java.lang.invoke.MethodHandle;
+import java.lang.invoke.MethodHandles;
+import java.lang.invoke.MethodType;
+import java.lang.invoke.VarHandle;
+import java.nio.ByteOrder;
+
+final class VarHandleFactory {
+
+    private VarHandleFactory() {
+    }
+
+    private static final MethodHandle FIND_VAR_HANDLE;
+    private static final MethodHandle PRIVATE_LOOKUP_IN;
+    private static final VarHandle LONG_LE_ARRAY_VIEW;
+    private static final VarHandle LONG_BE_ARRAY_VIEW;
+    private static final VarHandle INT_LE_ARRAY_VIEW;
+    private static final VarHandle INT_BE_ARRAY_VIEW;
+    private static final VarHandle SHORT_LE_ARRAY_VIEW;
+    private static final VarHandle SHORT_BE_ARRAY_VIEW;
+    private static final Throwable UNAVAILABILITY_CAUSE;
+
+    static {
+        MethodHandle findVarHandle = null;
+        MethodHandle privateLookupIn = null;
+        VarHandle longLeArrayViewHandle = null;
+        VarHandle longBeArrayViewHandle = null;
+        VarHandle intLeArrayViewHandle = null;
+        VarHandle intBeArrayViewHandle = null;
+        VarHandle shortLeArrayViewHandle = null;
+        VarHandle shortBeArrayViewHandle = null;
+        Throwable error = null;
+        try {
+            MethodHandles.Lookup lookup = MethodHandles.lookup();
+            findVarHandle = lookup.findVirtual(MethodHandles.Lookup.class, "findVarHandle",
+                    MethodType.methodType(VarHandle.class, Class.class, String.class, Class.class));
+            privateLookupIn = lookup.findStatic(MethodHandles.class, "privateLookupIn",
+                    MethodType.methodType(MethodHandles.Lookup.class, Class.class, MethodHandles.Lookup.class));
+            MethodHandle byteArrayViewHandle = lookup.findStatic(MethodHandles.class, "byteArrayViewVarHandle",
+                    MethodType.methodType(VarHandle.class, Class.class, ByteOrder.class));
+            longLeArrayViewHandle = (VarHandle) byteArrayViewHandle.invokeExact(long[].class, ByteOrder.LITTLE_ENDIAN);
+            longBeArrayViewHandle = (VarHandle) byteArrayViewHandle.invokeExact(long[].class, ByteOrder.BIG_ENDIAN);
+            intLeArrayViewHandle = (VarHandle) byteArrayViewHandle.invokeExact(int[].class, ByteOrder.LITTLE_ENDIAN);
+            intBeArrayViewHandle = (VarHandle) byteArrayViewHandle.invokeExact(int[].class, ByteOrder.BIG_ENDIAN);
+            shortLeArrayViewHandle = (VarHandle) byteArrayViewHandle.invokeExact(
+                    short[].class, ByteOrder.LITTLE_ENDIAN);
+            shortBeArrayViewHandle = (VarHandle) byteArrayViewHandle.invokeExact(short[].class, ByteOrder.BIG_ENDIAN);
+            error = null;
+        } catch (Throwable e) {
+            error = e;
+            findVarHandle = null;
+            privateLookupIn = null;
+            longLeArrayViewHandle = null;
+            longBeArrayViewHandle = null;
+            intLeArrayViewHandle = null;
+            intBeArrayViewHandle = null;
+            shortLeArrayViewHandle = null;
+        } finally {
+            FIND_VAR_HANDLE = findVarHandle;
+            PRIVATE_LOOKUP_IN = privateLookupIn;
+            LONG_LE_ARRAY_VIEW = longLeArrayViewHandle;
+            LONG_BE_ARRAY_VIEW = longBeArrayViewHandle;
+            INT_LE_ARRAY_VIEW = intLeArrayViewHandle;
+            INT_BE_ARRAY_VIEW = intBeArrayViewHandle;
+            SHORT_LE_ARRAY_VIEW = shortLeArrayViewHandle;
+            SHORT_BE_ARRAY_VIEW = shortBeArrayViewHandle;
+            UNAVAILABILITY_CAUSE = error;
+        }
+    }
+
+    public static boolean isSupported() {
+        return UNAVAILABILITY_CAUSE == null;
+    }
+
+    public static Throwable unavailableCause() {
+        return UNAVAILABILITY_CAUSE;
+    }
+
+    private static MethodHandles.Lookup privateLookup(MethodHandles.Lookup lookup, Class<?> targetClass) {
+        try {
+            return (MethodHandles.Lookup) PRIVATE_LOOKUP_IN.invokeExact(targetClass, lookup);
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static VarHandle privateFindVarHandle(MethodHandles.Lookup lookup, Class<?> declaringClass,
+                                                 String name, Class<?> type) {
+        try {
+            return (VarHandle) FIND_VAR_HANDLE.invokeExact(privateLookup(lookup, declaringClass),
+                    declaringClass, name, type);
+        } catch (Throwable e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static VarHandle longLeArrayView() {
+        return LONG_LE_ARRAY_VIEW;
+    }
+
+    public static VarHandle longBeArrayView() {
+        return LONG_BE_ARRAY_VIEW;
+    }
+
+    public static VarHandle intLeArrayView() {
+        return INT_LE_ARRAY_VIEW;
+    }
+
+    public static VarHandle intBeArrayView() {
+        return INT_BE_ARRAY_VIEW;
+    }
+
+    public static VarHandle shortLeArrayView() {
+        return SHORT_LE_ARRAY_VIEW;
+    }
+
+    public static VarHandle shortBeArrayView() {
+        return SHORT_BE_ARRAY_VIEW;
+    }
+}
diff --git a/common/src/main/java/io/netty/util/internal/VarHandleReferenceCountUpdater.java b/common/src/main/java/io/netty/util/internal/VarHandleReferenceCountUpdater.java
new file mode 100644
index 0000000000..fdcd6208f1
--- /dev/null
+++ b/common/src/main/java/io/netty/util/internal/VarHandleReferenceCountUpdater.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.util.internal;
+
+import io.netty.util.ReferenceCounted;
+import java.lang.invoke.VarHandle;
+
+public abstract class VarHandleReferenceCountUpdater<T extends ReferenceCounted>
+        extends ReferenceCountUpdater<T> {
+
+    protected VarHandleReferenceCountUpdater() {
+    }
+
+    protected abstract VarHandle varHandle();
+
+    @Override
+    protected final void safeInitializeRawRefCnt(T refCntObj, int value) {
+        varHandle().set(refCntObj, value);
+    }
+
+    @Override
+    protected final int getAndAddRawRefCnt(T refCntObj, int increment) {
+        return (int) varHandle().getAndAdd(refCntObj, increment);
+    }
+
+    @Override
+    protected final int getRawRefCnt(T refCnt) {
+        return (int) varHandle().get(refCnt);
+    }
+
+    @Override
+    protected final int getAcquireRawRefCnt(T refCnt) {
+        return (int) varHandle().getAcquire(refCnt);
+    }
+
+    @Override
+    protected final void setReleaseRawRefCnt(T refCnt, int value) {
+        varHandle().setRelease(refCnt, value);
+    }
+
+    @Override
+    protected final boolean casRawRefCnt(T refCnt, int expected, int value) {
+        return varHandle().compareAndSet(refCnt, expected, value);
+    }
+}
diff --git a/microbench/src/main/java/io/netty/buffer/ByteBufAccessBenchmark.java b/microbench/src/main/java/io/netty/buffer/ByteBufAccessBenchmark.java
index 14a58ff4d7..6cfd72611e 100644
--- a/microbench/src/main/java/io/netty/buffer/ByteBufAccessBenchmark.java
+++ b/microbench/src/main/java/io/netty/buffer/ByteBufAccessBenchmark.java
@@ -84,6 +84,13 @@ public class ByteBufAccessBenchmark extends AbstractMicrobenchmark {
                         UnpooledByteBufAllocator.DEFAULT, 64, 64).setIndex(0, 64);
             }
         },
+        DIRECT {
+            @Override
+            ByteBuf newBuffer() {
+                return new UnpooledDirectByteBuf(
+                        UnpooledByteBufAllocator.DEFAULT, 64, 64).setIndex(0, 64);
+            }
+        },
         UNSAFE_SLICE {
             @Override
             ByteBuf newBuffer() {
@@ -108,8 +115,13 @@ public class ByteBufAccessBenchmark extends AbstractMicrobenchmark {
         HEAP {
             @Override
             ByteBuf newBuffer() {
-                return new UnpooledUnsafeHeapByteBuf(
-                        UnpooledByteBufAllocator.DEFAULT, 64, 64).setIndex(0,  64);
+                if (PlatformDependent.hasUnsafe()) {
+                    return new UnpooledUnsafeHeapByteBuf(
+                            UnpooledByteBufAllocator.DEFAULT, 64, 64).setIndex(0, 64);
+                } else {
+                    return new UnpooledHeapByteBuf(
+                            UnpooledByteBufAllocator.DEFAULT, 64, 64).setIndex(0, 64);
+                }
             }
         },
         COMPOSITE {
diff --git a/pom.xml b/pom.xml
index 4a23b2d5b7..88f68e3ab5 100644
--- a/pom.xml
+++ b/pom.xml
@@ -809,6 +809,7 @@
     <module>transport-blockhound-tests</module>
     <module>microbench</module>
     <module>jfr-stub</module>
+    <module>varhandle-stub</module>
     <module>bom</module>
   </modules>
 
diff --git a/varhandle-stub/pom.xml b/varhandle-stub/pom.xml
new file mode 100644
index 0000000000..714be69046
--- /dev/null
+++ b/varhandle-stub/pom.xml
@@ -0,0 +1,35 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+  ~ Copyright 2025 The Netty Project
+  ~
+  ~ The Netty Project licenses this file to you under the Apache License,
+  ~ version 2.0 (the "License"); you may not use this file except in compliance
+  ~ with the License. You may obtain a copy of the License at:
+  ~
+  ~   https://www.apache.org/licenses/LICENSE-2.0
+  ~
+  ~ Unless required by applicable law or agreed to in writing, software
+  ~ distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+  ~ WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+  ~ License for the specific language governing permissions and limitations
+  ~ under the License.
+  -->
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/maven-v4_0_0.xsd">
+
+  <modelVersion>4.0.0</modelVersion>
+  <parent>
+    <groupId>io.netty</groupId>
+    <artifactId>netty-parent</artifactId>
+    <version>4.2.4.Final-SNAPSHOT</version>
+  </parent>
+
+  <artifactId>netty-varhandle-stub</artifactId>
+  <packaging>jar</packaging>
+
+  <name>Netty/VarHandle Stub</name>
+
+  <properties>
+    <revapi.skip>true</revapi.skip>
+  </properties>
+</project>
+
diff --git a/varhandle-stub/src/main/java/java/lang/invoke/MethodHandle.java b/varhandle-stub/src/main/java/java/lang/invoke/MethodHandle.java
new file mode 100644
index 0000000000..f530473c4c
--- /dev/null
+++ b/varhandle-stub/src/main/java/java/lang/invoke/MethodHandle.java
@@ -0,0 +1,23 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package java.lang.invoke;
+
+public class MethodHandle {
+    @java.lang.annotation.Target({java.lang.annotation.ElementType.METHOD})
+    @java.lang.annotation.Retention(java.lang.annotation.RetentionPolicy.RUNTIME)
+    @interface PolymorphicSignature {
+    }
+}
diff --git a/varhandle-stub/src/main/java/java/lang/invoke/VarHandle.java b/varhandle-stub/src/main/java/java/lang/invoke/VarHandle.java
new file mode 100644
index 0000000000..6271dd5b90
--- /dev/null
+++ b/varhandle-stub/src/main/java/java/lang/invoke/VarHandle.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package java.lang.invoke;
+
+/**
+ * A stub for the VarHandle class.<br>
+ * This stub is used to allow Java 8 release compilation to work as expected.
+ * The sole limit of this stub is that since {@code java.lang.invoke} is a privileged package
+ * it cannot be used at runtime (e.g. loaded by a classloader).<p>
+ * For example, if {@code SomeClass} is loaded at runtime:
+ * <pre>
+ *     class SomeClass {
+ *          private static final VarHandle VH = // ... obtained somehow;
+ *
+ *          public static void storeStoreFence() {
+ *              if (VH == null) {
+ *                  return;
+ *              }
+ *              VH.storeStoreFence();
+ *          }
+ *     }
+ * </pre>
+ * this is not going to work on Java 8.<p>
+ * To fix it is possible to use an holder class (which won't be loaded at runtime):
+ * <pre>
+ *     class SomeClass {
+ *          static class Holder {
+ *              private static final VarHandle VH = // ... obtained somehow;
+ *          }
+ *
+ *          public static void storeStoreFence() {
+ *              VarHandle vh = Holder.VH;
+ *              if (vh == null) {
+ *                  return;
+ *              }
+ *              vh.storeStoreFence();
+ *          }
+ *     }
+ * </pre>
+ * Or:
+ * <pre>
+ *     class SomeClass {
+ *          private static final Object VH = // ... obtained somehow;
+ *
+ *          public static void storeStoreFence() {
+ *              if (VH == null) {
+ *                  return;
+ *              }
+ *              ((VarHandle)VH).storeStoreFence();
+ *          }
+ *     }
+ * </pre>
+ *
+ * The reason why the methods on the stub are declared as native is to allow
+ * {@link java.lang.invoke.MethodHandle.PolymorphicSignature} to work as expected,
+ * see <a href="https://docs.oracle.com/javase/specs/jls/se9/html/jls-15.html#jls-15.12.3">JLS 15.12.3</a>:<br>
+ * <pre>
+ *   A method is signature polymorphic if all of the following are true:
+ *   - It is declared in the java.lang.invoke.MethodHandle class or the java.lang.invoke.VarHandle class.
+ *   - It has a single variable arity parameter (8.4.1) whose declared type is Object[].
+ *   - It is native.
+ * </pre>
+ * This seems counter-intuitive since this stub is not going to be used at runtime, but it is required to allow Java 8
+ * compilation to produce {@code VarHandle}'s method invocations with parameters and result types with
+ * the types of the formal ones of the compile-time declaration.
+ *
+ */
+public class VarHandle {
+
+    @MethodHandle.PolymorphicSignature
+    public native Object get(Object... args);
+
+    @MethodHandle.PolymorphicSignature
+    public native Object getAcquire(Object... args);
+
+    @MethodHandle.PolymorphicSignature
+    public native void set(Object... args);
+
+    @MethodHandle.PolymorphicSignature
+    public native void setRelease(Object... args);
+
+    @MethodHandle.PolymorphicSignature
+    public native Object getAndAdd(Object... args);
+
+    @MethodHandle.PolymorphicSignature
+    public native boolean compareAndSet(Object... args);
+
+    public static void storeStoreFence() {
+        throw new UnsupportedOperationException("Not implemented in varhandle-stub");
+    }
+}
diff --git a/varhandle-stub/src/main/java/java/lang/invoke/package-info.java b/varhandle-stub/src/main/java/java/lang/invoke/package-info.java
new file mode 100644
index 0000000000..df758192c7
--- /dev/null
+++ b/varhandle-stub/src/main/java/java/lang/invoke/package-info.java
@@ -0,0 +1,19 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+/**
+ * Stubs to compile VarHandle on Java 8. Not guaranteed to be stable API!
+ */
+package java.lang.invoke;
