diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java
index bfb28520c9..841aa44671 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java
@@ -27,12 +27,14 @@ public final class IoUring {
     private static final boolean IORING_CQE_F_SOCK_NONEMPTY_SUPPORTED;
     private static final boolean IORING_SPLICE_SUPPORTED;
     private static final boolean IORING_ACCEPT_NO_WAIT_SUPPORTED;
+    private static final boolean IORING_REGISTER_IOWQ_MAX_WORKERS_SUPPORTED;
 
     static {
         Throwable cause = null;
         boolean socketNonEmptySupported = false;
         boolean spliceSupported = false;
         boolean acceptSupportNoWait = false;
+        boolean registerIowqWorkersSupported = false;
         try {
             if (SystemPropertyUtil.getBoolean("io.netty.transport.noNative", false)) {
                 cause = new UnsupportedOperationException(
@@ -50,6 +52,7 @@ public final class IoUring {
                         spliceSupported = Native.isIOUringSupportSplice(ringBuffer.fd());
                         // IORING_FEAT_RECVSEND_BUNDLE was adde in the same release.
                         acceptSupportNoWait = (ringBuffer.features() & Native.IORING_FEAT_RECVSEND_BUNDLE) != 0;
+                        registerIowqWorkersSupported = Native.isRegisterIOWQWorkerSupported(ringBuffer.fd());
                     } finally {
                         if (ringBuffer != null) {
                             try {
@@ -78,6 +81,7 @@ public final class IoUring {
         IORING_CQE_F_SOCK_NONEMPTY_SUPPORTED = socketNonEmptySupported;
         IORING_SPLICE_SUPPORTED = spliceSupported;
         IORING_ACCEPT_NO_WAIT_SUPPORTED = acceptSupportNoWait;
+        IORING_REGISTER_IOWQ_MAX_WORKERS_SUPPORTED = registerIowqWorkersSupported;
     }
 
     public static boolean isAvailable() {
@@ -116,6 +120,10 @@ public final class IoUring {
         return IORING_ACCEPT_NO_WAIT_SUPPORTED;
     }
 
+    static boolean isRegisterIowqMaxWorkersSupported() {
+        return IORING_REGISTER_IOWQ_MAX_WORKERS_SUPPORTED;
+    }
+
     public static void ensureAvailability() {
         if (UNAVAILABILITY_CAUSE != null) {
             throw (Error) new UnsatisfiedLinkError(
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandler.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandler.java
index 295af8fef1..b1e7d7a33a 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandler.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandler.java
@@ -22,6 +22,7 @@ import io.netty.channel.IoHandler;
 import io.netty.channel.IoHandlerFactory;
 import io.netty.channel.IoOps;
 import io.netty.channel.IoRegistration;
+import io.netty.channel.unix.Errors;
 import io.netty.channel.unix.FileDescriptor;
 import io.netty.util.collection.IntObjectHashMap;
 import io.netty.util.collection.IntObjectMap;
@@ -34,6 +35,7 @@ import io.netty.util.internal.logging.InternalLogger;
 import io.netty.util.internal.logging.InternalLoggerFactory;
 
 import java.io.IOException;
+import java.io.UncheckedIOException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.RejectedExecutionException;
@@ -70,10 +72,21 @@ public final class IoUringIoHandler implements IoHandler {
     private static final int RINGFD_ID = EVENTFD_ID - 1;
     private static final int INVALID_ID = 0;
 
-    IoUringIoHandler(RingBuffer ringBuffer) {
+    IoUringIoHandler(IoUringIoHandlerConfiguration config) {
         // Ensure that we load all native bits as otherwise it may fail when try to use native methods in IovArray
         IoUring.ensureAvailability();
-        this.ringBuffer = requireNonNull(ringBuffer, "ringBuffer");
+        requireNonNull(config, "config");
+        this.ringBuffer = Native.createRingBuffer(config.getRingSize());
+        if (IoUring.isRegisterIowqMaxWorkersSupported() && config.needRegisterIowqMaxWorker()) {
+            int maxBoundedWorker = Math.max(config.getMaxBoundedWorker(), 0);
+            int maxUnboundedWorker = Math.max(config.getMaxUnboundedWorker(), 0);
+            int result = Native.ioUringRegisterIoWqMaxWorkers(ringBuffer.fd(), maxBoundedWorker, maxUnboundedWorker);
+            if (result < 0) {
+                // Close ringBuffer before throwing to ensure we release all memory on failure.
+                ringBuffer.close();
+                throw new UncheckedIOException(Errors.newIOException("io_uring_register", result));
+            }
+        }
         registrations = new IntObjectHashMap<>();
         eventfd = Native.newBlockingEventFd();
         eventfdReadBuf = PlatformDependent.allocateMemory(8);
@@ -416,8 +429,7 @@ public final class IoUringIoHandler implements IoHandler {
      * @return factory
      */
     public static IoHandlerFactory newFactory() {
-        IoUring.ensureAvailability();
-        return () -> new IoUringIoHandler(Native.createRingBuffer());
+        return newFactory(new IoUringIoHandlerConfiguration());
     }
 
     /**
@@ -428,8 +440,21 @@ public final class IoUringIoHandler implements IoHandler {
      * @return              factory
      */
     public static IoHandlerFactory newFactory(int ringSize) {
+        IoUringIoHandlerConfiguration configuration = new IoUringIoHandlerConfiguration();
+        configuration.setRingSize(ringSize);
+        return () -> new IoUringIoHandler(configuration);
+    }
+
+    /**
+     * Create a new {@link IoHandlerFactory} that can be used to create {@link IoUringIoHandler}s.
+     * Each {@link IoUringIoHandler} will use same option
+     * @param config the io_uring configuration
+     * @return factory
+     */
+    public static IoHandlerFactory newFactory(IoUringIoHandlerConfiguration config) {
         IoUring.ensureAvailability();
-        ObjectUtil.checkPositive(ringSize, "ringSize");
-        return () -> new IoUringIoHandler(Native.createRingBuffer(ringSize));
+        ObjectUtil.checkNotNull(config, "config");
+        return () -> new IoUringIoHandler(config);
     }
+
 }
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandlerConfiguration.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandlerConfiguration.java
new file mode 100644
index 0000000000..138c6d224c
--- /dev/null
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandlerConfiguration.java
@@ -0,0 +1,123 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.uring;
+
+import io.netty.util.internal.ObjectUtil;
+
+/**
+ * Configuration class for an {@link IoUringIoHandler},
+ * managing the settings for a {@link RingBuffer} and its io_uring file descriptor.
+ *
+ * <h3>Option Map</h3>
+ * These options are used exclusively during the initialization of the {@link IoUringIoHandler}
+ * to configure the associated io_uring instance.
+ *
+ * <p>
+ * The {@link IoUringIoHandlerConfiguration} class provides the following configurable options:
+ * </p>
+ *
+ * <table border="1" cellspacing="0" cellpadding="6">
+ *   <caption>Available Configuration Options</caption>
+ *   <thead>
+ *     <tr>
+ *       <th>Setter Method</th>
+ *       <th>Description</th>
+ *     </tr>
+ *   </thead>
+ *   <tbody>
+ *     <tr>
+ *       <td>{@link IoUringIoHandlerConfiguration#setRingSize}</td>
+ *       <td>Sets the size of the submission queue for the io_uring instance.</td>
+ *     </tr>
+ *     <tr>
+ *       <td>{@link IoUringIoHandlerConfiguration#setMaxBoundedWorker}</td>
+ *       <td>Defines the maximum number of bounded io_uring worker threads.</td>
+ *     </tr>
+ *     <tr>
+ *       <td>{@link IoUringIoHandlerConfiguration#setMaxUnboundedWorker}</td>
+ *       <td>Defines the maximum number of unbounded io_uring worker threads.</td>
+ *     </tr>
+ *   </tbody>
+ * </table>
+ */
+
+public final class IoUringIoHandlerConfiguration {
+    private int ringSize = Native.DEFAULT_RING_SIZE;
+
+    private int maxBoundedWorker;
+
+    private int maxUnboundedWorker;
+
+    /**
+     * Return the ring size of the io_uring instance.
+     * @return the ring size of the io_uring instance.
+     */
+    public int getRingSize() {
+        return ringSize;
+    }
+
+    /**
+     * Return the maximum number of bounded iowq worker threads.
+     * @return the maximum number of bounded iowq worker threads.
+     */
+    public int getMaxBoundedWorker() {
+        return maxBoundedWorker;
+    }
+
+    /**
+     * Return the maximum number of unbounded iowq worker threads.
+     * @return the maximum number of unbounded iowq worker threads.
+     */
+    public int getMaxUnboundedWorker() {
+        return maxUnboundedWorker;
+    }
+
+    /**
+     * Set the ring size of the io_uring instance.
+     * @param ringSize the ring size of the io_uring instance.
+     * @return reference to this, so the API can be used fluently
+     */
+    public IoUringIoHandlerConfiguration setRingSize(int ringSize) {
+        this.ringSize = ObjectUtil.checkPositive(ringSize, "ringSize");
+        return this;
+    }
+
+    /**
+     * Set the maximum number of bounded iowq worker threads.
+     * @param maxBoundedWorker the maximum number of bounded iowq worker threads,
+     *                         or 0 for the Linux kernel default
+     * @return reference to this, so the API can be used fluently
+     */
+    public IoUringIoHandlerConfiguration setMaxBoundedWorker(int maxBoundedWorker) {
+        this.maxBoundedWorker = ObjectUtil.checkPositiveOrZero(maxBoundedWorker, "maxBoundedWorker");
+        return this;
+    }
+
+    /**
+     * Set the maximum number of unbounded iowq worker threads.
+     * @param maxUnboundedWorker the maximum number of unbounded iowq worker threads,
+     *                           of 0 for the Linux kernel default
+     * @return reference to this, so the API can be used fluently
+     */
+    public IoUringIoHandlerConfiguration setMaxUnboundedWorker(int maxUnboundedWorker) {
+        this.maxUnboundedWorker = ObjectUtil.checkPositiveOrZero(maxUnboundedWorker, "maxUnboundedWorker");
+        return this;
+    }
+
+    boolean needRegisterIowqMaxWorker() {
+        return maxBoundedWorker > 0 || maxUnboundedWorker > 0;
+    }
+}
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/Native.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/Native.java
index 8205470ad7..3c98a33701 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/Native.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/Native.java
@@ -340,10 +340,25 @@ final class Native {
         return ioUringProbe(ringFd, new int[] { Native.IORING_OP_SPLICE });
     }
 
+    /**
+     * check current kernel version whether support io_uring_register_io_wq_worker
+     * Available since 5.15.
+     * @return true if support io_uring_register_io_wq_worker
+     */
+    static boolean isRegisterIOWQWorkerSupported(int ringFd) {
+        // See https://github.com/torvalds/linux/blob/v5.5/fs/io_uring.c#L5488C10-L5488C16
+        int result = ioUringRegisterIoWqMaxWorkers(ringFd, 0, 0);
+        if (result >= 0) {
+            return true;
+        }
+        // This is not supported and so will return -EINVAL
+        return false;
+    }
+
     static void checkKernelVersion(String kernelVersion) {
         boolean enforceKernelVersion = SystemPropertyUtil.getBoolean(
-                "io.netty5.transport.iouring.enforceKernelVersion", true);
-        boolean kernelSupported = checkKernelVersion0(kernelVersion);
+                "io.netty.transport.iouring.enforceKernelVersion", true);
+        boolean kernelSupported = checkKernelVersion(kernelVersion, 5, 9);
         if (!kernelSupported) {
             if (enforceKernelVersion) {
                 throw new UnsupportedOperationException(
@@ -355,39 +370,41 @@ final class Native {
         }
     }
 
-    private static boolean checkKernelVersion0(String kernelVersion) {
+    private static boolean checkKernelVersion(String kernelVersion, int major, int minor) {
         String[] versionComponents = kernelVersion.split("\\.");
         if (versionComponents.length < 3) {
             return false;
         }
-
-        int major;
+        int nativeMajor;
         try {
-            major = Integer.parseInt(versionComponents[0]);
+            nativeMajor = Integer.parseInt(versionComponents[0]);
         } catch (NumberFormatException e) {
             return false;
         }
 
-        if (major <= 4) {
+        if (nativeMajor < major) {
             return false;
         }
-        if (major > 5) {
+
+        if (nativeMajor > major) {
             return true;
         }
 
-        int minor;
+        int nativeMinor;
         try {
-            minor = Integer.parseInt(versionComponents[1]);
+            nativeMinor = Integer.parseInt(versionComponents[1]);
         } catch (NumberFormatException e) {
             return false;
         }
 
-        return minor >= 9;
+        return nativeMinor >= minor;
     }
 
     private static native boolean ioUringProbe(int ringFd, int[] ios);
     private static native long[] ioUringSetup(int entries);
 
+    static native int ioUringRegisterIoWqMaxWorkers(int ringFd, int maxBoundedValue, int maxUnboundedValue);
+
     static native int ioUringEnter(int ringFd, int toSubmit, int minComplete, int flags);
 
     static native void eventFdWrite(int fd, long value);
diff --git a/transport-native-io_uring/src/main/c/io_uring.h b/transport-native-io_uring/src/main/c/io_uring.h
index edc389bb6a..60623b484c 100644
--- a/transport-native-io_uring/src/main/c/io_uring.h
+++ b/transport-native-io_uring/src/main/c/io_uring.h
@@ -295,6 +295,18 @@ enum {
 	IORING_UNREGISTER_PERSONALITY		= 10,
 	IORING_REGISTER_RESTRICTIONS		= 11,
 	IORING_REGISTER_ENABLE_RINGS		= 12,
+	/* extended with tagging */
+	IORING_REGISTER_FILES2			= 13,
+	IORING_REGISTER_FILES_UPDATE2		= 14,
+	IORING_REGISTER_BUFFERS2		= 15,
+	IORING_REGISTER_BUFFERS_UPDATE		= 16,
+
+	/* set/clear io-wq thread affinities */
+	IORING_REGISTER_IOWQ_AFF		= 17,
+	IORING_UNREGISTER_IOWQ_AFF		= 18,
+
+	/* set/get max number of io-wq workers */
+	IORING_REGISTER_IOWQ_MAX_WORKERS	= 19,
 
 	/* this goes last */
 	IORING_REGISTER_LAST
diff --git a/transport-native-io_uring/src/main/c/netty_io_uring_native.c b/transport-native-io_uring/src/main/c/netty_io_uring_native.c
index d43c3bee10..5aef9bdef9 100644
--- a/transport-native-io_uring/src/main/c/netty_io_uring_native.c
+++ b/transport-native-io_uring/src/main/c/netty_io_uring_native.c
@@ -326,6 +326,13 @@ static jlongArray netty_io_uring_setup(JNIEnv *env, jclass clazz, jint entries)
     return array;
 }
 
+static jint netty_io_uring_register_iowq_max_workers(JNIEnv *env, jclass clazz, jint ringFd, jint maxBoundedValue, jint maxUnboundedValue) {
+     int values[2];
+     values[0] = maxBoundedValue;
+     values[1] = maxUnboundedValue;
+     return sys_io_uring_register(ringFd, IORING_REGISTER_IOWQ_MAX_WORKERS, values, 2);
+}
+
 static jint netty_create_file(JNIEnv *env, jclass class, jstring filename) {
     const char *file = (*env)->GetStringUTFChars(env, filename, 0);
 
@@ -605,6 +612,7 @@ static const jint statically_referenced_fixed_method_table_size = sizeof(statica
 
 static const JNINativeMethod method_table[] = {
     {"ioUringSetup", "(I)[J", (void *) netty_io_uring_setup},
+    {"ioUringRegisterIoWqMaxWorkers","(III)I", (void*) netty_io_uring_register_iowq_max_workers },
     {"ioUringProbe", "(I[I)Z", (void *) netty_io_uring_probe},
     {"ioUringExit", "(JIJIJII)V", (void *) netty_io_uring_ring_buffer_exit},
     {"createFile", "(Ljava/lang/String;)I", (void *) netty_create_file},
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringIoHandlerTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringIoHandlerTest.java
new file mode 100644
index 0000000000..ce9c435a90
--- /dev/null
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringIoHandlerTest.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.uring;
+
+import io.netty.channel.IoHandler;
+import io.netty.channel.IoHandlerFactory;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
+
+public class IoUringIoHandlerTest {
+
+    @BeforeAll
+    public static void loadJNI() {
+        assumeTrue(IoUring.isAvailable());
+    }
+
+    @Test
+    public void testOptions() {
+        IoUringIoHandlerConfiguration config = new IoUringIoHandlerConfiguration();
+        config.setMaxBoundedWorker(2)
+                .setMaxUnboundedWorker(2);
+        IoHandlerFactory ioHandlerFactory = IoUringIoHandler.newFactory(config);
+        IoHandler handler = ioHandlerFactory.newHandler();
+        handler.destroy();
+    }
+}
