diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PrivateAuthRequest.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PrivateAuthRequest.java
new file mode 100644
index 0000000000..3cb0a7d8b2
--- /dev/null
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PrivateAuthRequest.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.socksx.v5;
+
+import io.netty.handler.codec.DecoderResult;
+import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.StringUtil;
+
+/**
+ * The default {@link Socks5PrivateAuthRequest} implementation.
+ * <p>
+ * For custom private authentication protocols, you should implement the {@link Socks5PrivateAuthRequest}
+ * interface directly. Custom protocols should also implement their own encoder/decoder to handle the wire format.
+ * </p>
+ */
+public final class DefaultSocks5PrivateAuthRequest extends AbstractSocks5Message
+    implements Socks5PrivateAuthRequest {
+
+    /**
+     * The private authentication token.
+     */
+    private final byte[] privateToken;
+
+    /**
+     * Creates a new instance with the specified token.
+     *
+     * @param privateAuthToken the private authentication token
+     */
+    public DefaultSocks5PrivateAuthRequest(final byte[] privateAuthToken) {
+        this.privateToken = ObjectUtil.checkNotNull(privateAuthToken, "privateToken").clone();
+    }
+
+    @Override
+    public byte[] privateToken() {
+        return privateToken.clone();
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder(StringUtil.simpleClassName(this));
+
+        DecoderResult decoderResult = decoderResult();
+        if (!decoderResult.isSuccess()) {
+            buf.append("(decoderResult: ");
+            buf.append(decoderResult);
+            buf.append(", privateToken: ****)");
+        } else {
+            buf.append("(privateToken: ****)");
+        }
+
+        return buf.toString();
+    }
+}
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PrivateAuthResponse.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PrivateAuthResponse.java
new file mode 100644
index 0000000000..f720229da3
--- /dev/null
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/DefaultSocks5PrivateAuthResponse.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.socksx.v5;
+
+import io.netty.handler.codec.DecoderResult;
+import io.netty.util.internal.ObjectUtil;
+import io.netty.util.internal.StringUtil;
+
+/**
+ * The default {@link Socks5PrivateAuthResponse} implementation.
+ */
+public final class DefaultSocks5PrivateAuthResponse extends AbstractSocks5Message
+    implements Socks5PrivateAuthResponse {
+
+    /**
+     * The authentication status.
+     */
+    private final Socks5PrivateAuthStatus status;
+
+    /**
+     * Creates a new instance with the specified status.
+     *
+     * @param authStatus the authentication status
+     */
+    public DefaultSocks5PrivateAuthResponse(final Socks5PrivateAuthStatus authStatus) {
+        this.status = ObjectUtil.checkNotNull(authStatus, "authStatus");
+    }
+
+    @Override
+    public Socks5PrivateAuthStatus status() {
+        return status;
+    }
+
+    @Override
+    public String toString() {
+        StringBuilder buf = new StringBuilder(StringUtil.simpleClassName(this));
+
+        DecoderResult decoderResult = decoderResult();
+        if (!decoderResult.isSuccess()) {
+            buf.append("(decoderResult: ");
+            buf.append(decoderResult);
+            buf.append(", status: ");
+            buf.append(status);
+            buf.append(')');
+        } else {
+            buf.append("(status: ");
+            buf.append(status);
+            buf.append(')');
+        }
+
+        return buf.toString();
+    }
+}
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AuthMethod.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AuthMethod.java
index 309394e7a0..2aa0f119e5 100755
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AuthMethod.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5AuthMethod.java
@@ -32,6 +32,18 @@ public class Socks5AuthMethod implements Comparable<Socks5AuthMethod> {
      */
     public static final Socks5AuthMethod UNACCEPTED = new Socks5AuthMethod(0xff, "UNACCEPTED");
 
+    /**
+     * Returns whether the authentication method code is in the private methods range (0x80-0xFE)
+     * as defined by <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928 section 3</a>.
+     *
+     * @param b The authentication method code
+     * @return true if the code is in the private methods range
+     */
+    public static boolean isPrivateMethod(byte b) {
+        int ubyte = b & 0xFF;
+        return ubyte >= 0x80 && ubyte <= 0xFE;
+    }
+
     public static Socks5AuthMethod valueOf(byte b) {
         switch (b) {
         case 0x00:
@@ -44,6 +56,11 @@ public class Socks5AuthMethod implements Comparable<Socks5AuthMethod> {
             return UNACCEPTED;
         }
 
+        // Handle all private methods (0x80-0xFE)
+        if (isPrivateMethod(b)) {
+            return new Socks5AuthMethod(b, "PRIVATE_" + (b & 0xFF));
+        }
+
         return new Socks5AuthMethod(b);
     }
 
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ClientEncoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ClientEncoder.java
index 64e3d1d9a6..d043736658 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ClientEncoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ClientEncoder.java
@@ -66,6 +66,8 @@ public class Socks5ClientEncoder extends MessageToByteEncoder<Socks5Message> {
             encodeAuthMethodRequest((Socks5InitialRequest) msg, out);
         } else if (msg instanceof Socks5PasswordAuthRequest) {
             encodePasswordAuthRequest((Socks5PasswordAuthRequest) msg, out);
+        } else if (msg instanceof Socks5PrivateAuthRequest) {
+            encodePrivateAuthRequest((Socks5PrivateAuthRequest) msg, out);
         } else if (msg instanceof Socks5CommandRequest) {
             encodeCommandRequest((Socks5CommandRequest) msg, out);
         } else {
@@ -103,6 +105,13 @@ public class Socks5ClientEncoder extends MessageToByteEncoder<Socks5Message> {
         ByteBufUtil.writeAscii(out, password);
     }
 
+    private static void encodePrivateAuthRequest(Socks5PrivateAuthRequest msg, ByteBuf out) {
+        byte[] bytes = msg.privateToken();
+        out.writeByte(0x01);
+        out.writeByte(bytes.length);
+        out.writeBytes(bytes);
+    }
+
     private void encodeCommandRequest(Socks5CommandRequest msg, ByteBuf out) throws Exception {
         out.writeByte(msg.version().byteValue());
         out.writeByte(msg.type().byteValue());
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthRequest.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthRequest.java
new file mode 100644
index 0000000000..d6a1955fed
--- /dev/null
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthRequest.java
@@ -0,0 +1,40 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.socksx.v5;
+
+/**
+ * A SOCKS5 subnegotiation request for private authentication.
+ * <p>
+ * RFC 1928 reserves method codes 0x80-0xFE for private authentication methods.
+ * This interface provides a base implementation for method 0x80, but can be extended
+ * for other private authentication methods by implementing custom encoders/decoders.
+ * </p>
+ *
+ * @see <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928 Section 3</a>
+ */
+public interface Socks5PrivateAuthRequest extends Socks5Message {
+
+    /**
+     * Returns the private token of this request.
+     * <p>
+     * For custom subnegotiation protocols, this could be extended by adding
+     * additional methods in a subinterface.
+     * </p>
+     *
+     * @return the private authentication token
+     */
+    byte[] privateToken();
+}
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthRequestDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthRequestDecoder.java
new file mode 100644
index 0000000000..35c588a3ad
--- /dev/null
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthRequestDecoder.java
@@ -0,0 +1,94 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.socksx.v5;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.DecoderException;
+import io.netty.handler.codec.DecoderResult;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.util.internal.EmptyArrays;
+
+import java.util.List;
+
+/**
+ * Decodes a single {@link Socks5PrivateAuthRequest} from the inbound {@link ByteBuf}s.
+ * On successful decode, this decoder will forward the received data to the next handler, so that
+ * other handler can remove or replace this decoder later.
+ */
+public final class Socks5PrivateAuthRequestDecoder extends ByteToMessageDecoder {
+
+    private boolean decoded;
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        try {
+            if (decoded) {
+                int readableBytes = in.readableBytes();
+                if (readableBytes > 0) {
+                    out.add(in.readRetainedSlice(readableBytes));
+                }
+                return;
+            }
+
+            // Check if we have enough data to decode the message
+            if (in.readableBytes() < 2) {
+                return;
+            }
+
+            final int startOffset = in.readerIndex();
+            final byte version = in.getByte(startOffset);
+            if (version != 1) {
+                throw new DecoderException("unsupported subnegotiation version: " + version + " (expected: 1)");
+            }
+
+            final int tokenLength = in.getUnsignedByte(startOffset + 1);
+
+            // Check if the full message is available
+            if (in.readableBytes() < 2 + tokenLength) {
+                return;
+            }
+
+            // Read the version and token length
+            in.skipBytes(2);
+
+            // Read the token
+            byte[] token = new byte[tokenLength];
+            in.readBytes(token);
+
+            // Add the decoded token to the output list
+            out.add(new DefaultSocks5PrivateAuthRequest(token));
+
+            // Mark as decoded to handle remaining bytes in future calls
+            decoded = true;
+        } catch (Exception e) {
+            fail(out, e);
+        }
+    }
+
+    private void fail(List<Object> out, Exception cause) {
+        if (!(cause instanceof DecoderException)) {
+            cause = new DecoderException(cause);
+        }
+
+        decoded = true;
+
+        Socks5Message m = new
+            DefaultSocks5PrivateAuthRequest(EmptyArrays.EMPTY_BYTES);
+        m.setDecoderResult(DecoderResult.failure(cause));
+        out.add(m);
+    }
+}
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthResponse.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthResponse.java
new file mode 100644
index 0000000000..cd0bec70f1
--- /dev/null
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthResponse.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.socksx.v5;
+
+/**
+ * A SOCKS5 subnegotiation response for private authentication.
+ * <p>
+ * This interface corresponds to the response for private authentication methods
+ * in the range 0x80-0xFE as defined in RFC 1928. For custom private authentication
+ * protocols, this interface can be extended with additional methods.
+ * </p>
+ *
+ * @see <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928 Section 3</a>
+ */
+public interface Socks5PrivateAuthResponse extends Socks5Message {
+
+    /**
+     * Returns the status of this response.
+     *
+     * @return the authentication status
+     */
+    Socks5PrivateAuthStatus status();
+}
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthResponseDecoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthResponseDecoder.java
new file mode 100644
index 0000000000..44347f490b
--- /dev/null
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthResponseDecoder.java
@@ -0,0 +1,125 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.socksx.v5;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.ByteToMessageDecoder;
+import io.netty.handler.codec.DecoderException;
+import io.netty.handler.codec.DecoderResult;
+import io.netty.util.internal.UnstableApi;
+
+import java.util.List;
+
+/**
+ * Decodes a single {@link Socks5PrivateAuthResponse} from the inbound {@link ByteBuf}s.
+ * On successful decode, this decoder will forward the received data to the next handler, so that
+ * other handler can remove or replace this decoder later. On failed decode, this decoder will
+ * discard the received data, so that other handler closes the connection later.
+ * <p>
+ * The default format follows a simple structure:
+ * <ul>
+ *   <li>1 byte: version (must be 1)</li>
+ *   <li>1 byte: status (0x00 for success, 0xFF for failure)</li>
+ * </ul>
+ * </p>
+ * <p>
+ * For custom private authentication protocols, you can:
+ * <ul>
+ *   <li>Create a new decoder implementing {@link ByteToMessageDecoder} or similar</li>
+ *   <li>Implement the {@link Socks5PrivateAuthResponse} interface
+ *   or extend {@link DefaultSocks5PrivateAuthResponse}</li>
+ *   <li>Create a custom handler chain to process the authentication responses</li>
+ * </ul>
+ * </p>
+ */
+public final class Socks5PrivateAuthResponseDecoder extends ByteToMessageDecoder {
+
+    /**
+     * Decoder states for SOCKS5 private authentication responses.
+     */
+    private enum State {
+        /**
+         * Initial state.
+         */
+        INIT,
+        /**
+         * Authentication successful.
+         */
+        SUCCESS,
+        /**
+         * Authentication failed.
+         */
+        FAILURE
+    }
+
+    private State state = State.INIT;
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in,
+                          List<Object> out) throws Exception {
+        try {
+            switch (state) {
+                case INIT:
+                    if (in.readableBytes() < 2) {
+                        return;
+                    }
+
+                    final byte version = in.readByte();
+                    if (version != 1) {
+                        throw new DecoderException(
+                            "unsupported subnegotiation version: " + version + " (expected: 1)");
+                    }
+
+                    out.add(new DefaultSocks5PrivateAuthResponse(
+                        Socks5PrivateAuthStatus.valueOf(in.readByte())));
+                    state = State.SUCCESS;
+                    break;
+                case SUCCESS:
+                    int readableBytes = in.readableBytes();
+                    if (readableBytes > 0) {
+                        out.add(in.readRetainedSlice(readableBytes));
+                    }
+                    break;
+                case FAILURE:
+                    in.skipBytes(in.readableBytes());
+                    break;
+                default:
+                    throw new Error();
+            }
+        } catch (Exception e) {
+            fail(out, e);
+        }
+    }
+
+    /**
+     * Handles decoder failures by setting the appropriate error state.
+     *
+     * @param out   the output list to add the failure message to
+     * @param cause the exception that caused the failure
+     */
+    private void fail(List<Object> out, Exception cause) {
+        if (!(cause instanceof DecoderException)) {
+            cause = new DecoderException(cause);
+        }
+
+        state = State.FAILURE;
+
+        Socks5Message m = new DefaultSocks5PrivateAuthResponse(Socks5PrivateAuthStatus.FAILURE);
+        m.setDecoderResult(DecoderResult.failure(cause));
+        out.add(m);
+    }
+}
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthStatus.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthStatus.java
new file mode 100644
index 0000000000..edaea6fd23
--- /dev/null
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5PrivateAuthStatus.java
@@ -0,0 +1,117 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.handler.codec.socksx.v5;
+
+import io.netty.util.internal.ObjectUtil;
+
+/**
+ * The status of a SOCKS5 private authentication response.
+ * <p>
+ * RFC 1928 reserves method codes 0x80-0xFE for private authentication methods but does not
+ * specify the format of their subnegotiation. This class provides standard status codes
+ * for the private authentication response that follow the pattern established by the
+ * username/password authentication method in RFC 1929.
+ * </p>
+ *
+ * @see <a href="https://www.ietf.org/rfc/rfc1928.txt">RFC 1928 Section 3</a>
+ * @see <a href="https://www.ietf.org/rfc/rfc1929.txt">RFC 1929</a>
+ */
+public final class Socks5PrivateAuthStatus implements Comparable<Socks5PrivateAuthStatus> {
+
+    public static final Socks5PrivateAuthStatus SUCCESS = new Socks5PrivateAuthStatus(0x00, "SUCCESS");
+    public static final Socks5PrivateAuthStatus FAILURE = new Socks5PrivateAuthStatus(0xFF, "FAILURE");
+
+    /**
+     * Returns the {@link Socks5PrivateAuthStatus} instance that corresponds to the specified byte value.
+     * <p>
+     * This method returns a singleton instance for standard status codes:
+     * <ul>
+     *   <li>0x00: {@link #SUCCESS}</li>
+     *   <li>0xFF: {@link #FAILURE}</li>
+     * </ul>
+     * For any other values, a new instance is created.
+     *
+     * @param b The byte value of the SOCKS5 private authentication status
+     * @return The corresponding {@link Socks5PrivateAuthStatus} instance
+     */
+    public static Socks5PrivateAuthStatus valueOf(byte b) {
+        switch (b) {
+            case 0x00:
+                return SUCCESS;
+            case (byte) 0xFF:
+                return FAILURE;
+        }
+
+        return new Socks5PrivateAuthStatus(b);
+    }
+
+    private final byte byteValue;
+    private final String name;
+    private String text;
+
+    private Socks5PrivateAuthStatus(int byteValue) {
+        this(byteValue, "UNKNOWN");
+    }
+
+    /**
+     * Creates a new SOCKS5 private authentication status.
+     *
+     * @param byteValue The byte value representing the authentication status
+     *                  (0x00 for success, 0xFF for failure, or custom values)
+     * @param name      The descriptive name of this status, must not be null
+     * @throws NullPointerException if the name is null
+     */
+    public Socks5PrivateAuthStatus(int byteValue, String name) {
+        this.name = ObjectUtil.checkNotNull(name, "name");
+        this.byteValue = (byte) byteValue;
+    }
+
+    public byte byteValue() {
+        return byteValue;
+    }
+
+    public boolean isSuccess() {
+        return byteValue == 0;
+    }
+
+    @Override
+    public int hashCode() {
+        return byteValue;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (!(obj instanceof Socks5PrivateAuthStatus)) {
+            return false;
+        }
+
+        return byteValue == ((Socks5PrivateAuthStatus) obj).byteValue;
+    }
+
+    @Override
+    public int compareTo(Socks5PrivateAuthStatus o) {
+        return byteValue - o.byteValue;
+    }
+
+    @Override
+    public String toString() {
+        String text = this.text;
+        if (text == null) {
+            this.text = text = name + '(' + (byteValue & 0xFF) + ')';
+        }
+        return text;
+    }
+}
diff --git a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ServerEncoder.java b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ServerEncoder.java
index 1eb9e7d993..46eefa3a2b 100644
--- a/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ServerEncoder.java
+++ b/codec-socks/src/main/java/io/netty/handler/codec/socksx/v5/Socks5ServerEncoder.java
@@ -65,6 +65,8 @@ public class Socks5ServerEncoder extends MessageToByteEncoder<Socks5Message> {
             encodePasswordAuthResponse((Socks5PasswordAuthResponse) msg, out);
         } else if (msg instanceof Socks5CommandResponse) {
             encodeCommandResponse((Socks5CommandResponse) msg, out);
+        } else if (msg instanceof Socks5PrivateAuthResponse) {
+            encodePrivateAuthResponse((Socks5PrivateAuthResponse) msg, out);
         } else {
             throw new EncoderException("unsupported message type: " + StringUtil.simpleClassName(msg));
         }
@@ -80,6 +82,11 @@ public class Socks5ServerEncoder extends MessageToByteEncoder<Socks5Message> {
         out.writeByte(msg.status().byteValue());
     }
 
+    private static void encodePrivateAuthResponse(Socks5PrivateAuthResponse msg, ByteBuf out) {
+        out.writeByte(0x01);
+        out.writeByte(msg.status().byteValue());
+    }
+
     private void encodeCommandResponse(Socks5CommandResponse msg, ByteBuf out) throws Exception {
         out.writeByte(msg.version().byteValue());
         out.writeByte(msg.status().byteValue());
diff --git a/codec-socks/src/main/resources/META-INF/native-image/io.netty/netty-codec-socks/generated/handlers/reflect-config.json b/codec-socks/src/main/resources/META-INF/native-image/io.netty/netty-codec-socks/generated/handlers/reflect-config.json
index 9516c4e5d1..b36aa73d86 100644
--- a/codec-socks/src/main/resources/META-INF/native-image/io.netty/netty-codec-socks/generated/handlers/reflect-config.json
+++ b/codec-socks/src/main/resources/META-INF/native-image/io.netty/netty-codec-socks/generated/handlers/reflect-config.json
@@ -132,6 +132,20 @@
     },
     "queryAllPublicMethods": true
   },
+  {
+    "name": "io.netty.handler.codec.socksx.v5.Socks5PrivateAuthRequestDecoder",
+    "condition": {
+      "typeReachable": "io.netty.handler.codec.socksx.v5.Socks5PrivateAuthRequestDecoder"
+    },
+    "queryAllPublicMethods": true
+  },
+  {
+    "name": "io.netty.handler.codec.socksx.v5.Socks5PrivateAuthResponseDecoder",
+    "condition": {
+      "typeReachable": "io.netty.handler.codec.socksx.v5.Socks5PrivateAuthResponseDecoder"
+    },
+    "queryAllPublicMethods": true
+  },
   {
     "name": "io.netty.handler.codec.socksx.v5.Socks5ServerEncoder",
     "condition": {
diff --git a/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
index 9b25a919d9..527e7a6c9d 100644
--- a/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
+++ b/example/src/main/java/io/netty/example/socksproxy/SocksServerHandler.java
@@ -23,6 +23,7 @@ import io.netty.handler.codec.socksx.v4.Socks4CommandRequest;
 import io.netty.handler.codec.socksx.v4.Socks4CommandType;
 import io.netty.handler.codec.socksx.v5.DefaultSocks5InitialResponse;
 import io.netty.handler.codec.socksx.v5.DefaultSocks5PasswordAuthResponse;
+import io.netty.handler.codec.socksx.v5.DefaultSocks5PrivateAuthResponse;
 import io.netty.handler.codec.socksx.v5.Socks5AuthMethod;
 import io.netty.handler.codec.socksx.v5.Socks5InitialRequest;
 import io.netty.handler.codec.socksx.v5.Socks5CommandRequest;
@@ -30,6 +31,8 @@ import io.netty.handler.codec.socksx.v5.Socks5CommandRequestDecoder;
 import io.netty.handler.codec.socksx.v5.Socks5CommandType;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthRequest;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthStatus;
+import io.netty.handler.codec.socksx.v5.Socks5PrivateAuthRequest;
+import io.netty.handler.codec.socksx.v5.Socks5PrivateAuthStatus;
 
 @ChannelHandler.Sharable
 public final class SocksServerHandler extends SimpleChannelInboundHandler<SocksMessage> {
@@ -61,6 +64,9 @@ public final class SocksServerHandler extends SimpleChannelInboundHandler<SocksM
                 } else if (socksRequest instanceof Socks5PasswordAuthRequest) {
                     ctx.pipeline().addFirst(new Socks5CommandRequestDecoder());
                     ctx.write(new DefaultSocks5PasswordAuthResponse(Socks5PasswordAuthStatus.SUCCESS));
+                } else if (socksRequest instanceof Socks5PrivateAuthRequest) {
+                    ctx.pipeline().addFirst(new Socks5CommandRequestDecoder());
+                    ctx.write(new DefaultSocks5PrivateAuthResponse(Socks5PrivateAuthStatus.SUCCESS));
                 } else if (socksRequest instanceof Socks5CommandRequest) {
                     Socks5CommandRequest socks5CmdRequest = (Socks5CommandRequest) socksRequest;
                     if (socks5CmdRequest.type() == Socks5CommandType.CONNECT) {
diff --git a/handler-proxy/src/main/java/io/netty/handler/proxy/Socks5ProxyHandler.java b/handler-proxy/src/main/java/io/netty/handler/proxy/Socks5ProxyHandler.java
index c7de739ebc..2602750227 100644
--- a/handler-proxy/src/main/java/io/netty/handler/proxy/Socks5ProxyHandler.java
+++ b/handler-proxy/src/main/java/io/netty/handler/proxy/Socks5ProxyHandler.java
@@ -21,6 +21,7 @@ import io.netty.channel.ChannelPipeline;
 import io.netty.handler.codec.socksx.v5.DefaultSocks5InitialRequest;
 import io.netty.handler.codec.socksx.v5.DefaultSocks5CommandRequest;
 import io.netty.handler.codec.socksx.v5.DefaultSocks5PasswordAuthRequest;
+import io.netty.handler.codec.socksx.v5.DefaultSocks5PrivateAuthRequest;
 import io.netty.handler.codec.socksx.v5.Socks5AddressType;
 import io.netty.handler.codec.socksx.v5.Socks5AuthMethod;
 import io.netty.handler.codec.socksx.v5.Socks5InitialRequest;
@@ -34,6 +35,9 @@ import io.netty.handler.codec.socksx.v5.Socks5CommandType;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthResponse;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthResponseDecoder;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthStatus;
+import io.netty.handler.codec.socksx.v5.Socks5PrivateAuthResponse;
+import io.netty.handler.codec.socksx.v5.Socks5PrivateAuthResponseDecoder;
+import io.netty.handler.codec.socksx.v5.Socks5PrivateAuthStatus;
 import io.netty.util.NetUtil;
 import io.netty.util.internal.StringUtil;
 
@@ -50,6 +54,10 @@ public final class Socks5ProxyHandler extends ProxyHandler {
 
     private static final String PROTOCOL = "socks5";
     private static final String AUTH_PASSWORD = "password";
+    private static final String AUTH_PRIVATE = "private";
+
+    private static final byte NO_PRIVATE_AUTH_METHOD =
+        Socks5AuthMethod.NO_AUTH.byteValue();
 
     private static final Socks5InitialRequest INIT_REQUEST_NO_AUTH =
             new DefaultSocks5InitialRequest(Collections.singletonList(Socks5AuthMethod.NO_AUTH));
@@ -59,6 +67,9 @@ public final class Socks5ProxyHandler extends ProxyHandler {
 
     private final String username;
     private final String password;
+    private final byte privateAuthMethod;
+    private final byte[] privateToken;
+    private final Socks5ClientEncoder clientEncoder;
 
     private String decoderName;
     private String encoderName;
@@ -77,6 +88,32 @@ public final class Socks5ProxyHandler extends ProxyHandler {
         }
         this.username = username;
         this.password = password;
+        this.privateToken = null;
+        this.privateAuthMethod = NO_PRIVATE_AUTH_METHOD; // No private authentication method specified
+        this.clientEncoder = Socks5ClientEncoder.DEFAULT;
+    }
+
+    /**
+     * Creates a new SOCKS5 proxy handler with a custom private authentication method.
+     *
+     * @param proxyAddress     The address of the SOCKS5 proxy server
+     * @param privateAuthMethod The private authentication method code (must be in range 0x80-0xFE)
+     * @param privateToken     The token to use for private authentication
+     * @param customEncoder    The custom encoder to use for encoding SOCKS5 messages, if {@code null} the
+     *                         {@link Socks5ClientEncoder#DEFAULT} will be used
+     * @throws IllegalArgumentException If privateAuthMethod is not in the valid range
+     */
+    public Socks5ProxyHandler(SocketAddress proxyAddress, byte privateAuthMethod, byte[] privateToken,
+                              Socks5ClientEncoder customEncoder) {
+        super(proxyAddress);
+        if (!Socks5AuthMethod.isPrivateMethod(privateAuthMethod)) {
+            throw new IllegalArgumentException(
+                    "privateAuthMethod: " + (privateAuthMethod & 0xFF) + " (expected: 0x80-0xFE)");
+        }
+        this.username = this.password = null;
+        this.privateToken = privateToken;
+        this.privateAuthMethod = privateAuthMethod;
+        this.clientEncoder = customEncoder != null ? customEncoder : Socks5ClientEncoder.DEFAULT;
     }
 
     @Override
@@ -86,7 +123,14 @@ public final class Socks5ProxyHandler extends ProxyHandler {
 
     @Override
     public String authScheme() {
-        return socksAuthMethod() == Socks5AuthMethod.PASSWORD? AUTH_PASSWORD : AUTH_NONE;
+        Socks5AuthMethod authMethod = socksAuthMethod();
+        if (Socks5AuthMethod.isPrivateMethod(authMethod.byteValue())) {
+            return AUTH_PRIVATE;
+        }
+        if (authMethod == Socks5AuthMethod.PASSWORD) {
+            return AUTH_PASSWORD;
+        }
+        return AUTH_NONE;
     }
 
     public String username() {
@@ -108,7 +152,7 @@ public final class Socks5ProxyHandler extends ProxyHandler {
         decoderName = p.context(decoder).name();
         encoderName = decoderName + ".encoder";
 
-        p.addBefore(name, encoderName, Socks5ClientEncoder.DEFAULT);
+        p.addBefore(name, encoderName, clientEncoder);
     }
 
     @Override
@@ -126,7 +170,15 @@ public final class Socks5ProxyHandler extends ProxyHandler {
 
     @Override
     protected Object newInitialMessage(ChannelHandlerContext ctx) throws Exception {
-        return socksAuthMethod() == Socks5AuthMethod.PASSWORD? INIT_REQUEST_PASSWORD : INIT_REQUEST_NO_AUTH;
+        Socks5AuthMethod authMethod = socksAuthMethod();
+        if (authMethod == Socks5AuthMethod.PASSWORD) {
+            return INIT_REQUEST_PASSWORD;
+        }
+        if (Socks5AuthMethod.isPrivateMethod(authMethod.byteValue())) {
+            return new DefaultSocks5InitialRequest(Arrays.asList(Socks5AuthMethod.NO_AUTH,
+                authMethod));
+        }
+        return INIT_REQUEST_NO_AUTH;
     }
 
     @Override
@@ -135,7 +187,8 @@ public final class Socks5ProxyHandler extends ProxyHandler {
             Socks5InitialResponse res = (Socks5InitialResponse) response;
             Socks5AuthMethod authMethod = socksAuthMethod();
             Socks5AuthMethod resAuthMethod = res.authMethod();
-            if (resAuthMethod != Socks5AuthMethod.NO_AUTH && resAuthMethod != authMethod) {
+            if (resAuthMethod != Socks5AuthMethod.NO_AUTH && resAuthMethod != authMethod
+                && !Socks5AuthMethod.isPrivateMethod(resAuthMethod.byteValue())) {
                 // Server did not allow unauthenticated access nor accept the requested authentication scheme.
                 throw new ProxyConnectException(exceptionMessage("unexpected authMethod: " + res.authMethod()));
             }
@@ -147,6 +200,9 @@ public final class Socks5ProxyHandler extends ProxyHandler {
                 ctx.pipeline().replace(decoderName, decoderName, new Socks5PasswordAuthResponseDecoder());
                 sendToProxyServer(new DefaultSocks5PasswordAuthRequest(
                         username != null? username : "", password != null? password : ""));
+            } else if (Socks5AuthMethod.isPrivateMethod(resAuthMethod.byteValue())) {
+                ctx.pipeline().replace(decoderName, decoderName, new Socks5PrivateAuthResponseDecoder());
+                sendToProxyServer(new DefaultSocks5PrivateAuthRequest(privateToken));
             } else {
                 // Should never reach here.
                 throw new Error();
@@ -166,6 +222,16 @@ public final class Socks5ProxyHandler extends ProxyHandler {
             return false;
         }
 
+        if (response instanceof Socks5PrivateAuthResponse) {
+            Socks5PrivateAuthResponse res = (Socks5PrivateAuthResponse) response;
+            if (res.status() != Socks5PrivateAuthStatus.SUCCESS) {
+                throw new ProxyConnectException(exceptionMessage("privateAuthStatus: " + res.status()));
+            }
+
+            sendConnectCommand(ctx);
+            return false;
+        }
+
         // This should be the last message from the server.
         Socks5CommandResponse res = (Socks5CommandResponse) response;
         if (res.status() != Socks5CommandStatus.SUCCESS) {
@@ -177,7 +243,9 @@ public final class Socks5ProxyHandler extends ProxyHandler {
 
     private Socks5AuthMethod socksAuthMethod() {
         Socks5AuthMethod authMethod;
-        if (username == null && password == null) {
+        if (privateToken != null && privateToken.length > 0) {
+            authMethod = new Socks5AuthMethod(privateAuthMethod & 0xFF, "PRIVATE_" + (privateAuthMethod & 0xFF));
+        } else if (username == null && password == null) {
             authMethod = Socks5AuthMethod.NO_AUTH;
         } else {
             authMethod = Socks5AuthMethod.PASSWORD;
diff --git a/handler-proxy/src/test/java/io/netty/handler/proxy/ProxyHandlerTest.java b/handler-proxy/src/test/java/io/netty/handler/proxy/ProxyHandlerTest.java
index 88d82233fb..630d4a20c9 100644
--- a/handler-proxy/src/test/java/io/netty/handler/proxy/ProxyHandlerTest.java
+++ b/handler-proxy/src/test/java/io/netty/handler/proxy/ProxyHandlerTest.java
@@ -131,11 +131,20 @@ public class ProxyHandlerTest {
     static final ProxyServer socks5Proxy =
             new Socks5ProxyServer(false, TestMode.TERMINAL, DESTINATION, USERNAME, PASSWORD);
 
+    // Define private auth method and token for SOCKS5 private authentication
+    static final byte PRIVATE_AUTH_METHOD = (byte) 0x80; // Custom authentication method (range 0x80-0xFE)
+    static final byte[] PRIVATE_AUTH_TOKEN = "privateAuthToken123".getBytes(CharsetUtil.US_ASCII);
+    static final byte[] BAD_PRIVATE_AUTH_TOKEN = "wrongAuthToken".getBytes(CharsetUtil.US_ASCII);
+
+    // SOCKS5 proxy with private authentication
+    static final ProxyServer socks5PrivateProxy =
+            new Socks5ProxyServer(false, TestMode.TERMINAL, DESTINATION, PRIVATE_AUTH_METHOD, PRIVATE_AUTH_TOKEN);
+
     private static final Collection<ProxyServer> allProxies = Arrays.asList(
             deadHttpProxy, interHttpProxy, anonHttpProxy, httpProxy,
             deadHttpsProxy, interHttpsProxy, anonHttpsProxy, httpsProxy,
             deadSocks4Proxy, interSocks4Proxy, anonSocks4Proxy, socks4Proxy,
-            deadSocks5Proxy, interSocks5Proxy, anonSocks5Proxy, socks5Proxy
+            deadSocks5Proxy, interSocks5Proxy, anonSocks5Proxy, socks5Proxy, socks5PrivateProxy
     );
 
     // set to non-zero value in case you need predictable shuffling of test cases
@@ -361,6 +370,44 @@ public class ProxyHandlerTest {
                         "SOCKS5: timeout",
                         new Socks5ProxyHandler(deadSocks5Proxy.address())),
 
+                // SOCKS5 Private Authentication ---------------------------
+                new SuccessTestItem(
+                    "SOCKS5 Private Auth: successful connection, AUTO_READ on",
+                    DESTINATION,
+                    true,
+                    new Socks5ProxyHandler(socks5PrivateProxy.address(), PRIVATE_AUTH_METHOD, PRIVATE_AUTH_TOKEN,
+                        null)),
+
+                new SuccessTestItem(
+                    "SOCKS5: successful connection to anonymous server, AUTO_READ on",
+                    DESTINATION,
+                    true,
+                    new Socks5ProxyHandler(anonSocks5Proxy.address(), USERNAME, PASSWORD)),
+
+                new SuccessTestItem(
+                    "SOCKS5 Private Auth: successful connection, AUTO_READ off",
+                    DESTINATION,
+                    false,
+                    new Socks5ProxyHandler(socks5PrivateProxy.address(), PRIVATE_AUTH_METHOD, PRIVATE_AUTH_TOKEN,
+                        null)),
+
+                new FailureTestItem(
+                    "SOCKS5 Private Auth: rejected connection",
+                    BAD_DESTINATION, "status: FORBIDDEN",
+                    new Socks5ProxyHandler(socks5PrivateProxy.address(), PRIVATE_AUTH_METHOD, PRIVATE_AUTH_TOKEN,
+                        null)),
+
+                new FailureTestItem(
+                    "SOCKS5 Private Auth: authentication failure",
+                    DESTINATION, "privateAuthStatus: FAILURE",
+                    new Socks5ProxyHandler(socks5PrivateProxy.address(), PRIVATE_AUTH_METHOD, BAD_PRIVATE_AUTH_TOKEN,
+                        null)),
+
+                new FailureTestItem(
+                    "SOCKS5 Private Auth: rejected anonymous connection",
+                    DESTINATION, "unexpected authMethod",
+                    new Socks5ProxyHandler(socks5PrivateProxy.address())),
+
                 // HTTP + HTTPS + SOCKS4 + SOCKS5
 
                 new SuccessTestItem(
diff --git a/handler-proxy/src/test/java/io/netty/handler/proxy/Socks5ProxyServer.java b/handler-proxy/src/test/java/io/netty/handler/proxy/Socks5ProxyServer.java
index 02cd447933..02242f9155 100644
--- a/handler-proxy/src/test/java/io/netty/handler/proxy/Socks5ProxyServer.java
+++ b/handler-proxy/src/test/java/io/netty/handler/proxy/Socks5ProxyServer.java
@@ -24,6 +24,7 @@ import io.netty.handler.codec.LineBasedFrameDecoder;
 import io.netty.handler.codec.socksx.v5.DefaultSocks5CommandResponse;
 import io.netty.handler.codec.socksx.v5.DefaultSocks5InitialResponse;
 import io.netty.handler.codec.socksx.v5.DefaultSocks5PasswordAuthResponse;
+import io.netty.handler.codec.socksx.v5.DefaultSocks5PrivateAuthResponse;
 import io.netty.handler.codec.socksx.v5.Socks5AddressType;
 import io.netty.handler.codec.socksx.v5.Socks5AuthMethod;
 import io.netty.handler.codec.socksx.v5.Socks5CommandRequest;
@@ -36,12 +37,16 @@ import io.netty.handler.codec.socksx.v5.Socks5InitialRequestDecoder;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthRequest;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthRequestDecoder;
 import io.netty.handler.codec.socksx.v5.Socks5PasswordAuthStatus;
+import io.netty.handler.codec.socksx.v5.Socks5PrivateAuthRequest;
+import io.netty.handler.codec.socksx.v5.Socks5PrivateAuthRequestDecoder;
+import io.netty.handler.codec.socksx.v5.Socks5PrivateAuthStatus;
 import io.netty.handler.codec.socksx.v5.Socks5ServerEncoder;
 import io.netty.util.CharsetUtil;
 import io.netty.util.internal.SocketUtils;
 
 import java.net.InetSocketAddress;
 import java.net.SocketAddress;
+import java.util.Arrays;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 
@@ -49,6 +54,8 @@ final class Socks5ProxyServer extends ProxyServer {
 
     private static final String ENCODER = "encoder";
     private static final String DECODER = "decoder";
+    private byte privateAuthMethod;
+    private byte[] privateToken;
 
     Socks5ProxyServer(boolean useSsl, TestMode testMode, InetSocketAddress destination) {
         super(useSsl, testMode, destination);
@@ -59,6 +66,14 @@ final class Socks5ProxyServer extends ProxyServer {
         super(useSsl, testMode, destination, username, password);
     }
 
+    Socks5ProxyServer(
+            boolean useSsl, TestMode testMode, InetSocketAddress destination, byte privateAuthMethod,
+            byte[] privateToken) {
+        super(useSsl, testMode, destination);
+        this.privateAuthMethod = privateAuthMethod;
+        this.privateToken = privateToken;
+    }
+
     @Override
     protected void configure(SocketChannel ch) throws Exception {
         ChannelPipeline p = ch.pipeline();
@@ -80,27 +95,70 @@ final class Socks5ProxyServer extends ProxyServer {
     }
 
     boolean authenticate(ChannelHandlerContext ctx, Object msg) {
-        if (username == null) {
+        if (username == null && privateToken == null) {
             ctx.pipeline().replace(DECODER, DECODER, new Socks5CommandRequestDecoder());
             ctx.write(new DefaultSocks5InitialResponse(Socks5AuthMethod.NO_AUTH));
             return true;
         }
 
         if (msg instanceof Socks5InitialRequest) {
+            Socks5InitialRequest initialRequest = (Socks5InitialRequest) msg;
+
+            if (privateToken != null) {
+                // Check if the client requested our private auth method
+                boolean hasPrivateMethod = false;
+                for (Socks5AuthMethod method : initialRequest.authMethods()) {
+                    if (method.byteValue() == privateAuthMethod) {
+                        hasPrivateMethod = true;
+                        break;
+                    }
+                }
+
+                if (hasPrivateMethod) {
+                    ctx.pipeline().replace(DECODER, DECODER, new Socks5PrivateAuthRequestDecoder());
+                    ctx.write(new DefaultSocks5InitialResponse(Socks5AuthMethod.valueOf(privateAuthMethod)));
+                    return false;
+                }
+            }
+
+            if (username != null) {
+                ctx.pipeline().replace(DECODER, DECODER, new Socks5PasswordAuthRequestDecoder());
+                ctx.write(new DefaultSocks5InitialResponse(Socks5AuthMethod.PASSWORD));
+                return false;
+            }
+
+            // Neither private nor password auth was matched
             ctx.pipeline().replace(DECODER, DECODER, new Socks5PasswordAuthRequestDecoder());
             ctx.write(new DefaultSocks5InitialResponse(Socks5AuthMethod.PASSWORD));
             return false;
         }
 
-        Socks5PasswordAuthRequest req = (Socks5PasswordAuthRequest) msg;
-        if (req.username().equals(username) && req.password().equals(password)) {
-            ctx.pipeline().replace(DECODER, DECODER, new Socks5CommandRequestDecoder());
-            ctx.write(new DefaultSocks5PasswordAuthResponse(Socks5PasswordAuthStatus.SUCCESS));
-            return true;
+        if (msg instanceof Socks5PasswordAuthRequest) {
+            Socks5PasswordAuthRequest req = (Socks5PasswordAuthRequest) msg;
+            if (req.username().equals(username) && req.password().equals(password)) {
+                ctx.pipeline().replace(DECODER, DECODER, new Socks5CommandRequestDecoder());
+                ctx.write(new DefaultSocks5PasswordAuthResponse(Socks5PasswordAuthStatus.SUCCESS));
+                return true;
+            }
+
+            ctx.pipeline().replace(DECODER, DECODER, new Socks5PasswordAuthRequestDecoder());
+            ctx.write(new DefaultSocks5PasswordAuthResponse(Socks5PasswordAuthStatus.FAILURE));
+            return false;
+        }
+
+        if (msg instanceof Socks5PrivateAuthRequest) {
+            Socks5PrivateAuthRequest req = (Socks5PrivateAuthRequest) msg;
+            if (Arrays.equals(req.privateToken(), privateToken)) {
+                ctx.pipeline().replace(DECODER, DECODER, new Socks5CommandRequestDecoder());
+                ctx.write(new DefaultSocks5PrivateAuthResponse(Socks5PrivateAuthStatus.SUCCESS));
+                return true;
+            }
+
+            ctx.pipeline().replace(DECODER, DECODER, new Socks5PrivateAuthRequestDecoder());
+            ctx.write(new DefaultSocks5PrivateAuthResponse(Socks5PrivateAuthStatus.FAILURE));
+            return false;
         }
 
-        ctx.pipeline().replace(DECODER, DECODER, new Socks5PasswordAuthRequestDecoder());
-        ctx.write(new DefaultSocks5PasswordAuthResponse(Socks5PasswordAuthStatus.FAILURE));
         return false;
     }
 
