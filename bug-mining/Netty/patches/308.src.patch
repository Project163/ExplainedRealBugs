diff --git a/example/pom.xml b/example/pom.xml
index eaa315d351..04affd0cc4 100644
--- a/example/pom.xml
+++ b/example/pom.xml
@@ -128,10 +128,6 @@
       <artifactId>${conscrypt.artifactId}</artifactId>
       <classifier>${conscrypt.classifier}</classifier>
     </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty.npn</groupId>
-      <artifactId>npn-api</artifactId>
-    </dependency>
     <dependency>
       <groupId>com.jcraft</groupId>
       <artifactId>jzlib</artifactId>
diff --git a/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
index 56077187d3..a59f12276f 100644
--- a/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
+++ b/example/src/main/java/io/netty/example/spdy/client/SpdyClient.java
@@ -41,11 +41,6 @@ import io.netty.handler.ssl.util.InsecureTrustManagerFactory;
 /**
  * An SPDY client that allows you to send HTTP GET to a SPDY server.
  * <p>
- * This class must be run with the JVM parameter: {@code java -Xbootclasspath/p:<path_to_npn_boot_jar> ...}. The
- * "path_to_npn_boot_jar" is the path on the file system for the NPN Boot Jar file which can be downloaded from Maven at
- * coordinates org.mortbay.jetty.npn:npn-boot. Different versions applies to different OpenJDK versions. See
- * <a href="https://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty docs</a> for more information.
- * <p>
  * You may also use the {@code run-example.sh} script to start the client from the command line:
  * <pre>
  *     ./run-example.sh spdy-client
@@ -61,7 +56,7 @@ public final class SpdyClient {
         final SslContext sslCtx = SslContextBuilder.forClient()
             .trustManager(InsecureTrustManagerFactory.INSTANCE)
             .applicationProtocolConfig(new ApplicationProtocolConfig(
-                        Protocol.NPN,
+                        Protocol.ALPN,
                         // NO_ADVERTISE is currently the only mode supported by both OpenSsl and JDK providers.
                         SelectorFailureBehavior.NO_ADVERTISE,
                         // ACCEPT is currently the only mode supported by both OpenSsl and JDK providers.
diff --git a/example/src/main/java/io/netty/example/spdy/client/package-info.java b/example/src/main/java/io/netty/example/spdy/client/package-info.java
index c6d666bca4..6b7138aef3 100644
--- a/example/src/main/java/io/netty/example/spdy/client/package-info.java
+++ b/example/src/main/java/io/netty/example/spdy/client/package-info.java
@@ -19,17 +19,6 @@
  * SPDY frames flowing in and out using the {@link io.netty.example.spdy.client.SpdyFrameLogger}.
  *
  * <p>
- * This package relies on the Jetty project's implementation of the Transport Layer Security (TLS) extension for Next
- * Protocol Negotiation (NPN) for OpenJDK 7 is required. NPN allows the application layer to negotiate which
- * protocol, SPDY or HTTP, to use.
- * <p>
- * To start, run {@link io.netty.example.spdy.server.SpdyServer} with the JVM parameter:
- * {@code java -Xbootclasspath/p:<path_to_npn_boot_jar> ...}.
- * The "path_to_npn_boot_jar" is the path on the file system for the NPN Boot Jar file which can be downloaded from
- * Maven at coordinates org.mortbay.jetty.npn:npn-boot. Different versions applies to different OpenJDK versions.
- * See <a href="https://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty docs</a> for more
- * information.
- * <p>
  * After that, you can run {@link io.netty.example.spdy.client.SpdyClient}, also settings the JVM parameter
  * mentioned above.
  * <p>
diff --git a/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java b/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java
index a2b090aa03..557b23e868 100644
--- a/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java
+++ b/example/src/main/java/io/netty/example/spdy/server/SpdyServer.java
@@ -36,12 +36,6 @@ import io.netty.handler.ssl.util.SelfSignedCertificate;
 /**
  * A SPDY Server that responds to a GET request with a Hello World.
  * <p>
- * This class must be run with the JVM parameter: {@code java -Xbootclasspath/p:<path_to_npn_boot_jar> ...}.
- * The "path_to_npn_boot_jar" is the path on the file system for the NPN Boot Jar file which can be downloaded from
- * Maven at coordinates org.mortbay.jetty.npn:npn-boot. Different versions applies to different OpenJDK versions.
- * See <a href="https://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty docs</a> for more
- * information.
- * <p>
  * You may also use the {@code run-example.sh} script to start the server from the command line:
  * <pre>
  *     ./run-example.sh spdy-server
@@ -60,7 +54,7 @@ public final class SpdyServer {
         SelfSignedCertificate ssc = new SelfSignedCertificate();
         SslContext sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey())
             .applicationProtocolConfig(new ApplicationProtocolConfig(
-                        Protocol.NPN,
+                        Protocol.ALPN,
                         // NO_ADVERTISE is currently the only mode supported by both OpenSsl and JDK providers.
                         SelectorFailureBehavior.NO_ADVERTISE,
                         // ACCEPT is currently the only mode supported by both OpenSsl and JDK providers.
diff --git a/example/src/main/java/io/netty/example/spdy/server/package-info.java b/example/src/main/java/io/netty/example/spdy/server/package-info.java
index 6e92ffaa3a..b742c0e9a5 100644
--- a/example/src/main/java/io/netty/example/spdy/server/package-info.java
+++ b/example/src/main/java/io/netty/example/spdy/server/package-info.java
@@ -17,17 +17,6 @@
 /**
  * This package contains an example SPDY HTTP web server.
  * <p>
- * This package relies on the Jetty project's implementation of the Transport Layer Security (TLS) extension for Next
- * Protocol Negotiation (NPN) for OpenJDK 7 is required. NPN allows the application layer to negotiate which
- * protocol, SPDY or HTTP, to use.
- * <p>
- * To start, run {@link io.netty.example.spdy.server.SpdyServer} with the JVM parameter:
- * {@code java -Xbootclasspath/p:<path_to_npn_boot_jar> ...}.
- * The "path_to_npn_boot_jar" is the path on the file system for the NPN Boot Jar file which can be downloaded from
- * Maven at coordinates org.mortbay.jetty.npn:npn-boot. Different versions applies to different OpenJDK versions.
- * See <a href="https://www.eclipse.org/jetty/documentation/current/npn-chapter.html">Jetty docs</a> for more
- * information.
- * <p>
  * You may also use the {@code run-example.sh} script to start the server from the command line:
  * <pre>
  *     ./run-example spdy-server
diff --git a/handler/pom.xml b/handler/pom.xml
index a30f2be10d..f816179de7 100644
--- a/handler/pom.xml
+++ b/handler/pom.xml
@@ -81,11 +81,6 @@
       <artifactId>bcpkix-jdk18on</artifactId>
       <optional>true</optional>
     </dependency>
-    <dependency>
-      <groupId>org.eclipse.jetty.npn</groupId>
-      <artifactId>npn-api</artifactId>
-      <optional>true</optional>
-    </dependency>
     <dependency>
       <groupId>${conscrypt.groupId}</groupId>
       <artifactId>${conscrypt.artifactId}</artifactId>
diff --git a/handler/src/main/java/io/netty/handler/ssl/JdkNpnApplicationProtocolNegotiator.java b/handler/src/main/java/io/netty/handler/ssl/JdkNpnApplicationProtocolNegotiator.java
deleted file mode 100644
index cbaeb0c462..0000000000
--- a/handler/src/main/java/io/netty/handler/ssl/JdkNpnApplicationProtocolNegotiator.java
+++ /dev/null
@@ -1,123 +0,0 @@
-/*
- * Copyright 2014 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-package io.netty.handler.ssl;
-
-import javax.net.ssl.SSLEngine;
-
-/**
- * The {@link JdkApplicationProtocolNegotiator} to use if you need NPN and are using {@link SslProvider#JDK}.
- *
- * @deprecated use {@link ApplicationProtocolConfig}.
- */
-@Deprecated
-public final class JdkNpnApplicationProtocolNegotiator extends JdkBaseApplicationProtocolNegotiator {
-    private static final SslEngineWrapperFactory NPN_WRAPPER = new SslEngineWrapperFactory() {
-        {
-            if (!JettyNpnSslEngine.isAvailable()) {
-                throw new RuntimeException("NPN unsupported. Is your classpath configured correctly?"
-                        + " See https://wiki.eclipse.org/Jetty/Feature/NPN");
-            }
-        }
-
-        @Override
-        public SSLEngine wrapSslEngine(SSLEngine engine,
-                                       JdkApplicationProtocolNegotiator applicationNegotiator, boolean isServer) {
-            return new JettyNpnSslEngine(engine, applicationNegotiator, isServer);
-        }
-    };
-
-    /**
-     * Create a new instance.
-     * @param protocols The order of iteration determines the preference of support for protocols.
-     */
-    public JdkNpnApplicationProtocolNegotiator(Iterable<String> protocols) {
-        this(false, protocols);
-    }
-
-    /**
-     * Create a new instance.
-     * @param protocols The order of iteration determines the preference of support for protocols.
-     */
-    public JdkNpnApplicationProtocolNegotiator(String... protocols) {
-        this(false, protocols);
-    }
-
-    /**
-     * Create a new instance.
-     * @param failIfNoCommonProtocols Fail with a fatal alert if not common protocols are detected.
-     * @param protocols The order of iteration determines the preference of support for protocols.
-     */
-    public JdkNpnApplicationProtocolNegotiator(boolean failIfNoCommonProtocols, Iterable<String> protocols) {
-        this(failIfNoCommonProtocols, failIfNoCommonProtocols, protocols);
-    }
-
-    /**
-     * Create a new instance.
-     * @param failIfNoCommonProtocols Fail with a fatal alert if not common protocols are detected.
-     * @param protocols The order of iteration determines the preference of support for protocols.
-     */
-    public JdkNpnApplicationProtocolNegotiator(boolean failIfNoCommonProtocols, String... protocols) {
-        this(failIfNoCommonProtocols, failIfNoCommonProtocols, protocols);
-    }
-
-    /**
-     * Create a new instance.
-     * @param clientFailIfNoCommonProtocols Client side fail with a fatal alert if not common protocols are detected.
-     * @param serverFailIfNoCommonProtocols Server side fail with a fatal alert if not common protocols are detected.
-     * @param protocols The order of iteration determines the preference of support for protocols.
-     */
-    public JdkNpnApplicationProtocolNegotiator(boolean clientFailIfNoCommonProtocols,
-            boolean serverFailIfNoCommonProtocols, Iterable<String> protocols) {
-        this(clientFailIfNoCommonProtocols ? FAIL_SELECTOR_FACTORY : NO_FAIL_SELECTOR_FACTORY,
-                serverFailIfNoCommonProtocols ? FAIL_SELECTION_LISTENER_FACTORY : NO_FAIL_SELECTION_LISTENER_FACTORY,
-                protocols);
-    }
-
-    /**
-     * Create a new instance.
-     * @param clientFailIfNoCommonProtocols Client side fail with a fatal alert if not common protocols are detected.
-     * @param serverFailIfNoCommonProtocols Server side fail with a fatal alert if not common protocols are detected.
-     * @param protocols The order of iteration determines the preference of support for protocols.
-     */
-    public JdkNpnApplicationProtocolNegotiator(boolean clientFailIfNoCommonProtocols,
-            boolean serverFailIfNoCommonProtocols, String... protocols) {
-        this(clientFailIfNoCommonProtocols ? FAIL_SELECTOR_FACTORY : NO_FAIL_SELECTOR_FACTORY,
-                serverFailIfNoCommonProtocols ? FAIL_SELECTION_LISTENER_FACTORY : NO_FAIL_SELECTION_LISTENER_FACTORY,
-                protocols);
-    }
-
-    /**
-     * Create a new instance.
-     * @param selectorFactory The factory which provides classes responsible for selecting the protocol.
-     * @param listenerFactory The factory which provides to be notified of which protocol was selected.
-     * @param protocols The order of iteration determines the preference of support for protocols.
-     */
-    public JdkNpnApplicationProtocolNegotiator(ProtocolSelectorFactory selectorFactory,
-            ProtocolSelectionListenerFactory listenerFactory, Iterable<String> protocols) {
-        super(NPN_WRAPPER, selectorFactory, listenerFactory, protocols);
-    }
-
-    /**
-     * Create a new instance.
-     * @param selectorFactory The factory which provides classes responsible for selecting the protocol.
-     * @param listenerFactory The factory which provides to be notified of which protocol was selected.
-     * @param protocols The order of iteration determines the preference of support for protocols.
-     */
-    public JdkNpnApplicationProtocolNegotiator(ProtocolSelectorFactory selectorFactory,
-            ProtocolSelectionListenerFactory listenerFactory, String... protocols) {
-        super(NPN_WRAPPER, selectorFactory, listenerFactory, protocols);
-    }
-}
diff --git a/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
index 09c05e0825..68790fb165 100644
--- a/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
+++ b/handler/src/main/java/io/netty/handler/ssl/JdkSslContext.java
@@ -432,28 +432,6 @@ public class JdkSslContext extends SslContext {
                     .append(config.selectedListenerFailureBehavior()).append(" failure behavior").toString());
                 }
             }
-        case NPN:
-            if (isServer) {
-                switch(config.selectedListenerFailureBehavior()) {
-                case ACCEPT:
-                    return new JdkNpnApplicationProtocolNegotiator(false, config.supportedProtocols());
-                case FATAL_ALERT:
-                    return new JdkNpnApplicationProtocolNegotiator(true, config.supportedProtocols());
-                default:
-                    throw new UnsupportedOperationException(new StringBuilder("JDK provider does not support ")
-                    .append(config.selectedListenerFailureBehavior()).append(" failure behavior").toString());
-                }
-            } else {
-                switch(config.selectorFailureBehavior()) {
-                case FATAL_ALERT:
-                    return new JdkNpnApplicationProtocolNegotiator(true, config.supportedProtocols());
-                case NO_ADVERTISE:
-                    return new JdkNpnApplicationProtocolNegotiator(false, config.supportedProtocols());
-                default:
-                    throw new UnsupportedOperationException(new StringBuilder("JDK provider does not support ")
-                    .append(config.selectorFailureBehavior()).append(" failure behavior").toString());
-                }
-            }
         default:
             throw new UnsupportedOperationException(new StringBuilder("JDK provider does not support ")
             .append(config.protocol()).append(" protocol").toString());
diff --git a/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslEngine.java b/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslEngine.java
deleted file mode 100644
index aad00b5f6d..0000000000
--- a/handler/src/main/java/io/netty/handler/ssl/JettyNpnSslEngine.java
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright 2014 The Netty Project
- *
- * The Netty Project licenses this file to you under the Apache License,
- * version 2.0 (the "License"); you may not use this file except in compliance
- * with the License. You may obtain a copy of the License at:
- *
- *   https://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
- * License for the specific language governing permissions and limitations
- * under the License.
- */
-
-package io.netty.handler.ssl;
-
-import static io.netty.util.internal.ObjectUtil.checkNotNull;
-import io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelectionListener;
-import io.netty.handler.ssl.JdkApplicationProtocolNegotiator.ProtocolSelector;
-import io.netty.util.internal.PlatformDependent;
-
-import java.util.LinkedHashSet;
-import java.util.List;
-
-import javax.net.ssl.SSLEngine;
-import javax.net.ssl.SSLException;
-
-import org.eclipse.jetty.npn.NextProtoNego;
-import org.eclipse.jetty.npn.NextProtoNego.ClientProvider;
-import org.eclipse.jetty.npn.NextProtoNego.ServerProvider;
-
-final class JettyNpnSslEngine extends JdkSslEngine {
-    private static boolean available;
-
-    static boolean isAvailable() {
-        updateAvailability();
-        return available;
-    }
-
-    private static void updateAvailability() {
-        if (available) {
-            return;
-        }
-        try {
-            // Always use bootstrap class loader.
-            Class.forName("sun.security.ssl.NextProtoNegoExtension", true, null);
-            available = true;
-        } catch (Exception ignore) {
-            // npn-boot was not loaded.
-        }
-    }
-
-    JettyNpnSslEngine(SSLEngine engine, final JdkApplicationProtocolNegotiator applicationNegotiator, boolean server) {
-        super(engine);
-        checkNotNull(applicationNegotiator, "applicationNegotiator");
-
-        if (server) {
-            final ProtocolSelectionListener protocolListener = checkNotNull(applicationNegotiator
-                    .protocolListenerFactory().newListener(this, applicationNegotiator.protocols()),
-                    "protocolListener");
-            NextProtoNego.put(engine, new ServerProvider() {
-                @Override
-                public void unsupported() {
-                    protocolListener.unsupported();
-                }
-
-                @Override
-                public List<String> protocols() {
-                    return applicationNegotiator.protocols();
-                }
-
-                @Override
-                public void protocolSelected(String protocol) {
-                    try {
-                        protocolListener.selected(protocol);
-                    } catch (Throwable t) {
-                        PlatformDependent.throwException(t);
-                    }
-                }
-            });
-        } else {
-            final ProtocolSelector protocolSelector = checkNotNull(applicationNegotiator.protocolSelectorFactory()
-                    .newSelector(this, new LinkedHashSet<String>(applicationNegotiator.protocols())),
-                    "protocolSelector");
-            NextProtoNego.put(engine, new ClientProvider() {
-                @Override
-                public boolean supports() {
-                    return true;
-                }
-
-                @Override
-                public void unsupported() {
-                    protocolSelector.unsupported();
-                }
-
-                @Override
-                public String selectProtocol(List<String> protocols) {
-                    try {
-                        return protocolSelector.select(protocols);
-                    } catch (Throwable t) {
-                        PlatformDependent.throwException(t);
-                        return null;
-                    }
-                }
-            });
-        }
-    }
-
-    @Override
-    public void closeInbound() throws SSLException {
-        NextProtoNego.remove(getWrappedEngine());
-        super.closeInbound();
-    }
-
-    @Override
-    public void closeOutbound() {
-        NextProtoNego.remove(getWrappedEngine());
-        super.closeOutbound();
-    }
-}
diff --git a/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java b/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java
index a5b4b6823e..6f38e38ed7 100644
--- a/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java
+++ b/handler/src/test/java/io/netty/handler/ssl/JdkSslEngineTest.java
@@ -42,22 +42,6 @@ import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class JdkSslEngineTest extends SSLEngineTest {
     public enum ProviderType {
-        NPN_JETTY {
-            @Override
-            boolean isAvailable() {
-                return JettyNpnSslEngine.isAvailable();
-            }
-
-            @Override
-            Protocol protocol() {
-                return Protocol.NPN;
-            }
-
-            @Override
-            Provider provider() {
-                return null;
-            }
-        },
         ALPN_JAVA {
             @Override
             boolean isAvailable() {
@@ -197,51 +181,42 @@ public class JdkSslEngineTest extends SSLEngineTest {
             throws Exception {
         try {
             param.providerType.activate(this);
-            if (param.providerType == ProviderType.NPN_JETTY) {
-                ApplicationProtocolConfig clientApn = failingNegotiator(param.providerType.protocol(),
-                    PREFERRED_APPLICATION_LEVEL_PROTOCOL);
-                ApplicationProtocolConfig serverApn = acceptingNegotiator(param.providerType.protocol(),
-                    APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE);
-                setupHandlers(param, serverApn, clientApn);
-                assertTrue(clientLatch.await(2, TimeUnit.SECONDS));
-                assertTrue(clientException instanceof SSLHandshakeException);
-            } else {
-                // ALPN
-                SelfSignedCertificate ssc = new SelfSignedCertificate();
-                JdkApplicationProtocolNegotiator clientApn = new JdkAlpnApplicationProtocolNegotiator(true, true,
-                    PREFERRED_APPLICATION_LEVEL_PROTOCOL);
-                JdkApplicationProtocolNegotiator serverApn = new JdkAlpnApplicationProtocolNegotiator(
-                    new ProtocolSelectorFactory() {
-                        @Override
-                        public ProtocolSelector newSelector(SSLEngine engine, Set<String> supportedProtocols) {
-                            return new ProtocolSelector() {
-                                @Override
-                                public void unsupported() {
-                                }
-
-                                @Override
-                                public String select(List<String> protocols) {
-                                    return APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE;
-                                }
-                            };
-                        }
-                    }, JdkBaseApplicationProtocolNegotiator.FAIL_SELECTION_LISTENER_FACTORY,
-                    APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE);
-
-                SslContext serverSslCtx = new JdkSslServerContext(param.providerType.provider(),
-                    ssc.certificate(), ssc.privateKey(), null, null,
-                    IdentityCipherSuiteFilter.INSTANCE, serverApn, 0, 0, null);
-                SslContext clientSslCtx = new JdkSslClientContext(param.providerType.provider(), null,
-                    InsecureTrustManagerFactory.INSTANCE, null,
-                    IdentityCipherSuiteFilter.INSTANCE, clientApn, 0, 0);
-
-                setupHandlers(param.type(), param.delegate(), new TestDelegatingSslContext(param, serverSslCtx),
-                        new TestDelegatingSslContext(param, clientSslCtx));
-                assertTrue(clientLatch.await(2, TimeUnit.SECONDS));
-                // When using TLSv1.3 the handshake is NOT sent in an extra round trip which means there will be
-                // no exception reported in this case but just the channel will be closed.
-                assertTrue(clientException instanceof SSLHandshakeException || clientException == null);
-            }
+
+            // ALPN
+            SelfSignedCertificate ssc = new SelfSignedCertificate();
+            JdkApplicationProtocolNegotiator clientApn = new JdkAlpnApplicationProtocolNegotiator(true, true,
+                PREFERRED_APPLICATION_LEVEL_PROTOCOL);
+            JdkApplicationProtocolNegotiator serverApn = new JdkAlpnApplicationProtocolNegotiator(
+                new ProtocolSelectorFactory() {
+                    @Override
+                    public ProtocolSelector newSelector(SSLEngine engine, Set<String> supportedProtocols) {
+                        return new ProtocolSelector() {
+                            @Override
+                            public void unsupported() {
+                            }
+
+                            @Override
+                            public String select(List<String> protocols) {
+                                return APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE;
+                            }
+                        };
+                    }
+                }, JdkBaseApplicationProtocolNegotiator.FAIL_SELECTION_LISTENER_FACTORY,
+                APPLICATION_LEVEL_PROTOCOL_NOT_COMPATIBLE);
+
+            SslContext serverSslCtx = new JdkSslServerContext(param.providerType.provider(),
+                ssc.certificate(), ssc.privateKey(), null, null,
+                IdentityCipherSuiteFilter.INSTANCE, serverApn, 0, 0, null);
+            SslContext clientSslCtx = new JdkSslClientContext(param.providerType.provider(), null,
+                InsecureTrustManagerFactory.INSTANCE, null,
+                IdentityCipherSuiteFilter.INSTANCE, clientApn, 0, 0);
+
+            setupHandlers(param.type(), param.delegate(), new TestDelegatingSslContext(param, serverSslCtx),
+                    new TestDelegatingSslContext(param, clientSslCtx));
+            assertTrue(clientLatch.await(2, TimeUnit.SECONDS));
+            // When using TLSv1.3 the handshake is NOT sent in an extra round trip which means there will be
+            // no exception reported in this case but just the channel will be closed.
+            assertTrue(clientException instanceof SSLHandshakeException || clientException == null);
         } catch (SkipTestException e) {
             // ALPN availability is dependent on the java version. If ALPN is not available because of
             // java version incompatibility don't fail the test, but instead just skip the test
@@ -274,10 +249,6 @@ public class JdkSslEngineTest extends SSLEngineTest {
     public void testAlpnCompatibleProtocolsDifferentClientOrder(JdkSSLEngineTestParam param) throws Exception {
         try {
             param.providerType.activate(this);
-            if (param.providerType == ProviderType.NPN_JETTY) {
-                // This test only applies to ALPN.
-                throw tlsExtensionNotFound(param.providerType.protocol());
-            }
             // Even the preferred application protocol appears second in the client's list, it will be picked
             // because it's the first one on server's list.
             ApplicationProtocolConfig clientApn = acceptingNegotiator(Protocol.ALPN,
diff --git a/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
index 90792d29c6..794f6479ba 100644
--- a/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
+++ b/handler/src/test/java/io/netty/handler/ssl/SniHandlerTest.java
@@ -82,12 +82,11 @@ import static org.junit.jupiter.api.Assertions.assertNotNull;
 import static org.junit.jupiter.api.Assertions.assertNull;
 import static org.junit.jupiter.api.Assertions.assertThrows;
 import static org.junit.jupiter.api.Assertions.assertTrue;
-import static org.mockito.ArgumentMatchers.nullable;
 import static org.mockito.Mockito.mock;
 
 public class SniHandlerTest {
 
-    private static ApplicationProtocolConfig newApnConfig() {
+    private static ApplicationProtocolConfig newAlpnConfig() {
         return new ApplicationProtocolConfig(
                 ApplicationProtocolConfig.Protocol.ALPN,
                 // NO_ADVERTISE is currently the only mode supported by both OpenSsl and JDK providers.
@@ -97,7 +96,7 @@ public class SniHandlerTest {
                 "myprotocol");
     }
 
-    private static void assumeApnSupported(SslProvider provider) {
+    private static void assumeAlpnSupported(SslProvider provider) {
         switch (provider) {
             case OPENSSL:
             case OPENSSL_REFCNT:
@@ -110,9 +109,9 @@ public class SniHandlerTest {
         }
     }
 
-    private static SslContext makeSslContext(SslProvider provider, boolean apn) throws Exception {
-        if (apn) {
-            assumeApnSupported(provider);
+    private static SslContext makeSslContext(SslProvider provider, boolean alpn) throws Exception {
+        if (alpn) {
+            assumeAlpnSupported(provider);
         }
 
         File keyFile = ResourcesUtil.getFile(SniHandlerTest.class, "test_encrypted.pem");
@@ -120,15 +119,15 @@ public class SniHandlerTest {
 
         SslContextBuilder sslCtxBuilder = SslContextBuilder.forServer(crtFile, keyFile, "12345")
                 .sslProvider(provider);
-        if (apn) {
-            sslCtxBuilder.applicationProtocolConfig(newApnConfig());
+        if (alpn) {
+            sslCtxBuilder.applicationProtocolConfig(newAlpnConfig());
         }
         return sslCtxBuilder.build();
     }
 
-    private static SslContext makeSslClientContext(SslProvider provider, boolean apn) throws Exception {
-        if (apn) {
-            assumeApnSupported(provider);
+    private static SslContext makeSslClientContext(SslProvider provider, boolean alpn) throws Exception {
+        if (alpn) {
+            assumeAlpnSupported(provider);
         }
 
         File crtFile = ResourcesUtil.getFile(SniHandlerTest.class, "test.crt");
@@ -137,8 +136,8 @@ public class SniHandlerTest {
                 .trustManager(crtFile)
                 .endpointIdentificationAlgorithm(null)
                 .sslProvider(provider);
-        if (apn) {
-            sslCtxBuilder.applicationProtocolConfig(newApnConfig());
+        if (alpn) {
+            sslCtxBuilder.applicationProtocolConfig(newAlpnConfig());
         }
         return sslCtxBuilder.build();
     }
@@ -401,15 +400,15 @@ public class SniHandlerTest {
 
     @ParameterizedTest(name = "{index}: sslProvider={0}")
     @MethodSource("data")
-    public void testSniWithApnHandler(SslProvider provider) throws Exception {
+    public void testSniWithAlpnHandler(SslProvider provider) throws Exception {
         SslContext nettyContext = makeSslContext(provider, true);
         SslContext sniContext = makeSslContext(provider, true);
         final SslContext clientContext = makeSslClientContext(provider, true);
         try {
-            final AtomicBoolean serverApnCtx = new AtomicBoolean(false);
-            final AtomicBoolean clientApnCtx = new AtomicBoolean(false);
-            final CountDownLatch serverApnDoneLatch = new CountDownLatch(1);
-            final CountDownLatch clientApnDoneLatch = new CountDownLatch(1);
+            final AtomicBoolean serverAlpnCtx = new AtomicBoolean(false);
+            final AtomicBoolean clientAlpnCtx = new AtomicBoolean(false);
+            final CountDownLatch serverAlpnDoneLatch = new CountDownLatch(1);
+            final CountDownLatch clientAlpnDoneLatch = new CountDownLatch(1);
 
             final DomainNameMapping<SslContext> mapping = new DomainNameMappingBuilder<SslContext>(nettyContext)
                     .add("*.netty.io", nettyContext)
@@ -428,13 +427,13 @@ public class SniHandlerTest {
                         ChannelPipeline p = ch.pipeline();
                         // Server side SNI.
                         p.addLast(handler);
-                        // Catch the notification event that APN has completed successfully.
+                        // Catch the notification event that ALPN has completed successfully.
                         p.addLast(new ApplicationProtocolNegotiationHandler("foo") {
                             @Override
                             protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {
                                 // addresses issue #9131
-                                serverApnCtx.set(ctx.pipeline().context(this) != null);
-                                serverApnDoneLatch.countDown();
+                                serverAlpnCtx.set(ctx.pipeline().context(this) != null);
+                                serverAlpnDoneLatch.countDown();
                             }
                         });
                     }
@@ -448,13 +447,13 @@ public class SniHandlerTest {
                     protected void initChannel(Channel ch) throws Exception {
                         ch.pipeline().addLast(new SslHandler(clientContext.newEngine(
                                 ch.alloc(), "sni.fake.site", -1)));
-                        // Catch the notification event that APN has completed successfully.
+                        // Catch the notification event that ALPN has completed successfully.
                         ch.pipeline().addLast(new ApplicationProtocolNegotiationHandler("foo") {
                             @Override
                             protected void configurePipeline(ChannelHandlerContext ctx, String protocol) {
                                 // addresses issue #9131
-                                clientApnCtx.set(ctx.pipeline().context(this) != null);
-                                clientApnDoneLatch.countDown();
+                                clientAlpnCtx.set(ctx.pipeline().context(this) != null);
+                                clientAlpnDoneLatch.countDown();
                             }
                         });
                     }
@@ -466,10 +465,10 @@ public class SniHandlerTest {
                 assertTrue(ccf.awaitUninterruptibly().isSuccess());
                 clientChannel = ccf.channel();
 
-                assertTrue(serverApnDoneLatch.await(5, TimeUnit.SECONDS));
-                assertTrue(clientApnDoneLatch.await(5, TimeUnit.SECONDS));
-                assertTrue(serverApnCtx.get());
-                assertTrue(clientApnCtx.get());
+                assertTrue(serverAlpnDoneLatch.await(5, TimeUnit.SECONDS));
+                assertTrue(clientAlpnDoneLatch.await(5, TimeUnit.SECONDS));
+                assertTrue(serverAlpnCtx.get());
+                assertTrue(clientAlpnCtx.get());
                 assertThat(handler.hostname(), is("sni.fake.site"));
                 assertThat(handler.sslContext(), is(sniContext));
             } finally {
diff --git a/microbench/pom.xml b/microbench/pom.xml
index f410338050..6140867da7 100644
--- a/microbench/pom.xml
+++ b/microbench/pom.xml
@@ -258,7 +258,7 @@
                 <Export-Package>${project.groupId}.*</Export-Package>
                 <Export-Package>!*.generated.*</Export-Package>
                 <!-- enforce JVM vendor package as optional -->
-                <Import-Package>sun.nio.ch;resolution:=optional,org.eclipse.jetty.npn;version="[1,2)";resolution:=optional</Import-Package>
+                <Import-Package>sun.nio.ch;resolution:=optional</Import-Package>
                 <!-- override "internal" private package convention -->
                 <Private-Package>!*</Private-Package>
               </instructions>
diff --git a/pom.xml b/pom.xml
index 813f9c31a8..6f65f2a2d7 100644
--- a/pom.xml
+++ b/pom.xml
@@ -746,14 +746,6 @@
         <optional>true</optional>
       </dependency>
 
-      <!-- SPDY and HTTP/2 - completely optional -->
-      <dependency>
-        <groupId>org.eclipse.jetty.npn</groupId>
-        <artifactId>npn-api</artifactId>
-        <version>1.1.1.v20141010</version>
-        <scope>provided</scope> <!-- Provided by npn-boot -->
-      </dependency>
-
       <!-- Google Protocol Buffers - completely optional -->
       <dependency>
         <groupId>com.google.protobuf</groupId>
@@ -6126,6 +6118,13 @@
                   <old>class io.netty.handler.codec.xml.XmlFrameDecoder</old>
                   <justification>Remove split io.netty.handler.codec.xml split package between netty-codec and netty-codec-xml</justification>
                 </item>
+                <!-- Issue -->
+                <item>
+                  <ignore>true</ignore>
+                  <code>java.class.removed</code>
+                  <old>class io.netty.handler.ssl.JdkNpnApplicationProtocolNegotiator</old>
+                  <justification>Remove io.netty.handler.ssl.JdkNpnApplicationProtocolNegotiator dropped</justification>
+                </item>
               </differences>
             </revapi.differences>
           </analysisConfiguration>
@@ -6338,7 +6337,7 @@
               <instructions>
                 <Export-Package>${project.groupId}.*</Export-Package>
                 <!-- enforce JVM vendor package as optional -->
-                <Import-Package>sun.net.dns.*;resolution:=optional,sun.misc.*;resolution:=optional,sun.nio.ch;resolution:=optional,sun.security.*;resolution:=optional,org.eclipse.jetty.npn;version="[1,2)";resolution:=optional,org.bouncycastle.jcajce.provider;version="[1.0,2)";resolution:=optional,*</Import-Package>
+                <Import-Package>sun.net.dns.*;resolution:=optional,sun.misc.*;resolution:=optional,sun.nio.ch;resolution:=optional,sun.security.*;resolution:=optional,org.bouncycastle.jcajce.provider;version="[1.0,2)";resolution:=optional,*</Import-Package>
                 <!-- override "internal" private package convention -->
                 <Private-Package>!*</Private-Package>
               </instructions>
diff --git a/run-example.sh b/run-example.sh
index 926b0c0e55..84ca3d8181 100755
--- a/run-example.sh
+++ b/run-example.sh
@@ -62,15 +62,9 @@ EXAMPLE_MAP=(
   'dot-dns-client:io.netty.example.dns.dot.DoTClient'
 )
 
-NEEDS_NPN_MAP=(
-  'spdy-client'
-  'spdy-server'
-)
-
 EXAMPLE=''
 EXAMPLE_CLASS=''
 EXAMPLE_ARGS='-D_'
-FORCE_NPN=''
 I=0
 
 while [[ $# -gt 0 ]]; do
@@ -121,13 +115,6 @@ if [[ -z "$EXAMPLE" ]] || [[ -z "$EXAMPLE_CLASS" ]] || [[ $# -ne 0 ]]; then
   exit 1
 fi
 
-for E in "${NEEDS_NPN_MAP[@]}"; do
-  if [[ "$EXAMPLE" = "$E" ]]; then
-    FORCE_NPN='true'
-    break
-  fi
-done
-
 cd "`dirname "$0"`"/example
 echo "[INFO] Running: $EXAMPLE ($EXAMPLE_CLASS $EXAMPLE_ARGS)"
-exec mvn -q -nsu compile exec:exec -Dcheckstyle.skip=true -Dforbiddenapis.skip=true -Dforcenpn="$FORCE_NPN" -DargLine.example="$EXAMPLE_ARGS" -DexampleClass="$EXAMPLE_CLASS"
+exec mvn -q -nsu compile exec:exec -Dcheckstyle.skip=true -Dforbiddenapis.skip=true -DargLine.example="$EXAMPLE_ARGS" -DexampleClass="$EXAMPLE_CLASS"
diff --git a/testsuite-http2/src/main/java/io/netty/testsuite/http2/Http2ServerInitializer.java b/testsuite-http2/src/main/java/io/netty/testsuite/http2/Http2ServerInitializer.java
index 207923b00c..cf6a00fdb1 100644
--- a/testsuite-http2/src/main/java/io/netty/testsuite/http2/Http2ServerInitializer.java
+++ b/testsuite-http2/src/main/java/io/netty/testsuite/http2/Http2ServerInitializer.java
@@ -38,7 +38,7 @@ import io.netty.util.ReferenceCountUtil;
 
 /**
  * Sets up the Netty pipeline for the example server. Depending on the endpoint config, sets up the
- * pipeline for NPN or cleartext HTTP upgrade to HTTP/2.
+ * pipeline for cleartext HTTP upgrade to HTTP/2.
  */
 public class Http2ServerInitializer extends ChannelInitializer<SocketChannel> {
 
