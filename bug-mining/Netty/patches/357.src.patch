diff --git a/common/src/main/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactory.java b/common/src/main/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactory.java
index 679087699b..faddbab25c 100644
--- a/common/src/main/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactory.java
+++ b/common/src/main/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactory.java
@@ -21,6 +21,7 @@ import java.util.ArrayList;
 import java.util.Collections;
 import java.util.List;
 import java.util.concurrent.TimeUnit;
+import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
 /**
@@ -45,6 +46,41 @@ import java.util.concurrent.atomic.AtomicReference;
  */
 public final class AutoScalingEventExecutorChooserFactory implements EventExecutorChooserFactory {
 
+    /**
+     * A container for the utilization metric of a single EventExecutor.
+     * This object is intended to be created once and have its {@code utilization}
+     * field updated periodically.
+     */
+    public static final class AutoScalingUtilizationMetric {
+        private final EventExecutor executor;
+        private final AtomicLong utilizationBits = new AtomicLong();
+
+        AutoScalingUtilizationMetric(EventExecutor executor) {
+            this.executor = executor;
+        }
+
+        /**
+         * Returns the most recently calculated utilization for the associated executor.
+         * @return a value from 0.0 to 1.0.
+         */
+        public double utilization() {
+            return Double.longBitsToDouble(utilizationBits.get());
+        }
+
+        /**
+         * Returns the {@link EventExecutor} this metric belongs too.
+         * @return the executor.
+         */
+        public EventExecutor executor() {
+            return executor;
+        }
+
+        void setUtilization(double utilization) {
+            long bits = Double.doubleToRawLongBits(utilization);
+            utilizationBits.lazySet(bits);
+        }
+    }
+
     private static final Runnable NO_OOP_TASK = () -> { };
     private final int minChildren;
     private final int maxChildren;
@@ -72,13 +108,13 @@ public final class AutoScalingEventExecutorChooserFactory implements EventExecut
                                                   TimeUnit windowUnit, double scaleDownThreshold,
                                                   double scaleUpThreshold, int maxRampUpStep, int maxRampDownStep,
                                                   int scalingPatienceCycles) {
-        this.minChildren = ObjectUtil.checkPositiveOrZero(minThreads, "minThreads");
-        this.maxChildren = ObjectUtil.checkPositive(maxThreads, "maxThreads");
+        minChildren = ObjectUtil.checkPositiveOrZero(minThreads, "minThreads");
+        maxChildren = ObjectUtil.checkPositive(maxThreads, "maxThreads");
         if (minThreads > maxThreads) {
             throw new IllegalArgumentException(String.format(
                     "minThreads: %d must not be greater than maxThreads: %d", minThreads, maxThreads));
         }
-        this.utilizationCheckPeriodNanos = ObjectUtil.checkNotNull(windowUnit, "windowUnit")
+        utilizationCheckPeriodNanos = ObjectUtil.checkNotNull(windowUnit, "windowUnit")
                                                      .toNanos(ObjectUtil.checkPositive(utilizationWindow,
                                                                                        "utilizationWindow"));
         this.scaleDownThreshold = ObjectUtil.checkInRange(scaleDownThreshold, 0.0, 1.0, "scaleDownThreshold");
@@ -112,21 +148,27 @@ public final class AutoScalingEventExecutorChooserFactory implements EventExecut
             this.activeChildrenCount = activeChildrenCount;
             this.nextWakeUpIndex = nextWakeUpIndex;
             this.activeExecutors = activeExecutors;
-            this.activeExecutorsChooser = DefaultEventExecutorChooserFactory.INSTANCE.newChooser(activeExecutors);
+            activeExecutorsChooser = DefaultEventExecutorChooserFactory.INSTANCE.newChooser(activeExecutors);
         }
     }
 
-    private final class AutoScalingEventExecutorChooser implements EventExecutorChooser {
+    private final class AutoScalingEventExecutorChooser implements ObservableEventExecutorChooser {
         private final EventExecutor[] executors;
         private final EventExecutorChooser allExecutorsChooser;
         private final AtomicReference<AutoScalingState> state;
+        private final List<AutoScalingUtilizationMetric> utilizationMetrics;
 
         AutoScalingEventExecutorChooser(EventExecutor[] executors) {
             this.executors = executors;
-            this.allExecutorsChooser = DefaultEventExecutorChooserFactory.INSTANCE.newChooser(executors);
+            List<AutoScalingUtilizationMetric> metrics = new ArrayList<>(executors.length);
+            for (EventExecutor executor : executors) {
+                metrics.add(new AutoScalingUtilizationMetric(executor));
+            }
+            utilizationMetrics = Collections.unmodifiableList(metrics);
+            allExecutorsChooser = DefaultEventExecutorChooserFactory.INSTANCE.newChooser(executors);
 
             AutoScalingState initialState = new AutoScalingState(maxChildren, 0L, executors);
-            this.state = new AtomicReference<>(initialState);
+            state = new AtomicReference<>(initialState);
 
             ScheduledFuture<?> utilizationMonitoringTask = GlobalEventExecutor.INSTANCE.scheduleAtFixedRate(
                     new UtilizationMonitor(), utilizationCheckPeriodNanos, utilizationCheckPeriodNanos,
@@ -213,8 +255,19 @@ public final class AutoScalingEventExecutorChooserFactory implements EventExecut
             }
         }
 
+        @Override
+        public int activeExecutorCount() {
+            return state.get().activeChildrenCount;
+        }
+
+        @Override
+        public List<AutoScalingUtilizationMetric> executorUtilizations() {
+            return utilizationMetrics;
+        }
+
         private final class UtilizationMonitor implements Runnable {
             private final List<SingleThreadEventExecutor> consistentlyIdleChildren = new ArrayList<>(maxChildren);
+            private long lastCheckTimeNanos;
 
             @Override
             public void run() {
@@ -224,57 +277,82 @@ public final class AutoScalingEventExecutorChooserFactory implements EventExecut
                     return;
                 }
 
+                // Calculate the actual elapsed time since the last run.
+                final long now = executors[0].ticker().nanoTime();
+                long totalTime;
+
+                if (lastCheckTimeNanos == 0) {
+                    // On the first run, use the configured period as a baseline to avoid skipping the cycle.
+                    totalTime = utilizationCheckPeriodNanos;
+                } else {
+                    // On subsequent runs, calculate the actual elapsed time.
+                    totalTime = now - lastCheckTimeNanos;
+                }
+
+                // Always update the timestamp for the next cycle.
+                lastCheckTimeNanos = now;
+
+                if (totalTime <= 0) {
+                    // Skip this cycle if the clock has issues or the interval is invalid.
+                    return;
+                }
+
                 int consistentlyBusyChildren = 0;
                 consistentlyIdleChildren.clear();
 
                 final AutoScalingState currentState = state.get();
 
-                for (EventExecutor child : executors) {
-                    if (child.isSuspended() || !(child instanceof SingleThreadEventExecutor)) {
+                for (int i = 0; i < executors.length; i++) {
+                    EventExecutor child = executors[i];
+                    if (!(child instanceof SingleThreadEventExecutor)) {
                         continue;
                     }
 
-                    SingleThreadEventExecutor stee = (SingleThreadEventExecutor) child;
+                    SingleThreadEventExecutor eventExecutor = (SingleThreadEventExecutor) child;
 
-                    long activeTime = stee.getAndResetAccumulatedActiveTimeNanos();
-                    final long totalTime = utilizationCheckPeriodNanos;
+                    double utilization = 0.0;
+                    if (!eventExecutor.isSuspended()) {
+                        long activeTime = eventExecutor.getAndResetAccumulatedActiveTimeNanos();
 
-                    if (activeTime == 0) {
-                        long lastActivity = stee.getLastActivityTimeNanos();
-                        long idleTime = stee.ticker().nanoTime() - lastActivity;
+                        if (activeTime == 0) {
+                            long lastActivity = eventExecutor.getLastActivityTimeNanos();
+                            long idleTime = now - lastActivity;
 
-                        // If the event loop has been idle for less time than our utilization window,
-                        // it means it was active for the remainder of that window.
-                        if (idleTime < totalTime) {
-                            activeTime = totalTime - idleTime;
+                            // If the event loop has been idle for less time than our utilization window,
+                            // it means it was active for the remainder of that window.
+                            if (idleTime < totalTime) {
+                                activeTime = totalTime - idleTime;
+                            }
+                            // If idleTime >= totalTime, it was idle for the whole window, so activeTime remains 0.
                         }
-                        // If idleTime >= totalTime, it was idle for the whole window, so activeTime remains 0.
-                    }
-
-                    double utilization = Math.min(1.0, (double) activeTime / totalTime);
 
-                    if (utilization < scaleDownThreshold) {
-                        // Utilization is low, increment idle counter and reset busy counter.
-                        int idleCycles = stee.getAndIncrementIdleCycles();
-                        stee.resetBusyCycles();
-                        if (idleCycles >= scalingPatienceCycles && stee.getNumOfRegisteredChannels() <= 0) {
-                            consistentlyIdleChildren.add(stee);
+                        utilization = Math.min(1.0, (double) activeTime / totalTime);
+
+                        if (utilization < scaleDownThreshold) {
+                            // Utilization is low, increment idle counter and reset busy counter.
+                            int idleCycles = eventExecutor.getAndIncrementIdleCycles();
+                            eventExecutor.resetBusyCycles();
+                            if (idleCycles >= scalingPatienceCycles &&
+                                eventExecutor.getNumOfRegisteredChannels() <= 0) {
+                                consistentlyIdleChildren.add(eventExecutor);
+                            }
+                        } else if (utilization > scaleUpThreshold) {
+                            // Utilization is high, increment busy counter and reset idle counter.
+                            int busyCycles = eventExecutor.getAndIncrementBusyCycles();
+                            eventExecutor.resetIdleCycles();
+                            if (busyCycles >= scalingPatienceCycles) {
+                                consistentlyBusyChildren++;
+                            }
+                        } else {
+                            // Utilization is in the normal range, reset counters.
+                            eventExecutor.resetIdleCycles();
+                            eventExecutor.resetBusyCycles();
                         }
-                    } else if (utilization > scaleUpThreshold) {
-                        // Utilization is high, increment busy counter and reset idle counter.
-                        int busyCycles = stee.getAndIncrementBusyCycles();
-                        stee.resetIdleCycles();
-                        if (busyCycles >= scalingPatienceCycles) {
-                            consistentlyBusyChildren++;
-                        }
-                    } else {
-                        // Utilization is in the normal range, reset counters.
-                        stee.resetIdleCycles();
-                        stee.resetBusyCycles();
                     }
+
+                    utilizationMetrics.get(i).setUtilization(utilization);
                 }
 
-                boolean changed = false; // Flag to track if we need to rebuild the active executors list.
                 int currentActive = currentState.activeChildrenCount;
 
                 // Make scaling decisions based on stable states.
@@ -289,6 +367,7 @@ public final class AutoScalingEventExecutorChooserFactory implements EventExecut
                     }
                 }
 
+                boolean changed = false; // Flag to track if we need to rebuild the active executors list.
                 if (!consistentlyIdleChildren.isEmpty() && currentActive > minChildren) {
                     // Scale down, we have children that have been idle for multiple cycles.
 
diff --git a/common/src/main/java/io/netty/util/concurrent/EventExecutorChooserFactory.java b/common/src/main/java/io/netty/util/concurrent/EventExecutorChooserFactory.java
index 4245212724..5bd699a2d1 100644
--- a/common/src/main/java/io/netty/util/concurrent/EventExecutorChooserFactory.java
+++ b/common/src/main/java/io/netty/util/concurrent/EventExecutorChooserFactory.java
@@ -15,6 +15,10 @@
  */
 package io.netty.util.concurrent;
 
+import io.netty.util.concurrent.AutoScalingEventExecutorChooserFactory.AutoScalingUtilizationMetric;
+
+import java.util.List;
+
 /**
  * Factory that creates new {@link EventExecutorChooser}s.
  */
@@ -35,4 +39,24 @@ public interface EventExecutorChooserFactory {
          */
         EventExecutor next();
     }
+
+    /**
+     * An {@link EventExecutorChooser} that exposes metrics for observation.
+     */
+    interface ObservableEventExecutorChooser extends EventExecutorChooser {
+
+        /**
+         * Returns the current number of active {@link EventExecutor}s.
+         * @return the number of active executors.
+         */
+        int activeExecutorCount();
+
+        /**
+         * Returns a list containing the last calculated utilization for each
+         * {@link EventExecutor} in the group.
+         *
+         * @return an umodifiable view of the executor utilizations.
+         */
+        List<AutoScalingUtilizationMetric> executorUtilizations();
+    }
 }
diff --git a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
index d56afc2055..d89c6a5eac 100644
--- a/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
+++ b/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java
@@ -15,17 +15,21 @@
  */
 package io.netty.util.concurrent;
 
-import static io.netty.util.internal.ObjectUtil.checkPositive;
+import io.netty.util.concurrent.AutoScalingEventExecutorChooserFactory.AutoScalingUtilizationMetric;
+import io.netty.util.concurrent.EventExecutorChooserFactory.ObservableEventExecutorChooser;
 
 import java.util.Collections;
 import java.util.Iterator;
 import java.util.LinkedHashSet;
+import java.util.List;
 import java.util.Set;
 import java.util.concurrent.Executor;
 import java.util.concurrent.ThreadFactory;
 import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicInteger;
 
+import static io.netty.util.internal.ObjectUtil.checkPositive;
+
 /**
  * Abstract base class for {@link EventExecutorGroup} implementations that handles their tasks with multiple threads at
  * the same time.
@@ -150,6 +154,33 @@ public abstract class MultithreadEventExecutorGroup extends AbstractEventExecuto
         return children.length;
     }
 
+    /**
+     * Returns the number of currently active threads if the group is using an
+     * {@link ObservableEventExecutorChooser}. Otherwise, for a non-scaling group,
+     * this method returns the total number of threads, as all are considered active.
+     *
+     * @return the count of active threads.
+     */
+    public int activeExecutorCount() {
+        if (chooser instanceof ObservableEventExecutorChooser) {
+            return ((ObservableEventExecutorChooser) chooser).activeExecutorCount();
+        }
+        return executorCount();
+    }
+
+    /**
+     * Returns a list of real-time utilization metrics if the group was configured
+     * with a compatible {@link EventExecutorChooserFactory}, otherwise an empty list.
+     *
+     * @return A list of {@link AutoScalingUtilizationMetric} objects.
+     */
+    public List<AutoScalingUtilizationMetric> executorUtilizations() {
+        if (chooser instanceof ObservableEventExecutorChooser) {
+            return ((ObservableEventExecutorChooser) chooser).executorUtilizations();
+        }
+        return Collections.emptyList();
+    }
+
     /**
      * Create a new EventExecutor which will later then accessible via the {@link #next()}  method. This method will be
      * called for each thread that will serve this {@link MultithreadEventExecutorGroup}.
diff --git a/common/src/test/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactoryTest.java b/common/src/test/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactoryTest.java
index 61ac08fa48..a238f58229 100644
--- a/common/src/test/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactoryTest.java
+++ b/common/src/test/java/io/netty/util/concurrent/AutoScalingEventExecutorChooserFactoryTest.java
@@ -15,9 +15,11 @@
  */
 package io.netty.util.concurrent;
 
+import io.netty.util.concurrent.AutoScalingEventExecutorChooserFactory.AutoScalingUtilizationMetric;
 import org.junit.jupiter.api.Test;
 import org.junit.jupiter.api.Timeout;
 
+import java.util.List;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
 import java.util.concurrent.Executors;
@@ -25,6 +27,7 @@ import java.util.concurrent.TimeUnit;
 import java.util.concurrent.atomic.AtomicBoolean;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertTrue;
 import static org.junit.jupiter.api.Assertions.fail;
 
 public class AutoScalingEventExecutorChooserFactoryTest {
@@ -108,11 +111,11 @@ public class AutoScalingEventExecutorChooserFactoryTest {
         TestEventExecutorGroup group = new TestEventExecutorGroup(1, 3, 50, TimeUnit.MILLISECONDS);
         try {
             startAllExecutors(group);
-            assertEquals(3, countActiveExecutors(group));
+            assertEquals(3, group.activeExecutorCount());
             Thread.sleep(200);
 
             // The monitor should have suspended 2 executors, leaving 1 active.
-            assertEquals(1, countActiveExecutors(group));
+            assertEquals(1, group.activeExecutorCount());
         } finally {
             group.shutdownGracefully().syncUninterruptibly();
         }
@@ -125,7 +128,7 @@ public class AutoScalingEventExecutorChooserFactoryTest {
         try {
             startAllExecutors(group);
             Thread.sleep(200);
-            assertEquals(1, countActiveExecutors(group));
+            assertEquals(1, group.activeExecutorCount());
 
             TestEventExecutor activeExecutor = null;
             for (EventExecutor exec : group) {
@@ -143,10 +146,10 @@ public class AutoScalingEventExecutorChooserFactoryTest {
             // The monitor will see high utilization on the active thread. After 2 cycles (100 ms),
             // it will decide to scale up.
             long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(5);
-            while (countActiveExecutors(group) < 2 && System.nanoTime() < deadline) {
+            while (group.activeExecutorCount() < 2 && System.nanoTime() < deadline) {
                 Thread.sleep(50);
             }
-            assertEquals(2, countActiveExecutors(group),
+            assertEquals(2, group.activeExecutorCount(),
                          "Should scale up to 2 after stressing one executor.");
 
             for (EventExecutor exec : group) {
@@ -155,10 +158,10 @@ public class AutoScalingEventExecutorChooserFactoryTest {
                 }
             }
 
-            while (countActiveExecutors(group) < 3 && System.nanoTime() < deadline) {
+            while (group.activeExecutorCount() < 3 && System.nanoTime() < deadline) {
                 Thread.sleep(50);
             }
-            assertEquals(3, countActiveExecutors(group),
+            assertEquals(3, group.activeExecutorCount(),
                          "Should scale up to 3 after stressing two executors.");
         } finally {
             group.shutdownGracefully().syncUninterruptibly();
@@ -172,7 +175,7 @@ public class AutoScalingEventExecutorChooserFactoryTest {
         try {
             startAllExecutors(group);
             Thread.sleep(200);
-            assertEquals(2, countActiveExecutors(group), "Should not scale below minThreads");
+            assertEquals(2, group.activeExecutorCount(), "Should not scale below minThreads");
         } finally {
             group.shutdownGracefully().syncUninterruptibly();
         }
@@ -185,7 +188,7 @@ public class AutoScalingEventExecutorChooserFactoryTest {
         try {
             startAllExecutors(group);
             Thread.sleep(200); // Allow time for initial scale-down to minThreads
-            assertEquals(1, countActiveExecutors(group));
+            assertEquals(1, group.activeExecutorCount());
 
             TestEventExecutor activeExecutor = null;
             for (EventExecutor exec : group) {
@@ -201,10 +204,10 @@ public class AutoScalingEventExecutorChooserFactoryTest {
 
             // Wait for the UtilizationMonitor to react and scale up.
             long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(5);
-            while (countActiveExecutors(group) < 2 && System.nanoTime() < deadline) {
+            while (group.activeExecutorCount() < 2 && System.nanoTime() < deadline) {
                 Thread.sleep(50);
             }
-            assertEquals(2, countActiveExecutors(group), "Should scale up to maxThreads");
+            assertEquals(2, group.activeExecutorCount(), "Should scale up to maxThreads");
 
             // Now that we have scaled up, put all active executors under a high load
             // to prevent the new one from being scaled back down immediately.
@@ -219,7 +222,7 @@ public class AutoScalingEventExecutorChooserFactoryTest {
             group.next();
             Thread.sleep(200); // Give the monitor time to check again.
 
-            assertEquals(2, countActiveExecutors(group),
+            assertEquals(2, group.activeExecutorCount(),
                          "Should not scale back down while load is high");
         } finally {
             group.shutdownGracefully().syncUninterruptibly();
@@ -234,10 +237,10 @@ public class AutoScalingEventExecutorChooserFactoryTest {
             startAllExecutors(group);
 
             long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(5);
-            while (countActiveExecutors(group) > 1 && System.nanoTime() < deadline) {
+            while (group.activeExecutorCount() > 1 && System.nanoTime() < deadline) {
                 Thread.sleep(50);
             }
-            assertEquals(1, countActiveExecutors(group),
+            assertEquals(1, group.activeExecutorCount(),
                          "Group should scale down to 1 active executor");
 
             // Simulate a slow trickle of new work (e.g., new connections) by calling next() a few times.
@@ -246,7 +249,7 @@ public class AutoScalingEventExecutorChooserFactoryTest {
                 Thread.sleep(20);
             }
 
-            assertEquals(1, countActiveExecutors(group),
+            assertEquals(1, group.activeExecutorCount(),
                          "Should consolidate the trickle of work onto the single active executor, without" +
                          " waking up the suspended ones");
         } finally {
@@ -254,6 +257,74 @@ public class AutoScalingEventExecutorChooserFactoryTest {
         }
     }
 
+    @Test
+    @Timeout(30)
+    void testMetricsProvideCorrectUtilizationAndActiveExecutorCount() throws InterruptedException {
+        TestEventExecutorGroup group = new TestEventExecutorGroup(1, 3, 50, TimeUnit.MILLISECONDS);
+        try {
+            startAllExecutors(group);
+            long deadline = System.nanoTime() + TimeUnit.SECONDS.toNanos(5);
+            while (group.activeExecutorCount() > 1 && System.nanoTime() < deadline) {
+                Thread.sleep(50);
+            }
+            assertEquals(1, group.activeExecutorCount(), "Should have scaled down to 1 active executor.");
+
+            TestEventExecutor activeExecutor = null;
+            for (EventExecutor exec : group) {
+                if (!exec.isSuspended()) {
+                    activeExecutor = (TestEventExecutor) exec;
+                    break;
+                }
+            }
+            if (activeExecutor == null) {
+                fail("Could not find an active executor.");
+            }
+
+            activeExecutor.setHighLoad(true);
+
+            while (System.nanoTime() < deadline) {
+                List<AutoScalingUtilizationMetric> utilizationMetrics = group.executorUtilizations();
+                TestEventExecutor finalActiveExecutor = activeExecutor;
+                double utilization = utilizationMetrics.stream()
+                                                       .filter(metric -> metric.executor().equals(finalActiveExecutor))
+                                                       .findFirst()
+                        .map(AutoScalingUtilizationMetric::utilization)
+                        .orElse(0.0);
+                if (utilization > 0.4) {
+                    break;
+                }
+                Thread.sleep(50);
+            }
+
+            assertEquals(1, group.activeExecutorCount(), "Active count should still be 1 before scaling up.");
+
+            List<AutoScalingUtilizationMetric> utilizationMetrics = group.executorUtilizations();
+            assertEquals(3, utilizationMetrics.size(), "Utilization list should report on all executors.");
+
+            TestEventExecutor finalActiveExecutor2 = activeExecutor;
+            double activeUtilization = utilizationMetrics.stream()
+                                                         .filter(metric -> metric.executor()
+                                                                                 .equals(finalActiveExecutor2))
+                                                         .findFirst()
+                                                         .map(AutoScalingUtilizationMetric::utilization)
+                                                         .orElse(0.0);
+            assertTrue(activeUtilization > 0.4,
+                       "Active executor should have utilization above the scale-down threshold. " +
+                       "Was: " + activeUtilization);
+
+            TestEventExecutor finalActiveExecutor1 = activeExecutor;
+            utilizationMetrics.stream()
+                              .filter(metric -> metric.executor() != finalActiveExecutor1)
+                              .forEach(metric -> {
+                                  assertTrue(metric.executor().isSuspended(), "Other executors should be suspended.");
+                                  assertEquals(0.0, metric.utilization(),
+                                               "Suspended executor should have 0.0 utilization.");
+                              });
+        } finally {
+            group.shutdownGracefully().syncUninterruptibly();
+        }
+    }
+
     private static void startAllExecutors(MultithreadEventExecutorGroup group) throws InterruptedException {
         CountDownLatch startLatch = new CountDownLatch(group.executorCount());
         for (EventExecutor executor : group) {
@@ -261,14 +332,4 @@ public class AutoScalingEventExecutorChooserFactoryTest {
         }
         startLatch.await();
     }
-
-    private static int countActiveExecutors(MultithreadEventExecutorGroup group) {
-        int activeCount = 0;
-        for (EventExecutor executor : group) {
-            if (!executor.isSuspended()) {
-                activeCount++;
-            }
-        }
-        return activeCount;
-    }
 }
