diff --git a/handler/src/main/java/io/netty/handler/ssl/SslContext.java b/handler/src/main/java/io/netty/handler/ssl/SslContext.java
index efb8e36b4b..dc898915da 100644
--- a/handler/src/main/java/io/netty/handler/ssl/SslContext.java
+++ b/handler/src/main/java/io/netty/handler/ssl/SslContext.java
@@ -28,6 +28,7 @@ import io.netty.util.AttributeMap;
 import io.netty.util.DefaultAttributeMap;
 import io.netty.util.internal.EmptyArrays;
 
+import java.io.BufferedInputStream;
 import java.security.Provider;
 import javax.net.ssl.KeyManager;
 import javax.net.ssl.KeyManagerFactory;
@@ -1143,10 +1144,17 @@ public abstract class SslContext {
 
         // try BC first, if this fail fallback to original key extraction process
         if (BouncyCastlePemReader.isAvailable()) {
+            if (!keyInputStream.markSupported()) {
+                // We need an input stream that supports resetting, in case BouncyCastle fails to read.
+                keyInputStream = new BufferedInputStream(keyInputStream);
+            }
+            keyInputStream.mark(1048576); // Be able to reset up to 1 MiB of data.
             PrivateKey pk = BouncyCastlePemReader.getPrivateKey(keyInputStream, keyPassword);
             if (pk != null) {
                 return pk;
             }
+            // BouncyCastle could not read the key. Reset the input stream in case the input position changed.
+            keyInputStream.reset();
         }
 
         return getPrivateKeyFromByteBuffer(PemReader.readPrivateKey(keyInputStream), keyPassword);
