diff --git a/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
index b1a5eb00aa..229784949a 100644
--- a/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/SimpleLeakAwareByteBuf.java
@@ -140,12 +140,8 @@ class SimpleLeakAwareByteBuf extends WrappedByteBuf {
             // Update the parent to point to this buffer so we correctly close the ResourceLeakTracker.
             ((AbstractPooledDerivedByteBuf) unwrappedDerived).parent(this);
 
-            ResourceLeakTracker<ByteBuf> newLeak = AbstractByteBuf.leakDetector.track(derived);
-            if (newLeak == null) {
-                // No leak detection, just return the derived buffer.
-                return derived;
-            }
-            return newLeakAwareByteBuf(derived, newLeak);
+            // force tracking of derived buffers (see issue #13414)
+            return newLeakAwareByteBuf(derived, AbstractByteBuf.leakDetector.trackForcibly(derived));
         }
         return newSharedLeakAwareByteBuf(derived);
     }
diff --git a/common/src/main/java/io/netty/util/ResourceLeakDetector.java b/common/src/main/java/io/netty/util/ResourceLeakDetector.java
index ad5f5e8a9c..9409f9c42a 100644
--- a/common/src/main/java/io/netty/util/ResourceLeakDetector.java
+++ b/common/src/main/java/io/netty/util/ResourceLeakDetector.java
@@ -231,7 +231,7 @@ public class ResourceLeakDetector<T> {
      */
     @Deprecated
     public final ResourceLeak open(T obj) {
-        return track0(obj);
+        return track0(obj, false);
     }
 
     /**
@@ -242,25 +242,33 @@ public class ResourceLeakDetector<T> {
      */
     @SuppressWarnings("unchecked")
     public final ResourceLeakTracker<T> track(T obj) {
-        return track0(obj);
+        return track0(obj, false);
     }
 
+    /**
+     * Creates a new {@link ResourceLeakTracker} which is expected to be closed via
+     * {@link ResourceLeakTracker#close(Object)} when the related resource is deallocated.
+     *
+     * Unlike {@link #track(Object)}, this method always returns a tracker, regardless
+     * of the detection settings.
+     *
+     * @return the {@link ResourceLeakTracker}
+     */
     @SuppressWarnings("unchecked")
-    private DefaultResourceLeak track0(T obj) {
-        Level level = ResourceLeakDetector.level;
-        if (level == Level.DISABLED) {
-            return null;
-        }
+    public ResourceLeakTracker<T> trackForcibly(T obj) {
+        return track0(obj, true);
+    }
 
-        if (level.ordinal() < Level.PARANOID.ordinal()) {
-            if ((PlatformDependent.threadLocalRandom().nextInt(samplingInterval)) == 0) {
-                reportLeak();
-                return new DefaultResourceLeak(obj, refQueue, allLeaks, getInitialHint(resourceType));
-            }
-            return null;
+    @SuppressWarnings("unchecked")
+    private DefaultResourceLeak track0(T obj, boolean force) {
+        Level level = ResourceLeakDetector.level;
+        if (force ||
+                level == Level.PARANOID ||
+                (level != Level.DISABLED && PlatformDependent.threadLocalRandom().nextInt(samplingInterval) == 0)) {
+            reportLeak();
+            return new DefaultResourceLeak(obj, refQueue, allLeaks, getInitialHint(resourceType));
         }
-        reportLeak();
-        return new DefaultResourceLeak(obj, refQueue, allLeaks, getInitialHint(resourceType));
+        return null;
     }
 
     private void clearRefQueue() {
