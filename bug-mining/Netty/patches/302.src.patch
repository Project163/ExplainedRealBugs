diff --git a/handler/src/main/java/io/netty/handler/ssl/SslHandlerCoalescingBufferQueue.java b/handler/src/main/java/io/netty/handler/ssl/SslHandlerCoalescingBufferQueue.java
index 762cc4bdc2..289408cf40 100644
--- a/handler/src/main/java/io/netty/handler/ssl/SslHandlerCoalescingBufferQueue.java
+++ b/handler/src/main/java/io/netty/handler/ssl/SslHandlerCoalescingBufferQueue.java
@@ -42,38 +42,27 @@ abstract class SslHandlerCoalescingBufferQueue extends AbstractCoalescingBufferQ
 
     @Override
     protected ByteBuf compose(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf next) {
-        final int wrapDataSize = wrapDataSize();
-        if (cumulation instanceof CompositeByteBuf) {
-            CompositeByteBuf composite = (CompositeByteBuf) cumulation;
-            int numComponents = composite.numComponents();
-            if (numComponents == 0 ||
-                    !attemptCopyToCumulation(composite.internalComponent(numComponents - 1), next, wrapDataSize)) {
-                composite.addComponent(true, next);
-            }
-            return composite;
-        }
-        return attemptCopyToCumulation(cumulation, next, wrapDataSize) ? cumulation :
+        return attemptCopyToCumulation(cumulation, next, wrapDataSize()) ? cumulation :
                 copyAndCompose(alloc, cumulation, next);
     }
 
     @Override
-    protected ByteBuf composeFirst(ByteBufAllocator allocator, ByteBuf first) {
-        if (first instanceof CompositeByteBuf) {
-            CompositeByteBuf composite = (CompositeByteBuf) first;
-            if (wantsDirectBuffer) {
-                first = allocator.directBuffer(composite.readableBytes());
-            } else {
-                first = allocator.heapBuffer(composite.readableBytes());
-            }
-            try {
-                first.writeBytes(composite);
-            } catch (Throwable cause) {
-                first.release();
-                PlatformDependent.throwException(cause);
-            }
-            composite.release();
+    protected ByteBuf composeFirst(ByteBufAllocator allocator, ByteBuf first, int bufferSize) {
+        final ByteBuf newFirst;
+        if (wantsDirectBuffer) {
+            newFirst = allocator.directBuffer(bufferSize);
+        } else {
+            newFirst = allocator.heapBuffer(bufferSize);
+        }
+        try {
+            newFirst.writeBytes(first);
+        } catch (Throwable cause) {
+            newFirst.release();
+            PlatformDependent.throwException(cause);
         }
-        return first;
+        assert !first.isReadable();
+        first.release();
+        return newFirst;
     }
 
     @Override
diff --git a/handler/src/test/java/io/netty/handler/ssl/SslHandlerCoalescingBufferQueueTest.java b/handler/src/test/java/io/netty/handler/ssl/SslHandlerCoalescingBufferQueueTest.java
index 5ac8795cbd..12b72cadf2 100644
--- a/handler/src/test/java/io/netty/handler/ssl/SslHandlerCoalescingBufferQueueTest.java
+++ b/handler/src/test/java/io/netty/handler/ssl/SslHandlerCoalescingBufferQueueTest.java
@@ -21,19 +21,82 @@ import io.netty.buffer.UnpooledByteBufAllocator;
 import io.netty.channel.ChannelPromise;
 import io.netty.channel.embedded.EmbeddedChannel;
 import org.junit.jupiter.params.ParameterizedTest;
-import org.junit.jupiter.params.provider.ValueSource;
+import org.junit.jupiter.params.provider.EnumSource;
 
 import java.nio.ByteBuffer;
+import java.util.function.Function;
+import java.util.function.Supplier;
 
 import static org.junit.jupiter.api.Assertions.assertEquals;
 import static org.junit.jupiter.api.Assertions.assertFalse;
 import static org.junit.jupiter.api.Assertions.assertTrue;
 
 public class SslHandlerCoalescingBufferQueueTest {
+    static final Supplier<ByteBuf> BYTEBUF_SUPPLIER = new Supplier<ByteBuf>() {
+        @Override
+        public ByteBuf get() {
+            ByteBuf buf = Unpooled.directBuffer(128);
+            buf.writeLong(1);
+            buf.writeLong(2);
+            return buf;
+        }
+    };
+    static final Function<ByteBuf, ByteBuf> NO_WRAPPER = new Function<ByteBuf, ByteBuf>() {
+        @Override
+        public ByteBuf apply(ByteBuf byteBuf) {
+            return byteBuf;
+        }
+    };
+    static final Function<ByteBuf, ByteBuf> DUPLICATE_WRAPPER = new Function<ByteBuf, ByteBuf>() {
+        @Override
+        public ByteBuf apply(ByteBuf byteBuf) {
+            return byteBuf.duplicate();
+        }
+    };
+    static final Function<ByteBuf, ByteBuf> SLICE_WRAPPER = new Function<ByteBuf, ByteBuf>() {
+        @Override
+        public ByteBuf apply(ByteBuf byteBuf) {
+            return byteBuf.slice();
+        }
+    };
+    static ByteBuffer createNioBuffer() {
+        ByteBuffer nioBuffer = ByteBuffer.allocateDirect(128);
+        nioBuffer.putLong(1);
+        nioBuffer.putLong(2);
+        nioBuffer.position(nioBuffer.limit());
+        nioBuffer.flip();
+        return nioBuffer;
+    }
+
+    enum CumulationTestScenario {
+        BASIC_NIO_BUFFER(new Supplier() {
+            @Override
+            public ByteBuf get() {
+                return Unpooled.wrappedBuffer(createNioBuffer());
+            }
+        }, NO_WRAPPER),
+        READ_ONLY_AND_DUPLICATE_NIO_BUFFER(new Supplier() {
+            @Override
+            public ByteBuf get() {
+                return Unpooled.wrappedBuffer(createNioBuffer().asReadOnlyBuffer());
+            }
+        }, DUPLICATE_WRAPPER),
+        BASIC_DIRECT_BUFFER(BYTEBUF_SUPPLIER, NO_WRAPPER),
+        DUPLICATE_DIRECT_BUFFER(BYTEBUF_SUPPLIER, DUPLICATE_WRAPPER),
+        SLICED_DIRECT_BUFFER(BYTEBUF_SUPPLIER, SLICE_WRAPPER);
+
+        final Supplier<ByteBuf> bufferSupplier;
+        final Function<ByteBuf, ByteBuf> bufferWrapper;
+
+        CumulationTestScenario(Supplier<ByteBuf> bufferSupplier, Function<ByteBuf, ByteBuf> bufferWrapper) {
+            this.bufferSupplier = bufferSupplier;
+            this.bufferWrapper = bufferWrapper;
+        }
+    }
 
     @ParameterizedTest
-    @ValueSource(booleans = { true, false })
-    public void testCumulation(boolean readOnlyAndDuplicate) {
+    @EnumSource(CumulationTestScenario.class)
+    public void testCumulation(CumulationTestScenario testScenario) {
         EmbeddedChannel channel = new EmbeddedChannel();
         SslHandlerCoalescingBufferQueue queue = new SslHandlerCoalescingBufferQueue(channel, 16, false) {
             @Override
@@ -42,21 +105,12 @@ public class SslHandlerCoalescingBufferQueueTest {
             }
         };
 
-        ByteBuffer nioBuffer = ByteBuffer.allocateDirect(128);
-        nioBuffer.putLong(0);
-        nioBuffer.putLong(0);
-        nioBuffer.putLong(0);
-        nioBuffer.flip();
-        ByteBuf first;
-        if (readOnlyAndDuplicate) {
-            first = Unpooled.wrappedBuffer(nioBuffer.asReadOnlyBuffer()).duplicate();
-            first.writerIndex(8);
-        } else {
-            first = Unpooled.wrappedBuffer(nioBuffer);
-            first.writerIndex(8);
-        }
+        ByteBuf original = testScenario.bufferSupplier.get();
+        original.writerIndex(8);
+        ByteBuf first = testScenario.bufferWrapper.apply(original);
+        first.retain();
         queue.add(first);
-        ByteBuf second = Unpooled.copyLong(1);
+        ByteBuf second = Unpooled.copyLong(3);
         queue.add(second);
 
         ChannelPromise promise = channel.newPromise();
@@ -64,12 +118,16 @@ public class SslHandlerCoalescingBufferQueueTest {
         ByteBuf buffer = queue.remove(UnpooledByteBufAllocator.DEFAULT, 128, promise);
         try {
             assertEquals(16, buffer.readableBytes());
-            assertEquals(0, buffer.readLong());
             assertEquals(1, buffer.readLong());
+            assertEquals(3, buffer.readLong());
         } finally {
             buffer.release();
         }
         assertTrue(queue.isEmpty());
+        assertEquals(8, original.writerIndex());
+        original.writerIndex(original.capacity());
+        assertEquals(2, original.getLong(8));
+        first.release();
         assertEquals(0, first.refCnt());
         assertEquals(0, second.refCnt());
     }
diff --git a/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java b/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java
index 37f0f00843..58be9d1e48 100644
--- a/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java
+++ b/transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java
@@ -181,10 +181,10 @@ public abstract class AbstractCoalescingBufferQueue {
 
                     bytes -= bufferBytes;
                     if (toReturn == null) {
-                        // if there are no more bytes in the queue after this, there's no reason to compose
-                        toReturn = bufferBytes == readableBytes
+                        // if there are no more bytes to read, there's no reason to compose
+                        toReturn = bytes == 0
                                 ? entryBuffer
-                                : composeFirst(alloc, entryBuffer);
+                                : composeFirst(alloc, entryBuffer, bufferBytes + bytes);
                     } else {
                         toReturn = compose(alloc, toReturn, entryBuffer);
                     }
@@ -333,7 +333,21 @@ public abstract class AbstractCoalescingBufferQueue {
     /**
      * Calculate the first {@link ByteBuf} which will be used in subsequent calls to
      * {@link #compose(ByteBufAllocator, ByteBuf, ByteBuf)}.
+     * @param bufferSize the optimal size of the buffer needed for cumulation
+     * @return the first buffer
      */
+    protected ByteBuf composeFirst(ByteBufAllocator allocator, ByteBuf first, int bufferSize) {
+        return composeFirst(allocator, first);
+    }
+
+    /**
+     * Calculate the first {@link ByteBuf} which will be used in subsequent calls to
+     * {@link #compose(ByteBufAllocator, ByteBuf, ByteBuf)}.
+     * This method is deprecated and will be removed in the future. Implementing classes should
+     * override {@link #composeFirst(ByteBufAllocator, ByteBuf, int)} instead.
+     * @deprecated Use {AbstractCoalescingBufferQueue#composeFirst(ByteBufAllocator, ByteBuf, int)}
+     */
+    @Deprecated
     protected ByteBuf composeFirst(ByteBufAllocator allocator, ByteBuf first) {
         return first;
     }
