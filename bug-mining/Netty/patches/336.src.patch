diff --git a/common/src/main/java/io/netty/util/HashedWheelTimer.java b/common/src/main/java/io/netty/util/HashedWheelTimer.java
index 74576d3cbb..78848c0e6a 100644
--- a/common/src/main/java/io/netty/util/HashedWheelTimer.java
+++ b/common/src/main/java/io/netty/util/HashedWheelTimer.java
@@ -15,7 +15,6 @@
  */
 package io.netty.util;
 
-import static io.netty.util.internal.ObjectUtil.checkInRange;
 import static io.netty.util.internal.ObjectUtil.checkPositive;
 import static io.netty.util.internal.ObjectUtil.checkNotNull;
 
@@ -665,13 +664,15 @@ public class HashedWheelTimer implements Timer {
             return true;
         }
 
-        void removeAfterCancellation() {
+        private void remove() {
             HashedWheelBucket bucket = this.bucket;
             if (bucket != null) {
                 bucket.remove(this);
-            } else {
-                timer.pendingTimeouts.decrementAndGet();
             }
+            timer.pendingTimeouts.decrementAndGet();
+        }
+        void removeAfterCancellation() {
+            remove();
             task.cancelled(this);
         }
 
@@ -699,6 +700,7 @@ public class HashedWheelTimer implements Timer {
             }
 
             try {
+                remove();
                 timer.taskExecutor.execute(this);
             } catch (Throwable t) {
                 if (logger.isWarnEnabled()) {
@@ -784,7 +786,6 @@ public class HashedWheelTimer implements Timer {
             while (timeout != null) {
                 HashedWheelTimeout next = timeout.next;
                 if (timeout.remainingRounds <= 0) {
-                    next = remove(timeout);
                     if (timeout.deadline <= deadline) {
                         timeout.expire();
                     } else {
@@ -792,9 +793,7 @@ public class HashedWheelTimer implements Timer {
                         throw new IllegalStateException(String.format(
                                 "timeout.deadline (%d) > deadline (%d)", timeout.deadline, deadline));
                     }
-                } else if (timeout.isCancelled()) {
-                    next = remove(timeout);
-                } else {
+                } else if (!timeout.isCancelled()) {
                     timeout.remainingRounds --;
                 }
                 timeout = next;
@@ -827,7 +826,6 @@ public class HashedWheelTimer implements Timer {
             timeout.prev = null;
             timeout.next = null;
             timeout.bucket = null;
-            timeout.timer.pendingTimeouts.decrementAndGet();
             return next;
         }
 
diff --git a/common/src/test/java/io/netty/util/HashedWheelTimerTest.java b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java
index 5789e6ee14..a58f27167b 100644
--- a/common/src/test/java/io/netty/util/HashedWheelTimerTest.java
+++ b/common/src/test/java/io/netty/util/HashedWheelTimerTest.java
@@ -17,6 +17,8 @@ package io.netty.util;
 
 import org.junit.jupiter.api.Test;
 
+import java.util.ArrayList;
+import java.util.List;
 import java.util.concurrent.BlockingQueue;
 import java.util.concurrent.CountDownLatch;
 import java.util.concurrent.Executor;
@@ -298,7 +300,6 @@ public class HashedWheelTimerTest {
         }
     }
 
-    @Test
     @org.junit.jupiter.api.Timeout(value = 5000, unit = TimeUnit.MILLISECONDS)
     public void cancelWillCallCallback() throws InterruptedException {
         final CountDownLatch latch = new CountDownLatch(1);
@@ -318,7 +319,32 @@ public class HashedWheelTimerTest {
         assertEquals(1, timer.pendingTimeouts());
         t1.cancel();
         latch.await();
+    }
 
+    @Test
+    public void testPendingTimeoutsShouldBeCountedCorrectlyWhenTimeoutCancelledWithinGoalTick()
+        throws InterruptedException {
+        final HashedWheelTimer timer = new HashedWheelTimer();
+        final CountDownLatch barrier = new CountDownLatch(1);
+        // A total of 11 timeouts with the same delay are submitted, and they will be processed in the same tick.
+        timer.newTimeout(new TimerTask() {
+            @Override
+            public void run(Timeout timeout) throws Exception {
+                barrier.countDown();
+                Thread.sleep(1000);
+            }
+        }, 200, TimeUnit.MILLISECONDS);
+        List<Timeout> timeouts = new ArrayList<Timeout>();
+        for (int i = 0; i < 10; i++) {
+            timeouts.add(timer.newTimeout(createNoOpTimerTask(), 200, TimeUnit.MILLISECONDS));
+        }
+        barrier.await();
+        // The simulation here is that the timeout has been transferred to a bucket and is canceled before it is
+        // actually expired in the goal tick.
+        for (Timeout timeout : timeouts) {
+            timeout.cancel();
+        }
+        Thread.sleep(2000);
         assertEquals(0, timer.pendingTimeouts());
         timer.stop();
     }
