diff --git a/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java
index 411ca6b5ad..47886b246b 100644
--- a/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java
+++ b/codec-http2/src/main/java/io/netty/handler/codec/http2/StreamBufferingEncoder.java
@@ -151,22 +151,32 @@ public class StreamBufferingEncoder extends DecoratingHttp2ConnectionEncoder {
     }
 
     @Override
-    public ChannelFuture writeHeaders(ChannelHandlerContext ctx, int streamId, Http2Headers headers,
-                                      int padding, boolean endStream, ChannelPromise promise) {
-        return writeHeaders(ctx, streamId, headers, 0, Http2CodecUtil.DEFAULT_PRIORITY_WEIGHT,
-                false, padding, endStream, promise);
+    public ChannelFuture writeHeaders(ChannelHandlerContext ctx, int streamId, Http2Headers headers, int padding,
+                                      boolean endStream, ChannelPromise promise) {
+        return writeHeaders0(ctx, streamId, headers, false, 0, (short) 0,
+                             false, padding, endStream, promise);
     }
 
     @Override
     public ChannelFuture writeHeaders(ChannelHandlerContext ctx, int streamId, Http2Headers headers,
-                                      int streamDependency, short weight, boolean exclusive,
-                                      int padding, boolean endOfStream, ChannelPromise promise) {
+                                      int streamDependency, short weight, boolean exclusive, int padding,
+                                      boolean endOfStream, ChannelPromise promise) {
+        return writeHeaders0(ctx, streamId, headers, true, streamDependency, weight, exclusive, padding,
+                             endOfStream, promise);
+    }
+
+    private ChannelFuture writeHeaders0(ChannelHandlerContext ctx, int streamId, Http2Headers headers,
+                                        boolean hasPriority, int streamDependency, short weight, boolean exclusive,
+                                        int padding, boolean endOfStream, ChannelPromise promise) {
         if (closed) {
             return promise.setFailure(new Http2ChannelClosedException());
         }
         if (isExistingStream(streamId) || canCreateStream()) {
-            return super.writeHeaders(ctx, streamId, headers, streamDependency, weight,
-                    exclusive, padding, endOfStream, promise);
+            if (hasPriority) {
+                return super.writeHeaders(ctx, streamId, headers, streamDependency, weight,
+                                          exclusive, padding, endOfStream, promise);
+            }
+            return super.writeHeaders(ctx, streamId, headers, padding, endOfStream, promise);
         }
         if (goAwayDetail != null) {
             return promise.setFailure(new Http2GoAwayException(goAwayDetail));
@@ -176,7 +186,7 @@ public class StreamBufferingEncoder extends DecoratingHttp2ConnectionEncoder {
             pendingStream = new PendingStream(ctx, streamId);
             pendingStreams.put(streamId, pendingStream);
         }
-        pendingStream.frames.add(new HeadersFrame(headers, streamDependency, weight, exclusive,
+        pendingStream.frames.add(new HeadersFrame(headers, hasPriority, streamDependency, weight, exclusive,
                 padding, endOfStream, promise));
         return promise;
     }
@@ -332,15 +342,17 @@ public class StreamBufferingEncoder extends DecoratingHttp2ConnectionEncoder {
     private final class HeadersFrame extends Frame {
         final Http2Headers headers;
         final int streamDependency;
+        final boolean hasPriority;
         final short weight;
         final boolean exclusive;
         final int padding;
         final boolean endOfStream;
 
-        HeadersFrame(Http2Headers headers, int streamDependency, short weight, boolean exclusive,
+        HeadersFrame(Http2Headers headers, boolean hasPriority, int streamDependency, short weight, boolean exclusive,
                      int padding, boolean endOfStream, ChannelPromise promise) {
             super(promise);
             this.headers = headers;
+            this.hasPriority = hasPriority;
             this.streamDependency = streamDependency;
             this.weight = weight;
             this.exclusive = exclusive;
@@ -350,7 +362,9 @@ public class StreamBufferingEncoder extends DecoratingHttp2ConnectionEncoder {
 
         @Override
         void send(ChannelHandlerContext ctx, int streamId) {
-            writeHeaders(ctx, streamId, headers, streamDependency, weight, exclusive, padding, endOfStream, promise);
+            writeHeaders0(ctx, streamId, headers, hasPriority, streamDependency, weight, exclusive, padding,
+                          endOfStream,
+                          promise);
         }
     }
 
diff --git a/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java b/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
index ef000fcb2f..01a0afe711 100644
--- a/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
+++ b/codec-http2/src/test/java/io/netty/handler/codec/http2/StreamBufferingEncoderTest.java
@@ -165,7 +165,7 @@ public class StreamBufferingEncoderTest {
     @Test
     public void multipleWritesToActiveStream() {
         encoder.writeSettingsAck(ctx, newPromise());
-        encoderWriteHeaders(3, newPromise());
+        encoderWriteHeaders(3, newPromise(), false);
         assertEquals(0, encoder.numBufferedStreams());
         ByteBuf data = data();
         final int expectedBytes = data.readableBytes() * 3;
@@ -174,7 +174,7 @@ public class StreamBufferingEncoderTest {
         encoder.writeData(ctx, 3, data(), 0, false, newPromise());
         encoderWriteHeaders(3, newPromise());
 
-        writeVerifyWriteHeaders(times(1), 3);
+        writeVerifyWriteHeaders(times(1), 3, false);
         // Contiguous data writes are coalesced
         ArgumentCaptor<ByteBuf> bufCaptor = ArgumentCaptor.forClass(ByteBuf.class);
         verify(writer, times(1))
@@ -535,8 +535,16 @@ public class StreamBufferingEncoderTest {
     }
 
     private ChannelFuture encoderWriteHeaders(int streamId, ChannelPromise promise) {
-        encoder.writeHeaders(ctx, streamId, new DefaultHttp2Headers(), 0, DEFAULT_PRIORITY_WEIGHT,
-                             false, 0, false, promise);
+        return encoderWriteHeaders(streamId, promise, true);
+    }
+
+    private ChannelFuture encoderWriteHeaders(int streamId, ChannelPromise promise, boolean hasPriority) {
+        if (hasPriority) {
+            encoder.writeHeaders(ctx, streamId, new DefaultHttp2Headers(), 0, DEFAULT_PRIORITY_WEIGHT,
+                                 false, 0, false, promise);
+        } else {
+            encoder.writeHeaders(ctx, streamId, new DefaultHttp2Headers(), 0, false, promise);
+        }
         try {
             encoder.flowController().writePendingBytes();
             return promise;
@@ -546,9 +554,18 @@ public class StreamBufferingEncoderTest {
     }
 
     private void writeVerifyWriteHeaders(VerificationMode mode, int streamId) {
-        verify(writer, mode).writeHeaders(eq(ctx), eq(streamId), any(Http2Headers.class), eq(0),
-                                          eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0),
-                                          eq(false), any(ChannelPromise.class));
+        writeVerifyWriteHeaders(mode, streamId, true);
+    }
+
+    private void writeVerifyWriteHeaders(VerificationMode mode, int streamId, boolean hasPriority) {
+        if (hasPriority) {
+            verify(writer, mode).writeHeaders(eq(ctx), eq(streamId), any(Http2Headers.class), eq(0),
+                                              eq(DEFAULT_PRIORITY_WEIGHT), eq(false), eq(0),
+                                              eq(false), any(ChannelPromise.class));
+        } else {
+            verify(writer, mode).writeHeaders(eq(ctx), eq(streamId), any(Http2Headers.class), eq(0),
+                                              eq(false), any(ChannelPromise.class));
+        }
     }
 
     private Answer<ChannelFuture> successAnswer() {
