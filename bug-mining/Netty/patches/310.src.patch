diff --git a/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java
index 21e1291f37..1a277381e8 100644
--- a/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java
+++ b/buffer/src/main/java/io/netty/buffer/AbstractPooledDerivedByteBuf.java
@@ -16,6 +16,7 @@
 
 package io.netty.buffer;
 
+import io.netty.util.IllegalReferenceCountException;
 import io.netty.util.Recycler.EnhancedHandle;
 import io.netty.util.internal.ObjectPool.Handle;
 
@@ -51,6 +52,10 @@ abstract class AbstractPooledDerivedByteBuf extends AbstractReferenceCountedByte
 
     @Override
     public final AbstractByteBuf unwrap() {
+        AbstractByteBuf rootParent = this.rootParent;
+        if (rootParent == null) {
+            throw new IllegalReferenceCountException();
+        }
         return rootParent;
     }
 
@@ -83,6 +88,8 @@ abstract class AbstractPooledDerivedByteBuf extends AbstractReferenceCountedByte
         // otherwise it is possible that the same AbstractPooledDerivedByteBuf is again obtained and init(...) is
         // called before we actually have a chance to call release(). This leads to call release() on the wrong parent.
         ByteBuf parent = this.parent;
+        // Remove references to parent and root so that they can be GCed for leak detection [netty/netty#14247]
+        this.parent = this.rootParent = null;
         recyclerHandle.unguardedRecycle(this);
         parent.release();
     }
