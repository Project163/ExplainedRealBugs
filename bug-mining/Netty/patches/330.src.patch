diff --git a/common/src/main/java/io/netty/util/internal/ObjectUtil.java b/common/src/main/java/io/netty/util/internal/ObjectUtil.java
index e34c11b8cd..fc44eb87f8 100644
--- a/common/src/main/java/io/netty/util/internal/ObjectUtil.java
+++ b/common/src/main/java/io/netty/util/internal/ObjectUtil.java
@@ -26,6 +26,7 @@ public final class ObjectUtil {
     private static final double DOUBLE_ZERO = 0.0D;
     private static final long LONG_ZERO = 0L;
     private static final int INT_ZERO = 0;
+    private static final short SHORT_ZERO = 0;
 
     private ObjectUtil() {
     }
@@ -135,6 +136,17 @@ public final class ObjectUtil {
         return f;
     }
 
+    /**
+     * Checks that the given argument is positive or zero. If it is not , throws {@link IllegalArgumentException}.
+     * Otherwise, returns the argument.
+     */
+    public static short checkPositive(short s, String name) {
+        if (s <= SHORT_ZERO) {
+            throw new IllegalArgumentException(name + " : " + s + " (expected: > 0)");
+        }
+        return s;
+    }
+
     /**
      * Checks that the given argument is positive or zero. If it is not , throws {@link IllegalArgumentException}.
      * Otherwise, returns the argument.
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent.java b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
index a4a1df3b91..4996070a2c 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent.java
@@ -508,6 +508,10 @@ public final class PlatformDependent {
         PlatformDependent0.safeConstructPutInt(object, fieldOffset, value);
     }
 
+    public static void putShortOrdered(long adddress, short newValue) {
+        PlatformDependent0.putShortOrdered(adddress, newValue);
+    }
+
     public static int getIntVolatile(long address) {
         return PlatformDependent0.getIntVolatile(address);
     }
diff --git a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
index 2f387ec385..c41b330fa6 100644
--- a/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
+++ b/common/src/main/java/io/netty/util/internal/PlatformDependent0.java
@@ -31,7 +31,6 @@ import java.security.AccessController;
 import java.security.PrivilegedAction;
 import java.util.concurrent.atomic.AtomicLong;
 
-import static io.netty.util.internal.ObjectUtil.checkNotNull;
 import static java.lang.invoke.MethodType.methodType;
 
 /**
@@ -722,6 +721,11 @@ final class PlatformDependent0 {
         UNSAFE.putShort(address, value);
     }
 
+    static void putShortOrdered(long adddress, short newValue) {
+        UNSAFE.storeFence();
+        UNSAFE.putShort(null, adddress, newValue);
+    }
+
     static void putInt(long address, int value) {
         UNSAFE.putInt(address, value);
     }
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringStreamChannel.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringStreamChannel.java
index 4abd07b007..dcd289cafb 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringStreamChannel.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/AbstractIoUringStreamChannel.java
@@ -218,6 +218,7 @@ abstract class AbstractIoUringStreamChannel extends AbstractIoUringChannel imple
 
         private ByteBuf readBuffer;
         private IovArray iovArray;
+        private IoUringBufferRing lastUsedBufferRing;
 
         @Override
         protected int scheduleWriteMultiple(ChannelOutboundBuffer in) {
@@ -289,6 +290,24 @@ abstract class AbstractIoUringStreamChannel extends AbstractIoUringChannel imple
             assert readBuffer == null;
             assert readId == 0;
 
+            final IOUringStreamChannelConfig channelConfig = (IOUringStreamChannelConfig) config();
+            final IoUringIoHandler ioUringIoHandler = (IoUringIoHandler) registration().ioHandler();
+            // Although we checked whether the current kernel supports `register_buffer_ring`
+            // during the initialization of IoUringIoHandler
+            // we still check it again here.
+            // When the kernel does not support this feature, it helps the JIT to delete this branch.
+            // only `first` value is true, we will recv with the buffer ring;
+            if (IoUring.isRegisterBufferRingSupported() && first) {
+
+                short bgId = channelConfig.getBufferRingConfig();
+                if (bgId != IOUringStreamChannelConfig.DISABLE_BUFFER_SELECT_READ) {
+                    IoUringBufferRing ioUringBufferRing = ioUringIoHandler.findBufferRing(bgId);
+                    if (ioUringBufferRing.hasSpareBuffer() || !ioUringBufferRing.isFull()) {
+                        return scheduleReadProviderBuffer(ioUringBufferRing);
+                    }
+                }
+            }
+
             final IoUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();
             ByteBuf byteBuf = allocHandle.allocate(alloc());
             try {
@@ -335,6 +354,36 @@ abstract class AbstractIoUringStreamChannel extends AbstractIoUringChannel imple
             }
         }
 
+        private int scheduleReadProviderBuffer(IoUringBufferRing bufferRing) {
+            short bgId = bufferRing.bufferGroupId();
+            try {
+                int chunkSize = bufferRing.chunkSize();
+                IoUringIoRegistration registration = registration();
+                IoUringBufferRing ioUringBufferRing = ((IoUringIoHandler) registration.ioHandler())
+                        .findBufferRing(bgId);
+
+                if (!ioUringBufferRing.isFull()) {
+                    ioUringBufferRing.appendBuffer(1);
+                }
+
+                int fd = fd().intValue();
+
+                IoUringIoOps ops = IoUringIoOps.newRecv(
+                        fd, flags((byte) Native.IOSQE_BUFFER_SELECT), (short) 0, 0, 0,
+                        chunkSize, nextOpsId(), bgId
+                );
+                readId = registration.submit(ops);
+                if (readId == 0) {
+                    return 0;
+                }
+                lastUsedBufferRing = ioUringBufferRing;
+                return 1;
+            } catch (IllegalArgumentException illegalArgumentException) {
+                this.handleReadException(pipeline(), null, illegalArgumentException, false, recvBufAllocHandle());
+                return 0;
+            }
+        }
+
         @Override
         protected void readComplete0(byte op, int res, int flags, short data, int outstanding) {
             assert readId != 0;
@@ -344,19 +393,38 @@ abstract class AbstractIoUringStreamChannel extends AbstractIoUringChannel imple
             final IoUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();
             final ChannelPipeline pipeline = pipeline();
             ByteBuf byteBuf = this.readBuffer;
+            IoUringBufferRing bufferRing = lastUsedBufferRing;
             this.readBuffer = null;
-            assert byteBuf != null;
+            this.lastUsedBufferRing = null;
 
             try {
                 if (res < 0) {
                     if (res == Native.ERRNO_ECANCELED_NEGATIVE) {
-                        byteBuf.release();
+                        if (byteBuf != null) {
+                            //recv without buffer ring
+                            byteBuf.release();
+                        }
                         return;
                     }
+
+                    if (res == Native.ERRNO_NO_BUFFER_NEGATIVE) {
+                        //recv with provider buffer fail!
+                        //fallback to normal recv
+                        bufferRing.markReadFail();
+                        // fire the BufferRingExhaustedEvent to notify users.
+                        // Users can then switch the ring buffer or do other things as they wish
+                        pipeline.fireUserEventTriggered(bufferRing.getExhaustedEvent());
+                        scheduleNextRead(flags);
+                        return;
+                    }
+
                     // If res is negative we should pass it to ioResult(...) which will either throw
                     // or convert it to 0 if we could not read because the socket was not readable.
                     allocHandle.lastBytesRead(ioResult("io_uring read", res));
                 } else if (res > 0) {
+                    if (bufferRing != null) {
+                        byteBuf = bufferRing.borrowBuffer(flags >> Native.IORING_CQE_BUFFER_SHIFT, res);
+                    }
                     byteBuf.writerIndex(byteBuf.writerIndex() + res);
                     allocHandle.lastBytesRead(res);
                 } else {
@@ -364,9 +432,12 @@ abstract class AbstractIoUringStreamChannel extends AbstractIoUringChannel imple
                     allocHandle.lastBytesRead(-1);
                 }
                 if (allocHandle.lastBytesRead() <= 0) {
-                    // nothing was read, release the buffer.
-                    byteBuf.release();
-                    byteBuf = null;
+                    // byteBuf might be null if we used a buffer ring.
+                    if (byteBuf != null) {
+                        // nothing was read, release the buffer.
+                        byteBuf.release();
+                        byteBuf = null;
+                    }
                     allDataRead = allocHandle.lastBytesRead() < 0;
                     if (allDataRead) {
                         // There is nothing left to read as we received an EOF.
@@ -380,19 +451,25 @@ abstract class AbstractIoUringStreamChannel extends AbstractIoUringChannel imple
                 allocHandle.incMessagesRead(1);
                 pipeline.fireChannelRead(byteBuf);
                 byteBuf = null;
-                if (allocHandle.continueReading() && !socketIsEmpty(flags)) {
-                    // Let's schedule another read.
-                    scheduleRead(false);
-                } else {
-                    // We did not fill the whole ByteBuf so we should break the "read loop" and try again later.
-                    allocHandle.readComplete();
-                    pipeline.fireChannelReadComplete();
-                }
+                scheduleNextRead(flags);
             } catch (Throwable t) {
                 handleReadException(pipeline, byteBuf, t, allDataRead, allocHandle);
             }
         }
 
+        private void scheduleNextRead(int cqeFlags) {
+            final IoUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();
+            final ChannelPipeline pipeline = pipeline();
+            if (allocHandle.continueReading() && !socketIsEmpty(cqeFlags)) {
+                // Let's schedule another read.
+                scheduleRead(false);
+            } else {
+                // We did not fill the whole ByteBuf so we should break the "read loop" and try again later.
+                allocHandle.readComplete();
+                pipeline.fireChannelReadComplete();
+            }
+        }
+
         private void handleReadException(ChannelPipeline pipeline, ByteBuf byteBuf,
                                          Throwable cause, boolean allDataRead,
                                          IoUringRecvByteAllocatorHandle allocHandle) {
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IOUringSocketChannelConfig.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IOUringSocketChannelConfig.java
index be4303b27f..800ec50a53 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IOUringSocketChannelConfig.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IOUringSocketChannelConfig.java
@@ -31,7 +31,7 @@ import java.util.Map;
 import static io.netty.channel.ChannelOption.*;
 
 
-final class IOUringSocketChannelConfig extends IOUringChannelConfig implements SocketChannelConfig {
+final class IOUringSocketChannelConfig extends IOUringStreamChannelConfig implements SocketChannelConfig {
     private volatile boolean allowHalfClosure;
     private volatile boolean tcpFastopen;
 
@@ -625,4 +625,5 @@ final class IOUringSocketChannelConfig extends IOUringChannelConfig implements S
         super.setMessageSizeEstimator(estimator);
         return this;
     }
+
 }
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IOUringStreamChannelConfig.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IOUringStreamChannelConfig.java
new file mode 100644
index 0000000000..43f104e893
--- /dev/null
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IOUringStreamChannelConfig.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.uring;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelOption;
+import io.netty.channel.RecvByteBufAllocator;
+import io.netty.util.internal.ObjectUtil;
+
+import java.util.Map;
+
+abstract class IOUringStreamChannelConfig extends IOUringChannelConfig {
+
+    static final short DISABLE_BUFFER_SELECT_READ = 0;
+
+    private volatile short bufferGroupId = DISABLE_BUFFER_SELECT_READ;
+
+    IOUringStreamChannelConfig(Channel channel) {
+        super(channel);
+    }
+
+    IOUringStreamChannelConfig(Channel channel, RecvByteBufAllocator allocator) {
+        super(channel, allocator);
+    }
+
+    @Override
+    public <T> T getOption(ChannelOption<T> option) {
+        if (option == IoUringChannelOption.IO_URING_BUFFER_GROUP_ID) {
+            return (T) Short.valueOf(getBufferRingConfig());
+        }
+        return super.getOption(option);
+    }
+
+    @Override
+    public <T> boolean setOption(ChannelOption<T> option, T value) {
+        if (option == IoUringChannelOption.IO_URING_BUFFER_GROUP_ID) {
+            setBufferGroupId((Short) value);
+            return true;
+        }
+        return super.setOption(option, value);
+    }
+
+    @Override
+    public Map<ChannelOption<?>, Object> getOptions() {
+        return getOptions(super.getOptions(), IoUringChannelOption.IO_URING_BUFFER_GROUP_ID);
+    }
+
+    /**
+     * Returns the buffer ring config.
+     *
+     * @return the buffer ring config.
+     */
+    short getBufferRingConfig() {
+        return bufferGroupId;
+    }
+
+    /**
+     * Set the buffer group id that will be used to select the correct ring buffer. This must have been configured
+     * via {@link IoUringBufferRingConfig}.
+     *
+     * @param bufferGroupId the buffer group id.
+     * @return              itself.
+     */
+    IOUringStreamChannelConfig setBufferGroupId(short bufferGroupId) {
+        this.bufferGroupId = (short) ObjectUtil.checkPositiveOrZero(bufferGroupId, "bufferGroupId");
+        return this;
+    }
+}
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java
index 17dc4fcd7a..bfbee7081f 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUring.java
@@ -31,6 +31,8 @@ public final class IoUring {
     private static final boolean IORING_SETUP_SUBMIT_ALL_SUPPORTED;
     private static final boolean IORING_SETUP_SINGLE_ISSUER_SUPPORTED;
     private static final boolean IORING_SETUP_DEFER_TASKRUN_SUPPORTED;
+    private static final boolean IO_URING_REGISTER_BUFFER_RING_SUPPORTED;
+
     private static final InternalLogger logger;
 
     static {
@@ -43,6 +45,7 @@ public final class IoUring {
         boolean submitAllSupported = false;
         boolean singleIssuerSupported = false;
         boolean deferTaskrunSupported = false;
+        boolean registerBufferRingSupported = false;
         try {
             if (SystemPropertyUtil.getBoolean("io.netty.transport.noNative", false)) {
                 cause = new UnsupportedOperationException(
@@ -67,6 +70,7 @@ public final class IoUring {
                         // See https://manpages.debian.org/unstable/liburing-dev/io_uring_setup.2.en.html
                         deferTaskrunSupported = Native.ioUringSetupSupportsFlags(
                                 Native.IORING_SETUP_SINGLE_ISSUER | Native.IORING_SETUP_DEFER_TASKRUN);
+                        registerBufferRingSupported = Native.isRegisterBufferRingSupported(ringBuffer.fd());
                     } finally {
                         if (ringBuffer != null) {
                             try {
@@ -98,9 +102,11 @@ public final class IoUring {
                         "IORING_REGISTER_IOWQ_MAX_WORKERS_SUPPORTED={}, " +
                         "IORING_SETUP_SUBMIT_ALL_SUPPORTED={}, " +
                         "IORING_SETUP_SINGLE_ISSUER_SUPPORTED={}, " +
-                        "IORING_SETUP_DEFER_TASKRUN_SUPPORTED={}" +
+                        "IORING_SETUP_DEFER_TASKRUN_SUPPORTED={}, " +
+                        "IO_URING_REGISTER_BUFFER_RING_SUPPORTED={}" +
                         ")", socketNonEmptySupported, spliceSupported, acceptSupportNoWait,
-                        registerIowqWorkersSupported, submitAllSupported, singleIssuerSupported, deferTaskrunSupported);
+                        registerIowqWorkersSupported, submitAllSupported, singleIssuerSupported,
+                        deferTaskrunSupported, registerBufferRingSupported);
             }
         }
         UNAVAILABILITY_CAUSE = cause;
@@ -111,6 +117,7 @@ public final class IoUring {
         IORING_SETUP_SUBMIT_ALL_SUPPORTED = submitAllSupported;
         IORING_SETUP_SINGLE_ISSUER_SUPPORTED = singleIssuerSupported;
         IORING_SETUP_DEFER_TASKRUN_SUPPORTED = deferTaskrunSupported;
+        IO_URING_REGISTER_BUFFER_RING_SUPPORTED = registerBufferRingSupported;
     }
 
     public static boolean isAvailable() {
@@ -165,6 +172,10 @@ public final class IoUring {
         return IORING_SETUP_DEFER_TASKRUN_SUPPORTED;
     }
 
+    public static boolean isRegisterBufferRingSupported() {
+        return IO_URING_REGISTER_BUFFER_RING_SUPPORTED;
+    }
+
     public static void ensureAvailability() {
         if (UNAVAILABILITY_CAUSE != null) {
             throw (Error) new UnsatisfiedLinkError(
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java
new file mode 100644
index 0000000000..ffdcd17c69
--- /dev/null
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRing.java
@@ -0,0 +1,463 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.uring;
+
+import io.netty.buffer.AbstractReferenceCountedByteBuf;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.util.internal.PlatformDependent;
+import io.netty.util.internal.SystemPropertyUtil;
+import io.netty.util.internal.logging.InternalLogger;
+import io.netty.util.internal.logging.InternalLoggerFactory;
+
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.nio.ByteBuffer;
+import java.nio.ByteOrder;
+import java.nio.channels.FileChannel;
+import java.nio.channels.GatheringByteChannel;
+import java.nio.channels.ScatteringByteChannel;
+
+final class IoUringBufferRing {
+    private static final InternalLogger logger = InternalLoggerFactory.getInstance(IoUringBufferRing.class);
+    // todo 8 doesn't have any particular meaning. It's just my intuition.
+    // Maybe we can find a more appropriate value.
+    private static final int BATCH_ALLOCATE_SIZE =
+            SystemPropertyUtil.getInt("io.netty.iouring.bufferRing.allocate.batch.size", 8);
+
+    private final long ioUringBufRingAddr;
+    private final short entries;
+    private final short mask;
+    private final short bufferGroupId;
+    private final int ringFd;
+    private final ByteBuf[] userspaceBufferHolder;
+    private final int chunkSize;
+    private final IoUringIoHandler source;
+    private final ByteBufAllocator byteBufAllocator;
+    private final IoUringBufferRingExhaustedEvent exhaustedEvent;
+
+    private short nextIndex;
+    private boolean hasSpareBuffer;
+
+    IoUringBufferRing(int ringFd, long ioUringBufRingAddr,
+                      short entries, short bufferGroupId,
+                      int chunkSize, IoUringIoHandler ioUringIoHandler,
+                      ByteBufAllocator byteBufAllocator) {
+        assert entries % 2 == 0;
+        this.ioUringBufRingAddr = ioUringBufRingAddr;
+        this.entries = entries;
+        this.mask = (short) (entries - 1);
+        this.bufferGroupId = bufferGroupId;
+        this.ringFd = ringFd;
+        this.userspaceBufferHolder = new ByteBuf[entries];
+        this.chunkSize = chunkSize;
+        this.source = ioUringIoHandler;
+        this.byteBufAllocator = byteBufAllocator;
+        this.exhaustedEvent = new IoUringBufferRingExhaustedEvent(bufferGroupId);
+    }
+
+    void markReadFail() {
+        hasSpareBuffer = false;
+    }
+
+    boolean hasSpareBuffer() {
+        return hasSpareBuffer;
+    }
+
+    /**
+     * @return a BufferRingExhaustedEvent Instance
+     */
+    IoUringBufferRingExhaustedEvent getExhaustedEvent() {
+        return exhaustedEvent;
+    }
+
+    void addToRing(short bid, boolean needAdvance) {
+        ByteBuf byteBuf = userspaceBufferHolder[bid];
+
+        long tailFieldAddress = ioUringBufRingAddr + Native.IO_URING_BUFFER_RING_TAIL;
+        short oldTail = PlatformDependent.getShort(tailFieldAddress);
+        int ringIndex = oldTail & mask;
+        //  see:
+        //  https://github.com/axboe/liburing/blob/19134a8fffd406b22595a5813a3e319c19630ac9/src/include/liburing.h#L1561
+        long ioUringBufAddress = ioUringBufRingAddr + (long) Native.SIZEOF_IOURING_BUF * ringIndex;
+        PlatformDependent.putLong(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_ADDR, byteBuf.memoryAddress());
+        PlatformDependent.putInt(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_LEN, (short) byteBuf.capacity());
+        PlatformDependent.putShort(ioUringBufAddress + Native.IOURING_BUFFER_OFFSETOF_BID, bid);
+        if (needAdvance) {
+            advanceTail(1);
+        }
+    }
+
+    void appendBuffer(int count) {
+        int expectedIndex = nextIndex + count;
+        if (expectedIndex > entries) {
+            throw new IllegalStateException(
+                    String.format(
+                            "We want append %d buffer, but buffer ring is full. The ring hold %s buffers",
+                            count, entries)
+            );
+        }
+
+        int batchAllocateCount = count / BATCH_ALLOCATE_SIZE;
+        initBuffers(batchAllocateCount, BATCH_ALLOCATE_SIZE);
+        int countRemain = count % BATCH_ALLOCATE_SIZE;
+        if (countRemain != 0) {
+            initBuffers(countRemain, countRemain);
+        }
+
+        advanceTail(count);
+    }
+
+    private void initBuffers(int numBuffers, int multiplier) {
+        ByteBuf bigChunk = byteBufAllocator.ioBuffer(multiplier * chunkSize);
+        for (int j = 0; j < numBuffers; j++) {
+            ByteBuf byteBuf = bigChunk.retainedSlice(j * chunkSize, chunkSize);
+            short bid = nextIndex;
+            userspaceBufferHolder[bid] = byteBuf;
+            addToRing(bid, false);
+            nextIndex++;
+        }
+        bigChunk.release();
+    }
+
+    ByteBuf borrowBuffer(int bid, int maxCap) {
+        ByteBuf byteBuf = userspaceBufferHolder[bid];
+        ByteBuf slice = byteBuf.retainedSlice(0, maxCap);
+        return new UserspaceIoUringBuffer(this, (short) bid, slice);
+    }
+
+    private void advanceTail(int count) {
+        long tailFieldAddress = ioUringBufRingAddr + Native.IO_URING_BUFFER_RING_TAIL;
+        short oldTail = PlatformDependent.getShort(tailFieldAddress);
+        short newTail = (short) (oldTail + count);
+        PlatformDependent.putShortOrdered(tailFieldAddress, newTail);
+        hasSpareBuffer = true;
+    }
+
+    int entries() {
+        return entries;
+    }
+
+    short bufferGroupId() {
+        return bufferGroupId;
+    }
+
+    int chunkSize() {
+        return chunkSize;
+    }
+
+    boolean isFull() {
+        return nextIndex == entries;
+    }
+
+    long address() {
+        return ioUringBufRingAddr;
+    }
+
+    void close() {
+        Native.ioUringUnRegisterBufRing(ringFd, ioUringBufRingAddr, entries, bufferGroupId);
+        for (ByteBuf byteBuf : userspaceBufferHolder) {
+            if (byteBuf != null) {
+                byteBuf.release();
+            }
+        }
+    }
+
+    static final class UserspaceIoUringBuffer extends AbstractReferenceCountedByteBuf implements Runnable {
+        private final IoUringBufferRing ring;
+        private final short bid;
+        private final ByteBuf userspaceBuffer;
+
+        UserspaceIoUringBuffer(IoUringBufferRing ring, short bid, ByteBuf userspaceBuffer) {
+            super(userspaceBuffer.capacity());
+            this.ring = ring;
+            this.bid = bid;
+            this.userspaceBuffer = userspaceBuffer;
+        }
+
+        @Override
+        protected void deallocate() {
+            // Hand of to the IoExecutorThread to release and recycle.
+            // As we already need to schedule it to the IoExecutorThread we will also just call release there
+            // to reduce overhead. We can't reuse the buffer anyway till it was added back to the ring.
+            ring.source.runInExecutorThread(this);
+        }
+
+        @Override
+        public void run() {
+            try {
+                userspaceBuffer.release();
+                ring.addToRing(bid, true);
+            } catch (Throwable t) {
+                logger.error("Failed to recycle buffer for bid " + bid, t);
+            }
+        }
+
+        @Override
+        protected byte _getByte(int index) {
+            return userspaceBuffer.getByte(index);
+        }
+
+        @Override
+        protected short _getShort(int index) {
+            return userspaceBuffer.getShort(index);
+        }
+
+        @Override
+        protected short _getShortLE(int index) {
+            return userspaceBuffer.getShortLE(index);
+        }
+
+        @Override
+        protected int _getUnsignedMedium(int index) {
+            return userspaceBuffer.getUnsignedMedium(index);
+        }
+
+        @Override
+        protected int _getUnsignedMediumLE(int index) {
+            return userspaceBuffer.getUnsignedMediumLE(index);
+        }
+
+        @Override
+        protected int _getInt(int index) {
+            return userspaceBuffer.getInt(index);
+        }
+
+        @Override
+        protected int _getIntLE(int index) {
+            return userspaceBuffer.getIntLE(index);
+        }
+
+        @Override
+        protected long _getLong(int index) {
+            return userspaceBuffer.getLong(index);
+        }
+
+        @Override
+        protected long _getLongLE(int index) {
+            return userspaceBuffer.getLongLE(index);
+        }
+
+        @Override
+        protected void _setByte(int index, int value) {
+            userspaceBuffer.setByte(index, value);
+        }
+
+        @Override
+        protected void _setShort(int index, int value) {
+            userspaceBuffer.setShort(index, value);
+        }
+
+        @Override
+        protected void _setShortLE(int index, int value) {
+            userspaceBuffer.setShortLE(index, value);
+        }
+
+        @Override
+        protected void _setMedium(int index, int value) {
+            userspaceBuffer.setMedium(index, value);
+        }
+
+        @Override
+        protected void _setMediumLE(int index, int value) {
+            userspaceBuffer.setMediumLE(index, value);
+        }
+
+        @Override
+        protected void _setInt(int index, int value) {
+            userspaceBuffer.setInt(index, value);
+        }
+
+        @Override
+        protected void _setIntLE(int index, int value) {
+            userspaceBuffer.setIntLE(index, value);
+        }
+
+        @Override
+        protected void _setLong(int index, long value) {
+            userspaceBuffer.setLong(index, value);
+        }
+
+        @Override
+        protected void _setLongLE(int index, long value) {
+            userspaceBuffer.setLongLE(index, value);
+        }
+
+        @Override
+        public int capacity() {
+            return maxCapacity();
+        }
+
+        @Override
+        public ByteBuf capacity(int newCapacity) {
+            if (newCapacity <= maxCapacity()) {
+                this.maxCapacity(newCapacity);
+                setIndex(Math.min(readerIndex(), newCapacity), Math.min(writerIndex(), newCapacity));
+                return this;
+            }
+
+            throw new IllegalArgumentException(
+                    String.format(
+                        "minNewCapacity: %d (expected: not greater than maxCapacity(%d)",
+                        newCapacity, maxCapacity()
+                    )
+            );
+        }
+
+        @Override
+        public ByteBufAllocator alloc() {
+            return userspaceBuffer.alloc();
+        }
+
+        @Override
+        public ByteOrder order() {
+            return userspaceBuffer.order();
+        }
+
+        @Override
+        public ByteBuf unwrap() {
+            return null;
+        }
+
+        @Override
+        public boolean isDirect() {
+            return userspaceBuffer.isDirect();
+        }
+
+        @Override
+        public ByteBuf getBytes(int index, ByteBuf dst, int dstIndex, int length) {
+            checkIndex(index, length);
+            userspaceBuffer.getBytes(index, dst, dstIndex, length);
+            return this;
+        }
+
+        @Override
+        public ByteBuf getBytes(int index, byte[] dst, int dstIndex, int length) {
+            checkIndex(index, length);
+            userspaceBuffer.getBytes(index, dst, dstIndex, length);
+            return this;
+        }
+
+        @Override
+        public ByteBuf getBytes(int index, ByteBuffer dst) {
+            checkIndex(index, dst.remaining());
+            userspaceBuffer.getBytes(index, dst);
+            return this;
+        }
+
+        @Override
+        public ByteBuf getBytes(int index, OutputStream out, int length)
+                throws IOException {
+            checkIndex(index, length);
+            userspaceBuffer.getBytes(index, out, length);
+            return this;
+        }
+
+        @Override
+        public int getBytes(int index, GatheringByteChannel out, int length) throws IOException {
+            return userspaceBuffer.getBytes(index, out, length);
+        }
+
+        @Override
+        public int getBytes(int index, FileChannel out, long position, int length) throws IOException {
+            return userspaceBuffer.getBytes(index, out, position, length);
+        }
+
+        @Override
+        public ByteBuf setBytes(int index, ByteBuf src, int srcIndex, int length) {
+            userspaceBuffer.setBytes(index, src, srcIndex, length);
+            return this;
+        }
+
+        @Override
+        public ByteBuf setBytes(int index, byte[] src, int srcIndex, int length) {
+            userspaceBuffer.setBytes(index, src, srcIndex, length);
+            return this;
+        }
+
+        @Override
+        public ByteBuf setBytes(int index, ByteBuffer src) {
+            userspaceBuffer.setBytes(index, src);
+            return this;
+        }
+
+        @Override
+        public int setBytes(int index, InputStream in, int length) throws IOException {
+            return userspaceBuffer.setBytes(index, in, length);
+        }
+
+        @Override
+        public int setBytes(int index, ScatteringByteChannel in, int length) throws IOException {
+            return userspaceBuffer.setBytes(index, in, length);
+        }
+
+        @Override
+        public int setBytes(int index, FileChannel in, long position, int length) throws IOException {
+            return userspaceBuffer.setBytes(index, in, position, length);
+        }
+
+        @Override
+        public ByteBuf copy(int index, int length) {
+            return userspaceBuffer.copy(index, length);
+        }
+
+        @Override
+        public int nioBufferCount() {
+            return userspaceBuffer.nioBufferCount();
+        }
+
+        @Override
+        public ByteBuffer nioBuffer(int index, int length) {
+            return userspaceBuffer.nioBuffer(index, length);
+        }
+
+        @Override
+        public ByteBuffer internalNioBuffer(int index, int length) {
+            return userspaceBuffer.internalNioBuffer(index, length);
+        }
+
+        @Override
+        public ByteBuffer[] nioBuffers(int index, int length) {
+            return userspaceBuffer.nioBuffers(index, length);
+        }
+
+        @Override
+        public boolean hasArray() {
+            return userspaceBuffer.hasArray();
+        }
+
+        @Override
+        public byte[] array() {
+            return userspaceBuffer.array();
+        }
+
+        @Override
+        public int arrayOffset() {
+            return userspaceBuffer.arrayOffset();
+        }
+
+        @Override
+        public boolean hasMemoryAddress() {
+            return userspaceBuffer.hasMemoryAddress();
+        }
+
+        @Override
+        public long memoryAddress() {
+            return userspaceBuffer.memoryAddress();
+        }
+    }
+}
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingConfig.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingConfig.java
new file mode 100644
index 0000000000..dc7f325397
--- /dev/null
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingConfig.java
@@ -0,0 +1,132 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.uring;
+
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.util.internal.ObjectUtil;
+
+/**
+ * Configuration class for an {@link IoUringBufferRing}.
+ * It will configure the buffer ring size, buffer group id and the chunk size.
+ */
+public final class IoUringBufferRingConfig {
+
+    private final short bgId;
+    private final short bufferRingSize;
+    private final int chunkSize;
+    private final ByteBufAllocator allocator;
+    private final int initSize;
+
+    /**
+     * Create a new configuration.
+     *
+     * @param bgId              the buffer group id to use.
+     * @param bufferRingSize    the size of the ring
+     * @param chunkSize         the chunk size of each {@link io.netty.buffer.ByteBuf} that is allocated out of the
+     *                          {@link ByteBufAllocator} to fill the ring.
+     * @param allocator         the {@link ByteBufAllocator} to use to allocate {@link io.netty.buffer.ByteBuf}s.
+     */
+    public IoUringBufferRingConfig(short bgId, short bufferRingSize, int chunkSize, ByteBufAllocator allocator) {
+        this(bgId, bufferRingSize, chunkSize, allocator, 0);
+    }
+
+    /**
+     * Create a new configuration.
+     *
+     * @param bgId              the buffer group id to use.
+     * @param bufferRingSize    the size of the ring
+     * @param chunkSize         the chunk size of each {@link io.netty.buffer.ByteBuf} that is allocated out of the
+     *                          {@link ByteBufAllocator} to fill the ring.
+     * @param allocator         the {@link ByteBufAllocator} to use to allocate {@link io.netty.buffer.ByteBuf}s.
+     * @param initSize          the number of buffers that are created during initialization.
+     */
+    public IoUringBufferRingConfig(short bgId, short bufferRingSize, int chunkSize,
+                                   ByteBufAllocator allocator, int initSize) {
+        this.bgId = ObjectUtil.checkPositive(bgId, "bgId");
+        this.bufferRingSize = checkBufferRingSize(bufferRingSize);
+        this.chunkSize = ObjectUtil.checkPositive(chunkSize, "chunkSize");
+        this.allocator = ObjectUtil.checkNotNull(allocator, "allocator");
+        this.initSize = checkInitSize(initSize, bufferRingSize);
+    }
+
+    /**
+     * Returns the buffer group id to use.
+     *
+     * @return the buffer group id to use.
+     */
+    public short bufferGroupId() {
+        return bgId;
+    }
+
+    /**
+     * Returns the size of the ring.
+     *
+     * @return the size of the ring.
+     */
+    public short bufferRingSize() {
+        return bufferRingSize;
+    }
+
+    /**
+     * Returns the chunk size of each {@link io.netty.buffer.ByteBuf} that is allocated out of the
+     * {@link ByteBufAllocator} to fill the ring.
+     *
+     * @return  the chunksize.
+     */
+    public int chunkSize() {
+        return chunkSize;
+    }
+
+    /**
+     * Returns the {@link ByteBufAllocator} to use to allocate {@link io.netty.buffer.ByteBuf}s.
+     *
+     * @return  the allocator.
+     */
+    public ByteBufAllocator allocator() {
+        return allocator;
+    }
+
+    /**
+     * Returns the number of buffers that are created during initialization.
+     *
+     * @return  init size.
+     */
+    public int initSize() {
+        return initSize;
+    }
+
+    private static short checkBufferRingSize(short bufferRingSize) {
+        if (bufferRingSize < 1) {
+            throw new IllegalArgumentException("bufferRingSize: " + bufferRingSize + " (expected: > 0)");
+        }
+
+        boolean isPowerOfTwo = (bufferRingSize & (bufferRingSize - 1)) == 0;
+        if (!isPowerOfTwo) {
+            throw new IllegalArgumentException("bufferRingSize: " + bufferRingSize + " (expected: power of 2)");
+        }
+        return bufferRingSize;
+    }
+
+    private static int checkInitSize(int initSize, short bufferRingSize) {
+        ObjectUtil.checkPositiveOrZero(initSize, "initSize");
+        if (initSize > bufferRingSize) {
+            throw new IllegalArgumentException(
+                    "initSize: " + initSize + " (expected: <= bufferRingSize: " + bufferRingSize + ')'
+            );
+        }
+        return initSize;
+    }
+}
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingExhaustedEvent.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingExhaustedEvent.java
new file mode 100644
index 0000000000..eaa54b6a79
--- /dev/null
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringBufferRingExhaustedEvent.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.uring;
+
+/**
+ * Event that is fired when a cqe`s res is NO_BUFFER
+ */
+public final class IoUringBufferRingExhaustedEvent {
+    private final short bufferGroupId;
+
+    IoUringBufferRingExhaustedEvent(short bufferGroupId) {
+        this.bufferGroupId = bufferGroupId;
+    }
+
+    public short bufferGroupId() {
+        return bufferGroupId;
+    }
+
+    @Override
+    public String toString() {
+        return "BufferRingExhaustedEvent{" +
+               "bufferGroupId=" + bufferGroupId +
+               '}';
+    }
+
+    @Override
+    public int hashCode() {
+        return Short.hashCode(bufferGroupId);
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (obj instanceof IoUringBufferRingExhaustedEvent) {
+            return bufferGroupId == ((IoUringBufferRingExhaustedEvent) obj).bufferGroupId;
+        }
+        return false;
+    }
+}
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringChannelOption.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringChannelOption.java
index 599edfca41..3a04c48ed4 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringChannelOption.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringChannelOption.java
@@ -58,4 +58,16 @@ public final class IoUringChannelOption<T> extends UnixChannelOption<T> {
      * Use {@code IOSQE_ASYNC} when submitting {@link IoUringIoOps}.
      */
     public static final ChannelOption<Boolean> IOSQE_ASYNC = valueOf("IOSQE_ASYNC");
+
+    /**
+     * The buffer group id to use when submitting recv / read / readv {@link IoUringIoOps}.
+     * If it is set to {@code 0}, then this function will be disabled.
+     * <p>
+     * Check
+     * <a href="https://man7.org/linux/man-pages/man3/io_uring_setup_buf_ring.3.html"> man io_uring_setup_buf_ring</a>
+     * an this <a href="https://lwn.net/Articles/815491/">LWN article</a> for more details.
+     */
+    public static final ChannelOption<Short> IO_URING_BUFFER_GROUP_ID =
+            ChannelOption.valueOf(IoUringChannelOption.class, "IOURING_BUFFER_GROUP_ID");
+
 }
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandler.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandler.java
index f5c17266f0..948d3cd843 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandler.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandler.java
@@ -54,6 +54,7 @@ public final class IoUringIoHandler implements IoHandler {
     private static final short RING_CLOSE = 1;
 
     private final RingBuffer ringBuffer;
+    private final IntObjectMap<IoUringBufferRing> registeredIoUringBufferRing;
     private final IntObjectMap<DefaultIoUringIoRegistration> registrations;
     // The maximum number of bytes for an InetAddress / Inet6Address
     private final byte[] inet4AddressArray = new byte[SockaddrIn.IPV4_ADDRESS_LENGTH];
@@ -99,6 +100,30 @@ public final class IoUringIoHandler implements IoHandler {
                 throw new UncheckedIOException(Errors.newIOException("io_uring_register", result));
             }
         }
+
+        registeredIoUringBufferRing = new IntObjectHashMap<>();
+        List<IoUringBufferRingConfig> bufferRingConfigs = config.getInternBufferRingConfigs();
+        if (!bufferRingConfigs.isEmpty()) {
+            if (!IoUring.isRegisterBufferRingSupported()) {
+                // Close ringBuffer before throwing to ensure we release all memory on failure.
+                ringBuffer.close();
+                throw new UnsupportedOperationException("IORING_REGISTER_PBUF_RING is not supported");
+            }
+            for (IoUringBufferRingConfig bufferRingConfig : bufferRingConfigs) {
+                try {
+                    IoUringBufferRing ring = newBufferRing(bufferRingConfig);
+                    registeredIoUringBufferRing.put(bufferRingConfig.bufferGroupId(), ring);
+                } catch (Errors.NativeIoException e) {
+                    for (IoUringBufferRing bufferRing : registeredIoUringBufferRing.values()) {
+                        bufferRing.close();
+                    }
+                    // Close ringBuffer before throwing to ensure we release all memory on failure.
+                    ringBuffer.close();
+                    throw new UncheckedIOException(e);
+                }
+            }
+        }
+
         registrations = new IntObjectHashMap<>();
         eventfd = Native.newBlockingEventFd();
         eventfdReadBuf = PlatformDependent.allocateMemory(8);
@@ -154,6 +179,49 @@ public final class IoUringIoHandler implements IoHandler {
         }
     }
 
+    void runInExecutorThread(Runnable runnable) {
+        //if we are in the executor thread we can run the runnable directly
+        if (executor.inExecutorThread(Thread.currentThread())) {
+            // Just directly run.
+            runnable.run();
+        } else {
+            // This will also wakeup the blocked run(...) method if needed.
+            executor.execute(runnable);
+        }
+    }
+
+    IoUringBufferRing newBufferRing(IoUringBufferRingConfig bufferRingConfig) throws Errors.NativeIoException {
+        int ringFd = ringBuffer.fd();
+        short bufferRingSize = bufferRingConfig.bufferRingSize();
+        short bufferGroupId = bufferRingConfig.bufferGroupId();
+        int chunkSize = bufferRingConfig.chunkSize();
+        long ioUringBufRingAddr = Native.ioUringRegisterBuffRing(ringFd, bufferRingSize, bufferGroupId, 0);
+        if (ioUringBufRingAddr < 0) {
+            throw Errors.newIOException("ioUringRegisterBuffRing", (int) ioUringBufRingAddr);
+        }
+        IoUringBufferRing ioUringBufferRing = new IoUringBufferRing(
+                ringFd, ioUringBufRingAddr,
+                bufferRingSize, bufferGroupId, chunkSize,
+                this, bufferRingConfig.allocator()
+        );
+
+        if (bufferRingConfig.initSize() != 0) {
+            ioUringBufferRing.appendBuffer(bufferRingConfig.initSize());
+        }
+
+        return ioUringBufferRing;
+    }
+
+    IoUringBufferRing findBufferRing(short bgId) {
+        IoUringBufferRing cached = registeredIoUringBufferRing.get(bgId);
+        if (cached != null) {
+            return cached;
+        }
+        throw new IllegalArgumentException(
+                String.format("Cant find bgId:%d, please register it in ioUringIoHandler", bgId)
+        );
+    }
+
     private int drainAndProcessAll(CompletionQueue completionQueue, CompletionCallback callback) {
         int processed = 0;
         for (;;) {
@@ -304,6 +372,9 @@ public final class IoUringIoHandler implements IoHandler {
         // ... but only wait for 200 milliseconds on this
         submitAndWaitWithTimeout(submissionQueue, true, TimeUnit.MILLISECONDS.toNanos(200));
         completionQueue.process(this::handle);
+        for (IoUringBufferRing ioUringBufferRing : registeredIoUringBufferRing.values()) {
+            ioUringBufferRing.close();
+        }
         completeRingClose();
     }
 
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandlerConfig.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandlerConfig.java
index 97f613d9f1..eed1512a8e 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandlerConfig.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoHandlerConfig.java
@@ -17,6 +17,9 @@ package io.netty.channel.uring;
 
 import io.netty.util.internal.ObjectUtil;
 
+import java.util.ArrayList;
+import java.util.List;
+
 /**
  * Configuration class for an {@link IoUringIoHandler},
  * managing the settings for a {@link RingBuffer} and its io_uring file descriptor.
@@ -50,6 +53,13 @@ import io.netty.util.internal.ObjectUtil;
  *       <td>{@link IoUringIoHandlerConfig#setMaxUnboundedWorker}</td>
  *       <td>Defines the maximum number of unbounded io_uring worker threads.</td>
  *     </tr>
+ *     <tr>
+ *       <td>{@link IoUringIoHandlerConfig#addBufferRingConfig}</td>
+ *       <td>
+ *         Adds a buffer ring configuration to the list of buffer ring configurations.
+ *         It will be used to register the buffer ring for the io_uring instance.
+ *       </td>
+ *     </tr>
  *   </tbody>
  * </table>
  */
@@ -61,6 +71,8 @@ public final class IoUringIoHandlerConfig {
 
     private int maxUnboundedWorker;
 
+    private final List<IoUringBufferRingConfig> bufferRingConfigs = new ArrayList<>(0);
+
     /**
      * Return the ring size of the io_uring instance.
      * @return the ring size of the io_uring instance.
@@ -117,7 +129,36 @@ public final class IoUringIoHandlerConfig {
         return this;
     }
 
+    /**
+     * Add a buffer ring configuration to the list of buffer ring configurations.
+     * Each {@link IoUringBufferRingConfig} must have a different {@link IoUringBufferRingConfig#bufferGroupId()}.
+     *
+     * @param ringConfig the buffer ring configuration to append.
+     * @return reference to this, so the API can be used fluently
+     */
+    public IoUringIoHandlerConfig addBufferRingConfig(IoUringBufferRingConfig ringConfig) {
+        for (IoUringBufferRingConfig bufferRingConfig : bufferRingConfigs) {
+            if (bufferRingConfig.bufferGroupId() == ringConfig.bufferGroupId()) {
+                throw new IllegalArgumentException("Duplicated buffer group id: " + ringConfig.bufferGroupId());
+            }
+        }
+        bufferRingConfigs.add(ringConfig);
+        return this;
+    }
+
+    /**
+     * Get the list of buffer ring configurations.
+     * @return the copy of buffer ring configurations.
+     */
+    public List<IoUringBufferRingConfig> getBufferRingConfigs() {
+        return new ArrayList<>(bufferRingConfigs);
+    }
+
     boolean needRegisterIowqMaxWorker() {
         return maxBoundedWorker > 0 || maxUnboundedWorker > 0;
     }
+
+    List<IoUringBufferRingConfig> getInternBufferRingConfigs() {
+        return bufferRingConfigs;
+    }
 }
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoOps.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoOps.java
index 97a41b8aa6..b64b3eb7c7 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoOps.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/IoUringIoOps.java
@@ -379,9 +379,14 @@ public final class IoUringIoOps implements IoOps {
      */
     static IoUringIoOps newRecv(
             int fd, byte flags, short ioPrio, int recvFlags, long memoryAddress, int length, short data) {
+        return newRecv(fd, flags, ioPrio, recvFlags, memoryAddress, length, data, (short) 0);
+    }
+
+    static IoUringIoOps newRecv(
+            int fd, byte flags, short ioPrio, int recvFlags, long memoryAddress, int length, short data, short bid) {
         // See https://github.com/axboe/liburing/blob/liburing-2.8/src/include/liburing.h#L898
         return new IoUringIoOps(Native.IORING_OP_RECV, flags, ioPrio, fd,
-                0, memoryAddress, length, recvFlags, data, (short) 0, (short) 0, 0, 0);
+                0, memoryAddress, length, recvFlags, data, bid, (short) 0, 0, 0);
     }
 
     /**
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/Native.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/Native.java
index 2e91958a3f..6401465917 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/Native.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/Native.java
@@ -115,6 +115,8 @@ final class Native {
     static final int CMSG_OFFSETOF_CMSG_LEVEL = NativeStaticallyReferencedJniMethods.cmsghdrOffsetofCmsgLevel();
     static final int CMSG_OFFSETOF_CMSG_TYPE = NativeStaticallyReferencedJniMethods.cmsghdrOffsetofCmsgType();
 
+    static final int IO_URING_BUFFER_RING_TAIL = NativeStaticallyReferencedJniMethods.ioUringBufferRingOffsetTail();
+
     static final int IOVEC_OFFSETOF_IOV_BASE = NativeStaticallyReferencedJniMethods.iovecOffsetofIovBase();
     static final int IOVEC_OFFSETOF_IOV_LEN = NativeStaticallyReferencedJniMethods.iovecOffsetofIovLen();
     static final int SIZEOF_MSGHDR = NativeStaticallyReferencedJniMethods.sizeofMsghdr();
@@ -131,6 +133,14 @@ final class Native {
     static final int POLLRDHUP = NativeStaticallyReferencedJniMethods.pollrdhup();
     static final int ERRNO_ECANCELED_NEGATIVE = -NativeStaticallyReferencedJniMethods.ecanceled();
     static final int ERRNO_ETIME_NEGATIVE = -NativeStaticallyReferencedJniMethods.etime();
+    static final int ERRNO_NO_BUFFER_NEGATIVE = -NativeStaticallyReferencedJniMethods.enobufs();
+
+    static final int PAGE_SIZE = NativeStaticallyReferencedJniMethods.pageSize();
+
+    static final int SIZEOF_IOURING_BUF = NativeStaticallyReferencedJniMethods.sizeofIoUringBuf();
+    static final int IOURING_BUFFER_OFFSETOF_ADDR = NativeStaticallyReferencedJniMethods.ioUringBufferOffsetAddr();
+    static final int IOURING_BUFFER_OFFSETOF_LEN = NativeStaticallyReferencedJniMethods.ioUringBufferOffsetLen();
+    static final int IOURING_BUFFER_OFFSETOF_BID = NativeStaticallyReferencedJniMethods.ioUringBufferOffsetBid();
 
     // These constants must be defined to have the same numeric value as their corresponding
     // ordinal in the enum defined in the io_uring.h header file.
@@ -198,6 +208,7 @@ final class Native {
     static final int IORING_SETUP_SUBMIT_ALL = 1 << 7;
     static final int IORING_SETUP_SINGLE_ISSUER = 1 << 12;
     static final int IORING_SETUP_DEFER_TASKRUN = 1 << 13;
+    static final int IORING_CQE_BUFFER_SHIFT = 16;
 
     static final short IORING_RECVSEND_POLL_FIRST = 1 << 0;
     static final short IORING_ACCEPT_DONTWAIT = 1 << 1;
@@ -256,6 +267,7 @@ final class Native {
     static final int IOSQE_ASYNC = NativeStaticallyReferencedJniMethods.iosqeAsync();
     static final int IOSQE_LINK = NativeStaticallyReferencedJniMethods.iosqeLink();
     static final int IOSQE_IO_DRAIN = NativeStaticallyReferencedJniMethods.iosqeDrain();
+    static final int IOSQE_BUFFER_SELECT = NativeStaticallyReferencedJniMethods.iosqeBufferSelect();
     static final int MSG_DONTWAIT = NativeStaticallyReferencedJniMethods.msgDontwait();
     static final int MSG_FASTOPEN = NativeStaticallyReferencedJniMethods.msgFastopen();
     static final int SOL_UDP = NativeStaticallyReferencedJniMethods.solUdp();
@@ -372,6 +384,16 @@ final class Native {
         return false;
     }
 
+    static boolean isRegisterBufferRingSupported(int ringFd) {
+        long result = ioUringRegisterBuffRing(ringFd, 2, (short) 1, 0);
+        if (result >= 0) {
+            ioUringUnRegisterBufRing(ringFd, result, 2, 1);
+            return true;
+        }
+        // This is not supported and so will return -EINVAL
+        return false;
+    }
+
     static void checkKernelVersion(String kernelVersion) {
         boolean enforceKernelVersion = SystemPropertyUtil.getBoolean(
                 "io.netty.transport.iouring.enforceKernelVersion", true);
@@ -424,6 +446,10 @@ final class Native {
     static native int ioUringRegisterIoWqMaxWorkers(int ringFd, int maxBoundedValue, int maxUnboundedValue);
     static native int ioUringRegisterEnableRings(int ringFd);
     static native int ioUringRegisterRingFds(int ringFds);
+
+    static native long ioUringRegisterBuffRing(int ringFd, int entries, short bufferGroup, int flags);
+    static native int ioUringUnRegisterBufRing(int ringFd, long ioUringBufRingAddr, int entries, int bufferGroupId);
+
     static native int ioUringEnter(int ringFd, int toSubmit, int minComplete, int flags);
 
     static native void eventFdWrite(int fd, long value);
diff --git a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/NativeStaticallyReferencedJniMethods.java b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/NativeStaticallyReferencedJniMethods.java
index f51fabab40..8c0fa2df70 100644
--- a/transport-classes-io_uring/src/main/java/io/netty/channel/uring/NativeStaticallyReferencedJniMethods.java
+++ b/transport-classes-io_uring/src/main/java/io/netty/channel/uring/NativeStaticallyReferencedJniMethods.java
@@ -36,6 +36,7 @@ final class NativeStaticallyReferencedJniMethods {
     static native int afInet6();
     static native int sizeofSockaddrIn();
     static native int sizeofSockaddrIn6();
+    static native int pageSize();
     static native int sockaddrInOffsetofSinFamily();
     static native int sockaddrInOffsetofSinPort();
     static native int sockaddrInOffsetofSinAddr();
@@ -61,6 +62,7 @@ final class NativeStaticallyReferencedJniMethods {
     static native int msghdrOffsetofMsgFlags();
     static native int etime();
     static native int ecanceled();
+    static native int enobufs();
     static native int pollin();
     static native int pollout();
     static native int pollrdhup();
@@ -69,6 +71,7 @@ final class NativeStaticallyReferencedJniMethods {
     static native int iosqeLink();
     static native int iosqeDrain();
     static native int msgDontwait();
+    static native int iosqeBufferSelect();
     static native int msgFastopen();
     static native int cmsgSpace();
     static native int cmsgLen();
@@ -77,5 +80,10 @@ final class NativeStaticallyReferencedJniMethods {
     static native int cmsghdrOffsetofCmsgLen();
     static native int cmsghdrOffsetofCmsgLevel();
     static native int cmsghdrOffsetofCmsgType();
+    static native int ioUringBufferRingOffsetTail();
+    static native int ioUringBufferOffsetAddr();
+    static native int ioUringBufferOffsetLen();
+    static native int ioUringBufferOffsetBid();
+    static native int sizeofIoUringBuf();
     static native int tcpFastopenMode();
 }
diff --git a/transport-native-io_uring/src/main/c/io_uring.h b/transport-native-io_uring/src/main/c/io_uring.h
index 2138c8df13..272eb2dfea 100644
--- a/transport-native-io_uring/src/main/c/io_uring.h
+++ b/transport-native-io_uring/src/main/c/io_uring.h
@@ -340,6 +340,10 @@ enum {
 	IORING_REGISTER_RING_FDS		= 20,
 	IORING_UNREGISTER_RING_FDS		= 21,
 
+	/* register ring based provide buffer group */
+	IORING_REGISTER_PBUF_RING		= 22,
+	IORING_UNREGISTER_PBUF_RING		= 23,
+
 	/* this goes last */
 	IORING_REGISTER_LAST
 };
diff --git a/transport-native-io_uring/src/main/c/netty_io_uring.h b/transport-native-io_uring/src/main/c/netty_io_uring.h
index 7834f0e788..b0a25faa5e 100644
--- a/transport-native-io_uring/src/main/c/netty_io_uring.h
+++ b/transport-native-io_uring/src/main/c/netty_io_uring.h
@@ -62,4 +62,35 @@ struct io_uring {
     int ring_fd;
 };
 
+struct io_uring_buf {
+	__u64	addr;
+	__u32	len;
+	__u16	bid;
+	__u16	resv;
+};
+
+struct io_uring_buf_reg {
+	__u64	ring_addr;
+	__u32	ring_entries;
+	__u16	bgid;
+	__u16	flags;
+	__u64	resv[3];
+};
+
+struct io_uring_buf_ring {
+	union {
+		/*
+		 * To avoid spilling into more pages than we need to, the
+		 * ring tail is overlaid with the io_uring_buf->resv field.
+		 */
+		struct {
+			__u64	resv1;
+			__u32	resv2;
+			__u16	resv3;
+			__u16	tail;
+		};
+		struct io_uring_buf	bufs[0];
+	};
+};
+
 #endif
diff --git a/transport-native-io_uring/src/main/c/netty_io_uring_native.c b/transport-native-io_uring/src/main/c/netty_io_uring_native.c
index e988a525c9..ff25ba686e 100644
--- a/transport-native-io_uring/src/main/c/netty_io_uring_native.c
+++ b/transport-native-io_uring/src/main/c/netty_io_uring_native.c
@@ -367,6 +367,48 @@ static jint netty_io_uring_register_ring_fds(JNIEnv *env, jclass clazz, jint rin
     return -1;
 }
 
+static jlong netty_io_uring_register_buf_ring(JNIEnv* env, jclass clazz,
+                                           int ringFd, unsigned int nentries,
+                                           short bgid, unsigned int flags) {
+    struct io_uring_buf_ring *br;
+    struct io_uring_buf_reg reg;
+    size_t ring_size;
+
+    memset(&reg, 0, sizeof(reg));
+    ring_size = nentries * sizeof(struct io_uring_buf);
+    br = mmap(NULL, ring_size, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
+    if (br == MAP_FAILED) {
+        return -errno;
+    }
+
+    reg.ring_addr = (__u64)br;
+    reg.ring_entries = nentries;
+    reg.bgid = bgid;
+    reg.flags |= flags;
+
+    int registerRes = sys_io_uring_register(ringFd, IORING_REGISTER_PBUF_RING, &reg, 1);
+
+    if (registerRes) {
+        munmap(br,ring_size);
+        return registerRes;
+    }
+    br->tail = 0;
+    return (jlong)br;
+}
+
+static jint netty_io_uring_unregister_buf_ring(JNIEnv* env, jclass clazz,
+                                        int ringFd, struct io_uring_buf_ring *br,
+                                        unsigned int nentries, int bgid) {
+    struct io_uring_buf_reg reg = { .bgid = bgid };
+    int registerRes = sys_io_uring_register(ringFd, IORING_UNREGISTER_PBUF_RING, &reg, 1);
+    if (registerRes) {
+        return registerRes;
+    }
+    size_t ring_size = nentries * sizeof(struct io_uring_buf);
+    munmap(br,ring_size);
+    return 0;
+}
+
 static jint netty_create_file(JNIEnv *env, jclass class, jstring filename) {
     const char *file = (*env)->GetStringUTFChars(env, filename, 0);
 
@@ -375,7 +417,6 @@ static jint netty_create_file(JNIEnv *env, jclass class, jstring filename) {
     return fd;
 }
 
-
 static jint netty_io_uring_registerUnix(JNIEnv* env, jclass clazz) {
     register_unix_called = 1;
     return netty_unix_register(env, staticPackagePrefix);
@@ -389,6 +430,10 @@ static jint netty_io_uring_sockCloexec(JNIEnv* env, jclass clazz) {
     return SOCK_CLOEXEC;
 }
 
+static jint netty_io_uring_pageSize(JNIEnv* env, jclass clazz) {
+    return getpagesize();
+}
+
 static jint netty_io_uring_afInet(JNIEnv* env, jclass clazz) {
     return AF_INET;
 }
@@ -511,6 +556,26 @@ static jlong netty_io_uring_cmsghdrData(JNIEnv* env, jclass clazz, jlong cmsghdr
     return (jlong) CMSG_DATA((struct cmsghdr*) cmsghdrAddr);
 }
 
+static jint netty_io_uring_ioUringBufRingOffsetoftail(JNIEnv* env, jclass clazz) {
+   return offsetof(struct io_uring_buf_ring, tail);
+}
+
+static jint netty_io_uring_ioUringBufOffsetofaddr(JNIEnv* env, jclass clazz) {
+   return offsetof(struct io_uring_buf, addr);
+}
+
+static jint netty_io_uring_ioUringBufOffsetoflen(JNIEnv* env, jclass clazz) {
+    return offsetof(struct io_uring_buf, len);
+}
+
+static jint netty_io_uring_ioUringBufOffsetofbid(JNIEnv* env, jclass clazz) {
+    return offsetof(struct io_uring_buf, bid);
+}
+
+static jint netty_io_uring_sizeofIoUringBuf(JNIEnv* env, jclass clazz) {
+    return sizeof(struct io_uring_buf);
+}
+
 static int getSysctlValue(const char * property, int* returnValue) {
     int rc = -1;
     FILE *fd=fopen(property, "r");
@@ -539,6 +604,10 @@ static jint netty_io_uring_ecanceled(JNIEnv* env, jclass clazz) {
     return ECANCELED;
 }
 
+static jint netty_io_uring_enobufs(JNIEnv* env, jclass clazz) {
+    return ENOBUFS;
+}
+
 static jint netty_io_uring_pollin(JNIEnv* env, jclass clazz) {
     return POLLIN;
 }
@@ -567,6 +636,10 @@ static jint netty_io_uring_iosqeDrain(JNIEnv* env, jclass clazz) {
     return IOSQE_IO_DRAIN;
 }
 
+static jint netty_io_uring_BufferSelect(JNIEnv* env, jclass clazz) {
+    return IOSQE_BUFFER_SELECT;
+}
+
 static jint netty_io_uring_msgDontwait(JNIEnv* env, jclass clazz) {
     return MSG_DONTWAIT;
 }
@@ -599,6 +672,7 @@ static const JNINativeMethod statically_referenced_fixed_method_table[] = {
   { "afInet6", "()I", (void *) netty_io_uring_afInet6 },
   { "sizeofSockaddrIn", "()I", (void *) netty_io_uring_sizeofSockaddrIn },
   { "sizeofSockaddrIn6", "()I", (void *) netty_io_uring_sizeofSockaddrIn6 },
+  { "pageSize", "()I", (void*) netty_io_uring_pageSize},
   { "sockaddrInOffsetofSinFamily", "()I", (void *) netty_io_uring_sockaddrInOffsetofSinFamily },
   { "sockaddrInOffsetofSinPort", "()I", (void *) netty_io_uring_sockaddrInOffsetofSinPort },
   { "sockaddrInOffsetofSinAddr", "()I", (void *) netty_io_uring_sockaddrInOffsetofSinAddr },
@@ -626,6 +700,7 @@ static const JNINativeMethod statically_referenced_fixed_method_table[] = {
   { "msghdrOffsetofMsgFlags", "()I", (void *) netty_io_uring_msghdrOffsetofMsgFlags },
   { "etime", "()I", (void *) netty_io_uring_etime },
   { "ecanceled", "()I", (void *) netty_io_uring_ecanceled },
+  { "enobufs", "()I", (void*) netty_io_uring_enobufs},
   { "pollin", "()I", (void *) netty_io_uring_pollin },
   { "pollout", "()I", (void *) netty_io_uring_pollout },
   { "pollrdhup", "()I", (void *) netty_io_uring_pollrdhup },
@@ -633,6 +708,7 @@ static const JNINativeMethod statically_referenced_fixed_method_table[] = {
   { "iosqeAsync", "()I", (void *) netty_io_uring_iosqeAsync },
   { "iosqeLink", "()I", (void *) netty_io_uring_iosqeLink },
   { "iosqeDrain", "()I", (void *) netty_io_uring_iosqeDrain },
+  { "iosqeBufferSelect", "()I", (void *) netty_io_uring_BufferSelect },
   { "msgDontwait", "()I", (void *) netty_io_uring_msgDontwait },
   { "msgFastopen", "()I", (void *) netty_io_uring_msgFastopen },
   { "solUdp", "()I", (void *) netty_io_uring_solUdp },
@@ -640,6 +716,11 @@ static const JNINativeMethod statically_referenced_fixed_method_table[] = {
   { "cmsghdrOffsetofCmsgLen", "()I", (void *) netty_io_uring_cmsghdrOffsetofCmsgLen },
   { "cmsghdrOffsetofCmsgLevel", "()I", (void *) netty_io_uring_cmsghdrOffsetofCmsgLevel },
   { "cmsghdrOffsetofCmsgType", "()I", (void *) netty_io_uring_cmsghdrOffsetofCmsgType },
+  { "ioUringBufferRingOffsetTail", "()I", (void *) netty_io_uring_ioUringBufRingOffsetoftail },
+  { "sizeofIoUringBuf", "()I", (void *) netty_io_uring_sizeofIoUringBuf },
+  { "ioUringBufferOffsetAddr", "()I", (void *) netty_io_uring_ioUringBufOffsetofaddr },
+  { "ioUringBufferOffsetLen", "()I", (void *) netty_io_uring_ioUringBufOffsetoflen },
+  { "ioUringBufferOffsetBid", "()I", (void *) netty_io_uring_ioUringBufOffsetofbid },
   { "tcpFastopenMode", "()I", (void *) netty_io_uring_tcpFastopenMode },
 };
 static const jint statically_referenced_fixed_method_table_size = sizeof(statically_referenced_fixed_method_table) / sizeof(statically_referenced_fixed_method_table[0]);
@@ -659,7 +740,9 @@ static const JNINativeMethod method_table[] = {
     {"registerUnix", "()I", (void *) netty_io_uring_registerUnix },
     {"cmsghdrData", "(J)J", (void *) netty_io_uring_cmsghdrData},
     {"kernelVersion", "()Ljava/lang/String;", (void *) netty_io_uring_kernel_version },
-    {"getFd0", "(Ljava/lang/Object;)I", (void *) netty_io_uring_getFd0 }
+    {"getFd0", "(Ljava/lang/Object;)I", (void *) netty_io_uring_getFd0 },
+    {"ioUringRegisterBuffRing", "(IISI)J", (void *) netty_io_uring_register_buf_ring},
+    {"ioUringUnRegisterBufRing", "(IJII)I", (void *) netty_io_uring_unregister_buf_ring}
 };
 static const jint method_table_size =
     sizeof(method_table) / sizeof(method_table[0]);
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringBufferRingTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringBufferRingTest.java
new file mode 100644
index 0000000000..85399ba7ed
--- /dev/null
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringBufferRingTest.java
@@ -0,0 +1,161 @@
+/*
+ * Copyright 2025 The Netty Project
+ *
+ * The Netty Project licenses this file to you under the Apache License,
+ * version 2.0 (the "License"); you may not use this file except in compliance
+ * with the License. You may obtain a copy of the License at:
+ *
+ *   https://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
+ * License for the specific language governing permissions and limitations
+ * under the License.
+ */
+package io.netty.channel.uring;
+
+import io.netty.bootstrap.Bootstrap;
+import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufAllocator;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelFuture;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.MultiThreadIoEventLoopGroup;
+import io.netty.util.NetUtil;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+
+import java.util.UUID;
+import java.util.concurrent.ArrayBlockingQueue;
+import java.util.concurrent.BlockingQueue;
+import java.util.concurrent.LinkedBlockingQueue;
+
+import static org.junit.jupiter.api.Assertions.assertEquals;
+import static org.junit.jupiter.api.Assertions.assertFalse;
+import static org.junit.jupiter.api.Assertions.assertInstanceOf;
+import static org.junit.jupiter.api.Assertions.assertTrue;
+import static org.junit.jupiter.api.Assumptions.assumeTrue;
+
+public class IoUringBufferRingTest {
+    @BeforeAll
+    public static void loadJNI() {
+        assumeTrue(IoUring.isAvailable());
+    }
+
+    @Test
+    public void testRegister() {
+        RingBuffer ringBuffer = Native.createRingBuffer(8, 0);
+        try {
+            int ringFd = ringBuffer.fd();
+            long ioUringBufRingAddr = Native.ioUringRegisterBuffRing(ringFd, 4, (short) 1, 0);
+            assumeTrue(
+                    ioUringBufRingAddr > 0,
+                    "ioUringSetupBufRing result must great than 0, but now result is " + ioUringBufRingAddr);
+            int freeRes = Native.ioUringUnRegisterBufRing(ringFd, ioUringBufRingAddr, 4, 1);
+            assertEquals(
+                    0,
+                    freeRes,
+                    "ioUringFreeBufRing result must be 0, but now result is " + freeRes
+            );
+        } finally {
+            ringBuffer.close();
+        }
+    }
+
+    @Test
+    public void testProviderBufferRead() throws InterruptedException {
+        final BlockingQueue<ByteBuf> bufferSyncer = new LinkedBlockingQueue<>();
+        IoUringIoHandlerConfig ioUringIoHandlerConfiguration = new IoUringIoHandlerConfig();
+        IoUringBufferRingConfig bufferRingConfig = new IoUringBufferRingConfig(
+                (short) 1, (short) 2, 1024, ByteBufAllocator.DEFAULT);
+        ioUringIoHandlerConfiguration.addBufferRingConfig(bufferRingConfig);
+
+        IoUringBufferRingConfig bufferRingConfig1 = new IoUringBufferRingConfig(
+                (short) 2, (short) 16,
+                1024, ByteBufAllocator.DEFAULT,
+                12
+        );
+        ioUringIoHandlerConfiguration.addBufferRingConfig(bufferRingConfig1);
+
+        MultiThreadIoEventLoopGroup group = new MultiThreadIoEventLoopGroup(1,
+                IoUringIoHandler.newFactory(ioUringIoHandlerConfiguration)
+        );
+        ServerBootstrap serverBootstrap = new ServerBootstrap();
+        serverBootstrap.channel(IoUringServerSocketChannel.class);
+
+        String randomString = UUID.randomUUID().toString();
+        int randomStringLength = randomString.length();
+
+        ArrayBlockingQueue<IoUringBufferRingExhaustedEvent> eventSyncer = new ArrayBlockingQueue<>(1);
+
+        Channel serverChannel = serverBootstrap.group(group)
+                .childHandler(new ChannelInboundHandlerAdapter() {
+                    @Override
+                    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+                        bufferSyncer.offer((ByteBuf) msg);
+                    }
+
+                    @Override
+                    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {
+                        if (evt instanceof IoUringBufferRingExhaustedEvent) {
+                            eventSyncer.add((IoUringBufferRingExhaustedEvent) evt);
+                        }
+                    }
+                })
+                .childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, bufferRingConfig.bufferGroupId())
+                .bind(NetUtil.LOCALHOST, 0)
+                .syncUninterruptibly().channel();
+
+        Bootstrap clientBoostrap = new Bootstrap();
+        clientBoostrap.group(group)
+                .channel(IoUringSocketChannel.class)
+                .handler(new ChannelInboundHandlerAdapter());
+        ChannelFuture channelFuture = clientBoostrap.connect(serverChannel.localAddress()).syncUninterruptibly();
+        assumeTrue(channelFuture.isSuccess());
+        Channel clientChannel = channelFuture.channel();
+
+        //is provider buffer read?
+        ByteBuf writeBuffer = Unpooled.directBuffer(randomStringLength);
+        ByteBufUtil.writeAscii(writeBuffer, randomString);
+        ByteBuf userspaceIoUringBufferElement1 = sendAndRecvMessage(clientChannel, writeBuffer, bufferSyncer);
+        assertInstanceOf(IoUringBufferRing.UserspaceIoUringBuffer.class, userspaceIoUringBufferElement1);
+        ByteBuf userspaceIoUringBufferElement2 = sendAndRecvMessage(clientChannel, writeBuffer, bufferSyncer);
+        assertInstanceOf(IoUringBufferRing.UserspaceIoUringBuffer.class, userspaceIoUringBufferElement2);
+        assertEquals(0, eventSyncer.size());
+
+        //now we run out of buffer ring buffer
+        ByteBuf readBuffer = sendAndRecvMessage(clientChannel, writeBuffer, bufferSyncer);
+        assertFalse(readBuffer instanceof IoUringBufferRing.UserspaceIoUringBuffer);
+        readBuffer.release();
+        assertEquals(1, eventSyncer.size());
+        assertEquals(bufferRingConfig.bufferGroupId(), eventSyncer.take().bufferGroupId());
+
+        //now we release the buffer ring buffer
+        userspaceIoUringBufferElement1.release();
+        readBuffer = sendAndRecvMessage(clientChannel, writeBuffer, bufferSyncer);
+        assertInstanceOf(IoUringBufferRing.UserspaceIoUringBuffer.class, readBuffer);
+
+        userspaceIoUringBufferElement2.release();
+        readBuffer.release();
+        writeBuffer.release();
+
+        serverChannel.close();
+        clientChannel.close();
+        group.shutdownGracefully();
+    }
+
+    private ByteBuf sendAndRecvMessage(Channel clientChannel, ByteBuf writeBuffer, BlockingQueue<ByteBuf> bufferSyncer)
+            throws InterruptedException {
+        //retain the buffer to assert
+        clientChannel.writeAndFlush(writeBuffer.retainedDuplicate()).sync();
+        ByteBuf readBuffer = bufferSyncer.take();
+        assertEquals(writeBuffer.readableBytes(), readBuffer.readableBytes());
+        assertTrue(ByteBufUtil.equals(writeBuffer, readBuffer));
+        return readBuffer;
+    }
+}
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketAutoReadTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketAutoReadTest.java
index 569865089f..8db52d6330 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketAutoReadTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketAutoReadTest.java
@@ -42,6 +42,9 @@ public class IoUringSocketAutoReadTest extends SocketAutoReadTest {
     protected void configure(ServerBootstrap sb, Bootstrap cb, ByteBufAllocator allocator) {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        // This test does not enalbe IoUringChannelOption.IO_URING_BUFFER_GROUP_ID as it will not work because
+        // We want to use a custom RecvBytBufAllocator that limit the number of bytes that we can read per read
+        // operation to 1.
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
     }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketChannelNotYetConnectedTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketChannelNotYetConnectedTest.java
index dc1b194242..f257cee9d1 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketChannelNotYetConnectedTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketChannelNotYetConnectedTest.java
@@ -41,5 +41,6 @@ public class IoUringSocketChannelNotYetConnectedTest extends SocketChannelNotYet
     protected void configure(Bootstrap cb, ByteBufAllocator allocator) {
         super.configure(cb, allocator);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConditionalWritabilityTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConditionalWritabilityTest.java
index fccf210439..3d8c14bdff 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConditionalWritabilityTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConditionalWritabilityTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketConditionalWritabilityTest extends SocketConditionalWr
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConnectTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConnectTest.java
index a01a1fe0bb..b72e7fc2a1 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConnectTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConnectTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketConnectTest extends SocketConnectTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConnectionAttemptTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConnectionAttemptTest.java
index 4cebeba8f0..6f11b42eb8 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConnectionAttemptTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketConnectionAttemptTest.java
@@ -42,5 +42,6 @@ public class IoUringSocketConnectionAttemptTest extends SocketConnectionAttemptT
     protected void configure(Bootstrap cb, ByteBufAllocator allocator) {
         super.configure(cb, allocator);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketDataReadInitialStateTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketDataReadInitialStateTest.java
index 6c4ab72a6f..5eda569cbd 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketDataReadInitialStateTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketDataReadInitialStateTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketDataReadInitialStateTest extends SocketDataReadInitial
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketEchoTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketEchoTest.java
index 63c022ff64..eee3b598c9 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketEchoTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketEchoTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketEchoTest extends SocketEchoTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketExceptionHandlingTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketExceptionHandlingTest.java
index 6fe7e2129c..bb3fd30450 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketExceptionHandlingTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketExceptionHandlingTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketExceptionHandlingTest extends SocketExceptionHandlingT
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketFileRegionTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketFileRegionTest.java
index ba465d7c64..4c53f093cd 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketFileRegionTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketFileRegionTest.java
@@ -57,6 +57,8 @@ public class IoUringSocketFileRegionTest extends SocketFileRegionTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketFixedLengthEchoTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketFixedLengthEchoTest.java
index b7c2cc9365..9bf0130e91 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketFixedLengthEchoTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketFixedLengthEchoTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketFixedLengthEchoTest extends SocketFixedLengthEchoTest
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketGatheringWriteTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketGatheringWriteTest.java
index b99a01489a..c6cfd6841c 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketGatheringWriteTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketGatheringWriteTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketGatheringWriteTest extends SocketGatheringWriteTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketHalfClosedTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketHalfClosedTest.java
index 2fb0b56d4f..cb4897a208 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketHalfClosedTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketHalfClosedTest.java
@@ -60,6 +60,8 @@ public class IoUringSocketHalfClosedTest extends SocketHalfClosedTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketMultipleConnectTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketMultipleConnectTest.java
index 53985e3dcf..08fdebcc98 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketMultipleConnectTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketMultipleConnectTest.java
@@ -58,6 +58,8 @@ public class IoUringSocketMultipleConnectTest extends SocketMultipleConnectTest
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketReadPendingTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketReadPendingTest.java
index 40ea0910cb..31032f57c2 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketReadPendingTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketReadPendingTest.java
@@ -42,6 +42,7 @@ public class IoUringSocketReadPendingTest extends SocketReadPendingTest {
     protected void configure(ServerBootstrap sb, Bootstrap cb, ByteBufAllocator allocator) {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        // Don't use buffer group as the test wants to limit the number of bytes we read to 1.
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
     }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketRstTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketRstTest.java
index 4e04703988..af225b3ffe 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketRstTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketRstTest.java
@@ -60,6 +60,8 @@ public class IoUringSocketRstTest extends SocketRstTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketShutdownOutputByPeerTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketShutdownOutputByPeerTest.java
index a28429d93d..d4f38762c7 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketShutdownOutputByPeerTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketShutdownOutputByPeerTest.java
@@ -42,5 +42,7 @@ public class IoUringSocketShutdownOutputByPeerTest extends SocketShutdownOutputB
     protected void configure(ServerBootstrap bootstrap, ByteBufAllocator allocator) {
         super.configure(bootstrap, allocator);
         bootstrap.option(IoUringChannelOption.POLLIN_FIRST, false);
+        bootstrap.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        bootstrap.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketShutdownOutputBySelfTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketShutdownOutputBySelfTest.java
index 9c8947a4b2..85694faa37 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketShutdownOutputBySelfTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketShutdownOutputBySelfTest.java
@@ -42,5 +42,6 @@ public class IoUringSocketShutdownOutputBySelfTest extends SocketShutdownOutputB
     protected void configure(Bootstrap bootstrap, ByteBufAllocator allocator) {
         super.configure(bootstrap, allocator);
         bootstrap.option(IoUringChannelOption.POLLIN_FIRST, true);
+        bootstrap.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslClientRenegotiateTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslClientRenegotiateTest.java
index d004c72597..3e9d463609 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslClientRenegotiateTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslClientRenegotiateTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketSslClientRenegotiateTest extends SocketSslClientRenego
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslEchoTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslEchoTest.java
index b8eb6b5c06..58e8b0fbf5 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslEchoTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslEchoTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketSslEchoTest extends SocketSslEchoTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslGreetingTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslGreetingTest.java
index e9d9c34568..a3cbf35611 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslGreetingTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslGreetingTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketSslGreetingTest extends SocketSslGreetingTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslSessionReuseTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslSessionReuseTest.java
index cc76c61900..652c23741a 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslSessionReuseTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketSslSessionReuseTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketSslSessionReuseTest extends SocketSslSessionReuseTest
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketStartTlsTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketStartTlsTest.java
index 46b6689c94..241490415d 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketStartTlsTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketStartTlsTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketStartTlsTest extends SocketStartTlsTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketStringEchoTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketStringEchoTest.java
index 6215bcac34..8d27efd5f4 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketStringEchoTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketStringEchoTest.java
@@ -43,6 +43,8 @@ public class IoUringSocketStringEchoTest extends SocketStringEchoTest {
         super.configure(sb, cb, allocator);
         sb.option(IoUringChannelOption.POLLIN_FIRST, false);
         sb.childOption(IoUringChannelOption.POLLIN_FIRST, false);
+        sb.childOption(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
         cb.option(IoUringChannelOption.POLLIN_FIRST, false);
+        cb.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketTestPermutation.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketTestPermutation.java
index 6fbe8438d6..ee109f34a0 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketTestPermutation.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringSocketTestPermutation.java
@@ -17,12 +17,12 @@ package io.netty.channel.uring;
 
 import io.netty.bootstrap.Bootstrap;
 import io.netty.bootstrap.ServerBootstrap;
+import io.netty.buffer.ByteBufAllocator;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFactory;
 import io.netty.channel.ChannelOption;
 import io.netty.channel.EventLoopGroup;
 import io.netty.channel.MultiThreadIoEventLoopGroup;
-import io.netty.channel.socket.InternetProtocolFamily;
 import io.netty.channel.socket.SocketProtocolFamily;
 import io.netty.channel.socket.nio.NioDatagramChannel;
 import io.netty.channel.socket.nio.NioServerSocketChannel;
@@ -40,11 +40,15 @@ import java.util.List;
 public class IoUringSocketTestPermutation extends SocketTestPermutation {
 
     static final IoUringSocketTestPermutation INSTANCE = new IoUringSocketTestPermutation();
-
+    static final short BGID = 1;
     static final EventLoopGroup IO_URING_BOSS_GROUP = new MultiThreadIoEventLoopGroup(
             BOSSES, new DefaultThreadFactory("testsuite-io_uring-boss", true), IoUringIoHandler.newFactory());
     static final EventLoopGroup IO_URING_WORKER_GROUP = new MultiThreadIoEventLoopGroup(
-            WORKERS, new DefaultThreadFactory("testsuite-io_uring-worker", true), IoUringIoHandler.newFactory());
+            WORKERS, new DefaultThreadFactory("testsuite-io_uring-worker", true),
+            IoUringIoHandler.newFactory(new IoUringIoHandlerConfig()
+                    // Configure a buffer ring that we can easily enable by setting the correct IoUringChannelOption.
+                    .addBufferRingConfig(
+                            new IoUringBufferRingConfig(BGID, (short) 16, 1024, ByteBufAllocator.DEFAULT))));
 
     @Override
     public List<BootstrapComboFactory<ServerBootstrap, Bootstrap>> socket() {
diff --git a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringWriteBeforeRegisteredTest.java b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringWriteBeforeRegisteredTest.java
index 0c35529ea9..d2fab4317a 100644
--- a/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringWriteBeforeRegisteredTest.java
+++ b/transport-native-io_uring/src/test/java/io/netty/channel/uring/IoUringWriteBeforeRegisteredTest.java
@@ -41,5 +41,6 @@ public class IoUringWriteBeforeRegisteredTest extends WriteBeforeRegisteredTest
     protected void configure(Bootstrap bootstrap, ByteBufAllocator allocator) {
         super.configure(bootstrap, allocator);
         bootstrap.option(IoUringChannelOption.POLLIN_FIRST, false);
+        bootstrap.option(IoUringChannelOption.IO_URING_BUFFER_GROUP_ID, IoUringSocketTestPermutation.BGID);
     }
 }
