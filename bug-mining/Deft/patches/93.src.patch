diff --git a/NEWS.txt b/NEWS.txt
index 1b2f0a9..31e55d5 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -6,6 +6,7 @@ Features
     - Asynchronous HTTP client has configurable redirect support (HTTP status code 301 & 302) (#118)
     - Asynchronous HTTP client supports 'Transfer-Encoding: chunked' (#116)
     - Multi-threaded web server support (#139)
+    - Experimental support for large static files. (Nb. will memory map the entire file) (#75)
 
 Configuration
 ------------
diff --git a/src/main/java/org/deftserver/example/DeftServerExample.java b/src/main/java/org/deftserver/example/DeftServerExample.java
index 1330d3c..389dee6 100644
--- a/src/main/java/org/deftserver/example/DeftServerExample.java
+++ b/src/main/java/org/deftserver/example/DeftServerExample.java
@@ -2,6 +2,7 @@ package org.deftserver.example;
 
 import java.util.Map;
 
+import org.deftserver.io.IOLoop;
 import org.deftserver.web.Application;
 import org.deftserver.web.HttpServer;
 import org.deftserver.web.handler.RequestHandler;
@@ -47,9 +48,9 @@ public class DeftServerExample {
 
 		logger.debug("Starting up server on port: " + PORT);
 		HttpServer server = new HttpServer(application);
-		//server.listen(PORT);
-		server.bind(PORT);
-		server.start(8);
-		//IOLoop.INSTANCE.start();
+		server.listen(PORT);
+		//server.bind(PORT);
+		//server.start(Runtime.getRuntime().availableProcessors());
+		IOLoop.INSTANCE.start();
 	}
 }
diff --git a/src/main/java/org/deftserver/io/AsynchronousSocket.java b/src/main/java/org/deftserver/io/AsynchronousSocket.java
index 3d957ff..e8cf079 100644
--- a/src/main/java/org/deftserver/io/AsynchronousSocket.java
+++ b/src/main/java/org/deftserver/io/AsynchronousSocket.java
@@ -7,6 +7,7 @@ import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
+import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
 import java.nio.channels.UnresolvedAddressException;
 
@@ -47,7 +48,37 @@ public class AsynchronousSocket implements IOHandler {
 	private boolean reachedEOF = false;
 	
 	/**
-	 * Create a new {@code AsynchronousSocket} that will delegate its io operations the given {@code SelectableChannel}.
+	 * Creates a new {@code AsynchronousSocket} that will delegate its io operations to the given 
+	 * {@link SelectableChannel}. 
+	 * <p>
+	 * Support for three non-blocking asynchronous methods that take callbacks:
+	 * <p> 
+	 * {@link #readUntil(String, AsyncResult)}
+	 * <p>  
+	 * {@link #readBytes(int, AsyncResult)} and
+	 * <p>
+	 * {@link #write(String, AsyncCallback)} 
+	 * <p>
+	 * The {@link SelectableChannel} should be the result of either {@link SocketChannel#open()} (client operations, 
+	 * connected or  unconnected) or {@link ServerSocketChannel#accept()} (server operations).
+	 * <p> 
+	 * The given {@code SelectableChannel} will be configured to be in non-blocking mode, even if it is non-blocking
+	 * already. 
+	 * 
+	 * <p>Below is an example of how a simple server could be implemented.
+	 * <pre>
+     *   final ServerSocketChannel server = ServerSocketChannel.open();
+     *   server.socket().bind(new InetSocketAddress(9090));
+     * 	
+     *   AcceptUtil.accept(server, new AsyncCallback() { public void onCallback() { onAccept(server);} });
+     *   IOLoop.INSTANCE.start();
+	 * 
+     *   private static void onAccept(ServerSocketChannel channel) {
+     *       SocketChannel client = channel.accept();
+     *       AsynchronousSocket socket = new AsynchronousSocket(client);
+     *       // use socket
+     *   }
+	 * </pre>
 	 */
 	public AsynchronousSocket(SelectableChannel channel) {
 		this(IOLoop.INSTANCE, channel);
@@ -56,7 +87,12 @@ public class AsynchronousSocket implements IOHandler {
 	public AsynchronousSocket(IOLoop ioLoop, SelectableChannel channel) {
 		this.ioLoop = ioLoop;
 		this.channel = channel;
-		interestOps = SelectionKey.OP_CONNECT;
+		interestOps = SelectionKey.OP_CONNECT;	// TODO RS110628 should probably be moved to connect(..)
+		try {
+			channel.configureBlocking(false);
+		} catch (IOException e) {
+			logger.error("Could not configure SocketChannel to be non-blocking");
+		}
 		if (channel instanceof SocketChannel && (((SocketChannel) channel).isConnected())) {
 			interestOps |= SelectionKey.OP_READ;
 		}
@@ -65,6 +101,9 @@ public class AsynchronousSocket implements IOHandler {
 	
 	/**
 	 * Connects to the given host port tuple and invokes the given callback when a successful connection is established.
+	 * <p>
+	 * You can both read and write on the {@code AsynchronousSocket} before it is connected
+	 * (in which case the data will be written/read as soon as the connection is ready).
 	 */
 	public void connect(String host, int port, AsyncResult<Boolean> ccb) {
 		ioLoop.updateHandler(channel, interestOps |= SelectionKey.OP_CONNECT);
diff --git a/src/main/java/org/deftserver/util/AcceptUtil.java b/src/main/java/org/deftserver/util/AcceptUtil.java
new file mode 100644
index 0000000..b895eb2
--- /dev/null
+++ b/src/main/java/org/deftserver/util/AcceptUtil.java
@@ -0,0 +1,36 @@
+package org.deftserver.util;
+
+import java.io.IOException;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.ServerSocketChannel;
+
+import org.deftserver.io.IOHandler;
+import org.deftserver.io.IOLoop;
+import org.deftserver.web.AsyncCallback;
+
+public class AcceptUtil {
+
+	public static void accept(ServerSocketChannel server, final AsyncCallback cb) {
+		accept(IOLoop.INSTANCE, server, cb);
+	}
+	
+	public static void accept(IOLoop ioLoop, ServerSocketChannel server, final AsyncCallback cb) {
+		ioLoop.addHandler(
+				server, 
+				new AcceptingIOHandler() {public void handleAccept(SelectionKey key) { cb.onCallback(); }},
+				SelectionKey.OP_ACCEPT, 
+				null
+		);
+	}
+	
+	private static abstract class AcceptingIOHandler implements IOHandler {
+
+		public void handleConnect(SelectionKey key) throws IOException {}
+
+		public void handleRead(SelectionKey key) throws IOException {}
+
+		public void handleWrite(SelectionKey key) {}
+		
+	}
+
+}
diff --git a/src/main/java/org/deftserver/util/HttpUtil.java b/src/main/java/org/deftserver/util/HttpUtil.java
index f59739d..aea0ac3 100644
--- a/src/main/java/org/deftserver/util/HttpUtil.java
+++ b/src/main/java/org/deftserver/util/HttpUtil.java
@@ -155,7 +155,6 @@ public class HttpUtil {
 	public static String getEtag(byte[] bytes) {
 		if (md.get() == null) {
 			try {
-				System.out.println("create instance");
 				md.set(MessageDigest.getInstance("MD5"));
 			} catch (NoSuchAlgorithmException e) {
 				throw new RuntimeException("MD5 cryptographic algorithm is not available.", e);
diff --git a/src/main/java/org/deftserver/web/HttpServer.java b/src/main/java/org/deftserver/web/HttpServer.java
index 7116bc8..2a0c3ea 100644
--- a/src/main/java/org/deftserver/web/HttpServer.java
+++ b/src/main/java/org/deftserver/web/HttpServer.java
@@ -85,6 +85,8 @@ public class HttpServer {
 	public void stop() {
 		logger.debug("Stopping HTTP server");
 		for (IOLoop ioLoop : ioLoops) {
+			// TODO RS 110527 Should probably do this in each IOLoop through an AsyncCallback 
+			// (hint: ioloop.addCallback(..))
 			Closeables.closeQuietly(ioLoop, serverChannel);
 		}
 	}
diff --git a/src/main/java/org/deftserver/web/http/HttpProtocol.java b/src/main/java/org/deftserver/web/http/HttpProtocol.java
index b5c4dfc..a34575c 100644
--- a/src/main/java/org/deftserver/web/http/HttpProtocol.java
+++ b/src/main/java/org/deftserver/web/http/HttpProtocol.java
@@ -5,6 +5,7 @@ import static org.deftserver.web.http.HttpServerDescriptor.READ_BUFFER_SIZE;
 
 import java.io.IOException;
 import java.nio.ByteBuffer;
+import java.nio.MappedByteBuffer;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
@@ -81,33 +82,59 @@ public class HttpProtocol implements IOHandler {
 			response.finish();
 		}
 	}
-	
+
 	@Override
 	public void handleWrite(SelectionKey key) {
 		logger.debug("handle write...");
+		SocketChannel channel = ((SocketChannel) key.channel());
+
+		if (key.attachment() instanceof MappedByteBuffer) {
+			writeMappedByteBuffer(key, channel);
+		} else if (key.attachment() instanceof DynamicByteBuffer) {
+			writeDynamicByteBuffer(key, channel);
+		}
+		if (ioLoop.hasKeepAliveTimeout(channel)) {
+			prolongKeepAliveTimeout(channel);
+		}
+
+	}
+
+	private void writeMappedByteBuffer(SelectionKey key, SocketChannel channel) {
+		MappedByteBuffer mbb = (MappedByteBuffer) key.attachment();
+		if (mbb.hasRemaining()) {
+			try {
+				channel.write(mbb);
+			} catch (IOException e) {
+				logger.error("Failed to send data to client: {}", e.getMessage());
+				Closeables.closeQuietly(channel);
+			}
+		}
+		if (!mbb.hasRemaining()) {
+			closeOrRegisterForRead(key);
+		}
+	}
+	
+	private void writeDynamicByteBuffer(SelectionKey key, SocketChannel channel) {
 		DynamicByteBuffer dbb = (DynamicByteBuffer) key.attachment();
 		logger.debug("pending data about to be written");
 		ByteBuffer toSend = dbb.getByteBuffer();
-		SocketChannel channel = ((SocketChannel) key.channel());
+		toSend.flip(); // prepare for write
+		long bytesWritten = 0;
 		try {
-			toSend.flip();	// prepare for write
-			long bytesWritten = channel.write(toSend);
-			if (ioLoop.hasKeepAliveTimeout(channel)) {
-				prolongKeepAliveTimeout(channel);
-			}
-			logger.debug("sent {} bytes to wire", bytesWritten);
-			if (!toSend.hasRemaining()) {
-				logger.debug("sent all data in toSend buffer");
-				closeOrRegisterForRead(key);	// should probably only be done if the HttpResponse is finished
-			} else {
-				toSend.compact();	// make room for more data be "read" in
-			}
+			bytesWritten = channel.write(toSend);
 		} catch (IOException e) {
 			logger.error("Failed to send data to client: {}", e.getMessage());
-			Closeables.closeQuietly(ioLoop, channel);
+			Closeables.closeQuietly(channel);
+		}
+		logger.debug("sent {} bytes to wire", bytesWritten);
+		if (!toSend.hasRemaining()) {
+			logger.debug("sent all data in toSend buffer");
+			closeOrRegisterForRead(key); // should probably only be done if the HttpResponse is finished
+		} else {
+			toSend.compact(); // make room for more data be "read" in
 		}
 	}
-	
+
 	public void closeOrRegisterForRead(SelectionKey key) {
 		if (key.isValid() && ioLoop.hasKeepAliveTimeout(key.channel())) {
 			try {
@@ -143,19 +170,21 @@ public class HttpProtocol implements IOHandler {
 	private ByteBuffer reuseAttachment(SelectionKey key) {
 		Object o = key.attachment();
 		ByteBuffer attachment = null;
-		if (o instanceof DynamicByteBuffer) {
-			attachment = ((DynamicByteBuffer)o).getByteBuffer();
+		if (o instanceof MappedByteBuffer) {
+			attachment = ByteBuffer.allocate(READ_BUFFER_SIZE);
+		} else if (o instanceof DynamicByteBuffer) {
+			attachment = ((DynamicByteBuffer) o).getByteBuffer();
 		} else {
 			attachment = (ByteBuffer) o;
 		}
+
 		if (attachment.capacity() < READ_BUFFER_SIZE) {
 			attachment = ByteBuffer.allocate(READ_BUFFER_SIZE);
 		}
-		attachment.clear();	// prepare for reuse
+		attachment.clear(); // prepare for reuse
 		return attachment;
 	}
 
-
 	private HttpRequest getHttpRequest(SelectionKey key, SocketChannel clientChannel) {
 		ByteBuffer buffer = (ByteBuffer) key.attachment();
 		try {
diff --git a/src/main/java/org/deftserver/web/http/HttpResponse.java b/src/main/java/org/deftserver/web/http/HttpResponse.java
index 5bac6e9..862bad8 100644
--- a/src/main/java/org/deftserver/web/http/HttpResponse.java
+++ b/src/main/java/org/deftserver/web/http/HttpResponse.java
@@ -5,9 +5,12 @@ import static org.deftserver.web.http.HttpServerDescriptor.WRITE_BUFFER_SIZE;
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
+import java.nio.MappedByteBuffer;
 import java.nio.channels.ClosedChannelException;
+import java.nio.channels.FileChannel;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.SocketChannel;
+import java.nio.channels.FileChannel.MapMode;
 import java.util.HashMap;
 import java.util.Map;
 
@@ -87,7 +90,7 @@ public class HttpResponse {
 		if (responseData.hasRemaining()) { 
 			responseData.compact();	// make room for more data be "read" in
 			try {
-				key.channel().register(key.selector(), SelectionKey.OP_WRITE);
+				key.channel().register(key.selector(), SelectionKey.OP_WRITE);	//TODO RS 110621, use IOLoop.updateHandler
 			} catch (ClosedChannelException e) {
 				logger.error("ClosedChannelException during flush(): {}", e.getMessage());
 				Closeables.closeQuietly(protocol.getIOLoop(), key.channel());
@@ -109,27 +112,42 @@ public class HttpResponse {
 	public long finish() {
 		long bytesWritten = 0;
 		SocketChannel clientChannel = (SocketChannel) key.channel();
-		if (clientChannel.isOpen()) {
-			if (!headersCreated) {
-				setEtagAndContentLength();
+
+		if (key.attachment() instanceof MappedByteBuffer) {
+			MappedByteBuffer mbb = (MappedByteBuffer) key.attachment();
+			if (mbb.hasRemaining() && clientChannel.isOpen()) {
+				try {
+					bytesWritten = clientChannel.write(mbb);
+				} catch (IOException e) {
+					logger.warn("Could not write to channel: ", e.getMessage());					
+					Closeables.closeQuietly(key.channel());
+				}
 			}
-			bytesWritten = flush();
-		}
-		
-		// close (or register for read) iff 
-		// (a) DBB is attached but all data is sent to wire (hasRemaining == false)
-		// (b) no DBB is attached (never had to register for write)
-		if (key.attachment() instanceof DynamicByteBuffer) {
-			DynamicByteBuffer dbb = (DynamicByteBuffer) key.attachment();
-			if (!(dbb).hasRemaining()) {
+			if (!mbb.hasRemaining()) {
 				protocol.closeOrRegisterForRead(key);
-			} 
+			}
 		} else {
-			protocol.closeOrRegisterForRead(key);
+			if (clientChannel.isOpen()) {
+				if (!headersCreated) {
+					setEtagAndContentLength();
+				}
+				bytesWritten = flush();
+			}
+			// close (or register for read) if
+			// (a) DBB is attached but all data is sent to wire (hasRemaining ==
+			// false)
+			// (b) no DBB is attached (never had to register for write)
+			if (key.attachment() instanceof DynamicByteBuffer) {
+				DynamicByteBuffer dbb = (DynamicByteBuffer) key.attachment();
+				if (!(dbb).hasRemaining()) {
+					protocol.closeOrRegisterForRead(key);
+				}
+			} else {
+				protocol.closeOrRegisterForRead(key);
+			}
 		}
 		return bytesWritten;
-	}
-	
+	}	
 	private void setEtagAndContentLength() {
 		if (responseData.position() > 0) {
 			setHeader("Etag", HttpUtil.getEtag(responseData.array()));
@@ -159,11 +177,26 @@ public class HttpResponse {
 		setHeader("Content-Length", String.valueOf(file.length()));
 		long bytesWritten = 0;
 		flush(); // write initial line + headers
+		
 		RandomAccessFile raf = null;
 		try {
 			raf = new RandomAccessFile(file, "r");
-			bytesWritten = raf.getChannel().transferTo(0, file.length(), (SocketChannel) key.channel());
-			logger.debug("sent file, bytes sent: {}", bytesWritten);
+			FileChannel fc = raf.getChannel();
+			MappedByteBuffer mbb = raf.getChannel().map(MapMode.READ_ONLY, 0L, fc.size());
+
+			if (mbb.hasRemaining()) {
+				bytesWritten = ((SocketChannel) key.channel()).write(mbb);
+				logger.debug("sent file, bytes sent: {}", bytesWritten);
+			}
+			if (mbb.hasRemaining()) {
+				try {
+					key.channel().register(key.selector(), SelectionKey.OP_WRITE); //TODO RS 110621, use IOLoop.updateHandler
+				} catch (ClosedChannelException e) {
+					logger.error("ClosedChannelException during write(File): {}", e.getMessage());
+					Closeables.closeQuietly(key.channel());
+				}
+				key.attach(mbb);
+			}
 		} catch (IOException e) {
 			logger.error("Error writing (static file) response: {}", e.getMessage());
 		} finally {
