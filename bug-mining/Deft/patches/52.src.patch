diff --git a/NEWS.txt b/NEWS.txt
index 6c2a85c..cd48a48 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -11,7 +11,8 @@ Features
     - Closed HTTP request premature in HttpResponse.finish() (#72)
     - JMX monitoring (read only) for IOLoop (#68)
     - Configurable knobs, e.g. keep-alive timeout, read/write buffer sizes. (#57, #67)
-     
+    - java.nio.ByteBuffer reuse (byte[] allocation is expensive) (#77)
+         
 Configuration
 ------------
      - See org.deftserver.example.DeftServerExample (or www.deftserver.org) for
diff --git a/src/main/java/org/deftserver/web/http/HttpProtocol.java b/src/main/java/org/deftserver/web/http/HttpProtocol.java
index 45abe37..52bb13e 100644
--- a/src/main/java/org/deftserver/web/http/HttpProtocol.java
+++ b/src/main/java/org/deftserver/web/http/HttpProtocol.java
@@ -85,6 +85,7 @@ public class HttpProtocol implements IOHandler {
 	public void closeOrRegisterForRead(SelectionKey key) {
 		if (IOLoop.INSTANCE.hasKeepAliveTimeout(key.channel())) {
 			try {
+				//key.channel().register(key.selector(), SelectionKey.OP_READ, reuseAttachment(key));
 				key.channel().register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(READ_BUFFER_SIZE));
 				logger.debug("keep-alive connection. registrating for read.");
 			} catch (ClosedChannelException e) {
@@ -97,6 +98,24 @@ public class HttpProtocol implements IOHandler {
 			Closeables.closeQuietly(key.channel());
 		}
 	}
+	/**
+	 * Clears the buffer (prepares for reuse) attached to the given SelectionKey.
+	 * @return A cleared (position=0, limit=capacity) ByteBuffer which is ready for new reads
+	 */
+	private ByteBuffer reuseAttachment(SelectionKey key) {
+		Object o = key.attachment();
+		ByteBuffer attachment = null;
+		if (o instanceof DynamicByteBuffer) {
+			attachment = ((DynamicByteBuffer)o).getByteBuffer();
+		} else {
+			attachment = (ByteBuffer) o;
+		}
+		if (attachment.capacity() < READ_BUFFER_SIZE) {
+			attachment = ByteBuffer.allocate(READ_BUFFER_SIZE);
+		}
+		attachment.clear();	// prepare for reuse
+		return attachment;
+	}
 
 
 	private HttpRequest getHttpRequest(SelectionKey key, SocketChannel clientChannel) {
