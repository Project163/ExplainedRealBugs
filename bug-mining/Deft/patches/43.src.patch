diff --git a/src/main/java/org/deftserver/web/buffer/DynamicByteBuffer.java b/src/main/java/org/deftserver/web/buffer/DynamicByteBuffer.java
new file mode 100644
index 0000000..0dddf06
--- /dev/null
+++ b/src/main/java/org/deftserver/web/buffer/DynamicByteBuffer.java
@@ -0,0 +1,85 @@
+package org.deftserver.web.buffer;
+
+import java.nio.ByteBuffer;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.base.Charsets;
+
+public class DynamicByteBuffer {
+	
+	private final static Logger logger = LoggerFactory.getLogger(DynamicByteBuffer.class);
+
+	private ByteBuffer backend;
+
+	private DynamicByteBuffer(ByteBuffer bb) { 	
+		this.backend = bb;
+	}
+	
+	public static DynamicByteBuffer allocate(int capacity) {
+		return new DynamicByteBuffer(ByteBuffer.allocate(capacity));
+	}
+
+	public void put(byte[] src) {
+		ensureCapacity(src.length);
+		backend.put(src);
+	}
+	
+	public void prepend(String data) {
+		byte[] bytes = data.getBytes(Charsets.UTF_8);
+		int newSize = bytes.length + backend.position();
+		byte[] newBuffer = new byte[newSize];
+		System.arraycopy(bytes, 0, newBuffer, 0, bytes.length);	// initial line and headers
+		System.arraycopy(backend.array(), 0, newBuffer, bytes.length, backend.position()); // body
+		backend = ByteBuffer.wrap(newBuffer);
+		backend.position(newSize);
+	}
+	
+	/**
+	 * Ensures that its safe to append size data to backend. 
+	 * @param size The size of the data that is about to be appended.
+	 */
+	private void ensureCapacity(int size) {
+		int remaining = backend.remaining();
+		if (size > remaining) {
+			logger.debug("allocating new DynamicByteBuffer, old capacity {}: ", backend.capacity());
+			int newSize =  (int) (Math.max(backend.capacity(), size) * 1.5);
+			reallocate(newSize);
+		}
+	}
+	
+	// Preserves position.
+	private void reallocate(int newCapacity) {
+		int oldPosition = backend.position();
+		byte[] newBuffer = new byte[newCapacity];
+		System.arraycopy(backend.array(), 0, newBuffer, 0, backend.position());
+		backend = ByteBuffer.wrap(newBuffer);
+		backend.position(oldPosition);
+		logger.debug("allocated new DynamicByteBufer, new capacity: {}", backend.capacity());
+	}
+	
+	public ByteBuffer getByteBuffer() {
+		return backend;
+	}
+
+	public void flip() {
+		backend.flip();
+	}
+
+	public int limit() {
+		return backend.limit();
+	}
+
+	public int position() {
+		return backend.position();
+	}
+
+	public byte[] array() {
+		return backend.array();
+	}
+
+	public int capacity() {
+		return backend.capacity();
+	}
+}
diff --git a/src/main/java/org/deftserver/web/protocol/HttpProtocol.java b/src/main/java/org/deftserver/web/protocol/HttpProtocol.java
index 52a8aef..dc53405 100644
--- a/src/main/java/org/deftserver/web/protocol/HttpProtocol.java
+++ b/src/main/java/org/deftserver/web/protocol/HttpProtocol.java
@@ -11,8 +11,6 @@ import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
 import java.util.HashMap;
 import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.List;
 import java.util.Map;
 import java.util.Map.Entry;
 
@@ -20,6 +18,7 @@ import javax.management.MBeanServer;
 import javax.management.ObjectName;
 
 import org.deftserver.web.Application;
+import org.deftserver.web.buffer.DynamicByteBuffer;
 import org.deftserver.web.handler.RequestHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -40,7 +39,6 @@ public class HttpProtocol implements Protocol, HttpProtocolMXBean {
 	 */
 	private final Map<SocketChannel, Long> persistentConnections = new HashMap<SocketChannel, Long>();
 	
-	private final Map<SelectionKey, List<ByteBuffer>> stagedData = Maps.newHashMap();
 	private final Map<SelectionKey, File> stagedFiles = Maps.newHashMap();
 	private final int readBufferSize;
 
@@ -94,25 +92,22 @@ public class HttpProtocol implements Protocol, HttpProtocolMXBean {
 	@Override
 	public void handleWrite(SelectionKey key) {
 		logger.debug("handle write...");
-		List<ByteBuffer> pending = stagedData.get(key);
+		DynamicByteBuffer dbb = (DynamicByteBuffer) key.attachment();
 		logger.debug("pending data about to be written");
-		ByteBuffer toSend = pending.get(0);
-		if (pending != null && !pending.isEmpty()) {
-			try {
-				long bytesWritten = ((SocketChannel)key.channel()).write(toSend);
-				logger.debug("sent {} bytes to wire", bytesWritten);
-				if (!toSend.hasRemaining()) {
-					logger.debug("sent all data in toSend buffer");
-					pending.remove(0);
-					if (pending.isEmpty()) {
-						// last 'chunk' sent
-						closeOrRegisterForRead(key);
-					}
-				}
-			} catch (IOException e) {
-				logger.error("Failed to send data to client: {}", e.getMessage());
-				Closeables.closeQuietly(key.channel());
+		try {
+			ByteBuffer toSend = dbb.getByteBuffer();
+			toSend.flip();	// prepare for write
+			long bytesWritten = ((SocketChannel)key.channel()).write(toSend);
+			logger.debug("sent {} bytes to wire", bytesWritten);
+			if (!toSend.hasRemaining()) {
+				logger.debug("sent all data in toSend buffer");
+				closeOrRegisterForRead(key);	// should probably only be done if the HttpResponse is finished
+			} else {
+				toSend.compact();	// make room for more data be "read" in
 			}
+		} catch (IOException e) {
+			logger.error("Failed to send data to client: {}", e.getMessage());
+			Closeables.closeQuietly(key.channel());
 		}
 		if (stagedFiles.containsKey(key)) {
 			File file = stagedFiles.get(key);
@@ -180,14 +175,14 @@ public class HttpProtocol implements Protocol, HttpProtocolMXBean {
 	 * @param key
 	 * @param responseData
 	 */
-	public void stage(SelectionKey key, ByteBuffer responseData) {
-		List<ByteBuffer> pending = stagedData.get(key);
-		if (pending == null) {
-			pending = new LinkedList<ByteBuffer>();
-			stagedData.put(key, pending);
-		}
-		pending.add(responseData);
-	}
+//	public void stage(SelectionKey key, ByteBuffer responseData) {
+//		List<ByteBuffer> pending = stagedData.get(key);
+//		if (pending == null) {
+//			pending = new LinkedList<ByteBuffer>();
+//			stagedData.put(key, pending);
+//		}
+//		pending.add(responseData);
+//	}
 
 
 	public void stage(SelectionKey key, File file) {
diff --git a/src/main/java/org/deftserver/web/protocol/HttpResponse.java b/src/main/java/org/deftserver/web/protocol/HttpResponse.java
index 22973fe..cc79f52 100644
--- a/src/main/java/org/deftserver/web/protocol/HttpResponse.java
+++ b/src/main/java/org/deftserver/web/protocol/HttpResponse.java
@@ -1,7 +1,6 @@
 package org.deftserver.web.protocol;
 
 import java.io.File;
-import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.SocketChannel;
@@ -10,6 +9,7 @@ import java.util.Map;
 
 import org.deftserver.util.DateUtil;
 import org.deftserver.util.HttpUtil;
+import org.deftserver.web.buffer.DynamicByteBuffer;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -29,22 +29,14 @@ public class HttpResponse {
 	
 	private final Map<String, String> headers = new HashMap<String, String>();
 	private boolean headersCreated = false;
-	private ByteBuffer responseData = ByteBuffer.allocate(WRITE_BUFFER_SIZE);
-//	private final boolean keepAlive;
+	private DynamicByteBuffer responseData = DynamicByteBuffer.allocate(WRITE_BUFFER_SIZE);
 	
 	public HttpResponse(HttpProtocol protocol, SelectionKey key, boolean keepAlive) {
 		this.protocol = protocol;
 		this.key = key;
 		headers.put("Server", "DeftServer/0.2.0-SNAPSHOT");
 		headers.put("Date", DateUtil.getCurrentAsString());
-
-		if (keepAlive) {
-//			this.keepAlive = true;
-			headers.put("Connection", "Keep-Alive");
-		} else {
-//			this.keepAlive = false;
-			headers.put("Connection", "Close");	
-		}
+		headers.put("Connection", keepAlive ? "Keep-Alive" : "Close");
 	}
 	
 	public void setStatusCode(int sc) {
@@ -57,7 +49,6 @@ public class HttpResponse {
 
 	public HttpResponse write(String data) {
 		byte[] bytes = data.getBytes(Charsets.UTF_8);
-		ensureCapacity(bytes.length);
 		responseData.put(bytes);
 		return this;
 	}
@@ -65,7 +56,7 @@ public class HttpResponse {
 	public long flush() {
 		if (!headersCreated) {
 			String initial = createInitalLineAndHeaders();			
-			prepend(initial);
+			responseData.prepend(initial);
 			headersCreated = true;
 		}
 		if (!key.isWritable()) {
@@ -77,11 +68,9 @@ public class HttpResponse {
 				Closeables.closeQuietly(key.channel());
 			}
 		}
-		responseData.flip();	// prepare for write
-		protocol.stage(key, responseData);
-		logger.debug("{} bytes staged for writing", responseData.limit());
-		long bytesFlushed = responseData.limit();
-		responseData = ByteBuffer.allocate(WRITE_BUFFER_SIZE);
+		key.attach(responseData);
+		logger.debug("{} bytes staged for writing", responseData.position());
+		long bytesFlushed = responseData.position();
 		return bytesFlushed;
 	}
 	
@@ -117,37 +106,6 @@ public class HttpResponse {
 		return sb.toString();
 	}
 	
-	/**
-	 * Ensures that its safe to append size data to responseData. If we need to allocate a new ButeBuffer, the new
-	 * buffer will be twice as large as the old one.
-	 * @param size The size of the data that is about to be appended.
-	 */
-	private void ensureCapacity(int size) {
-		int remaining = responseData.remaining();
-		if (size > remaining) {
-			// allocate new ByteBuffer
-			logger.debug("allocation new responseData buffer.");
-			int newSize = Math.max(2 * responseData.capacity(), 2 * size);
-			allocate(newSize);
-		}
-	}
-
-	private void allocate(int newCapacity) {
-		byte[] newBuffer = new byte[newCapacity];
-		System.arraycopy(responseData.array(),0 , newBuffer, 0, responseData.position());
-		responseData = ByteBuffer.wrap(newBuffer);
-		logger.debug("allocated new responseData buffer, new size: {}", newBuffer.length);
-	}
-	
-	private void prepend(String data) {
-		byte[] bytes = data.getBytes(Charsets.UTF_8);
-		int newSize = bytes.length + responseData.position();
-		byte[] newBuffer = new byte[newSize];
-		System.arraycopy(bytes, 0, newBuffer, 0, bytes.length);	// initial line and headers
-		System.arraycopy(responseData.array(), 0, newBuffer, bytes.length, responseData.position()); // body
-		responseData = ByteBuffer.wrap(newBuffer);
-		responseData.position(newSize);
-	}
 
 	/**
 	 * @param file Static resource/file to send
@@ -155,19 +113,8 @@ public class HttpResponse {
 	public void write(File file) {
 		//setHeader("Etag", HttpUtil.getEtag(file));
 		setHeader("Content-Length", String.valueOf(file.length()));
-//		long bytesWritten = 0;
 		flush();	// write initial line + headers
 		protocol.stage(key, file);
-//		try {
-//			SocketChannel clientChannel = (SocketChannel) key.channel();
-//			logger.debug("sending file..");
-//			bytesWritten = new RandomAccessFile(file, "r").getChannel().transferTo(0, file.length(), clientChannel);
-//			logger.debug("sent bytes: " + bytesWritten);
-//		} catch (IOException e) {
-//			logger.error("Error writing (static file) response: {}", e.getMessage());
-//		}
-//		return bytesWritten;
 	}
-
 	
 }
diff --git a/src/test/java/org/deftserver/web/buffer/DynamicByteBufferTest.java b/src/test/java/org/deftserver/web/buffer/DynamicByteBufferTest.java
new file mode 100644
index 0000000..d83cdc2
--- /dev/null
+++ b/src/test/java/org/deftserver/web/buffer/DynamicByteBufferTest.java
@@ -0,0 +1,74 @@
+package org.deftserver.web.buffer;
+
+import static org.junit.Assert.assertEquals;
+
+import org.junit.Before;
+import org.junit.Test;
+
+public class DynamicByteBufferTest {
+
+	private DynamicByteBuffer dbb;
+	private static final int INITIAL_CAPACITY = 10;	// bytes
+	
+	@Before
+	public void allocation() {
+		this.dbb = DynamicByteBuffer.allocate(INITIAL_CAPACITY);
+	}
+	
+	@Test
+	public void testAllocation() {
+		assertInternalState(INITIAL_CAPACITY, 0, INITIAL_CAPACITY, INITIAL_CAPACITY);
+	}
+	
+	private void assertInternalState(int expectedCapacity, int expectedPosition, int expectedLimit, int arrayLength) {
+		assertEquals(expectedCapacity, dbb.capacity());
+		assertEquals(expectedPosition, dbb.position());
+		assertEquals(expectedLimit, dbb.limit());
+		assertEquals(arrayLength, dbb.array().length);
+	}
+	
+	@Test
+	public void testNoReallactionPut() {
+		byte[] data = new byte[] {'q', 'w', 'e', 'r', 't', 'y'};
+		dbb.put(data);
+		assertInternalState(INITIAL_CAPACITY, data.length, INITIAL_CAPACITY, INITIAL_CAPACITY);
+	}
+	
+	@Test
+	public void testReallocationTriggeredPut() {
+		byte[] data = new byte[] {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A'};
+		dbb.put(data);
+		assertInternalState(16, 11, 16, 16);
+		
+		dbb.put(data);
+		assertInternalState(24, 22, 24, 24);
+		
+		dbb.put(data);
+		dbb.put(data);
+		assertInternalState(54, 44, 54, 54);
+	}
+	
+	@Test
+	public void testPrepend() {
+		byte[] data = new byte[] {'[', 'q', 'w', 'e', 'r', 't', 'y', ']'};
+		dbb.put(data);
+		
+		String initial = "|HTTP/1.1 200 OK|";
+		int initialLength = initial.length();
+		dbb.prepend(initial);
+		
+		int expectedCapacity = data.length + initialLength;
+		int expectedPosition = data.length + initialLength;
+		int expectedLimit 	 = data.length + initialLength;
+		int arrayLength 	 = data.length + initialLength;
+		assertInternalState(expectedCapacity, expectedPosition, expectedLimit, arrayLength);
+		
+		dbb.put(data);
+		expectedCapacity += expectedCapacity * 0.5;	
+		expectedPosition += data.length;
+		expectedLimit 	 += expectedLimit * 0.5;
+		arrayLength 	 += arrayLength * 0.5;
+		assertInternalState(expectedCapacity, expectedPosition, expectedLimit, arrayLength);
+	}
+	
+}
