diff --git a/CHANGES.txt b/CHANGES.txt
index 2949712..aded34c 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,5 +1,5 @@
 0.1.1
- * #56 (add support for all http response status code)
- * #55 (Dont set Etag response header if payload is empty)
+ * #56 (Support for all response status codes)
+ * #55 (Don't set Etag response header if payload is empty)
  * #54 (Make parsing of HttpRequest more robust) 
  * #61 (Wrong 'Cache-Control' header in SCH) 
\ No newline at end of file
diff --git a/NEWS.txt b/NEWS.txt
index c9c7764..0705e64 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -13,6 +13,7 @@ Features
     - Configurable knobs, e.g. keep-alive timeout, read/write buffer sizes. (#57, #67)
     - java.nio.ByteBuffer reuse (byte[] allocation is expensive) (#77)
     - Configurable (and efficient) timeouts handling (#80, #85)
+    - Http Post support (#50, #71)
          
 Configuration
 ------------
diff --git a/src/main/java/org/deftserver/example/DeftServerExample.java b/src/main/java/org/deftserver/example/DeftServerExample.java
index d51d31d..9e03de2 100644
--- a/src/main/java/org/deftserver/example/DeftServerExample.java
+++ b/src/main/java/org/deftserver/example/DeftServerExample.java
@@ -27,6 +27,11 @@ public class DeftServerExample {
 		public void get(HttpRequest request, HttpResponse response) {
 			response.write("hello world");
 		}
+		
+		@Override
+		public void post(HttpRequest request, HttpResponse response) {
+			response.write("hello post world\nbody: " + request.getBody());
+		}
 
 	}
 
diff --git a/src/main/java/org/deftserver/web/http/HttpProtocol.java b/src/main/java/org/deftserver/web/http/HttpProtocol.java
index f353c5a..806e524 100644
--- a/src/main/java/org/deftserver/web/http/HttpProtocol.java
+++ b/src/main/java/org/deftserver/web/http/HttpProtocol.java
@@ -6,9 +6,11 @@ import static org.deftserver.web.http.HttpServerDescriptor.READ_BUFFER_SIZE;
 import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException;
+import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
+import java.util.Map;
 
 import org.deftserver.io.IOHandler;
 import org.deftserver.io.IOLoop;
@@ -20,12 +22,17 @@ import org.deftserver.web.handler.RequestHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.google.common.collect.Maps;
+
 public class HttpProtocol implements IOHandler {
 	
 	private final static Logger logger = LoggerFactory.getLogger(HttpProtocol.class);
 
 	private final Application application;
-	
+
+	// a queue of half-baked (pending/unfinished) HTTP post request
+	private final Map<SelectableChannel, PartialHttpRequest> partials = Maps.newHashMap();
+ 	
 	public HttpProtocol(Application app) {
 		application = app;
 	}
@@ -54,8 +61,8 @@ public class HttpProtocol implements IOHandler {
 		RequestHandler rh = application.getHandler(request);
 		HttpRequestDispatcher.dispatch(rh, request, response);
 		
-		//Only close if not async. In that case its up to RH to close it
-		if (!rh.isMethodAsynchronous(request.getMethod())) {
+		//Only close if not async. In that case its up to RH to close it (+ don't close if it's a partial request).
+		if (!rh.isMethodAsynchronous(request.getMethod()) && ! (request instanceof PartialHttpRequest)) {
 			response.finish();
 		}
 	}
@@ -127,7 +134,25 @@ public class HttpProtocol implements IOHandler {
 			Closeables.closeQuietly(clientChannel);
 		}
 		buffer.flip();
-		return HttpRequest.of(buffer);
+		
+		return doGetHttpRequest(key, clientChannel, buffer);
+	}
+	
+	private HttpRequest doGetHttpRequest(SelectionKey key, SocketChannel clientChannel, ByteBuffer buffer) {
+		//do we have any unfinished http post requests for this channel?
+		HttpRequest request = null;
+		if (partials.containsKey(clientChannel)) {
+			request = HttpRequest.continueParsing(buffer, partials.get(clientChannel));
+			if (! (request instanceof PartialHttpRequest)) {	// received the entire payload/body
+				partials.remove(clientChannel);
+			}
+		} else {
+			request = HttpRequest.of(buffer);
+			if (request instanceof PartialHttpRequest) {
+				partials.put(key.channel(), (PartialHttpRequest) request);
+			}
+		}
+		return request;
 	}
 	
 	@Override
diff --git a/src/main/java/org/deftserver/web/http/HttpRequest.java b/src/main/java/org/deftserver/web/http/HttpRequest.java
index 085d488..ccef332 100644
--- a/src/main/java/org/deftserver/web/http/HttpRequest.java
+++ b/src/main/java/org/deftserver/web/http/HttpRequest.java
@@ -1,7 +1,6 @@
 package org.deftserver.web.http;
 
 import java.nio.ByteBuffer;
-import java.nio.charset.Charset;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.HashMap;
@@ -10,12 +9,11 @@ import java.util.Map;
 import org.deftserver.util.ArrayUtil;
 import org.deftserver.web.HttpVerb;
 
+import com.google.common.base.Charsets;
 import com.google.common.collect.ImmutableMultimap;
 
 public class HttpRequest {
-
-	private final static Charset CHAR_SET = Charset.forName("US-ASCII");
-
+	
 	private final String requestLine;
 	private final HttpVerb method;
 	private final String requestedPath;	// correct name?
@@ -45,7 +43,7 @@ public class HttpRequest {
 	
 	public static HttpRequest of(ByteBuffer buffer) {
 		try {
-			String raw = new String(buffer.array(), CHAR_SET);
+			String raw = new String(buffer.array(), 0, buffer.limit(), Charsets.US_ASCII);
 			String[] headersAndBody = raw.split("\\r\\n\\r\\n"); //TODO fix a better regexp for this
 			String[] headerFields = headersAndBody[0].split("\\r\\n");
 			headerFields = ArrayUtil.dropFromEndWhile(headerFields, "");
@@ -58,16 +56,34 @@ public class HttpRequest {
 			}
 
 			String body = "";
-			for (int i=1; i<headersAndBody.length; ++i) { //First entry contains headers
+			for (int i = 1; i < headersAndBody.length; ++i) { //First entry contains headers
 				body += headersAndBody[i];
 			}
-
+			
+			if (requestLine.contains("POST")) {
+				int contentLength = Integer.parseInt(generalHeaders.get("Content-Length"));
+				if (contentLength > body.length()) {
+					return new PartialHttpRequest(requestLine, generalHeaders, body);
+				}
+			}
 			return new HttpRequest(requestLine, generalHeaders, body);
 		} catch (Exception t) {
 			return MalFormedHttpRequest.instance;
 		}
 	}
-
+	
+	public static HttpRequest continueParsing(ByteBuffer buffer, PartialHttpRequest unfinished) {
+		String nextChunk = new String(buffer.array(), 0, buffer.limit(), Charsets.US_ASCII);
+		unfinished.appendBody(nextChunk);
+		
+		int contentLength = Integer.parseInt(unfinished.getHeader("Content-Length"));
+		if (contentLength > unfinished.getBody().length()) {
+			return unfinished;
+		} else {
+			return new HttpRequest(unfinished.getRequestLine(), unfinished.getHeaders(), unfinished.getBody());
+		}
+	}
+	
 	public String getRequestLine() {
 		return requestLine;
 	}
@@ -177,4 +193,5 @@ public class HttpRequest {
 			keepAlive = true;
 		}
 	}
+
 }
diff --git a/src/main/java/org/deftserver/web/http/PartialHttpRequest.java b/src/main/java/org/deftserver/web/http/PartialHttpRequest.java
new file mode 100644
index 0000000..72a5b2e
--- /dev/null
+++ b/src/main/java/org/deftserver/web/http/PartialHttpRequest.java
@@ -0,0 +1,38 @@
+package org.deftserver.web.http;
+
+import java.util.Map;
+
+
+/**
+ * Represents an unfinished "dummy" HTTP request, e.g, an HTTP POST request where the entire payload hasn't been 
+ * received.
+ * (E.g. because the size of the underlying (OS) socket's read buffer has a fixed size.)
+ * 
+ */
+
+public class PartialHttpRequest extends HttpRequest {
+	
+	private final String requestLine;
+	private String unfinishedBody;
+
+	public PartialHttpRequest(String requestLine, Map<String, String> generalHeaders, String body) {
+		super("POST <> Unfinished request\r\n", generalHeaders);
+		this.requestLine = requestLine;
+		this.unfinishedBody = body;
+	}
+
+	public void appendBody(String nextChunk) {
+		unfinishedBody += nextChunk;
+	}
+	
+	@Override
+	public String getBody() {
+		return unfinishedBody;
+	}
+	
+	@Override
+	public String getRequestLine() {
+		return requestLine;
+	}
+	
+}
diff --git a/src/test/java/org/deftserver/web/DeftSystemTest.java b/src/test/java/org/deftserver/web/DeftSystemTest.java
index 962abb2..02db417 100644
--- a/src/test/java/org/deftserver/web/DeftSystemTest.java
+++ b/src/test/java/org/deftserver/web/DeftSystemTest.java
@@ -50,6 +50,7 @@ import org.junit.Test;
 
 import com.ning.http.client.AsyncCompletionHandler;
 import com.ning.http.client.AsyncHttpClient;
+import com.ning.http.client.Response;
 
 
 public class DeftSystemTest {
@@ -208,7 +209,7 @@ public class DeftSystemTest {
 
 	}
 	
-	public static class _450KBResponseEntityRequestHandlr extends RequestHandler {
+	public static class _450KBResponseEntityRequestHandler extends RequestHandler {
 		public static String entity;
 
 		static {
@@ -223,6 +224,13 @@ public class DeftSystemTest {
 			response.write(entity);
 		}
 	}
+	
+	public static class EchoingPostBodyRequestHandler extends RequestHandler {
+		@Override
+		public void post(HttpRequest request, org.deftserver.web.http.HttpResponse response) {
+			response.write(request.getBody());
+		}
+	}
 
 	@BeforeClass
 	public static void setup() {
@@ -244,7 +252,8 @@ public class DeftSystemTest {
 		reqHandlers.put("/moved_perm", new MovedPermanentlyRequestHandler());
 		reqHandlers.put("/static_file_handler", new UserDefinedStaticContentHandler());
 		reqHandlers.put("/redis", new KeyValueStoreExampleRequestHandler());
-		reqHandlers.put("/450kb_body", new _450KBResponseEntityRequestHandlr());
+		reqHandlers.put("/450kb_body", new _450KBResponseEntityRequestHandler());
+		reqHandlers.put("/echo", new EchoingPostBodyRequestHandler());
 
 		final Application application = new Application(reqHandlers);
 		application.setStaticContentDir("src/test/resources");
@@ -875,7 +884,85 @@ public class DeftSystemTest {
 		//assertEquals(450*1024, Integer.parseInt(response.getFirstHeader("Content-Length").getValue())/8);
 		//assertEquals(450*1024, _450KBResponseEntityRequestHandlr.entity.getBytes(Charsets.UTF_8).length);
 		String payLoad = convertStreamToString(response.getEntity().getContent()).trim();
-		assertEquals(_450KBResponseEntityRequestHandlr.entity, payLoad);
+		assertEquals(_450KBResponseEntityRequestHandler.entity, payLoad);
+	}
+	
+//	@Test
+//	public void smallHttpPostBodyTest() throws ClientProtocolException, IOException {
+//		final String body = "Roger Schildmeijer";
+//		
+//		DefaultHttpClient httpclient = new DefaultHttpClient();
+//		HttpPost httppost = new HttpPost("http://localhost:" + PORT + "/echo");
+//		httppost.setEntity(new StringEntity(body));
+//		HttpResponse response = httpclient.execute(httppost);	
+//		
+//		assertNotNull(response);
+//		assertEquals(200, response.getStatusLine().getStatusCode());
+//		assertEquals(new ProtocolVersion("HTTP", 1, 1), response.getStatusLine().getProtocolVersion());
+//		assertEquals("OK", response.getStatusLine().getReasonPhrase());
+//		assertEquals(5, response.getAllHeaders().length);
+//		String payLoad = convertStreamToString(response.getEntity().getContent()).trim();
+//		assertEquals(body, payLoad);
+//	}
+	
+	@Test
+	public void smallHttpPostBodyTest() throws ClientProtocolException, IOException, InterruptedException {
+		final String body = "Roger Schildmeijer";
+		final CountDownLatch latch = new CountDownLatch(1);
+		AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
+		asyncHttpClient.preparePost("http://localhost:" + PORT + "/echo").setBody(body).
+		execute(new AsyncCompletionHandler<Response>(){
+
+			@Override
+			public Response onCompleted(Response response) throws Exception{
+				assertNotNull(response);
+				assertEquals(200, response.getStatusCode());
+				assertEquals("OK", response.getStatusText());
+				assertEquals(5, response.getHeaders().getHeaderNames().size());
+				String payLoad = response.getResponseBody();
+				assertEquals(body, payLoad);
+				latch.countDown();
+				return response;
+			}
+
+			@Override
+			public void onThrowable(Throwable t) { }
+		});
+
+		latch.await();
+		assertTrue(latch.getCount() == 0);
+	}
+	
+	@Test
+	public void largeHttpPostBodyTest() throws ClientProtocolException, IOException, InterruptedException {
+		String body = "Roger Schildmeijer: 0\n";
+		for (int i = 1; i <= 1000; i++) {
+			body += "Roger Schildmeijer: " + i + "\n";
+		}
+		final String expectedBody = body;
+		final CountDownLatch latch = new CountDownLatch(1);
+		AsyncHttpClient asyncHttpClient = new AsyncHttpClient();
+		asyncHttpClient.preparePost("http://localhost:" + PORT + "/echo").setBody(body).
+		execute(new AsyncCompletionHandler<Response>(){
+
+			@Override
+			public Response onCompleted(Response response) throws Exception{
+				assertNotNull(response);
+				assertEquals(200, response.getStatusCode());
+				assertEquals("OK", response.getStatusText());
+				assertEquals(5, response.getHeaders().getHeaderNames().size());
+				String payLoad = response.getResponseBody();
+				assertEquals(expectedBody, payLoad);
+				latch.countDown();
+				return response;
+			}
+
+			@Override
+			public void onThrowable(Throwable t) { }
+		});
+
+		latch.await();
+		assertTrue(latch.getCount() == 0);
 	}
 
 	public String convertStreamToString(InputStream is) throws IOException {
