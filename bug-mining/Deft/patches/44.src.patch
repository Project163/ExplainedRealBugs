diff --git a/NEWS.txt b/NEWS.txt
index 4a6b8dc..6eec5b8 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -4,6 +4,8 @@
 Features
 --------
     - Asynchronous writes (#63).
+    - Support for third party libraries to work within Deft's IOLoop (#62)
+      (Thanks to github.com/williame and github.com/sris for inspiration and implementation details).
      
 Configuration
 ------------
diff --git a/src/main/java/org/deftserver/example/AsyncDbApi.java b/src/main/java/org/deftserver/example/AsyncDbApi.java
index 15fe0ed..c192ee9 100644
--- a/src/main/java/org/deftserver/example/AsyncDbApi.java
+++ b/src/main/java/org/deftserver/example/AsyncDbApi.java
@@ -1,6 +1,6 @@
 package org.deftserver.example;
 
-import org.deftserver.web.AsyncCallback;
+import org.deftserver.web.AsyncResult;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -13,7 +13,7 @@ public class AsyncDbApi {
 	Logger logger = LoggerFactory.getLogger(AsyncDbApi.class);
 	private final int DELAY = 100;
 	
-	public void getNameFromId(final String id, final AsyncCallback<String> callback) {
+	public void getNameFromId(final String id, final AsyncResult<String> callback) {
 		logger.debug("Getting name from database...");
 		
 		Runnable runnable = new Runnable( ) {
diff --git a/src/main/java/org/deftserver/example/AsyncDbHandler.java b/src/main/java/org/deftserver/example/AsyncDbHandler.java
index df83ecd..e7f3525 100644
--- a/src/main/java/org/deftserver/example/AsyncDbHandler.java
+++ b/src/main/java/org/deftserver/example/AsyncDbHandler.java
@@ -1,6 +1,6 @@
 package org.deftserver.example;
 
-import org.deftserver.web.AsyncCallback;
+import org.deftserver.web.AsyncResult;
 import org.deftserver.web.Asynchronous;
 import org.deftserver.web.handler.RequestHandler;
 import org.deftserver.web.protocol.HttpRequest;
@@ -20,7 +20,7 @@ public class AsyncDbHandler extends RequestHandler{
 	}
 	
 
-	private class MyCallback implements AsyncCallback<String> {
+	private class MyCallback implements AsyncResult<String> {
 
 		HttpRequest request; 
 		HttpResponse response;
diff --git a/src/main/java/org/deftserver/example/DeftServerExample.java b/src/main/java/org/deftserver/example/DeftServerExample.java
index eb3a5be..38b4eed 100644
--- a/src/main/java/org/deftserver/example/DeftServerExample.java
+++ b/src/main/java/org/deftserver/example/DeftServerExample.java
@@ -5,6 +5,7 @@ import java.util.Map;
 
 import org.deftserver.web.Application;
 import org.deftserver.web.HttpServer;
+import org.deftserver.web.IOLoop;
 import org.deftserver.web.handler.RequestHandler;
 import org.deftserver.web.protocol.HttpRequest;
 import org.deftserver.web.protocol.HttpResponse;
@@ -38,7 +39,8 @@ public class DeftServerExample {
 
 		logger.debug("Starting up server on port: " + PORT);
 		HttpServer server = new HttpServer(application);
-		server.listen(PORT).getIOLoop().start();
+		server.listen(PORT);
+		IOLoop.INSTANCE.start();
 	
 	}
 }
diff --git a/src/main/java/org/deftserver/example/kv/Client.java b/src/main/java/org/deftserver/example/kv/Client.java
new file mode 100644
index 0000000..a33851b
--- /dev/null
+++ b/src/main/java/org/deftserver/example/kv/Client.java
@@ -0,0 +1,28 @@
+package org.deftserver.example.kv;
+
+import org.deftserver.io.Timeout;
+import org.deftserver.web.AsyncResult;
+
+public class Client {
+	
+	private final Connection connection;
+	
+		
+	public Client() {
+		Timeout timeout = new Timeout(0, null);
+		connection = new Connection(KeyValueStore.HOST, KeyValueStore.PORT, timeout);
+	}
+
+	public void connect() {
+		connection.connect();
+	}
+	
+//	public void disconnect() {
+//		connection.disconnect();
+//	}
+
+	public void get(String value, AsyncResult<String> cb) {
+		connection.write("GET deft\r\n", cb);
+	}
+
+}
diff --git a/src/main/java/org/deftserver/example/kv/Connection.java b/src/main/java/org/deftserver/example/kv/Connection.java
new file mode 100644
index 0000000..f316939
--- /dev/null
+++ b/src/main/java/org/deftserver/example/kv/Connection.java
@@ -0,0 +1,60 @@
+package org.deftserver.example.kv;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+
+import org.deftserver.io.Timeout;
+import org.deftserver.web.AsyncResult;
+import org.deftserver.web.IOLoop;
+import org.deftserver.web.buffer.DynamicByteBuffer;
+
+import com.google.common.base.Charsets;
+
+public class Connection {
+	
+	//private IOStream iostream;
+	private SocketChannel channel;
+	private final KeyValueStoreIOHandler handler = new KeyValueStoreIOHandler();
+	private final String host;
+	private final int port;
+	private final Timeout timeout;
+
+	public Connection(String host, int port, Timeout timeout) {
+		this.host = host;
+		this.port = port;
+		this.timeout = timeout;
+	}
+
+	public void connect() {
+		try {
+			channel = SocketChannel.open(new InetSocketAddress(host, port));
+			channel.configureBlocking(false);
+		} catch (IOException e) { e.printStackTrace(); }
+		//IOLoop.INSTANCE.addHandler(channel, handler, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
+		//iostream = new IOStream(channel, ioLoop);
+	}
+
+//	public void disconnect() {
+//		iostream.close();
+//	}
+//
+//	
+//	public void readLine(int length, AsyncResult<String> cb) {
+//		this.iostream.read_until("\r\n", cb);
+//	}
+//
+//	public void read(int length, AsyncResult<String> cb) {
+//		this.iostream.read_byte(length, cb);
+//	}
+
+	public void write(String data, AsyncResult<String> cb) {
+		DynamicByteBuffer dbb = DynamicByteBuffer.allocate(1024);
+		dbb.put(data.getBytes(Charsets.UTF_8));
+		SelectionKey key = IOLoop.INSTANCE.addHandler(channel, handler, SelectionKey.OP_WRITE, dbb);
+		handler.addReadCallback(key, cb);
+		//this.iostream.write(data);		
+	}
+
+}
diff --git a/src/main/java/org/deftserver/example/kv/KeyValueStore.java b/src/main/java/org/deftserver/example/kv/KeyValueStore.java
new file mode 100644
index 0000000..f8efb07
--- /dev/null
+++ b/src/main/java/org/deftserver/example/kv/KeyValueStore.java
@@ -0,0 +1,86 @@
+package org.deftserver.example.kv;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.util.HashMap;
+import java.util.Map;
+
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+
+/**
+ * Mocked KeyValueStoreHandler server (accepts a connection and echoes back the input)
+ *
+ */
+public class KeyValueStore extends Thread {
+
+	private final static Logger logger = LoggerFactory.getLogger(KeyValueStore.class);
+
+	public static final String HOST = "127.0.0.1";
+	public static final int PORT = 6379;
+
+	private final static Map<String, String> dict = new HashMap<String, String>() {
+		{ put("deft", "kickass"); }
+	};
+
+	private ServerSocket serverSocket;
+
+	public KeyValueStore() {
+		logger.debug("Initializing KeyValueStore");
+		initialize();
+	}
+
+	public void run() {
+		try {
+			logger.debug("KeyValueStore waiting for clients...");	
+			Socket clientSocket = serverSocket.accept();
+			logger.debug("KeyValueStore client connected...");
+			BufferedWriter os = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));
+			BufferedReader is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
+			String input = is.readLine();
+			if (input.split("\\s+").length == 2) {
+				input = input.split("\\s+")[1];	// "GET deft" => "deft"
+			}
+			logger.debug("KeyValueStore received input: {}", input);
+			if (input != null) {
+				logger.debug("KeyValueStore server sleeps...");
+				try {
+					Thread.sleep(1*500);
+				} catch (InterruptedException e) {
+					e.printStackTrace();
+				}
+				logger.debug("KeyValueStore woke up...");
+				String value = dict.get(input);
+				os.write(value, 0, value.length());
+				logger.debug("KeyValueStore echoed back");
+				os.flush();
+			}
+
+			{	// cleanup
+				try {
+					if (is != null)
+						is.close();
+					if (os != null)
+						os.close();
+					if (clientSocket != null)
+						clientSocket.close();
+				}
+				catch (IOException ignore) {}
+			}
+		} catch (IOException e) { e.printStackTrace(); }
+		logger.debug("Closing KeyValueStore");
+	}
+
+	private void initialize() {
+		try {
+			serverSocket = new ServerSocket(PORT);
+		} catch (IOException e) { e.printStackTrace(); }
+	}
+
+}
diff --git a/src/main/java/org/deftserver/example/kv/KeyValueStoreExample.java b/src/main/java/org/deftserver/example/kv/KeyValueStoreExample.java
new file mode 100644
index 0000000..c540f29
--- /dev/null
+++ b/src/main/java/org/deftserver/example/kv/KeyValueStoreExample.java
@@ -0,0 +1,54 @@
+package org.deftserver.example.kv;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import org.deftserver.web.Application;
+import org.deftserver.web.AsyncResult;
+import org.deftserver.web.Asynchronous;
+import org.deftserver.web.HttpServer;
+import org.deftserver.web.IOLoop;
+import org.deftserver.web.handler.RequestHandler;
+import org.deftserver.web.protocol.HttpRequest;
+import org.deftserver.web.protocol.HttpResponse;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KeyValueStoreExample {
+
+	private final static Logger logger = LoggerFactory.getLogger(KeyValueStoreExample.class);
+	private final static int PORT = 8080;
+	
+	private static class KeyValueStoreExampleRequestHandler extends RequestHandler {
+
+		private final Client client = new Client();
+		
+		public KeyValueStoreExampleRequestHandler() {
+			new KeyValueStore().start();
+			client.connect();
+		}
+		
+		@Override
+		@Asynchronous
+		public void get(HttpRequest request, final HttpResponse response) {
+			client.get("deft", new AsyncResult<String>() {
+				@Override public void onFailure(Throwable caught) { /* ignore */}
+				@Override public void onSuccess(String result) { response.write(result).finish(); }
+			});
+		}
+
+	}
+	
+	public static void main(String[] args) {
+		Map<String, RequestHandler> reqHandlers = new HashMap<String, RequestHandler>();
+		reqHandlers.put("/", new KeyValueStoreExampleRequestHandler());
+		
+		Application application = new Application(reqHandlers);
+
+		logger.debug("Starting up server on port: " + PORT);
+		HttpServer server = new HttpServer(application);
+		server.listen(PORT);
+		IOLoop.INSTANCE.start();
+	}
+
+}
diff --git a/src/main/java/org/deftserver/example/kv/KeyValueStoreIOHandler.java b/src/main/java/org/deftserver/example/kv/KeyValueStoreIOHandler.java
new file mode 100644
index 0000000..d0b1dfd
--- /dev/null
+++ b/src/main/java/org/deftserver/example/kv/KeyValueStoreIOHandler.java
@@ -0,0 +1,83 @@
+package org.deftserver.example.kv;
+
+import java.io.IOException;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+import java.util.Map;
+
+import org.deftserver.util.Closeables;
+import org.deftserver.web.AsyncResult;
+import org.deftserver.web.IOHandler;
+import org.deftserver.web.IOLoop;
+import org.deftserver.web.buffer.DynamicByteBuffer;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.base.Charsets;
+import com.google.common.collect.Maps;
+
+public class KeyValueStoreIOHandler implements IOHandler {
+	
+	private final Logger logger = LoggerFactory.getLogger(KeyValueStoreIOHandler.class);
+	
+	// Read callbacks (callbacks that are supposed to be invoked upon a successful read)
+	private final Map<SelectionKey, AsyncResult<String>> rcbs = Maps.newHashMap();
+
+	@Override
+	public void handleAccept(SelectionKey key) throws IOException {
+//		logger.debug("[KeyValueStoreHandler] handle accept...");
+//		SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
+//		clientChannel.configureBlocking(false);
+//		IOLoop.INSTANCE.addHandler(clientChannel, this, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
+	}
+
+	@Override
+	public void handleRead(SelectionKey key) throws IOException {
+		logger.debug("[KeyValueStoreHandler] handle read...");
+		SocketChannel channel = (SocketChannel) key.channel();
+		ByteBuffer buffer = (ByteBuffer) key.attachment();
+		try {
+			long bytesRead = channel.read(buffer);
+			logger.debug("[KeyValueStoreHandler] read data: {} bytes", bytesRead);
+		} catch (IOException e) {
+			logger.debug("[KeyValueStoreHandler] could not read data: ", e.getMessage());
+			Closeables.closeQuietly(channel);
+		}
+		int length = buffer.position();
+		buffer.flip();
+		String data = new String(buffer.array(), 0, length, Charsets.UTF_8);
+		logger.debug("[KeyValueStoreHandler] KeyValueStore server sent: {}", data);
+		Closeables.closeQuietly(channel);
+		logger.debug("[KeyValueStoreHandler] closed connection to KeyValueStore");
+		if (rcbs.containsKey(key)) {
+			rcbs.get(key).onSuccess(data);
+		}
+	}
+
+	@Override
+	public void handleWrite(SelectionKey key) {
+		logger.debug("[KeyValueStoreHandler] handle write...");
+		DynamicByteBuffer dbb = (DynamicByteBuffer) key.attachment();
+		ByteBuffer toSend = dbb.getByteBuffer();
+		SocketChannel channel = (SocketChannel)key.channel();
+		logger.debug("[KeyValueStoreHandler] about to send: {} bytes", dbb.position());
+		try {
+			toSend.flip();	// prepare for write
+			long bytesWritten = channel.write(toSend);
+			logger.debug("[KeyValueStoreHandler] sent: {} bytes", bytesWritten);
+			if (!toSend.hasRemaining()) {
+			} else {
+				toSend.compact();	// make room for more data be "read" in
+			}
+		} catch (IOException e) {
+			logger.error("[KeyValueStoreHandler] Failed to send data to client: {}", e.getMessage());
+		}
+		IOLoop.INSTANCE.addHandler(channel, this, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
+	}
+	
+	void addReadCallback(SelectionKey key, AsyncResult<String> cb) {
+		rcbs.put(key, cb);
+	}
+
+}
diff --git a/src/main/java/org/deftserver/io/JMXConfigurableTimeoutManager.java b/src/main/java/org/deftserver/io/JMXConfigurableTimeoutManager.java
new file mode 100644
index 0000000..c3c6f3f
--- /dev/null
+++ b/src/main/java/org/deftserver/io/JMXConfigurableTimeoutManager.java
@@ -0,0 +1,30 @@
+package org.deftserver.io;
+
+import java.nio.channels.SelectableChannel;
+
+public class JMXConfigurableTimeoutManager implements TimeoutManager {
+
+	@Override
+	public void addKeepAliveTimeout(SelectableChannel channel, Timeout timeout) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public void addTimeout(Timeout timeout) {
+		// TODO Auto-generated method stub
+		
+	}
+
+	@Override
+	public boolean hasKeepAliveTimeout(SelectableChannel channel) {
+		// TODO Auto-generated method stub
+		return false;
+	}
+
+	@Override
+	public void touch(SelectableChannel channel) {
+		// TODO Auto-generated method stub
+	}
+
+}
diff --git a/src/main/java/org/deftserver/io/Timeout.java b/src/main/java/org/deftserver/io/Timeout.java
new file mode 100644
index 0000000..a052cf1
--- /dev/null
+++ b/src/main/java/org/deftserver/io/Timeout.java
@@ -0,0 +1,23 @@
+package org.deftserver.io;
+
+import org.deftserver.web.AsyncCallback;
+
+public class Timeout {
+
+	private final long timeout;
+	private final AsyncCallback cb;
+
+	public Timeout(long timeout, AsyncCallback cb) {
+		this.timeout = timeout;
+		this.cb = cb;
+	}
+
+	public long getTimeout() {
+		return timeout;
+	}
+
+	public AsyncCallback getCallback() {
+		return cb;
+	}
+
+}
diff --git a/src/main/java/org/deftserver/io/TimeoutManager.java b/src/main/java/org/deftserver/io/TimeoutManager.java
new file mode 100644
index 0000000..3e23cad
--- /dev/null
+++ b/src/main/java/org/deftserver/io/TimeoutManager.java
@@ -0,0 +1,15 @@
+package org.deftserver.io;
+
+import java.nio.channels.SelectableChannel;
+
+public interface TimeoutManager {
+
+	void addTimeout(Timeout timeout);
+	
+	void addKeepAliveTimeout(SelectableChannel channel, Timeout timeout);
+	
+	boolean hasKeepAliveTimeout(SelectableChannel channel);
+	
+	void touch(SelectableChannel channel); 
+	
+}
diff --git a/src/main/java/org/deftserver/util/Closeables.java b/src/main/java/org/deftserver/util/Closeables.java
new file mode 100644
index 0000000..7c59f6c
--- /dev/null
+++ b/src/main/java/org/deftserver/util/Closeables.java
@@ -0,0 +1,19 @@
+package org.deftserver.util;
+
+import java.io.IOException;
+import java.nio.channels.SelectableChannel;
+
+import org.deftserver.web.IOLoop;
+
+public class Closeables {
+
+	private Closeables() {}
+
+	public static void closeQuietly(SelectableChannel channel) {
+		try {
+			IOLoop.INSTANCE.removeHandler(channel);
+			com.google.common.io.Closeables.close(channel, true);
+		} catch (IOException ignore) { }
+	}
+
+}
diff --git a/src/main/java/org/deftserver/util/TimeoutFactory.java b/src/main/java/org/deftserver/util/TimeoutFactory.java
new file mode 100644
index 0000000..f7db99b
--- /dev/null
+++ b/src/main/java/org/deftserver/util/TimeoutFactory.java
@@ -0,0 +1,21 @@
+package org.deftserver.util;
+
+import java.nio.channels.SocketChannel;
+
+import org.deftserver.io.Timeout;
+import org.deftserver.web.AsyncCallback;
+
+public class TimeoutFactory {
+
+	public static Timeout keepAliveTimeout(final SocketChannel clientChannel, long keepAliveTimeout) {
+		return new Timeout(
+				System.currentTimeMillis() + keepAliveTimeout,
+				new AsyncCallback() {
+					
+					@Override public void onCallback() { Closeables.closeQuietly(clientChannel); }
+				
+				}
+		);
+	}
+	
+}
diff --git a/src/main/java/org/deftserver/web/AsyncCallback.java b/src/main/java/org/deftserver/web/AsyncCallback.java
index 50a624c..1aab68f 100644
--- a/src/main/java/org/deftserver/web/AsyncCallback.java
+++ b/src/main/java/org/deftserver/web/AsyncCallback.java
@@ -1,23 +1,12 @@
-package org.deftserver.web;
-
-/**
-*	The generic interface a caller must implement to receive a response from an
-* 	async call
-*/
-public interface AsyncCallback<T> {
-	
-    /**
-     * The asynchronous call failed to complete normally.
-     * 
-     * @param caught failure encountered while executing an async operation
-     */
-    void onFailure(Throwable caught);
-
-    /**
-     * Called when an asynchronous call completes successfully.
-     * 
-     * @param result return value of the async call
-     */
-    void onSuccess(T result);
-	
-}
+package org.deftserver.web;
+
+
+/**
+*	The generic interface a caller must implement to receive an arbitrary callback from an
+* 	async call (similar to {@link AsyncResult}).
+*/
+public interface AsyncCallback {
+
+	void onCallback();
+	
+}
diff --git a/src/main/java/org/deftserver/web/AsyncResult.java b/src/main/java/org/deftserver/web/AsyncResult.java
new file mode 100644
index 0000000..b7a78e7
--- /dev/null
+++ b/src/main/java/org/deftserver/web/AsyncResult.java
@@ -0,0 +1,23 @@
+package org.deftserver.web;
+
+/**
+*	The generic interface a caller must implement to receive a result from an
+* 	async call
+*/
+public interface AsyncResult<T> {
+	
+    /**
+     * The asynchronous call failed to complete normally.
+     * 
+     * @param caught failure encountered while executing an async operation
+     */
+    void onFailure(Throwable caught);
+
+    /**
+     * Called when an asynchronous call completes successfully.
+     * 
+     * @param result return value of the async call
+     */
+    void onSuccess(T result);
+	
+}
diff --git a/src/main/java/org/deftserver/web/HttpServer.java b/src/main/java/org/deftserver/web/HttpServer.java
index d5d947d..ee37623 100644
--- a/src/main/java/org/deftserver/web/HttpServer.java
+++ b/src/main/java/org/deftserver/web/HttpServer.java
@@ -1,34 +1,59 @@
 package org.deftserver.web;
 
-import org.deftserver.web.protocol.HttpProtocol;
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.ServerSocketChannel;
 
+import org.deftserver.web.protocol.HttpProtocol;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
 
 public class HttpServer {
 	
+	private final Logger logger = LoggerFactory.getLogger(HttpServer.class);
+	
 	private static final int MIN_PORT_NUMBER = 1;
 	private static final int MAX_PORT_NUMBER = 65535;
-
-	private final IOLoop ioLoop;
 	
-	public HttpServer(Application application) {
-		ioLoop = new IOLoop(new HttpProtocol(application));
-	}
+	private ServerSocketChannel serverChannel;
+	
+	private final IOHandler protocol;
 
-	public IOLoop getIOLoop() {
-		return ioLoop;
+	public HttpServer(Application application) {
+		protocol = new HttpProtocol(application);
+		try {
+			serverChannel = ServerSocketChannel.open();
+			serverChannel.configureBlocking(false);
+		} catch (IOException e) {
+			logger.error("Error creating ServerSocketChannel: {}", e);
+		}
 	}
 
 	/**
 	 * @return this for chaining purposes
 	 */
-	public HttpServer listen(int port) {
+	public void listen(int port) {
 		if (port <= MIN_PORT_NUMBER || port > MAX_PORT_NUMBER) {
 			throw new IllegalArgumentException("Invalid port number. Valid range: [" + 
 					MIN_PORT_NUMBER + ", " + MAX_PORT_NUMBER + ")");
 		}
-		
-		ioLoop.listen(port);
-		return this;
+		InetSocketAddress endpoint = new InetSocketAddress(port);	// use "any" address
+		try {
+			serverChannel.socket().bind(endpoint);
+		} catch (IOException e) {
+			logger.error("Could not bind socket: {}", e);
+		}
+		registerHandler();
+	}
+	
+	private void registerHandler() {
+		IOLoop.INSTANCE.addHandler(
+				serverChannel,
+				protocol, 
+				SelectionKey.OP_ACCEPT,
+				null /*attachment*/
+		);
 	}
 
 }
diff --git a/src/main/java/org/deftserver/web/protocol/Protocol.java b/src/main/java/org/deftserver/web/IOHandler.java
similarity index 68%
rename from src/main/java/org/deftserver/web/protocol/Protocol.java
rename to src/main/java/org/deftserver/web/IOHandler.java
index bfe3289..2360833 100644
--- a/src/main/java/org/deftserver/web/protocol/Protocol.java
+++ b/src/main/java/org/deftserver/web/IOHandler.java
@@ -1,13 +1,19 @@
-package org.deftserver.web.protocol;
+package org.deftserver.web;
 
 import java.io.IOException;
 import java.nio.channels.SelectionKey;
 
-public interface Protocol {
+
+/**
+ * TODO RS 101024 Add javadoc 
+ *
+ */
+public interface IOHandler {
 
 	void handleAccept(SelectionKey key) throws IOException;
+	
 	void handleRead(SelectionKey key) throws IOException;
+	
 	void handleWrite(SelectionKey key);
-	void handleCallback();
 	
 }
diff --git a/src/main/java/org/deftserver/web/IOLoop.java b/src/main/java/org/deftserver/web/IOLoop.java
index c36e392..e00ec84 100644
--- a/src/main/java/org/deftserver/web/IOLoop.java
+++ b/src/main/java/org/deftserver/web/IOLoop.java
@@ -1,68 +1,71 @@
 package org.deftserver.web;
 
 import java.io.IOException;
-import java.net.InetSocketAddress;
 import java.nio.channels.ClosedChannelException;
+import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.Selector;
-import java.nio.channels.ServerSocketChannel;
 import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
 
-import org.deftserver.web.protocol.Protocol;
+import org.deftserver.io.Timeout;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-public class IOLoop {
+import com.google.common.collect.Lists;
+import com.google.common.collect.Maps;
+
+public enum IOLoop {
+	
+	INSTANCE;
 	
-	private final static Logger logger = LoggerFactory.getLogger(IOLoop.class);
+	private final Logger logger = LoggerFactory.getLogger(IOLoop.class);
 
 	private static final long TIMEOUT = 250;	// 0.25s in ms
-	private static final long CALLBACK_PERIOD = 2 * 1000;	//2s in ms
+	private static final long TIMEOUT_CALLBACK_PERIOD = 2 * 1000;	//2s in ms
 
-	private final Protocol protocol;
-	private ServerSocketChannel channel;
 	private Selector selector;
-	private long lastCallback;
+	private long lastTimeout;
 	
-
-	protected IOLoop(Protocol protocol) {
-		this.protocol = protocol;
+	private final Map<SelectableChannel, IOHandler> handlers = Maps.newHashMap();
+	private final List<Timeout> timeouts = Lists.newLinkedList();
+	private final Map<SelectableChannel, Timeout> keepAliveTimeouts = Maps.newHashMap();
+	
+	private IOLoop() {
 		try {
-			channel = ServerSocketChannel.open();
-			channel.configureBlocking(false);
 			selector = Selector.open();
 		} catch (IOException e) {
-			logger.error("Error creating ServerSocketChannel: {}", e);
+			logger.error("Could not open selector: {}", e.getMessage());
 		}
 	}
-
+	
 	public void start() {
 		Thread.currentThread().setName("I/O-LOOP");
-		//Thread.currentThread().setPriority(Thread.MAX_PRIORITY);
 
-		registerSelector();
 		while (true) {
 			try {
 				if (selector.select(TIMEOUT) == 0) {
-					invokeCallback();
+					invokeTimeouts();
 					continue;
 				}
 
 				Iterator<SelectionKey> keys = selector.selectedKeys().iterator();
 				while (keys.hasNext()) {
 					SelectionKey key = keys.next();
+					IOHandler handler = handlers.get(key.channel());
 					if (key.isAcceptable()) {
-						protocol.handleAccept(key);
+						handler.handleAccept(key);
 					}
 					if (key.isReadable()) {
-						protocol.handleRead(key);
+						handler.handleRead(key);
 					}
 					if (key.isValid() && key.isWritable()) {
-						protocol.handleWrite(key);
+						handler.handleWrite(key);
 					}
 					keys.remove();
 				}
-				invokeCallback();
+				invokeTimeouts();
 
 			} catch (IOException e) {
 				logger.error("Exception received in IOLoop: {}", e);			
@@ -70,29 +73,68 @@ public class IOLoop {
 		}
 	}
 
-	private void invokeCallback() {
+	private void invokeTimeouts() {
 		long now = System.currentTimeMillis();
-		if (now >= lastCallback + CALLBACK_PERIOD) {
-			protocol.handleCallback();
-			lastCallback = now;
+		if (now >= lastTimeout + TIMEOUT_CALLBACK_PERIOD) {
+			Iterator<Timeout> iter = timeouts.iterator();
+			while (iter.hasNext()) {
+				Timeout candidate = iter.next();
+				if (candidate.getTimeout() <= now) {
+					candidate.getCallback().onCallback();
+					iter.remove();
+					logger.debug("generic timeout triggered: {}", candidate);
+				}
+			}
+		
+			iter = keepAliveTimeouts.values().iterator();
+			while (iter.hasNext()) {
+				Timeout candidate = iter.next();
+				if (candidate.getTimeout() <= now) {
+					candidate.getCallback().onCallback();
+					iter.remove();
+					logger.debug("keep-alive timeout triggered: {}", candidate);
+				}
+			}
+
+			lastTimeout = now;
 		}
 	}
 
-	protected void listen(int port) {
-		InetSocketAddress endpoint = new InetSocketAddress(port);	// use "any" address
-		try {
-			channel.socket().bind(endpoint);
-		} catch (IOException e) {
-			logger.error("Could not bind socket: {}", e);
-		}
+	public SelectionKey addHandler(SelectableChannel channel, IOHandler handler, int interestOps, Object attachment) {
+		handlers.put(channel, handler);
+		return registerChannel(channel, interestOps, attachment);		
+	}
+	
+	public void removeHandler(SelectableChannel channel) {
+		handlers.remove(channel);
+	}
+	
+	public void addTimeout(Timeout timeout) {
+		logger.debug("added generic timeout: {}", timeout);
+		timeouts.add(timeout);
 	}
+	
+	public void addKeepAliveTimeout(SelectableChannel channel, Timeout timeout) {
+		logger.debug("added keep-alive timeout: {}", timeout);
+		keepAliveTimeouts.put(channel, timeout);
+	}
+	
+	public boolean hasKeepAliveTimeout(SelectableChannel channel) {
+		return keepAliveTimeouts.containsKey(channel);
+	}
+	
+//	public <T> void addCallback(AsyncResult<T> cb) {
+//		// TODO RS 101022 store this timeout 
+//	}
 
-	private void registerSelector() {
+	private SelectionKey registerChannel(SelectableChannel channel, int interestOps, Object attachment) {
 		try {
-			channel.register(selector, SelectionKey.OP_ACCEPT);
+			return channel.register(selector, interestOps, attachment);
 		} catch (ClosedChannelException e) {
-			logger.error("Could not register selector: {}", e);		
+			removeHandler(channel);
+			logger.error("Could not register channel: {}", e.getMessage());		
 		}		
+		return null;
 	}
 
 }
diff --git a/src/main/java/org/deftserver/web/protocol/HttpProtocol.java b/src/main/java/org/deftserver/web/protocol/HttpProtocol.java
index 43288f7..bd0687a 100644
--- a/src/main/java/org/deftserver/web/protocol/HttpProtocol.java
+++ b/src/main/java/org/deftserver/web/protocol/HttpProtocol.java
@@ -3,42 +3,32 @@ package org.deftserver.web.protocol;
 import java.io.File;
 import java.io.IOException;
 import java.io.RandomAccessFile;
-import java.lang.management.ManagementFactory;
 import java.nio.ByteBuffer;
 import java.nio.channels.ClosedChannelException;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.ServerSocketChannel;
 import java.nio.channels.SocketChannel;
-import java.util.HashMap;
-import java.util.Iterator;
 import java.util.Map;
-import java.util.Map.Entry;
-
-import javax.management.MBeanServer;
-import javax.management.ObjectName;
 
+import org.deftserver.util.Closeables;
+import org.deftserver.util.TimeoutFactory;
 import org.deftserver.web.Application;
+import org.deftserver.web.IOHandler;
+import org.deftserver.web.IOLoop;
 import org.deftserver.web.buffer.DynamicByteBuffer;
 import org.deftserver.web.handler.RequestHandler;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.google.common.collect.Maps;
-import com.google.common.io.Closeables;
 
-public class HttpProtocol implements Protocol, HttpProtocolMXBean {
+public class HttpProtocol implements IOHandler {
 	
 	private final static Logger logger = LoggerFactory.getLogger(HttpProtocol.class);
 
 	/** The number of seconds Deft will wait for a subsequent request before closing the connection */
 	private final static long KEEP_ALIVE_TIMEOUT = 30 * 1000;	// 30s 
 	
-	/** All {@link SocketChannel} connections where request header "Connection: Close" is missing. 
-	 * ("In HTTP 1.1 all connections are considered persistent, unless declared otherwise")
-	 * The value associated with each {@link SocketChannel} is the connection expiration time in ms.
-	 */
-	private final Map<SocketChannel, Long> persistentConnections = new HashMap<SocketChannel, Long>();
-	
 	private final Map<SelectionKey, File> stagedFiles = Maps.newHashMap();
 	private final int readBufferSize;
 
@@ -47,19 +37,6 @@ public class HttpProtocol implements Protocol, HttpProtocolMXBean {
 	public HttpProtocol(Application app) {
 		application = app;
 		readBufferSize = app.getReadBufferSize();
-		registerMXBean();
-	}
-	
-
-	private void registerMXBean() {
-		MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
-        String mbeanName = "org.deftserver.web.protocol:type=HttpProtocol";
-        try {
-            mbs.registerMBean(this, new ObjectName(mbeanName));
-        }
-        catch (Exception e) {
-            logger.error("Unable to register {} MXBean", this.getClass().getCanonicalName());
-        }
 	}
 	
 	@Override
@@ -67,7 +44,7 @@ public class HttpProtocol implements Protocol, HttpProtocolMXBean {
 		logger.debug("handle accept...");
 		SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
 		clientChannel.configureBlocking(false);
-		clientChannel.register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(readBufferSize));
+		IOLoop.INSTANCE.addHandler(clientChannel, this, SelectionKey.OP_READ, ByteBuffer.allocate(readBufferSize));
 	}
 
 	@Override
@@ -77,7 +54,11 @@ public class HttpProtocol implements Protocol, HttpProtocolMXBean {
 		HttpRequest request = getHttpRequest(key, clientChannel);
 		
 		if (request.isKeepAlive()) {
-			persistentConnections.put(clientChannel, System.currentTimeMillis() + KEEP_ALIVE_TIMEOUT);
+			//persistentConnections.add(clientChannel);
+			IOLoop.INSTANCE.addKeepAliveTimeout(
+					clientChannel, 
+					TimeoutFactory.keepAliveTimeout(clientChannel, KEEP_ALIVE_TIMEOUT)
+			);
 		}
 		HttpResponse response = new HttpResponse(this, key, request.isKeepAlive());
 		RequestHandler rh = application.getHandler(request);
@@ -122,7 +103,7 @@ public class HttpProtocol implements Protocol, HttpProtocolMXBean {
 	}
 	
 	private void closeOrRegisterForRead(SelectionKey key) {
-		if (persistentConnections.containsKey(key.channel())) {
+		if (IOLoop.INSTANCE.hasKeepAliveTimeout(key.channel())) {
 			try {
 				key.channel().register(key.selector(), SelectionKey.OP_READ, ByteBuffer.allocate(readBufferSize));
 				logger.debug("keep-alive connection. registrating for read.");
@@ -150,41 +131,6 @@ public class HttpProtocol implements Protocol, HttpProtocolMXBean {
 		return HttpRequest.of(buffer);
 	}
 	
-	public void handleCallback() {
-		long now = System.currentTimeMillis();
-		Iterator<Entry<SocketChannel, Long>> iter = persistentConnections.entrySet().iterator();
-		while (iter.hasNext()) {
-			Entry<SocketChannel, Long> candidate = iter.next();
-			long expires = candidate.getValue();
-			if (now >= expires) {
-				logger.debug("Closing expired keep-alive connection");
-				Closeables.closeQuietly(candidate.getKey());
-				iter.remove();
-			}
-		}
-	}
-
-	@Override
-	public int getPersistentConnections() {
-		return persistentConnections.size();
-	}
-
-	/**
-	 * Staging data to be written to wire.
-	 * 
-	 * @param key
-	 * @param responseData
-	 */
-//	public void stage(SelectionKey key, ByteBuffer responseData) {
-//		List<ByteBuffer> pending = stagedData.get(key);
-//		if (pending == null) {
-//			pending = new LinkedList<ByteBuffer>();
-//			stagedData.put(key, pending);
-//		}
-//		pending.add(responseData);
-//	}
-
-
 	public void stage(SelectionKey key, File file) {
 		stagedFiles.put(key, file);
 	}
diff --git a/src/main/java/org/deftserver/web/protocol/HttpProtocolMXBean.java b/src/main/java/org/deftserver/web/protocol/HttpProtocolMXBean.java
deleted file mode 100644
index 1177ada..0000000
--- a/src/main/java/org/deftserver/web/protocol/HttpProtocolMXBean.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package org.deftserver.web.protocol;
-
-public interface HttpProtocolMXBean {
-		
-	int getPersistentConnections();
-	
-}
diff --git a/src/main/java/org/deftserver/web/protocol/HttpResponse.java b/src/main/java/org/deftserver/web/protocol/HttpResponse.java
index bba373a..1e81c82 100644
--- a/src/main/java/org/deftserver/web/protocol/HttpResponse.java
+++ b/src/main/java/org/deftserver/web/protocol/HttpResponse.java
@@ -7,6 +7,7 @@ import java.nio.channels.SocketChannel;
 import java.util.HashMap;
 import java.util.Map;
 
+import org.deftserver.util.Closeables;
 import org.deftserver.util.DateUtil;
 import org.deftserver.util.HttpUtil;
 import org.deftserver.web.buffer.DynamicByteBuffer;
@@ -14,7 +15,6 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.google.common.base.Charsets;
-import com.google.common.io.Closeables;
 
 public class HttpResponse {
 	
diff --git a/src/test/java/org/deftserver/io/TimeoutTest.java b/src/test/java/org/deftserver/io/TimeoutTest.java
new file mode 100644
index 0000000..7f25959
--- /dev/null
+++ b/src/test/java/org/deftserver/io/TimeoutTest.java
@@ -0,0 +1,22 @@
+package org.deftserver.io;
+
+import static org.junit.Assert.assertEquals;
+
+import org.deftserver.web.AsyncCallback;
+import org.junit.Test;
+
+public class TimeoutTest {
+
+	@Test
+	public void simpleTimeoutConstructorTest() {
+		final AsyncCallback cb = new AsyncCallback() {
+			@Override public void onCallback() {}
+		};
+		
+		Timeout t = new Timeout(1492, cb);
+
+		assertEquals(1492, t.getTimeout());
+		assertEquals(cb, t.getCallback());
+	}
+	
+}
diff --git a/src/test/java/org/deftserver/web/DeftSystemTest.java b/src/test/java/org/deftserver/web/DeftSystemTest.java
index 8f86b49..9369a0d 100644
--- a/src/test/java/org/deftserver/web/DeftSystemTest.java
+++ b/src/test/java/org/deftserver/web/DeftSystemTest.java
@@ -38,6 +38,9 @@ import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.deftserver.example.AsyncDbHandler;
+import org.deftserver.example.kv.Client;
+import org.deftserver.example.kv.KeyValueStore;
+import org.deftserver.io.Timeout;
 import org.deftserver.web.handler.RequestHandler;
 import org.deftserver.web.protocol.HttpException;
 import org.deftserver.web.protocol.HttpRequest;
@@ -166,6 +169,26 @@ public class DeftSystemTest {
 			response.write(new File("src/test/resources/test.txt"));
 		}
 	}
+	
+	public static class KeyValueStoreExampleRequestHandler extends RequestHandler {
+
+		private final Client client = new Client();
+		
+		public KeyValueStoreExampleRequestHandler() {
+			new KeyValueStore().start();
+			client.connect();
+		}
+		
+		@Override
+		@Asynchronous
+		public void get(HttpRequest request, final org.deftserver.web.protocol.HttpResponse response) {
+			client.get("deft", new AsyncResult<String>() {
+				@Override public void onFailure(Throwable caught) { /* ignore */}
+				@Override public void onSuccess(String result) { response.write(result).finish(); }
+			});
+		}
+
+	}
 
 	@BeforeClass
 	public static void setup() {
@@ -185,6 +208,7 @@ public class DeftSystemTest {
 		reqHandlers.put("/no_body", new NoBodyRequestHandler());
 		reqHandlers.put("/moved_perm", new MovedPermanentlyRequestHandler());
 		reqHandlers.put("/static_file_handler", new UserDefinedStaticContentHandler());
+		reqHandlers.put("/redis", new KeyValueStoreExampleRequestHandler());
 
 		final Application application = new Application(reqHandlers);
 		application.setStaticContentDir("src/test/resources");
@@ -192,7 +216,9 @@ public class DeftSystemTest {
 		// start deft instance from a new thread because the start invocation is blocking 
 		// (invoking thread will be I/O loop thread)
 		new Thread(new Runnable() {
-			@Override public void run() { new HttpServer(application).listen(PORT).getIOLoop().start(); }
+			@Override public void run() { 
+				new HttpServer(application).listen(PORT);
+				IOLoop.INSTANCE.start(); }
 		}).start();
 	}
 
@@ -644,6 +670,46 @@ public class DeftSystemTest {
 		assertEquals(4, response.getAllHeaders().length);
 		assertEquals("8", response.getFirstHeader("Content-Length").getValue());
 	}
+	
+	@Test
+	public void timeoutTest() throws InterruptedException {
+		long now = System.currentTimeMillis();
+		final CountDownLatch latch = new CountDownLatch(5);
+		final AsyncCallback cb = new AsyncCallback() {
+
+			@Override public void onCallback() { latch.countDown(); }
+			
+		};
+			
+		Timeout t1 = new Timeout(now+1000, cb);
+		Timeout t2 = new Timeout(now+1200, cb);
+		Timeout t3 = new Timeout(now+1400, cb);
+		Timeout t4 = new Timeout(now+1600, cb);
+		Timeout t5 = new Timeout(now+1800, cb);
+		IOLoop.INSTANCE.addTimeout(t1);
+		IOLoop.INSTANCE.addTimeout(t2);
+		IOLoop.INSTANCE.addTimeout(t3);
+		IOLoop.INSTANCE.addTimeout(t4);
+		IOLoop.INSTANCE.addTimeout(t5);
+		
+		latch.await(5 * 1000, TimeUnit.MILLISECONDS);
+		assertTrue(latch.getCount() == 0);
+	}
+	
+	@Test
+	public void keyValueStoreClientTest() throws ClientProtocolException, IOException {
+		DefaultHttpClient httpclient = new DefaultHttpClient();
+		HttpGet httpget = new HttpGet("http://localhost:" + PORT + "/redis");
+		HttpResponse response = httpclient.execute(httpget);
+
+		assertNotNull(response);
+		assertEquals(200, response.getStatusLine().getStatusCode());
+		assertEquals(new ProtocolVersion("HTTP", 1, 1), response.getStatusLine().getProtocolVersion());
+		assertEquals("OK", response.getStatusLine().getReasonPhrase());
+		assertEquals(5, response.getAllHeaders().length);
+		assertEquals("7", response.getFirstHeader("Content-Length").getValue());
+		assertEquals("kickass", convertStreamToString(response.getEntity().getContent()).trim());
+	}
 
 	public String convertStreamToString(InputStream is) throws IOException {
 		if (is != null) {
