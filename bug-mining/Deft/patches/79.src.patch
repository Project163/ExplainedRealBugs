diff --git a/src/main/java/org/deftserver/io/AsynchronousSocket.java b/src/main/java/org/deftserver/io/AsynchronousSocket.java
index 57e69c4..3ded081 100644
--- a/src/main/java/org/deftserver/io/AsynchronousSocket.java
+++ b/src/main/java/org/deftserver/io/AsynchronousSocket.java
@@ -2,11 +2,13 @@ package org.deftserver.io;
 
 import java.io.EOFException;
 import java.io.IOException;
+import java.net.ConnectException;
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.SelectableChannel;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.SocketChannel;
+import java.nio.channels.UnresolvedAddressException;
 
 import org.deftserver.util.Closeables;
 import org.deftserver.util.NopAsyncResult;
@@ -23,7 +25,8 @@ public class AsynchronousSocket implements IOHandler {
 	
 	private final int DEFAULT_BYTEBUFFER_SIZE = 1024;
 	
-	private final AsyncResult<String> nopAsyncResult = NopAsyncResult.of(String.class).nopAsyncResult;
+	private final AsyncResult<String> nopAsyncStringResult = NopAsyncResult.of(String.class).nopAsyncResult;
+	private final AsyncResult<Boolean> nopAsyncBooleanResult = NopAsyncResult.of(Boolean.class).nopAsyncResult;
 	
 	private final SelectableChannel channel;
 	private int interestOps;
@@ -31,9 +34,9 @@ public class AsynchronousSocket implements IOHandler {
 	private String readDelimiter = "";
 	private int readBytes = Integer.MAX_VALUE;
 	
-	private AsyncCallback connectCallback = AsyncCallback.nopCb;
+	private AsyncResult<Boolean> connectCallback = nopAsyncBooleanResult;
 	private AsyncCallback closeCallback = AsyncCallback.nopCb;
-	private AsyncResult<String> readCallback = nopAsyncResult;
+	private AsyncResult<String> readCallback = nopAsyncStringResult;
 	private AsyncCallback writeCallback = AsyncCallback.nopCb;
 	
 	private final StringBuilder readBuffer = new StringBuilder();
@@ -53,7 +56,7 @@ public class AsynchronousSocket implements IOHandler {
 	/**
 	 * Connects to the given host port tuple and invokes the given callback when a successful connection is established.
 	 */
-	public void connect(String host, int port, AsyncCallback ccb) {
+	public void connect(String host, int port, AsyncResult<Boolean> ccb) {
 		IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_CONNECT);
 		connectCallback = ccb;
 		if (channel instanceof SocketChannel) {
@@ -61,6 +64,10 @@ public class AsynchronousSocket implements IOHandler {
 				((SocketChannel) channel).connect(new InetSocketAddress(host, port));
 			} catch (IOException e) {
 				logger.error("Failed to connect to: {}, message: {} ", host, e.getMessage());
+				invokeConnectFailureCallback(e);
+			} catch (UnresolvedAddressException e) {
+				logger.warn("Unresolvable host: {}", host);
+				invokeConnectFailureCallback(e);
 			}
 		}
 	}
@@ -91,11 +98,17 @@ public class AsynchronousSocket implements IOHandler {
 	@Override
 	public void handleConnect(SelectionKey key) throws IOException {
 		logger.debug("handle connect...");
-		if (((SocketChannel) channel).isConnectionPending()) {
-			((SocketChannel) channel).finishConnect();
-			invokeConnectCallback();
-			interestOps &= ~SelectionKey.OP_CONNECT;
-			IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_READ);
+		SocketChannel sc = (SocketChannel) channel;
+		if (sc.isConnectionPending()) {
+			try {
+				sc.finishConnect();
+				invokeConnectSuccessfulCallback();
+				interestOps &= ~SelectionKey.OP_CONNECT;
+				IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_READ);
+			} catch (ConnectException e) {
+				logger.warn("Connect failed: {}", e.getMessage());
+				invokeConnectFailureCallback(e);
+			}
 		}
 	}
 	
@@ -176,13 +189,13 @@ public class AsynchronousSocket implements IOHandler {
 
 	private void invokeReadSuccessfulCallback(String result) {
 		AsyncResult<String> cb = readCallback;
-		readCallback = nopAsyncResult;
+		readCallback = nopAsyncStringResult;
 		cb.onSuccess(result);
 	}
 	
 	private void invokeReadFailureCallback(Exception e) {
 		AsyncResult<String> cb = readCallback;
-		readCallback = nopAsyncResult;
+		readCallback = nopAsyncStringResult;
 		cb.onFailure(e);
 	}
 	
@@ -198,10 +211,16 @@ public class AsynchronousSocket implements IOHandler {
 		cb.onCallback();
 	}
 	
-	private void invokeConnectCallback() {
-		AsyncCallback cb = connectCallback;
-		connectCallback = AsyncCallback.nopCb;
-		cb.onCallback();
+	private void invokeConnectSuccessfulCallback() {
+		AsyncResult<Boolean> cb = connectCallback;
+		connectCallback = nopAsyncBooleanResult;
+		cb.onSuccess(true);
+	}
+	
+	private void invokeConnectFailureCallback(Exception e) {
+		AsyncResult<Boolean> cb = connectCallback;
+		connectCallback = nopAsyncBooleanResult;
+		cb.onFailure(e);;
 	}
 
 	/**
diff --git a/src/main/java/org/deftserver/io/IOLoop.java b/src/main/java/org/deftserver/io/IOLoop.java
index 84aa5a3..3fbf314 100644
--- a/src/main/java/org/deftserver/io/IOLoop.java
+++ b/src/main/java/org/deftserver/io/IOLoop.java
@@ -78,7 +78,7 @@ public enum IOLoop implements IOLoopMXBean {
 					if (key.isConnectable()) {
 						handler.handleConnect(key);
 					}
-					if (key.isReadable()) {
+					if (key.isValid() && key.isReadable()) {
 						handler.handleRead(key);
 					}
 					if (key.isValid() && key.isWritable()) {
diff --git a/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java b/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
index c77c2f4..3dcbcb2 100644
--- a/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
+++ b/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
@@ -25,6 +25,7 @@ public class AsynchronousHttpClient {
 	private AsynchronousSocket socket;
 	
 	private HttpRequest request;
+	private long requestStarted;
 	private HttpResponse response;
 	private AsyncResult<HttpResponse> responseCallback;
 	
@@ -54,6 +55,7 @@ public class AsynchronousHttpClient {
 	}
 	
 	private void doFetch(AsyncResult<HttpResponse> cb) {
+		requestStarted = System.currentTimeMillis();
 		try {
 			socket = new AsynchronousSocket(SocketChannel.open().configureBlocking(false));
 		} catch (IOException e) {
@@ -64,8 +66,11 @@ public class AsynchronousHttpClient {
 		port = port == -1 ? 80 : port;
 		socket.connect(
 				request.getURL().getHost(), 
-				port, 
-				new AsyncCallback() { public void onCallback() { onConnect(); }}
+				port,
+				new AsyncResult<Boolean>() {
+					public void onFailure(Throwable t) { responseCallback.onFailure(t); }
+					public void onSuccess(Boolean result) { onConnect(); }
+				}
 		);
 		startTimeout();
 	}
@@ -135,7 +140,7 @@ public class AsynchronousHttpClient {
 	private void onHeaders(String result) {
 		logger.debug("headers: {}", result);
 		cancelTimeout();
-		response = new HttpResponse();
+		response = new HttpResponse(requestStarted);
 		String[] headers = result.split("\r\n");
 		response.setStatuLine(headers[0]);	// first entry contains status line (e.g. HTTP/1.1 200 OK)
 		for (int i = 1; i < headers.length; i++) {
diff --git a/src/main/java/org/deftserver/web/http/client/HttpResponse.java b/src/main/java/org/deftserver/web/http/client/HttpResponse.java
index 19f0f93..d7fd079 100644
--- a/src/main/java/org/deftserver/web/http/client/HttpResponse.java
+++ b/src/main/java/org/deftserver/web/http/client/HttpResponse.java
@@ -6,6 +6,12 @@ import com.google.common.collect.Maps;
 
 public class HttpResponse {
 	
+	private final long requestTime;
+	
+	public HttpResponse(long requestStarted) {
+		requestTime = System.currentTimeMillis() - requestStarted;
+	}
+	
 	private String statusLine;
 	private final Map<String, String> headers = Maps.newHashMap();
 	private String body;
@@ -34,10 +40,17 @@ public class HttpResponse {
 		return body;
 	}
 	
+	/**
+	 * @return The total execution time of the request/response round trip.
+	 */
+	public long getRequestTime() {
+		return requestTime;
+	}
+	
 	@Override
 	public String toString() {
 		return "HttpResponse [body=" + body + ", headers=" + headers
-				+ "\n, statusLine=" + statusLine + "]";
+				+ "\n, statusLine=" + statusLine + "]\n" + ", request time: " + requestTime +"ms";
 	}
 	
 }
diff --git a/src/test/java/org/deftserver/io/AsynchronousSocketTest.java b/src/test/java/org/deftserver/io/AsynchronousSocketTest.java
index ef5b478..6a602aa 100644
--- a/src/test/java/org/deftserver/io/AsynchronousSocketTest.java
+++ b/src/test/java/org/deftserver/io/AsynchronousSocketTest.java
@@ -95,7 +95,10 @@ public class AsynchronousSocketTest {
 	
 	@Test
 	public void connectWriteAndReadCallbackTest() throws InterruptedException, IOException {
-		AsyncCallback ccb = new AsyncCallback() { @Override public void onCallback() { onConnect(); }};
+		AsyncResult<Boolean> ccb = new AsyncResult<Boolean>() {
+			public void onFailure(Throwable caught) { }
+			public void onSuccess(Boolean result) { onConnect(); }
+		};
 		socket.connect(HOST, PORT, ccb);
 		
 		latch.await(5, TimeUnit.SECONDS);
diff --git a/src/test/java/org/deftserver/web/DeftSystemTest.java b/src/test/java/org/deftserver/web/DeftSystemTest.java
index d43ab3e..a879969 100644
--- a/src/test/java/org/deftserver/web/DeftSystemTest.java
+++ b/src/test/java/org/deftserver/web/DeftSystemTest.java
@@ -9,9 +9,11 @@ import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.InputStreamReader;
+import java.net.ConnectException;
 import java.net.InetSocketAddress;
 import java.nio.ByteBuffer;
 import java.nio.channels.SocketChannel;
+import java.nio.channels.UnresolvedAddressException;
 import java.util.Arrays;
 import java.util.HashMap;
 import java.util.LinkedList;
@@ -44,6 +46,7 @@ import org.deftserver.io.timeout.Timeout;
 import org.deftserver.web.handler.RequestHandler;
 import org.deftserver.web.http.HttpException;
 import org.deftserver.web.http.HttpRequest;
+import org.deftserver.web.http.client.AsynchronousHttpClient;
 import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
@@ -1051,6 +1054,57 @@ public class DeftSystemTest {
 		assertEquals(0, latch.getCount());
 	}
 	
+	@Test
+	public void connectToUnresolvableAddressUsingAsynchronousHttpClient() throws InterruptedException {
+		final String unresolvableAddress = "http://ttasfdqwertyuiop.se./start";
+		final CountDownLatch latch = new CountDownLatch(1);
+		final AsynchronousHttpClient client = new AsynchronousHttpClient();
+		final AsyncCallback runByIOLoop = new AsyncCallback() {
+
+			public void onCallback() {
+				client.fetch(unresolvableAddress, new AsyncResult<org.deftserver.web.http.client.HttpResponse>() {
+
+					public void onSuccess(org.deftserver.web.http.client.HttpResponse result) { client.close(); }
+
+					public void onFailure(Throwable caught) { 
+						if (caught instanceof UnresolvedAddressException) latch.countDown();
+						client.close();
+					}
+				});
+			}
+		};
+		IOLoop.INSTANCE.addCallback(runByIOLoop);
+		
+		latch.await(5, TimeUnit.SECONDS);
+		assertEquals(0, latch.getCount());
+	}
+
+	@Test
+	public void connectToUnconnectableAddressUsingAsynchronousHttpClient() throws InterruptedException {
+		final String unconnectableAddress = "http://localhost:8039/start";
+		final CountDownLatch latch = new CountDownLatch(1);
+		final AsynchronousHttpClient client = new AsynchronousHttpClient();
+		final AsyncCallback runByIOLoop = new AsyncCallback() {
+
+			public void onCallback() {
+				client.fetch(unconnectableAddress, new AsyncResult<org.deftserver.web.http.client.HttpResponse>() {
+
+					public void onSuccess(org.deftserver.web.http.client.HttpResponse result) { client.close(); }
+
+					public void onFailure(Throwable caught) { 
+						if (caught instanceof ConnectException) latch.countDown();
+						client.close();
+					}
+				});
+			}
+		};
+		IOLoop.INSTANCE.addCallback(runByIOLoop);
+		
+		latch.await(5, TimeUnit.SECONDS);
+		assertEquals(0, latch.getCount());
+	}
+	
+	
 	public String convertStreamToString(InputStream is) throws IOException {
 		if (is != null) {
 			StringBuilder sb = new StringBuilder();
