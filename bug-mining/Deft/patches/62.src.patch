diff --git a/NEWS.txt b/NEWS.txt
index acfdbba..3f01b74 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -5,6 +5,7 @@ Features
 --------
     - Authentication support (#83)
     - Header names are now case-insensitive (#48)
+    - Generic callbacks in IOLoop (#93)
 
 Configuration
 ------------
diff --git a/src/main/java/org/deftserver/io/IOLoop.java b/src/main/java/org/deftserver/io/IOLoop.java
index 12f49b3..7d034d1 100644
--- a/src/main/java/org/deftserver/io/IOLoop.java
+++ b/src/main/java/org/deftserver/io/IOLoop.java
@@ -14,10 +14,13 @@ import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 
+import org.deftserver.io.callback.CallbackManager;
+import org.deftserver.io.callback.JMXDebuggableCallbackManager;
 import org.deftserver.io.timeout.JMXDebuggableTimeoutManager;
 import org.deftserver.io.timeout.Timeout;
 import org.deftserver.io.timeout.TimeoutManager;
 import org.deftserver.util.MXBeanUtil;
+import org.deftserver.web.AsyncCallback;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -31,13 +34,12 @@ public enum IOLoop implements IOLoopMXBean {
 	
 	private final Logger logger = LoggerFactory.getLogger(IOLoop.class);
 
-	private static final long TIMEOUT = 250;	// 0.25s in ms
-
 	private Selector selector;
 	
 	private final Map<SelectableChannel, IOHandler> handlers = Maps.newHashMap();
 	
 	private final TimeoutManager tm = new JMXDebuggableTimeoutManager();
+	private final CallbackManager cm = new JMXDebuggableCallbackManager();
 	
 	private IOLoop() {
 		try {
@@ -52,9 +54,13 @@ public enum IOLoop implements IOLoopMXBean {
 		Thread.currentThread().setName("I/O-LOOP");
 
 		while (true) {
+			long selectorTimeout = 250; // 250 ms
 			try {
-				if (selector.select(TIMEOUT) == 0) {
+				if (selector.select(selectorTimeout) == 0) {
 					tm.execute();
+					if (cm.execute()) {
+						selectorTimeout = 0;
+					}
 					continue;
 				}
 
@@ -74,6 +80,9 @@ public enum IOLoop implements IOLoopMXBean {
 					keys.remove();
 				}
 				tm.execute();
+				if (cm.execute()) { 
+					selectorTimeout = 0; 
+				}
 
 			} catch (IOException e) {
 				logger.error("Exception received in IOLoop: {}", e);			
@@ -90,10 +99,6 @@ public enum IOLoop implements IOLoopMXBean {
 		handlers.remove(channel);
 	}
 	
-//	public <T> void addCallback(AsyncResult<T> cb) {
-//		// TODO RS 101022 store this timeout 
-//	}
-
 	private SelectionKey registerChannel(SelectableChannel channel, int interestOps, Object attachment) {
 		try {
 			return channel.register(selector, interestOps, attachment);
@@ -116,6 +121,10 @@ public enum IOLoop implements IOLoopMXBean {
 		tm.addTimeout(timeout);
 	}
 	
+	public void addCallback(AsyncCallback callback) {
+		cm.addCallback(callback);
+	}
+	
 // implements IOLoopMXBean
 	@Override
 	public int getNumberOfRegisteredIOHandlers() {
@@ -131,9 +140,4 @@ public enum IOLoop implements IOLoopMXBean {
 		return Lists.newLinkedList(readables);
 	}
 
-	@Override
-	public long getSelectorTimeout() {
-		return TIMEOUT;
-	}
-
 }
diff --git a/src/main/java/org/deftserver/io/IOLoopMXBean.java b/src/main/java/org/deftserver/io/IOLoopMXBean.java
index 85d097a..f790c01 100644
--- a/src/main/java/org/deftserver/io/IOLoopMXBean.java
+++ b/src/main/java/org/deftserver/io/IOLoopMXBean.java
@@ -10,6 +10,4 @@ public interface IOLoopMXBean {
 	
 	List<String> getRegisteredIOHandlers();
 	
-	long getSelectorTimeout();
-	
 }
diff --git a/src/main/java/org/deftserver/io/callback/CallbackManager.java b/src/main/java/org/deftserver/io/callback/CallbackManager.java
new file mode 100644
index 0000000..de6f2c3
--- /dev/null
+++ b/src/main/java/org/deftserver/io/callback/CallbackManager.java
@@ -0,0 +1,15 @@
+package org.deftserver.io.callback;
+
+import org.deftserver.web.AsyncCallback;
+
+public interface CallbackManager {
+
+	void addCallback(AsyncCallback callback);
+	
+	/**
+	 * 
+	 * @return true if there are callbacks scheduled to be executed during the next IO loop iteration.
+	 */
+	boolean execute();
+	
+}
diff --git a/src/main/java/org/deftserver/io/callback/CallbackManagerMXBean.java b/src/main/java/org/deftserver/io/callback/CallbackManagerMXBean.java
new file mode 100644
index 0000000..7f8b4aa
--- /dev/null
+++ b/src/main/java/org/deftserver/io/callback/CallbackManagerMXBean.java
@@ -0,0 +1,7 @@
+package org.deftserver.io.callback;
+
+public interface CallbackManagerMXBean {
+
+	int getNumberOfCallbacks();
+	
+}
diff --git a/src/main/java/org/deftserver/io/callback/JMXDebuggableCallbackManager.java b/src/main/java/org/deftserver/io/callback/JMXDebuggableCallbackManager.java
new file mode 100644
index 0000000..e7062b3
--- /dev/null
+++ b/src/main/java/org/deftserver/io/callback/JMXDebuggableCallbackManager.java
@@ -0,0 +1,46 @@
+package org.deftserver.io.callback;
+
+import java.util.List;
+
+import org.deftserver.util.MXBeanUtil;
+import org.deftserver.web.AsyncCallback;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.collect.Lists;
+
+public class JMXDebuggableCallbackManager implements CallbackManager, CallbackManagerMXBean {
+
+	private final Logger logger = LoggerFactory.getLogger(JMXDebuggableCallbackManager.class);
+	
+	private final List<AsyncCallback> callbacks = Lists.newLinkedList();
+	
+	{ 	// instance initialization block
+		MXBeanUtil.registerMXBean(this, "org.deftserver.io.callback:type=JMXDebuggableCallbackManager"); 
+	}
+	
+	@Override
+	public int getNumberOfCallbacks() {
+		return callbacks.size();
+	}
+
+	@Override
+	public void addCallback(AsyncCallback callback) {
+		callbacks.add(callback);
+		logger.debug("Callback added");
+	}
+
+	@Override
+	public boolean execute() {
+		// makes a defensive copy to avoid (1) CME (new callbacks are added this iteration) and (2) IO starvation.
+		List<AsyncCallback> defensive = Lists.newLinkedList(callbacks);
+		callbacks.clear();
+		for (AsyncCallback callback : defensive) {
+			callback.onCallback();
+			logger.debug("Callback executed");
+		}
+		return !callbacks.isEmpty();
+	}
+	
+
+}
diff --git a/src/main/java/org/deftserver/io/timeout/JMXDebuggableTimeoutManager.java b/src/main/java/org/deftserver/io/timeout/JMXDebuggableTimeoutManager.java
index 0d5d26d..d630ced 100644
--- a/src/main/java/org/deftserver/io/timeout/JMXDebuggableTimeoutManager.java
+++ b/src/main/java/org/deftserver/io/timeout/JMXDebuggableTimeoutManager.java
@@ -13,7 +13,7 @@ import com.google.common.collect.Maps;
 import com.google.common.collect.TreeMultiset;
 
 
-public class JMXDebuggableTimeoutManager implements TimeoutManager, TimeoutMXBean {
+public class JMXDebuggableTimeoutManager implements TimeoutManager, TimeoutManagerMXBean {
 
 	private final Logger logger = LoggerFactory.getLogger(JMXDebuggableTimeoutManager.class);
 
@@ -21,7 +21,7 @@ public class JMXDebuggableTimeoutManager implements TimeoutManager, TimeoutMXBea
 	private final Map<SelectableChannel, DecoratedTimeout> index = Maps.newHashMap();
 
 	{ 	// instance initialization block
-		MXBeanUtil.registerMXBean(this, "org.deftserver.io.timeout:type=JMXConfigurableTimeoutManager"); 
+		MXBeanUtil.registerMXBean(this, "org.deftserver.io.timeout:type=JMXDebuggableTimeoutManager"); 
 	}
 
 	@Override
diff --git a/src/main/java/org/deftserver/io/timeout/TimeoutMXBean.java b/src/main/java/org/deftserver/io/timeout/TimeoutManagerMXBean.java
similarity index 72%
rename from src/main/java/org/deftserver/io/timeout/TimeoutMXBean.java
rename to src/main/java/org/deftserver/io/timeout/TimeoutManagerMXBean.java
index 2a47b90..289e1e8 100644
--- a/src/main/java/org/deftserver/io/timeout/TimeoutMXBean.java
+++ b/src/main/java/org/deftserver/io/timeout/TimeoutManagerMXBean.java
@@ -1,6 +1,6 @@
 package org.deftserver.io.timeout;
 
-public interface TimeoutMXBean {
+public interface TimeoutManagerMXBean {
 
 	int getNumberOfTimeouts();
 	
diff --git a/src/test/java/org/deftserver/io/callback/JMXDebuggableCallbackManagerTest.java b/src/test/java/org/deftserver/io/callback/JMXDebuggableCallbackManagerTest.java
new file mode 100644
index 0000000..6f7c40c
--- /dev/null
+++ b/src/test/java/org/deftserver/io/callback/JMXDebuggableCallbackManagerTest.java
@@ -0,0 +1,51 @@
+package org.deftserver.io.callback;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.concurrent.CountDownLatch;
+
+import org.deftserver.web.AsyncCallback;
+import org.junit.Test;
+
+
+public class JMXDebuggableCallbackManagerTest {
+	
+	private final JMXDebuggableCallbackManager cm = new JMXDebuggableCallbackManager();
+	
+	@Test
+	public void simpleJMXDeubggableCallbackManagerTest() {
+		final CountDownLatch latch = new CountDownLatch(3);
+		
+		final AsyncCallback cb1 = new AsyncCallback() {
+			@Override
+			public void onCallback() { latch.countDown(); }
+		};
+		
+		final AsyncCallback cb2 = new AsyncCallback() {
+			@Override
+			public void onCallback() { latch.countDown(); }
+		};
+		
+		final AsyncCallback cb3 = new AsyncCallback() {
+			@Override
+			public void onCallback() { 
+				latch.countDown();
+				cm.addCallback(cb1); 	// adding a new callback that should be scheduled for execution 
+										// during the next iteration (i.e next call to execute)
+			}
+		};
+		
+		cm.addCallback(cb1);
+		cm.addCallback(cb2);
+		cm.addCallback(cb3);
+		
+		assertEquals(3, cm.getNumberOfCallbacks());
+		
+		boolean pending = cm.execute();
+		
+		assertEquals(true, pending);
+		assertEquals(1, cm.getNumberOfCallbacks());
+		assertEquals(0, latch.getCount());
+	}
+
+}
diff --git a/src/test/java/org/deftserver/web/DeftSystemTest.java b/src/test/java/org/deftserver/web/DeftSystemTest.java
index cd6489a..4c8ad59 100644
--- a/src/test/java/org/deftserver/web/DeftSystemTest.java
+++ b/src/test/java/org/deftserver/web/DeftSystemTest.java
@@ -791,6 +791,24 @@ public class DeftSystemTest {
 		latch.await(5 * 1000, TimeUnit.MILLISECONDS);
 		assertTrue(latch.getCount() == 0);
 	}
+	
+	@Test
+	public void callbackTest() throws InterruptedException {
+		final CountDownLatch latch = new CountDownLatch(5);
+		final AsyncCallback cb = new AsyncCallback() {
+
+			@Override public void onCallback() { latch.countDown(); }
+		
+		};
+		IOLoop.INSTANCE.addCallback(cb);
+		IOLoop.INSTANCE.addCallback(cb);
+		IOLoop.INSTANCE.addCallback(cb);
+		IOLoop.INSTANCE.addCallback(cb);
+		IOLoop.INSTANCE.addCallback(cb);
+		
+		latch.await(5 * 1000, TimeUnit.MILLISECONDS);
+		assertTrue(latch.getCount() == 0);
+	}
 
 	@Test
 	public void keyValueStoreClientTest() throws ClientProtocolException, IOException {
