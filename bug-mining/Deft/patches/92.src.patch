diff --git a/CHANGES.txt b/CHANGES.txt
index 26a548a..ca0d71f 100644
--- a/CHANGES.txt
+++ b/CHANGES.txt
@@ -1,6 +1,8 @@
 0.4.0
  * Renaming org.deftserver.web.http.client.{HttpRequest.java -> Request.java} and
    org.deftserver.web.http.client.{HttpResponse.java -> Response.java}.
+ * o.d.io.timeout.Timeout.newKeepAliveTimeout now requires that you specifies an ioloop explicitly (previously the 
+   global singleton was used implicitly.)
 
 0.1.1
  * #56 (Support for all response status codes)
diff --git a/NEWS.txt b/NEWS.txt
index 2cf9011..1b2f0a9 100644
--- a/NEWS.txt
+++ b/NEWS.txt
@@ -5,6 +5,7 @@ Features
 --------
     - Asynchronous HTTP client has configurable redirect support (HTTP status code 301 & 302) (#118)
     - Asynchronous HTTP client supports 'Transfer-Encoding: chunked' (#116)
+    - Multi-threaded web server support (#139)
 
 Configuration
 ------------
diff --git a/src/main/java/org/deftserver/example/DeftServerExample.java b/src/main/java/org/deftserver/example/DeftServerExample.java
index ba3f422..1330d3c 100644
--- a/src/main/java/org/deftserver/example/DeftServerExample.java
+++ b/src/main/java/org/deftserver/example/DeftServerExample.java
@@ -2,13 +2,11 @@ package org.deftserver.example;
 
 import java.util.Map;
 
-import org.deftserver.io.IOLoop;
 import org.deftserver.web.Application;
 import org.deftserver.web.HttpServer;
 import org.deftserver.web.handler.RequestHandler;
 import org.deftserver.web.http.HttpRequest;
 import org.deftserver.web.http.HttpResponse;
-import org.deftserver.web.http.HttpServerDescriptor;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -42,14 +40,16 @@ public class DeftServerExample {
 		Application application = new Application(handlers);
 		application.setStaticContentDir("static");
 		
-		HttpServerDescriptor.KEEP_ALIVE_TIMEOUT = 30 * 1000;	// 30s  
-		HttpServerDescriptor.READ_BUFFER_SIZE = 1500;			// 1500 bytes 
-		HttpServerDescriptor.WRITE_BUFFER_SIZE = 1500;			// 1500 bytes 
+//		HttpServerDescriptor.KEEP_ALIVE_TIMEOUT = 30 * 1000;	// 30s  
+//		HttpServerDescriptor.READ_BUFFER_SIZE = 1500;			// 1500 bytes 
+//		HttpServerDescriptor.WRITE_BUFFER_SIZE = 1500;			// 1500 bytes 
 		
 
 		logger.debug("Starting up server on port: " + PORT);
 		HttpServer server = new HttpServer(application);
-		server.listen(PORT);
-		IOLoop.INSTANCE.start();
+		//server.listen(PORT);
+		server.bind(PORT);
+		server.start(8);
+		//IOLoop.INSTANCE.start();
 	}
 }
diff --git a/src/main/java/org/deftserver/io/AsynchronousSocket.java b/src/main/java/org/deftserver/io/AsynchronousSocket.java
index 4969ff0..3d957ff 100644
--- a/src/main/java/org/deftserver/io/AsynchronousSocket.java
+++ b/src/main/java/org/deftserver/io/AsynchronousSocket.java
@@ -23,6 +23,8 @@ public class AsynchronousSocket implements IOHandler {
 	
 	private static final Logger logger = LoggerFactory.getLogger(AsynchronousSocket.class);
 	
+	private final IOLoop ioLoop;
+	
 	private final int DEFAULT_BYTEBUFFER_SIZE = 1024;
 	
 	private final AsyncResult<String> nopAsyncStringResult = NopAsyncResult.of(String.class).nopAsyncResult;
@@ -48,19 +50,24 @@ public class AsynchronousSocket implements IOHandler {
 	 * Create a new {@code AsynchronousSocket} that will delegate its io operations the given {@code SelectableChannel}.
 	 */
 	public AsynchronousSocket(SelectableChannel channel) {
+		this(IOLoop.INSTANCE, channel);
+	}
+	
+	public AsynchronousSocket(IOLoop ioLoop, SelectableChannel channel) {
+		this.ioLoop = ioLoop;
 		this.channel = channel;
 		interestOps = SelectionKey.OP_CONNECT;
 		if (channel instanceof SocketChannel && (((SocketChannel) channel).isConnected())) {
 			interestOps |= SelectionKey.OP_READ;
 		}
-		IOLoop.INSTANCE.addHandler(channel, this, interestOps, null);
+		ioLoop.addHandler(channel, this, interestOps, null);
 	}
 	
 	/**
 	 * Connects to the given host port tuple and invokes the given callback when a successful connection is established.
 	 */
 	public void connect(String host, int port, AsyncResult<Boolean> ccb) {
-		IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_CONNECT);
+		ioLoop.updateHandler(channel, interestOps |= SelectionKey.OP_CONNECT);
 		connectCallback = ccb;
 		if (channel instanceof SocketChannel) {
 			try {
@@ -79,7 +86,7 @@ public class AsynchronousSocket implements IOHandler {
 	 * Close the socket.
 	 */
 	public void close() {
-		Closeables.closeQuietly(channel);
+		Closeables.closeQuietly(ioLoop, channel);
 		invokeCloseCallback();
 	}
 	
@@ -110,7 +117,7 @@ public class AsynchronousSocket implements IOHandler {
 				sc.finishConnect();
 				invokeConnectSuccessfulCallback();
 				interestOps &= ~SelectionKey.OP_CONNECT;
-				IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_READ);
+				ioLoop.updateHandler(channel, interestOps |= SelectionKey.OP_READ);
 			} catch (ConnectException e) {
 				logger.warn("Connect failed: {}", e.getMessage());
 				invokeConnectFailureCallback(e);
@@ -128,7 +135,7 @@ public class AsynchronousSocket implements IOHandler {
 		int read = ((SocketChannel) key.channel()).read(buffer);
 		if (read == -1) {	// EOF
 			reachedEOF = true;
-			IOLoop.INSTANCE.updateHandler(channel, interestOps &= ~SelectionKey.OP_READ);
+			ioLoop.updateHandler(channel, interestOps &= ~SelectionKey.OP_READ);
 			return;
 		}
 		readBuffer.append(new String(buffer.array(), 0, buffer.position(), Charsets.ISO_8859_1));
@@ -253,15 +260,15 @@ public class AsynchronousSocket implements IOHandler {
 		} catch (IOException e) {
 			logger.error("IOException during write: {}", e.getMessage());
 			invokeCloseCallback();
-			Closeables.closeQuietly(channel);
+			Closeables.closeQuietly(ioLoop, channel);
 		}
 		writeBuffer.delete(0, written);
 		logger.debug("wrote: {} bytes", written);
 		logger.debug("writeBuffer size: {}", writeBuffer.length());
 		if (writeBuffer.length() > 0) {
-			IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_WRITE);
+			ioLoop.updateHandler(channel, interestOps |= SelectionKey.OP_WRITE);
 		} else {
-			IOLoop.INSTANCE.updateHandler(channel, interestOps &= ~SelectionKey.OP_WRITE);
+			ioLoop.updateHandler(channel, interestOps &= ~SelectionKey.OP_WRITE);
 			invokeWriteCallback();
 		}
 	}
diff --git a/src/main/java/org/deftserver/io/IOLoop.java b/src/main/java/org/deftserver/io/IOLoop.java
index 869904c..f64d3d8 100644
--- a/src/main/java/org/deftserver/io/IOLoop.java
+++ b/src/main/java/org/deftserver/io/IOLoop.java
@@ -12,6 +12,7 @@ import java.util.HashMap;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
+import java.util.concurrent.atomic.AtomicInteger;
 
 import org.deftserver.io.callback.CallbackManager;
 import org.deftserver.io.callback.JMXDebuggableCallbackManager;
@@ -27,9 +28,11 @@ import com.google.common.base.Function;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 
-public enum IOLoop implements IOLoopMXBean {
+public class IOLoop implements IOLoopMXBean {
 	
-	INSTANCE;
+	/* IOLoop singleton to use for convenience (otherwise you would have to pass around the 
+	 * IOLoop instance explicitly, now you can simply use IOLoop.INSTANCE) */
+	public static final IOLoop INSTANCE = new IOLoop();
 	
 	private boolean running = false;
 	
@@ -42,7 +45,9 @@ public enum IOLoop implements IOLoopMXBean {
 	private final TimeoutManager tm = new JMXDebuggableTimeoutManager();
 	private final CallbackManager cm = new JMXDebuggableCallbackManager();
 	
-	private IOLoop() {
+	private static final AtomicInteger sequence = new AtomicInteger();
+	
+	public IOLoop() {
 		try {
 			selector = Selector.open();
 		} catch (IOException e) {
@@ -55,7 +60,7 @@ public enum IOLoop implements IOLoopMXBean {
 	 * and will be the io loop thread.
 	 */
 	public void start() {
-		Thread.currentThread().setName("I/O-LOOP");
+		Thread.currentThread().setName("I/O-LOOP" + sequence.incrementAndGet());
 		running = true;
 		
 		long selectorTimeout = 250; // 250 ms
diff --git a/src/main/java/org/deftserver/io/callback/PeriodicCallback.java b/src/main/java/org/deftserver/io/callback/PeriodicCallback.java
index 01b102f..a5bd41c 100644
--- a/src/main/java/org/deftserver/io/callback/PeriodicCallback.java
+++ b/src/main/java/org/deftserver/io/callback/PeriodicCallback.java
@@ -6,6 +6,7 @@ import org.deftserver.web.AsyncCallback;
 
 public class PeriodicCallback {
 	
+	private final IOLoop ioLoop;
 	private final AsyncCallback cb;
 	private final long period;
 	private boolean active = true;
@@ -16,6 +17,11 @@ public class PeriodicCallback {
 	 * @param period The period in ms
 	 */
 	public PeriodicCallback(AsyncCallback cb, long period) {
+		this(IOLoop.INSTANCE, cb, period);
+	}
+	
+	public PeriodicCallback(IOLoop ioLoop, AsyncCallback cb, long period) {
+		this.ioLoop = ioLoop;
 		this.cb = cb;
 		this.period = period;
 	}
@@ -24,7 +30,7 @@ public class PeriodicCallback {
 	 * Start the {@code PeriodicCallback}
 	 */
 	public void start() {
-		IOLoop.INSTANCE.addTimeout(
+		ioLoop.addTimeout(
 				new Timeout(
 						System.currentTimeMillis() + period, 
 						new AsyncCallback() { @Override public void onCallback() { run(); }}
diff --git a/src/main/java/org/deftserver/io/timeout/Timeout.java b/src/main/java/org/deftserver/io/timeout/Timeout.java
index 216f286..4d005db 100644
--- a/src/main/java/org/deftserver/io/timeout/Timeout.java
+++ b/src/main/java/org/deftserver/io/timeout/Timeout.java
@@ -2,6 +2,7 @@ package org.deftserver.io.timeout;
 
 import java.nio.channels.SelectableChannel;
 
+import org.deftserver.io.IOLoop;
 import org.deftserver.util.Closeables;
 import org.deftserver.web.AsyncCallback;
 
@@ -33,10 +34,10 @@ public class Timeout {
 		return cancelled ? AsyncCallback.nopCb : cb;
 	}
 	
-	public static Timeout newKeepAliveTimeout(final SelectableChannel clientChannel, long keepAliveTimeout) {
+	public static Timeout newKeepAliveTimeout(final IOLoop ioLoop, final SelectableChannel clientChannel, long keepAliveTimeout) {
 		return new Timeout(
 				System.currentTimeMillis() + keepAliveTimeout,
-				new AsyncCallback() { public void onCallback() { Closeables.closeQuietly(clientChannel); } }
+				new AsyncCallback() { public void onCallback() { Closeables.closeQuietly(ioLoop, clientChannel); } }
 		);
 	}
 
diff --git a/src/main/java/org/deftserver/util/Closeables.java b/src/main/java/org/deftserver/util/Closeables.java
index d71faf2..7e96553 100644
--- a/src/main/java/org/deftserver/util/Closeables.java
+++ b/src/main/java/org/deftserver/util/Closeables.java
@@ -10,10 +10,14 @@ public class Closeables {
 	private Closeables() {}
 
 	public static void closeQuietly(SelectableChannel channel) {
+		closeQuietly(IOLoop.INSTANCE, channel);
+	}
+	
+	public static void closeQuietly(IOLoop ioLoop, SelectableChannel channel) {
 		try {
-			IOLoop.INSTANCE.removeHandler(channel);
+			ioLoop.removeHandler(channel);
 			com.google.common.io.Closeables.close(channel, true);
 		} catch (IOException ignore) { }
 	}
-
+	
 }
diff --git a/src/main/java/org/deftserver/util/HttpUtil.java b/src/main/java/org/deftserver/util/HttpUtil.java
index effb482..f59739d 100644
--- a/src/main/java/org/deftserver/util/HttpUtil.java
+++ b/src/main/java/org/deftserver/util/HttpUtil.java
@@ -14,14 +14,9 @@ public class HttpUtil {
 
 	private static final Logger logger = LoggerFactory.getLogger(HttpUtil.class);
 
-	private static final MessageDigest md;
-	static {
-		try {	/* Creating a MessageDigest instance is expensive. Do it only once.*/
-			md = MessageDigest.getInstance("MD5");
-		} catch (NoSuchAlgorithmException e) {
-			throw new RuntimeException("MD5 cryptographic algorithm is not available.", e);
-		}
-	}
+	/* MessageDigest are not thread-safe and are expensive to create. 
+	 * Do it lazily for each thread that need access to one.*/
+	private static final ThreadLocal<MessageDigest> md = new ThreadLocal<MessageDigest>();
 	
 	private static final String _200_OK 		 			= "HTTP/1.1 200 OK\r\n"; 
 	private static final String _201_CREATED 		 		= "HTTP/1.1 201 Created\r\n"; 
@@ -158,7 +153,15 @@ public class HttpUtil {
 
 
 	public static String getEtag(byte[] bytes) {
-		byte[] digest = md.digest(bytes);
+		if (md.get() == null) {
+			try {
+				System.out.println("create instance");
+				md.set(MessageDigest.getInstance("MD5"));
+			} catch (NoSuchAlgorithmException e) {
+				throw new RuntimeException("MD5 cryptographic algorithm is not available.", e);
+			}
+		}
+		byte[] digest = md.get().digest(bytes);
 		BigInteger number = new BigInteger(1, digest);
 		return '0' + number.toString(16);	// prepend a '0' to get a proper MD5 hash 
 	}
diff --git a/src/main/java/org/deftserver/web/HttpServer.java b/src/main/java/org/deftserver/web/HttpServer.java
index b4c0b08..7116bc8 100644
--- a/src/main/java/org/deftserver/web/HttpServer.java
+++ b/src/main/java/org/deftserver/web/HttpServer.java
@@ -4,14 +4,16 @@ import java.io.IOException;
 import java.net.InetSocketAddress;
 import java.nio.channels.SelectionKey;
 import java.nio.channels.ServerSocketChannel;
+import java.util.List;
 
-import org.deftserver.io.IOHandler;
 import org.deftserver.io.IOLoop;
 import org.deftserver.util.Closeables;
 import org.deftserver.web.http.HttpProtocol;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+import com.google.common.collect.Lists;
+
 public class HttpServer {
 	
 	private final Logger logger = LoggerFactory.getLogger(HttpServer.class);
@@ -20,17 +22,28 @@ public class HttpServer {
 	private static final int MAX_PORT_NUMBER = 65535;
 	
 	private ServerSocketChannel serverChannel;
+	private final List<IOLoop> ioLoops = Lists.newLinkedList();
+	
+	private final Application application;
 	
-	private final IOHandler protocol;
-
 	public HttpServer(Application application) {
-		protocol = new HttpProtocol(application);
+		this.application = application;
 	}
 
 	/**
+	 * If you want to run Deft on multiple threads first invoke {@link #bind(int)} then {@link #start(int)} 
+	 * instead of {@link #listen(int)} (listen starts Deft http server on a single thread with the default IOLoop 
+	 * instance: {@code IOLoop.INSTANCE}).
+	 * 
 	 * @return this for chaining purposes
 	 */
 	public void listen(int port) {
+		bind(port);
+		ioLoops.add(IOLoop.INSTANCE);
+		registerHandler(IOLoop.INSTANCE, new HttpProtocol(application));
+	}
+	
+	public void bind(int port) {
 		if (port <= MIN_PORT_NUMBER || port > MAX_PORT_NUMBER) {
 			throw new IllegalArgumentException("Invalid port number. Valid range: [" + 
 					MIN_PORT_NUMBER + ", " + MAX_PORT_NUMBER + ")");
@@ -48,8 +61,22 @@ public class HttpServer {
 			serverChannel.socket().bind(endpoint);
 		} catch (IOException e) {
 			logger.error("Could not bind socket: {}", e);
+		}	
+	}
+	
+	public void start(int numThreads) {
+		for (int i = 0; i < numThreads; i++) {
+			final IOLoop ioLoop = new IOLoop();
+			ioLoops.add(ioLoop);
+			final HttpProtocol protocol = new HttpProtocol(ioLoop, application);
+			new Thread(new Runnable() {
+				
+				@Override public void run() {
+					registerHandler(ioLoop, protocol);
+					ioLoop.start();
+				}
+			}).start();
 		}
-		registerHandler();
 	}
 	
 	/**
@@ -57,11 +84,13 @@ public class HttpServer {
 	 */
 	public void stop() {
 		logger.debug("Stopping HTTP server");
-		Closeables.closeQuietly(serverChannel);
+		for (IOLoop ioLoop : ioLoops) {
+			Closeables.closeQuietly(ioLoop, serverChannel);
+		}
 	}
 	
-	private void registerHandler() {
-		IOLoop.INSTANCE.addHandler(
+	private void registerHandler(IOLoop ioLoop, HttpProtocol protocol) {
+		ioLoop.addHandler(
 				serverChannel,
 				protocol, 
 				SelectionKey.OP_ACCEPT,
diff --git a/src/main/java/org/deftserver/web/http/HttpProtocol.java b/src/main/java/org/deftserver/web/http/HttpProtocol.java
index 1ba187a..b5c4dfc 100644
--- a/src/main/java/org/deftserver/web/http/HttpProtocol.java
+++ b/src/main/java/org/deftserver/web/http/HttpProtocol.java
@@ -28,12 +28,19 @@ public class HttpProtocol implements IOHandler {
 	
 	private final static Logger logger = LoggerFactory.getLogger(HttpProtocol.class);
 
+	private final IOLoop ioLoop;
 	private final Application application;
 
+	
 	// a queue of half-baked (pending/unfinished) HTTP post request
 	private final Map<SelectableChannel, PartialHttpRequest> partials = Maps.newHashMap();
  	
 	public HttpProtocol(Application app) {
+		this(IOLoop.INSTANCE, app);
+	}
+	
+	public HttpProtocol(IOLoop ioLoop, Application app) {
+		this.ioLoop = ioLoop;
 		application = app;
 	}
 	
@@ -41,8 +48,11 @@ public class HttpProtocol implements IOHandler {
 	public void handleAccept(SelectionKey key) throws IOException {
 		logger.debug("handle accept...");
 		SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
-		clientChannel.configureBlocking(false);
-		IOLoop.INSTANCE.addHandler(clientChannel, this, SelectionKey.OP_READ, ByteBuffer.allocate(READ_BUFFER_SIZE));
+		if (clientChannel != null) {
+			// could be null in a multithreaded deft environment because another ioloop was "faster" to accept()
+			clientChannel.configureBlocking(false);
+			ioLoop.addHandler(clientChannel, this, SelectionKey.OP_READ, ByteBuffer.allocate(READ_BUFFER_SIZE));
+		}
 	}
 	
 	@Override
@@ -57,9 +67,9 @@ public class HttpProtocol implements IOHandler {
 		HttpRequest request = getHttpRequest(key, clientChannel);
 		
 		if (request.isKeepAlive()) {
-			IOLoop.INSTANCE.addKeepAliveTimeout(
+			ioLoop.addKeepAliveTimeout(
 					clientChannel, 
-					Timeout.newKeepAliveTimeout(clientChannel, KEEP_ALIVE_TIMEOUT)
+					Timeout.newKeepAliveTimeout(ioLoop, clientChannel, KEEP_ALIVE_TIMEOUT)
 			);
 		}
 		HttpResponse response = new HttpResponse(this, key, request.isKeepAlive());
@@ -82,7 +92,7 @@ public class HttpProtocol implements IOHandler {
 		try {
 			toSend.flip();	// prepare for write
 			long bytesWritten = channel.write(toSend);
-			if (IOLoop.INSTANCE.hasKeepAliveTimeout(channel)) {
+			if (ioLoop.hasKeepAliveTimeout(channel)) {
 				prolongKeepAliveTimeout(channel);
 			}
 			logger.debug("sent {} bytes to wire", bytesWritten);
@@ -94,34 +104,38 @@ public class HttpProtocol implements IOHandler {
 			}
 		} catch (IOException e) {
 			logger.error("Failed to send data to client: {}", e.getMessage());
-			Closeables.closeQuietly(channel);
+			Closeables.closeQuietly(ioLoop, channel);
 		}
 	}
 	
 	public void closeOrRegisterForRead(SelectionKey key) {
-		if (key.isValid() && IOLoop.INSTANCE.hasKeepAliveTimeout(key.channel())) {
+		if (key.isValid() && ioLoop.hasKeepAliveTimeout(key.channel())) {
 			try {
 				key.channel().register(key.selector(), SelectionKey.OP_READ, reuseAttachment(key));
 				prolongKeepAliveTimeout(key.channel());
 				logger.debug("keep-alive connection. registrating for read.");
 			} catch (ClosedChannelException e) {
 				logger.debug("ClosedChannelException while registrating key for read: {}", e.getMessage());
-				Closeables.closeQuietly(key.channel());
+				Closeables.closeQuietly(ioLoop, key.channel());
 			}		
 		} else {
 			// http request should be finished and no 'keep-alive' => close connection
 			logger.debug("Closing finished (non keep-alive) http connection"); 
-			Closeables.closeQuietly(key.channel());
+			Closeables.closeQuietly(ioLoop, key.channel());
 		}
 	}
 	
 	public void prolongKeepAliveTimeout(SelectableChannel channel) {
-		IOLoop.INSTANCE.addKeepAliveTimeout(
+		ioLoop.addKeepAliveTimeout(
 				channel, 
-				Timeout.newKeepAliveTimeout(channel, KEEP_ALIVE_TIMEOUT)
+				Timeout.newKeepAliveTimeout(ioLoop, channel, KEEP_ALIVE_TIMEOUT)
 		);
 	}
 	
+	public IOLoop getIOLoop() {
+		return ioLoop;
+	}
+	
 	/**
 	 * Clears the buffer (prepares for reuse) attached to the given SelectionKey.
 	 * @return A cleared (position=0, limit=capacity) ByteBuffer which is ready for new reads
@@ -148,7 +162,7 @@ public class HttpProtocol implements IOHandler {
 			clientChannel.read(buffer);
 		} catch (IOException e) {
 			logger.warn("Could not read buffer: {}", e.getMessage());
-			Closeables.closeQuietly(clientChannel);
+			Closeables.closeQuietly(ioLoop, clientChannel);
 		}
 		buffer.flip();
 		
diff --git a/src/main/java/org/deftserver/web/http/HttpRequest.java b/src/main/java/org/deftserver/web/http/HttpRequest.java
index af6a546..f5849dc 100644
--- a/src/main/java/org/deftserver/web/http/HttpRequest.java
+++ b/src/main/java/org/deftserver/web/http/HttpRequest.java
@@ -8,6 +8,7 @@ import java.util.HashMap;
 import java.util.Map;
 import java.util.regex.Pattern;
 
+import org.deftserver.io.IOLoop;
 import org.deftserver.util.ArrayUtil;
 import org.deftserver.web.HttpVerb;
 
@@ -16,6 +17,8 @@ import com.google.common.collect.ImmutableMultimap;
 
 public class HttpRequest {
 	
+	private IOLoop ioLoop;
+	
 	private final String requestLine;
 	private final HttpVerb method;
 	private final String requestedPath;	// correct name?
@@ -118,6 +121,14 @@ public class HttpRequest {
 		}
 	}
 	
+	protected void setIOLoop(IOLoop ioLoop) {
+		this.ioLoop = ioLoop;
+	}
+	
+	public IOLoop getIOLoop() {
+		return ioLoop;
+	}
+	
 	public String getRequestLine() {
 		return requestLine;
 	}
diff --git a/src/main/java/org/deftserver/web/http/HttpResponse.java b/src/main/java/org/deftserver/web/http/HttpResponse.java
index af569d8..5bac6e9 100644
--- a/src/main/java/org/deftserver/web/http/HttpResponse.java
+++ b/src/main/java/org/deftserver/web/http/HttpResponse.java
@@ -11,7 +11,6 @@ import java.nio.channels.SocketChannel;
 import java.util.HashMap;
 import java.util.Map;
 
-import org.deftserver.io.IOLoop;
 import org.deftserver.io.buffer.DynamicByteBuffer;
 import org.deftserver.util.Closeables;
 import org.deftserver.util.DateUtil;
@@ -79,10 +78,10 @@ public class HttpResponse {
 			channel.write(responseData.getByteBuffer());
 		} catch (IOException e) {
 			logger.error("ClosedChannelException during channel.write(): {}", e.getMessage());
-			Closeables.closeQuietly(key.channel());
+			Closeables.closeQuietly(protocol.getIOLoop(), key.channel());
 		}
 		long bytesFlushed = responseData.position();
-		if (IOLoop.INSTANCE.hasKeepAliveTimeout(channel)) {
+		if (protocol.getIOLoop().hasKeepAliveTimeout(channel)) {
 			protocol.prolongKeepAliveTimeout(channel);
 		}
 		if (responseData.hasRemaining()) { 
@@ -91,7 +90,7 @@ public class HttpResponse {
 				key.channel().register(key.selector(), SelectionKey.OP_WRITE);
 			} catch (ClosedChannelException e) {
 				logger.error("ClosedChannelException during flush(): {}", e.getMessage());
-				Closeables.closeQuietly(key.channel());
+				Closeables.closeQuietly(protocol.getIOLoop(), key.channel());
 			}
 			key.attach(responseData);
 		} else {
diff --git a/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java b/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
index 22432d1..f8cb32e 100644
--- a/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
+++ b/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
@@ -48,11 +48,19 @@ public class AsynchronousHttpClient {
 	
 	private Timeout timeout;
 	
+	private final IOLoop ioLoop;
+	
 	private static final String HTTP_VERSION = "HTTP/1.1\r\n";
 	private static final String USER_AGENT_HEADER = "User-Agent: Deft AsynchronousHttpClient/0.2-SNAPSHOT\r\n";
 	private static final String NEWLINE = "\r\n";
 	
-	public AsynchronousHttpClient() { }
+	public AsynchronousHttpClient() { 
+		this(IOLoop.INSTANCE);
+	}
+	
+	public AsynchronousHttpClient(IOLoop ioLoop) {
+		this.ioLoop = ioLoop;
+	}
 
 	/**
 	 * Makes an asynchronous HTTP GET request against the specified url and invokes the given 
@@ -106,7 +114,7 @@ public class AsynchronousHttpClient {
 				System.currentTimeMillis() + TIMEOUT, 
 				new AsyncCallback() { public void onCallback() { onTimeout(); } }
 		);
-		IOLoop.INSTANCE.addTimeout(timeout);		
+		ioLoop.addTimeout(timeout);		
 	}
 	
 	private void cancelTimeout() {
diff --git a/src/test/java/org/deftserver/web/DeftSystemTest.java b/src/test/java/org/deftserver/web/DeftSystemTest.java
index 921e315..c8abd0f 100644
--- a/src/test/java/org/deftserver/web/DeftSystemTest.java
+++ b/src/test/java/org/deftserver/web/DeftSystemTest.java
@@ -1078,7 +1078,7 @@ public class DeftSystemTest {
 			IOLoop.INSTANCE.addCallback(new AsyncCallback() { public void onCallback() { server.listen(PORT+1); }});
 			IOLoop.INSTANCE.addCallback(new AsyncCallback() { public void onCallback() { server.stop(); latch.countDown(); }});
 		}
-		latch.await(5, TimeUnit.SECONDS);
+		latch.await(50, TimeUnit.SECONDS);
 		assertEquals(0, latch.getCount());
 	}
 	
@@ -1152,7 +1152,7 @@ public class DeftSystemTest {
 			};
 			// make sure that the http.fetch(..) is invoked from the ioloop thread
 			IOLoop.INSTANCE.addCallback(new AsyncCallback() { public void onCallback() { http.fetch(url, cb); }});
-			latch.await(5, TimeUnit.SECONDS);
+			latch.await(15, TimeUnit.SECONDS);
 			assertEquals(0, latch.getCount());
 			assertEquals("hello test", result[0]);
 			assertEquals("HTTP/1.1 200 OK", result[1]);
