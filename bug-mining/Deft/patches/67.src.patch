diff --git a/src/main/java/org/deftserver/example/DeftServerExample.java b/src/main/java/org/deftserver/example/DeftServerExample.java
index 9e03de2..4b42974 100644
--- a/src/main/java/org/deftserver/example/DeftServerExample.java
+++ b/src/main/java/org/deftserver/example/DeftServerExample.java
@@ -8,7 +8,6 @@ import org.deftserver.web.HttpServer;
 import org.deftserver.web.handler.RequestHandler;
 import org.deftserver.web.http.HttpRequest;
 import org.deftserver.web.http.HttpResponse;
-import org.deftserver.web.http.HttpServerDescriptor;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -43,9 +42,9 @@ public class DeftServerExample {
 		Application application = new Application(handlers);
 		application.setStaticContentDir("static");
 		
-		HttpServerDescriptor.KEEP_ALIVE_TIMEOUT = 30 * 1000;	// 30s  
-		HttpServerDescriptor.READ_BUFFER_SIZE = 1500;			// 1500 bytes 
-		HttpServerDescriptor.WRITE_BUFFER_SIZE = 1500;			// 1500 bytes 
+		//HttpServerDescriptor.KEEP_ALIVE_TIMEOUT = 30 * 1000;	// 30s  
+		//HttpServerDescriptor.READ_BUFFER_SIZE = 1500;			// 1500 bytes 
+		//HttpServerDescriptor.WRITE_BUFFER_SIZE = 1500;			// 1500 bytes 
 		
 
 		logger.debug("Starting up server on port: " + PORT);
diff --git a/src/main/java/org/deftserver/example/kv/Client.java b/src/main/java/org/deftserver/example/kv/Client.java
deleted file mode 100644
index 0f77ae0..0000000
--- a/src/main/java/org/deftserver/example/kv/Client.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package org.deftserver.example.kv;
-
-import org.deftserver.io.timeout.Timeout;
-import org.deftserver.web.AsyncResult;
-
-public class Client {
-	
-	private final Connection connection;
-	
-		
-	public Client() {
-		Timeout timeout = new Timeout(0, null);
-		connection = new Connection(KeyValueStore.HOST, KeyValueStore.PORT, timeout);
-	}
-
-	public void connect() {
-		connection.connect();
-	}
-	
-//	public void disconnect() {
-//		connection.disconnect();
-//	}
-
-	public void get(String value, AsyncResult<String> cb) {
-		connection.write("GET deft\r\n", cb);
-	}
-
-}
diff --git a/src/main/java/org/deftserver/example/kv/Connection.java b/src/main/java/org/deftserver/example/kv/Connection.java
deleted file mode 100644
index e5f7c25..0000000
--- a/src/main/java/org/deftserver/example/kv/Connection.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package org.deftserver.example.kv;
-
-import java.io.IOException;
-import java.net.InetSocketAddress;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.SocketChannel;
-
-import org.deftserver.io.IOLoop;
-import org.deftserver.io.buffer.DynamicByteBuffer;
-import org.deftserver.io.timeout.Timeout;
-import org.deftserver.web.AsyncResult;
-
-import com.google.common.base.Charsets;
-
-public class Connection {
-	
-	//private IOStream iostream;
-	private SocketChannel channel;
-	private final KeyValueStoreIOHandler handler = new KeyValueStoreIOHandler();
-	private final String host;
-	private final int port;
-	private final Timeout timeout;
-
-	public Connection(String host, int port, Timeout timeout) {
-		this.host = host;
-		this.port = port;
-		this.timeout = timeout;
-	}
-
-	public void connect() {
-		try {
-			channel = SocketChannel.open(new InetSocketAddress(host, port));
-			channel.configureBlocking(false);
-		} catch (IOException e) { e.printStackTrace(); }
-		//IOLoop.INSTANCE.addHandler(channel, handler, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
-		//iostream = new IOStream(channel, ioLoop);
-	}
-
-//	public void disconnect() {
-//		iostream.close();
-//	}
-//
-//	
-//	public void readLine(int length, AsyncResult<String> cb) {
-//		this.iostream.read_until("\r\n", cb);
-//	}
-//
-//	public void read(int length, AsyncResult<String> cb) {
-//		this.iostream.read_byte(length, cb);
-//	}
-
-	public void write(String data, AsyncResult<String> cb) {
-		DynamicByteBuffer dbb = DynamicByteBuffer.allocate(1024);
-		dbb.put(data.getBytes(Charsets.UTF_8));
-		SelectionKey key = IOLoop.INSTANCE.addHandler(channel, handler, SelectionKey.OP_WRITE, dbb);
-		handler.addReadCallback(key, cb);
-		//this.iostream.write(data);		
-	}
-
-}
diff --git a/src/main/java/org/deftserver/example/kv/KeyValueStore.java b/src/main/java/org/deftserver/example/kv/KeyValueStore.java
index f8efb07..238e1da 100644
--- a/src/main/java/org/deftserver/example/kv/KeyValueStore.java
+++ b/src/main/java/org/deftserver/example/kv/KeyValueStore.java
@@ -35,7 +35,7 @@ public class KeyValueStore extends Thread {
 		logger.debug("Initializing KeyValueStore");
 		initialize();
 	}
-
+	
 	public void run() {
 		try {
 			logger.debug("KeyValueStore waiting for clients...");	
@@ -44,24 +44,30 @@ public class KeyValueStore extends Thread {
 			BufferedWriter os = new BufferedWriter(new OutputStreamWriter(clientSocket.getOutputStream()));
 			BufferedReader is = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
 			String input = is.readLine();
+			logger.debug("KeyValueStore received input: {}", input);
 			if (input.split("\\s+").length == 2) {
 				input = input.split("\\s+")[1];	// "GET deft" => "deft"
 			}
-			logger.debug("KeyValueStore received input: {}", input);
+			int sleep = 250;
 			if (input != null) {
-				logger.debug("KeyValueStore server sleeps...");
+				logger.debug("KeyValueStore server sleeps " + sleep + "ms..." );
 				try {
-					Thread.sleep(1*500);
+					Thread.sleep(sleep);
 				} catch (InterruptedException e) {
 					e.printStackTrace();
 				}
 				logger.debug("KeyValueStore woke up...");
-				String value = dict.get(input);
+				String value = dict.get(input) + "\r\n";
 				os.write(value, 0, value.length());
-				logger.debug("KeyValueStore echoed back");
+				logger.debug("KeyValueStore echoed back: " + value);
 				os.flush();
 			}
 
+			try {
+				Thread.sleep(sleep);
+			} catch (InterruptedException e) {
+				e.printStackTrace();
+			}
 			{	// cleanup
 				try {
 					if (is != null)
diff --git a/src/main/java/org/deftserver/example/kv/KeyValueStoreClient.java b/src/main/java/org/deftserver/example/kv/KeyValueStoreClient.java
new file mode 100644
index 0000000..5ca7671
--- /dev/null
+++ b/src/main/java/org/deftserver/example/kv/KeyValueStoreClient.java
@@ -0,0 +1,60 @@
+package org.deftserver.example.kv;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+
+import org.deftserver.io.AsynchronousSocket;
+import org.deftserver.io.IOLoop;
+import org.deftserver.web.AsyncCallback;
+import org.deftserver.web.AsyncResult;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class KeyValueStoreClient {
+	
+	private final static Logger logger = LoggerFactory.getLogger(KeyValueStoreClient.class);
+	
+	private AsynchronousSocket socket;
+	private SocketChannel channel;
+	private final String host;
+	private final int port;
+	
+	public KeyValueStoreClient(String host, int port) {
+		this.host = host;
+		this.port = port;
+	}
+
+	public void connect() {
+		try {
+			channel = SocketChannel.open(new InetSocketAddress(host, port));
+			channel.configureBlocking(false);
+		} catch (IOException e) { e.printStackTrace(); }
+		socket = new AsynchronousSocket(channel);
+		IOLoop.INSTANCE.addHandler(channel, socket, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
+	}
+	
+	public void get(String value, AsyncResult<String> cb) {
+		socket.write("GET deft\r\n", new WriteCallback(cb));
+	}
+	
+	private class WriteCallback implements AsyncCallback {
+
+		private final AsyncResult<String> cb;
+		
+		public WriteCallback(AsyncResult<String> cb) { 
+			this.cb = cb; 
+		}
+		
+		@Override
+		public void onCallback() {
+			// write is finished. read response from server
+			logger.debug("readUntil: \r\n");
+			socket.readUntil("\r\n", cb);
+		}
+		
+	}
+	
+}
diff --git a/src/main/java/org/deftserver/example/kv/KeyValueStoreExample.java b/src/main/java/org/deftserver/example/kv/KeyValueStoreExample.java
index 5627b13..7f90bf2 100644
--- a/src/main/java/org/deftserver/example/kv/KeyValueStoreExample.java
+++ b/src/main/java/org/deftserver/example/kv/KeyValueStoreExample.java
@@ -19,18 +19,9 @@ public class KeyValueStoreExample {
 	private final static Logger logger = LoggerFactory.getLogger(KeyValueStoreExample.class);
 	private final static int PORT = 8080;
 	
-	private static class HelloWorldRequestHandler extends RequestHandler {
-
-		@Override
-		public void get(HttpRequest request, HttpResponse response) {
-			response.write("hello world");
-		}
-
-	}
-	
 	private static class KeyValueStoreExampleRequestHandler extends RequestHandler {
 
-		private final Client client = new Client();
+		private final KeyValueStoreClient client = new KeyValueStoreClient(KeyValueStore.HOST, KeyValueStore.PORT);
 		
 		public KeyValueStoreExampleRequestHandler() {
 			new KeyValueStore().start();
@@ -49,12 +40,9 @@ public class KeyValueStoreExample {
 	}
 	
 	public static void main(String[] args) {
-		Map<String, RequestHandler> reqHandlers = new HashMap<String, RequestHandler>();
-		reqHandlers.put("/", new HelloWorldRequestHandler());
-		reqHandlers.put("/kv", new KeyValueStoreExampleRequestHandler());
-		
-		Application application = new Application(reqHandlers);
-
+		Map<String, RequestHandler> handlers = new HashMap<String, RequestHandler>();
+		handlers.put("/kv", new KeyValueStoreExampleRequestHandler());
+		Application application = new Application(handlers);
 		logger.debug("Starting up server on port: " + PORT);
 		HttpServer server = new HttpServer(application);
 		server.listen(PORT);
diff --git a/src/main/java/org/deftserver/example/kv/KeyValueStoreIOHandler.java b/src/main/java/org/deftserver/example/kv/KeyValueStoreIOHandler.java
deleted file mode 100644
index 3a06c3a..0000000
--- a/src/main/java/org/deftserver/example/kv/KeyValueStoreIOHandler.java
+++ /dev/null
@@ -1,86 +0,0 @@
-package org.deftserver.example.kv;
-
-import java.io.IOException;
-import java.nio.ByteBuffer;
-import java.nio.channels.SelectionKey;
-import java.nio.channels.SocketChannel;
-import java.util.Map;
-
-import org.deftserver.io.IOHandler;
-import org.deftserver.io.IOLoop;
-import org.deftserver.io.buffer.DynamicByteBuffer;
-import org.deftserver.util.Closeables;
-import org.deftserver.web.AsyncResult;
-import org.slf4j.Logger;
-import org.slf4j.LoggerFactory;
-
-import com.google.common.base.Charsets;
-import com.google.common.collect.Maps;
-
-public class KeyValueStoreIOHandler implements IOHandler {
-	
-	private final Logger logger = LoggerFactory.getLogger(KeyValueStoreIOHandler.class);
-	
-	// Read callbacks (callbacks that are supposed to be invoked upon a successful read)
-	private final Map<SelectionKey, AsyncResult<String>> rcbs = Maps.newHashMap();
-
-	@Override
-	public void handleAccept(SelectionKey key) throws IOException {
-//		logger.debug("[KeyValueStoreHandler] handle accept...");
-//		SocketChannel clientChannel = ((ServerSocketChannel) key.channel()).accept();
-//		clientChannel.configureBlocking(false);
-//		IOLoop.INSTANCE.addHandler(clientChannel, this, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
-	}
-
-	@Override
-	public void handleRead(SelectionKey key) throws IOException {
-		logger.debug("[KeyValueStoreHandler] handle read...");
-		SocketChannel channel = (SocketChannel) key.channel();
-		ByteBuffer buffer = (ByteBuffer) key.attachment();
-		try {
-			long bytesRead = channel.read(buffer);
-			logger.debug("[KeyValueStoreHandler] read data: {} bytes", bytesRead);
-		} catch (IOException e) {
-			if (rcbs.containsKey(key)) { rcbs.get(key).onFailure(e); }
-			logger.debug("[KeyValueStoreHandler] could not read data: ", e.getMessage());
-			Closeables.closeQuietly(channel);
-		}
-		int length = buffer.position();
-		buffer.flip();
-		String data = new String(buffer.array(), 0, length, Charsets.UTF_8);
-		logger.debug("[KeyValueStoreHandler] KeyValueStore server sent: {}", data);
-		Closeables.closeQuietly(channel);
-		logger.debug("[KeyValueStoreHandler] closed connection to KeyValueStore");
-		if (rcbs.containsKey(key)) {
-			rcbs.get(key).onSuccess(data);
-		}
-	}
-
-	@Override
-	public void handleWrite(SelectionKey key) {
-		logger.debug("[KeyValueStoreHandler] handle write...");
-		DynamicByteBuffer dbb = (DynamicByteBuffer) key.attachment();
-		ByteBuffer toSend = dbb.getByteBuffer();
-		SocketChannel channel = (SocketChannel)key.channel();
-		logger.debug("[KeyValueStoreHandler] about to send: {} bytes", dbb.position());
-		try {
-			toSend.flip();	// prepare for write
-			long bytesWritten = channel.write(toSend);
-			logger.debug("[KeyValueStoreHandler] sent: {} bytes", bytesWritten);
-			if (!toSend.hasRemaining()) {
-			} else {
-				toSend.compact();	// make room for more data be "read" in
-			}
-		} catch (IOException e) {
-			logger.error("[KeyValueStoreHandler] Failed to send data to client: {}", e.getMessage());
-		}
-		IOLoop.INSTANCE.addHandler(channel, this, SelectionKey.OP_READ, ByteBuffer.allocate(1024));
-	}
-	
-	void addReadCallback(SelectionKey key, AsyncResult<String> cb) {
-		rcbs.put(key, cb);
-	}
-
-	@Override public String toString() { return "KeyValueStoreIOHandler"; }
-	
-}
diff --git a/src/main/java/org/deftserver/io/AsynchronousSocket.java b/src/main/java/org/deftserver/io/AsynchronousSocket.java
new file mode 100644
index 0000000..5f8be21
--- /dev/null
+++ b/src/main/java/org/deftserver/io/AsynchronousSocket.java
@@ -0,0 +1,203 @@
+package org.deftserver.io;
+
+import java.io.IOException;
+import java.net.InetSocketAddress;
+import java.nio.ByteBuffer;
+import java.nio.channels.SelectableChannel;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.SocketChannel;
+
+import org.deftserver.util.Closeables;
+import org.deftserver.web.AsyncCallback;
+import org.deftserver.web.AsyncResult;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+import com.google.common.base.Charsets;
+
+public class AsynchronousSocket implements IOHandler {
+	
+	private static final Logger logger = LoggerFactory.getLogger(AsynchronousSocket.class);
+	
+	private final int DEFAULT_BYTEBUFFER_SIZE = 1024;
+	
+	private final SelectableChannel channel;
+	private int interestOps;
+	
+	private String readDelimiter = "";
+	
+	private AsyncCallback connectCallback = AsyncCallback.nopCb;
+	private AsyncCallback closeCallback = AsyncCallback.nopCb;
+	private AsyncResult<String> readCallback = NopAsyncStringResult;
+	private AsyncCallback writeCallback = AsyncCallback.nopCb;
+	
+	private final StringBuilder readBuffer = new StringBuilder();
+	private final StringBuilder writeBuffer = new StringBuilder();
+	
+	public AsynchronousSocket(SelectableChannel channel) {
+		this.channel = channel;
+		interestOps = /*SelectionKey.OP_ACCEPT | */SelectionKey.OP_CONNECT;
+		if (channel instanceof SocketChannel && (((SocketChannel) channel).isConnected())) {
+			interestOps |= SelectionKey.OP_READ;
+		}
+		IOLoop.INSTANCE.addHandler(channel, this, interestOps, null);
+	}
+	
+	/**
+	 * Connects to the given host port tuple and invokes the given callback when a successful connection is established.
+	 */
+	public void connect(String host, int port, AsyncCallback ccb) {
+		IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_CONNECT);
+		connectCallback = ccb;
+		if (channel instanceof SocketChannel) {
+			try {
+				((SocketChannel) channel).connect(new InetSocketAddress(host, port));
+			} catch (IOException e) {
+				logger.error("Failed to connect to: {}, message: {} ", host, e.getMessage());
+			}
+		}
+	}
+	
+	/**
+	 * Close the socket.
+	 */
+	public void close() {
+		try {
+			channel.close();
+			closeCallback.onCallback();
+			closeCallback = AsyncCallback.nopCb;
+		} catch (IOException e) {
+			logger.error("Could not close SocketChannel: {}", e.getMessage());
+		}
+	}
+	
+	public void setCloseCallback(AsyncCallback ccb) {
+		closeCallback = ccb;
+	}
+	
+	/**
+	 * Should only be invoked by the IOLoop
+	 */
+	@Override
+	public void handleAccept(SelectionKey key) throws IOException {
+		logger.debug("handle accept...");
+	}
+
+	/**
+	 * Should only be invoked by the IOLoop
+	 */
+	@Override
+	public void handleConnect(SelectionKey key) throws IOException {
+		logger.debug("handle connect...");
+		((SocketChannel) channel).finishConnect();
+		connectCallback.onCallback();
+		connectCallback = AsyncCallback.nopCb;
+		interestOps &= ~SelectionKey.OP_CONNECT;
+		IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_READ);
+		
+	}
+	
+	/**
+	 * Should only be invoked by the IOLoop
+	 */
+	@Override
+	public void handleRead(SelectionKey key) throws IOException {
+		logger.debug("handle read...");
+		ByteBuffer buffer = ByteBuffer.allocate(DEFAULT_BYTEBUFFER_SIZE);
+		int read = ((SocketChannel) key.channel()).read(buffer);
+		if (read == -1) {	// EOF
+			closeCallback.onCallback();
+			closeCallback = AsyncCallback.nopCb;
+			Closeables.closeQuietly(key.channel());
+			return;
+		}
+		readBuffer.append(new String(buffer.array(), 0, buffer.position(), Charsets.UTF_8));
+		logger.debug("readBuffer size: {}", readBuffer.length());
+		checkReadState();
+	}
+
+	/**
+	 * Should only be invoked by the IOLoop
+	 */
+	@Override
+	public void handleWrite(SelectionKey key) {
+		logger.debug("handle write...");
+		doWrite();
+	}
+
+	/**
+	 * Reads from the underlaying SelectableChannel until delimiter is reached. When it its, the given
+	 * AsyncResult will be invoked.
+	 */
+	public void readUntil(String delimiter, AsyncResult<String> rcb) {
+		logger.debug("readUntil delimiter: {}", delimiter);
+		readDelimiter = delimiter;
+		readCallback = rcb;
+		checkReadState();
+	}
+	
+	/**
+	 *  If readBuffer contains readDelimiter, client read is finished => invoke readCallback
+	 */
+	private void checkReadState() {
+		int index = readBuffer.indexOf(readDelimiter);
+		if (index != -1 && !readDelimiter.isEmpty()) {
+			String result = readBuffer.substring(0, index /*+ readDelimiter.length()*/);
+			readCallback.onSuccess(result);
+			readBuffer.delete(0, index + readDelimiter.length());
+			logger.debug("readBuffer size: {}", readBuffer.length());
+			readDelimiter = "";
+			readCallback = NopAsyncStringResult;
+		}
+	}
+
+	/**
+	 * Writes the given data to the underlaying SelectableChannel. When all data is successfully transmitted, the given 
+	 * AsyncCallback will be invoked 
+	 */
+	public void write(String data, AsyncCallback wcb) {
+		logger.debug("write data: {}", data);
+		writeBuffer.append(data);
+		logger.debug("writeBuffer size: {}", writeBuffer.length());
+		writeCallback = wcb;
+		doWrite();
+	}
+	
+	/**
+	 * If we succeed to write everything in writeBuffer, client write is finished => invoke writeCallback
+	 */
+	private void doWrite() {
+		int written = 0;
+		try {
+			if (((SocketChannel)channel).isConnected()) {
+				written = ((SocketChannel) channel).write(ByteBuffer.wrap(writeBuffer.toString().getBytes()));
+			}
+		} catch (IOException e) {
+			logger.error("IOException during write: {}", e.getMessage());
+			closeCallback.onCallback();
+			closeCallback = AsyncCallback.nopCb;
+			Closeables.closeQuietly(channel);
+		}
+		writeBuffer.delete(0, written);
+		logger.debug("wrote: {} bytes", written);
+		logger.debug("writeBuffer size: {}", writeBuffer.length());
+		if (writeBuffer.length() > 0) {
+			IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_WRITE);
+		} else {
+			IOLoop.INSTANCE.updateHandler(channel, interestOps &= ~SelectionKey.OP_WRITE);
+			writeCallback.onCallback();
+			writeCallback = AsyncCallback.nopCb;
+		}
+	}
+
+
+	private static final AsyncResult<String> NopAsyncStringResult = new AsyncResult<String>() {
+
+		@Override public void onFailure(Throwable caught) {}
+		
+		@Override public void onSuccess(String result) {} 
+	
+	};
+
+
+}
diff --git a/src/main/java/org/deftserver/io/IOHandler.java b/src/main/java/org/deftserver/io/IOHandler.java
index 46b2a6c..a22521d 100644
--- a/src/main/java/org/deftserver/io/IOHandler.java
+++ b/src/main/java/org/deftserver/io/IOHandler.java
@@ -11,6 +11,8 @@ import java.nio.channels.SelectionKey;
 public interface IOHandler {
 
 	void handleAccept(SelectionKey key) throws IOException;
+
+	void handleConnect(SelectionKey key) throws IOException;
 	
 	void handleRead(SelectionKey key) throws IOException;
 	
diff --git a/src/main/java/org/deftserver/io/IOLoop.java b/src/main/java/org/deftserver/io/IOLoop.java
index 31556c1..850290c 100644
--- a/src/main/java/org/deftserver/io/IOLoop.java
+++ b/src/main/java/org/deftserver/io/IOLoop.java
@@ -32,6 +32,8 @@ public enum IOLoop implements IOLoopMXBean {
 	
 	INSTANCE;
 	
+	private boolean running = false;
+	
 	private final Logger logger = LoggerFactory.getLogger(IOLoop.class);
 
 	private Selector selector;
@@ -52,15 +54,16 @@ public enum IOLoop implements IOLoopMXBean {
 	
 	public void start() {
 		Thread.currentThread().setName("I/O-LOOP");
-
-		while (true) {
-			long selectorTimeout = 250; // 250 ms
+		running = true;
+		
+		long selectorTimeout = 250; // 250 ms
+		while (running) {
 			try {
 				if (selector.select(selectorTimeout) == 0) {
 					long ms = tm.execute();
-					selectorTimeout = Math.min(ms, selectorTimeout);
+					selectorTimeout = Math.min(ms, /*selectorTimeout*/ 250);
 					if (cm.execute()) {
-						selectorTimeout = 0;
+						selectorTimeout = 1;
 					}
 					continue;
 				}
@@ -72,6 +75,9 @@ public enum IOLoop implements IOLoopMXBean {
 					if (key.isAcceptable()) {
 						handler.handleAccept(key);
 					}
+					if (key.isConnectable()) {
+						handler.handleConnect(key);
+					}
 					if (key.isReadable()) {
 						handler.handleRead(key);
 					}
@@ -81,9 +87,9 @@ public enum IOLoop implements IOLoopMXBean {
 					keys.remove();
 				}
 				long ms = tm.execute();
-				selectorTimeout = Math.min(ms, selectorTimeout);
+				selectorTimeout = Math.min(ms, /*selectorTimeout*/ 250);
 				if (cm.execute()) { 
-					selectorTimeout = 0; 
+					selectorTimeout = 1; 
 				}
 
 			} catch (IOException e) {
@@ -91,6 +97,11 @@ public enum IOLoop implements IOLoopMXBean {
 			}
 		}
 	}
+	
+	public void stop() {
+		running = false;
+		logger.debug("Stopping IOLoop...");
+	}
 
 	public SelectionKey addHandler(SelectableChannel channel, IOHandler handler, int interestOps, Object attachment) {
 		handlers.put(channel, handler);
@@ -101,6 +112,18 @@ public enum IOLoop implements IOLoopMXBean {
 		handlers.remove(channel);
 	}
 	
+	/**
+	 * 
+	 * @param newInterestOps The complete new set of interest operations.
+	 */
+	public void updateHandler(SelectableChannel channel, int newInterestOps) {
+		if (handlers.containsKey(channel)) {
+			channel.keyFor(selector).interestOps(newInterestOps);
+		} else {
+			logger.warn("Tried to update interestOps for an unknown SelectableChannel.");
+		}
+	}
+	
 	private SelectionKey registerChannel(SelectableChannel channel, int interestOps, Object attachment) {
 		try {
 			return channel.register(selector, interestOps, attachment);
diff --git a/src/main/java/org/deftserver/io/callback/PeriodicCallback.java b/src/main/java/org/deftserver/io/callback/PeriodicCallback.java
new file mode 100644
index 0000000..792fccd
--- /dev/null
+++ b/src/main/java/org/deftserver/io/callback/PeriodicCallback.java
@@ -0,0 +1,43 @@
+package org.deftserver.io.callback;
+
+import org.deftserver.io.IOLoop;
+import org.deftserver.io.timeout.Timeout;
+import org.deftserver.web.AsyncCallback;
+
+public class PeriodicCallback {
+	
+	private final AsyncCallback cb;
+	private final long period;
+	private boolean active = true;
+	
+	/** 
+	 * A periodic callback that will execute its callback once every period.
+	 * @param cb 
+	 * @param period The period in ms
+	 */
+	public PeriodicCallback(AsyncCallback cb, long period) {
+		this.cb = cb;
+		this.period = period;
+	}
+	
+	public void start() {
+		IOLoop.INSTANCE.addTimeout(
+				new Timeout(
+						System.currentTimeMillis() + period, 
+						new AsyncCallback() { @Override public void onCallback() { run(); }}
+				)
+		);
+	}
+	
+	private void run() {
+		if (active) {
+			cb.onCallback();
+			start();	// reschedule
+		}
+	}
+	
+	public void cancel() {
+		this.active = false;
+	}
+	
+}
diff --git a/src/main/java/org/deftserver/io/timeout/JMXDebuggableTimeoutManager.java b/src/main/java/org/deftserver/io/timeout/JMXDebuggableTimeoutManager.java
index 107436d..d9a0d9b 100644
--- a/src/main/java/org/deftserver/io/timeout/JMXDebuggableTimeoutManager.java
+++ b/src/main/java/org/deftserver/io/timeout/JMXDebuggableTimeoutManager.java
@@ -64,10 +64,9 @@ public class JMXDebuggableTimeoutManager implements TimeoutManager, TimeoutManag
 		// makes a defensive copy to avoid (1) CME (new timeouts are added this iteration) and (2) IO starvation.
 		TreeMultiset<DecoratedTimeout> defensive = TreeMultiset.create(timeouts);
 		Iterator<DecoratedTimeout> iter = defensive.iterator();
-		DecoratedTimeout candidate = null;
 		final long now = System.currentTimeMillis();
 		while (iter.hasNext()) {
-			candidate = iter.next();
+			DecoratedTimeout candidate = iter.next();
 			if (candidate.timeout.getTimeout() > now) { break; }
 			candidate.timeout.getCallback().onCallback();
 			index.remove(candidate.channel);
@@ -75,7 +74,7 @@ public class JMXDebuggableTimeoutManager implements TimeoutManager, TimeoutManag
 			timeouts.remove(candidate);
 			logger.debug("Timeout triggered: {}", candidate.timeout);
 		}
-		return timeouts.isEmpty() ? Long.MAX_VALUE : Math.max(0, candidate.timeout.getTimeout() - now);
+		return timeouts.isEmpty() ? Long.MAX_VALUE : Math.max(1, timeouts.iterator().next().timeout.getTimeout() - now);
 	}
 
 	// implements TimoutMXBean
diff --git a/src/main/java/org/deftserver/io/timeout/Timeout.java b/src/main/java/org/deftserver/io/timeout/Timeout.java
index e519db5..39952d5 100644
--- a/src/main/java/org/deftserver/io/timeout/Timeout.java
+++ b/src/main/java/org/deftserver/io/timeout/Timeout.java
@@ -9,8 +9,6 @@ public class Timeout {
 	private final AsyncCallback cb;
 	private boolean cancelled = false;
 	
-	private final AsyncCallback nopCb = new AsyncCallback() { @Override public void onCallback() { /*nop*/} };
-
 	public Timeout(long timeout, AsyncCallback cb) {
 		this.timeout = timeout;
 		this.cb = cb;
@@ -29,7 +27,7 @@ public class Timeout {
 	}
 
 	public AsyncCallback getCallback() {
-		return cancelled ? nopCb : cb;
+		return cancelled ? AsyncCallback.nopCb : cb;
 	}
 
 }
diff --git a/src/main/java/org/deftserver/io/timeout/TimeoutManager.java b/src/main/java/org/deftserver/io/timeout/TimeoutManager.java
index 9b7c06e..50526ea 100644
--- a/src/main/java/org/deftserver/io/timeout/TimeoutManager.java
+++ b/src/main/java/org/deftserver/io/timeout/TimeoutManager.java
@@ -15,7 +15,7 @@ public interface TimeoutManager {
 	
 	/**
 	 * 
-	 * @return the positive number of milliseconds until next scheduled timeout.
+	 * @return the positive number (>0) of milliseconds until next scheduled timeout.
 	 */
 	long execute();
 	
diff --git a/src/main/java/org/deftserver/web/AsyncCallback.java b/src/main/java/org/deftserver/web/AsyncCallback.java
index 1aab68f..78cdbdb 100644
--- a/src/main/java/org/deftserver/web/AsyncCallback.java
+++ b/src/main/java/org/deftserver/web/AsyncCallback.java
@@ -6,7 +6,9 @@ package org.deftserver.web;
 * 	async call (similar to {@link AsyncResult}).
 */
 public interface AsyncCallback {
-
+	
+	public static final AsyncCallback nopCb = new AsyncCallback() { @Override public void onCallback() { /*nop*/} };
+	
 	void onCallback();
 	
 }
diff --git a/src/main/java/org/deftserver/web/http/HttpProtocol.java b/src/main/java/org/deftserver/web/http/HttpProtocol.java
index 806e524..6a3f4e4 100644
--- a/src/main/java/org/deftserver/web/http/HttpProtocol.java
+++ b/src/main/java/org/deftserver/web/http/HttpProtocol.java
@@ -44,6 +44,11 @@ public class HttpProtocol implements IOHandler {
 		clientChannel.configureBlocking(false);
 		IOLoop.INSTANCE.addHandler(clientChannel, this, SelectionKey.OP_READ, ByteBuffer.allocate(READ_BUFFER_SIZE));
 	}
+	
+	@Override
+	public void handleConnect(SelectionKey key) throws IOException {
+		logger.error("handle connect in HttpProcotol...");
+	}
 
 	@Override
 	public void handleRead(SelectionKey key) throws IOException {
diff --git a/src/test/java/org/deftserver/io/AsynchronousSocketTest.java b/src/test/java/org/deftserver/io/AsynchronousSocketTest.java
new file mode 100644
index 0000000..261ea76
--- /dev/null
+++ b/src/test/java/org/deftserver/io/AsynchronousSocketTest.java
@@ -0,0 +1,127 @@
+package org.deftserver.io;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.ServerSocket;
+import java.net.Socket;
+import java.nio.channels.SelectableChannel;
+import java.nio.channels.SocketChannel;
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.deftserver.web.AsyncCallback;
+import org.deftserver.web.AsyncResult;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+public class AsynchronousSocketTest {
+
+	public static final String HOST = "localhost";
+	public static final int PORT = 6228;
+
+	@Before
+	public void setup() throws InterruptedException {
+		// start the IOLoop from a new thread so we dont block this test.
+		new Thread(new Runnable() {
+			@Override public void run() { IOLoop.INSTANCE.start(); }
+		}).start();
+		Thread.sleep(300);	// hack to avoid SLF4J warning
+		
+		final CountDownLatch latch = new CountDownLatch(1);	
+		new Thread(new Runnable() {
+
+			@Override
+			public void run() {
+				DataInputStream is = null;
+				DataOutputStream os = null;
+				try {
+					System.out.println("waiting for client...");
+					ServerSocket server = new ServerSocket(PORT);
+					latch.countDown();
+					Socket client = server.accept();
+					System.out.println("client connected..");
+					is = new DataInputStream(client.getInputStream());
+					os = new DataOutputStream(client.getOutputStream());
+
+					String recevied = is.readLine();
+					System.out.println("about to send: " + recevied);
+					os.writeBytes(recevied.toUpperCase());
+					System.out.println("sent data to client, shutdown server...");
+					server.close();
+				} catch (Exception e) {
+					e.printStackTrace();
+				} finally {
+					closeQuietly(is, os);
+				}
+			}
+		}).start();
+		
+		latch.await(5, TimeUnit.SECONDS);
+	}
+	
+	@After
+	public void tearDown() throws InterruptedException {
+		IOLoop.INSTANCE.addCallback(new AsyncCallback() {
+			@Override
+			public void onCallback() { IOLoop.INSTANCE.stop(); }
+		});
+		Thread.sleep(300);	// give the IOLoop thread some time to gracefully shutdown
+	}
+
+	private void closeQuietly(InputStream is, OutputStream os) {
+		try {
+			if (is != null) is.close();
+			if (os != null) os.close();
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+
+	private final AsynchronousSocket socket;
+	private final CountDownLatch latch = new CountDownLatch(3);	// 3 op/callbacks (connect, write, read)
+	
+	public AsynchronousSocketTest() throws IOException {
+		SelectableChannel channel = SocketChannel.open();
+		channel.configureBlocking(false);
+		socket = new AsynchronousSocket(channel);
+	}
+	
+	@Test
+	public void connectWriteAndReadCallbackTest() throws InterruptedException, IOException {
+		AsyncCallback ccb = new AsyncCallback() { @Override public void onCallback() { onConnect(); }};
+		socket.connect(HOST, PORT, ccb);
+		
+		latch.await(5, TimeUnit.SECONDS);
+		
+		assertEquals(0, latch.getCount());
+		// TODO stop ioloop
+	}
+	
+	private void onConnect() {
+		latch.countDown();
+		AsyncCallback wcb = new AsyncCallback() { @Override public void onCallback() { onWriteComplete(); }};
+		socket.write("roger|\r\n", wcb);
+	}
+	
+	private void onWriteComplete() {
+		latch.countDown();
+		AsyncResult<String> rcb = new AsyncResult<String>() { 
+			@Override public void onFailure(Throwable caught) { assertTrue(false); }
+			@Override public void onSuccess(String result) { onReadComplete(result); }
+		};
+		socket.readUntil("|", rcb);
+	}
+	
+	private void onReadComplete(String result) {
+		latch.countDown();
+		assertEquals("ROGER", result);
+	}
+	
+}
diff --git a/src/test/java/org/deftserver/io/callback/PeriodicCallbackTest.java b/src/test/java/org/deftserver/io/callback/PeriodicCallbackTest.java
new file mode 100644
index 0000000..d143975
--- /dev/null
+++ b/src/test/java/org/deftserver/io/callback/PeriodicCallbackTest.java
@@ -0,0 +1,38 @@
+package org.deftserver.io.callback;
+
+import static org.junit.Assert.assertEquals;
+
+import java.util.concurrent.CountDownLatch;
+import java.util.concurrent.TimeUnit;
+
+import org.deftserver.io.IOLoop;
+import org.deftserver.web.AsyncCallback;
+import org.junit.Test;
+
+public class PeriodicCallbackTest {
+	
+	@Test
+	public void testPeriodicCallback() throws InterruptedException {
+		// start the IOLoop from a new thread so we dont block this test.
+		new Thread(new Runnable() {
+
+			@Override public void run() { IOLoop.INSTANCE.start(); }
+		
+		}).start();
+		
+		final CountDownLatch latch = new CountDownLatch(200);
+		long period = 10; // 10ms (=> ~100times / s)
+		AsyncCallback cb = new AsyncCallback() {
+			@Override public void onCallback() { latch.countDown(); }
+		};
+		PeriodicCallback pcb = new PeriodicCallback(cb, period);
+		pcb.start();
+		
+		latch.await(5, TimeUnit.SECONDS);
+		pcb.cancel();
+		IOLoop.INSTANCE.stop();
+		// TODO wait?
+		assertEquals(0, latch.getCount());
+	}
+	
+}
diff --git a/src/test/java/org/deftserver/web/DeftSystemTest.java b/src/test/java/org/deftserver/web/DeftSystemTest.java
index cf97719..fae7208 100644
--- a/src/test/java/org/deftserver/web/DeftSystemTest.java
+++ b/src/test/java/org/deftserver/web/DeftSystemTest.java
@@ -38,13 +38,14 @@ import org.apache.http.params.HttpConnectionParams;
 import org.apache.http.params.HttpParams;
 import org.apache.http.params.HttpProtocolParams;
 import org.deftserver.example.AsyncDbHandler;
-import org.deftserver.example.kv.Client;
 import org.deftserver.example.kv.KeyValueStore;
+import org.deftserver.example.kv.KeyValueStoreClient;
 import org.deftserver.io.IOLoop;
 import org.deftserver.io.timeout.Timeout;
 import org.deftserver.web.handler.RequestHandler;
 import org.deftserver.web.http.HttpException;
 import org.deftserver.web.http.HttpRequest;
+import org.junit.AfterClass;
 import org.junit.BeforeClass;
 import org.junit.Test;
 
@@ -191,7 +192,7 @@ public class DeftSystemTest {
 
 	public static class KeyValueStoreExampleRequestHandler extends RequestHandler {
 
-		private final Client client = new Client();
+		private final KeyValueStoreClient client = new KeyValueStoreClient(KeyValueStore.HOST, KeyValueStore.PORT);
 
 		public KeyValueStoreExampleRequestHandler() {
 			new KeyValueStore().start();
@@ -288,6 +289,12 @@ public class DeftSystemTest {
 				IOLoop.INSTANCE.start(); }
 		}).start();
 	}
+	
+	@AfterClass
+	public static void tearDown() throws InterruptedException {
+		IOLoop.INSTANCE.addCallback(new AsyncCallback() { @Override public void onCallback() { IOLoop.INSTANCE.stop(); }});
+		Thread.sleep(300);
+	}
 
 	@Test
 	public void simpleGetRequestTest() throws ClientProtocolException, IOException {
@@ -1058,7 +1065,7 @@ public class DeftSystemTest {
 		assertEquals(expected, convertStreamToString(response.getEntity().getContent()).trim());
 		assertEquals(expected.length()+"", response.getFirstHeader("Content-Length").getValue());
 	}
-
+	
 	public String convertStreamToString(InputStream is) throws IOException {
 		if (is != null) {
 			StringBuilder sb = new StringBuilder();
