diff --git a/src/main/java/org/deftserver/io/AsynchronousSocket.java b/src/main/java/org/deftserver/io/AsynchronousSocket.java
index 3ded081..4969ff0 100644
--- a/src/main/java/org/deftserver/io/AsynchronousSocket.java
+++ b/src/main/java/org/deftserver/io/AsynchronousSocket.java
@@ -44,6 +44,9 @@ public class AsynchronousSocket implements IOHandler {
 	
 	private boolean reachedEOF = false;
 	
+	/**
+	 * Create a new {@code AsynchronousSocket} that will delegate its io operations the given {@code SelectableChannel}.
+	 */
 	public AsynchronousSocket(SelectableChannel channel) {
 		this.channel = channel;
 		interestOps = SelectionKey.OP_CONNECT;
@@ -80,6 +83,9 @@ public class AsynchronousSocket implements IOHandler {
 		invokeCloseCallback();
 	}
 	
+	/**
+	 * The given callback will invoked when the underlaying {@code SelectableChannel} is closed. 
+	 */
 	public void setCloseCallback(AsyncCallback ccb) {
 		closeCallback = ccb;
 	}
diff --git a/src/main/java/org/deftserver/io/IOHandler.java b/src/main/java/org/deftserver/io/IOHandler.java
index a22521d..f2cce1e 100644
--- a/src/main/java/org/deftserver/io/IOHandler.java
+++ b/src/main/java/org/deftserver/io/IOHandler.java
@@ -3,9 +3,9 @@ package org.deftserver.io;
 import java.io.IOException;
 import java.nio.channels.SelectionKey;
 
-
 /**
- * TODO RS 101024 Add javadoc 
+ * {@code IOHandler}s are added to the IOLoop via {@link IOLoop#addHandler} method.
+ * The callbacks defined in the {@code IOHandler} will be invoked by the {@code IOLoop} when io is ready.
  *
  */
 public interface IOHandler {
diff --git a/src/main/java/org/deftserver/io/IOLoop.java b/src/main/java/org/deftserver/io/IOLoop.java
index 3fbf314..e99a74f 100644
--- a/src/main/java/org/deftserver/io/IOLoop.java
+++ b/src/main/java/org/deftserver/io/IOLoop.java
@@ -51,7 +51,10 @@ public enum IOLoop implements IOLoopMXBean {
 		}
 		MXBeanUtil.registerMXBean(this, "IOLoop");
 	}
-	
+	/**
+	 * Start the io loop. The thread that invokes this method will be blocked (until {@link IOLoop#stop} is invoked) 
+	 * and will be the io loop thread.
+	 */
 	public void start() {
 		Thread.currentThread().setName("I/O-LOOP");
 		running = true;
@@ -98,22 +101,42 @@ public enum IOLoop implements IOLoopMXBean {
 		}
 	}
 	
+	/**
+	 * Stop the io loop and release the thread (io loop thread) that invoked the {@link IOLoop#start} method.
+	 */
 	public void stop() {
 		running = false;
 		logger.debug("Stopping IOLoop...");
 	}
-
+	
+	/**
+	 * Registers a new {@code IOHandler} with this {@code IOLoop}.
+	 * 
+	 * @param channel The {@code SelectableChannel}
+	 * @param handler {@code IOHandler that will receive the io callbacks.}
+	 * @param interestOps See {@link SelectionKey} for valid values. (Xor for multiple interests).
+	 * @param attachment The {@code attachment} that will be accessible from the returning {@code SelectionKey}s 
+	 * attachment.
+	 * 
+	 */
 	public SelectionKey addHandler(SelectableChannel channel, IOHandler handler, int interestOps, Object attachment) {
 		handlers.put(channel, handler);
 		return registerChannel(channel, interestOps, attachment);		
 	}
 	
+	/**
+	 * Unregisters the previously registered {@code IOHandler}.
+
+	 * @param channel The {@code SelectableChannel} that was registered with a user defined {@code IOHandler}
+	 */
 	public void removeHandler(SelectableChannel channel) {
 		handlers.remove(channel);
 	}
 	
 	/**
+	 * Update an earlier registered {@code SelectableChannel}
 	 * 
+	 * @param channel The {@code SelectableChannel}
 	 * @param newInterestOps The complete new set of interest operations.
 	 */
 	public void updateHandler(SelectableChannel channel, int newInterestOps) {
@@ -124,6 +147,13 @@ public enum IOLoop implements IOLoopMXBean {
 		}
 	}
 	
+	/**
+	 * 
+	 * @param channel
+	 * @param interestOps
+	 * @param attachment
+	 * @return
+	 */
 	private SelectionKey registerChannel(SelectableChannel channel, int interestOps, Object attachment) {
 		try {
 			return channel.register(selector, interestOps, attachment);
@@ -145,7 +175,12 @@ public enum IOLoop implements IOLoopMXBean {
 	public void addTimeout(Timeout timeout) {
 		tm.addTimeout(timeout);
 	}
-	
+
+	/**
+	 * The callback will be invoked in the next iteration in the io loop. This is the only thread safe method that is
+	 * exposed by Deft. 
+	 * This is a convenient way to return control to the io loop.
+	 */
 	public void addCallback(AsyncCallback callback) {
 		cm.addCallback(callback);
 	}
diff --git a/src/main/java/org/deftserver/io/buffer/DynamicByteBuffer.java b/src/main/java/org/deftserver/io/buffer/DynamicByteBuffer.java
index e7c4f66..746a968 100644
--- a/src/main/java/org/deftserver/io/buffer/DynamicByteBuffer.java
+++ b/src/main/java/org/deftserver/io/buffer/DynamicByteBuffer.java
@@ -1,6 +1,5 @@
 package org.deftserver.io.buffer;
 
-import java.nio.Buffer;
 import java.nio.ByteBuffer;
 
 import org.slf4j.Logger;
@@ -18,15 +17,26 @@ public class DynamicByteBuffer {
 		this.backend = bb;
 	}
 	
+	/**
+	 * Allocate a new {@code DynamicByteBuffer} that will be using a {@ByteBuffer} internally.
+	 * @param capacity initial capacity
+	 */
 	public static DynamicByteBuffer allocate(int capacity) {
 		return new DynamicByteBuffer(ByteBuffer.allocate(capacity));
 	}
 
+	/**
+	 * Append the data. Will reallocate if needed.
+	 */
 	public void put(byte[] src) {
 		ensureCapacity(src.length);
 		backend.put(src);
 	}
+
 	
+	/**
+	 * Prepend the data. Will reallocate if needed.
+	 */
 	public void prepend(String data) {
 		byte[] bytes = data.getBytes(Charsets.UTF_8);
 		int newSize = bytes.length + backend.position();
@@ -60,39 +70,67 @@ public class DynamicByteBuffer {
 		logger.debug("allocated new DynamicByteBufer, new capacity: {}", backend.capacity());
 	}
 	
+	/**
+	 * Returns the {@code ByteBuffer} that is used internally by this {@DynamicByteBufer}.
+	 * Changes made to the returned {@code ByteBuffer} will be incur modifications in this {@DynamicByteBufer}.
+	 */
 	public ByteBuffer getByteBuffer() {
 		return backend;
 	}
 
+	/**
+	 * See {@link ByteBuffer#flip}
+	 */
 	public void flip() {
 		backend.flip();
 	}
 
+	/**
+	 * See {@link ByteBuffer#limit}
+	 */
 	public int limit() {
 		return backend.limit();
 	}
 
+	/**
+	 * See {@link ByteBuffer#position}
+	 */
 	public int position() {
 		return backend.position();
 	}
 
+	/**
+	 * See {@link ByteBuffer#array}
+	 */	
 	public byte[] array() {
 		return backend.array();
 	}
 
+	/**
+	 * See {@link ByteBuffer#capacity}
+	 */
 	public int capacity() {
 		return backend.capacity();
 	}
 
+	/**
+	 * See {@link ByteBuffer#hasRemaining}
+	 */
 	public boolean hasRemaining() {
 		return backend.hasRemaining();
 	}
 
+	/**
+	 * See {@link ByteBuffer#compact}
+	 */
 	public DynamicByteBuffer compact() {
 		backend.compact();
 		return this;
 	}
 
+	/**
+	 * See {@link ByteBuffer#clear}
+	 */
 	public DynamicByteBuffer clear() {
 		backend.clear();
 		return this;
diff --git a/src/main/java/org/deftserver/io/callback/PeriodicCallback.java b/src/main/java/org/deftserver/io/callback/PeriodicCallback.java
index 792fccd..01b102f 100644
--- a/src/main/java/org/deftserver/io/callback/PeriodicCallback.java
+++ b/src/main/java/org/deftserver/io/callback/PeriodicCallback.java
@@ -20,6 +20,9 @@ public class PeriodicCallback {
 		this.period = period;
 	}
 	
+	/**
+	 * Start the {@code PeriodicCallback}
+	 */
 	public void start() {
 		IOLoop.INSTANCE.addTimeout(
 				new Timeout(
@@ -36,6 +39,10 @@ public class PeriodicCallback {
 		}
 	}
 	
+	/**
+	 * Cancel the {@code PeriodicCallback}. (No way to resume the cancellation, you will need to create a new
+	 * {@code PeriodicCallback}).
+	 */
 	public void cancel() {
 		this.active = false;
 	}
diff --git a/src/main/java/org/deftserver/util/NopAsyncResult.java b/src/main/java/org/deftserver/util/NopAsyncResult.java
index 857674b..b6917fc 100644
--- a/src/main/java/org/deftserver/util/NopAsyncResult.java
+++ b/src/main/java/org/deftserver/util/NopAsyncResult.java
@@ -2,6 +2,9 @@ package org.deftserver.util;
 
 import org.deftserver.web.AsyncResult;
 
+/**
+ * Convenience class used to limit the Java verboseness.
+ */
 public class NopAsyncResult<T> {
 	
 	private NopAsyncResult() {}
diff --git a/src/main/java/org/deftserver/web/http/HttpResponse.java b/src/main/java/org/deftserver/web/http/HttpResponse.java
index 230d91f..e670d0e 100644
--- a/src/main/java/org/deftserver/web/http/HttpResponse.java
+++ b/src/main/java/org/deftserver/web/http/HttpResponse.java
@@ -49,12 +49,22 @@ public class HttpResponse {
 		headers.put(header, value);
 	}
 
+	/**
+	 * The given data data will be sent as the HTTP response upon next flush or when the response is finished.
+	 *
+	 * @return this for chaining purposes.
+	 */
 	public HttpResponse write(String data) {
 		byte[] bytes = data.getBytes(Charsets.UTF_8);
 		responseData.put(bytes);
 		return this;
 	}
 
+	/**
+	 * Explicit flush. 
+	 * 
+	 * @return the number of bytes that were actually written as the result of this flush.
+	 */
 	public long flush() {
 		if (!headersCreated) {
 			String initial = createInitalLineAndHeaders();			
@@ -87,6 +97,13 @@ public class HttpResponse {
 		return bytesFlushed;
 	}
 	
+	/**
+	 * Should only be invoked by third party asynchronous request handlers 
+	 * (or by the Deft framework for synchronous request handlers). 
+	 * If no previous (explicit) flush is invoked, the "Content-Length" and "Etag" header will be calculated and 
+	 * inserted to the HTTP response.
+	 * 
+	 */
 	public long finish() {
 		long bytesWritten = 0;
 		SocketChannel clientChannel = (SocketChannel) key.channel();
@@ -131,6 +148,10 @@ public class HttpResponse {
 		return sb.toString();
 	}
 	
+	/**
+	 * Experimental support.
+	 * Before use, read https://github.com/rschildmeijer/deft/issues/75
+	 */
 	public long write(File file) {
 		//setHeader("Etag", HttpUtil.getEtag(file));
 		setHeader("Content-Length", String.valueOf(file.length()));
diff --git a/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java b/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
index f9152ec..3306d94 100644
--- a/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
+++ b/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
@@ -14,6 +14,23 @@ import org.deftserver.web.HttpVerb;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
+/**
+* This class implements a simple HTTP 1.1 client on top of Deft's {@code AsynchronousSocket}.
+* It does not currently implement all applicable parts of the HTTP
+* specification.
+* <pre>
+* E.g the following is not supported.
+*  - redirects
+*  - POST and PUT
+*  - Transfer-Encoding: chunked
+* </pre>
+* This class has not been tested extensively in production and
+* should be considered experimental as of the release of
+* Deft 0.3.
+* 
+* This http client is inspired by https://github.com/facebook/tornado/blob/master/tornado/simple_httpclient.py
+* and part of the documentation is simply copy pasted.
+*/
 public class AsynchronousHttpClient {
 
 	private static final Logger logger = LoggerFactory.getLogger(AsynchronousHttpClient.class);
@@ -75,6 +92,9 @@ public class AsynchronousHttpClient {
 		);
 	}
 	
+	/**
+	 * Close the underlaying {@code AsynchronousSocket}.
+	 */
 	public void close() {
 		logger.debug("Closing http client connection...");
 		socket.close(); 
diff --git a/src/main/java/org/deftserver/web/http/client/HttpResponse.java b/src/main/java/org/deftserver/web/http/client/HttpResponse.java
index d7fd079..26928e4 100644
--- a/src/main/java/org/deftserver/web/http/client/HttpResponse.java
+++ b/src/main/java/org/deftserver/web/http/client/HttpResponse.java
@@ -7,15 +7,14 @@ import com.google.common.collect.Maps;
 public class HttpResponse {
 	
 	private final long requestTime;
+	private String statusLine;
+	private final Map<String, String> headers = Maps.newHashMap();
+	private String body;
 	
 	public HttpResponse(long requestStarted) {
 		requestTime = System.currentTimeMillis() - requestStarted;
 	}
 	
-	private String statusLine;
-	private final Map<String, String> headers = Maps.newHashMap();
-	private String body;
-	
 	public void setStatuLine(String statusLine) {
 		this.statusLine = statusLine;
 	}
