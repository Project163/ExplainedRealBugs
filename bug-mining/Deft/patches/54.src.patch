diff --git a/src/main/java/org/deftserver/io/timeout/JMXConfigurableTimeoutManager.java b/src/main/java/org/deftserver/io/timeout/JMXConfigurableTimeoutManager.java
index 647da16..7f025e0 100644
--- a/src/main/java/org/deftserver/io/timeout/JMXConfigurableTimeoutManager.java
+++ b/src/main/java/org/deftserver/io/timeout/JMXConfigurableTimeoutManager.java
@@ -1,84 +1,89 @@
 package org.deftserver.io.timeout;
 
 import java.nio.channels.SelectableChannel;
-import java.util.Collection;
 import java.util.Iterator;
-import java.util.List;
 import java.util.Map;
 
 import org.deftserver.util.MXBeanUtil;
+import org.deftserver.web.http.HttpServerDescriptor;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
-import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
+import com.google.common.collect.TreeMultiset;
 
 
 public class JMXConfigurableTimeoutManager implements TimeoutManager, TimeoutMXBean {
-	
+
 	private final Logger logger = LoggerFactory.getLogger(JMXConfigurableTimeoutManager.class);
-	
+
 	private static final long TIMEOUT_CALLBACK_PERIOD = 2 * 1000;	//2s in ms
-	
+
 	private long maxTime = 100;	//ms
 	private int maxOperations = Integer.MAX_VALUE;
 
-	private final List<Timeout> timeouts = Lists.newLinkedList();
-	private final Map<SelectableChannel, Timeout> keepAliveTimeouts = Maps.newHashMap();
-	
+	private final TreeMultiset<DecoratedTimeout> timeouts = TreeMultiset.create();
+	private final Map<SelectableChannel, DecoratedTimeout> index = Maps.newHashMap();
+
 	private long lastIteration;
-	
+
 	{ 	// instance initialization block
 		MXBeanUtil.registerMXBean(this, "org.deftserver.io.timeout:type=JMXConfigurableTimeoutManager"); 
 	}
-	
+
 	@Override
 	public void addKeepAliveTimeout(SelectableChannel channel, Timeout timeout) {
 		logger.debug("added keep-alive timeout: {}", timeout);
-		keepAliveTimeouts.put(channel, timeout);		
+		DecoratedTimeout oldTimeout = index.get(channel);
+		if (oldTimeout != null) {
+			timeouts.remove(oldTimeout);
+		}
+		DecoratedTimeout decorated = new DecoratedTimeout(channel, timeout);
+		timeouts.add(decorated);
+		index.put(channel, decorated);
 	}
-	
+
 	@Override
 	public void addTimeout(Timeout timeout) {
 		logger.debug("added generic timeout: {}", timeout);
-		timeouts.add(timeout);		
+		timeouts.add(new DecoratedTimeout(timeout));		
 	}
 
 	@Override
 	public boolean hasKeepAliveTimeout(SelectableChannel channel) {
-		return keepAliveTimeouts.containsKey(channel);
+		return index.containsKey(channel);
 	}
 
 	@Override
 	public void touch(SelectableChannel channel) {
-		// TODO RS101113 Prolong/reset keep-alive timeout associated with channel
+		//Prolong/reset keep-alive timeout associated with channel
+		DecoratedTimeout oldTimeout = index.get(channel);
+		timeouts.remove(oldTimeout);
+		Timeout newTimeout = new Timeout(
+				System.currentTimeMillis() + HttpServerDescriptor.KEEP_ALIVE_TIMEOUT, 
+				oldTimeout.timeout.getCallback()
+		);
+		timeouts.add(new DecoratedTimeout(channel, newTimeout));
 	}
-	
+
 	@Override
 	public void execute() {
 		long now = System.currentTimeMillis();
-		long deadline = now + maxTime;
 		if (now >= lastIteration + TIMEOUT_CALLBACK_PERIOD) {
+			long deadline = now + maxTime;
 			int operations = 0;
-			operations = triggerTimeouts(timeouts, now, deadline, operations);
-			triggerTimeouts(keepAliveTimeouts.values(), now, deadline, operations);
-			lastIteration = now;
-		}
-	}
-	
-	private int triggerTimeouts(Collection<Timeout> timeouts, long now, long deadline, int operations) {
-		Iterator<Timeout> iter = timeouts.iterator();
-		while (iter.hasNext()) {
-			if (now > deadline || operations > maxOperations) { break; }
-			Timeout candidate = iter.next();
-			if (candidate.getTimeout() <= now) {
-				candidate.getCallback().onCallback();
-				operations++;
+			Iterator<DecoratedTimeout> iter = timeouts.iterator();
+			while (iter.hasNext()) {
+				DecoratedTimeout candidate = iter.next();
+				if (now > deadline || operations > maxOperations || candidate.timeout.getTimeout() > now) { break; }
+				candidate.timeout.getCallback().onCallback();
+				index.remove(candidate.channel);
 				iter.remove();
-				logger.debug("Timeout triggered: {}", candidate);
+				operations++;
+				logger.debug("Timeout triggered: {}", candidate.timeout);
 			}
+			lastIteration = now;
 		}
-		return operations;
 	}
 
 	// implements TimoutMXBean
@@ -91,12 +96,12 @@ public class JMXConfigurableTimeoutManager implements TimeoutManager, TimeoutMXB
 	public void setMaxTimePerIterationInMs(long newMaxTime) {
 		maxTime = newMaxTime;
 	}
-	
+
 	@Override
 	public int getMaxNumberOfTimeoutOperationsPerIteration() {
 		return maxOperations;
 	}
-	
+
 	@Override
 	public void setMaxNumberOfTimeoutOperationsPerIteration(int newMaxOperations) {
 		maxOperations = newMaxOperations;
@@ -104,7 +109,7 @@ public class JMXConfigurableTimeoutManager implements TimeoutManager, TimeoutMXB
 
 	@Override
 	public int getNumberOfKeepAliveTimeouts() {
-		return keepAliveTimeouts.size();
+		return index.size();
 	}
 
 	@Override
@@ -117,4 +122,37 @@ public class JMXConfigurableTimeoutManager implements TimeoutManager, TimeoutMXB
 		return TIMEOUT_CALLBACK_PERIOD;
 	}
 
+	private class DecoratedTimeout implements Comparable<DecoratedTimeout> {
+
+		public final SelectableChannel channel;
+		public final Timeout timeout;
+
+		public DecoratedTimeout(SelectableChannel channel, Timeout timeout) {
+			this.channel = channel;
+			this.timeout = timeout;
+		}
+
+		public DecoratedTimeout(Timeout timeout) {
+			this(null, timeout);
+		}
+
+		@Override
+		public int compareTo(DecoratedTimeout that) {
+			long diff = timeout.getTimeout() - that.timeout.getTimeout();
+			if (diff < 0) {
+				return -1;
+			} else if (diff > 0) {
+				return 1; 
+			} 
+			if (channel != null && that.channel != null) {
+				return channel.hashCode() - that.channel.hashCode(); 
+			} else if (channel == null || that.channel == null ){
+				return -1;
+			} else {
+				return 0;
+			}
+		}
+		
+	}
+
 }
diff --git a/src/test/java/org/deftserver/io/timeout/JMXConfigurableTimeoutManagerTest.java b/src/test/java/org/deftserver/io/timeout/JMXConfigurableTimeoutManagerTest.java
new file mode 100644
index 0000000..8a1cca7
--- /dev/null
+++ b/src/test/java/org/deftserver/io/timeout/JMXConfigurableTimeoutManagerTest.java
@@ -0,0 +1,127 @@
+package org.deftserver.io.timeout;
+
+import static org.junit.Assert.assertEquals;
+
+import java.io.IOException;
+import java.nio.channels.ClosedChannelException;
+import java.nio.channels.SelectableChannel;
+import java.nio.channels.SelectionKey;
+import java.nio.channels.Selector;
+import java.nio.channels.spi.SelectorProvider;
+
+import org.deftserver.web.AsyncCallback;
+import org.junit.Test;
+
+public class JMXConfigurableTimeoutManagerTest {
+
+	private final JMXConfigurableTimeoutManager tm = new JMXConfigurableTimeoutManager();
+	
+	@Test
+	public void timeoutManagerTest() throws InterruptedException {
+		final long now = System.currentTimeMillis();
+		MockChannel c1 = new MockChannel();
+		MockChannel c2 = new MockChannel();
+		MockChannel c3 = new MockChannel();
+
+		addNopTimeout(now);
+		addNopTimeout(now);
+		addNopTimeout(now);
+		addNopTimeout(now+1);
+		addNopTimeout(now+2);
+		addNopTimeout(now+1000);
+		addNopTimeout(now+1200);
+		addNopTimeout(now+1400);
+		
+		addNopKeepAliveTimeout(c1, now);
+		addNopKeepAliveTimeout(c2, now);
+		addNopKeepAliveTimeout(c3, now+1);
+		tm.touch(c1);
+		
+		assertEquals(11, tm.getNumberOfTimeouts());
+		assertEquals(3, tm.getNumberOfKeepAliveTimeouts());
+
+		Thread.sleep(200);
+	
+		tm.execute();
+		assertEquals(4, tm.getNumberOfTimeouts());
+		assertEquals(1, tm.getNumberOfKeepAliveTimeouts());
+	
+		Thread.sleep(2000);
+		tm.execute();
+		assertEquals(1, tm.getNumberOfTimeouts());
+		assertEquals(1, tm.getNumberOfKeepAliveTimeouts());
+	}
+	
+	private void addNopTimeout(long timeout) {
+		tm.addTimeout(new Timeout(timeout, new AsyncCallback() {
+			@Override public void onCallback() { /*nop*/}
+		}));	
+	}
+
+	private void addNopKeepAliveTimeout(SelectableChannel channel, long timeout) {
+		tm.addKeepAliveTimeout(channel, new Timeout(timeout, new AsyncCallback() {
+			@Override public void onCallback() { /*nop*/ }
+		}));
+	}
+	
+	private class MockChannel extends SelectableChannel {
+
+		@Override
+		public Object blockingLock() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public SelectableChannel configureBlocking(boolean block)
+		throws IOException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public boolean isBlocking() {
+			// TODO Auto-generated method stub
+			return false;
+		}
+
+		@Override
+		public boolean isRegistered() {
+			// TODO Auto-generated method stub
+			return false;
+		}
+
+		@Override
+		public SelectionKey keyFor(Selector sel) {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public SelectorProvider provider() {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public SelectionKey register(Selector sel, int ops, Object att)
+		throws ClosedChannelException {
+			// TODO Auto-generated method stub
+			return null;
+		}
+
+		@Override
+		public int validOps() {
+			// TODO Auto-generated method stub
+			return 0;
+		}
+
+		@Override
+		protected void implCloseChannel() throws IOException {
+			// TODO Auto-generated method stub
+
+		}
+
+	}
+
+}
diff --git a/src/test/java/org/deftserver/io/TimeoutTest.java b/src/test/java/org/deftserver/io/timeout/TimeoutTest.java
similarity index 92%
rename from src/test/java/org/deftserver/io/TimeoutTest.java
rename to src/test/java/org/deftserver/io/timeout/TimeoutTest.java
index 09b56c7..0e8f4c5 100644
--- a/src/test/java/org/deftserver/io/TimeoutTest.java
+++ b/src/test/java/org/deftserver/io/timeout/TimeoutTest.java
@@ -1,4 +1,4 @@
-package org.deftserver.io;
+package org.deftserver.io.timeout;
 
 import static org.junit.Assert.assertEquals;
 
