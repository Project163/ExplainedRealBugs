diff --git a/src/main/java/org/deftserver/example/AsynchronousHttpClientExample.java b/src/main/java/org/deftserver/example/AsynchronousHttpClientExample.java
new file mode 100644
index 0000000..16db34f
--- /dev/null
+++ b/src/main/java/org/deftserver/example/AsynchronousHttpClientExample.java
@@ -0,0 +1,26 @@
+package org.deftserver.example;
+
+import static java.lang.System.out;
+
+import org.deftserver.io.IOLoop;
+import org.deftserver.web.AsyncResult;
+import org.deftserver.web.http.client.AsynchronousHttpClient;
+import org.deftserver.web.http.client.HttpResponse;
+
+public class AsynchronousHttpClientExample {
+
+	public static void main(String[] args) {
+		AsynchronousHttpClient client = new AsynchronousHttpClient();
+		client.fetch("http://tt.se/start/", new ResultCallback());
+		IOLoop.INSTANCE.start();
+	}
+	
+	private static class ResultCallback implements AsyncResult<HttpResponse> {
+
+		@Override public void onFailure(Throwable caught) { out.println("exception caught: " + caught); }
+
+		@Override public void onSuccess(HttpResponse response) { out.println("http resonse:\n" + response); }
+		
+	}
+
+}
diff --git a/src/main/java/org/deftserver/io/AsynchronousSocket.java b/src/main/java/org/deftserver/io/AsynchronousSocket.java
index d2acd53..a069c49 100644
--- a/src/main/java/org/deftserver/io/AsynchronousSocket.java
+++ b/src/main/java/org/deftserver/io/AsynchronousSocket.java
@@ -8,6 +8,7 @@ import java.nio.channels.SelectionKey;
 import java.nio.channels.SocketChannel;
 
 import org.deftserver.util.Closeables;
+import org.deftserver.util.NopAsyncResult;
 import org.deftserver.web.AsyncCallback;
 import org.deftserver.web.AsyncResult;
 import org.slf4j.Logger;
@@ -21,14 +22,17 @@ public class AsynchronousSocket implements IOHandler {
 	
 	private final int DEFAULT_BYTEBUFFER_SIZE = 1024;
 	
+	private final AsyncResult<String> nopAsyncResult = NopAsyncResult.of(String.class).nopAsyncResult;
+	
 	private final SelectableChannel channel;
 	private int interestOps;
 	
 	private String readDelimiter = "";
+	private int readBytes = Integer.MAX_VALUE;
 	
 	private AsyncCallback connectCallback = AsyncCallback.nopCb;
 	private AsyncCallback closeCallback = AsyncCallback.nopCb;
-	private AsyncResult<String> readCallback = NopAsyncStringResult;
+	private AsyncResult<String> readCallback = nopAsyncResult;
 	private AsyncCallback writeCallback = AsyncCallback.nopCb;
 	
 	private final StringBuilder readBuffer = new StringBuilder();
@@ -62,13 +66,8 @@ public class AsynchronousSocket implements IOHandler {
 	 * Close the socket.
 	 */
 	public void close() {
-		try {
-			channel.close();
-			closeCallback.onCallback();
-			closeCallback = AsyncCallback.nopCb;
-		} catch (IOException e) {
-			logger.error("Could not close SocketChannel: {}", e.getMessage());
-		}
+		Closeables.closeQuietly(channel);
+		invokeCloseCallback();
 	}
 	
 	public void setCloseCallback(AsyncCallback ccb) {
@@ -91,8 +90,7 @@ public class AsynchronousSocket implements IOHandler {
 		logger.debug("handle connect...");
 		if (((SocketChannel) channel).isConnectionPending()) {
 			((SocketChannel) channel).finishConnect();
-			connectCallback.onCallback();
-			connectCallback = AsyncCallback.nopCb;
+			invokeConnectCallback();
 			interestOps &= ~SelectionKey.OP_CONNECT;
 			IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_READ);
 		}
@@ -107,12 +105,11 @@ public class AsynchronousSocket implements IOHandler {
 		ByteBuffer buffer = ByteBuffer.allocate(DEFAULT_BYTEBUFFER_SIZE);
 		int read = ((SocketChannel) key.channel()).read(buffer);
 		if (read == -1) {	// EOF
-			closeCallback.onCallback();
-			closeCallback = AsyncCallback.nopCb;
+			invokeCloseCallback();
 			Closeables.closeQuietly(key.channel());
 			return;
 		}
-		readBuffer.append(new String(buffer.array(), 0, buffer.position(), Charsets.UTF_8));
+		readBuffer.append(new String(buffer.array(), 0, buffer.position(), Charsets.US_ASCII));
 		logger.debug("readBuffer size: {}", readBuffer.length());
 		checkReadState();
 	}
@@ -136,22 +133,63 @@ public class AsynchronousSocket implements IOHandler {
 		readCallback = rcb;
 		checkReadState();
 	}
+
+	/**
+	 * Reads from the underlaying SelectableChannel until n bytes are read. When it its, the given
+	 * AsyncResult will be invoked.
+	 */
+	public void readBytes(int n, AsyncResult<String> rcb) {
+		logger.debug("readBytes #bytes: {}", n);
+		readBytes = n;
+		readCallback = rcb;
+		checkReadState();
+	}
 	
 	/**
 	 *  If readBuffer contains readDelimiter, client read is finished => invoke readCallback
+	 *  Or if readBytes bytes are read, client read is finished => invoke readCallback
 	 */
 	private void checkReadState() {
 		int index = readBuffer.indexOf(readDelimiter);
 		if (index != -1 && !readDelimiter.isEmpty()) {
 			String result = readBuffer.substring(0, index /*+ readDelimiter.length()*/);
-			readCallback.onSuccess(result);
 			readBuffer.delete(0, index + readDelimiter.length());
 			logger.debug("readBuffer size: {}", readBuffer.length());
 			readDelimiter = "";
-			readCallback = NopAsyncStringResult;
+			invokeReadCallback(result);
+		} else if (readBuffer.length() >= readBytes) {
+			String result = readBuffer.substring(0, readBytes);
+			readBuffer.delete(0, readBytes);
+			logger.debug("readBuffer size: {}", readBuffer.length());
+			readBytes = Integer.MAX_VALUE;
+			invokeReadCallback(result);
 		}
 	}
 
+	private void invokeReadCallback(String result) {
+		AsyncResult<String> cb = readCallback;
+		readCallback = nopAsyncResult;
+		cb.onSuccess(result);
+	}
+	
+	private void invokeWriteCallback() {
+		AsyncCallback cb = writeCallback;
+		writeCallback = AsyncCallback.nopCb;
+		cb.onCallback();
+	}
+	
+	private void invokeCloseCallback() {
+		AsyncCallback cb = closeCallback;
+		closeCallback = AsyncCallback.nopCb;
+		cb.onCallback();
+	}
+	
+	private void invokeConnectCallback() {
+		AsyncCallback cb = connectCallback;
+		connectCallback = AsyncCallback.nopCb;
+		cb.onCallback();
+	}
+
 	/**
 	 * Writes the given data to the underlaying SelectableChannel. When all data is successfully transmitted, the given 
 	 * AsyncCallback will be invoked 
@@ -175,8 +213,7 @@ public class AsynchronousSocket implements IOHandler {
 			}
 		} catch (IOException e) {
 			logger.error("IOException during write: {}", e.getMessage());
-			closeCallback.onCallback();
-			closeCallback = AsyncCallback.nopCb;
+			invokeCloseCallback();
 			Closeables.closeQuietly(channel);
 		}
 		writeBuffer.delete(0, written);
@@ -186,19 +223,8 @@ public class AsynchronousSocket implements IOHandler {
 			IOLoop.INSTANCE.updateHandler(channel, interestOps |= SelectionKey.OP_WRITE);
 		} else {
 			IOLoop.INSTANCE.updateHandler(channel, interestOps &= ~SelectionKey.OP_WRITE);
-			writeCallback.onCallback();
-			writeCallback = AsyncCallback.nopCb;
+			invokeWriteCallback();
 		}
 	}
 
-
-	private static final AsyncResult<String> NopAsyncStringResult = new AsyncResult<String>() {
-
-		@Override public void onFailure(Throwable caught) {}
-		
-		@Override public void onSuccess(String result) {} 
-	
-	};
-
-
 }
diff --git a/src/main/java/org/deftserver/util/NopAsyncResult.java b/src/main/java/org/deftserver/util/NopAsyncResult.java
new file mode 100644
index 0000000..a543a7e
--- /dev/null
+++ b/src/main/java/org/deftserver/util/NopAsyncResult.java
@@ -0,0 +1,20 @@
+package org.deftserver.util;
+
+import org.deftserver.web.AsyncResult;
+
+public class NopAsyncResult<T> {
+	
+	private NopAsyncResult() {}
+	
+	public final AsyncResult<T> nopAsyncResult = new AsyncResult<T>() {
+
+		@Override public void onFailure(Throwable caught) {}
+		
+		@Override public void onSuccess(T result) {System.out.println();} 
+	
+	};
+	
+	public static <T> NopAsyncResult<T> of(Class<T> type) {
+		return new NopAsyncResult<T>();
+	}
+}
diff --git a/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java b/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
new file mode 100644
index 0000000..c77c2f4
--- /dev/null
+++ b/src/main/java/org/deftserver/web/http/client/AsynchronousHttpClient.java
@@ -0,0 +1,179 @@
+package org.deftserver.web.http.client;
+
+import java.io.IOException;
+import java.nio.channels.SocketChannel;
+import java.util.concurrent.TimeoutException;
+
+import org.deftserver.io.AsynchronousSocket;
+import org.deftserver.io.IOLoop;
+import org.deftserver.io.timeout.Timeout;
+import org.deftserver.util.NopAsyncResult;
+import org.deftserver.web.AsyncCallback;
+import org.deftserver.web.AsyncResult;
+import org.deftserver.web.HttpVerb;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class AsynchronousHttpClient {
+
+	private static final Logger logger = LoggerFactory.getLogger(AsynchronousHttpClient.class);
+
+	private static final long TIMEOUT = 15 * 1000;	// 15s
+	
+	private static final AsyncResult<HttpResponse> nopAsyncResult = NopAsyncResult.of(HttpResponse.class).nopAsyncResult;
+
+	private AsynchronousSocket socket;
+	
+	private HttpRequest request;
+	private HttpResponse response;
+	private AsyncResult<HttpResponse> responseCallback;
+	
+	private Timeout timeout;
+	
+	private static final String HTTP_VERSION = "HTTP/1.1\r\n";
+	private static final String USER_AGENT_HEADER = "User-Agent: Deft AsynchronousHttpClient/0.1\r\n";
+	private static final String NEWLINE = "\r\n";
+	
+	public AsynchronousHttpClient() { }
+
+	/**
+	 * Makes an asynchronous HTTP GET request against the specified url and invokes the given 
+	 * callback when the response is fetched.
+	 * 
+	 * @param url e.g "http://tt.se:80/start/"
+	 * @param cb callback that will be executed when the response is received.
+	 */
+	public void fetch(String url, AsyncResult<HttpResponse> cb) {
+		request = new HttpRequest(url, HttpVerb.GET);
+		doFetch(cb);
+	}
+	
+	public void fetch(HttpRequest request, AsyncResult<HttpResponse> cb) {
+		this.request = request;
+		doFetch(cb);
+	}
+	
+	private void doFetch(AsyncResult<HttpResponse> cb) {
+		try {
+			socket = new AsynchronousSocket(SocketChannel.open().configureBlocking(false));
+		} catch (IOException e) {
+			logger.error("Error opening SocketChannel: {}" + e.getMessage());
+		}
+		responseCallback = cb;
+		int port = request.getURL().getPort();
+		port = port == -1 ? 80 : port;
+		socket.connect(
+				request.getURL().getHost(), 
+				port, 
+				new AsyncCallback() { public void onCallback() { onConnect(); }}
+		);
+		startTimeout();
+	}
+	
+	public void close() {
+		logger.debug("Closing http client connection...");
+		socket.close(); 
+	}
+	
+	private void startTimeout() {
+		timeout = new Timeout(
+				System.currentTimeMillis() + TIMEOUT, 
+				new AsyncCallback() { public void onCallback() { onTimeout(); } }
+		);
+		IOLoop.INSTANCE.addTimeout(timeout);		
+	}
+	
+	private void cancelTimeout() {
+		timeout.cancel();
+		timeout = null;
+	}
+	
+	private void onTimeout() {
+		logger.debug("Pending operation (connect, read or write) timed out...");
+		AsyncResult<HttpResponse> cb = responseCallback;
+		responseCallback = nopAsyncResult;
+		cb.onFailure(new TimeoutException("Connection timed out"));
+		close();
+	}
+
+	private void onConnect() {
+		logger.debug("Connected...");
+		cancelTimeout();
+		startTimeout();
+		socket.write(
+				makeRequestLineAndHeaders(), 
+				new AsyncCallback() { public void onCallback() { onWriteComplete(); }}
+		);
+	}
+
+	/**
+	 * 
+	 * @return Eg. 
+	 * 				GET /path/to/file/index.html HTTP/1.0
+	 * 				From: a@b.com
+	 * 				User-Agent: HTTPTool/1.0
+	 * 
+	 */
+	private String makeRequestLineAndHeaders() {
+		return request.getVerb() + " " + request.getURL().getPath() + " " + HTTP_VERSION +
+				"From: a@b.com\r\n" +
+				"Host: " + request.getURL().getHost() + "\r\n" +
+				USER_AGENT_HEADER +
+				NEWLINE;
+	}
+	
+	private void onWriteComplete() {
+		logger.debug("onWriteComplete...");
+		cancelTimeout();
+		startTimeout();
+		socket.readUntil(
+				"\r\n\r\n", 	/* header delimiter */
+				new NaiveAsyncResult() { public void onSuccess(String headers) { onHeaders(headers); }
+		});
+	}
+	
+	private void onHeaders(String result) {
+		logger.debug("headers: {}", result);
+		cancelTimeout();
+		response = new HttpResponse();
+		String[] headers = result.split("\r\n");
+		response.setStatuLine(headers[0]);	// first entry contains status line (e.g. HTTP/1.1 200 OK)
+		for (int i = 1; i < headers.length; i++) {
+			String[] header = headers[i].split(": ");
+			response.setHeader(header[0], header[1]);
+		}
+		int readBytes = Integer.parseInt(response.getHeader("Content-Length"));
+		startTimeout();
+		socket.readBytes(
+				readBytes, 
+				new NaiveAsyncResult() { public void onSuccess(String result) { onBody(result); } }
+		);
+	}
+				
+	private void onBody(String body) {
+		logger.debug("body size: {}", body.length());
+		cancelTimeout();
+		response.setBody(body);
+		close();
+		invokeResponseCallback();
+	} 
+	
+	private void invokeResponseCallback() {
+		AsyncResult<HttpResponse> cb = responseCallback;
+		responseCallback = nopAsyncResult;
+		cb.onSuccess(response);
+	}
+				
+	/**
+	 * Naive because all it does when an exception is thrown is log the exception.
+	 */
+	private abstract class NaiveAsyncResult implements AsyncResult<String> {
+		
+		@Override
+		public void onFailure(Throwable caught) {
+			logger.debug("onFailure: {}", caught);
+		}
+		
+	}
+
+}
diff --git a/src/main/java/org/deftserver/web/http/client/HttpRequest.java b/src/main/java/org/deftserver/web/http/client/HttpRequest.java
new file mode 100644
index 0000000..0eee7c6
--- /dev/null
+++ b/src/main/java/org/deftserver/web/http/client/HttpRequest.java
@@ -0,0 +1,39 @@
+package org.deftserver.web.http.client;
+
+import java.net.MalformedURLException;
+import java.net.URL;
+
+import org.deftserver.web.HttpVerb;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+public class HttpRequest {
+	
+	private static final Logger logger = LoggerFactory.getLogger(HttpRequest.class);
+
+	private final URL url;
+	private final HttpVerb verb;
+	
+	public HttpRequest(String url, HttpVerb verb) {
+		try {
+			this.url = new URL(url);
+			this.verb = verb;
+		} catch (MalformedURLException e) {
+			logger.error("Malformed URL: {}", e.getMessage());
+			throw new RuntimeException(e);
+		}
+	}
+
+	public URL getURL() {
+		return url;
+	}
+	
+	/**
+	 * 
+	 * @return The verb (method) name, e.g. "GET" or "POST"
+	 */
+	public String getVerb() {
+		return verb.name();
+	}
+	
+}
diff --git a/src/main/java/org/deftserver/web/http/client/HttpResponse.java b/src/main/java/org/deftserver/web/http/client/HttpResponse.java
new file mode 100644
index 0000000..19f0f93
--- /dev/null
+++ b/src/main/java/org/deftserver/web/http/client/HttpResponse.java
@@ -0,0 +1,43 @@
+package org.deftserver.web.http.client;
+
+import java.util.Map;
+
+import com.google.common.collect.Maps;
+
+public class HttpResponse {
+	
+	private String statusLine;
+	private final Map<String, String> headers = Maps.newHashMap();
+	private String body;
+	
+	public void setStatuLine(String statusLine) {
+		this.statusLine = statusLine;
+	}
+	
+	public String getStatusLine() {
+		return statusLine;
+	}
+	
+	public void setHeader(String key, String value) {
+		headers.put(key, value);
+	}
+	
+	public String getHeader(String key) {
+		return headers.get(key);
+	}
+	
+	public void setBody(String body) {
+		this.body = body;
+	}
+	
+	public String getBody() {
+		return body;
+	}
+	
+	@Override
+	public String toString() {
+		return "HttpResponse [body=" + body + ", headers=" + headers
+				+ "\n, statusLine=" + statusLine + "]";
+	}
+	
+}
diff --git a/src/test/java/org/deftserver/io/AsynchronousSocketTest.java b/src/test/java/org/deftserver/io/AsynchronousSocketTest.java
index 261ea76..ef5b478 100644
--- a/src/test/java/org/deftserver/io/AsynchronousSocketTest.java
+++ b/src/test/java/org/deftserver/io/AsynchronousSocketTest.java
@@ -120,7 +120,9 @@ public class AsynchronousSocketTest {
 	}
 	
 	private void onReadComplete(String result) {
-		latch.countDown();
+		if ("ROGER".equals(result)) {
+			latch.countDown();
+		}
 		assertEquals("ROGER", result);
 	}
 	
