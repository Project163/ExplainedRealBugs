diff --git a/src/main/java/com/spatial4j/core/shape/ShapeCollection.java b/src/main/java/com/spatial4j/core/shape/ShapeCollection.java
index d2969a4f..c45bae98 100644
--- a/src/main/java/com/spatial4j/core/shape/ShapeCollection.java
+++ b/src/main/java/com/spatial4j/core/shape/ShapeCollection.java
@@ -9,13 +9,9 @@
 package com.spatial4j.core.shape;
 
 import com.spatial4j.core.context.SpatialContext;
-import com.spatial4j.core.shape.impl.Range;
+import com.spatial4j.core.shape.impl.BBoxCalculator;
 
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.RandomAccess;
+import java.util.*;
 
 import static com.spatial4j.core.shape.SpatialRelation.CONTAINS;
 import static com.spatial4j.core.shape.SpatialRelation.INTERSECTS;
@@ -61,22 +57,11 @@ public class ShapeCollection<S extends Shape> extends AbstractList<S> implements
   protected Rectangle computeBoundingBox(Collection<? extends Shape> shapes, SpatialContext ctx) {
     if (shapes.isEmpty())
       return ctx.makeRectangle(Double.NaN, Double.NaN, Double.NaN, Double.NaN);
-    Range xRange = null;
-    double minY = Double.POSITIVE_INFINITY;
-    double maxY = Double.NEGATIVE_INFINITY;
+    BBoxCalculator bboxCalc = new BBoxCalculator(ctx);
     for (Shape geom : shapes) {
-      Rectangle r = geom.getBoundingBox();
-
-      Range xRange2 = Range.xRange(r, ctx);
-      if (xRange == null) {
-        xRange = xRange2;
-      } else {
-        xRange = xRange.expandTo(xRange2);
-      }
-      minY = Math.min(minY, r.getMinY());
-      maxY = Math.max(maxY, r.getMaxY());
+      bboxCalc.expandRange(geom.getBoundingBox());
     }
-    return ctx.makeRectangle(xRange.getMin(), xRange.getMax(), minY, maxY);
+    return bboxCalc.getBoundary();
   }
 
   public List<S> getShapes() {
diff --git a/src/main/java/com/spatial4j/core/shape/impl/BBoxCalculator.java b/src/main/java/com/spatial4j/core/shape/impl/BBoxCalculator.java
index 2553cf96..14c9eb02 100644
--- a/src/main/java/com/spatial4j/core/shape/impl/BBoxCalculator.java
+++ b/src/main/java/com/spatial4j/core/shape/impl/BBoxCalculator.java
@@ -1,145 +1,217 @@
-/*
- * Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *    http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
+/*******************************************************************************
+ * Copyright (c) 2015 David Smiley
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License, Version 2.0 which
+ * accompanies this distribution and is available at
+ *    http://www.apache.org/licenses/LICENSE-2.0.txt
+ ******************************************************************************/
 
 package com.spatial4j.core.shape.impl;
 
 import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.shape.Rectangle;
 
+import java.util.Iterator;
 import java.util.Map;
-import java.util.NavigableMap;
 import java.util.TreeMap;
 
+/**
+ * (INTERNAL) Calculates the minimum bounding box given a bunch of rectangles (ranges).  It's a temporary object and not
+ * thread-safe; throw it away when done.
+ * For a cartesian space, the calculations are trivial but it is not for geodetic.  For
+ * geodetic, it must maintain an ordered set of disjoint ranges as each range is provided.
+ */
 public class BBoxCalculator {
   
-  SpatialContext ctx;
-  double minX = Double.POSITIVE_INFINITY;
-  double maxX = Double.NEGATIVE_INFINITY;
-  double minY = Double.POSITIVE_INFINITY;
-  double maxY = Double.NEGATIVE_INFINITY;
+  private final SpatialContext ctx;
+
+  private double minY = Double.POSITIVE_INFINITY;
+  private double maxY = Double.NEGATIVE_INFINITY;
+
+  private double minX = Double.POSITIVE_INFINITY;
+  private double maxX = Double.NEGATIVE_INFINITY;
+
+  /** Sorted list of <em>disjoint</em> X ranges keyed by maxX and with minX stored as the "value". */
+  private TreeMap<Double, Double> ranges; // maxX -> minX
+
+  // note: The use of a TreeMap of Double objects is a bit heavy for the points-only use-case.  In such a case,
+  //  we could instead maintain an array of longitudes we just add onto during expandXRange(). A simplified version
+  //  of the processRanges() method could be used that initially sorts and then proceeds in a similar but simplified
+  //  fashion.
 
-  TreeMap<Double, Double> ranges;
-  boolean worldWrapped = false;
+  public BBoxCalculator(SpatialContext ctx) {
+    this.ctx = ctx;
+  }
+
+  public void expandRange(Rectangle rect) {
+    expandRange(rect.getMinX(), rect.getMaxX(), rect.getMinY(), rect.getMaxY());
+  }
 
-  public void expandRange(double minX, double maxX, double minY, double maxY) {
+  public void expandRange(final double minX, final double maxX, double minY, double maxY) {
     this.minY = Math.min(this.minY, minY);
     this.maxY = Math.max(this.maxY, maxY);
+
+    expandXRange(minX, maxX);
+  }//expandRange
+
+  public void expandXRange(double minX, double maxX) {
     if (!ctx.isGeo()) {
       this.minX = Math.min(this.minX, minX);
       this.maxX = Math.max(this.maxX, maxX);
       return;
     }
 
-    if (worldWrapped)
+    if (doesXWorldWrap())
       return;
 
     if (ranges == null) {
-      ranges = new TreeMap<Double, Double>();
+      ranges = new TreeMap<>();
       ranges.put(maxX, minX);
       return;
     }
     assert !ranges.isEmpty();
     //now the hard part!
 
-    //Get a subMap where the first entry either contains minX or it's to the right.
-    NavigableMap<Double,Double> iterMap = ranges.tailMap(minX, true/*inclusive*/);//Log(N)
-    if (iterMap.isEmpty()) {
-      iterMap = ranges;//wrapped across dateline
+    //Get an iterator starting from the first entry that either contains minX or it's to the right of minX
+    Iterator<Map.Entry<Double, Double>> entryIter = ranges.tailMap(minX, true/*inclusive*/).entrySet().iterator();
+    if (!entryIter.hasNext()) {
+      entryIter = ranges.entrySet().iterator();//wrapped across dateline
     }
-    final Map.Entry<Double, Double> firstEntry = iterMap.firstEntry();
+    Map.Entry<Double, Double> entry = entryIter.next();
 
-    Double firstEntryMin = firstEntry.getValue();
-    Double firstEntryMax = firstEntry.getKey();
+    Double entryMin = entry.getValue();
+    Double entryMax = entry.getKey();
 
-    //See if firstEntry contains maxX
-    if (containsPt(firstEntryMin, firstEntryMax, maxX)) {
+    //See if entry contains maxX
+    if (rangeContains(entryMin, entryMax, maxX)) {
+      // Easy: either minX is also within this entry in which case nothing to do, or it's below in which case
+      // we just need to update the minX of this entry.
 
-      //See if firstEntry contains minX
-      if (containsPt(firstEntryMin, firstEntryMax, minX)) {
+      //See if entry contains minX
+      if (rangeContains(entryMin, entryMax, minX)) {
 
-        //Done: either world-wrap or we're within an existing range
-        if ( (minX != firstEntryMin || maxX != firstEntryMax) //ranges not equal
-            && containsPt(minX, maxX, firstEntryMin) && containsPt(minX, maxX, firstEntryMax)) {
-          worldWrapped = true;
+        // This entry & the new range together might wrap the world.
+        if ( (minX != entryMin || maxX != entryMax) //ranges not equal
+            && rangeContains(minX, maxX, entryMin) && rangeContains(minX, maxX, entryMax)) {
+          this.minX = -180;
+          this.maxX = +180;
           ranges = null;
         }
-        //optimization: check for existing world-wrap
-        if (firstEntryMin == -180 && firstEntryMax == 180) {
-          worldWrapped = true;
-          ranges = null;
-        }
-
-        return;
+        // Done; nothing to do.
+      } else {
+        //Done: Update entry's start to be minX
+        // note:  TreeMap's Map.Entry doesn't support setting the value :-(  So we remove & add the entry.
+        entryIter.remove();
+        ranges.put(entryMax, minX);
       }
 
-      //Done: Update firstEntry's start to be minX
-      firstEntry.setValue(minX);
-
-    } else {//firstEntry does NOT contain maxX
-
-      final Double newMinX;//of new range to insert
+    } else {//entry does NOT contain maxX:
 
-      //See if firstEntry does NOT contains minX
-      if (!containsPt(firstEntryMin, firstEntryMax, minX)) {
+      // We're going to insert an entry.  Determine it's min & max.  While finding the max, we'll delete entries
+      //  that overlap with the new entry.
 
-        //if minX-MaxX doesn't cross into firstEntry, just add the range
-        if (!containsPt(minX, maxX, firstEntryMin)) {
-          //doesn't intersect any ranges
-          ranges.put(minX, maxX);
-          return;
-        }
-        //else remove to the right then add...
-        newMinX = minX;
-
-      } else {
-        //firstEntry DOES contains minX (but not maxX)
-        //remove to the right then add...
-        newMinX = firstEntryMin;
-      }
+      // newMinX is basically the lower of minX & entryMin
+      final Double newMinX  = rangeContains(entryMin, entryMax, minX) ? entryMin : minX;
 
       Double newMaxX = maxX;
-      //The remove-right loop
-      iterMap.pollFirstEntry();//remove firstEntry
-      while (!ranges.isEmpty()) {
-        final Map.Entry<Double, Double> entry = iterMap.firstEntry();
-        if (entry == null) {
-          //wrap around (will only happen once)
-          iterMap = ranges;
-          continue;
-        }
-        final Double entryMin = entry.getValue();
-        if (!containsPt(newMinX, newMaxX, entryMin))
-          break;
-        final Double entryMax = entry.getKey();
-        iterMap.pollFirstEntry();//remove entry
-        if (!containsPt(minX, maxX, entryMax)) {
+      //Loop through entries (starting with current) to see if we should remove it.  At the last one, update newMaxX.
+      while (rangeContains(newMinX, newMaxX, entryMin)) {
+        entryIter.remove();//remove entry!
+        if (!rangeContains(minX, maxX, entryMax)) {
           newMaxX = entryMax;//adjust newMaxX and stop.
           break;
         }
+        // get new entry:
+        if (!entryIter.hasNext()) {
+          if (ranges.isEmpty()) {
+            break;
+          }
+          //wrap around (can only happen once)
+          entryIter = ranges.entrySet().iterator();
+        }
+        entry = entryIter.next();
+        entryMin = entry.getValue();
+        entryMax = entry.getKey();
       }
+
       //Add entry
-      ranges.put(newMinX, newMaxX);
+      ranges.put(newMaxX, newMinX);
     }
-  }//expandRange
+  }
+
+  private void processRanges() {
+    if (ranges.size() == 1) { // an optimization
+      Map.Entry<Double, Double> rangeEntry = ranges.firstEntry();
+      minX = rangeEntry.getValue();
+      maxX = rangeEntry.getKey();
+    } else {
+      // Find the biggest gap. Whenever we do, update minX & maxX for the rect opposite of the gap.
+      Map.Entry<Double, Double> prevRange = ranges.lastEntry();
+      double biggestGap = 0;
+      double possibleRemainingGap = 360;  //calculating this enables us to exit early; often on the first lap!
+      for (Map.Entry<Double, Double> range : ranges.entrySet()) {
+        // calc width of this range and the gap before it.
+        double widthPlusGap = range.getKey() - prevRange.getKey();// this max - last max
+        if (widthPlusGap < 0) {
+          widthPlusGap += 360;
+        }
+        double gap = range.getValue() - prevRange.getKey(); // this min - last max
+        if (gap < 0) {
+          gap += 360;
+        }
+        // reduce possibleRemainingGap by this range width and trailing gap.
+        possibleRemainingGap -= widthPlusGap;
+        if (gap > biggestGap) {
+          biggestGap = gap;
+          minX = range.getValue();
+          maxX = prevRange.getKey();
+          if (possibleRemainingGap <= biggestGap) {
+            break;// no point in continuing
+          }
+        }
+        prevRange = range;
+      }
+    }
+    // Null out the ranges to signify we processed them
+    ranges = null;
+  }
 
-  private static boolean containsPt(double minX, double maxX, double x) {
+  private static boolean rangeContains(double minX, double maxX, double x) {
     if (minX <= maxX)
       return x >= minX && x <= maxX;
     else
-      return x <= minX || x >= maxX;
+      return x >= minX || x <= maxX;
+  }
+
+  public boolean doesXWorldWrap() {
+    assert ctx.isGeo();
+    //note: not dependent on "ranges", since once we expand to world bounds then ranges is null'ed out
+    return minX == -180 && maxX == 180;
+  }
+
+  public Rectangle getBoundary() {
+    return ctx.makeRectangle(getMinX(), getMaxX(), getMinY(), getMaxY());
+  }
+
+  public double getMinX() {
+    if (ranges != null) {
+      processRanges();
+    }
+    return minX;
   }
 
+  public double getMaxX() {
+    if (ranges != null) {
+      processRanges();
+    }
+    return maxX;
+  }
+
+  public double getMinY() {
+    return minY;
+  }
+
+  public double getMaxY() {
+    return maxY;
+  }
 }
diff --git a/src/main/java/com/spatial4j/core/shape/impl/Range.java b/src/main/java/com/spatial4j/core/shape/impl/Range.java
index ec2a8df8..7291985b 100644
--- a/src/main/java/com/spatial4j/core/shape/impl/Range.java
+++ b/src/main/java/com/spatial4j/core/shape/impl/Range.java
@@ -16,6 +16,7 @@ import com.spatial4j.core.shape.Rectangle;
  * Perhaps this class could become 1st class citizen extending Shape but not now.
  * Only public so is accessible from tests in another package.
  */
+@Deprecated // See BBoxCalculator
 public class Range {
   protected final double min, max;
 
@@ -95,6 +96,7 @@ public class Range {
     return max3 - min3;
   }
 
+  @Deprecated // See BBoxCalculator
   public static class LongitudeRange extends Range {
 
     public static final LongitudeRange WORLD_180E180W = new LongitudeRange(-180, 180);
diff --git a/src/main/java/com/spatial4j/core/shape/jts/JtsGeometry.java b/src/main/java/com/spatial4j/core/shape/jts/JtsGeometry.java
index b7bea522..cba0ad2b 100755
--- a/src/main/java/com/spatial4j/core/shape/jts/JtsGeometry.java
+++ b/src/main/java/com/spatial4j/core/shape/jts/JtsGeometry.java
@@ -13,9 +13,9 @@ import com.spatial4j.core.context.jts.JtsSpatialContext;
 import com.spatial4j.core.exception.InvalidShapeException;
 import com.spatial4j.core.shape.*;
 import com.spatial4j.core.shape.Point;
+import com.spatial4j.core.shape.impl.BBoxCalculator;
 import com.spatial4j.core.shape.impl.BufferedLineString;
 import com.spatial4j.core.shape.impl.PointImpl;
-import com.spatial4j.core.shape.impl.Range;
 import com.spatial4j.core.shape.impl.RectangleImpl;
 import com.vividsolutions.jts.geom.*;
 import com.vividsolutions.jts.geom.prep.PreparedGeometry;
@@ -151,21 +151,16 @@ public class JtsGeometry extends BaseShape<JtsSpatialContext> {
     if (geoms.isEmpty())
       return new RectangleImpl(Double.NaN, Double.NaN, Double.NaN, Double.NaN, ctx);
     final Envelope env = geoms.getEnvelopeInternal();//for minY & maxY (simple)
-    if (env.getWidth() > 180 && geoms.getNumGeometries() > 1)  {
+    if (ctx.isGeo() && env.getWidth() > 180 && geoms.getNumGeometries() > 1)  {
       // This is ShapeCollection's bbox algorithm
-      Range xRange = null;
+      BBoxCalculator bboxCalc = new BBoxCalculator(ctx);
       for (int i = 0; i < geoms.getNumGeometries(); i++ ) {
         Envelope envI = geoms.getGeometryN(i).getEnvelopeInternal();
-        Range xRange2 = new Range.LongitudeRange(envI.getMinX(), envI.getMaxX());
-        if (xRange == null) {
-          xRange = xRange2;
-        } else {
-          xRange = xRange.expandTo(xRange2);
-        }
-        if (xRange == Range.LongitudeRange.WORLD_180E180W)
+        bboxCalc.expandXRange(envI.getMinX(), envI.getMaxX());
+        if (bboxCalc.doesXWorldWrap())
           break; // can't grow any bigger
       }
-      return new RectangleImpl(xRange.getMin(), xRange.getMax(), env.getMinY(), env.getMaxY(), ctx);
+      return new RectangleImpl(bboxCalc.getMinX(), bboxCalc.getMaxX(), env.getMinY(), env.getMaxY(), ctx);
     } else {
       return new RectangleImpl(env.getMinX(), env.getMaxX(), env.getMinY(), env.getMaxY(), ctx);
     }
diff --git a/src/test/java/com/spatial4j/core/shape/ShapeCollectionTest.java b/src/test/java/com/spatial4j/core/shape/ShapeCollectionTest.java
index 5e561e12..330f178e 100644
--- a/src/test/java/com/spatial4j/core/shape/ShapeCollectionTest.java
+++ b/src/test/java/com/spatial4j/core/shape/ShapeCollectionTest.java
@@ -47,7 +47,8 @@ public class ShapeCollectionTest extends RandomizedShapeTest {
     Rectangle r2 = ctx.makeRectangle(130, 172, -10, 10);
     Rectangle r3 = ctx.makeRectangle(172, -60, -10, 10);
     ShapeCollection<Rectangle> s = new ShapeCollection<Rectangle>(Arrays.asList(r1,r2,r3), ctx);
-    assertEquals(WORLD180, getLonRangeString(s.getBoundingBox()));
+    assertEquals("130.0 90.0", getLonRangeString(s.getBoundingBox()));
+    // note: BBoxCalculatorTest thoroughly tests the longitude range
   }
 
 
diff --git a/src/test/java/com/spatial4j/core/shape/impl/BBoxCalculatorTest.java b/src/test/java/com/spatial4j/core/shape/impl/BBoxCalculatorTest.java
new file mode 100644
index 00000000..1bf28e84
--- /dev/null
+++ b/src/test/java/com/spatial4j/core/shape/impl/BBoxCalculatorTest.java
@@ -0,0 +1,97 @@
+/*******************************************************************************
+ * Copyright (c) 2015 David Smiley
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Apache License, Version 2.0 which
+ * accompanies this distribution and is available at
+ *    http://www.apache.org/licenses/LICENSE-2.0.txt
+ ******************************************************************************/
+
+package com.spatial4j.core.shape.impl;
+
+import com.carrotsearch.randomizedtesting.annotations.Repeat;
+import com.spatial4j.core.context.SpatialContext;
+import com.spatial4j.core.shape.RandomizedShapeTest;
+import com.spatial4j.core.shape.Rectangle;
+import com.spatial4j.core.shape.SpatialRelation;
+import org.junit.Test;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class BBoxCalculatorTest extends RandomizedShapeTest {
+
+  public BBoxCalculatorTest() {
+    super(SpatialContext.GEO);
+  }
+
+  // note: testing latitude would be so simple that's effectively the same code as the code to be tested. So I don't.
+
+
+  @Test @Repeat(iterations = 100)
+  public void testGeoLongitude() {
+    BBoxCalculator calc = new BBoxCalculator(ctx);
+    final int numShapes = randomIntBetween(1, 4);//inclusive
+    List<Rectangle> rects = new ArrayList<>(numShapes);
+    for (int i = 0; i < numShapes; i++) {
+      Rectangle rect = randomRectangle(30);// divisible by
+      rects.add(rect);
+      calc.expandRange(rect);
+    }
+    Rectangle boundary = calc.getBoundary();
+    if (numShapes == 1) {
+      assertEquals(rects.get(0), boundary);
+      return;
+    }
+
+    // If the boundary is the world-bounds, check that it's right.
+    if (boundary.getMinX() == -180 && boundary.getMaxX() == 180) {
+      // each longitude should be present in at least one shape:
+      for (int lon = -180; lon <= +180; lon++) {
+        assertTrue(atLeastOneRectHasLon(rects, lon));
+      }
+      return;
+    }
+
+    // Test that it contains all shapes:
+    for (Rectangle rect : rects) {
+      assertRelation(SpatialRelation.CONTAINS, boundary, rect);
+    }
+
+    // Test that the left & right are boundaries:
+    assertTrue(atLeastOneRectHasLon(rects, boundary.getMinX()));
+    assertFalse(atLeastOneRectHasLon(rects, normX(boundary.getMinX() - 0.5)));
+
+    assertTrue(atLeastOneRectHasLon(rects, boundary.getMaxX()));
+    assertFalse(atLeastOneRectHasLon(rects, normX(boundary.getMaxX() + 0.5)));
+
+    // Test that this is the smallest enclosing boundary by ensuring the gap (opposite the bbox) is
+    //  the largest:
+    if (boundary.getWidth() > 180) { // conversely if wider than 180 then no wider gap is possible
+      double biggerGap = 360.0 - boundary.getWidth() + 0.5;
+      for (Rectangle rect : rects) {
+        // try to see if a bigger gap could lie to the right of this rect
+        double gapRectLeft = rect.getMaxX() + 0.25;
+        double gapRectRight = gapRectLeft + biggerGap;
+        Rectangle testGap = makeNormRect(gapRectLeft, gapRectRight, -90, 90);
+        boolean fits = true;
+        for (Rectangle rect2 : rects) {
+          if (rect2.relate(testGap).intersects()) {
+            fits = false;
+            break;
+          }
+        }
+        assertFalse(fits);//should never fit because it's larger than the biggest gap
+      }
+    }
+  }
+
+  private boolean atLeastOneRectHasLon(List<Rectangle> rects, double lon) {
+    for (Rectangle rect : rects) {
+      if (rect.relateXRange(lon, lon).intersects()) {
+        return true;
+      }
+    }
+    return false;
+  }
+
+}
\ No newline at end of file
