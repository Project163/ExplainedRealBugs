diff --git a/pom.xml b/pom.xml
index b63bf6ff..c2a349e0 100644
--- a/pom.xml
+++ b/pom.xml
@@ -94,8 +94,8 @@
   </properties>
 
   <!-- To check for new plugins and dependencies:
-  mvn org.codehaus.mojo:versions-maven-plugin:2.2:display-plugin-updates
-  mvn org.codehaus.mojo:versions-maven-plugin:2.2:display-dependency-updates
+  mvn org.codehaus.mojo:versions-maven-plugin:2.5:display-plugin-updates
+  mvn org.codehaus.mojo:versions-maven-plugin:2.5:display-dependency-updates
   -->
   <prerequisites>
     <maven>3.0</maven>
diff --git a/src/main/java/org/locationtech/spatial4j/shape/jts/JtsGeometry.java b/src/main/java/org/locationtech/spatial4j/shape/jts/JtsGeometry.java
index 848c12d1..71b120d7 100755
--- a/src/main/java/org/locationtech/spatial4j/shape/jts/JtsGeometry.java
+++ b/src/main/java/org/locationtech/spatial4j/shape/jts/JtsGeometry.java
@@ -58,7 +58,7 @@ public class JtsGeometry extends BaseShape<JtsSpatialContext> {
     } else if (ctx.isGeo()) {
       //Unwraps the geometry across the dateline so it exceeds the standard geo bounds (-180 to +180).
       if (dateline180Check)
-        unwrapDateline(geom);//potentially modifies geom
+        geom = unwrapDateline(geom);//returns same or new geom
       //If given multiple overlapping polygons, fix it by union
       if (allowMultiOverlap)
         geom = unionGeometryCollection(geom);//returns same or new geom
@@ -417,23 +417,42 @@ public class JtsGeometry extends BaseShape<JtsSpatialContext> {
   }
 
   /**
-   * If <code>geom</code> spans the dateline, then this modifies it to be a
+   * If <code>geom</code> spans the dateline (aka anti-meridian), then this modifies it to be a
    * valid JTS geometry that extends to the right of the standard -180 to +180
    * width such that some points are greater than +180 but some remain less.
-   * Takes care to invoke {@link org.locationtech.jts.geom.Geometry#geometryChanged()}
-   * if needed.
    *
-   * @return The number of times the geometry spans the dateline.  >= 0
+   * @return The same geometry or a new one if it was unwrapped
    */
-  //TODO https://github.com/locationtech/spatial4j/issues/150 conditional clone
-  private static int unwrapDateline(Geometry geom) {
+  private static Geometry unwrapDateline(Geometry geom) {
     if (geom.getEnvelopeInternal().getWidth() < 180)
-      return 0;//can't possibly cross the dateline
+      return geom;//can't possibly cross the dateline
+
+    // if a multi-geom:
+    if (geom instanceof GeometryCollection) {
+      if (geom instanceof MultiPoint) {
+        return geom; // always safe since no point crosses the dateline (on it is okay)
+      }
+      GeometryCollection gc = (GeometryCollection) geom;
+      List<Geometry> list = new ArrayList<>(gc.getNumGeometries());
+      boolean didUnwrap = false;
+      for (int n = 0; n < gc.getNumGeometries(); n++) {
+        Geometry geometryN = gc.getGeometryN(n);
+        Geometry geometryUnwrapped = unwrapDateline(geometryN);
+        list.add(geometryUnwrapped);
+        didUnwrap |= (geometryUnwrapped != geometryN);
+      }
+      return !didUnwrap ? geom : geom.getFactory().buildGeometry(list);
+    }
+
+    // a geom (not multi).
+
+    Geometry newGeom = geom.copy();
+
     final int[] crossings = {0};//an array so that an inner class can modify it.
-    geom.apply(new GeometryFilter() {
+    newGeom.apply(new GeometryFilter() {
       @Override
       public void filter(Geometry geom) {
-        int cross = 0;
+        int cross;
         if (geom instanceof LineString) {//note: LinearRing extends LineString
           if (geom.getEnvelopeInternal().getWidth() < 180)
             return;//can't possibly cross the dateline
@@ -442,15 +461,21 @@ public class JtsGeometry extends BaseShape<JtsSpatialContext> {
           if (geom.getEnvelopeInternal().getWidth() < 180)
             return;//can't possibly cross the dateline
           cross = unwrapDateline((Polygon) geom);
-        } else
+        } else {
+          // The only other JTS subclass of Geometry is a Point, which can't cross anything.
+          //  If the geom is something custom, we don't know what else to do but return.
           return;
+        }
         crossings[0] = Math.max(crossings[0], cross);
       }
     });//geom.apply()
 
-    if (crossings[0] > 0)
-      geom.geometryChanged();//applies to call component Geometries
-    return crossings[0];
+    if (crossings[0] > 0) {
+      newGeom.geometryChanged();
+      return newGeom;
+    } else {
+      return geom; // original
+    }
   }
 
   /** See {@link #unwrapDateline(Geometry)}. */
diff --git a/src/test/java/org/locationtech/spatial4j/context/jts/JtsSpatialContextTest.java b/src/test/java/org/locationtech/spatial4j/context/jts/JtsSpatialContextTest.java
index eb1ffe97..1c6551c0 100644
--- a/src/test/java/org/locationtech/spatial4j/context/jts/JtsSpatialContextTest.java
+++ b/src/test/java/org/locationtech/spatial4j/context/jts/JtsSpatialContextTest.java
@@ -8,25 +8,31 @@
 
 package org.locationtech.spatial4j.context.jts;
 
+import org.locationtech.jts.geom.Geometry;
+import org.locationtech.jts.geom.GeometryFactory;
 import org.locationtech.spatial4j.shape.jts.JtsGeometry;
 import org.locationtech.jts.geom.GeometryCollection;
 import org.locationtech.jts.geom.Polygon;
 import org.junit.Test;
+import org.locationtech.spatial4j.shape.jts.JtsShapeFactory;
 import org.locationtech.spatial4j.util.Geom;
 
+import static org.junit.Assert.assertEquals;
 import static org.junit.Assert.assertTrue;
 
 public class JtsSpatialContextTest {
 
     @Test
     public void testDatelineRule() {
+        // rectangle enclosing the dateline
         Polygon polygon = Geom.build().points(-179, -90, 179, -90, 179, 90, -179, 90).toPolygon();
 
         JtsSpatialContextFactory factory = new JtsSpatialContextFactory();
         factory.datelineRule = DatelineRule.width180;
-
         JtsSpatialContext ctx = factory.newSpatialContext();
-        JtsGeometry shp = ctx.makeShape((Polygon) polygon.clone());
+        final Polygon polygonCloned = polygon.copy();
+        JtsGeometry shp = ctx.makeShape(polygonCloned);
+        assertEquals("shouldn't be modified after calling makeShape", polygon, polygonCloned);
         assertTrue(shp.getGeom() instanceof GeometryCollection);
 
         factory.datelineRule = DatelineRule.none;
@@ -34,4 +40,26 @@ public class JtsSpatialContextTest {
         shp = ctx.makeShape(polygon);
         assertTrue(shp.getGeom() instanceof Polygon);
     }
+
+    @Test
+    public void testDatelineRuleWithMultiPolygon() {
+        JtsSpatialContext ctx = new JtsSpatialContextFactory().newSpatialContext();
+        JtsShapeFactory shapeFactory = ctx.getShapeFactory();
+        GeometryFactory geomFactory = shapeFactory.getGeometryFactory();
+
+        // rectangle enclosing the dateline
+        Polygon poly1Geom = Geom.build().points(-179, -90, 179, -90, 179, 90, -179, 90).toPolygon();
+        // simple triangle
+        Polygon poly2Geom = Geom.build().points(0, 0, 1, 1, 1, 0, 0, 0).toPolygon();
+
+        GeometryCollection geomColl = geomFactory.createGeometryCollection(
+                new Geometry[]{poly1Geom, poly2Geom});
+        JtsGeometry jtsGeometry = shapeFactory.makeShape(geomColl);
+        // one of them is split; other is unchanged
+        assertEquals("MULTIPOLYGON (" +
+                "((-180 -90, -180 90, -179 90, -179 -90, -180 -90)), " +
+                "((179 90, 180 90, 180 -90, 179 -90, 179 90)), " +
+                "((0 0, 1 1, 1 0, 0 0))" +
+                ")", jtsGeometry.toString());
+    }
 }
