diff --git a/src/main/java/com/spatial4j/core/shape/jts/JtsGeometry.java b/src/main/java/com/spatial4j/core/shape/jts/JtsGeometry.java
index cba0ad2b..6d627e43 100755
--- a/src/main/java/com/spatial4j/core/shape/jts/JtsGeometry.java
+++ b/src/main/java/com/spatial4j/core/shape/jts/JtsGeometry.java
@@ -10,12 +10,12 @@ package com.spatial4j.core.shape.jts;
 
 import com.spatial4j.core.context.SpatialContext;
 import com.spatial4j.core.context.jts.JtsSpatialContext;
+import com.spatial4j.core.distance.CartesianDistCalc;
 import com.spatial4j.core.exception.InvalidShapeException;
 import com.spatial4j.core.shape.*;
 import com.spatial4j.core.shape.Point;
 import com.spatial4j.core.shape.impl.BBoxCalculator;
 import com.spatial4j.core.shape.impl.BufferedLineString;
-import com.spatial4j.core.shape.impl.PointImpl;
 import com.spatial4j.core.shape.impl.RectangleImpl;
 import com.vividsolutions.jts.geom.*;
 import com.vividsolutions.jts.geom.prep.PreparedGeometry;
@@ -238,30 +238,117 @@ public class JtsGeometry extends BaseShape<JtsSpatialContext> {
     return relate(ctx.getGeometryFrom(rectangle));
   }
 
-  public SpatialRelation relate(Circle circle) {
+  public SpatialRelation relate(final Circle circle) {
     SpatialRelation bboxR = bbox.relate(circle);
     if (bboxR == SpatialRelation.WITHIN || bboxR == SpatialRelation.DISJOINT)
       return bboxR;
+    // The result could be anything still.
 
-    //Test each point to see how many of them are outside of the circle.
-    //TODO consider instead using geom.apply(CoordinateSequenceFilter) -- maybe faster since avoids Coordinate[] allocation
-    Coordinate[] coords = geom.getCoordinates();
-    int outside = 0;
-    int i = 0;
-    for (Coordinate coord : coords) {
-      i++;
-      SpatialRelation sect = circle.relate(new PointImpl(coord.x, coord.y, ctx));
-      if (sect == SpatialRelation.DISJOINT)
-        outside++;
-      if (i != outside && outside != 0)//short circuit: partially outside, partially inside
-        return SpatialRelation.INTERSECTS;
-    }
-    if (i == outside) {
-      return (relate(circle.getCenter()) == SpatialRelation.DISJOINT)
-          ? SpatialRelation.DISJOINT : SpatialRelation.CONTAINS;
-    }
-    assert outside == 0;
-    return SpatialRelation.WITHIN;
+    final SpatialRelation[] result = {null};
+    // Visit each geometry (this geom might contain others).
+    geom.apply(new GeometryFilter() {
+
+      // We use cartesian math.  It's a limitation/assumption when working with JTS.  When geo=true (i.e. we're using
+      //   WGS84 instead of a projected coordinate system), the errors here will be pretty terrible east-west.  At
+      //   60 degrees latitude, the circle will work as if it has half the width it should.
+      //   Instead, consider converting the circle to a polygon first (not great but better), or projecting both first.
+      //   Ideally, use Geo3D.
+      final CartesianDistCalc calcSqd = CartesianDistCalc.INSTANCE_SQUARED;
+      final double radiusSquared = circle.getRadius() * circle.getRadius();
+      final Geometry ctrGeom = ctx.getGeometryFrom(circle.getCenter());
+
+      @Override
+      public void filter(Geometry geom) {
+        if (result[0] == SpatialRelation.INTERSECTS || result[0] == SpatialRelation.CONTAINS) {
+          // a previous filter(geom) call had a result that won't be changed no matter how this geom relates
+          return;
+        }
+
+        if (geom instanceof Polygon) {
+          Polygon polygon = (Polygon) geom;
+          SpatialRelation rel = relateEnclosedRing((LinearRing) polygon.getExteriorRing());
+          // if rel == INTERSECTS or WITHIN or DISJOINT; done.  But CONTAINS...
+          if (rel == SpatialRelation.CONTAINS) {
+            // if the poly outer ring contains the circle, check the holes. Could become DISJOINT or INTERSECTS.
+            HOLE_LOOP: for (int i = 0; i < polygon.getNumInteriorRing(); i++){
+              // TODO short-circuit based on the hole's bbox if it's disjoint or within the circle.
+              switch (relateEnclosedRing((LinearRing) polygon.getInteriorRingN(i))) {
+                case WITHIN:// fall through
+                case INTERSECTS:
+                  rel = SpatialRelation.INTERSECTS;
+                  break HOLE_LOOP;
+                case CONTAINS:
+                  rel = SpatialRelation.DISJOINT;
+                  break HOLE_LOOP;
+                //case DISJOINT: break; // continue hole loop
+              }
+            }
+          }
+          result[0] = rel.combine(result[0]);
+        } else if (geom instanceof LineString) {
+          LineString lineString = (LineString) geom;
+          SpatialRelation rel = relateLineString(lineString);
+          result[0] = rel.combine(result[0]);
+        } else if (geom instanceof com.vividsolutions.jts.geom.Point) {
+          com.vividsolutions.jts.geom.Point point = (com.vividsolutions.jts.geom.Point) geom;
+          SpatialRelation rel =
+                  calcSqd.distance(circle.getCenter(), point.getX(), point.getY()) > radiusSquared
+                          ? SpatialRelation.DISJOINT : SpatialRelation.WITHIN;
+          result[0] = rel.combine(result[0]);
+        }
+        // else it's going to be some GeometryCollection and we'll visit the contents.
+      }
+
+      /** As if the ring is the outer ring of a polygon */
+      SpatialRelation relateEnclosedRing(LinearRing ring) {
+        SpatialRelation rel = relateLineString(ring);
+        if (rel == SpatialRelation.DISJOINT
+                && ctx.getGeometryFactory().createPolygon(ring).contains(ctrGeom)) {
+          // If it contains the circle center point, then the result is CONTAINS
+          rel = SpatialRelation.CONTAINS;
+        }
+        return rel;
+      }
+
+      SpatialRelation relateLineString(LineString lineString) {
+        final CoordinateSequence seq = lineString.getCoordinateSequence();
+        final boolean isRing = lineString instanceof LinearRing;
+        int numOutside = 0;
+        // Compare the coordinates:
+        for (int i = 0, numComparisons = 0; i < seq.size(); i++) {
+          if (i == 0 && isRing) {
+            continue;
+          }
+          numComparisons++;
+          boolean outside = calcSqd.distance(circle.getCenter(), seq.getX(i), seq.getY(i)) > radiusSquared;
+          if (outside) {
+            numOutside++;
+          }
+          // If the comparisons have a mix of outside/inside, then we can short-circuit INTERSECTS.
+          if (numComparisons != numOutside && numOutside != 0) {
+            assert numComparisons > 1;
+            return SpatialRelation.INTERSECTS;
+          }
+        }
+        // Either all vertices are outside or inside, by this stage.
+        if (numOutside == 0) { // all inside
+          return SpatialRelation.WITHIN.combine(result[0]);
+        }
+        // They are all outside.
+        // Check the edges (line segments) to see if any are inside.
+        for (int i = 1; i < seq.size(); i++) {
+          boolean outside = calcSqd.distanceToLineSegment(
+                  circle.getCenter(), seq.getX(i-1), seq.getY(i-1), seq.getX(i), seq.getY(i))
+                  > radiusSquared;
+          if (!outside) {
+            return SpatialRelation.INTERSECTS;
+          }
+        }
+        return SpatialRelation.DISJOINT;
+      }
+    });
+
+    return result[0] == null ? SpatialRelation.DISJOINT : result[0];
   }
 
   public SpatialRelation relate(JtsGeometry jtsGeometry) {
diff --git a/src/test/java/com/spatial4j/core/shape/JtsGeometryTest.java b/src/test/java/com/spatial4j/core/shape/JtsGeometryTest.java
index 91a4a5e7..a5ba884c 100755
--- a/src/test/java/com/spatial4j/core/shape/JtsGeometryTest.java
+++ b/src/test/java/com/spatial4j/core/shape/JtsGeometryTest.java
@@ -15,6 +15,7 @@ import com.spatial4j.core.context.jts.JtsSpatialContext;
 import com.spatial4j.core.context.jts.JtsSpatialContextFactory;
 import com.spatial4j.core.io.WKTReader;
 import com.spatial4j.core.shape.impl.PointImpl;
+import com.spatial4j.core.shape.impl.RectangleImpl;
 import com.spatial4j.core.shape.jts.JtsGeometry;
 import com.vividsolutions.jts.geom.*;
 import io.jeo.geom.Geom;
@@ -30,6 +31,7 @@ import java.util.Random;
 import static com.spatial4j.core.shape.SpatialRelation.CONTAINS;
 import static com.spatial4j.core.shape.SpatialRelation.DISJOINT;
 import static com.spatial4j.core.shape.SpatialRelation.INTERSECTS;
+import static com.spatial4j.core.shape.SpatialRelation.WITHIN;
 
 /** Tests {@link com.spatial4j.core.shape.jts.JtsGeometry} and some other code related
  * to {@link com.spatial4j.core.context.jts.JtsSpatialContext}.
@@ -40,6 +42,7 @@ public class JtsGeometryTest extends AbstractTestShapes {
   private JtsGeometry POLY_SHAPE;
   private final int DL_SHIFT = 180;//since POLY_SHAPE contains 0 0, I know a shift of 180 will make it cross the DL.
   private JtsGeometry POLY_SHAPE_DL;//POLY_SHAPE shifted by DL_SHIFT to cross the dateline
+  final JtsSpatialContext ctxNotGeo;
 
   public JtsGeometryTest() throws ParseException {
     super(JtsSpatialContext.GEO);
@@ -49,6 +52,11 @@ public class JtsGeometryTest extends AbstractTestShapes {
       POLY_SHAPE_DL = shiftPoly(POLY_SHAPE, DL_SHIFT);
       assertTrue(POLY_SHAPE_DL.getBoundingBox().getCrossesDateLine());
     }
+
+    JtsSpatialContextFactory ctxFactory = new JtsSpatialContextFactory();
+    ctxFactory.geo = false;
+    ctxFactory.worldBounds = new RectangleImpl(-1000, 1000, -1000, 1000, null);
+    ctxNotGeo = ctxFactory.newSpatialContext();
   }
 
   private JtsGeometry shiftPoly(JtsGeometry poly, final int lon_shift) throws ParseException {
@@ -277,6 +285,46 @@ public class JtsGeometryTest extends AbstractTestShapes {
 
   }
 
+  @Test
+  public void testPolyRelatesToCircle() throws ParseException {
+    // The polygon is a triangle with a 90-degree angle and two equal sides, and with
+    // a rectangular hole in the middle.
+    Shape poly = wkt(ctxNotGeo, "POLYGON ((1 1, 1 50, 50 1, 1 1), (10 10, 10 15, 15 15, 15 10, 10 10))");
+
+    assertRelation(WITHIN, poly, ctxNotGeo.makeCircle(25, 25, 40));
+    assertRelation(CONTAINS, poly, ctxNotGeo.makeCircle(10, 25, 5));
+    assertRelation(DISJOINT, poly, ctxNotGeo.makeCircle(35, 35, 5));
+    assertRelation(DISJOINT, poly, ctxNotGeo.makeCircle(12, 12, 1)); // inside the hole
+
+    // Intersects, or almost intersects and is something else
+    //                                                                  The circle...
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(25, 25, 34)); // not *quite* within
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(30, 30, 10)); // crosses into the long angle
+    assertRelation(DISJOINT,   poly, ctxNotGeo.makeCircle(30, 30, 5)); // almost crosses into the long angle
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(25, -5, 10)); // crosses into the bottom edge
+    assertRelation(DISJOINT,   poly, ctxNotGeo.makeCircle(25, -5, 1)); // almost crosses into the bottom edge
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(0, 0, 10)); // encloses a corner
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(10, 35, 5)); // inside but sticks out at the angle
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(12, 12, 10)); // encloses the hole but otherwise inside the triangle
+  }
+
+  @Test
+  public void testMultiLineStringRelatesToCircle() throws com.vividsolutions.jts.io.ParseException {
+    // use JTS WKTReader to ensure we get one Geometry in the end
+    com.vividsolutions.jts.io.WKTReader wktReader = new com.vividsolutions.jts.io.WKTReader();
+    Shape poly = ctxNotGeo.makeShape(wktReader.read("MULTILINESTRING ((5 20, 5 5, 20 5), (20 25, 30 15))"));
+    assertEquals(JtsGeometry.class, poly.getClass());
+
+    assertRelation(WITHIN, poly, ctxNotGeo.makeCircle(15, 15, 20));
+    assertRelation(DISJOINT, poly, ctxNotGeo.makeCircle(15, 15, 5)); // much smaller now; doesn't touch anything
+
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(5, 5, 16)); // circle encloses the left lineString
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(25, 20, 10)); // circle encloses the right lineString
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(5, 20, 1)); // circle encloses first point
+    assertRelation(INTERSECTS, poly, ctxNotGeo.makeCircle(26, 21, 2)); // only intersects an edge of 2nd
+    // not CONTAINS is impossible with a circle; line strings don't contain anything
+  }
+
   private Shape wkt(SpatialContext ctx, String wkt) throws ParseException {
     return ((WKTReader) ctx.getFormats().getWktReader()).parse(wkt);
   }
