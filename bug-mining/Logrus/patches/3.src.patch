diff --git a/text_formatter.go b/text_formatter.go
index ce19ead..c5cf225 100644
--- a/text_formatter.go
+++ b/text_formatter.go
@@ -69,7 +69,7 @@ func (f *TextFormatter) Format(entry *Entry) ([]byte, error) {
 	}
 
 	b.WriteByte('\n')
-	return b.Bytes(), nil
+	return b.Bytes()[1:], nil
 }
 
 func printColored(b *bytes.Buffer, entry *Entry, keys []string) {
@@ -85,7 +85,7 @@ func printColored(b *bytes.Buffer, entry *Entry, keys []string) {
 
 	levelText := strings.ToUpper(entry.Level.String())[0:4]
 
-	fmt.Fprintf(b, "\x1b[%dm%s\x1b[0m[%04d] %-44s ", levelColor, levelText, miniTS(), entry.Message)
+	fmt.Fprintf(b, " \x1b[%dm%s\x1b[0m[%04d] %-44s", levelColor, levelText, miniTS(), entry.Message)
 	for _, k := range keys {
 		v := entry.Data[k]
 		fmt.Fprintf(b, " \x1b[%dm%s\x1b[0m=%v", levelColor, k, v)
@@ -111,12 +111,12 @@ func printKeyValue(b *bytes.Buffer, key, value interface{}) {
 	case error:
 		value = value.(error).Error()
 	default:
-		fmt.Fprintf(b, "%v=%v ", key, value)
+		fmt.Fprintf(b, " %v=%v", key, value)
 	}
 
 	if needsQuoting(value.(string)) {
-		fmt.Fprintf(b, "%v=%s ", key, value)
+		fmt.Fprintf(b, " %v=%s", key, value)
 	} else {
-		fmt.Fprintf(b, "%v=%q ", key, value)
+		fmt.Fprintf(b, " %v=%q", key, value)
 	}
 }
diff --git a/text_formatter_test.go b/text_formatter_test.go
index f604f1b..8b71afb 100644
--- a/text_formatter_test.go
+++ b/text_formatter_test.go
@@ -31,3 +31,30 @@ func TestQuoting(t *testing.T) {
 	checkQuoting(false, errors.New("invalid"))
 	checkQuoting(true, errors.New("invalid argument"))
 }
+
+func TestTextPrint(t *testing.T) {
+	tf := &TextFormatter{DisableColors: true}
+	byts, _ := tf.Format(&Entry{Message: "msg content"})
+
+	// make sure no leading or trailing spaces
+	if string(byts) !=
+		"time=\"0001-01-01T00:00:00Z\" level=panic msg=\"msg content\"\n" {
+		t.Errorf("not expected: %q", string(byts))
+	}
+}
+
+func TestColorPrint(t *testing.T) {
+	tf := &TextFormatter{ForceColors: true}
+	entry := WithField("testkey", "value")
+	entry.Message = "msg content"
+	byts, _ := tf.Format(entry)
+
+	// make sure no leading or trailing spaces
+	if string(byts) !=
+		"\x1b[31mPANI\x1b[0m[0000] " +
+			// length 44 plus one space
+			"msg content                                  " +
+			"\x1b[31mtestkey\x1b[0m=value\n" {
+		t.Errorf("not expected: %q", string(byts))
+	}
+}
