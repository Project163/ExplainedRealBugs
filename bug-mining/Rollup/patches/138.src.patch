diff --git a/src/Module.ts b/src/Module.ts
index 51f87c359..63115bd5f 100644
--- a/src/Module.ts
+++ b/src/Module.ts
@@ -182,6 +182,7 @@ export default class Module {
 	private esTreeAst: ESTree.Program;
 	private magicString: MagicString;
 	private needsTreeshakingPass: boolean = false;
+	private transformDependencies: string[];
 
 	constructor(graph: Graph, id: string) {
 		this.id = id;
@@ -219,12 +220,14 @@ export default class Module {
 		originalSourcemap,
 		ast,
 		sourcemapChain,
-		resolvedIds
+		resolvedIds,
+		transformDependencies
 	}: ModuleJSON) {
 		this.code = code;
 		this.originalCode = originalCode;
 		this.originalSourcemap = originalSourcemap;
 		this.sourcemapChain = sourcemapChain;
+		this.transformDependencies = transformDependencies;
 
 		timeStart('generate ast', 3);
 
@@ -640,6 +643,7 @@ export default class Module {
 		return {
 			id: this.id,
 			dependencies: this.dependencies.map(module => module.id),
+			transformDependencies: this.transformDependencies,
 			code: this.code,
 			originalCode: this.originalCode,
 			originalSourcemap: this.originalSourcemap,
diff --git a/src/rollup/types.d.ts b/src/rollup/types.d.ts
index a09630a05..4e08a9a71 100644
--- a/src/rollup/types.d.ts
+++ b/src/rollup/types.d.ts
@@ -56,6 +56,7 @@ export interface SourceDescription {
 export interface ModuleJSON {
 	id: string;
 	dependencies: string[];
+	transformDependencies: string[];
 	code: string;
 	originalCode: string;
 	originalSourcemap: RawSourceMap | void;
diff --git a/src/utils/transform.ts b/src/utils/transform.ts
index 4275f9ef4..0a49046e1 100644
--- a/src/utils/transform.ts
+++ b/src/utils/transform.ts
@@ -13,6 +13,7 @@ import {
 } from '../rollup/types';
 import error from './error';
 import getCodeFrame from './getCodeFrame';
+import { dirname, resolve } from './path';
 
 function augmentCodeLocation<T extends RollupError | RollupWarning>({
 	object,
@@ -104,6 +105,7 @@ export default function transform(
 	let ast = <Program>source.ast;
 
 	let promise = Promise.resolve(source.code);
+	let transformDependencies: string[];
 
 	plugins.forEach(plugin => {
 		if (!plugin.transform) return;
@@ -128,6 +130,13 @@ export default function transform(
 						result.map = JSON.parse(result.map);
 					}
 
+					if (Array.isArray(result.dependencies)) {
+						if (!transformDependencies) transformDependencies = [];
+						for (const dep of result.dependencies) {
+							transformDependencies.push(resolve(dirname(id), dep));
+						}
+					}
+
 					if (result.map && typeof result.map.mappings === 'string') {
 						result.map.mappings = decode(result.map.mappings);
 					}
@@ -157,6 +166,7 @@ export default function transform(
 	return promise.then(code => {
 		return {
 			code,
+			transformDependencies,
 			originalCode,
 			originalSourcemap,
 			ast: <ESTree.Program>ast,
diff --git a/src/watch/fileWatchers.ts b/src/watch/fileWatchers.ts
index 0df903a90..e4e38ed2e 100644
--- a/src/watch/fileWatchers.ts
+++ b/src/watch/fileWatchers.ts
@@ -11,52 +11,43 @@ export function addTask(
 	id: string,
 	task: Task,
 	chokidarOptions: WatchOptions,
-	chokidarOptionsHash: string
+	chokidarOptionsHash: string,
+	isTransformDependency: boolean
 ) {
 	if (!watchers.has(chokidarOptionsHash)) watchers.set(chokidarOptionsHash, new Map());
 	const group = watchers.get(chokidarOptionsHash);
 
-	if (!group.has(id)) {
-		const watcher = new FileWatcher(id, chokidarOptions, () => {
-			group.delete(id);
-		});
-
-		if (watcher.fileExists) {
-			group.set(id, watcher);
-		} else {
-			return;
-		}
+	const watcher = group.get(id) || new FileWatcher(id, chokidarOptions, group);
+	if (!watcher.fileExists) {
+		if (isTransformDependency) throw new Error(`Transform dependency ${id} does not exist.`);
+	} else {
+		watcher.addTask(task, isTransformDependency);
 	}
-
-	group.get(id).tasks.add(task);
 }
 
 export function deleteTask(id: string, target: Task, chokidarOptionsHash: string) {
 	const group = watchers.get(chokidarOptionsHash);
-
 	const watcher = group.get(id);
-	if (watcher) {
-		watcher.tasks.delete(target);
-
-		if (watcher.tasks.size === 0) {
-			watcher.close();
-			group.delete(id);
-		}
-	}
+	if (watcher) watcher.deleteTask(target, group);
 }
 
 export default class FileWatcher {
-	fileExists: boolean;
 	fsWatcher: FSWatcher | fs.FSWatcher;
-	tasks: Set<Task>;
+	fileExists: boolean;
+	private id: string;
+	private tasks: Set<Task>;
+	private transformDependencyTasks: Set<Task>;
 
-	constructor(id: string, chokidarOptions: WatchOptions, dispose: () => void) {
+	constructor(id: string, chokidarOptions: WatchOptions, group: Map<string, FileWatcher>) {
+		this.id = id;
 		this.tasks = new Set();
+		this.transformDependencyTasks = new Set();
 
-		let data: string;
+		let modifiedTime: number;
 
 		try {
-			fs.statSync(id);
+			const stats = fs.statSync(id);
+			modifiedTime = +stats.mtime;
 			this.fileExists = true;
 		} catch (err) {
 			if (err.code === 'ENOENT') {
@@ -71,16 +62,23 @@ export default class FileWatcher {
 
 		const handleWatchEvent = (event: string) => {
 			if (event === 'rename' || event === 'unlink') {
-				this.fsWatcher.close();
-				this.trigger();
-				dispose();
+				this.close();
+				group.delete(id);
+				this.trigger(id);
 			} else {
-				// this is necessary because we get duplicate events...
-				const contents = fs.readFileSync(id, 'utf-8');
-				if (contents !== data) {
-					data = contents;
-					this.trigger();
+				let stats: fs.Stats;
+				try {
+					stats = fs.statSync(id);
+				} catch (err) {
+					if (err.code === 'ENOENT') {
+						modifiedTime = -1;
+						this.trigger(id);
+						return;
+					}
+					throw err;
 				}
+				// debounce
+				if (+stats.mtime - modifiedTime > 15) this.trigger(id);
 			}
 		};
 
@@ -89,15 +87,35 @@ export default class FileWatcher {
 		} else {
 			this.fsWatcher = fs.watch(id, opts, handleWatchEvent);
 		}
+
+		group.set(id, this);
+	}
+
+	addTask(task: Task, isTransformDependency = false) {
+		if (isTransformDependency) this.transformDependencyTasks.add(task);
+		else this.tasks.add(task);
+	}
+
+	deleteTask(task: Task, group: Map<string, FileWatcher>) {
+		let deleted = this.tasks.delete(task);
+		deleted = this.transformDependencyTasks.delete(task) || deleted;
+
+		if (deleted && this.tasks.size === 0 && this.transformDependencyTasks.size === 0) {
+			group.delete(this.id);
+			this.close();
+		}
 	}
 
 	close() {
 		this.fsWatcher.close();
 	}
 
-	trigger() {
+	trigger(id: string) {
 		this.tasks.forEach(task => {
-			task.makeDirty();
+			task.invalidate(id, false);
+		});
+		this.transformDependencyTasks.forEach(task => {
+			task.invalidate(id, true);
 		});
 	}
 }
diff --git a/src/watch/index.ts b/src/watch/index.ts
index 29cd93689..48905da20 100644
--- a/src/watch/index.ts
+++ b/src/watch/index.ts
@@ -21,25 +21,21 @@ import { addTask, deleteTask } from './fileWatchers';
 const DELAY = 100;
 
 export class Watcher extends EventEmitter {
-	dirty: boolean;
-	running: boolean;
-	tasks: Task[];
-	succeeded: boolean;
+	private buildTimeout: NodeJS.Timer;
+	private running: boolean;
+	private rerun: boolean = false;
+	private tasks: Task[];
+	private succeeded: boolean = false;
 
 	constructor(configs: RollupWatchOptions[]) {
 		super();
-
-		this.dirty = true;
-		this.running = false;
 		this.tasks = ensureArray(configs).map(config => new Task(this, config));
-		this.succeeded = false;
-
-		process.nextTick(() => {
-			this._run();
-		});
+		this.running = true;
+		process.nextTick(() => this.run());
 	}
 
 	close() {
+		if (this.buildTimeout) clearTimeout(this.buildTimeout);
 		this.tasks.forEach(task => {
 			task.close();
 		});
@@ -47,20 +43,24 @@ export class Watcher extends EventEmitter {
 		this.removeAllListeners();
 	}
 
-	_makeDirty() {
-		if (this.dirty) return;
-		this.dirty = true;
-
-		if (!this.running) {
-			setTimeout(() => {
-				this._run();
-			}, DELAY);
+	invalidate() {
+		if (this.running) {
+			this.rerun = true;
+			return;
 		}
+
+		if (this.buildTimeout) clearTimeout(this.buildTimeout);
+
+		this.buildTimeout = setTimeout(() => {
+			this.buildTimeout = undefined;
+			this.run();
+		}, DELAY);
 	}
 
-	_run() {
+	private run() {
 		this.running = true;
-		this.dirty = false;
+
+		const minBuildDelayPromise = new Promise(resolve => setTimeout(resolve, DELAY));
 
 		this.emit('event', {
 			code: 'START'
@@ -80,39 +80,41 @@ export class Watcher extends EventEmitter {
 					error
 				});
 			})
+			.then(() => {
+				return minBuildDelayPromise;
+			})
 			.then(() => {
 				this.running = false;
 
-				if (this.dirty) {
-					this._run();
+				if (this.rerun) {
+					this.rerun = false;
+					this.run();
 				}
 			});
 	}
 }
 
 export class Task {
-	watcher: Watcher;
-	dirty: boolean;
-	closed: boolean;
-	watched: Set<string>;
-	inputOptions: InputOptions;
+	private watcher: Watcher;
+	private closed: boolean;
+	private watched: Set<string>;
+	private inputOptions: InputOptions;
 	cache: {
 		modules: ModuleJSON[];
 	};
-	chokidarOptions: WatchOptions;
-	chokidarOptionsHash: string;
-	outputFiles: string[];
-	outputs: OutputOptions[];
+	private chokidarOptions: WatchOptions;
+	private chokidarOptionsHash: string;
+	private outputFiles: string[];
+	private outputs: OutputOptions[];
 
-	deprecations: { old: string; new: string }[];
+	private deprecations: { old: string; new: string }[];
 
-	filter: (id: string) => boolean;
+	private filter: (id: string) => boolean;
 
 	constructor(watcher: Watcher, config: RollupWatchOptions) {
 		this.cache = null;
 		this.watcher = watcher;
 
-		this.dirty = true;
 		this.closed = false;
 		this.watched = new Set();
 
@@ -156,17 +158,19 @@ export class Task {
 		});
 	}
 
-	makeDirty() {
-		if (!this.dirty) {
-			this.dirty = true;
-			this.watcher._makeDirty();
+	invalidate(id: string, isTransformDependency: boolean) {
+		if (isTransformDependency) {
+			this.cache.modules.forEach(module => {
+				if (!module.transformDependencies || module.transformDependencies.indexOf(id) === -1)
+					return;
+				// effective invalidation
+				module.originalCode = null;
+			});
 		}
+		this.watcher.invalidate();
 	}
 
 	run() {
-		if (!this.dirty) return;
-		this.dirty = false;
-
 		const options = {
 			...this.inputOptions,
 			cache: this.cache
@@ -198,9 +202,15 @@ export class Task {
 				const watched = (this.watched = new Set());
 
 				this.cache = result.cache;
-				result.cache.modules.forEach(module => {
+				this.cache.modules.forEach(module => {
 					watched.add(module.id);
 					this.watchFile(module.id);
+					if (module.transformDependencies) {
+						module.transformDependencies.forEach(depId => {
+							watched.add(depId);
+							this.watchFile(depId, true);
+						});
+					}
 				});
 				this.watched.forEach(id => {
 					if (!watched.has(id)) deleteTask(id, this, this.chokidarOptionsHash);
@@ -228,14 +238,21 @@ export class Task {
 					// this is necessary to ensure that any 'renamed' files
 					// continue to be watched following an error
 					if (this.cache.modules) {
-						this.cache.modules.forEach(module => this.watchFile(module.id));
+						this.cache.modules.forEach(module => {
+							this.watchFile(module.id);
+							if (module.transformDependencies) {
+								module.transformDependencies.forEach(depId => {
+									this.watchFile(depId, true);
+								});
+							}
+						});
 					}
 				}
 				throw error;
 			});
 	}
 
-	watchFile(id: string) {
+	watchFile(id: string, isTransformDependency = false) {
 		if (!this.filter(id)) return;
 
 		if (this.outputFiles.some(file => file === id)) {
@@ -244,7 +261,7 @@ export class Task {
 
 		// this is necessary to ensure that any 'renamed' files
 		// continue to be watched following an error
-		addTask(id, this, this.chokidarOptions, this.chokidarOptionsHash);
+		addTask(id, this, this.chokidarOptions, this.chokidarOptionsHash, isTransformDependency);
 	}
 }
 
diff --git a/test/watch/index.js b/test/watch/index.js
index 2317d52d3..cc261f4bd 100644
--- a/test/watch/index.js
+++ b/test/watch/index.js
@@ -311,6 +311,226 @@ describe('rollup.watch', () => {
 				});
 		});
 
+		it('watches and rebuilds transform dependencies', () => {
+			return sander
+				.copydir('test/watch/samples/transform-dependencies')
+				.to('test/_tmp/input')
+				.then(() => {
+					const watcher = rollup.watch({
+						input: 'test/_tmp/input/main.js',
+						output: {
+							file: 'test/_tmp/output/bundle.js',
+							format: 'cjs'
+						},
+						plugins: [{
+							transform (code) {
+								const dependencies = ['./asdf'];
+								const text = sander.readFileSync('test/_tmp/input/asdf').toString();
+								return { code: `export default "${text}"`, dependencies };
+							}
+						}],
+						watch: { chokidar }
+					});
+
+					return sequence(watcher, [
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 'asdf');
+							sander.unlinkSync('test/_tmp/input/asdf');
+							sander.writeFileSync('test/_tmp/input/asdf', 'next');
+						},
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 'next');
+							watcher.close();
+						}
+					]);
+				});
+		});
+
+		it('throws if transform dependency doesnt exist', () => {
+			return sander
+				.copydir('test/watch/samples/transform-dependencies')
+				.to('test/_tmp/input')
+				.then(() => {
+					const watcher = rollup.watch({
+						input: 'test/_tmp/input/main.js',
+						output: {
+							file: 'test/_tmp/output/bundle.js',
+							format: 'cjs'
+						},
+						plugins: [{
+							transform (code) {
+								const dependencies = ['./doesnotexist'];
+								const text = sander.readFileSync('test/_tmp/input/asdf').toString();
+								return { code: `export default "${text}"`, dependencies };
+							}
+						}],
+						watch: { chokidar }
+					});
+
+					return sequence(watcher, [
+						'START',
+						'BUNDLE_START',
+						'FATAL',
+						event => {
+							assert.ok(event.error.message.startsWith('Transform dependency'));
+							assert.ok(event.error.message.endsWith('does not exist.'));
+							watcher.close();
+						}
+					]);
+				});
+		});
+
+		it('watches and rebuilds transform dependencies that are modules', () => {
+			return sander
+				.copydir('test/watch/samples/transform-dependencies')
+				.to('test/_tmp/input')
+				.then(() => {
+					const watcher = rollup.watch({
+						input: 'test/_tmp/input/main.js',
+						output: {
+							file: 'test/_tmp/output/bundle.js',
+							format: 'cjs'
+						},
+						plugins: [{
+							transform (code) {
+								const dependencies = ['./main.js'];
+								const text = sander.readFileSync('test/_tmp/input/main.js').toString().trim();
+								return { code: `export default "${text}"`, dependencies };
+							}
+						}],
+						watch: { chokidar }
+					});
+
+					return sequence(watcher, [
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 'export default 42;');
+							sander.unlinkSync('test/_tmp/input/main.js');
+							sander.writeFileSync('test/_tmp/input/main.js', 'next');
+						},
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 'next');
+							watcher.close();
+						}
+					]);
+				});
+		});
+
+		it('watches and rebuilds transform dependencies directories', () => {
+			let v = 1;
+			return sander
+				.copydir('test/watch/samples/transform-dependencies')
+				.to('test/_tmp/input')
+				.then(() => {
+					const watcher = rollup.watch({
+						input: 'test/_tmp/input/main.js',
+						output: {
+							file: 'test/_tmp/output/bundle.js',
+							format: 'cjs'
+						},
+						plugins: [{
+							transform (code) {
+								const dependencies = ['./'];
+								return { code: `export default ${v++}`, dependencies };
+							}
+						}],
+						watch: { chokidar }
+					});
+
+					return sequence(watcher, [
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 1);
+							sander.unlinkSync('test/_tmp/input/asdf');
+						},
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 2);
+							watcher.close();
+						}
+					]);
+				});
+		});
+
+		it('watches and rebuilds transform dependencies created and removed between runs', () => {
+			let v = 1;
+			return sander
+				.copydir('test/watch/samples/transform-dependencies')
+				.to('test/_tmp/input')
+				.then(() => {
+					const watcher = rollup.watch({
+						input: 'test/_tmp/input/main.js',
+						output: {
+							file: 'test/_tmp/output/bundle.js',
+							format: 'cjs'
+						},
+						plugins: [{
+							transform (code) {
+								let dependencies = [];
+								if (v === 2)
+									dependencies = ['./asdf'];
+								return { code: `export default ${v++}`, dependencies };
+							}
+						}],
+						watch: { chokidar }
+					});
+
+					return sequence(watcher, [
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 1);
+							sander.unlinkSync('test/_tmp/input/main.js');
+							sander.writeFileSync('test/_tmp/input/main.js', 'next');
+						},
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 2);
+							sander.unlinkSync('test/_tmp/input/asdf');
+						},
+						'START',
+						'BUNDLE_START',
+						'BUNDLE_END',
+						'END',
+						() => {
+							assert.equal(run('../_tmp/output/bundle.js'), 3);
+							sander.writeFileSync('test/_tmp/input/asdf', 'ignored');
+							return new Promise(resolve => setTimeout(resolve, 50));
+						},
+						() => {
+							watcher.close();
+						}
+					]);
+				});
+		});
+
+
 		it('refuses to watch the output file (#15)', () => {
 			return sander
 				.copydir('test/watch/samples/basic')
diff --git a/test/watch/samples/transform-dependencies/asdf b/test/watch/samples/transform-dependencies/asdf
new file mode 100644
index 000000000..5e40c0877
--- /dev/null
+++ b/test/watch/samples/transform-dependencies/asdf
@@ -0,0 +1 @@
+asdf
\ No newline at end of file
diff --git a/test/watch/samples/transform-dependencies/main.js b/test/watch/samples/transform-dependencies/main.js
new file mode 100644
index 000000000..7a4e8a723
--- /dev/null
+++ b/test/watch/samples/transform-dependencies/main.js
@@ -0,0 +1 @@
+export default 42;
