diff --git a/src/Declaration.js b/src/Declaration.js
index ef10b7f38..ad6d13c88 100644
--- a/src/Declaration.js
+++ b/src/Declaration.js
@@ -1,5 +1,6 @@
 import { blank, keys } from './utils/object.js';
 import run from './utils/run.js';
+import { SyntheticReference } from './Reference.js';
 
 export default class Declaration {
 	constructor ( node, isParam, statement ) {
@@ -170,6 +171,12 @@ export class SyntheticNamespaceDeclaration {
 		if ( !this.needsNamespaceBlock ) {
 			this.needsNamespaceBlock = true;
 			this.module.bundle.internalNamespaces.push( this );
+
+			// add synthetic references, in case of chained
+			// namespace imports
+			keys( this.originals ).forEach( name => {
+				this.originals[ name ].addReference( new SyntheticReference( name ) );
+			});
 		}
 
 		reference.declaration = this;
diff --git a/src/Reference.js b/src/Reference.js
new file mode 100644
index 000000000..e86ad9b2d
--- /dev/null
+++ b/src/Reference.js
@@ -0,0 +1,30 @@
+export class Reference {
+	constructor ( node, scope, statement ) {
+		this.node = node;
+		this.scope = scope;
+		this.statement = statement;
+
+		this.declaration = null; // bound later
+
+		this.parts = [];
+
+		let root = node;
+		while ( root.type === 'MemberExpression' ) {
+			this.parts.unshift( root.property.name );
+			root = root.object;
+		}
+
+		this.name = root.name;
+
+		this.start = node.start;
+		this.end = node.start + this.name.length; // can be overridden in the case of namespace members
+		this.rewritten = false;
+	}
+}
+
+export class SyntheticReference {
+	constructor ( name ) {
+		this.name = name;
+		this.parts = [];
+	}
+}
diff --git a/src/Statement.js b/src/Statement.js
index 9d75f1319..06d882770 100644
--- a/src/Statement.js
+++ b/src/Statement.js
@@ -6,30 +6,7 @@ import isFunctionDeclaration from './ast/isFunctionDeclaration.js';
 import isReference from './ast/isReference.js';
 import getLocation from './utils/getLocation.js';
 import run from './utils/run.js';
-
-class Reference {
-	constructor ( node, scope, statement ) {
-		this.node = node;
-		this.scope = scope;
-		this.statement = statement;
-
-		this.declaration = null; // bound later
-
-		this.parts = [];
-
-		let root = node;
-		while ( root.type === 'MemberExpression' ) {
-			this.parts.unshift( root.property.name );
-			root = root.object;
-		}
-
-		this.name = root.name;
-
-		this.start = node.start;
-		this.end = node.start + this.name.length; // can be overridden in the case of namespace members
-		this.rewritten = false;
-	}
-}
+import { Reference } from './Reference.js';
 
 export default class Statement {
 	constructor ( node, module, start, end ) {
diff --git a/test/function/import-chain-as/_config.js b/test/function/import-chain-as/_config.js
index 53d9107f1..9294fd44f 100644
--- a/test/function/import-chain-as/_config.js
+++ b/test/function/import-chain-as/_config.js
@@ -1,5 +1,3 @@
 module.exports = {
 	description: 'imports as- chained exports'
 };
-
-// test copied from https://github.com/esnext/es6-module-transpiler/tree/master/test/examples/import-chain
diff --git a/test/function/import-chain-as/main.js b/test/function/import-chain-as/main.js
index 5d3ebc2ea..d1dc2b90c 100644
--- a/test/function/import-chain-as/main.js
+++ b/test/function/import-chain-as/main.js
@@ -1,6 +1,5 @@
 import * as second from './second';
 
-assert.equal(second.first.value, 42);
-assert.deepEqual(second, {first: {value: 42}})
-//console.log("second", second)
-//console.log("first", second.first)
+assert.equal( second.first.value, 42 );
+console.log( 'second', second )
+assert.deepEqual( second, { first: { value: 42 } });
