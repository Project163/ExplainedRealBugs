diff --git a/Source/Charts/Charts/BarLineChartViewBase.swift b/Source/Charts/Charts/BarLineChartViewBase.swift
index be881576..22103fea 100644
--- a/Source/Charts/Charts/BarLineChartViewBase.swift
+++ b/Source/Charts/Charts/BarLineChartViewBase.swift
@@ -511,12 +511,12 @@ open class BarLineChartViewBase: ChartViewBase, BarLineScatterCandleBubbleChartD
             
             if h === nil || h!.isEqual(self.lastHighlighted)
             {
-                self.highlightValue(highlight: nil, callDelegate: true)
+                self.highlightValue(nil, callDelegate: true)
                 self.lastHighlighted = nil
             }
             else
             {
-                self.highlightValue(highlight: h, callDelegate: true)
+                self.highlightValue(h, callDelegate: true)
                 self.lastHighlighted = h
             }
         }
@@ -715,7 +715,7 @@ open class BarLineChartViewBase: ChartViewBase, BarLineScatterCandleBubbleChartD
                     (h !== nil && lastHighlighted !== nil && !h!.isEqual(lastHighlighted)))
                 {
                     self.lastHighlighted = h
-                    self.highlightValue(highlight: h, callDelegate: true)
+                    self.highlightValue(h, callDelegate: true)
                 }
             }
         }
diff --git a/Source/Charts/Charts/ChartViewBase.swift b/Source/Charts/Charts/ChartViewBase.swift
index 248ed7f4..695a6229 100755
--- a/Source/Charts/Charts/ChartViewBase.swift
+++ b/Source/Charts/Charts/ChartViewBase.swift
@@ -448,8 +448,8 @@ open class ChartViewBase: NSUIView, ChartDataProvider, AnimatorDelegate
 
     /// Highlights the values at the given indices in the given DataSets. Provide
     /// null or an empty array to undo all highlighting. 
-    /// This should be used to programmatically highlight values. 
-    /// This DOES NOT generate a callback to the delegate.
+    /// This should be used to programmatically highlight values.
+    /// This method *will not* call the delegate.
     open func highlightValues(_ highs: [Highlight]?)
     {
         // set the indices to highlight
@@ -468,44 +468,71 @@ open class ChartViewBase: NSUIView, ChartDataProvider, AnimatorDelegate
         setNeedsDisplay()
     }
     
-    
-    /// Highlights the values represented by the provided Highlight object
-    /// This DOES NOT generate a callback to the delegate.
-    /// - parameter highlight: contains information about which entry should be highlighted
-    open func highlightValue(_ highlight: Highlight?)
+    /// Highlights any y-value at the given x-value in the given DataSet.
+    /// Provide -1 as the dataSetIndex to undo all highlighting.
+    /// This method will call the delegate.
+    /// - parameter x: The x-value to highlight
+    /// - parameter dataSetIndex: The dataset index to search in
+    open func highlightValue(x: Double, dataSetIndex: Int)
     {
-        highlightValue(highlight: highlight, callDelegate: false)
+        highlightValue(x: x, dataSetIndex: dataSetIndex, callDelegate: true)
     }
     
-    /// Highlights the value at the given x-value in the given DataSet.
+    /// Highlights the value at the given x-value and y-value in the given DataSet.
     /// Provide -1 as the dataSetIndex to undo all highlighting.
-    open func highlightValue(x: Double, dataSetIndex: Int)
+    /// This method will call the delegate.
+    /// - parameter x: The x-value to highlight
+    /// - parameter y: The y-value to highlight. Supply `NaN` for "any"
+    /// - parameter dataSetIndex: The dataset index to search in
+    open func highlightValue(x: Double, y: Double, dataSetIndex: Int)
     {
-        highlightValue(x: x, dataSetIndex: dataSetIndex, callDelegate: true)
+        highlightValue(x: x, y: y, dataSetIndex: dataSetIndex, callDelegate: true)
     }
     
-    /// Highlights the value at the given x-value in the given DataSet.
+    /// Highlights any y-value at the given x-value in the given DataSet.
     /// Provide -1 as the dataSetIndex to undo all highlighting.
+    /// - parameter x: The x-value to highlight
+    /// - parameter dataSetIndex: The dataset index to search in
+    /// - parameter callDelegate: Should the delegate be called for this change
     open func highlightValue(x: Double, dataSetIndex: Int, callDelegate: Bool)
+    {
+        highlightValue(x: x, y: Double.nan, dataSetIndex: dataSetIndex, callDelegate: callDelegate)
+    }
+    
+    /// Highlights the value at the given x-value and y-value in the given DataSet.
+    /// Provide -1 as the dataSetIndex to undo all highlighting.
+    /// - parameter x: The x-value to highlight
+    /// - parameter y: The y-value to highlight. Supply `NaN` for "any"
+    /// - parameter dataSetIndex: The dataset index to search in
+    /// - parameter callDelegate: Should the delegate be called for this change
+    open func highlightValue(x: Double, y: Double, dataSetIndex: Int, callDelegate: Bool)
     {
         guard let data = _data else
         {
             Swift.print("Value not highlighted because data is nil")
             return
         }
-
+        
         if dataSetIndex < 0 || dataSetIndex >= data.dataSetCount
         {
-            highlightValue(highlight: nil, callDelegate: callDelegate)
+            highlightValue(nil, callDelegate: callDelegate)
         }
         else
         {
-            highlightValue(highlight: Highlight(x: x, dataSetIndex: dataSetIndex), callDelegate: callDelegate)
+            highlightValue(Highlight(x: x, y: y, dataSetIndex: dataSetIndex), callDelegate: callDelegate)
         }
     }
+    
+    /// Highlights the values represented by the provided Highlight object
+    /// This method *will not* call the delegate.
+    /// - parameter highlight: contains information about which entry should be highlighted
+    open func highlightValue(_ highlight: Highlight?)
+    {
+        highlightValue(highlight, callDelegate: false)
+    }
 
     /// Highlights the value selected by touch gesture.
-    open func highlightValue(highlight: Highlight?, callDelegate: Bool)
+    open func highlightValue(_ highlight: Highlight?, callDelegate: Bool)
     {
         var entry: ChartDataEntry?
         var h = highlight
@@ -785,26 +812,6 @@ open class ChartViewBase: NSUIView, ChartDataProvider, AnimatorDelegate
         return _viewPortHandler.contentRect
     }
     
-    /// Get all Entry objects at the given index across all DataSets.
-    open func getEntriesAtIndex(_ xValue: Double) -> [ChartDataEntry]
-    {
-        var vals = [ChartDataEntry]()
-        
-        guard let data = _data else { return vals }
-
-        for i in 0 ..< data.dataSetCount
-        {
-            guard let set = data.getDataSetByIndex(i)
-                else { continue }
-            if let e = set.entryForXValue(xValue)
-            {
-                vals.append(e)
-            }
-        }
-        
-        return vals
-    }
-    
     /// - returns: The ViewPortHandler of the chart that is responsible for the
     /// content area of the chart and its offsets and dimensions.
     open var viewPortHandler: ViewPortHandler!
diff --git a/Source/Charts/Charts/PieChartView.swift b/Source/Charts/Charts/PieChartView.swift
index c015bee6..cf8fbc96 100755
--- a/Source/Charts/Charts/PieChartView.swift
+++ b/Source/Charts/Charts/PieChartView.swift
@@ -283,7 +283,7 @@ open class PieChartView: PieRadarChartViewBase
         
         for i in 0 ..< dataSets.count
         {
-            if (dataSets[i].entryForXValue(xValue) !== nil)
+            if (dataSets[i].entryForXValue(xValue, closestToY: Double.nan) !== nil)
             {
                 return i
             }
diff --git a/Source/Charts/Charts/PieRadarChartViewBase.swift b/Source/Charts/Charts/PieRadarChartViewBase.swift
index 8dd7227a..0d99e2a8 100755
--- a/Source/Charts/Charts/PieRadarChartViewBase.swift
+++ b/Source/Charts/Charts/PieRadarChartViewBase.swift
@@ -829,7 +829,7 @@ open class PieRadarChartViewBase: ChartViewBase
             let location = recognizer.location(in: self)
             
             let high = self.getHighlightByTouchPoint(location)
-            self.highlightValue(highlight: high, callDelegate: true)
+            self.highlightValue(high, callDelegate: true)
         }
     }
     
diff --git a/Source/Charts/Data/Implementations/ChartBaseDataSet.swift b/Source/Charts/Data/Implementations/ChartBaseDataSet.swift
index 9f691022..e8d3def3 100644
--- a/Source/Charts/Data/Implementations/ChartBaseDataSet.swift
+++ b/Source/Charts/Data/Implementations/ChartBaseDataSet.swift
@@ -83,14 +83,19 @@ open class ChartBaseDataSet: NSObject, IChartDataSet
         fatalError("entryForIndex is not implemented in ChartBaseDataSet")
     }
     
-    open func entryForXValue(_ x: Double, rounding: ChartDataSetRounding) -> ChartDataEntry?
+    open func entryForXValue(
+        _ x: Double,
+        closestToY y: Double,
+        rounding: ChartDataSetRounding) -> ChartDataEntry?
     {
-        fatalError("entryForXValue(x, rounding) is not implemented in ChartBaseDataSet")
+        fatalError("entryForXValue(x, closestToY, rounding) is not implemented in ChartBaseDataSet")
     }
     
-    open func entryForXValue(_ x: Double) -> ChartDataEntry?
+    open func entryForXValue(
+        _ x: Double,
+        closestToY y: Double) -> ChartDataEntry?
     {
-        fatalError("entryForXValue(x) is not implemented in ChartBaseDataSet")
+        fatalError("entryForXValue(x, closestToY) is not implemented in ChartBaseDataSet")
     }
     
     open func entriesForXValue(_ x: Double) -> [ChartDataEntry]
@@ -98,9 +103,12 @@ open class ChartBaseDataSet: NSObject, IChartDataSet
         fatalError("entriesForXValue is not implemented in ChartBaseDataSet")
     }
     
-    open func entryIndex(x: Double, rounding: ChartDataSetRounding) -> Int
+    open func entryIndex(
+        x xValue: Double,
+        closestToY y: Double,
+        rounding: ChartDataSetRounding) -> Int
     {
-        fatalError("entryIndex(x, rounding) is not implemented in ChartBaseDataSet")
+        fatalError("entryIndex(x, closestToY, rounding) is not implemented in ChartBaseDataSet")
     }
     
     open func entryIndex(entry e: ChartDataEntry) -> Int
@@ -134,7 +142,7 @@ open class ChartBaseDataSet: NSObject, IChartDataSet
     
     open func removeEntry(x: Double) -> Bool
     {
-        if let entry = entryForXValue(x)
+        if let entry = entryForXValue(x, closestToY: Double.nan)
         {
             return removeEntry(entry)
         }
diff --git a/Source/Charts/Data/Implementations/Standard/ChartData.swift b/Source/Charts/Data/Implementations/Standard/ChartData.swift
index e45935eb..046c209d 100644
--- a/Source/Charts/Data/Implementations/Standard/ChartData.swift
+++ b/Source/Charts/Data/Implementations/Standard/ChartData.swift
@@ -410,7 +410,7 @@ open class ChartData: NSObject
         }
         else
         {
-            return dataSets[highlight.dataSetIndex].entryForXValue(highlight.x)
+            return dataSets[highlight.dataSetIndex].entryForXValue(highlight.x, closestToY: highlight.y)
         }
     }
     
@@ -537,7 +537,7 @@ open class ChartData: NSObject
             return false
         }
         
-        if let entry = _dataSets[dataSetIndex].entryForXValue(xValue)
+        if let entry = _dataSets[dataSetIndex].entryForXValue(xValue, closestToY: Double.nan)
         {
             return removeEntry(entry, dataSetIndex: dataSetIndex)
         }
@@ -557,7 +557,7 @@ open class ChartData: NSObject
         {
             let set = _dataSets[i]
             
-            if (e === set.entryForXValue(e.x))
+            if e === set.entryForXValue(e.x, closestToY: e.y)
             {
                 return set
             }
diff --git a/Source/Charts/Data/Implementations/Standard/ChartDataSet.swift b/Source/Charts/Data/Implementations/Standard/ChartDataSet.swift
index e451e1b3..7b38303e 100644
--- a/Source/Charts/Data/Implementations/Standard/ChartDataSet.swift
+++ b/Source/Charts/Data/Implementations/Standard/ChartDataSet.swift
@@ -119,8 +119,8 @@ open class ChartDataSet: ChartBaseDataSet
         _yMax = -DBL_MAX
         _yMin = DBL_MAX
         
-        let indexFrom = entryIndex(x: fromX, rounding: .down)
-        let indexTo = entryIndex(x: toX, rounding: .up)
+        let indexFrom = entryIndex(x: fromX, closestToY: Double.nan, rounding: .down)
+        let indexTo = entryIndex(x: toX, closestToY: Double.nan, rounding: .up)
         
         if indexTo <= indexFrom { return }
         
@@ -188,13 +188,17 @@ open class ChartDataSet: ChartBaseDataSet
     }
     
     /// - returns: The first Entry object found at the given x-value with binary search.
-    /// If the no Entry at the specifed x-value is found, this method returns the Entry at the closest x-value.
+    /// If the no Entry at the specified x-value is found, this method returns the Entry at the closest x-value according to the rounding.
     /// nil if no Entry object at that x-value.
-    /// - parameter x: the x-value
+    /// - parameter xValue: the x-value
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
     /// - parameter rounding: determine whether to round up/down/closest if there is no Entry matching the provided x-value
-    open override func entryForXValue(_ x: Double, rounding: ChartDataSetRounding) -> ChartDataEntry?
+    open override func entryForXValue(
+        _ xValue: Double,
+        closestToY yValue: Double,
+        rounding: ChartDataSetRounding) -> ChartDataEntry?
     {
-        let index = self.entryIndex(x: x, rounding: rounding)
+        let index = self.entryIndex(x: xValue, closestToY: yValue, rounding: rounding)
         if index > -1
         {
             return _values[index]
@@ -203,16 +207,20 @@ open class ChartDataSet: ChartBaseDataSet
     }
     
     /// - returns: The first Entry object found at the given x-value with binary search.
-    /// If the no Entry at the specifed x-value is found, this method returns the Entry at the closest x-value.
+    /// If the no Entry at the specified x-value is found, this method returns the Entry at the closest x-value.
     /// nil if no Entry object at that x-value.
-    open override func entryForXValue(_ x: Double) -> ChartDataEntry?
+    /// - parameter xValue: the x-value
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
+    open override func entryForXValue(
+        _ xValue: Double,
+        closestToY yValue: Double) -> ChartDataEntry?
     {
-        return entryForXValue(x, rounding: .closest)
+        return entryForXValue(xValue, closestToY: yValue, rounding: .closest)
     }
     
     /// - returns: All Entry objects found at the given xIndex with binary search.
     /// An empty array if no Entry object at that index.
-    open override func entriesForXValue(_ x: Double) -> [ChartDataEntry]
+    open override func entriesForXValue(_ xValue: Double) -> [ChartDataEntry]
     {
         var entries = [ChartDataEntry]()
         
@@ -225,9 +233,9 @@ open class ChartDataSet: ChartBaseDataSet
             var entry = _values[m]
             
             // if we have a match
-            if x == entry.x
+            if xValue == entry.x
             {
-                while m > 0 && _values[m - 1].x == x
+                while m > 0 && _values[m - 1].x == xValue
                 {
                     m -= 1
                 }
@@ -238,7 +246,7 @@ open class ChartDataSet: ChartBaseDataSet
                 while m < high
                 {
                     entry = _values[m]
-                    if entry.x == x
+                    if entry.x == xValue
                     {
                         entries.append(entry)
                     }
@@ -254,7 +262,7 @@ open class ChartDataSet: ChartBaseDataSet
             }
             else
             {
-                if x > entry.x
+                if xValue > entry.x
                 {
                     low = m + 1
                 }
@@ -268,14 +276,20 @@ open class ChartDataSet: ChartBaseDataSet
         return entries
     }
     
-    /// - returns: The array-index of the specified entry
+    /// - returns: The array-index of the specified entry.
+    /// If the no Entry at the specified x-value is found, this method returns the index of the Entry at the closest x-value according to the rounding.
     ///
-    /// - parameter x: x-index of the entry to search for
-    /// - parameter rounding: x-index of the entry to search for
-    open override func entryIndex(x xValue: Double, rounding: ChartDataSetRounding) -> Int
+    /// - parameter xValue: x-value of the entry to search for
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
+    /// - parameter rounding: Rounding method if exact value was not found
+    open override func entryIndex(
+        x xValue: Double,
+        closestToY yValue: Double,
+        rounding: ChartDataSetRounding) -> Int
     {
         var low = 0
         var high = _values.count - 1
+        var closest = high
         
         while low < high
         {
@@ -312,28 +326,62 @@ open class ChartDataSet: ChartBaseDataSet
                     low = m + 1
                 }
             }
+            
+            closest = high
         }
         
-        if high != -1
+        if closest != -1
         {
-            let closestXValue = _values[high].x
+            let closestXValue = _values[closest].x
+            
             if rounding == .up
             {
-                if closestXValue < xValue && high < _values.count - 1
+                // If rounding up, and found x-value is lower than specified x, and we can go upper...
+                if closestXValue < xValue && closest < _values.count - 1
                 {
-                    high += 1
+                    closest += 1
                 }
             }
             else if rounding == .down
             {
-                if closestXValue > xValue && high > 0
+                // If rounding down, and found x-value is upper than specified x, and we can go lower...
+                if closestXValue > xValue && closest > 0
                 {
-                    high -= 1
+                    closest -= 1
                 }
             }
+            
+            // Search by closest to y-value
+            if !yValue.isNaN
+            {
+                while closest > 0 && _values[closest - 1].x == closestXValue
+                {
+                    closest -= 1
+                }
+                
+                var closestYValue = _values[closest].y
+                var closestYIndex = closest
+                
+                while true
+                {
+                    closest += 1
+                    if closest >= _values.count { break }
+                    
+                    let value = _values[closest]
+                    
+                    if value.x != closestXValue { break }
+                    if abs(value.y - yValue) < abs(closestYValue - yValue)
+                    {
+                        closestYValue = yValue
+                        closestYIndex = closest
+                    }
+                }
+                
+                closest = closestYIndex
+            }
         }
         
-        return high
+        return closest
     }
     
     /// - returns: The array-index of the specified entry
@@ -387,7 +435,7 @@ open class ChartDataSet: ChartBaseDataSet
         
         if _values.count > 0 && _values.last!.x > e.x
         {
-            var closestIndex = entryIndex(x: e.x, rounding: .up)
+            var closestIndex = entryIndex(x: e.x, closestToY: e.y, rounding: .up)
             while _values[closestIndex].x < e.x
             {
                 closestIndex += 1
diff --git a/Source/Charts/Data/Interfaces/IChartDataSet.swift b/Source/Charts/Data/Interfaces/IChartDataSet.swift
index 5ac19664..8b45bda3 100644
--- a/Source/Charts/Data/Interfaces/IChartDataSet.swift
+++ b/Source/Charts/Data/Interfaces/IChartDataSet.swift
@@ -47,26 +47,39 @@ public protocol IChartDataSet
     func entryForIndex(_ i: Int) -> ChartDataEntry?
     
     /// - returns: The first Entry object found at the given x-value with binary search.
-    /// If the no Entry at the specifed x-value is found, this method returns the Entry at the closest x-pox.
+    /// If the no Entry at the specified x-value is found, this method returns the Entry at the closest x-value according to the rounding.
     /// nil if no Entry object at that x-value.
-    /// - parameter x: the x-value
+    /// - parameter xValue: the x-value
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
     /// - parameter rounding: determine whether to round up/down/closest if there is no Entry matching the provided x-value
-    func entryForXValue(_ x: Double, rounding: ChartDataSetRounding) -> ChartDataEntry?
+    func entryForXValue(
+        _ xValue: Double,
+        closestToY yValue: Double,
+        rounding: ChartDataSetRounding) -> ChartDataEntry?
     
     /// - returns: The first Entry object found at the given x-value with binary search.
-    /// If the no Entry at the specifed x-value is found, this method returns the Entry at the closest x-value.
+    /// If the no Entry at the specified x-value is found, this method returns the Entry at the closest x-value.
     /// nil if no Entry object at that x-value.
-    func entryForXValue(_ x: Double) -> ChartDataEntry?
+    /// - parameter xValue: the x-value
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
+    func entryForXValue(
+        _ xValue: Double,
+        closestToY yValue: Double) -> ChartDataEntry?
     
     /// - returns: All Entry objects found at the given x-value with binary search.
     /// An empty array if no Entry object at that x-value.
-    func entriesForXValue(_ x: Double) -> [ChartDataEntry]
-    
-    /// - returns: The array-index of the specified entry
-    ///
-    /// - parameter x: x-value of the entry to search for
-    /// - parameter rounding: x-value of the entry to search for
-    func entryIndex(x: Double, rounding: ChartDataSetRounding) -> Int
+    func entriesForXValue(_ xValue: Double) -> [ChartDataEntry]
+    
+    /// - returns: The array-index of the specified entry.
+    /// If the no Entry at the specified x-value is found, this method returns the index of the Entry at the closest x-value according to the rounding.
+    ///
+    /// - parameter xValue: x-value of the entry to search for
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
+    /// - parameter rounding: Rounding method if exact value was not found
+    func entryIndex(
+        x xValue: Double,
+        closestToY yValue: Double,
+        rounding: ChartDataSetRounding) -> Int
     
     /// - returns: The array-index of the specified entry
     ///
diff --git a/Source/Charts/Highlight/BarHighlighter.swift b/Source/Charts/Highlight/BarHighlighter.swift
index c4f7b8c6..c0235dd5 100644
--- a/Source/Charts/Highlight/BarHighlighter.swift
+++ b/Source/Charts/Highlight/BarHighlighter.swift
@@ -66,7 +66,7 @@ open class BarHighlighter: ChartHighlighter
     {
         guard
             let chart = self.chart as? BarLineScatterCandleBubbleChartDataProvider,
-            let entry = set.entryForXValue(xValue) as? BarChartDataEntry
+            let entry = set.entryForXValue(xValue, closestToY: yValue) as? BarChartDataEntry
             else { return nil }
         
         // Not stacked
diff --git a/Source/Charts/Highlight/ChartHighlighter.swift b/Source/Charts/Highlight/ChartHighlighter.swift
index e638eabc..dd942638 100644
--- a/Source/Charts/Highlight/ChartHighlighter.swift
+++ b/Source/Charts/Highlight/ChartHighlighter.swift
@@ -95,33 +95,42 @@ open class ChartHighlighter : NSObject, IHighlighter
             // extract all y-values from all DataSets at the given x-value.
             // some datasets (i.e bubble charts) make sense to have multiple values for an x-value. We'll have to find a way to handle that later on. It's more complicated now when x-indices are floating point.
             
-            if let high = buildHighlight(dataSet: dataSet, dataSetIndex: i, xValue: xValue, rounding: .closest)
-            {
-                vals.append(high)
-            }
+            vals.append(contentsOf: buildHighlights(dataSet: dataSet, dataSetIndex: i, xValue: xValue, rounding: .closest))
         }
         
         return vals
     }
     
-    /// - returns: The SelectionDetail object corresponding to the selected xValue and dataSetIndex.
-    internal func buildHighlight(
+    /// - returns: An array of `Highlight` objects corresponding to the selected xValue and dataSetIndex.
+    internal func buildHighlights(
         dataSet set: IChartDataSet,
         dataSetIndex: Int,
         xValue: Double,
-        rounding: ChartDataSetRounding) -> Highlight?
+        rounding: ChartDataSetRounding) -> [Highlight]
     {
+        var highlights = [Highlight]()
+        
         guard let chart = self.chart as? BarLineScatterCandleBubbleChartDataProvider
-            else { return nil }
+            else { return highlights }
+        
+        var entries = set.entriesForXValue(xValue)
+        if entries.count == 0
+        {
+            // Try to find closest x-value and take all entries for that x-value
+            if let closest = set.entryForXValue(xValue, closestToY: Double.nan, rounding: rounding)
+            {
+                entries = set.entriesForXValue(closest.x)
+            }
+        }
         
-        if let e = set.entryForXValue(xValue, rounding: rounding)
+        for e in entries
         {
             let px = chart.getTransformer(forAxis: set.axisDependency).pixelForValues(x: e.x, y: e.y)
             
-            return Highlight(x: e.x, y: e.y, xPx: px.x, yPx: px.y, dataSetIndex: dataSetIndex, axis: set.axisDependency)
+            highlights.append(Highlight(x: e.x, y: e.y, xPx: px.x, yPx: px.y, dataSetIndex: dataSetIndex, axis: set.axisDependency))
         }
         
-        return nil
+        return highlights
     }
 
     // - MARK: - Utilities
diff --git a/Source/Charts/Highlight/CombinedHighlighter.swift b/Source/Charts/Highlight/CombinedHighlighter.swift
index 1b1aad81..cd2892f2 100644
--- a/Source/Charts/Highlight/CombinedHighlighter.swift
+++ b/Source/Charts/Highlight/CombinedHighlighter.swift
@@ -61,10 +61,12 @@ open class CombinedHighlighter: ChartHighlighter
                             continue
                         }
                         
-                        if let s1 = buildHighlight(dataSet: dataSet, dataSetIndex: j, xValue: xValue, rounding: .closest)
+                        let highs = buildHighlights(dataSet: dataSet, dataSetIndex: j, xValue: xValue, rounding: .closest)
+                        
+                        for high in highs
                         {
-                            s1.dataIndex = i
-                            vals.append(s1)
+                            high.dataIndex = i
+                            vals.append(high)
                         }
                     }
                 }
diff --git a/Source/Charts/Highlight/Highlight.swift b/Source/Charts/Highlight/Highlight.swift
index ddb596d9..3ef03a6d 100644
--- a/Source/Charts/Highlight/Highlight.swift
+++ b/Source/Charts/Highlight/Highlight.swift
@@ -125,10 +125,12 @@ open class Highlight: NSObject
     }
     
     /// - parameter x: the x-value of the highlighted value
+    /// - parameter y: the y-value of the highlighted value
     /// - parameter dataSetIndex: the index of the DataSet the highlighted value belongs to
-    public init(x: Double, dataSetIndex: Int)
+    public init(x: Double, y: Double, dataSetIndex: Int)
     {
         _x = x
+        _y = y
         _dataSetIndex = dataSetIndex
     }
     
@@ -137,7 +139,7 @@ open class Highlight: NSObject
     /// - parameter stackIndex: references which value of a stacked-bar entry has been selected
     public convenience init(x: Double, dataSetIndex: Int, stackIndex: Int)
     {
-        self.init(x: x, dataSetIndex: dataSetIndex)
+        self.init(x: x, y: Double.nan, dataSetIndex: dataSetIndex)
         _stackIndex = stackIndex
     }
     
diff --git a/Source/Charts/Highlight/HorizontalBarHighlighter.swift b/Source/Charts/Highlight/HorizontalBarHighlighter.swift
index 16e45b5b..eec39c80 100644
--- a/Source/Charts/Highlight/HorizontalBarHighlighter.swift
+++ b/Source/Charts/Highlight/HorizontalBarHighlighter.swift
@@ -38,23 +38,35 @@ open class HorizontalBarHighlighter: BarHighlighter
         return nil
     }
     
-    internal override func buildHighlight(
+    internal override func buildHighlights(
         dataSet set: IChartDataSet,
         dataSetIndex: Int,
         xValue: Double,
-        rounding: ChartDataSetRounding) -> Highlight?
+        rounding: ChartDataSetRounding) -> [Highlight]
     {
+        var highlights = [Highlight]()
+        
         guard let chart = self.chart as? BarLineScatterCandleBubbleChartDataProvider
-            else { return nil }
+            else { return highlights }
         
-        if let e = set.entryForXValue(xValue, rounding: rounding)
+        var entries = set.entriesForXValue(xValue)
+        if entries.count == 0
+        {
+            // Try to find closest x-value and take all entries for that x-value
+            if let closest = set.entryForXValue(xValue, closestToY: Double.nan, rounding: rounding)
+            {
+                entries = set.entriesForXValue(closest.x)
+            }
+        }
+        
+        for e in entries
         {
             let px = chart.getTransformer(forAxis: set.axisDependency).pixelForValues(x: e.y, y: e.x)
             
-            return Highlight(x: e.x, y: e.y, xPx: px.x, yPx: px.y,dataSetIndex: dataSetIndex, axis: set.axisDependency)
+            highlights.append(Highlight(x: e.x, y: e.y, xPx: px.x, yPx: px.y, dataSetIndex: dataSetIndex, axis: set.axisDependency))
         }
         
-        return nil
+        return highlights
     }
     
     internal override func getDistance(x1: CGFloat, y1: CGFloat, x2: CGFloat, y2: CGFloat) -> CGFloat
diff --git a/Source/Charts/Renderers/BarChartRenderer.swift b/Source/Charts/Renderers/BarChartRenderer.swift
index 928e23a4..579810f8 100644
--- a/Source/Charts/Renderers/BarChartRenderer.swift
+++ b/Source/Charts/Renderers/BarChartRenderer.swift
@@ -575,7 +575,7 @@ open class BarChartRenderer: BarLineScatterCandleBubbleRenderer
                 set.isHighlightEnabled
                 else { continue }
             
-            if let e = set.entryForXValue(high.x) as? BarChartDataEntry
+            if let e = set.entryForXValue(high.x, closestToY: high.y) as? BarChartDataEntry
             {
                 if !isInBoundsX(entry: e, dataSet: set)
                 {
diff --git a/Source/Charts/Renderers/BarLineScatterCandleBubbleRenderer.swift b/Source/Charts/Renderers/BarLineScatterCandleBubbleRenderer.swift
index 18550439..a3e8f8b5 100644
--- a/Source/Charts/Renderers/BarLineScatterCandleBubbleRenderer.swift
+++ b/Source/Charts/Renderers/BarLineScatterCandleBubbleRenderer.swift
@@ -86,8 +86,8 @@ open class BarLineScatterCandleBubbleRenderer: DataRenderer
             let low = chart.lowestVisibleX
             let high = chart.highestVisibleX
             
-            let entryFrom = dataSet.entryForXValue(low, rounding: ChartDataSetRounding.down)
-            let entryTo = dataSet.entryForXValue(high, rounding: ChartDataSetRounding.up)
+            let entryFrom = dataSet.entryForXValue(low, closestToY: Double.nan, rounding: ChartDataSetRounding.down)
+            let entryTo = dataSet.entryForXValue(high, closestToY: Double.nan, rounding: ChartDataSetRounding.up)
             
             self.min = entryFrom == nil ? 0 : dataSet.entryIndex(entry: entryFrom!)
             self.max = entryTo == nil ? 0 : dataSet.entryIndex(entry: entryTo!)
diff --git a/Source/Charts/Renderers/BubbleChartRenderer.swift b/Source/Charts/Renderers/BubbleChartRenderer.swift
index d8d63a13..7bd2ead4 100644
--- a/Source/Charts/Renderers/BubbleChartRenderer.swift
+++ b/Source/Charts/Renderers/BubbleChartRenderer.swift
@@ -240,80 +240,70 @@ open class BubbleChartRenderer: BarLineScatterCandleBubbleRenderer
                 dataSet.isHighlightEnabled
                 else { continue }
                         
-            // In bubble charts - it makes sense to have multiple bubbles on the same X value in the same dataset.
+            guard let entry = dataSet.entryForXValue(high.x, closestToY: high.y) as? BubbleChartDataEntry else { continue }
             
-            let entries = dataSet.entriesForXValue(high.x)
+            if !isInBoundsX(entry: entry, dataSet: dataSet) { continue }
             
-            for entry in entries
+            let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
+            
+            _sizeBuffer[0].x = 0.0
+            _sizeBuffer[0].y = 0.0
+            _sizeBuffer[1].x = 1.0
+            _sizeBuffer[1].y = 0.0
+            
+            trans.pointValuesToPixel(&_sizeBuffer)
+            
+            let normalizeSize = dataSet.isNormalizeSizeEnabled
+            
+            // calcualte the full width of 1 step on the x-axis
+            let maxBubbleWidth: CGFloat = abs(_sizeBuffer[1].x - _sizeBuffer[0].x)
+            let maxBubbleHeight: CGFloat = abs(viewPortHandler.contentBottom - viewPortHandler.contentTop)
+            let referenceSize: CGFloat = min(maxBubbleHeight, maxBubbleWidth)
+            
+            _pointBuffer.x = CGFloat(entry.x)
+            _pointBuffer.y = CGFloat(entry.y * phaseY)
+            trans.pointValueToPixel(&_pointBuffer)
+            
+            let shapeSize = getShapeSize(entrySize: entry.size, maxSize: dataSet.maxSize, reference: referenceSize, normalizeSize: normalizeSize)
+            let shapeHalf = shapeSize / 2.0
+            
+            if !viewPortHandler.isInBoundsTop(_pointBuffer.y + shapeHalf) ||
+                !viewPortHandler.isInBoundsBottom(_pointBuffer.y - shapeHalf)
             {
-                guard let entry = entry as? BubbleChartDataEntry
-                    else { continue }
-                
-                if entry.y != high.y { continue }
-                
-                if !isInBoundsX(entry: entry, dataSet: dataSet) { continue }
-                
-                let trans = dataProvider.getTransformer(forAxis: dataSet.axisDependency)
-                
-                _sizeBuffer[0].x = 0.0
-                _sizeBuffer[0].y = 0.0
-                _sizeBuffer[1].x = 1.0
-                _sizeBuffer[1].y = 0.0
-                
-                trans.pointValuesToPixel(&_sizeBuffer)
-                
-                let normalizeSize = dataSet.isNormalizeSizeEnabled
-                
-                // calcualte the full width of 1 step on the x-axis
-                let maxBubbleWidth: CGFloat = abs(_sizeBuffer[1].x - _sizeBuffer[0].x)
-                let maxBubbleHeight: CGFloat = abs(viewPortHandler.contentBottom - viewPortHandler.contentTop)
-                let referenceSize: CGFloat = min(maxBubbleHeight, maxBubbleWidth)
-                
-                _pointBuffer.x = CGFloat(entry.x)
-                _pointBuffer.y = CGFloat(entry.y * phaseY)
-                trans.pointValueToPixel(&_pointBuffer)
-                
-                let shapeSize = getShapeSize(entrySize: entry.size, maxSize: dataSet.maxSize, reference: referenceSize, normalizeSize: normalizeSize)
-                let shapeHalf = shapeSize / 2.0
-                
-                if !viewPortHandler.isInBoundsTop(_pointBuffer.y + shapeHalf) ||
-                    !viewPortHandler.isInBoundsBottom(_pointBuffer.y - shapeHalf)
-                {
-                    continue
-                }
-                
-                if !viewPortHandler.isInBoundsLeft(_pointBuffer.x + shapeHalf)
-                {
-                    continue
-                }
-                
-                if !viewPortHandler.isInBoundsRight(_pointBuffer.x - shapeHalf)
-                {
-                    break
-                }
-                
-                let originalColor = dataSet.color(atIndex: Int(entry.x))
-                
-                var h: CGFloat = 0.0
-                var s: CGFloat = 0.0
-                var b: CGFloat = 0.0
-                var a: CGFloat = 0.0
-                
-                originalColor.getHue(&h, saturation: &s, brightness: &b, alpha: &a)
-                
-                let color = NSUIColor(hue: h, saturation: s, brightness: b * 0.5, alpha: a)
-                let rect = CGRect(
-                    x: _pointBuffer.x - shapeHalf,
-                    y: _pointBuffer.y - shapeHalf,
-                    width: shapeSize,
-                    height: shapeSize)
-                
-                context.setLineWidth(dataSet.highlightCircleWidth)
-                context.setStrokeColor(color.cgColor)
-                context.strokeEllipse(in: rect)
-                
-                high.setDraw(x: _pointBuffer.x, y: _pointBuffer.y)
+                continue
             }
+            
+            if !viewPortHandler.isInBoundsLeft(_pointBuffer.x + shapeHalf)
+            {
+                continue
+            }
+            
+            if !viewPortHandler.isInBoundsRight(_pointBuffer.x - shapeHalf)
+            {
+                break
+            }
+            
+            let originalColor = dataSet.color(atIndex: Int(entry.x))
+            
+            var h: CGFloat = 0.0
+            var s: CGFloat = 0.0
+            var b: CGFloat = 0.0
+            var a: CGFloat = 0.0
+            
+            originalColor.getHue(&h, saturation: &s, brightness: &b, alpha: &a)
+            
+            let color = NSUIColor(hue: h, saturation: s, brightness: b * 0.5, alpha: a)
+            let rect = CGRect(
+                x: _pointBuffer.x - shapeHalf,
+                y: _pointBuffer.y - shapeHalf,
+                width: shapeSize,
+                height: shapeSize)
+            
+            context.setLineWidth(dataSet.highlightCircleWidth)
+            context.setStrokeColor(color.cgColor)
+            context.strokeEllipse(in: rect)
+            
+            high.setDraw(x: _pointBuffer.x, y: _pointBuffer.y)
         }
         
         context.restoreGState()
diff --git a/Source/Charts/Renderers/CandleStickChartRenderer.swift b/Source/Charts/Renderers/CandleStickChartRenderer.swift
index f0f6beb8..8dbaaecc 100644
--- a/Source/Charts/Renderers/CandleStickChartRenderer.swift
+++ b/Source/Charts/Renderers/CandleStickChartRenderer.swift
@@ -331,7 +331,7 @@ open class CandleStickChartRenderer: LineScatterCandleRadarRenderer
                 set.isHighlightEnabled
                 else { continue }
             
-            guard let e = set.entryForXValue(high.x) as? CandleChartDataEntry else { continue }
+            guard let e = set.entryForXValue(high.x, closestToY: high.y) as? CandleChartDataEntry else { continue }
             
             if !isInBoundsX(entry: e, dataSet: set)
             {
diff --git a/Source/Charts/Renderers/LineChartRenderer.swift b/Source/Charts/Renderers/LineChartRenderer.swift
index bd8854ff..fbcdbc92 100644
--- a/Source/Charts/Renderers/LineChartRenderer.swift
+++ b/Source/Charts/Renderers/LineChartRenderer.swift
@@ -712,7 +712,7 @@ open class LineChartRenderer: LineRadarRenderer
                 , set.isHighlightEnabled
                 else { continue }
             
-            guard let e = set.entryForXValue(high.x) else { continue }
+            guard let e = set.entryForXValue(high.x, closestToY: high.y) else { continue }
             
             if !isInBoundsX(entry: e, dataSet: set)
             {
diff --git a/Source/Charts/Renderers/ScatterChartRenderer.swift b/Source/Charts/Renderers/ScatterChartRenderer.swift
index 24f54c60..8d0d57ab 100644
--- a/Source/Charts/Renderers/ScatterChartRenderer.swift
+++ b/Source/Charts/Renderers/ScatterChartRenderer.swift
@@ -203,37 +203,32 @@ open class ScatterChartRenderer: LineScatterCandleRadarRenderer
                 set.isHighlightEnabled
                 else { continue }
             
-            let entries = set.entriesForXValue(high.x)
+            guard let entry = set.entryForXValue(high.x, closestToY: high.y) else { continue }
             
-            for entry in entries
+            if !isInBoundsX(entry: entry, dataSet: set) { continue }
+            
+            context.setStrokeColor(set.highlightColor.cgColor)
+            context.setLineWidth(set.highlightLineWidth)
+            if set.highlightLineDashLengths != nil
             {
-                if entry.y != high.y { continue }
-                
-                if !isInBoundsX(entry: entry, dataSet: set) { continue }
-                
-                context.setStrokeColor(set.highlightColor.cgColor)
-                context.setLineWidth(set.highlightLineWidth)
-                if set.highlightLineDashLengths != nil
-                {
-                    context.setLineDash(phase: set.highlightLineDashPhase, lengths: set.highlightLineDashLengths!)
-                }
-                else
-                {
-                    context.setLineDash(phase: 0.0, lengths: [])
-                }
-                
-                let x = entry.x // get the x-position
-                let y = entry.y * Double(animator.phaseY)
-                
-                let trans = dataProvider.getTransformer(forAxis: set.axisDependency)
-                
-                let pt = trans.pixelForValues(x: x, y: y)
-                
-                high.setDraw(pt: pt)
-                
-                // draw the lines
-                drawHighlightLines(context: context, point: pt, set: set)
+                context.setLineDash(phase: set.highlightLineDashPhase, lengths: set.highlightLineDashLengths!)
             }
+            else
+            {
+                context.setLineDash(phase: 0.0, lengths: [])
+            }
+            
+            let x = entry.x // get the x-position
+            let y = entry.y * Double(animator.phaseY)
+            
+            let trans = dataProvider.getTransformer(forAxis: set.axisDependency)
+            
+            let pt = trans.pixelForValues(x: x, y: y)
+            
+            high.setDraw(pt: pt)
+            
+            // draw the lines
+            drawHighlightLines(context: context, point: pt, set: set)
         }
         
         context.restoreGState()
diff --git a/Source/ChartsRealm/Data/RealmBaseDataSet.swift b/Source/ChartsRealm/Data/RealmBaseDataSet.swift
index 44e874e2..3067647b 100644
--- a/Source/ChartsRealm/Data/RealmBaseDataSet.swift
+++ b/Source/ChartsRealm/Data/RealmBaseDataSet.swift
@@ -252,13 +252,17 @@ open class RealmBaseDataSet: ChartBaseDataSet
     }
     
     /// - returns: The first Entry object found at the given x-value with binary search.
-    /// If the no Entry at the specifed x-value is found, this method returns the Entry at the closest x-value.
+    /// If the no Entry at the specified x-value is found, this method returns the Entry at the closest x-value according to the rounding.
     /// nil if no Entry object at that x-value.
-    /// - parameter x: the x-value
+    /// - parameter xValue: the x-value
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
     /// - parameter rounding: determine whether to round up/down/closest if there is no Entry matching the provided x-value
-    open override func entryForXValue(_ x: Double, rounding: ChartDataSetRounding) -> ChartDataEntry?
+    open override func entryForXValue(
+        _ xValue: Double,
+        closestToY yValue: Double,
+        rounding: ChartDataSetRounding) -> ChartDataEntry?
     {
-        let index = self.entryIndex(x: x, rounding: rounding)
+        let index = self.entryIndex(x: xValue, closestToY: yValue, rounding: rounding)
         if index > -1
         {
             return entryForIndex(index)
@@ -267,16 +271,20 @@ open class RealmBaseDataSet: ChartBaseDataSet
     }
     
     /// - returns: The first Entry object found at the given x-value with binary search.
-    /// If the no Entry at the specifed x-value is found, this method returns the Entry at the closest x-value.
+    /// If the no Entry at the specified x-value is found, this method returns the Entry at the closest x-value.
     /// nil if no Entry object at that x-value.
-    open override func entryForXValue(_ x: Double) -> ChartDataEntry?
+    /// - parameter xValue: the x-value
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
+    open override func entryForXValue(
+        _ xValue: Double,
+        closestToY y: Double) -> ChartDataEntry?
     {
-        return entryForXValue(x, rounding: .closest)
+        return entryForXValue(xValue, closestToY: y, rounding: .closest)
     }
     
     /// - returns: All Entry objects found at the given x-value with binary search.
     /// An empty array if no Entry object at that x-value.
-    open override func entriesForXValue(_ x: Double) -> [ChartDataEntry]
+    open override func entriesForXValue(_ xValue: Double) -> [ChartDataEntry]
     {
         /*var entries = [ChartDataEntry]()
         
@@ -306,9 +314,9 @@ open class RealmBaseDataSet: ChartBaseDataSet
             var m = (high + low) / 2
             var entry = _cache[m]
             
-            if x == entry.x
+            if xValue == entry.x
             {
-                while m > 0 && _cache[m - 1].x == x
+                while m > 0 && _cache[m - 1].x == xValue
                 {
                     m -= 1
                 }
@@ -317,7 +325,7 @@ open class RealmBaseDataSet: ChartBaseDataSet
                 while m < high
                 {
                     entry = _cache[m]
-                    if entry.x == x
+                    if entry.x == xValue
                     {
                         entries.append(entry)
                     }
@@ -333,7 +341,7 @@ open class RealmBaseDataSet: ChartBaseDataSet
             }
             else
             {
-                if x > entry.x
+                if xValue > entry.x
                 {
                     low = m + 1
                 }
@@ -347,10 +355,16 @@ open class RealmBaseDataSet: ChartBaseDataSet
         return entries
     }
     
-    /// - returns: The array-index of the specified entry
+    /// - returns: The array-index of the specified entry.
+    /// If the no Entry at the specified x-value is found, this method returns the index of the Entry at the closest x-value according to the rounding.
     ///
-    /// - parameter x: x-value of the entry to search for
-    open override func entryIndex(x: Double, rounding: ChartDataSetRounding) -> Int
+    /// - parameter xValue: x-value of the entry to search for
+    /// - parameter closestToY: If there are multiple y-values for the specified x-value,
+    /// - parameter rounding: Rounding method if exact value was not found
+    open override func entryIndex(
+        x xValue: Double,
+        closestToY yValue: Double,
+        rounding: ChartDataSetRounding) -> Int
     {
         /*guard let results = _results else { return -1 }
         
@@ -364,52 +378,95 @@ open class RealmBaseDataSet: ChartBaseDataSet
         
         var low = 0
         var high = _cache.count - 1
-        var closest = -1
+        var closest = high
         
-        while low <= high
+        while low < high
         {
-            var m = (high + low) / 2
-            let entry = _cache[m]
+            let m = (low + high) / 2
             
-            if x == entry.x
-            {
-                while m > 0 && _cache[m - 1].x == x
-                {
-                    m -= 1
-                }
-                
-                return m
-            }
+            let d1 = _cache[m].x - xValue
+            let d2 = _cache[m + 1].x - xValue
+            let ad1 = abs(d1), ad2 = abs(d2)
             
-            if x > entry.x
+            if ad2 < ad1
             {
+                // [m + 1] is closer to xValue
+                // Search in an higher place
                 low = m + 1
             }
+            else if ad1 < ad2
+            {
+                // [m] is closer to xValue
+                // Search in a lower place
+                high = m
+            }
             else
             {
-                high = m - 1
+                // We have multiple sequential x-value with same distance
+                
+                if d1 >= 0.0
+                {
+                    // Search in a lower place
+                    high = m
+                }
+                else if d1 < 0.0
+                {
+                    // Search in an higher place
+                    low = m + 1
+                }
             }
             
-            closest = m
+            closest = high
         }
         
         if closest != -1
         {
+            let closestXValue = _cache[closest].x
+            
             if rounding == .up
             {
-                let closestXIndex = _cache[closest].x
-                if closestXIndex < x && closest < _cache.count - 1
+                // If rounding up, and found x-value is lower than specified x, and we can go upper...
+                if closestXValue < xValue && closest < _cache.count - 1
                 {
-                    closest = closest + 1
+                    closest += 1
                 }
             }
             else if rounding == .down
             {
-                let closestXIndex = _cache[closest].x
-                if closestXIndex > x && closest > 0
+                // If rounding down, and found x-value is upper than specified x, and we can go lower...
+                if closestXValue > xValue && closest > 0
+                {
+                    closest -= 1
+                }
+            }
+            
+            // Search by closest to y-value
+            if !yValue.isNaN
+            {
+                while closest > 0 && _cache[closest - 1].x == closestXValue
+                {
+                    closest -= 1
+                }
+                
+                var closestYValue = _cache[closest].y
+                var closestYIndex = closest
+                
+                while true
                 {
-                    closest = closest - 1
+                    closest += 1
+                    if closest >= _cache.count { break }
+                    
+                    let value = _cache[closest]
+                    
+                    if value.x != closestXValue { break }
+                    if abs(value.y - yValue) < abs(closestYValue - yValue)
+                    {
+                        closestYValue = yValue
+                        closestYIndex = closest
+                    }
                 }
+                
+                closest = closestYIndex
             }
         }
         
