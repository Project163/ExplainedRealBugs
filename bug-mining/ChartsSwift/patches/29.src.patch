diff --git a/Charts/Charts.xcodeproj/project.pbxproj b/Charts/Charts.xcodeproj/project.pbxproj
index 64e13934..c9d54f11 100644
--- a/Charts/Charts.xcodeproj/project.pbxproj
+++ b/Charts/Charts.xcodeproj/project.pbxproj
@@ -536,7 +536,6 @@
 		5B759ED41A9F98A90039D97F /* Renderers */ = {
 			isa = PBXGroup;
 			children = (
-				5B6A54711AA5DCA8000F57C2 /* ChartAxisRendererBase.swift */,
 				5B6A54961AA66AD2000F57C2 /* BarChartRenderer.swift */,
 				55E3565A1ADC63EB00A57971 /* BubbleChartRenderer.swift */,
 				5B6A54941AA66AC0000F57C2 /* CandleStickChartRenderer.swift */,
@@ -550,6 +549,7 @@
 				5B6A54861AA669F4000F57C2 /* RadarChartRenderer.swift */,
 				5B6A546F1AA5DB34000F57C2 /* ChartRendererBase.swift */,
 				5B6A54841AA669C9000F57C2 /* ScatterChartRenderer.swift */,
+				5B6A54711AA5DCA8000F57C2 /* ChartAxisRendererBase.swift */,
 				5B6A54731AA5DEDC000F57C2 /* ChartXAxisRenderer.swift */,
 				5B6A54751AA5DEE3000F57C2 /* ChartXAxisRendererBarChart.swift */,
 				5B6A547B1AA5DF02000F57C2 /* ChartXAxisRendererHorizontalBarChart.swift */,
diff --git a/Charts/Classes/Renderers/BarChartRenderer.swift b/Charts/Classes/Renderers/BarChartRenderer.swift
index 91bbd4b4..e4ec7e50 100644
--- a/Charts/Classes/Renderers/BarChartRenderer.swift
+++ b/Charts/Classes/Renderers/BarChartRenderer.swift
@@ -32,18 +32,27 @@ public class BarChartRenderer: ChartDataRendererBase
         
         for (var i = 0; i < barData.dataSetCount; i++)
         {
-            let set = barData.getDataSetByIndex(i)
+            guard let set = barData.getDataSetByIndex(i) else { continue }
             
-            if set !== nil && set!.isVisible && set.entryCount > 0
+            if set.isVisible && set.entryCount > 0
             {
+                if !(set is IBarChartDataSet)
+                {
+                    fatalError("Datasets for BarChartRenderer must conform to IBarChartDataset")
+                }
+                
                 drawDataSet(context: context, dataSet: set as! IBarChartDataSet, index: i)
             }
         }
     }
     
-    internal func drawDataSet(context context: CGContext, dataSet: IBarChartDataSet, index: Int)
+    public func drawDataSet(context context: CGContext, dataSet: IBarChartDataSet, index: Int)
     {
-        guard let dataProvider = dataProvider, barData = dataProvider.barData else { return }
+        guard let
+            dataProvider = dataProvider,
+            barData = dataProvider.barData,
+            animator = animator
+            else { return }
         
         CGContextSaveGState(context)
         
@@ -58,13 +67,13 @@ public class BarChartRenderer: ChartDataRendererBase
         let containsStacks = dataSet.isStacked
         let isInverted = dataProvider.isInverted(dataSet.axisDependency)
         let barWidth: CGFloat = 0.5
-        let phaseY = _animator.phaseY
+        let phaseY = animator.phaseY
         var barRect = CGRect()
         var barShadow = CGRect()
         var y: Double
         
         // do the drawing
-        for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * _animator.phaseX)); j < count; j++)
+        for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * animator.phaseX)); j < count; j++)
         {
             guard let e = dataSet.entryForIndex(j) as? BarChartDataEntry else { continue }
             
@@ -233,7 +242,7 @@ public class BarChartRenderer: ChartDataRendererBase
     }
     
     /// Prepares a bar for being highlighted.
-    internal func prepareBarHighlight(x x: CGFloat, y1: Double, y2: Double, barspacehalf: CGFloat, trans: ChartTransformer, inout rect: CGRect)
+    public func prepareBarHighlight(x x: CGFloat, y1: Double, y2: Double, barspacehalf: CGFloat, trans: ChartTransformer, inout rect: CGRect)
     {
         let barWidth: CGFloat = 0.5
         
@@ -247,7 +256,7 @@ public class BarChartRenderer: ChartDataRendererBase
         rect.size.width = right - left
         rect.size.height = bottom - top
         
-        trans.rectValueToPixel(&rect, phaseY: _animator.phaseY)
+        trans.rectValueToPixel(&rect, phaseY: animator?.phaseY ?? 1.0)
     }
     
     public override func drawValues(context context: CGContext)
@@ -255,7 +264,11 @@ public class BarChartRenderer: ChartDataRendererBase
         // if values are drawn
         if (passesCheck())
         {
-            guard let dataProvider = dataProvider, barData = dataProvider.barData else { return }
+            guard let
+                dataProvider = dataProvider,
+                barData = dataProvider.barData,
+                animator = animator
+                else { return }
             
             var dataSets = barData.dataSets
             
@@ -266,7 +279,7 @@ public class BarChartRenderer: ChartDataRendererBase
             
             for (var dataSetIndex = 0, count = barData.dataSetCount; dataSetIndex < count; dataSetIndex++)
             {
-                let dataSet = dataSets[dataSetIndex] as! IBarChartDataSet
+                guard let dataSet = dataSets[dataSetIndex] as? IBarChartDataSet else { continue }
                 
                 if !dataSet.isDrawValuesEnabled || dataSet.entryCount == 0
                 {
@@ -290,22 +303,29 @@ public class BarChartRenderer: ChartDataRendererBase
                 
                 let valueTextColor = dataSet.valueTextColor
                 
-                let formatter = dataSet.valueFormatter
+                guard let formatter = dataSet.valueFormatter else { continue }
                 
                 let trans = dataProvider.getTransformer(dataSet.axisDependency)
                 
-                let phaseY = _animator.phaseY
+                let phaseY = animator.phaseY
                 let dataSetCount = barData.dataSetCount
                 let groupSpace = barData.groupSpace
                 
                 // if only single values are drawn (sum)
                 if (!dataSet.isStacked)
                 {
-                    for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * _animator.phaseX)); j < count; j++)
+                    for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * animator.phaseX)); j < count; j++)
                     {
                         guard let e = dataSet.entryForIndex(j) as? BarChartDataEntry else { continue }
                         
-                        let valuePoint = trans.getTransformedValueBarChart(entry: e, xIndex: e.xIndex, dataSetIndex: dataSetIndex, phaseY: phaseY, dataSetCount: dataSetCount, groupSpace: groupSpace)
+                        let valuePoint = trans.getTransformedValueBarChart(
+                            entry: e,
+                            xIndex: e.xIndex,
+                            dataSetIndex: dataSetIndex,
+                            phaseY: phaseY,
+                            dataSetCount: dataSetCount,
+                            groupSpace: groupSpace
+                        )
                         
                         if (!viewPortHandler.isInBoundsRight(valuePoint.x))
                         {
@@ -321,7 +341,7 @@ public class BarChartRenderer: ChartDataRendererBase
                         let val = e.value
                     
                         drawValue(context: context,
-                            value: formatter!.stringFromNumber(val)!,
+                            value: formatter.stringFromNumber(val)!,
                             xPos: valuePoint.x,
                             yPos: valuePoint.y + (val >= 0.0 ? posOffset : negOffset),
                             font: valueFont,
@@ -333,7 +353,7 @@ public class BarChartRenderer: ChartDataRendererBase
                 {
                     // if we have stacks
                     
-                    for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * _animator.phaseX)); j < count; j++)
+                    for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * animator.phaseX)); j < count; j++)
                     {
                         guard let e = dataSet.entryForIndex(j) as? BarChartDataEntry else { continue }
                         
@@ -356,7 +376,7 @@ public class BarChartRenderer: ChartDataRendererBase
                             }
                             
                             drawValue(context: context,
-                                value: formatter!.stringFromNumber(e.value)!,
+                                value: formatter.stringFromNumber(e.value)!,
                                 xPos: valuePoint.x,
                                 yPos: valuePoint.y + (e.value >= 0.0 ? posOffset : negOffset),
                                 font: valueFont,
@@ -389,7 +409,7 @@ public class BarChartRenderer: ChartDataRendererBase
                                     negY -= value
                                 }
                                 
-                                transformed.append(CGPoint(x: 0.0, y: CGFloat(y) * _animator.phaseY))
+                                transformed.append(CGPoint(x: 0.0, y: CGFloat(y) * animator.phaseY))
                             }
                             
                             trans.pointValuesToPixel(&transformed)
@@ -410,7 +430,7 @@ public class BarChartRenderer: ChartDataRendererBase
                                 }
                                 
                                 drawValue(context: context,
-                                    value: formatter!.stringFromNumber(vals[k])!,
+                                    value: formatter.stringFromNumber(vals[k])!,
                                     xPos: x,
                                     yPos: y,
                                     font: valueFont,
@@ -425,7 +445,7 @@ public class BarChartRenderer: ChartDataRendererBase
     }
     
     /// Draws a value at the specified x and y position.
-    internal func drawValue(context context: CGContext, value: String, xPos: CGFloat, yPos: CGFloat, font: UIFont, align: NSTextAlignment, color: UIColor)
+    public func drawValue(context context: CGContext, value: String, xPos: CGFloat, yPos: CGFloat, font: UIFont, align: NSTextAlignment, color: UIColor)
     {
         ChartUtils.drawText(context: context, text: value, point: CGPoint(x: xPos, y: yPos), align: align, attributes: [NSFontAttributeName: font, NSForegroundColorAttributeName: color])
     }
@@ -439,7 +459,11 @@ public class BarChartRenderer: ChartDataRendererBase
     
     public override func drawHighlighted(context context: CGContext, indices: [ChartHighlight])
     {
-        guard let dataProvider = dataProvider, barData = dataProvider.barData else { return }
+        guard let
+            dataProvider = dataProvider,
+            barData = dataProvider.barData,
+            animator = animator
+            else { return }
         
         CGContextSaveGState(context)
         
@@ -453,9 +477,10 @@ public class BarChartRenderer: ChartDataRendererBase
             let index = h.xIndex
             
             let dataSetIndex = h.dataSetIndex
-            let set = barData.getDataSetByIndex(dataSetIndex) as! IBarChartDataSet!
             
-            if (set === nil || !set.isHighlightEnabled)
+            guard let set = barData.getDataSetByIndex(dataSetIndex) as? IBarChartDataSet else { continue }
+            
+            if (!set.isHighlightEnabled)
             {
                 continue
             }
@@ -468,7 +493,7 @@ public class BarChartRenderer: ChartDataRendererBase
             CGContextSetAlpha(context, set.highlightAlpha)
             
             // check outofbounds
-            if (CGFloat(index) < (CGFloat(dataProvider.chartXMax) * _animator.phaseX) / CGFloat(setCount))
+            if (CGFloat(index) < (CGFloat(dataProvider.chartXMax) * animator.phaseX) / CGFloat(setCount))
             {
                 let e = set.entryForXIndex(index) as! BarChartDataEntry!
                 
@@ -506,7 +531,7 @@ public class BarChartRenderer: ChartDataRendererBase
                     CGContextSetAlpha(context, 1.0)
                     
                     // distance between highlight arrow and bar
-                    let offsetY = _animator.phaseY * 0.07
+                    let offsetY = animator.phaseY * 0.07
                     
                     CGContextSaveGState(context)
                     
@@ -516,7 +541,7 @@ public class BarChartRenderer: ChartDataRendererBase
                     let arrowWidth = set.barSpace / 2.0
                     let arrowHeight = arrowWidth * xToYRel
                     
-                    let yArrow = (y1 > -y2 ? y1 : y1) * Double(_animator.phaseY)
+                    let yArrow = (y1 > -y2 ? y1 : y1) * Double(animator.phaseY)
                     
                     _highlightArrowPtsBuffer[0].x = CGFloat(x) + 0.4
                     _highlightArrowPtsBuffer[0].y = CGFloat(yArrow) + offsetY
diff --git a/Charts/Classes/Renderers/BubbleChartRenderer.swift b/Charts/Classes/Renderers/BubbleChartRenderer.swift
index cf5a5b3a..37293b8e 100644
--- a/Charts/Classes/Renderers/BubbleChartRenderer.swift
+++ b/Charts/Classes/Renderers/BubbleChartRenderer.swift
@@ -47,14 +47,17 @@ public class BubbleChartRenderer: ChartDataRendererBase
     private var _pointBuffer = CGPoint()
     private var _sizeBuffer = [CGPoint](count: 2, repeatedValue: CGPoint())
     
-    internal func drawDataSet(context context: CGContext, dataSet: IBubbleChartDataSet)
+    public func drawDataSet(context context: CGContext, dataSet: IBubbleChartDataSet)
     {
-        guard let dataProvider = dataProvider else { return }
+        guard let
+            dataProvider = dataProvider,
+            animator = animator
+            else { return }
         
         let trans = dataProvider.getTransformer(dataSet.axisDependency)
         
-        let phaseX = _animator.phaseX
-        let phaseY = _animator.phaseY
+        let phaseX = animator.phaseX
+        let phaseY = animator.phaseY
         
         let entryCount = dataSet.entryCount
         
@@ -62,11 +65,13 @@ public class BubbleChartRenderer: ChartDataRendererBase
         
         CGContextSaveGState(context)
         
-        let entryFrom = dataSet.entryForXIndex(_minX)
-        let entryTo = dataSet.entryForXIndex(_maxX)
+        guard let
+            entryFrom = dataSet.entryForXIndex(self.minX),
+            entryTo = dataSet.entryForXIndex(self.maxX)
+            else { return }
         
-        let minx = max(dataSet.entryIndex(entry: entryFrom!), 0)
-        let maxx = min(dataSet.entryIndex(entry: entryTo!) + 1, entryCount)
+        let minx = max(dataSet.entryIndex(entry: entryFrom), 0)
+        let maxx = min(dataSet.entryIndex(entry: entryTo) + 1, entryCount)
         
         _sizeBuffer[0].x = 0.0
         _sizeBuffer[0].y = 0.0
@@ -125,15 +130,19 @@ public class BubbleChartRenderer: ChartDataRendererBase
     
     public override func drawValues(context context: CGContext)
     {
-        guard let dataProvider = dataProvider, bubbleData = dataProvider.bubbleData else { return }
+        guard let
+            dataProvider = dataProvider,
+            bubbleData = dataProvider.bubbleData,
+            animator = animator
+            else { return }
         
         // if values are drawn
         if (bubbleData.yValCount < Int(ceil(CGFloat(dataProvider.maxVisibleValueCount) * viewPortHandler.scaleX)))
         {
-            let dataSets = bubbleData.dataSets as! [IBubbleChartDataSet]
+            guard let dataSets = bubbleData.dataSets as? [IBubbleChartDataSet] else { return }
             
-            let phaseX = _animator.phaseX
-            let phaseY = _animator.phaseY
+            let phaseX = animator.phaseX
+            let phaseY = animator.phaseY
             
             var pt = CGPoint()
             
@@ -147,18 +156,20 @@ public class BubbleChartRenderer: ChartDataRendererBase
                 let alpha = phaseX == 1 ? phaseY : phaseX
                 let valueTextColor = dataSet.valueTextColor.colorWithAlphaComponent(alpha)
                 
-                let formatter = dataSet.valueFormatter
+                guard let formatter = dataSet.valueFormatter else { continue }
                 
                 let trans = dataProvider.getTransformer(dataSet.axisDependency)
                 let valueToPixelMatrix = trans.valueToPixelMatrix
                 
                 let entryCount = dataSet.entryCount
                 
-                let entryFrom = dataSet.entryForXIndex(_minX)
-                let entryTo = dataSet.entryForXIndex(_maxX)
+                guard let
+                    entryFrom = dataSet.entryForXIndex(self.minX),
+                    entryTo = dataSet.entryForXIndex(self.maxX)
+                    else { continue }
                 
-                let minx = max(dataSet.entryIndex(entry: entryFrom!), 0)
-                let maxx = min(dataSet.entryIndex(entry: entryTo!) + 1, entryCount)
+                let minx = max(dataSet.entryIndex(entry: entryFrom), 0)
+                let maxx = min(dataSet.entryIndex(entry: entryTo) + 1, entryCount)
                 
                 for (var j = minx; j < maxx; j++)
                 {
@@ -178,7 +189,7 @@ public class BubbleChartRenderer: ChartDataRendererBase
                         continue
                     }
                     
-                    let text = formatter!.stringFromNumber(e.size)
+                    let text = formatter.stringFromNumber(e.size)
                     
                     // Larger font for larger bubbles?
                     let valueFont = dataSet.valueFont
@@ -204,24 +215,28 @@ public class BubbleChartRenderer: ChartDataRendererBase
     
     public override func drawHighlighted(context context: CGContext, indices: [ChartHighlight])
     {
-        guard let dataProvider = dataProvider, bubbleData = dataProvider.bubbleData else { return }
+        guard let
+            dataProvider = dataProvider,
+            bubbleData = dataProvider.bubbleData,
+            animator = animator
+            else { return }
         
         CGContextSaveGState(context)
         
-        let phaseX = _animator.phaseX
-        let phaseY = _animator.phaseY
+        let phaseX = animator.phaseX
+        let phaseY = animator.phaseY
         
         for indice in indices
         {
-            let dataSet = bubbleData.getDataSetByIndex(indice.dataSetIndex) as! IBubbleChartDataSet!
+            guard let dataSet = bubbleData.getDataSetByIndex(indice.dataSetIndex) as? IBubbleChartDataSet else { continue }
             
-            if (dataSet === nil || !dataSet.isHighlightEnabled)
+            if (!dataSet.isHighlightEnabled)
             {
                 continue
             }
             
-            let entryFrom = dataSet.entryForXIndex(_minX)
-            let entryTo = dataSet.entryForXIndex(_maxX)
+            let entryFrom = dataSet.entryForXIndex(self.minX)
+            let entryTo = dataSet.entryForXIndex(self.maxX)
             
             let minx = max(dataSet.entryIndex(entry: entryFrom!), 0)
             let maxx = min(dataSet.entryIndex(entry: entryTo!) + 1, dataSet.entryCount)
diff --git a/Charts/Classes/Renderers/CandleStickChartRenderer.swift b/Charts/Classes/Renderers/CandleStickChartRenderer.swift
index f7f349d7..83b588fe 100644
--- a/Charts/Classes/Renderers/CandleStickChartRenderer.swift
+++ b/Charts/Classes/Renderers/CandleStickChartRenderer.swift
@@ -43,18 +43,21 @@ public class CandleStickChartRenderer: LineScatterCandleRadarChartRenderer
     private var _bodyRect = CGRect()
     private var _lineSegments = [CGPoint](count: 2, repeatedValue: CGPoint())
     
-    internal func drawDataSet(context context: CGContext, dataSet: ICandleChartDataSet)
+    public func drawDataSet(context context: CGContext, dataSet: ICandleChartDataSet)
     {
-        guard let trans = dataProvider?.getTransformer(dataSet.axisDependency) else { return }
+        guard let
+            trans = dataProvider?.getTransformer(dataSet.axisDependency),
+            animator = animator
+            else { return }
         
-        let phaseX = _animator.phaseX
-        let phaseY = _animator.phaseY
+        let phaseX = animator.phaseX
+        let phaseY = animator.phaseY
         let bodySpace = dataSet.bodySpace
         
         let entryCount = dataSet.entryCount
         
-        let minx = max(_minX, 0)
-        let maxx = min(_maxX + 1, entryCount)
+        let minx = max(self.minX, 0)
+        let maxx = min(self.maxX + 1, entryCount)
         
         CGContextSaveGState(context)
         
@@ -65,7 +68,7 @@ public class CandleStickChartRenderer: LineScatterCandleRadarChartRenderer
             // get the entry
             guard let e = dataSet.entryForIndex(j) as? CandleChartDataEntry else { continue }
             
-            if (e.xIndex < _minX || e.xIndex > _maxX)
+            if (e.xIndex < minx || e.xIndex >= maxx)
             {
                 continue
             }
@@ -155,15 +158,19 @@ public class CandleStickChartRenderer: LineScatterCandleRadarChartRenderer
     
     public override func drawValues(context context: CGContext)
     {
-        guard let dataProvider = dataProvider, candleData = dataProvider.candleData else { return }
+        guard let
+            dataProvider = dataProvider,
+            candleData = dataProvider.candleData,
+            animator = animator
+            else { return }
         
         // if values are drawn
         if (candleData.yValCount < Int(ceil(CGFloat(dataProvider.maxVisibleValueCount) * viewPortHandler.scaleX)))
         {
             var dataSets = candleData.dataSets
             
-            let phaseX = _animator.phaseX
-            let phaseY = _animator.phaseY
+            let phaseX = animator.phaseX
+            let phaseY = animator.phaseY
             
             var pt = CGPoint()
             
@@ -179,15 +186,15 @@ public class CandleStickChartRenderer: LineScatterCandleRadarChartRenderer
                 let valueFont = dataSet.valueFont
                 let valueTextColor = dataSet.valueTextColor
                 
-                let formatter = dataSet.valueFormatter
+                guard let formatter = dataSet.valueFormatter else { continue }
                 
                 let trans = dataProvider.getTransformer(dataSet.axisDependency)
                 let valueToPixelMatrix = trans.valueToPixelMatrix
                 
                 let entryCount = dataSet.entryCount
                 
-                let minx = max(_minX, 0)
-                let maxx = min(_maxX + 1, entryCount)
+                let minx = max(self.minX, 0)
+                let maxx = min(self.maxX + 1, entryCount)
                 
                 let lineHeight = valueFont.lineHeight
                 let yOffset: CGFloat = lineHeight + 5.0
@@ -212,7 +219,7 @@ public class CandleStickChartRenderer: LineScatterCandleRadarChartRenderer
                     
                     ChartUtils.drawText(
                         context: context,
-                        text: formatter!.stringFromNumber(e.high)!,
+                        text: formatter.stringFromNumber(e.high)!,
                         point: CGPoint(
                             x: pt.x,
                             y: pt.y - yOffset),
@@ -231,7 +238,11 @@ public class CandleStickChartRenderer: LineScatterCandleRadarChartRenderer
     
     public override func drawHighlighted(context context: CGContext, indices: [ChartHighlight])
     {
-        guard let dataProvider = dataProvider, candleData = dataProvider.candleData else { return }
+        guard let
+            dataProvider = dataProvider,
+            candleData = dataProvider.candleData,
+            animator = animator
+            else { return }
         
         CGContextSaveGState(context)
         
@@ -239,16 +250,16 @@ public class CandleStickChartRenderer: LineScatterCandleRadarChartRenderer
         {
             let xIndex = indices[i].xIndex; // get the x-position
             
-            let set = candleData.getDataSetByIndex(indices[i].dataSetIndex) as! ICandleChartDataSet!
+            guard let set = candleData.getDataSetByIndex(indices[i].dataSetIndex) as? ICandleChartDataSet else { continue }
             
-            if (set === nil || !set.isHighlightEnabled)
+            if (!set.isHighlightEnabled)
             {
                 continue
             }
             
-            let e = set.entryForXIndex(xIndex) as! CandleChartDataEntry!
+            guard let e = set.entryForXIndex(xIndex) as? CandleChartDataEntry else { continue }
             
-            if (e === nil || e.xIndex != xIndex)
+            if e.xIndex != xIndex
             {
                 continue
             }
@@ -266,8 +277,8 @@ public class CandleStickChartRenderer: LineScatterCandleRadarChartRenderer
                 CGContextSetLineDash(context, 0.0, nil, 0)
             }
             
-            let low = CGFloat(e.low) * _animator.phaseY
-            let high = CGFloat(e.high) * _animator.phaseY
+            let low = CGFloat(e.low) * animator.phaseY
+            let high = CGFloat(e.high) * animator.phaseY
             let y = (low + high) / 2.0
             
             _highlightPointBuffer.x = CGFloat(xIndex)
diff --git a/Charts/Classes/Renderers/ChartDataRendererBase.swift b/Charts/Classes/Renderers/ChartDataRendererBase.swift
index f2b432af..86f79458 100644
--- a/Charts/Classes/Renderers/ChartDataRendererBase.swift
+++ b/Charts/Classes/Renderers/ChartDataRendererBase.swift
@@ -16,12 +16,13 @@ import CoreGraphics
 
 public class ChartDataRendererBase: ChartRendererBase
 {
-    internal var _animator: ChartAnimator!
+    public var animator: ChartAnimator?
     
     public init(animator: ChartAnimator?, viewPortHandler: ChartViewPortHandler)
     {
         super.init(viewPortHandler: viewPortHandler)
-        _animator = animator
+        
+        self.animator = animator
     }
 
     public func drawData(context context: CGContext)
diff --git a/Charts/Classes/Renderers/ChartLegendRenderer.swift b/Charts/Classes/Renderers/ChartLegendRenderer.swift
index 4e9c09e6..87b60262 100755
--- a/Charts/Classes/Renderers/ChartLegendRenderer.swift
+++ b/Charts/Classes/Renderers/ChartLegendRenderer.swift
@@ -18,18 +18,21 @@ import UIKit
 public class ChartLegendRenderer: ChartRendererBase
 {
     /// the legend object this renderer renders
-    internal var _legend: ChartLegend!
+    public var legend: ChartLegend?
 
     public init(viewPortHandler: ChartViewPortHandler, legend: ChartLegend?)
     {
         super.init(viewPortHandler: viewPortHandler)
-        _legend = legend
+        
+        self.legend = legend
     }
 
     /// Prepares the legend and calculates all needed forms, labels and colors.
     public func computeLegend(data: ChartData)
     {
-        if (!_legend.isLegendCustom)
+        guard let legend = legend else { return }
+        
+        if (!legend.isLegendCustom)
         {
             var labels = [String?]()
             var colors = [UIColor?]()
@@ -107,41 +110,43 @@ public class ChartLegendRenderer: ChartRendererBase
                 }
             }
             
-            _legend.colors = colors + _legend._extraColors
-            _legend.labels = labels + _legend._extraLabels
+            legend.colors = colors + legend._extraColors
+            legend.labels = labels + legend._extraLabels
         }
         
         // calculate all dimensions of the legend
-        _legend.calculateDimensions(labelFont: _legend.font, viewPortHandler: viewPortHandler)
+        legend.calculateDimensions(labelFont: legend.font, viewPortHandler: viewPortHandler)
     }
     
     public func renderLegend(context context: CGContext)
     {
-        if (_legend === nil || !_legend.enabled)
+        guard let legend = legend else { return }
+        
+        if !legend.enabled
         {
             return
         }
         
-        let labelFont = _legend.font
-        let labelTextColor = _legend.textColor
+        let labelFont = legend.font
+        let labelTextColor = legend.textColor
         let labelLineHeight = labelFont.lineHeight
         let formYOffset = labelLineHeight / 2.0
 
-        var labels = _legend.labels
-        var colors = _legend.colors
+        var labels = legend.labels
+        var colors = legend.colors
         
-        let formSize = _legend.formSize
-        let formToTextSpace = _legend.formToTextSpace
-        let xEntrySpace = _legend.xEntrySpace
-        let direction = _legend.direction
+        let formSize = legend.formSize
+        let formToTextSpace = legend.formToTextSpace
+        let xEntrySpace = legend.xEntrySpace
+        let direction = legend.direction
 
         // space between the entries
-        let stackSpace = _legend.stackSpace
+        let stackSpace = legend.stackSpace
 
-        let yoffset = _legend.yOffset
-        let xoffset = _legend.xOffset
+        let yoffset = legend.yOffset
+        let xoffset = legend.xOffset
         
-        let legendPosition = _legend.position
+        let legendPosition = legend.position
         
         switch (legendPosition)
         {
@@ -163,7 +168,7 @@ public class ChartLegendRenderer: ChartRendererBase
                 
                 if (direction == .RightToLeft)
                 {
-                    originPosX += _legend.neededWidth
+                    originPosX += legend.neededWidth
                 }
             }
             else if (legendPosition == .BelowChartRight || legendPosition == .AboveChartRight)
@@ -172,7 +177,7 @@ public class ChartLegendRenderer: ChartRendererBase
                 
                 if (direction == .LeftToRight)
                 {
-                    originPosX -= _legend.neededWidth
+                    originPosX -= legend.neededWidth
                 }
             }
             else // .BelowChartCenter || .AboveChartCenter
@@ -180,9 +185,9 @@ public class ChartLegendRenderer: ChartRendererBase
                 originPosX = viewPortHandler.contentLeft + contentWidth / 2.0
             }
             
-            var calculatedLineSizes = _legend.calculatedLineSizes
-            var calculatedLabelSizes = _legend.calculatedLabelSizes
-            var calculatedLabelBreakPoints = _legend.calculatedLabelBreakPoints
+            var calculatedLineSizes = legend.calculatedLineSizes
+            var calculatedLabelSizes = legend.calculatedLabelSizes
+            var calculatedLabelBreakPoints = legend.calculatedLabelBreakPoints
             
             var posX: CGFloat = originPosX
             var posY: CGFloat
@@ -195,7 +200,7 @@ public class ChartLegendRenderer: ChartRendererBase
             }
             else
             {
-                posY = viewPortHandler.chartHeight - yoffset - _legend.neededHeight
+                posY = viewPortHandler.chartHeight - yoffset - legend.neededHeight
             }
             
             var lineIndex: Int = 0
@@ -216,7 +221,7 @@ public class ChartLegendRenderer: ChartRendererBase
                 }
                 
                 let drawingForm = colors[i] != nil
-                let isStacked = labels[i] == nil; // grouped forms have null labels
+                let isStacked = labels[i] == nil // grouped forms have null labels
                 
                 if (drawingForm)
                 {
@@ -225,7 +230,7 @@ public class ChartLegendRenderer: ChartRendererBase
                         posX -= formSize
                     }
                     
-                    drawForm(context: context, x: posX, y: posY + formYOffset, colorIndex: i, legend: _legend)
+                    drawForm(context: context, x: posX, y: posY + formYOffset, colorIndex: i, legend: legend)
                     
                     if (direction == .LeftToRight)
                     {
@@ -276,8 +281,8 @@ public class ChartLegendRenderer: ChartRendererBase
             
             if (legendPosition == .PiechartCenter)
             {
-                posX = viewPortHandler.chartWidth / 2.0 + (direction == .LeftToRight ? -_legend.textWidthMax / 2.0 : _legend.textWidthMax / 2.0)
-                posY = viewPortHandler.chartHeight / 2.0 - _legend.neededHeight / 2.0 + _legend.yOffset
+                posX = viewPortHandler.chartWidth / 2.0 + (direction == .LeftToRight ? -legend.textWidthMax / 2.0 : legend.textWidthMax / 2.0)
+                posY = viewPortHandler.chartHeight / 2.0 - legend.neededHeight / 2.0 + legend.yOffset
             }
             else
             {
@@ -290,7 +295,7 @@ public class ChartLegendRenderer: ChartRendererBase
                     posX = viewPortHandler.chartWidth - xoffset
                     if (direction == .LeftToRight)
                     {
-                        posX -= _legend.textWidthMax
+                        posX -= legend.textWidthMax
                     }
                 }
                 else
@@ -298,7 +303,7 @@ public class ChartLegendRenderer: ChartRendererBase
                     posX = xoffset
                     if (direction == .RightToLeft)
                     {
-                        posX += _legend.textWidthMax
+                        posX += legend.textWidthMax
                     }
                 }
                 
@@ -307,7 +312,7 @@ public class ChartLegendRenderer: ChartRendererBase
                 case .RightOfChart, .LeftOfChart:
                     posY = viewPortHandler.contentTop + yoffset
                 case .RightOfChartCenter, .LeftOfChartCenter:
-                    posY = viewPortHandler.chartHeight / 2.0 - _legend.neededHeight / 2.0
+                    posY = viewPortHandler.chartHeight / 2.0 - legend.neededHeight / 2.0
                 default: // case .RightOfChartInside, .LeftOfChartInside
                     posY = viewPortHandler.contentTop + yoffset
                 }
@@ -329,7 +334,7 @@ public class ChartLegendRenderer: ChartRendererBase
                         x -= formSize - stack
                     }
                     
-                    drawForm(context: context, x: x, y: posY + formYOffset, colorIndex: i, legend: _legend)
+                    drawForm(context: context, x: x, y: posY + formYOffset, colorIndex: i, legend: legend)
                     
                     if (direction == .LeftToRight)
                     {
@@ -380,7 +385,7 @@ public class ChartLegendRenderer: ChartRendererBase
     private var _formLineSegmentsBuffer = [CGPoint](count: 2, repeatedValue: CGPoint())
     
     /// Draws the Legend-form at the given position with the color at the given index.
-    internal func drawForm(context context: CGContext, x: CGFloat, y: CGFloat, colorIndex: Int, legend: ChartLegend)
+    public func drawForm(context context: CGContext, x: CGFloat, y: CGFloat, colorIndex: Int, legend: ChartLegend)
     {
         guard let formColor = legend.colors[colorIndex] where formColor != UIColor.clearColor() else {
             return
@@ -413,7 +418,7 @@ public class ChartLegendRenderer: ChartRendererBase
     }
 
     /// Draws the provided label at the given position.
-    internal func drawLabel(context context: CGContext, x: CGFloat, y: CGFloat, label: String, font: UIFont, textColor: UIColor)
+    public func drawLabel(context context: CGContext, x: CGFloat, y: CGFloat, label: String, font: UIFont, textColor: UIColor)
     {
         ChartUtils.drawText(context: context, text: label, point: CGPoint(x: x, y: y), align: .Left, attributes: [NSFontAttributeName: font, NSForegroundColorAttributeName: textColor])
     }
diff --git a/Charts/Classes/Renderers/ChartRendererBase.swift b/Charts/Classes/Renderers/ChartRendererBase.swift
index a4369450..ca3940a4 100644
--- a/Charts/Classes/Renderers/ChartRendererBase.swift
+++ b/Charts/Classes/Renderers/ChartRendererBase.swift
@@ -20,10 +20,10 @@ public class ChartRendererBase: NSObject
     public var viewPortHandler: ChartViewPortHandler!
     
     /// the minimum value on the x-axis that should be plotted
-    internal var _minX: Int = 0
+    public var minX: Int = 0
     
     /// the maximum value on the x-axis that should be plotted
-    internal var _maxX: Int = 0
+    public var maxX: Int = 0
     
     public override init()
     {
@@ -35,19 +35,6 @@ public class ChartRendererBase: NSObject
         super.init()
         self.viewPortHandler = viewPortHandler
     }
-
-    /// - returns: true if the specified value fits in between the provided min and max bounds, false if not.
-    internal func fitsBounds(val: Double, min: Double, max: Double) -> Bool
-    {
-        if (val < min || val > max)
-        {
-            return false
-        }
-        else
-        {
-            return true
-        }
-    }
     
     /// Calculates the minimum and maximum x-value the chart can currently display (with the given zoom level).
     public func calcXBounds(chart chart: BarLineChartViewBase, xAxisModulus: Int)
@@ -57,8 +44,8 @@ public class ChartRendererBase: NSObject
         
         let subLow = (low % xAxisModulus == 0) ? xAxisModulus : 0
         
-        _minX = max((low / xAxisModulus) * (xAxisModulus) - subLow, 0)
-        _maxX = min((high / xAxisModulus) * (xAxisModulus) + xAxisModulus, Int(chart.chartXMax))
+        minX = max((low / xAxisModulus) * (xAxisModulus) - subLow, 0)
+        maxX = min((high / xAxisModulus) * (xAxisModulus) + xAxisModulus, Int(chart.chartXMax))
     }
 }
         
\ No newline at end of file
diff --git a/Charts/Classes/Renderers/ChartXAxisRenderer.swift b/Charts/Classes/Renderers/ChartXAxisRenderer.swift
index 4811855e..20d63d53 100644
--- a/Charts/Classes/Renderers/ChartXAxisRenderer.swift
+++ b/Charts/Classes/Renderers/ChartXAxisRenderer.swift
@@ -17,20 +17,22 @@ import UIKit
 
 public class ChartXAxisRenderer: ChartAxisRendererBase
 {
-    internal var _xAxis: ChartXAxis!
+    public var xAxis: ChartXAxis?
   
     public init(viewPortHandler: ChartViewPortHandler, xAxis: ChartXAxis, transformer: ChartTransformer!)
     {
         super.init(viewPortHandler: viewPortHandler, transformer: transformer)
         
-        _xAxis = xAxis
+        self.xAxis = xAxis
     }
     
     public func computeAxis(xValAverageLength xValAverageLength: Double, xValues: [String?])
     {
+        guard let xAxis = xAxis else { return }
+        
         var a = ""
         
-        let max = Int(round(xValAverageLength + Double(_xAxis.spaceBetweenLabels)))
+        let max = Int(round(xValAverageLength + Double(xAxis.spaceBetweenLabels)))
         
         for (var i = 0; i < max; i++)
         {
@@ -39,45 +41,47 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
         
         let widthText = a as NSString
         
-        let labelSize = widthText.sizeWithAttributes([NSFontAttributeName: _xAxis.labelFont])
+        let labelSize = widthText.sizeWithAttributes([NSFontAttributeName: xAxis.labelFont])
         
         let labelWidth = labelSize.width
         let labelHeight = labelSize.height
         
-        let labelRotatedSize = ChartUtils.sizeOfRotatedRectangle(labelSize, degrees: _xAxis.labelRotationAngle)
+        let labelRotatedSize = ChartUtils.sizeOfRotatedRectangle(labelSize, degrees: xAxis.labelRotationAngle)
         
-        _xAxis.labelWidth = labelWidth
-        _xAxis.labelHeight = labelHeight
-        _xAxis.labelRotatedWidth = labelRotatedSize.width
-        _xAxis.labelRotatedHeight = labelRotatedSize.height
+        xAxis.labelWidth = labelWidth
+        xAxis.labelHeight = labelHeight
+        xAxis.labelRotatedWidth = labelRotatedSize.width
+        xAxis.labelRotatedHeight = labelRotatedSize.height
         
-        _xAxis.values = xValues
+        xAxis.values = xValues
     }
     
     public override func renderAxisLabels(context context: CGContext)
     {
-        if (!_xAxis.isEnabled || !_xAxis.isDrawLabelsEnabled)
+        guard let xAxis = xAxis else { return }
+        
+        if (!xAxis.isEnabled || !xAxis.isDrawLabelsEnabled)
         {
             return
         }
         
-        let yOffset = _xAxis.yOffset
+        let yOffset = xAxis.yOffset
         
-        if (_xAxis.labelPosition == .Top)
+        if (xAxis.labelPosition == .Top)
         {
             drawLabels(context: context, pos: viewPortHandler.contentTop - yOffset, anchor: CGPoint(x: 0.5, y: 1.0))
         }
-        else if (_xAxis.labelPosition == .TopInside)
+        else if (xAxis.labelPosition == .TopInside)
         {
-            drawLabels(context: context, pos: viewPortHandler.contentTop + yOffset + _xAxis.labelRotatedHeight, anchor: CGPoint(x: 0.5, y: 1.0))
+            drawLabels(context: context, pos: viewPortHandler.contentTop + yOffset + xAxis.labelRotatedHeight, anchor: CGPoint(x: 0.5, y: 1.0))
         }
-        else if (_xAxis.labelPosition == .Bottom)
+        else if (xAxis.labelPosition == .Bottom)
         {
             drawLabels(context: context, pos: viewPortHandler.contentBottom + yOffset, anchor: CGPoint(x: 0.5, y: 0.0))
         }
-        else if (_xAxis.labelPosition == .BottomInside)
+        else if (xAxis.labelPosition == .BottomInside)
         {
-            drawLabels(context: context, pos: viewPortHandler.contentBottom - yOffset - _xAxis.labelRotatedHeight, anchor: CGPoint(x: 0.5, y: 0.0))
+            drawLabels(context: context, pos: viewPortHandler.contentBottom - yOffset - xAxis.labelRotatedHeight, anchor: CGPoint(x: 0.5, y: 0.0))
         }
         else
         { // BOTH SIDED
@@ -90,27 +94,29 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
     
     public override func renderAxisLine(context context: CGContext)
     {
-        if (!_xAxis.isEnabled || !_xAxis.isDrawAxisLineEnabled)
+        guard let xAxis = xAxis else { return }
+        
+        if (!xAxis.isEnabled || !xAxis.isDrawAxisLineEnabled)
         {
             return
         }
         
         CGContextSaveGState(context)
         
-        CGContextSetStrokeColorWithColor(context, _xAxis.axisLineColor.CGColor)
-        CGContextSetLineWidth(context, _xAxis.axisLineWidth)
-        if (_xAxis.axisLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, xAxis.axisLineColor.CGColor)
+        CGContextSetLineWidth(context, xAxis.axisLineWidth)
+        if (xAxis.axisLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _xAxis.axisLineDashPhase, _xAxis.axisLineDashLengths, _xAxis.axisLineDashLengths.count)
+            CGContextSetLineDash(context, xAxis.axisLineDashPhase, xAxis.axisLineDashLengths, xAxis.axisLineDashLengths.count)
         }
         else
         {
             CGContextSetLineDash(context, 0.0, nil, 0)
         }
 
-        if (_xAxis.labelPosition == .Top
-                || _xAxis.labelPosition == .TopInside
-                || _xAxis.labelPosition == .BothSided)
+        if (xAxis.labelPosition == .Top
+                || xAxis.labelPosition == .TopInside
+                || xAxis.labelPosition == .BothSided)
         {
             _axisLineSegmentsBuffer[0].x = viewPortHandler.contentLeft
             _axisLineSegmentsBuffer[0].y = viewPortHandler.contentTop
@@ -119,9 +125,9 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
             CGContextStrokeLineSegments(context, _axisLineSegmentsBuffer, 2)
         }
 
-        if (_xAxis.labelPosition == .Bottom
-                || _xAxis.labelPosition == .BottomInside
-                || _xAxis.labelPosition == .BothSided)
+        if (xAxis.labelPosition == .Bottom
+                || xAxis.labelPosition == .BottomInside
+                || xAxis.labelPosition == .BothSided)
         {
             _axisLineSegmentsBuffer[0].x = viewPortHandler.contentLeft
             _axisLineSegmentsBuffer[0].y = viewPortHandler.contentBottom
@@ -134,15 +140,17 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
     }
     
     /// draws the x-labels on the specified y-position
-    internal func drawLabels(context context: CGContext, pos: CGFloat, anchor: CGPoint)
+    public func drawLabels(context context: CGContext, pos: CGFloat, anchor: CGPoint)
     {
+        guard let xAxis = xAxis else { return }
+        
         let paraStyle = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
         paraStyle.alignment = .Center
         
-        let labelAttrs = [NSFontAttributeName: _xAxis.labelFont,
-            NSForegroundColorAttributeName: _xAxis.labelTextColor,
+        let labelAttrs = [NSFontAttributeName: xAxis.labelFont,
+            NSForegroundColorAttributeName: xAxis.labelTextColor,
             NSParagraphStyleAttributeName: paraStyle]
-        let labelRotationAngleRadians = _xAxis.labelRotationAngle * ChartUtils.Math.FDEG2RAD
+        let labelRotationAngleRadians = xAxis.labelRotationAngle * ChartUtils.Math.FDEG2RAD
         
         let valueToPixelMatrix = transformer.valueToPixelMatrix
         
@@ -150,14 +158,14 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
         
         var labelMaxSize = CGSize()
         
-        if (_xAxis.isWordWrapEnabled)
+        if (xAxis.isWordWrapEnabled)
         {
-            labelMaxSize.width = _xAxis.wordWrapWidthPercent * valueToPixelMatrix.a
+            labelMaxSize.width = xAxis.wordWrapWidthPercent * valueToPixelMatrix.a
         }
         
-        for (var i = _minX, maxX = min(_maxX + 1, _xAxis.values.count); i < maxX; i += _xAxis.axisLabelModulus)
+        for i in self.minX.stride(to: min(self.maxX + 1, xAxis.values.count), by: xAxis.axisLabelModulus)
         {
-            let label = _xAxis.values[i]
+            let label = xAxis.values[i]
             if (label == nil)
             {
                 continue
@@ -171,10 +179,10 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
             {
                 let labelns = label! as NSString
                 
-                if (_xAxis.isAvoidFirstLastClippingEnabled)
+                if (xAxis.isAvoidFirstLastClippingEnabled)
                 {
                     // avoid clipping of the last
-                    if (i == _xAxis.values.count - 1 && _xAxis.values.count > 1)
+                    if (i == xAxis.values.count - 1 && xAxis.values.count > 1)
                     {
                         let width = labelns.boundingRectWithSize(labelMaxSize, options: .UsesLineFragmentOrigin, attributes: labelAttrs, context: nil).size.width
                         
@@ -196,9 +204,11 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
         }
     }
     
-    internal func drawLabel(context context: CGContext, label: String, xIndex: Int, x: CGFloat, y: CGFloat, attributes: [String: NSObject], constrainedToSize: CGSize, anchor: CGPoint, angleRadians: CGFloat)
+    public func drawLabel(context context: CGContext, label: String, xIndex: Int, x: CGFloat, y: CGFloat, attributes: [String: NSObject], constrainedToSize: CGSize, anchor: CGPoint, angleRadians: CGFloat)
     {
-        let formattedLabel = _xAxis.valueFormatter?.stringForXValue(xIndex, original: label, viewPortHandler: viewPortHandler) ?? label
+        guard let xAxis = xAxis else { return }
+        
+        let formattedLabel = xAxis.valueFormatter?.stringForXValue(xIndex, original: label, viewPortHandler: viewPortHandler) ?? label
         ChartUtils.drawMultilineText(context: context, text: formattedLabel, point: CGPoint(x: x, y: y), attributes: attributes, constrainedToSize: constrainedToSize, anchor: anchor, angleRadians: angleRadians)
     }
     
@@ -206,23 +216,25 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
     
     public override func renderGridLines(context context: CGContext)
     {
-        if (!_xAxis.isDrawGridLinesEnabled || !_xAxis.isEnabled)
+        guard let xAxis = xAxis else { return }
+        
+        if (!xAxis.isDrawGridLinesEnabled || !xAxis.isEnabled)
         {
             return
         }
         
         CGContextSaveGState(context)
 
-        if (!_xAxis.gridAntialiasEnabled)
+        if (!xAxis.gridAntialiasEnabled)
         {
             CGContextSetShouldAntialias(context, false)
         }
 
-        CGContextSetStrokeColorWithColor(context, _xAxis.gridColor.CGColor)
-        CGContextSetLineWidth(context, _xAxis.gridLineWidth)
-        if (_xAxis.gridLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, xAxis.gridColor.CGColor)
+        CGContextSetLineWidth(context, xAxis.gridLineWidth)
+        if (xAxis.gridLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _xAxis.gridLineDashPhase, _xAxis.gridLineDashLengths, _xAxis.gridLineDashLengths.count)
+            CGContextSetLineDash(context, xAxis.gridLineDashPhase, xAxis.gridLineDashLengths, xAxis.gridLineDashLengths.count)
         }
         else
         {
@@ -233,7 +245,7 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
         
         var position = CGPoint(x: 0.0, y: 0.0)
         
-        for (var i = _minX; i <= _maxX; i += _xAxis.axisLabelModulus)
+        for i in self.minX.stride(to: self.maxX, by: xAxis.axisLabelModulus)
         {
             position.x = CGFloat(i)
             position.y = 0.0
@@ -255,7 +267,9 @@ public class ChartXAxisRenderer: ChartAxisRendererBase
     
     public override func renderLimitLines(context context: CGContext)
     {
-        var limitLines = _xAxis.limitLines
+        guard let xAxis = xAxis else { return }
+        
+        var limitLines = xAxis.limitLines
         
         if (limitLines.count == 0)
         {
diff --git a/Charts/Classes/Renderers/ChartXAxisRendererBarChart.swift b/Charts/Classes/Renderers/ChartXAxisRendererBarChart.swift
index 59012fba..7b3a1267 100644
--- a/Charts/Classes/Renderers/ChartXAxisRendererBarChart.swift
+++ b/Charts/Classes/Renderers/ChartXAxisRendererBarChart.swift
@@ -17,32 +17,31 @@ import UIKit
 
 public class ChartXAxisRendererBarChart: ChartXAxisRenderer
 {
-    internal weak var _chart: BarChartView!
+    public weak var chart: BarChartView?
     
     public init(viewPortHandler: ChartViewPortHandler, xAxis: ChartXAxis, transformer: ChartTransformer!, chart: BarChartView)
     {
         super.init(viewPortHandler: viewPortHandler, xAxis: xAxis, transformer: transformer)
         
-        self._chart = chart
+        self.chart = chart
     }
     
     /// draws the x-labels on the specified y-position
-    internal override func drawLabels(context context: CGContext, pos: CGFloat, anchor: CGPoint)
+    public override func drawLabels(context context: CGContext, pos: CGFloat, anchor: CGPoint)
     {
-        if (_chart.data === nil)
-        {
-            return
-        }
+        guard let
+            xAxis = xAxis,
+            barData = chart?.data as? BarChartData
+            else { return }
         
         let paraStyle = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
         paraStyle.alignment = .Center
         
-        let labelAttrs = [NSFontAttributeName: _xAxis.labelFont,
-            NSForegroundColorAttributeName: _xAxis.labelTextColor,
+        let labelAttrs = [NSFontAttributeName: xAxis.labelFont,
+            NSForegroundColorAttributeName: xAxis.labelTextColor,
             NSParagraphStyleAttributeName: paraStyle]
-        let labelRotationAngleRadians = _xAxis.labelRotationAngle * ChartUtils.Math.FDEG2RAD
+        let labelRotationAngleRadians = xAxis.labelRotationAngle * ChartUtils.Math.FDEG2RAD
         
-        let barData = _chart.data as! BarChartData
         let step = barData.dataSetCount
         
         let valueToPixelMatrix = transformer.valueToPixelMatrix
@@ -51,14 +50,14 @@ public class ChartXAxisRendererBarChart: ChartXAxisRenderer
         
         var labelMaxSize = CGSize()
         
-        if (_xAxis.isWordWrapEnabled)
+        if (xAxis.isWordWrapEnabled)
         {
-            labelMaxSize.width = _xAxis.wordWrapWidthPercent * valueToPixelMatrix.a
+            labelMaxSize.width = xAxis.wordWrapWidthPercent * valueToPixelMatrix.a
         }
         
-        for (var i = _minX, maxX = min(_maxX + 1, _xAxis.values.count); i < maxX; i += _xAxis.axisLabelModulus)
+        for i in self.minX.stride(to: min(self.maxX + 1, xAxis.values.count), by: xAxis.axisLabelModulus)
         {
-            let label = i >= 0 && i < _xAxis.values.count ? _xAxis.values[i] : nil
+            let label = i >= 0 && i < xAxis.values.count ? xAxis.values[i] : nil
             if (label == nil)
             {
                 continue
@@ -77,10 +76,10 @@ public class ChartXAxisRendererBarChart: ChartXAxisRenderer
             
             if (viewPortHandler.isInBoundsX(position.x))
             {
-                if (_xAxis.isAvoidFirstLastClippingEnabled)
+                if (xAxis.isAvoidFirstLastClippingEnabled)
                 {
                     // avoid clipping of the last
-                    if (i == _xAxis.values.count - 1)
+                    if (i == xAxis.values.count - 1)
                     {
                         let width = label!.sizeWithAttributes(labelAttrs).width
                         
@@ -109,21 +108,25 @@ public class ChartXAxisRendererBarChart: ChartXAxisRenderer
     
     public override func renderGridLines(context context: CGContext)
     {
-        if (!_xAxis.isDrawGridLinesEnabled || !_xAxis.isEnabled)
+        guard let
+            xAxis = xAxis,
+            barData = chart?.data as? BarChartData
+            else { return }
+        
+        if (!xAxis.isDrawGridLinesEnabled || !xAxis.isEnabled)
         {
             return
         }
         
-        let barData = _chart.data as! BarChartData
         let step = barData.dataSetCount
         
         CGContextSaveGState(context)
         
-        CGContextSetStrokeColorWithColor(context, _xAxis.gridColor.CGColor)
-        CGContextSetLineWidth(context, _xAxis.gridLineWidth)
-        if (_xAxis.gridLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, xAxis.gridColor.CGColor)
+        CGContextSetLineWidth(context, xAxis.gridLineWidth)
+        if (xAxis.gridLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _xAxis.gridLineDashPhase, _xAxis.gridLineDashLengths, _xAxis.gridLineDashLengths.count)
+            CGContextSetLineDash(context, xAxis.gridLineDashPhase, xAxis.gridLineDashLengths, xAxis.gridLineDashLengths.count)
         }
         else
         {
@@ -134,7 +137,7 @@ public class ChartXAxisRendererBarChart: ChartXAxisRenderer
         
         var position = CGPoint(x: 0.0, y: 0.0)
         
-        for (var i = _minX; i < _maxX; i += _xAxis.axisLabelModulus)
+        for i in self.minX.stride(to: self.maxX, by: xAxis.axisLabelModulus)
         {
             position.x = CGFloat(i * step) + CGFloat(i) * barData.groupSpace - 0.5
             position.y = 0.0
diff --git a/Charts/Classes/Renderers/ChartXAxisRendererHorizontalBarChart.swift b/Charts/Classes/Renderers/ChartXAxisRendererHorizontalBarChart.swift
index 82bc4119..67b9e397 100644
--- a/Charts/Classes/Renderers/ChartXAxisRendererHorizontalBarChart.swift
+++ b/Charts/Classes/Renderers/ChartXAxisRendererHorizontalBarChart.swift
@@ -24,45 +24,49 @@ public class ChartXAxisRendererHorizontalBarChart: ChartXAxisRendererBarChart
     
     public override func computeAxis(xValAverageLength xValAverageLength: Double, xValues: [String?])
     {
-        _xAxis.values = xValues
+        guard let xAxis = xAxis else { return }
+        
+        xAxis.values = xValues
        
-        let longest = _xAxis.getLongestLabel() as NSString
+        let longest = xAxis.getLongestLabel() as NSString
         
-        let labelSize = longest.sizeWithAttributes([NSFontAttributeName: _xAxis.labelFont])
+        let labelSize = longest.sizeWithAttributes([NSFontAttributeName: xAxis.labelFont])
         
-        let labelWidth = floor(labelSize.width + _xAxis.xOffset * 3.5)
+        let labelWidth = floor(labelSize.width + xAxis.xOffset * 3.5)
         let labelHeight = labelSize.height
         
-        let labelRotatedSize = ChartUtils.sizeOfRotatedRectangle(rectangleWidth: labelSize.width, rectangleHeight:  labelHeight, degrees: _xAxis.labelRotationAngle)
+        let labelRotatedSize = ChartUtils.sizeOfRotatedRectangle(rectangleWidth: labelSize.width, rectangleHeight:  labelHeight, degrees: xAxis.labelRotationAngle)
         
-        _xAxis.labelWidth = labelWidth
-        _xAxis.labelHeight = labelHeight
-        _xAxis.labelRotatedWidth = round(labelRotatedSize.width + _xAxis.xOffset * 3.5)
-        _xAxis.labelRotatedHeight = round(labelRotatedSize.height)
+        xAxis.labelWidth = labelWidth
+        xAxis.labelHeight = labelHeight
+        xAxis.labelRotatedWidth = round(labelRotatedSize.width + xAxis.xOffset * 3.5)
+        xAxis.labelRotatedHeight = round(labelRotatedSize.height)
     }
 
     public override func renderAxisLabels(context context: CGContext)
     {
-        if (!_xAxis.isEnabled || !_xAxis.isDrawLabelsEnabled || _chart.data === nil)
+        guard let xAxis = xAxis else { return }
+        
+        if !xAxis.isEnabled || !xAxis.isDrawLabelsEnabled || chart?.data === nil
         {
             return
         }
         
-        let xoffset = _xAxis.xOffset
+        let xoffset = xAxis.xOffset
         
-        if (_xAxis.labelPosition == .Top)
+        if (xAxis.labelPosition == .Top)
         {
             drawLabels(context: context, pos: viewPortHandler.contentRight + xoffset, anchor: CGPoint(x: 0.0, y: 0.5))
         }
-        else if (_xAxis.labelPosition == .TopInside)
+        else if (xAxis.labelPosition == .TopInside)
         {
             drawLabels(context: context, pos: viewPortHandler.contentRight - xoffset, anchor: CGPoint(x: 1.0, y: 0.5))
         }
-        else if (_xAxis.labelPosition == .Bottom)
+        else if (xAxis.labelPosition == .Bottom)
         {
             drawLabels(context: context, pos: viewPortHandler.contentLeft - xoffset, anchor: CGPoint(x: 1.0, y: 0.5))
         }
-        else if (_xAxis.labelPosition == .BottomInside)
+        else if (xAxis.labelPosition == .BottomInside)
         {
             drawLabels(context: context, pos: viewPortHandler.contentLeft + xoffset, anchor: CGPoint(x: 0.0, y: 0.5))
         }
@@ -74,21 +78,25 @@ public class ChartXAxisRendererHorizontalBarChart: ChartXAxisRendererBarChart
     }
 
     /// draws the x-labels on the specified y-position
-    internal override func drawLabels(context context: CGContext, pos: CGFloat, anchor: CGPoint)
+    public override func drawLabels(context context: CGContext, pos: CGFloat, anchor: CGPoint)
     {
-        let labelFont = _xAxis.labelFont
-        let labelTextColor = _xAxis.labelTextColor
-        let labelRotationAngleRadians = _xAxis.labelRotationAngle * ChartUtils.Math.FDEG2RAD
+        guard let
+            xAxis = xAxis,
+            bd = chart?.data as? BarChartData
+            else { return }
+        
+        let labelFont = xAxis.labelFont
+        let labelTextColor = xAxis.labelTextColor
+        let labelRotationAngleRadians = xAxis.labelRotationAngle * ChartUtils.Math.FDEG2RAD
         
         // pre allocate to save performance (dont allocate in loop)
         var position = CGPoint(x: 0.0, y: 0.0)
         
-        let bd = _chart.data as! BarChartData
         let step = bd.dataSetCount
         
-        for (var i = _minX, maxX = min(_maxX + 1, _xAxis.values.count); i < maxX; i += _xAxis.axisLabelModulus)
+        for i in self.minX.stride(to: min(self.maxX + 1, xAxis.values.count), by: xAxis.axisLabelModulus)
         {
-            let label = _xAxis.values[i]
+            let label = xAxis.values[i]
             
             if (label == nil)
             {
@@ -113,9 +121,11 @@ public class ChartXAxisRendererHorizontalBarChart: ChartXAxisRendererBarChart
         }
     }
     
-    internal func drawLabel(context context: CGContext, label: String, xIndex: Int, x: CGFloat, y: CGFloat, attributes: [String: NSObject], anchor: CGPoint, angleRadians: CGFloat)
+    public func drawLabel(context context: CGContext, label: String, xIndex: Int, x: CGFloat, y: CGFloat, attributes: [String: NSObject], anchor: CGPoint, angleRadians: CGFloat)
     {
-        let formattedLabel = _xAxis.valueFormatter?.stringForXValue(xIndex, original: label, viewPortHandler: viewPortHandler) ?? label
+        guard let xAxis = xAxis else { return }
+        
+        let formattedLabel = xAxis.valueFormatter?.stringForXValue(xIndex, original: label, viewPortHandler: viewPortHandler) ?? label
         ChartUtils.drawText(context: context, text: formattedLabel, point: CGPoint(x: x, y: y), attributes: attributes, anchor: anchor, angleRadians: angleRadians)
     }
     
@@ -123,18 +133,23 @@ public class ChartXAxisRendererHorizontalBarChart: ChartXAxisRendererBarChart
     
     public override func renderGridLines(context context: CGContext)
     {
-        if (!_xAxis.isEnabled || !_xAxis.isDrawGridLinesEnabled || _chart.data === nil)
+        guard let
+            xAxis = xAxis,
+            bd = chart?.data as? BarChartData
+            else { return }
+        
+        if !xAxis.isEnabled || !xAxis.isDrawGridLinesEnabled
         {
             return
         }
         
         CGContextSaveGState(context)
         
-        CGContextSetStrokeColorWithColor(context, _xAxis.gridColor.CGColor)
-        CGContextSetLineWidth(context, _xAxis.gridLineWidth)
-        if (_xAxis.gridLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, xAxis.gridColor.CGColor)
+        CGContextSetLineWidth(context, xAxis.gridLineWidth)
+        if (xAxis.gridLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _xAxis.gridLineDashPhase, _xAxis.gridLineDashLengths, _xAxis.gridLineDashLengths.count)
+            CGContextSetLineDash(context, xAxis.gridLineDashPhase, xAxis.gridLineDashLengths, xAxis.gridLineDashLengths.count)
         }
         else
         {
@@ -143,12 +158,10 @@ public class ChartXAxisRendererHorizontalBarChart: ChartXAxisRendererBarChart
         
         var position = CGPoint(x: 0.0, y: 0.0)
         
-        let bd = _chart.data as! BarChartData
-        
         // take into consideration that multiple DataSets increase _deltaX
         let step = bd.dataSetCount
         
-        for (var i = _minX, maxX = min(_maxX + 1, _xAxis.values.count); i < maxX; i += _xAxis.axisLabelModulus)
+        for i in self.minX.stride(to: min(self.maxX + 1, xAxis.values.count), by: xAxis.axisLabelModulus)
         {
             position.x = 0.0
             position.y = CGFloat(i * step) + CGFloat(i) * bd.groupSpace - 0.5
@@ -172,27 +185,29 @@ public class ChartXAxisRendererHorizontalBarChart: ChartXAxisRendererBarChart
     
     public override func renderAxisLine(context context: CGContext)
     {
-        if (!_xAxis.isEnabled || !_xAxis.isDrawAxisLineEnabled)
+        guard let xAxis = xAxis else { return }
+        
+        if (!xAxis.isEnabled || !xAxis.isDrawAxisLineEnabled)
         {
             return
         }
         
         CGContextSaveGState(context)
         
-        CGContextSetStrokeColorWithColor(context, _xAxis.axisLineColor.CGColor)
-        CGContextSetLineWidth(context, _xAxis.axisLineWidth)
-        if (_xAxis.axisLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, xAxis.axisLineColor.CGColor)
+        CGContextSetLineWidth(context, xAxis.axisLineWidth)
+        if (xAxis.axisLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _xAxis.axisLineDashPhase, _xAxis.axisLineDashLengths, _xAxis.axisLineDashLengths.count)
+            CGContextSetLineDash(context, xAxis.axisLineDashPhase, xAxis.axisLineDashLengths, xAxis.axisLineDashLengths.count)
         }
         else
         {
             CGContextSetLineDash(context, 0.0, nil, 0)
         }
         
-        if (_xAxis.labelPosition == .Top
-            || _xAxis.labelPosition == .TopInside
-            || _xAxis.labelPosition == .BothSided)
+        if (xAxis.labelPosition == .Top
+            || xAxis.labelPosition == .TopInside
+            || xAxis.labelPosition == .BothSided)
         {
             _axisLineSegmentsBuffer[0].x = viewPortHandler.contentRight
             _axisLineSegmentsBuffer[0].y = viewPortHandler.contentTop
@@ -201,9 +216,9 @@ public class ChartXAxisRendererHorizontalBarChart: ChartXAxisRendererBarChart
             CGContextStrokeLineSegments(context, _axisLineSegmentsBuffer, 2)
         }
         
-        if (_xAxis.labelPosition == .Bottom
-            || _xAxis.labelPosition == .BottomInside
-            || _xAxis.labelPosition == .BothSided)
+        if (xAxis.labelPosition == .Bottom
+            || xAxis.labelPosition == .BottomInside
+            || xAxis.labelPosition == .BothSided)
         {
             _axisLineSegmentsBuffer[0].x = viewPortHandler.contentLeft
             _axisLineSegmentsBuffer[0].y = viewPortHandler.contentTop
@@ -219,7 +234,9 @@ public class ChartXAxisRendererHorizontalBarChart: ChartXAxisRendererBarChart
     
     public override func renderLimitLines(context context: CGContext)
     {
-        var limitLines = _xAxis.limitLines
+        guard let xAxis = xAxis else { return }
+        
+        var limitLines = xAxis.limitLines
         
         if (limitLines.count == 0)
         {
diff --git a/Charts/Classes/Renderers/ChartXAxisRendererRadarChart.swift b/Charts/Classes/Renderers/ChartXAxisRendererRadarChart.swift
index 3f007340..eca49094 100644
--- a/Charts/Classes/Renderers/ChartXAxisRendererRadarChart.swift
+++ b/Charts/Classes/Renderers/ChartXAxisRendererRadarChart.swift
@@ -17,55 +17,62 @@ import UIKit
 
 public class ChartXAxisRendererRadarChart: ChartXAxisRenderer
 {
-    private weak var _chart: RadarChartView!
+    public weak var chart: RadarChartView?
     
     public init(viewPortHandler: ChartViewPortHandler, xAxis: ChartXAxis, chart: RadarChartView)
     {
         super.init(viewPortHandler: viewPortHandler, xAxis: xAxis, transformer: nil)
         
-        _chart = chart
+        self.chart = chart
     }
     
     public override func renderAxisLabels(context context: CGContext)
     {
-        if (!_xAxis.isEnabled || !_xAxis.isDrawLabelsEnabled)
+        guard let
+            xAxis = xAxis,
+            chart = chart
+            else { return }
+        
+        if (!xAxis.isEnabled || !xAxis.isDrawLabelsEnabled)
         {
             return
         }
         
-        let labelFont = _xAxis.labelFont
-        let labelTextColor = _xAxis.labelTextColor
-        let labelRotationAngleRadians = _xAxis.labelRotationAngle * ChartUtils.Math.FDEG2RAD
+        let labelFont = xAxis.labelFont
+        let labelTextColor = xAxis.labelTextColor
+        let labelRotationAngleRadians = xAxis.labelRotationAngle * ChartUtils.Math.FDEG2RAD
         let drawLabelAnchor = CGPoint(x: 0.5, y: 0.0)
         
-        let sliceangle = _chart.sliceAngle
+        let sliceangle = chart.sliceAngle
         
         // calculate the factor that is needed for transforming the value to pixels
-        let factor = _chart.factor
+        let factor = chart.factor
         
-        let center = _chart.centerOffsets
+        let center = chart.centerOffsets
         
-        let modulus = _xAxis.axisLabelModulus
-        for var i = 0, count = _xAxis.values.count; i < count; i += modulus
+        let modulus = xAxis.axisLabelModulus
+        for var i = 0, count = xAxis.values.count; i < count; i += modulus
         {
-            let label = _xAxis.values[i]
+            let label = xAxis.values[i]
             
             if (label == nil)
             {
                 continue
             }
             
-            let angle = (sliceangle * CGFloat(i) + _chart.rotationAngle) % 360.0
+            let angle = (sliceangle * CGFloat(i) + chart.rotationAngle) % 360.0
             
-            let p = ChartUtils.getPosition(center: center, dist: CGFloat(_chart.yRange) * factor + _xAxis.labelRotatedWidth / 2.0, angle: angle)
+            let p = ChartUtils.getPosition(center: center, dist: CGFloat(chart.yRange) * factor + xAxis.labelRotatedWidth / 2.0, angle: angle)
             
-            drawLabel(context: context, label: label!, xIndex: i, x: p.x, y: p.y - _xAxis.labelRotatedHeight / 2.0, attributes: [NSFontAttributeName: labelFont, NSForegroundColorAttributeName: labelTextColor], anchor: drawLabelAnchor, angleRadians: labelRotationAngleRadians)
+            drawLabel(context: context, label: label!, xIndex: i, x: p.x, y: p.y - xAxis.labelRotatedHeight / 2.0, attributes: [NSFontAttributeName: labelFont, NSForegroundColorAttributeName: labelTextColor], anchor: drawLabelAnchor, angleRadians: labelRotationAngleRadians)
         }
     }
     
-    internal func drawLabel(context context: CGContext, label: String, xIndex: Int, x: CGFloat, y: CGFloat, attributes: [String: NSObject], anchor: CGPoint, angleRadians: CGFloat)
+    public func drawLabel(context context: CGContext, label: String, xIndex: Int, x: CGFloat, y: CGFloat, attributes: [String: NSObject], anchor: CGPoint, angleRadians: CGFloat)
     {
-        let formattedLabel = _xAxis.valueFormatter?.stringForXValue(xIndex, original: label, viewPortHandler: viewPortHandler) ?? label
+        guard let xAxis = xAxis else { return }
+        
+        let formattedLabel = xAxis.valueFormatter?.stringForXValue(xIndex, original: label, viewPortHandler: viewPortHandler) ?? label
         ChartUtils.drawText(context: context, text: formattedLabel, point: CGPoint(x: x, y: y), attributes: attributes, anchor: anchor, angleRadians: angleRadians)
     }
     
diff --git a/Charts/Classes/Renderers/ChartYAxisRenderer.swift b/Charts/Classes/Renderers/ChartYAxisRenderer.swift
index 09dc2995..64243e1b 100644
--- a/Charts/Classes/Renderers/ChartYAxisRenderer.swift
+++ b/Charts/Classes/Renderers/ChartYAxisRenderer.swift
@@ -17,18 +17,20 @@ import UIKit
 
 public class ChartYAxisRenderer: ChartAxisRendererBase
 {
-    internal var _yAxis: ChartYAxis!
+    public var yAxis: ChartYAxis?
     
     public init(viewPortHandler: ChartViewPortHandler, yAxis: ChartYAxis, transformer: ChartTransformer!)
     {
         super.init(viewPortHandler: viewPortHandler, transformer: transformer)
         
-        _yAxis = yAxis
+        self.yAxis = yAxis
     }
     
     /// Computes the axis values.
     public func computeAxis(var yMin yMin: Double, var yMax: Double)
     {
+        guard let yAxis = yAxis else { return }
+        
         // calculate the starting and entry point of the y-labels (depending on
         // zoom / contentrect bounds)
         if (viewPortHandler.contentWidth > 10.0 && !viewPortHandler.isFullyZoomedOutY)
@@ -36,7 +38,7 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
             let p1 = transformer.getValueByTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
             let p2 = transformer.getValueByTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentBottom))
             
-            if (!_yAxis.isInverted)
+            if (!yAxis.isInverted)
             {
                 yMin = Double(p2.y)
                 yMax = Double(p1.y)
@@ -54,17 +56,19 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
     /// Sets up the y-axis labels. Computes the desired number of labels between
     /// the two given extremes. Unlike the papareXLabels() method, this method
     /// needs to be called upon every refresh of the view.
-    internal func computeAxisValues(min min: Double, max: Double)
+    public func computeAxisValues(min min: Double, max: Double)
     {
+        guard let yAxis = yAxis else { return }
+        
         let yMin = min
         let yMax = max
         
-        let labelCount = _yAxis.labelCount
+        let labelCount = yAxis.labelCount
         let range = abs(yMax - yMin)
     
         if (labelCount == 0 || range <= 0)
         {
-            _yAxis.entries = [Double]()
+            yAxis.entries = [Double]()
             return
         }
         
@@ -79,26 +83,26 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
         }
         
         // force label count
-        if _yAxis.isForceLabelsEnabled
+        if yAxis.isForceLabelsEnabled
         {
             let step = Double(range) / Double(labelCount - 1)
             
-            if _yAxis.entries.count < labelCount
+            if yAxis.entries.count < labelCount
             {
                 // Ensure stops contains at least numStops elements.
-                _yAxis.entries.removeAll(keepCapacity: true)
+                yAxis.entries.removeAll(keepCapacity: true)
             }
             else
             {
-                _yAxis.entries = [Double]()
-                _yAxis.entries.reserveCapacity(labelCount)
+                yAxis.entries = [Double]()
+                yAxis.entries.reserveCapacity(labelCount)
             }
             
             var v = yMin
             
             for (var i = 0; i < labelCount; i++)
             {
-                _yAxis.entries.append(v)
+                yAxis.entries.append(v)
                 v += step
             }
             
@@ -108,9 +112,9 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
             // no forced count
             
             // if the labels should only show min and max
-            if (_yAxis.isShowOnlyMinMaxEnabled)
+            if (yAxis.isShowOnlyMinMaxEnabled)
             {
-                _yAxis.entries = [yMin, yMax]
+                yAxis.entries = [yMin, yMax]
             }
             else
             {
@@ -125,19 +129,19 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
                     ++n
                 }
                 
-                if (_yAxis.entries.count < n)
+                if (yAxis.entries.count < n)
                 {
                     // Ensure stops contains at least numStops elements.
-                    _yAxis.entries = [Double](count: n, repeatedValue: 0.0)
+                    yAxis.entries = [Double](count: n, repeatedValue: 0.0)
                 }
-                else if (_yAxis.entries.count > n)
+                else if (yAxis.entries.count > n)
                 {
-                    _yAxis.entries.removeRange(n..<_yAxis.entries.count)
+                    yAxis.entries.removeRange(n..<yAxis.entries.count)
                 }
                 
                 for (f = first, i = 0; i < n; f += interval, ++i)
                 {
-                    _yAxis.entries[i] = Double(f)
+                    yAxis.entries[i] = Double(f)
                 }
             }
         }
@@ -146,16 +150,18 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
     /// draws the y-axis labels to the screen
     public override func renderAxisLabels(context context: CGContext)
     {
-        if (!_yAxis.isEnabled || !_yAxis.isDrawLabelsEnabled)
+        guard let yAxis = yAxis else { return }
+        
+        if (!yAxis.isEnabled || !yAxis.isDrawLabelsEnabled)
         {
             return
         }
         
-        let xoffset = _yAxis.xOffset
-        let yoffset = _yAxis.labelFont.lineHeight / 2.5 + _yAxis.yOffset
+        let xoffset = yAxis.xOffset
+        let yoffset = yAxis.labelFont.lineHeight / 2.5 + yAxis.yOffset
         
-        let dependency = _yAxis.axisDependency
-        let labelPosition = _yAxis.labelPosition
+        let dependency = yAxis.axisDependency
+        let labelPosition = yAxis.labelPosition
         
         var xPos = CGFloat(0.0)
         
@@ -189,32 +195,34 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
             }
         }
         
-        drawYLabels(context: context, fixedPosition: xPos, offset: yoffset - _yAxis.labelFont.lineHeight, textAlign: textAlign)
+        drawYLabels(context: context, fixedPosition: xPos, offset: yoffset - yAxis.labelFont.lineHeight, textAlign: textAlign)
     }
     
     private var _axisLineSegmentsBuffer = [CGPoint](count: 2, repeatedValue: CGPoint())
     
     public override func renderAxisLine(context context: CGContext)
     {
-        if (!_yAxis.isEnabled || !_yAxis.drawAxisLineEnabled)
+        guard let yAxis = yAxis else { return }
+        
+        if (!yAxis.isEnabled || !yAxis.drawAxisLineEnabled)
         {
             return
         }
         
         CGContextSaveGState(context)
         
-        CGContextSetStrokeColorWithColor(context, _yAxis.axisLineColor.CGColor)
-        CGContextSetLineWidth(context, _yAxis.axisLineWidth)
-        if (_yAxis.axisLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, yAxis.axisLineColor.CGColor)
+        CGContextSetLineWidth(context, yAxis.axisLineWidth)
+        if (yAxis.axisLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _yAxis.axisLineDashPhase, _yAxis.axisLineDashLengths, _yAxis.axisLineDashLengths.count)
+            CGContextSetLineDash(context, yAxis.axisLineDashPhase, yAxis.axisLineDashLengths, yAxis.axisLineDashLengths.count)
         }
         else
         {
             CGContextSetLineDash(context, 0.0, nil, 0)
         }
         
-        if (_yAxis.axisDependency == .Left)
+        if (yAxis.axisDependency == .Left)
         {
             _axisLineSegmentsBuffer[0].x = viewPortHandler.contentLeft
             _axisLineSegmentsBuffer[0].y = viewPortHandler.contentTop
@@ -237,24 +245,26 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
     /// draws the y-labels on the specified x-position
     internal func drawYLabels(context context: CGContext, fixedPosition: CGFloat, offset: CGFloat, textAlign: NSTextAlignment)
     {
-        let labelFont = _yAxis.labelFont
-        let labelTextColor = _yAxis.labelTextColor
+        guard let yAxis = yAxis else { return }
+        
+        let labelFont = yAxis.labelFont
+        let labelTextColor = yAxis.labelTextColor
         
         let valueToPixelMatrix = transformer.valueToPixelMatrix
         
         var pt = CGPoint()
         
-        for (var i = 0; i < _yAxis.entryCount; i++)
+        for (var i = 0; i < yAxis.entryCount; i++)
         {
-            let text = _yAxis.getFormattedLabel(i)
+            let text = yAxis.getFormattedLabel(i)
             
-            if (!_yAxis.isDrawTopYLabelEntryEnabled && i >= _yAxis.entryCount - 1)
+            if (!yAxis.isDrawTopYLabelEntryEnabled && i >= yAxis.entryCount - 1)
             {
                 break
             }
             
             pt.x = 0
-            pt.y = CGFloat(_yAxis.entries[i])
+            pt.y = CGFloat(yAxis.entries[i])
             pt = CGPointApplyAffineTransform(pt, valueToPixelMatrix)
             
             pt.x = fixedPosition
@@ -268,23 +278,25 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
     
     public override func renderGridLines(context context: CGContext)
     {
-        if (!_yAxis.isDrawGridLinesEnabled || !_yAxis.isEnabled)
+        guard let yAxis = yAxis else { return }
+        
+        if (!yAxis.isDrawGridLinesEnabled || !yAxis.isEnabled)
         {
             return
         }
         
         CGContextSaveGState(context)
 
-        if (!_yAxis.gridAntialiasEnabled)
+        if (!yAxis.gridAntialiasEnabled)
         {
             CGContextSetShouldAntialias(context, false)
         }
 
-        CGContextSetStrokeColorWithColor(context, _yAxis.gridColor.CGColor)
-        CGContextSetLineWidth(context, _yAxis.gridLineWidth)
-        if (_yAxis.gridLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, yAxis.gridColor.CGColor)
+        CGContextSetLineWidth(context, yAxis.gridLineWidth)
+        if (yAxis.gridLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _yAxis.gridLineDashPhase, _yAxis.gridLineDashLengths, _yAxis.gridLineDashLengths.count)
+            CGContextSetLineDash(context, yAxis.gridLineDashPhase, yAxis.gridLineDashLengths, yAxis.gridLineDashLengths.count)
         }
         else
         {
@@ -296,10 +308,10 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
         var position = CGPoint(x: 0.0, y: 0.0)
         
         // draw the horizontal grid
-        for (var i = 0, count = _yAxis.entryCount; i < count; i++)
+        for (var i = 0, count = yAxis.entryCount; i < count; i++)
         {
             position.x = 0.0
-            position.y = CGFloat(_yAxis.entries[i])
+            position.y = CGFloat(yAxis.entries[i])
             position = CGPointApplyAffineTransform(position, valueToPixelMatrix)
         
             _gridLineBuffer[0].x = viewPortHandler.contentLeft
@@ -316,7 +328,9 @@ public class ChartYAxisRenderer: ChartAxisRendererBase
     
     public override func renderLimitLines(context context: CGContext)
     {
-        var limitLines = _yAxis.limitLines
+        guard let yAxis = yAxis else { return }
+        
+        var limitLines = yAxis.limitLines
         
         if (limitLines.count == 0)
         {
diff --git a/Charts/Classes/Renderers/ChartYAxisRendererHorizontalBarChart.swift b/Charts/Classes/Renderers/ChartYAxisRendererHorizontalBarChart.swift
index 86bb20f8..26e7c76e 100644
--- a/Charts/Classes/Renderers/ChartYAxisRendererHorizontalBarChart.swift
+++ b/Charts/Classes/Renderers/ChartYAxisRendererHorizontalBarChart.swift
@@ -25,13 +25,15 @@ public class ChartYAxisRendererHorizontalBarChart: ChartYAxisRenderer
     /// Computes the axis values.
     public override func computeAxis(var yMin yMin: Double, var yMax: Double)
     {
+        guard let yAxis = yAxis else { return }
+        
         // calculate the starting and entry point of the y-labels (depending on zoom / contentrect bounds)
         if (viewPortHandler.contentHeight > 10.0 && !viewPortHandler.isFullyZoomedOutX)
         {
             let p1 = transformer.getValueByTouchPoint(CGPoint(x: viewPortHandler.contentLeft, y: viewPortHandler.contentTop))
             let p2 = transformer.getValueByTouchPoint(CGPoint(x: viewPortHandler.contentRight, y: viewPortHandler.contentTop))
             
-            if (!_yAxis.isInverted)
+            if (!yAxis.isInverted)
             {
                 yMin = Double(p1.x)
                 yMax = Double(p2.x)
@@ -49,26 +51,28 @@ public class ChartYAxisRendererHorizontalBarChart: ChartYAxisRenderer
     /// draws the y-axis labels to the screen
     public override func renderAxisLabels(context context: CGContext)
     {
-        if (!_yAxis.isEnabled || !_yAxis.isDrawLabelsEnabled)
+        guard let yAxis = yAxis else { return }
+        
+        if (!yAxis.isEnabled || !yAxis.isDrawLabelsEnabled)
         {
             return
         }
         
         var positions = [CGPoint]()
-        positions.reserveCapacity(_yAxis.entries.count)
+        positions.reserveCapacity(yAxis.entries.count)
         
-        for (var i = 0; i < _yAxis.entries.count; i++)
+        for (var i = 0; i < yAxis.entries.count; i++)
         {
-            positions.append(CGPoint(x: CGFloat(_yAxis.entries[i]), y: 0.0))
+            positions.append(CGPoint(x: CGFloat(yAxis.entries[i]), y: 0.0))
         }
         
         transformer.pointValuesToPixel(&positions)
         
-        let lineHeight = _yAxis.labelFont.lineHeight
+        let lineHeight = yAxis.labelFont.lineHeight
         let baseYOffset: CGFloat = 2.5
         
-        let dependency = _yAxis.axisDependency
-        let labelPosition = _yAxis.labelPosition
+        let dependency = yAxis.axisDependency
+        let labelPosition = yAxis.labelPosition
         
         var yPos: CGFloat = 0.0
         
@@ -99,32 +103,34 @@ public class ChartYAxisRendererHorizontalBarChart: ChartYAxisRenderer
         // And here we pull the line back up
         yPos -= lineHeight
         
-        drawYLabels(context: context, fixedPosition: yPos, positions: positions, offset: _yAxis.yOffset)
+        drawYLabels(context: context, fixedPosition: yPos, positions: positions, offset: yAxis.yOffset)
     }
     
     private var _axisLineSegmentsBuffer = [CGPoint](count: 2, repeatedValue: CGPoint())
     
     public override func renderAxisLine(context context: CGContext)
     {
-        if (!_yAxis.isEnabled || !_yAxis.drawAxisLineEnabled)
+        guard let yAxis = yAxis else { return }
+        
+        if (!yAxis.isEnabled || !yAxis.drawAxisLineEnabled)
         {
             return
         }
         
         CGContextSaveGState(context)
         
-        CGContextSetStrokeColorWithColor(context, _yAxis.axisLineColor.CGColor)
-        CGContextSetLineWidth(context, _yAxis.axisLineWidth)
-        if (_yAxis.axisLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, yAxis.axisLineColor.CGColor)
+        CGContextSetLineWidth(context, yAxis.axisLineWidth)
+        if (yAxis.axisLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _yAxis.axisLineDashPhase, _yAxis.axisLineDashLengths, _yAxis.axisLineDashLengths.count)
+            CGContextSetLineDash(context, yAxis.axisLineDashPhase, yAxis.axisLineDashLengths, yAxis.axisLineDashLengths.count)
         }
         else
         {
             CGContextSetLineDash(context, 0.0, nil, 0)
         }
 
-        if (_yAxis.axisDependency == .Left)
+        if (yAxis.axisDependency == .Left)
         {
             _axisLineSegmentsBuffer[0].x = viewPortHandler.contentLeft
             _axisLineSegmentsBuffer[0].y = viewPortHandler.contentTop
@@ -145,16 +151,18 @@ public class ChartYAxisRendererHorizontalBarChart: ChartYAxisRenderer
     }
 
     /// draws the y-labels on the specified x-position
-    internal func drawYLabels(context context: CGContext, fixedPosition: CGFloat, positions: [CGPoint], offset: CGFloat)
+    public func drawYLabels(context context: CGContext, fixedPosition: CGFloat, positions: [CGPoint], offset: CGFloat)
     {
-        let labelFont = _yAxis.labelFont
-        let labelTextColor = _yAxis.labelTextColor
+        guard let yAxis = yAxis else { return }
         
-        for (var i = 0; i < _yAxis.entryCount; i++)
+        let labelFont = yAxis.labelFont
+        let labelTextColor = yAxis.labelTextColor
+        
+        for (var i = 0; i < yAxis.entryCount; i++)
         {
-            let text = _yAxis.getFormattedLabel(i)
+            let text = yAxis.getFormattedLabel(i)
             
-            if (!_yAxis.isDrawTopYLabelEntryEnabled && i >= _yAxis.entryCount - 1)
+            if (!yAxis.isDrawTopYLabelEntryEnabled && i >= yAxis.entryCount - 1)
             {
                 return
             }
@@ -165,7 +173,9 @@ public class ChartYAxisRendererHorizontalBarChart: ChartYAxisRenderer
 
     public override func renderGridLines(context context: CGContext)
     {
-        if (!_yAxis.isEnabled || !_yAxis.isDrawGridLinesEnabled)
+        guard let yAxis = yAxis else { return }
+        
+        if (!yAxis.isEnabled || !yAxis.isDrawGridLinesEnabled)
         {
             return
         }
@@ -175,11 +185,11 @@ public class ChartYAxisRendererHorizontalBarChart: ChartYAxisRenderer
         // pre alloc
         var position = CGPoint()
         
-        CGContextSetStrokeColorWithColor(context, _yAxis.gridColor.CGColor)
-        CGContextSetLineWidth(context, _yAxis.gridLineWidth)
-        if (_yAxis.gridLineDashLengths != nil)
+        CGContextSetStrokeColorWithColor(context, yAxis.gridColor.CGColor)
+        CGContextSetLineWidth(context, yAxis.gridLineWidth)
+        if (yAxis.gridLineDashLengths != nil)
         {
-            CGContextSetLineDash(context, _yAxis.gridLineDashPhase, _yAxis.gridLineDashLengths, _yAxis.gridLineDashLengths.count)
+            CGContextSetLineDash(context, yAxis.gridLineDashPhase, yAxis.gridLineDashLengths, yAxis.gridLineDashLengths.count)
         }
         else
         {
@@ -187,9 +197,9 @@ public class ChartYAxisRendererHorizontalBarChart: ChartYAxisRenderer
         }
         
         // draw the horizontal grid
-        for (var i = 0; i < _yAxis.entryCount; i++)
+        for (var i = 0; i < yAxis.entryCount; i++)
         {
-            position.x = CGFloat(_yAxis.entries[i])
+            position.x = CGFloat(yAxis.entries[i])
             position.y = 0.0
             transformer.pointValueToPixel(&position)
             
@@ -206,7 +216,9 @@ public class ChartYAxisRendererHorizontalBarChart: ChartYAxisRenderer
     
     public override func renderLimitLines(context context: CGContext)
     {
-        var limitLines = _yAxis.limitLines
+        guard let yAxis = yAxis else { return }
+        
+        var limitLines = yAxis.limitLines
 
         if (limitLines.count <= 0)
         {
diff --git a/Charts/Classes/Renderers/ChartYAxisRendererRadarChart.swift b/Charts/Classes/Renderers/ChartYAxisRendererRadarChart.swift
index e6eb1fe7..eb2d82e5 100644
--- a/Charts/Classes/Renderers/ChartYAxisRendererRadarChart.swift
+++ b/Charts/Classes/Renderers/ChartYAxisRendererRadarChart.swift
@@ -17,13 +17,13 @@ import UIKit
 
 public class ChartYAxisRendererRadarChart: ChartYAxisRenderer
 {
-    private weak var _chart: RadarChartView!
+    private weak var chart: RadarChartView?
     
     public init(viewPortHandler: ChartViewPortHandler, yAxis: ChartYAxis, chart: RadarChartView)
     {
         super.init(viewPortHandler: viewPortHandler, yAxis: yAxis, transformer: nil)
         
-        _chart = chart
+        self.chart = chart
     }
     
     public override func computeAxis(yMin yMin: Double, yMax: Double)
@@ -31,14 +31,16 @@ public class ChartYAxisRendererRadarChart: ChartYAxisRenderer
         computeAxisValues(min: yMin, max: yMax)
     }
     
-    internal override func computeAxisValues(min yMin: Double, max yMax: Double)
+    public override func computeAxisValues(min yMin: Double, max yMax: Double)
     {
-        let labelCount = _yAxis.labelCount
+        guard let yAxis = yAxis else { return }
+        
+        let labelCount = yAxis.labelCount
         let range = abs(yMax - yMin)
         
         if (labelCount == 0 || range <= 0)
         {
-            _yAxis.entries = [Double]()
+            yAxis.entries = [Double]()
             return
         }
         
@@ -55,26 +57,26 @@ public class ChartYAxisRendererRadarChart: ChartYAxisRenderer
         }
         
         // force label count
-        if _yAxis.isForceLabelsEnabled
+        if yAxis.isForceLabelsEnabled
         {
             let step = Double(range) / Double(labelCount - 1)
             
-            if _yAxis.entries.count < labelCount
+            if yAxis.entries.count < labelCount
             {
                 // Ensure stops contains at least numStops elements.
-                _yAxis.entries.removeAll(keepCapacity: true)
+                yAxis.entries.removeAll(keepCapacity: true)
             }
             else
             {
-                _yAxis.entries = [Double]()
-                _yAxis.entries.reserveCapacity(labelCount)
+                yAxis.entries = [Double]()
+                yAxis.entries.reserveCapacity(labelCount)
             }
             
             var v = yMin
             
             for (var i = 0; i < labelCount; i++)
             {
-                _yAxis.entries.append(v)
+                yAxis.entries.append(v)
                 v += step
             }
             
@@ -84,24 +86,24 @@ public class ChartYAxisRendererRadarChart: ChartYAxisRenderer
             // no forced count
             
             // clean old values
-            if (_yAxis.entries.count > 0)
+            if (yAxis.entries.count > 0)
             {
-                _yAxis.entries.removeAll(keepCapacity: false)
+                yAxis.entries.removeAll(keepCapacity: false)
             }
             
             // if the labels should only show min and max
-            if (_yAxis.isShowOnlyMinMaxEnabled)
+            if (yAxis.isShowOnlyMinMaxEnabled)
             {
-                _yAxis.entries = [Double]()
-                _yAxis.entries.append(yMin)
-                _yAxis.entries.append(yMax)
+                yAxis.entries = [Double]()
+                yAxis.entries.append(yMin)
+                yAxis.entries.append(yMax)
             }
             else
             {
                 let rawCount = Double(yMin) / interval
                 var first = rawCount < 0.0 ? floor(rawCount) * interval : ceil(rawCount) * interval;
                 
-                if (first < yMin && _yAxis.isStartAtZeroEnabled)
+                if (first < yMin && yAxis.isStartAtZeroEnabled)
                 { // Force the first label to be at the 0 (or smallest negative value)
                     first = yMin
                 }
@@ -121,63 +123,68 @@ public class ChartYAxisRendererRadarChart: ChartYAxisRenderer
                     ++n
                 }
                 
-                if (isnan(_yAxis.customAxisMax))
+                if (isnan(yAxis.customAxisMax))
                 {
                     n += 1
                 }
                 
-                if (_yAxis.entries.count < n)
+                if (yAxis.entries.count < n)
                 {
                     // Ensure stops contains at least numStops elements.
-                    _yAxis.entries = [Double](count: n, repeatedValue: 0.0)
+                    yAxis.entries = [Double](count: n, repeatedValue: 0.0)
                 }
                 
                 for (f = first, i = 0; i < n; f += interval, ++i)
                 {
-                    _yAxis.entries[i] = Double(f)
+                    yAxis.entries[i] = Double(f)
                 }
             }
         }
         
-        if !_yAxis.isStartAtZeroEnabled && _yAxis.entries[0] < yMin
+        if !yAxis.isStartAtZeroEnabled && yAxis.entries[0] < yMin
         {
             // If startAtZero is disabled, and the first label is lower that the axis minimum,
             // Then adjust the axis minimum
-            _yAxis.axisMinimum = _yAxis.entries[0]
+            yAxis.axisMinimum = yAxis.entries[0]
         }
-        _yAxis.axisMaximum = _yAxis.entries[_yAxis.entryCount - 1]
-        _yAxis.axisRange = abs(_yAxis.axisMaximum - _yAxis.axisMinimum)
+        yAxis.axisMaximum = yAxis.entries[yAxis.entryCount - 1]
+        yAxis.axisRange = abs(yAxis.axisMaximum - yAxis.axisMinimum)
     }
     
     public override func renderAxisLabels(context context: CGContext)
     {
-        if (!_yAxis.isEnabled || !_yAxis.isDrawLabelsEnabled)
+        guard let
+            yAxis = yAxis,
+            chart = chart
+            else { return }
+        
+        if (!yAxis.isEnabled || !yAxis.isDrawLabelsEnabled)
         {
             return
         }
         
-        let labelFont = _yAxis.labelFont
-        let labelTextColor = _yAxis.labelTextColor
+        let labelFont = yAxis.labelFont
+        let labelTextColor = yAxis.labelTextColor
         
-        let center = _chart.centerOffsets
-        let factor = _chart.factor
+        let center = chart.centerOffsets
+        let factor = chart.factor
         
-        let labelCount = _yAxis.entryCount
+        let labelCount = yAxis.entryCount
         
-        let labelLineHeight = _yAxis.labelFont.lineHeight
+        let labelLineHeight = yAxis.labelFont.lineHeight
         
         for (var j = 0; j < labelCount; j++)
         {
-            if (j == labelCount - 1 && _yAxis.isDrawTopYLabelEntryEnabled == false)
+            if (j == labelCount - 1 && yAxis.isDrawTopYLabelEntryEnabled == false)
             {
                 break
             }
             
-            let r = CGFloat(_yAxis.entries[j] - _yAxis.axisMinimum) * factor
+            let r = CGFloat(yAxis.entries[j] - yAxis.axisMinimum) * factor
             
-            let p = ChartUtils.getPosition(center: center, dist: r, angle: _chart.rotationAngle)
+            let p = ChartUtils.getPosition(center: center, dist: r, angle: chart.rotationAngle)
             
-            let label = _yAxis.getFormattedLabel(j)
+            let label = yAxis.getFormattedLabel(j)
             
             ChartUtils.drawText(context: context, text: label, point: CGPoint(x: p.x + 10.0, y: p.y - labelLineHeight), align: .Left, attributes: [NSFontAttributeName: labelFont, NSForegroundColorAttributeName: labelTextColor])
         }
@@ -185,7 +192,12 @@ public class ChartYAxisRendererRadarChart: ChartYAxisRenderer
     
     public override func renderLimitLines(context context: CGContext)
     {
-        var limitLines = _yAxis.limitLines
+        guard let
+            yAxis = yAxis,
+            chart = chart
+            else { return }
+        
+        var limitLines = yAxis.limitLines
         
         if (limitLines.count == 0)
         {
@@ -194,12 +206,12 @@ public class ChartYAxisRendererRadarChart: ChartYAxisRenderer
         
         CGContextSaveGState(context)
         
-        let sliceangle = _chart.sliceAngle
+        let sliceangle = chart.sliceAngle
         
         // calculate the factor that is needed for transforming the value to pixels
-        let factor = _chart.factor
+        let factor = chart.factor
         
-        let center = _chart.centerOffsets
+        let center = chart.centerOffsets
         
         for (var i = 0; i < limitLines.count; i++)
         {
@@ -221,13 +233,13 @@ public class ChartYAxisRendererRadarChart: ChartYAxisRenderer
                 CGContextSetLineDash(context, 0.0, nil, 0)
             }
             
-            let r = CGFloat(l.limit - _chart.chartYMin) * factor
+            let r = CGFloat(l.limit - chart.chartYMin) * factor
             
             CGContextBeginPath(context)
             
-            for (var j = 0, count = _chart.data!.xValCount; j < count; j++)
+            for (var j = 0, count = chart.data!.xValCount; j < count; j++)
             {
-                let p = ChartUtils.getPosition(center: center, dist: r, angle: sliceangle * CGFloat(j) + _chart.rotationAngle)
+                let p = ChartUtils.getPosition(center: center, dist: r, angle: sliceangle * CGFloat(j) + chart.rotationAngle)
                 
                 if (j == 0)
                 {
diff --git a/Charts/Classes/Renderers/CombinedChartRenderer.swift b/Charts/Classes/Renderers/CombinedChartRenderer.swift
index 54ac0354..82d81687 100644
--- a/Charts/Classes/Renderers/CombinedChartRenderer.swift
+++ b/Charts/Classes/Renderers/CombinedChartRenderer.swift
@@ -16,7 +16,7 @@ import CoreGraphics
 
 public class CombinedChartRenderer: ChartDataRendererBase
 {
-    internal weak var _chart: CombinedChartView!
+    public weak var chart: CombinedChartView?
     
     /// flag that enables or disables the highlighting arrow
     public var drawHighlightArrowEnabled = false
@@ -35,7 +35,7 @@ public class CombinedChartRenderer: ChartDataRendererBase
     {
         super.init(animator: animator, viewPortHandler: viewPortHandler)
         
-        _chart = chart
+        self.chart = chart
         
         createRenderers()
     }
@@ -44,43 +44,48 @@ public class CombinedChartRenderer: ChartDataRendererBase
     internal func createRenderers()
     {
         _renderers = [ChartDataRendererBase]()
+        
+        guard let
+            chart = chart,
+            animator = animator
+            else { return }
 
         for order in drawOrder
         {
             switch (order)
             {
             case .Bar:
-                if (_chart.barData !== nil)
+                if (chart.barData !== nil)
                 {
-                    _renderers.append(BarChartRenderer(dataProvider: _chart, animator: _animator, viewPortHandler: viewPortHandler))
+                    _renderers.append(BarChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
                 }
                 break
                 
             case .Line:
-                if (_chart.lineData !== nil)
+                if (chart.lineData !== nil)
                 {
-                    _renderers.append(LineChartRenderer(dataProvider: _chart, animator: _animator, viewPortHandler: viewPortHandler))
+                    _renderers.append(LineChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
                 }
                 break
                 
             case .Candle:
-                if (_chart.candleData !== nil)
+                if (chart.candleData !== nil)
                 {
-                    _renderers.append(CandleStickChartRenderer(dataProvider: _chart, animator: _animator, viewPortHandler: viewPortHandler))
+                    _renderers.append(CandleStickChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
                 }
                 break
                 
             case .Scatter:
-                if (_chart.scatterData !== nil)
+                if (chart.scatterData !== nil)
                 {
-                    _renderers.append(ScatterChartRenderer(dataProvider: _chart, animator: _animator, viewPortHandler: viewPortHandler))
+                    _renderers.append(ScatterChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
                 }
                 break
                 
             case .Bubble:
-                if (_chart.bubbleData !== nil)
+                if (chart.bubbleData !== nil)
                 {
-                    _renderers.append(BubbleChartRenderer(dataProvider: _chart, animator: _animator, viewPortHandler: viewPortHandler))
+                    _renderers.append(BubbleChartRenderer(dataProvider: chart, animator: animator, viewPortHandler: viewPortHandler))
                 }
                 break
             }
diff --git a/Charts/Classes/Renderers/HorizontalBarChartRenderer.swift b/Charts/Classes/Renderers/HorizontalBarChartRenderer.swift
index ba4bcc7d..11e874f9 100644
--- a/Charts/Classes/Renderers/HorizontalBarChartRenderer.swift
+++ b/Charts/Classes/Renderers/HorizontalBarChartRenderer.swift
@@ -22,9 +22,13 @@ public class HorizontalBarChartRenderer: BarChartRenderer
         super.init(dataProvider: dataProvider, animator: animator, viewPortHandler: viewPortHandler)
     }
     
-    internal override func drawDataSet(context context: CGContext, dataSet: IBarChartDataSet, index: Int)
+    public override func drawDataSet(context context: CGContext, dataSet: IBarChartDataSet, index: Int)
     {
-        guard let dataProvider = dataProvider, barData = dataProvider.barData else { return }
+        guard let
+            dataProvider = dataProvider,
+            barData = dataProvider.barData,
+            animator = animator
+            else { return }
         
         CGContextSaveGState(context)
         
@@ -39,13 +43,13 @@ public class HorizontalBarChartRenderer: BarChartRenderer
         let containsStacks = dataSet.isStacked
         let isInverted = dataProvider.isInverted(dataSet.axisDependency)
         let barWidth: CGFloat = 0.5
-        let phaseY = _animator.phaseY
+        let phaseY = animator.phaseY
         var barRect = CGRect()
         var barShadow = CGRect()
         var y: Double
         
         // do the drawing
-        for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * _animator.phaseX)); j < count; j++)
+        for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * animator.phaseX)); j < count; j++)
         {
             guard let e = dataSet.entryForIndex(j) as? BarChartDataEntry else { continue }
             
@@ -214,7 +218,7 @@ public class HorizontalBarChartRenderer: BarChartRenderer
         CGContextRestoreGState(context)
     }
     
-    internal override func prepareBarHighlight(x x: CGFloat, y1: Double, y2: Double, barspacehalf: CGFloat, trans: ChartTransformer, inout rect: CGRect)
+    public override func prepareBarHighlight(x x: CGFloat, y1: Double, y2: Double, barspacehalf: CGFloat, trans: ChartTransformer, inout rect: CGRect)
     {
         let barWidth: CGFloat = 0.5
         
@@ -228,7 +232,7 @@ public class HorizontalBarChartRenderer: BarChartRenderer
         rect.size.width = right - left
         rect.size.height = bottom - top
         
-        trans.rectValueToPixelHorizontal(&rect, phaseY: _animator.phaseY)
+        trans.rectValueToPixelHorizontal(&rect, phaseY: animator?.phaseY ?? 1.0)
     }
     
     public override func drawValues(context context: CGContext)
@@ -236,7 +240,11 @@ public class HorizontalBarChartRenderer: BarChartRenderer
         // if values are drawn
         if (passesCheck())
         {
-            guard let dataProvider = dataProvider, barData = dataProvider.barData else { return }
+            guard let
+                dataProvider = dataProvider,
+                barData = dataProvider.barData,
+                animator = animator
+                else { return }
             
             var dataSets = barData.dataSets
             
@@ -250,7 +258,7 @@ public class HorizontalBarChartRenderer: BarChartRenderer
             
             for (var dataSetIndex = 0, count = barData.dataSetCount; dataSetIndex < count; dataSetIndex++)
             {
-                let dataSet = dataSets[dataSetIndex] as! IBarChartDataSet
+                guard let dataSet = dataSets[dataSetIndex] as? IBarChartDataSet else { continue }
                 
                 if !dataSet.isDrawValuesEnabled || dataSet.entryCount == 0
                 {
@@ -263,18 +271,18 @@ public class HorizontalBarChartRenderer: BarChartRenderer
                 let valueTextColor = dataSet.valueTextColor
                 let yOffset = -valueFont.lineHeight / 2.0
                 
-                let formatter = dataSet.valueFormatter
+                guard let formatter = dataSet.valueFormatter else { continue }
                 
                 let trans = dataProvider.getTransformer(dataSet.axisDependency)
                 
-                let phaseY = _animator.phaseY
+                let phaseY = animator.phaseY
                 let dataSetCount = barData.dataSetCount
                 let groupSpace = barData.groupSpace
                 
                 // if only single values are drawn (sum)
                 if (!dataSet.isStacked)
                 {
-                    for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * _animator.phaseX)); j < count; j++)
+                    for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * animator.phaseX)); j < count; j++)
                     {
                         guard let e = dataSet.entryForIndex(j) as? BarChartDataEntry else { continue }
                         
@@ -296,7 +304,7 @@ public class HorizontalBarChartRenderer: BarChartRenderer
                         }
                         
                         let val = e.value
-                        let valueText = formatter!.stringFromNumber(val)!
+                        let valueText = formatter.stringFromNumber(val)!
                         
                         // calculate the correct offset depending on the draw position of the value
                         let valueTextWidth = valueText.sizeWithAttributes([NSFontAttributeName: valueFont]).width
@@ -323,7 +331,7 @@ public class HorizontalBarChartRenderer: BarChartRenderer
                 {
                     // if each value of a potential stack should be drawn
                     
-                    for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * _animator.phaseX)); j < count; j++)
+                    for (var j = 0, count = Int(ceil(CGFloat(dataSet.entryCount) * animator.phaseX)); j < count; j++)
                     {
                         guard let e = dataSet.entryForIndex(j) as? BarChartDataEntry else { continue }
                         
@@ -350,7 +358,7 @@ public class HorizontalBarChartRenderer: BarChartRenderer
                             }
                             
                             let val = e.value
-                            let valueText = formatter!.stringFromNumber(val)!
+                            let valueText = formatter.stringFromNumber(val)!
                             
                             // calculate the correct offset depending on the draw position of the value
                             let valueTextWidth = valueText.sizeWithAttributes([NSFontAttributeName: valueFont]).width
@@ -396,7 +404,7 @@ public class HorizontalBarChartRenderer: BarChartRenderer
                                     negY -= value
                                 }
                                 
-                                transformed.append(CGPoint(x: CGFloat(y) * _animator.phaseY, y: 0.0))
+                                transformed.append(CGPoint(x: CGFloat(y) * animator.phaseY, y: 0.0))
                             }
                             
                             trans.pointValuesToPixel(&transformed)
@@ -404,7 +412,7 @@ public class HorizontalBarChartRenderer: BarChartRenderer
                             for (var k = 0; k < transformed.count; k++)
                             {
                                 let val = vals[k]
-                                let valueText = formatter!.stringFromNumber(val)!
+                                let valueText = formatter.stringFromNumber(val)!
                                 
                                 // calculate the correct offset depending on the draw position of the value
                                 let valueTextWidth = valueText.sizeWithAttributes([NSFontAttributeName: valueFont]).width
diff --git a/Charts/Classes/Renderers/LineChartRenderer.swift b/Charts/Classes/Renderers/LineChartRenderer.swift
index cace7bcc..1ba6b844 100644
--- a/Charts/Classes/Renderers/LineChartRenderer.swift
+++ b/Charts/Classes/Renderers/LineChartRenderer.swift
@@ -36,29 +36,17 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
             
             if set.isVisible
             {
+                if !(set is ILineChartDataSet)
+                {
+                    fatalError("Datasets for LineChartRenderer must conform to ILineChartDataSet")
+                }
+                
                 drawDataSet(context: context, dataSet: set as! ILineChartDataSet)
             }
         }
     }
     
-    internal struct CGCPoint
-    {
-        internal var x: CGFloat = 0.0
-        internal var y: CGFloat = 0.0
-        
-        ///  x-axis distance
-        internal var dx: CGFloat = 0.0
-        ///  y-axis distance
-        internal var dy: CGFloat = 0.0
-        
-        internal init(x: CGFloat, y: CGFloat)
-        {
-            self.x = x
-            self.y = y
-        }
-    }
-    
-    internal func drawDataSet(context context: CGContext, dataSet: ILineChartDataSet)
+    public func drawDataSet(context context: CGContext, dataSet: ILineChartDataSet)
     {
         let entryCount = dataSet.entryCount
         
@@ -92,21 +80,26 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
         CGContextRestoreGState(context)
     }
     
-    internal func drawCubic(context context: CGContext, dataSet: ILineChartDataSet)
+    public func drawCubic(context context: CGContext, dataSet: ILineChartDataSet)
     {
-        let trans = dataProvider?.getTransformer(dataSet.axisDependency)
+        guard let
+            trans = dataProvider?.getTransformer(dataSet.axisDependency),
+            animator = animator
+            else { return }
         
         let entryCount = dataSet.entryCount
         
-        let entryFrom = dataSet.entryForXIndex(_minX)!
-        let entryTo = dataSet.entryForXIndex(_maxX)!
+        guard let
+            entryFrom = dataSet.entryForXIndex(self.minX),
+            entryTo = dataSet.entryForXIndex(self.maxX)
+            else { return }
         
         let diff = (entryFrom == entryTo) ? 1 : 0
         let minx = max(dataSet.entryIndex(entry: entryFrom) - diff, 0)
         let maxx = min(max(minx + 2, dataSet.entryIndex(entry: entryTo) + 1), entryCount)
         
-        let phaseX = _animator.phaseX
-        let phaseY = _animator.phaseY
+        let phaseX = animator.phaseX
+        let phaseY = animator.phaseY
         
         // get the color that is specified for this position from the DataSet
         let drawingColor = dataSet.colors.first!
@@ -116,7 +109,7 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
         // the path for the cubic-spline
         let cubicPath = CGPathCreateMutable()
         
-        var valueToPixelMatrix = trans!.valueToPixelMatrix
+        var valueToPixelMatrix = trans.valueToPixelMatrix
         
         let size = Int(ceil(CGFloat(maxx - minx) * phaseX + CGFloat(minx)))
         
@@ -204,7 +197,7 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
         CGContextRestoreGState(context)
     }
     
-    internal func drawCubicFill(context context: CGContext, dataSet: ILineChartDataSet, spline: CGMutablePath, matrix: CGAffineTransform, from: Int, to: Int)
+    public func drawCubicFill(context context: CGContext, dataSet: ILineChartDataSet, spline: CGMutablePath, matrix: CGAffineTransform, from: Int, to: Int)
     {
         guard let dataProvider = dataProvider else { return }
         
@@ -237,20 +230,26 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
     
     private var _lineSegments = [CGPoint](count: 2, repeatedValue: CGPoint())
     
-    internal func drawLinear(context context: CGContext, dataSet: ILineChartDataSet)
+    public func drawLinear(context context: CGContext, dataSet: ILineChartDataSet)
     {
-        guard let trans = dataProvider?.getTransformer(dataSet.axisDependency) else { return }
+        guard let
+            trans = dataProvider?.getTransformer(dataSet.axisDependency),
+            animator = animator
+            else { return }
+        
         let valueToPixelMatrix = trans.valueToPixelMatrix
         
         let entryCount = dataSet.entryCount
         
-        let phaseX = _animator.phaseX
-        let phaseY = _animator.phaseY
+        let phaseX = animator.phaseX
+        let phaseY = animator.phaseY
         
         CGContextSaveGState(context)
         
-        let entryFrom = dataSet.entryForXIndex(_minX)!
-        let entryTo = dataSet.entryForXIndex(_maxX)!
+        guard let
+            entryFrom = dataSet.entryForXIndex(self.minX),
+            entryTo = dataSet.entryForXIndex(self.maxX)
+            else { return }
         
         let diff = (entryFrom == entryTo) ? 1 : 0
         let minx = max(dataSet.entryIndex(entry: entryFrom) - diff, 0)
@@ -354,7 +353,7 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
         }
     }
     
-    internal func drawLinearFill(context context: CGContext, dataSet: ILineChartDataSet, minx: Int, maxx: Int, trans: ChartTransformer)
+    public func drawLinearFill(context context: CGContext, dataSet: ILineChartDataSet, minx: Int, maxx: Int, trans: ChartTransformer)
     {
         guard let dataProvider = dataProvider else { return }
         
@@ -382,8 +381,8 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
     /// Generates the path that is used for filled drawing.
     private func generateFilledPath(dataSet dataSet: ILineChartDataSet, fillMin: CGFloat, from: Int, to: Int, var matrix: CGAffineTransform) -> CGPath
     {
-        let phaseX = _animator.phaseX
-        let phaseY = _animator.phaseY
+        let phaseX = animator?.phaseX ?? 1.0
+        let phaseY = animator?.phaseY ?? 1.0
         
         var e: ChartDataEntry!
         
@@ -416,14 +415,18 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
     
     public override func drawValues(context context: CGContext)
     {
-        guard let dataProvider = dataProvider, lineData = dataProvider.lineData else { return }
+        guard let
+            dataProvider = dataProvider,
+            lineData = dataProvider.lineData,
+            animator = animator
+            else { return }
         
         if (CGFloat(lineData.yValCount) < CGFloat(dataProvider.maxVisibleValueCount) * viewPortHandler.scaleX)
         {
             var dataSets = lineData.dataSets
             
-            let phaseX = _animator.phaseX
-            let phaseY = _animator.phaseY
+            let phaseX = animator.phaseX
+            let phaseY = animator.phaseY
             
             var pt = CGPoint()
             
@@ -439,7 +442,7 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
                 let valueFont = dataSet.valueFont
                 let valueTextColor = dataSet.valueTextColor
                 
-                let formatter = dataSet.valueFormatter
+                guard let formatter = dataSet.valueFormatter else { continue }
                 
                 let trans = dataProvider.getTransformer(dataSet.axisDependency)
                 let valueToPixelMatrix = trans.valueToPixelMatrix
@@ -454,8 +457,10 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
                 
                 let entryCount = dataSet.entryCount
                 
-                let entryFrom = dataSet.entryForXIndex(_minX)!
-                let entryTo = dataSet.entryForXIndex(_maxX)!
+                guard let
+                    entryFrom = dataSet.entryForXIndex(self.minX),
+                    entryTo = dataSet.entryForXIndex(self.maxX)
+                    else { continue }
                 
                 let diff = (entryFrom == entryTo) ? 1 : 0
                 let minx = max(dataSet.entryIndex(entry: entryFrom) - diff, 0)
@@ -480,7 +485,7 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
                     }
                     
                     ChartUtils.drawText(context: context,
-                        text: formatter!.stringFromNumber(e.value)!,
+                        text: formatter.stringFromNumber(e.value)!,
                         point: CGPoint(
                             x: pt.x,
                             y: pt.y - CGFloat(valOffset) - valueFont.lineHeight),
@@ -498,10 +503,14 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
     
     private func drawCircles(context context: CGContext)
     {
-        guard let dataProvider = dataProvider, lineData = dataProvider.lineData else { return }
+        guard let
+            dataProvider = dataProvider,
+            lineData = dataProvider.lineData,
+            animator = animator
+            else { return }
         
-        let phaseX = _animator.phaseX
-        let phaseY = _animator.phaseY
+        let phaseX = animator.phaseX
+        let phaseY = animator.phaseY
         
         let dataSets = lineData.dataSets
         
@@ -512,7 +521,7 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
         
         for (var i = 0, count = dataSets.count; i < count; i++)
         {
-            let dataSet = lineData.getDataSetByIndex(i) as! ILineChartDataSet!
+            guard let dataSet = lineData.getDataSetByIndex(i) as? ILineChartDataSet else { continue }
             
             if !dataSet.isVisible || !dataSet.isDrawCirclesEnabled || dataSet.entryCount == 0
             {
@@ -530,8 +539,10 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
             let circleHoleRadius = circleHoleDiameter / 2.0
             let isDrawCircleHoleEnabled = dataSet.isDrawCircleHoleEnabled
             
-            let entryFrom = dataSet.entryForXIndex(_minX)!
-            let entryTo = dataSet.entryForXIndex(_maxX)!
+            guard let
+                entryFrom = dataSet.entryForXIndex(self.minX),
+                entryTo = dataSet.entryForXIndex(self.maxX)
+                else { continue }
             
             let diff = (entryFrom == entryTo) ? 1 : 0
             let minx = max(dataSet.entryIndex(entry: entryFrom) - diff, 0)
@@ -584,7 +595,11 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
     
     public override func drawHighlighted(context context: CGContext, indices: [ChartHighlight])
     {
-        guard let lineData = dataProvider?.lineData, chartXMax = dataProvider?.chartXMax else { return }
+        guard let
+            lineData = dataProvider?.lineData,
+            chartXMax = dataProvider?.chartXMax,
+            animator = animator
+            else { return }
         
         CGContextSaveGState(context)
         
@@ -610,7 +625,7 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
             
             let xIndex = indices[i].xIndex; // get the x-position
             
-            if (CGFloat(xIndex) > CGFloat(chartXMax) * _animator.phaseX)
+            if (CGFloat(xIndex) > CGFloat(chartXMax) * animator.phaseX)
             {
                 continue
             }
@@ -621,7 +636,7 @@ public class LineChartRenderer: LineScatterCandleRadarChartRenderer
                 continue
             }
             
-            let y = CGFloat(yValue) * _animator.phaseY; // get the y-position
+            let y = CGFloat(yValue) * animator.phaseY; // get the y-position
             
             _highlightPointBuffer.x = CGFloat(xIndex)
             _highlightPointBuffer.y = y
diff --git a/Charts/Classes/Renderers/PieChartRenderer.swift b/Charts/Classes/Renderers/PieChartRenderer.swift
index af0b8a3e..9436998d 100755
--- a/Charts/Classes/Renderers/PieChartRenderer.swift
+++ b/Charts/Classes/Renderers/PieChartRenderer.swift
@@ -17,7 +17,7 @@ import UIKit
 
 public class PieChartRenderer: ChartDataRendererBase
 {
-    internal weak var _chart: PieChartView!
+    public weak var chart: PieChartView?
     
     public var drawHoleEnabled = true
     public var holeTransparent = true
@@ -35,39 +35,44 @@ public class PieChartRenderer: ChartDataRendererBase
     {
         super.init(animator: animator, viewPortHandler: viewPortHandler)
         
-        _chart = chart
+        self.chart = chart
     }
     
     public override func drawData(context context: CGContext)
     {
-        if (_chart !== nil)
+        guard let chart = chart else { return }
+        
+        let pieData = chart.data
+        
+        if (pieData != nil)
         {
-            let pieData = _chart.data
-            
-            if (pieData != nil)
+            for set in pieData!.dataSets as! [IPieChartDataSet]
             {
-                for set in pieData!.dataSets as! [IPieChartDataSet]
+                if set.isVisible && set.entryCount > 0
                 {
-                    if set.isVisible && set.entryCount > 0
-                    {
-                        drawDataSet(context: context, dataSet: set)
-                    }
+                    drawDataSet(context: context, dataSet: set)
                 }
             }
         }
     }
     
-    internal func drawDataSet(context context: CGContext, dataSet: IPieChartDataSet)
+    public func drawDataSet(context context: CGContext, dataSet: IPieChartDataSet)
     {
+        guard let
+            chart = chart,
+            data = chart.data,
+            animator = animator
+            else {return }
+        
         var angle: CGFloat = 0.0
-        let rotationAngle = _chart.rotationAngle
+        let rotationAngle = chart.rotationAngle
         
         var cnt = 0
         
         let entryCount = dataSet.entryCount
-        var drawAngles = _chart.drawAngles
-        let circleBox = _chart.circleBox
-        let radius = _chart.radius
+        var drawAngles = chart.drawAngles
+        let circleBox = chart.circleBox
+        let radius = chart.radius
         let innerRadius = drawHoleEnabled && holeTransparent ? radius * holeRadiusPercent : 0.0
         
         CGContextSaveGState(context)
@@ -82,11 +87,11 @@ public class PieChartRenderer: ChartDataRendererBase
             // draw only if the value is greater than zero
             if ((abs(e.value) > 0.000001))
             {
-                if (!_chart.needsHighlight(xIndex: e.xIndex,
-                    dataSetIndex: _chart.data!.indexOfDataSet(dataSet)))
+                if (!chart.needsHighlight(xIndex: e.xIndex,
+                    dataSetIndex: data.indexOfDataSet(dataSet)))
                 {
-                    let startAngle = rotationAngle + (angle + sliceSpace / 2.0) * _animator.phaseY
-                    var sweepAngle = (sliceAngle - sliceSpace / 2.0) * _animator.phaseY
+                    let startAngle = rotationAngle + (angle + sliceSpace / 2.0) * animator.phaseY
+                    var sweepAngle = (sliceAngle - sliceSpace / 2.0) * animator.phaseY
                     if (sweepAngle < 0.0)
                     {
                         sweepAngle = 0.0
@@ -112,7 +117,7 @@ public class PieChartRenderer: ChartDataRendererBase
                 }
             }
             
-            angle += sliceAngle * _animator.phaseX
+            angle += sliceAngle * animator.phaseX
             cnt++
         }
         
@@ -121,25 +126,29 @@ public class PieChartRenderer: ChartDataRendererBase
     
     public override func drawValues(context context: CGContext)
     {
-        let center = _chart.centerCircleBox
+        guard let
+            chart = chart,
+            data = chart.data,
+            animator = animator
+            else { return }
+        
+        let center = chart.centerCircleBox
         
         // get whole the radius
-        var r = _chart.radius
-        let rotationAngle = _chart.rotationAngle
-        var drawAngles = _chart.drawAngles
-        var absoluteAngles = _chart.absoluteAngles
+        var r = chart.radius
+        let rotationAngle = chart.rotationAngle
+        var drawAngles = chart.drawAngles
+        var absoluteAngles = chart.absoluteAngles
         
         var off = r / 10.0 * 3.0
         
         if (drawHoleEnabled)
         {
-            off = (r - (r * _chart.holeRadiusPercent)) / 2.0
+            off = (r - (r * chart.holeRadiusPercent)) / 2.0
         }
         
         r -= off; // offset to keep things inside the chart
         
-        guard let data = _chart.data else { return }
-        
         var dataSets = data.dataSets
         
         let yValueSum = (data as! PieChartData).yValueSum
@@ -162,9 +171,9 @@ public class PieChartRenderer: ChartDataRendererBase
             let valueFont = dataSet.valueFont
             let valueTextColor = dataSet.valueTextColor
             
-            let formatter = dataSet.valueFormatter
+            guard let formatter = dataSet.valueFormatter else { continue }
             
-            for (var j = 0, maxEntry = Int(min(ceil(CGFloat(dataSet.entryCount) * _animator.phaseX), CGFloat(dataSet.entryCount))); j < maxEntry; j++)
+            for (var j = 0, maxEntry = Int(min(ceil(CGFloat(dataSet.entryCount) * animator.phaseX), CGFloat(dataSet.entryCount))); j < maxEntry; j++)
             {
                 if (drawXVals && !drawYVals && (j >= data.xValCount || data.xVals[j] == nil))
                 {
@@ -176,7 +185,7 @@ public class PieChartRenderer: ChartDataRendererBase
                 // offset needed to center the drawn text in the slice
                 let offset = drawAngles[cnt] / 2.0
                 
-                let angle = (absoluteAngles[cnt] - offset) * _animator.phaseY
+                let angle = (absoluteAngles[cnt] - offset) * animator.phaseY
 
                 // calculate the text position
                 let x = r
@@ -188,7 +197,7 @@ public class PieChartRenderer: ChartDataRendererBase
 
                 let value = usePercentValuesEnabled ? e.value / yValueSum * 100.0 : e.value
                 
-                let val = formatter!.stringFromNumber(value)!
+                let val = formatter.stringFromNumber(value)!
                 
                 let lineHeight = valueFont.lineHeight
                 y -= lineHeight
@@ -226,13 +235,18 @@ public class PieChartRenderer: ChartDataRendererBase
     /// draws the hole in the center of the chart and the transparent circle / hole
     private func drawHole(context context: CGContext)
     {
-        if (_chart.drawHoleEnabled)
+        guard let
+            chart = chart,
+            animator = animator
+            else { return }
+        
+        if (chart.drawHoleEnabled)
         {
             CGContextSaveGState(context)
             
-            let radius = _chart.radius
+            let radius = chart.radius
             let holeRadius = radius * holeRadiusPercent
-            let center = _chart.centerCircleBox
+            let center = chart.centerCircleBox
             
             if (holeColor !== nil && holeColor != UIColor.clearColor())
             {
@@ -244,7 +258,7 @@ public class PieChartRenderer: ChartDataRendererBase
             // only draw the circle if it can be seen (not covered by the hole)
             if (transparentCircleRadiusPercent > holeRadiusPercent)
             {
-                let alpha = holeAlpha * _animator.phaseX * _animator.phaseY
+                let alpha = holeAlpha * animator.phaseX * animator.phaseY
                 let secondHoleRadius = radius * transparentCircleRadiusPercent
                 
                 // make transparent
@@ -261,12 +275,15 @@ public class PieChartRenderer: ChartDataRendererBase
     /// draws the description text in the center of the pie chart makes most sense when center-hole is enabled
     private func drawCenterText(context context: CGContext)
     {
-        guard let centerAttributedText = centerAttributedText else { return }
+        guard let
+            chart = chart,
+            centerAttributedText = centerAttributedText
+            else { return }
         
         if drawCenterTextEnabled && centerAttributedText.length > 0
         {
-            let center = _chart.centerCircleBox
-            let innerRadius = drawHoleEnabled && holeTransparent ? _chart.radius * holeRadiusPercent : _chart.radius
+            let center = chart.centerCircleBox
+            let innerRadius = drawHoleEnabled && holeTransparent ? chart.radius * holeRadiusPercent : chart.radius
             let holeRect = CGRect(x: center.x - innerRadius, y: center.y - innerRadius, width: innerRadius * 2.0, height: innerRadius * 2.0)
             var boundingRect = holeRect
             
@@ -297,20 +314,21 @@ public class PieChartRenderer: ChartDataRendererBase
     
     public override func drawHighlighted(context context: CGContext, indices: [ChartHighlight])
     {
-        if _chart.data == nil
-        {
-            return
-        }
+        guard let
+            chart = chart,
+            data = chart.data,
+            animator = animator
+            else { return }
         
         CGContextSaveGState(context)
         
         var angle: CGFloat = 0.0
-        let rotationAngle = _chart.rotationAngle
+        let rotationAngle = chart.rotationAngle
         
-        var drawAngles = _chart.drawAngles
-        var absoluteAngles = _chart.absoluteAngles
+        var drawAngles = chart.drawAngles
+        var absoluteAngles = chart.absoluteAngles
         
-        let innerRadius = drawHoleEnabled && holeTransparent ? _chart.radius * holeRadiusPercent : 0.0
+        let innerRadius = drawHoleEnabled && holeTransparent ? chart.radius * holeRadiusPercent : 0.0
         
         for (var i = 0; i < indices.count; i++)
         {
@@ -321,7 +339,7 @@ public class PieChartRenderer: ChartDataRendererBase
                 continue
             }
             
-            guard let set = _chart.data?.getDataSetByIndex(indices[i].dataSetIndex) as? IPieChartDataSet else { continue }
+            guard let set = data.getDataSetByIndex(indices[i].dataSetIndex) as? IPieChartDataSet else { continue }
             
             if !set.isHighlightEnabled
             {
@@ -334,14 +352,14 @@ public class PieChartRenderer: ChartDataRendererBase
             }
             else
             {
-                angle = absoluteAngles[xIndex - 1] * _animator.phaseX
+                angle = absoluteAngles[xIndex - 1] * animator.phaseX
             }
             
             let sliceAngle = drawAngles[xIndex]
             let sliceSpace = set.sliceSpace
             
             let shift = set.selectionShift
-            let circleBox = _chart.circleBox
+            let circleBox = chart.circleBox
             
             let highlighted = CGRect(
                 x: circleBox.origin.x - shift,
@@ -353,8 +371,8 @@ public class PieChartRenderer: ChartDataRendererBase
             
             // redefine the rect that contains the arc so that the highlighted pie is not cut off
             
-            let startAngle = rotationAngle + (angle + sliceSpace / 2.0) * _animator.phaseY
-            var sweepAngle = (sliceAngle - sliceSpace / 2.0) * _animator.phaseY
+            let startAngle = rotationAngle + (angle + sliceSpace / 2.0) * animator.phaseY
+            var sweepAngle = (sliceAngle - sliceSpace / 2.0) * animator.phaseY
             if (sweepAngle < 0.0)
             {
                 sweepAngle = 0.0
diff --git a/Charts/Classes/Renderers/RadarChartRenderer.swift b/Charts/Classes/Renderers/RadarChartRenderer.swift
index 6dd9d782..2e6e53a6 100644
--- a/Charts/Classes/Renderers/RadarChartRenderer.swift
+++ b/Charts/Classes/Renderers/RadarChartRenderer.swift
@@ -17,29 +17,28 @@ import UIKit
 
 public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
 {
-    internal weak var _chart: RadarChartView!
+    public weak var chart: RadarChartView?
 
     public init(chart: RadarChartView, animator: ChartAnimator?, viewPortHandler: ChartViewPortHandler)
     {
         super.init(animator: animator, viewPortHandler: viewPortHandler)
         
-        _chart = chart
+        self.chart = chart
     }
     
     public override func drawData(context context: CGContext)
     {
-        if (_chart !== nil)
+        guard let chart = chart else { return }
+        
+        let radarData = chart.data
+        
+        if (radarData != nil)
         {
-            let radarData = _chart.data
-            
-            if (radarData != nil)
+            for set in radarData!.dataSets as! [IRadarChartDataSet]
             {
-                for set in radarData!.dataSets as! [IRadarChartDataSet]
+                if set.isVisible && set.entryCount > 0
                 {
-                    if set.isVisible && set.entryCount > 0
-                    {
-                        drawDataSet(context: context, dataSet: set)
-                    }
+                    drawDataSet(context: context, dataSet: set)
                 }
             }
         }
@@ -47,14 +46,16 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
     
     internal func drawDataSet(context context: CGContext, dataSet: IRadarChartDataSet)
     {
+        guard let chart = chart else { return }
+        
         CGContextSaveGState(context)
         
-        let sliceangle = _chart.sliceAngle
+        let sliceangle = chart.sliceAngle
         
         // calculate the factor that is needed for transforming the value to pixels
-        let factor = _chart.factor
+        let factor = chart.factor
         
-        let center = _chart.centerOffsets
+        let center = chart.centerOffsets
         let entryCount = dataSet.entryCount
         let path = CGPathCreateMutable()
         var hasMovedToPoint = false
@@ -63,7 +64,7 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
         {
             guard let e = dataSet.entryForIndex(j) else { continue }
             
-            let p = ChartUtils.getPosition(center: center, dist: CGFloat(e.value - _chart.chartYMin) * factor, angle: sliceangle * CGFloat(j) + _chart.rotationAngle)
+            let p = ChartUtils.getPosition(center: center, dist: CGFloat(e.value - chart.chartYMin) * factor, angle: sliceangle * CGFloat(j) + chart.rotationAngle)
             
             if (p.x.isNaN)
             {
@@ -111,19 +112,17 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
     
     public override func drawValues(context context: CGContext)
     {
-        if _chart.data == nil
-        {
-            return
-        }
+        guard let
+            chart = chart,
+            data = chart.data
+            else { return }
         
-        let data = _chart.data!
-        
-        let sliceangle = _chart.sliceAngle
+        let sliceangle = chart.sliceAngle
         
         // calculate the factor that is needed for transforming the value to pixels
-        let factor = _chart.factor
+        let factor = chart.factor
         
-        let center = _chart.centerOffsets
+        let center = chart.centerOffsets
         
         let yoffset = CGFloat(5.0)
         
@@ -142,14 +141,14 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
             {
                 guard let e = dataSet.entryForIndex(j) else { continue }
                 
-                let p = ChartUtils.getPosition(center: center, dist: CGFloat(e.value) * factor, angle: sliceangle * CGFloat(j) + _chart.rotationAngle)
+                let p = ChartUtils.getPosition(center: center, dist: CGFloat(e.value) * factor, angle: sliceangle * CGFloat(j) + chart.rotationAngle)
                 
                 let valueFont = dataSet.valueFont
                 let valueTextColor = dataSet.valueTextColor
                 
-                let formatter = dataSet.valueFormatter
+                guard let formatter = dataSet.valueFormatter else { continue }
                 
-                ChartUtils.drawText(context: context, text: formatter!.stringFromNumber(e.value)!, point: CGPoint(x: p.x, y: p.y - yoffset - valueFont.lineHeight), align: .Center, attributes: [NSFontAttributeName: valueFont, NSForegroundColorAttributeName: valueTextColor])
+                ChartUtils.drawText(context: context, text: formatter.stringFromNumber(e.value)!, point: CGPoint(x: p.x, y: p.y - yoffset - valueFont.lineHeight), align: .Center, attributes: [NSFontAttributeName: valueFont, NSForegroundColorAttributeName: valueTextColor])
             }
         }
     }
@@ -161,29 +160,34 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
     
     private var _webLineSegmentsBuffer = [CGPoint](count: 2, repeatedValue: CGPoint())
     
-    internal func drawWeb(context context: CGContext)
+    public func drawWeb(context context: CGContext)
     {
-        let sliceangle = _chart.sliceAngle
+        guard let
+            chart = chart,
+            data = chart.data
+            else { return }
+        
+        let sliceangle = chart.sliceAngle
         
         CGContextSaveGState(context)
         
         // calculate the factor that is needed for transforming the value to
         // pixels
-        let factor = _chart.factor
-        let rotationangle = _chart.rotationAngle
+        let factor = chart.factor
+        let rotationangle = chart.rotationAngle
         
-        let center = _chart.centerOffsets
+        let center = chart.centerOffsets
         
         // draw the web lines that come from the center
-        CGContextSetLineWidth(context, _chart.webLineWidth)
-        CGContextSetStrokeColorWithColor(context, _chart.webColor.CGColor)
-        CGContextSetAlpha(context, _chart.webAlpha)
+        CGContextSetLineWidth(context, chart.webLineWidth)
+        CGContextSetStrokeColorWithColor(context, chart.webColor.CGColor)
+        CGContextSetAlpha(context, chart.webAlpha)
         
-        let xIncrements = 1 + _chart.skipWebLineCount
+        let xIncrements = 1 + chart.skipWebLineCount
         
-        for var i = 0, xValCount = _chart.data!.xValCount; i < xValCount; i += xIncrements
+        for var i = 0, xValCount = data.xValCount; i < xValCount; i += xIncrements
         {
-            let p = ChartUtils.getPosition(center: center, dist: CGFloat(_chart.yRange) * factor, angle: sliceangle * CGFloat(i) + rotationangle)
+            let p = ChartUtils.getPosition(center: center, dist: CGFloat(chart.yRange) * factor, angle: sliceangle * CGFloat(i) + rotationangle)
             
             _webLineSegmentsBuffer[0].x = center.x
             _webLineSegmentsBuffer[0].y = center.y
@@ -194,17 +198,17 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
         }
         
         // draw the inner-web
-        CGContextSetLineWidth(context, _chart.innerWebLineWidth)
-        CGContextSetStrokeColorWithColor(context, _chart.innerWebColor.CGColor)
-        CGContextSetAlpha(context, _chart.webAlpha)
+        CGContextSetLineWidth(context, chart.innerWebLineWidth)
+        CGContextSetStrokeColorWithColor(context, chart.innerWebColor.CGColor)
+        CGContextSetAlpha(context, chart.webAlpha)
         
-        let labelCount = _chart.yAxis.entryCount
+        let labelCount = chart.yAxis.entryCount
         
         for (var j = 0; j < labelCount; j++)
         {
-            for (var i = 0, xValCount = _chart.data!.xValCount; i < xValCount; i++)
+            for (var i = 0, xValCount = data.xValCount; i < xValCount; i++)
             {
-                let r = CGFloat(_chart.yAxis.entries[j] - _chart.chartYMin) * factor
+                let r = CGFloat(chart.yAxis.entries[j] - chart.chartYMin) * factor
 
                 let p1 = ChartUtils.getPosition(center: center, dist: r, angle: sliceangle * CGFloat(i) + rotationangle)
                 let p2 = ChartUtils.getPosition(center: center, dist: r, angle: sliceangle * CGFloat(i + 1) + rotationangle)
@@ -225,12 +229,10 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
 
     public override func drawHighlighted(context context: CGContext, indices: [ChartHighlight])
     {
-        if _chart.data == nil
-        {
-            return
-        }
-        
-        let data = _chart.data as! RadarChartData
+        guard let
+            chart = chart,
+            data = chart.data as? RadarChartData
+            else { return }
         
         CGContextSaveGState(context)
         CGContextSetLineWidth(context, data.highlightLineWidth)
@@ -243,14 +245,14 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
             CGContextSetLineDash(context, 0.0, nil, 0)
         }
         
-        let sliceangle = _chart.sliceAngle
-        let factor = _chart.factor
+        let sliceangle = chart.sliceAngle
+        let factor = chart.factor
         
-        let center = _chart.centerOffsets
+        let center = chart.centerOffsets
         
         for (var i = 0; i < indices.count; i++)
         {
-            guard let set = _chart.data?.getDataSetByIndex(indices[i].dataSetIndex) as? IRadarChartDataSet else { continue }
+            guard let set = chart.data?.getDataSetByIndex(indices[i].dataSetIndex) as? IRadarChartDataSet else { continue }
             
             if !set.isHighlightEnabled
             {
@@ -269,7 +271,7 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
             }
             
             let j = set.entryIndex(entry: e!)
-            let y = (e!.value - _chart.chartYMin)
+            let y = (e!.value - chart.chartYMin)
             
             if (y.isNaN)
             {
@@ -277,7 +279,7 @@ public class RadarChartRenderer: LineScatterCandleRadarChartRenderer
             }
             
             _highlightPointBuffer = ChartUtils.getPosition(center: center, dist: CGFloat(y) * factor,
-                angle: sliceangle * CGFloat(j) + _chart.rotationAngle)
+                angle: sliceangle * CGFloat(j) + chart.rotationAngle)
             
             // draw the lines
             drawHighlightLines(context: context, point: _highlightPointBuffer, set: set)
diff --git a/Charts/Classes/Renderers/ScatterChartRenderer.swift b/Charts/Classes/Renderers/ScatterChartRenderer.swift
index 64e37e7f..355f08fd 100644
--- a/Charts/Classes/Renderers/ScatterChartRenderer.swift
+++ b/Charts/Classes/Renderers/ScatterChartRenderer.swift
@@ -32,10 +32,15 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
         
         for (var i = 0; i < scatterData.dataSetCount; i++)
         {
-            let set = scatterData.getDataSetByIndex(i)
+            guard let set = scatterData.getDataSetByIndex(i) else { continue }
             
-            if (set !== nil && set!.isVisible)
+            if set.isVisible
             {
+                if !(set is IScatterChartDataSet)
+                {
+                    fatalError("Datasets for ScatterChartRenderer must conform to IScatterChartDataSet")
+                }
+                
                 drawDataSet(context: context, dataSet: set as! IScatterChartDataSet)
             }
         }
@@ -43,13 +48,16 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
     
     private var _lineSegments = [CGPoint](count: 2, repeatedValue: CGPoint())
     
-    internal func drawDataSet(context context: CGContext, dataSet: IScatterChartDataSet)
+    public func drawDataSet(context context: CGContext, dataSet: IScatterChartDataSet)
     {
-        guard let dataProvider = dataProvider else { return }
+        guard let
+            dataProvider = dataProvider,
+            animator = animator
+            else { return }
         
         let trans = dataProvider.getTransformer(dataSet.axisDependency)
         
-        let phaseY = _animator.phaseY
+        let phaseY = animator.phaseY
         
         let entryCount = dataSet.entryCount
         
@@ -64,7 +72,7 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
         
         CGContextSaveGState(context)
         
-        for (var j = 0, count = Int(min(ceil(CGFloat(entryCount) * _animator.phaseX), CGFloat(entryCount))); j < count; j++)
+        for (var j = 0, count = Int(min(ceil(CGFloat(entryCount) * animator.phaseX), CGFloat(entryCount))); j < count; j++)
         {
             guard let e = dataSet.entryForIndex(j) else { continue }
             
@@ -158,15 +166,19 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
     
     public override func drawValues(context context: CGContext)
     {
-        guard let dataProvider = dataProvider, scatterData = dataProvider.scatterData else { return }
+        guard let
+            dataProvider = dataProvider,
+            scatterData = dataProvider.scatterData,
+            animator = animator
+            else { return }
         
         // if values are drawn
         if (scatterData.yValCount < Int(ceil(CGFloat(dataProvider.maxVisibleValueCount) * viewPortHandler.scaleX)))
         {
-            var dataSets = scatterData.dataSets as! [IScatterChartDataSet]
+            guard let dataSets = scatterData.dataSets as? [IScatterChartDataSet] else { return }
             
-            let phaseX = _animator.phaseX
-            let phaseY = _animator.phaseY
+            let phaseX = animator.phaseX
+            let phaseY = animator.phaseY
             
             var pt = CGPoint()
             
@@ -182,7 +194,7 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
                 let valueFont = dataSet.valueFont
                 let valueTextColor = dataSet.valueTextColor
                 
-                let formatter = dataSet.valueFormatter
+                guard let formatter = dataSet.valueFormatter else { continue }
                 
                 let trans = dataProvider.getTransformer(dataSet.axisDependency)
                 let valueToPixelMatrix = trans.valueToPixelMatrix
@@ -212,7 +224,7 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
                         continue
                     }
                     
-                    let text = formatter!.stringFromNumber(e.value)
+                    let text = formatter.stringFromNumber(e.value)
                     
                     ChartUtils.drawText(
                         context: context,
@@ -236,7 +248,11 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
     
     public override func drawHighlighted(context context: CGContext, indices: [ChartHighlight])
     {
-        guard let dataProvider = dataProvider, scatterData = dataProvider.scatterData else { return }
+        guard let
+            dataProvider = dataProvider,
+            scatterData = dataProvider.scatterData,
+            animator = animator
+            else { return }
         
         let chartXMax = dataProvider.chartXMax
         
@@ -264,7 +280,7 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
             
             let xIndex = indices[i].xIndex; // get the x-position
             
-            if (CGFloat(xIndex) > CGFloat(chartXMax) * _animator.phaseX)
+            if (CGFloat(xIndex) > CGFloat(chartXMax) * animator.phaseX)
             {
                 continue
             }
@@ -275,7 +291,7 @@ public class ScatterChartRenderer: LineScatterCandleRadarChartRenderer
                 continue
             }
             
-            let y = CGFloat(yVal) * _animator.phaseY; // get the y-position
+            let y = CGFloat(yVal) * animator.phaseY; // get the y-position
             
             _highlightPointBuffer.x = CGFloat(xIndex)
             _highlightPointBuffer.y = y
