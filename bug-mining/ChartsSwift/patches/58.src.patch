diff --git a/Charts/Charts.xcodeproj/project.pbxproj b/Charts/Charts.xcodeproj/project.pbxproj
index 2bbe342e..a24efe23 100644
--- a/Charts/Charts.xcodeproj/project.pbxproj
+++ b/Charts/Charts.xcodeproj/project.pbxproj
@@ -174,6 +174,7 @@
 		5BD4C5821BCDBF6C00462351 /* ScatterChartDataProvider.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5BD4C57B1BCDBF6C00462351 /* ScatterChartDataProvider.swift */; };
 		5BD8F06D1AB897D500566E05 /* ViewPortHandler.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5BD8F06C1AB897D500566E05 /* ViewPortHandler.swift */; };
 		5BD8F06E1AB89AD800566E05 /* HorizontalBarChartView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5B6A54A01AA66B6A000F57C2 /* HorizontalBarChartView.swift */; };
+		5BDFEF241D6093F0000A869A /* LegendEntry.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5BDFEF231D6093F0000A869A /* LegendEntry.swift */; };
 		5BE377E01D44A17A006EB34F /* IAxisValueFormatter.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5BE377DF1D44A17A006EB34F /* IAxisValueFormatter.swift */; };
 		5BE377E91D44D6D0006EB34F /* ChartDataEntryBase.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5BE377E81D44D6D0006EB34F /* ChartDataEntryBase.swift */; };
 		5BE377EA1D44D6D0006EB34F /* ChartDataEntryBase.swift in Sources */ = {isa = PBXBuildFile; fileRef = 5BE377E81D44D6D0006EB34F /* ChartDataEntryBase.swift */; };
@@ -539,6 +540,7 @@
 		5BD4C57A1BCDBF6C00462351 /* LineChartDataProvider.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = LineChartDataProvider.swift; sourceTree = "<group>"; };
 		5BD4C57B1BCDBF6C00462351 /* ScatterChartDataProvider.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ScatterChartDataProvider.swift; sourceTree = "<group>"; };
 		5BD8F06C1AB897D500566E05 /* ViewPortHandler.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ViewPortHandler.swift; sourceTree = "<group>"; };
+		5BDFEF231D6093F0000A869A /* LegendEntry.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = LegendEntry.swift; sourceTree = "<group>"; };
 		5BE377DF1D44A17A006EB34F /* IAxisValueFormatter.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = IAxisValueFormatter.swift; sourceTree = "<group>"; };
 		5BE377E81D44D6D0006EB34F /* ChartDataEntryBase.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = ChartDataEntryBase.swift; sourceTree = "<group>"; };
 		659400871BF463C1004F9C27 /* BarChartData.swift */ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = sourcecode.swift; path = BarChartData.swift; sourceTree = "<group>"; };
@@ -808,6 +810,7 @@
 				5B6556F61AB72BA000FFBFD3 /* ChartComponentBase.swift */,
 				5BA8EC6B1A9D151C00CE82E1 /* ChartLegend.swift */,
 				5BA8EC6C1A9D151C00CE82E1 /* ChartLimitLine.swift */,
+				5BDFEF231D6093F0000A869A /* LegendEntry.swift */,
 				5B6A546A1AA5C23F000F57C2 /* IMarker.swift */,
 				5B613DAE1D526BBF000F1E98 /* MarkerImage.swift */,
 				5B613DAA1D526B60000F1E98 /* MarkerView.swift */,
@@ -1200,6 +1203,7 @@
 				5B4AC1CA1C58A2B90028D1A6 /* Fill.swift in Sources */,
 				65B3F6321C739F7F000983D0 /* Platform.swift in Sources */,
 				5BD4C5811BCDBF6C00462351 /* LineChartDataProvider.swift in Sources */,
+				5BDFEF241D6093F0000A869A /* LegendEntry.swift in Sources */,
 				659400AC1BF463C1004F9C27 /* BubbleChartDataEntry.swift in Sources */,
 				5B613DE91D5A069F000F1E98 /* DefaultValueFormatter.swift in Sources */,
 				5B6A54851AA669C9000F57C2 /* ScatterChartRenderer.swift in Sources */,
diff --git a/Charts/Classes/Components/ChartLegend.swift b/Charts/Classes/Components/ChartLegend.swift
index 7aab00f8..ee46763e 100644
--- a/Charts/Classes/Components/ChartLegend.swift
+++ b/Charts/Classes/Components/ChartLegend.swift
@@ -42,8 +42,22 @@ public class ChartLegend: ChartComponentBase
     @objc(ChartLegendForm)
     public enum Form: Int
     {
+        /// Avoid drawing a form
+        case None
+        
+        /// Do not draw the a form, but leave space for it
+        case Empty
+        
+        /// Use default (default dataset's form to the legend's form)
+        case Default
+        
+        /// Draw a square
         case Square
+        
+        /// Draw a circle
         case Circle
+        
+        /// Draw a horizontal line
         case Line
     }
     
@@ -76,21 +90,13 @@ public class ChartLegend: ChartComponentBase
         case LeftToRight
         case RightToLeft
     }
-
-    /// the legend colors array, each color is for the form drawn at the same index
-    public var colors = [NSUIColor?]()
     
-    // the legend text array. a nil label will start a group.
-    public var labels = [String?]()
+    /// The legend entries array
+    public var entries = [LegendEntry]()
     
-    internal var _extraColors = [NSUIColor?]()
-    internal var _extraLabels = [String?]()
-    
-    /// colors that will be appended to the end of the colors array after calculating the legend.
-    public var extraColors: [NSUIColor?] { return _extraColors; }
-    
-    /// labels that will be appended to the end of the labels array after calculating the legend. a nil label will start a group.
-    public var extraLabels: [String?] { return _extraLabels; }
+    /// Entries that will be appended to the end of the auto calculated entries after calculating the legend.
+    /// (if the legend has already been calculated, you will need to call notifyDataSetChanged() to let the changes take effect)
+    public var extraEntries = [LegendEntry]()
     
     /// Are the legend labels/colors a custom value or auto calculated? If false, then it's auto, if true, then custom.
     /// 
@@ -193,8 +199,13 @@ public class ChartLegend: ChartComponentBase
     public var font: NSUIFont = NSUIFont.systemFontOfSize(10.0)
     public var textColor = NSUIColor.blackColor()
 
+    /// The form/shape of the legend forms
     public var form = Form.Square
+    
+    /// The size of the legend forms
     public var formSize = CGFloat(8.0)
+    
+    /// The line width for forms that consist of lines
     public var formLineWidth = CGFloat(1.5)
     
     public var xEntrySpace = CGFloat(6.0)
@@ -214,20 +225,11 @@ public class ChartLegend: ChartComponentBase
         self.yOffset = 3.0
     }
     
-    public init(colors: [NSUIColor?], labels: [String?])
-    {
-        super.init()
-        
-        self.colors = colors
-        self.labels = labels
-    }
-    
-    public init(colors: [NSObject], labels: [NSObject])
+    public init(entries: [LegendEntry])
     {
         super.init()
         
-        self.colorsObjc = colors
-        self.labelsObjc = labels
+        self.entries = entries
     }
     
     public func getMaximumEntrySize(font: NSUIFont) -> CGSize
@@ -235,15 +237,20 @@ public class ChartLegend: ChartComponentBase
         var maxW = CGFloat(0.0)
         var maxH = CGFloat(0.0)
         
-        var labels = self.labels
-        for i in 0 ..< labels.count
+        var maxFormSize: CGFloat = 0.0
+
+        for entry in entries
         {
-            if (labels[i] == nil)
+            let formSize = isnan(entry.formSize) ? self.formSize : entry.formSize
+            if formSize > maxFormSize
             {
-                continue
+                maxFormSize = formSize
             }
             
-            let size = (labels[i] as NSString!).sizeWithAttributes([NSFontAttributeName: font])
+            guard let label = entry.label
+                else { continue }
+            
+            let size = (label as NSString!).sizeWithAttributes([NSFontAttributeName: font])
             
             if (size.width > maxW)
             {
@@ -256,15 +263,10 @@ public class ChartLegend: ChartComponentBase
         }
         
         return CGSize(
-            width: maxW + formSize + formToTextSpace,
+            width: maxW + maxFormSize + formToTextSpace,
             height: maxH
         )
     }
-    
-    public func getLabel(index: Int) -> String?
-    {
-        return labels[index]
-    }
 
     public var neededWidth = CGFloat(0.0)
     public var neededHeight = CGFloat(0.0)
@@ -291,6 +293,15 @@ public class ChartLegend: ChartComponentBase
     public func calculateDimensions(labelFont labelFont: NSUIFont, viewPortHandler: ViewPortHandler)
     {
         let maxEntrySize = getMaximumEntrySize(labelFont)
+        let defaultFormSize = self.formSize
+        let stackSpace = self.stackSpace
+        let formToTextSpace = self.formToTextSpace
+        let xEntrySpace = self.xEntrySpace
+        let yEntrySpace = self.yEntrySpace
+        let wordWrapEnabled = self.wordWrapEnabled
+        let entries = self.entries
+        let entryCount = entries.count
+        
         textWidthMax = maxEntrySize.width
         textHeightMax = maxEntrySize.height
         
@@ -303,13 +314,14 @@ public class ChartLegend: ChartComponentBase
             var maxHeight = CGFloat(0.0)
             let labelLineHeight = labelFont.lineHeight
             
-            var labels = self.labels
-            let count = labels.count
             var wasStacked = false
             
-            for i in 0 ..< count
+            for i in 0 ..< entryCount
             {
-                let drawingForm = colors[i] != nil
+                let e = entries[i]
+                let drawingForm = e.form != .None
+                let formSize = isnan(e.formSize) ? defaultFormSize : e.formSize
+                let label = e.label
                 
                 if !wasStacked
                 {
@@ -325,9 +337,9 @@ public class ChartLegend: ChartComponentBase
                     width += formSize
                 }
                 
-                if labels[i] != nil
+                if label != nil
                 {
-                    let size = (labels[i] as NSString!).sizeWithAttributes([NSFontAttributeName: labelFont])
+                    let size = (label as NSString!).sizeWithAttributes([NSFontAttributeName: labelFont])
                     
                     if drawingForm && !wasStacked
                     {
@@ -343,7 +355,7 @@ public class ChartLegend: ChartComponentBase
                     
                     width += size.width
                     
-                    if (i < count - 1)
+                    if i < entryCount - 1
                     {
                         maxHeight += labelLineHeight + yEntrySpace
                     }
@@ -353,7 +365,7 @@ public class ChartLegend: ChartComponentBase
                     wasStacked = true
                     width += formSize
                     
-                    if (i < count - 1)
+                    if i < entryCount - 1
                     {
                         width += stackSpace
                     }
@@ -367,28 +379,19 @@ public class ChartLegend: ChartComponentBase
             
         case .Horizontal:
             
-            var labels = self.labels
-            var colors = self.colors
-            let labelCount = labels.count
-            
             let labelLineHeight = labelFont.lineHeight
-            let formSize = self.formSize
-            let formToTextSpace = self.formToTextSpace
-            let xEntrySpace = self.xEntrySpace
-            let stackSpace = self.stackSpace
-            let wordWrapEnabled = self.wordWrapEnabled
             
             let contentWidth: CGFloat = viewPortHandler.contentWidth * maxSizePercent
             
             // Prepare arrays for calculated layout
-            if (calculatedLabelSizes.count != labelCount)
+            if (calculatedLabelSizes.count != entryCount)
             {
-                calculatedLabelSizes = [CGSize](count: labelCount, repeatedValue: CGSize())
+                calculatedLabelSizes = [CGSize](count: entryCount, repeatedValue: CGSize())
             }
             
-            if (calculatedLabelBreakPoints.count != labelCount)
+            if (calculatedLabelBreakPoints.count != entryCount)
             {
-                calculatedLabelBreakPoints = [Bool](count: labelCount, repeatedValue: false)
+                calculatedLabelBreakPoints = [Bool](count: entryCount, repeatedValue: false)
             }
             
             calculatedLineSizes.removeAll(keepCapacity: true)
@@ -401,9 +404,11 @@ public class ChartLegend: ChartComponentBase
             var requiredWidth: CGFloat = 0.0
             var stackedStartIndex: Int = -1
             
-            for i in 0 ..< labelCount
+            for i in 0 ..< entryCount
             {
-                let drawingForm = colors[i] != nil
+                let e = entries[i]
+                let drawingForm = e.form != .None
+                let label = e.label
                 
                 calculatedLabelBreakPoints[i] = false
                 
@@ -419,9 +424,9 @@ public class ChartLegend: ChartComponentBase
                 }
                 
                 // grouped forms have null labels
-                if (labels[i] != nil)
+                if label != nil
                 {
-                    calculatedLabelSizes[i] = (labels[i] as NSString!).sizeWithAttributes(labelAttrs)
+                    calculatedLabelSizes[i] = (label as NSString!).sizeWithAttributes(labelAttrs)
                     requiredWidth += drawingForm ? formToTextSpace + formSize : 0.0
                     requiredWidth += calculatedLabelSizes[i].width
                 }
@@ -437,7 +442,7 @@ public class ChartLegend: ChartComponentBase
                     }
                 }
                 
-                if (labels[i] != nil || i == labelCount - 1)
+                if label != nil || i == entryCount - 1
                 {
                     let requiredSpacing = currentLineWidth == 0.0 ? 0.0 : xEntrySpace
                     
@@ -460,14 +465,14 @@ public class ChartLegend: ChartComponentBase
                         currentLineWidth = requiredWidth
                     }
                     
-                    if (i == labelCount - 1)
+                    if (i == entryCount - 1)
                     { // Add last line size to array
                         calculatedLineSizes.append(CGSize(width: currentLineWidth, height: labelLineHeight))
                         maxLineWidth = max(maxLineWidth, currentLineWidth)
                     }
                 }
                 
-                stackedStartIndex = labels[i] != nil ? -1 : stackedStartIndex
+                stackedStartIndex = label != nil ? -1 : stackedStartIndex
             }
             
             neededWidth = maxLineWidth
@@ -481,94 +486,362 @@ public class ChartLegend: ChartComponentBase
     
     /// MARK: - Custom legend
     
-    /// colors and labels that will be appended to the end of the auto calculated colors and labels after calculating the legend.
-    /// (if the legend has already been calculated, you will need to call notifyDataSetChanged() to let the changes take effect)
-    public func setExtra(colors colors: [NSUIColor?], labels: [String?])
-    {
-        self._extraLabels = labels
-        self._extraColors = colors
-    }
-    
-    /// Sets a custom legend's labels and colors arrays.
-    /// The colors count should match the labels count.
-    /// * Each color is for the form drawn at the same index.
+    /// Sets a custom legend's entries array.
     /// * A nil label will start a group.
-    /// * A nil color will avoid drawing a form, and a clearColor will leave a space for the form.
-    /// This will disable the feature that automatically calculates the legend labels and colors from the datasets.
+    /// This will disable the feature that automatically calculates the legend entries from the datasets.
     /// Call `resetCustom(...)` to re-enable automatic calculation (and then `notifyDataSetChanged()` is needed).
-    public func setCustom(colors colors: [NSUIColor?], labels: [String?])
+    public func setCustom(entries entries: [LegendEntry])
     {
-        self.labels = labels
-        self.colors = colors
+        self.entries = entries
         _isLegendCustom = true
     }
     
-    /// Calling this will disable the custom legend labels (set by `setLegend(...)`). Instead, the labels will again be calculated automatically (after `notifyDataSetChanged()` is called).
+    /// Calling this will disable the custom legend entries (set by `setLegend(...)`). Instead, the entries will again be calculated automatically (after `notifyDataSetChanged()` is called).
     public func resetCustom()
     {
         _isLegendCustom = false
     }
     
     /// **default**: false (automatic legend)
-    /// - returns: `true` if a custom legend labels and colors has been set
+    /// - returns: `true` if a custom legend entries has been set
     public var isLegendCustom: Bool
     {
         return _isLegendCustom
     }
     
-    /// MARK: - ObjC compatibility
+    // MARK: - Deprecated stuff
     
-    /// colors that will be appended to the end of the colors array after calculating the legend.
-    public var extraColorsObjc: [NSObject] { return ChartUtils.bridgedObjCGetNSUIColorArray(swift: _extraColors); }
+    /// This property is deprecated - Use `entries`.
+    @available(*, deprecated=1.0, message="Use `entries`.")
+    public var colors: [NSUIColor?]
+    {
+        get
+        {
+            var old = [NSUIColor?]()
+            for e in entries
+            {
+                old.append(
+                    e.form == .None ? nil :
+                        (e.form == .Empty ? NSUIColor.clearColor() :
+                        e.formColor))
+            }
+            return old
+        }
+        set
+        {
+            for i in 0 ..< newValue.count
+            {
+                if entries.count <= i
+                {
+                    entries.append(LegendEntry())
+                }
+                entries[i].formColor = newValue[i]
+                
+                if newValue[i] == nil
+                {
+                    entries[i].form = .None
+                }
+                else if newValue[i] == NSUIColor.clearColor()
+                {
+                    entries[i].form = .Empty
+                }
+            }
+        }
+    }
+    
+    /// This property is deprecated - Use `entries`.
+    @available(*, deprecated=1.0, message="Use `entries`.")
+    public var labels: [String?]
+    {
+        get
+        {
+            var old = [String?]()
+            for e in entries
+            {
+                old.append(e.label)
+            }
+            return old
+        }
+        set
+        {
+            for i in 0 ..< newValue.count
+            {
+                if entries.count <= i
+                {
+                    entries.append(LegendEntry())
+                }
+                entries[i].label = newValue[i]
+            }
+        }
+    }
     
-    /// labels that will be appended to the end of the labels array after calculating the legend. a nil label will start a group.
-    public var extraLabelsObjc: [NSObject] { return ChartUtils.bridgedObjCGetStringArray(swift: _extraLabels); }
     
-    /// the legend colors array, each color is for the form drawn at the same index
-    /// (ObjC bridging functions, as Swift 1.2 does not bridge optionals in array to `NSNull`s)
+    /// This property is deprecated - Use `extraEntries`.
+    @available(*, deprecated=1.0, message="Use `extraEntries`.")
+    public var extraColors: [NSUIColor?]
+    {
+        get
+        {
+            var old = [NSUIColor?]()
+            for e in extraEntries
+            {
+                old.append(
+                    e.form == .None ? nil :
+                        (e.form == .Empty ? NSUIColor.clearColor() :
+                            e.formColor))
+            }
+            return old
+        }
+        set
+        {
+            if extraEntries.count > newValue.count
+            {
+                extraEntries.removeRange(newValue.count ..< extraEntries.count)
+            }
+            
+            for i in 0 ..< newValue.count
+            {
+                extraEntries[i].formColor = newValue[i]
+                
+                if newValue[i] == nil
+                {
+                    extraEntries[i].form = .None
+                }
+                else if newValue[i] == NSUIColor.clearColor()
+                {
+                    extraEntries[i].form = .Empty
+                }
+            }
+        }
+    }
+    
+    /// This property is deprecated - Use `extraEntries`.
+    @available(*, deprecated=1.0, message="Use `extraEntries`.")
+    public var extraLabels: [String?]
+    {
+        get
+        {
+            var old = [String?]()
+            for e in extraEntries
+            {
+                old.append(e.label)
+            }
+            return old
+        }
+        set
+        {
+            if extraEntries.count > newValue.count
+            {
+                extraEntries.removeRange(newValue.count ..< extraEntries.count)
+            }
+            
+            for i in 0 ..< newValue.count
+            {
+                extraEntries[i].label = newValue[i]
+            }
+        }
+    }
+    
+    /// This constructor is deprecated - Use `init(entries:)`
+    @available(*, deprecated=1.0, message="Use `init(entries:)`")
+    public init(colors: [NSUIColor?], labels: [String?])
+    {
+        super.init()
+        
+        var entries = [LegendEntry]()
+        
+        for i in 0 ..< min(colors.count, labels.count)
+        {
+            let entry = LegendEntry()
+            entry.formColor = colors[i]
+            entry.label = labels[i]
+            
+            if entry.formColor == nil
+            {
+                entry.form = .None
+            }
+            else if entry.formColor == NSUIColor.clearColor()
+            {
+                entry.form = .Empty
+            }
+            
+            entries.append(entry)
+        }
+        
+        self.entries = entries
+    }
+    
+    /// This constructor is deprecated - Use `init(entries:)`
+    @available(*, deprecated=1.0, message="Use `init(entries:)`")
+    public init(colors: [NSObject], labels: [NSObject])
+    {
+        super.init()
+        
+        var entries = [LegendEntry]()
+        
+        for i in 0 ..< min(colors.count, labels.count)
+        {
+            let entry = LegendEntry()
+            entry.formColor = colors[i] as? NSUIColor
+            entry.label = labels[i] as? String
+            
+            if entry.formColor == nil
+            {
+                entry.form = .None
+            }
+            else if entry.formColor == NSUIColor.clearColor()
+            {
+                entry.form = .Empty
+            }
+            
+            entries.append(entry)
+        }
+        
+        self.entries = entries
+    }
+    
+    /// This property is deprecated - Use `extraEntries`
+    @available(*, deprecated=1.0, message="Use `extraEntries`")
+    public var extraColorsObjc: [NSObject]
+    {
+        return ChartUtils.bridgedObjCGetNSUIColorArray(swift: extraColors)
+    }
+    
+    /// This property is deprecated - Use `extraLabels`
+    @available(*, deprecated=1.0, message="Use `extraLabels`")
+    public var extraLabelsObjc: [NSObject]
+    {
+        return ChartUtils.bridgedObjCGetStringArray(swift: extraLabels)
+    }
+    
+    /// This property is deprecated - Use `colors`
+    @available(*, deprecated=1.0, message="Use `colors`")
     public var colorsObjc: [NSObject]
     {
-        get { return ChartUtils.bridgedObjCGetNSUIColorArray(swift: colors); }
-        set { self.colors = ChartUtils.bridgedObjCGetNSUIColorArray(objc: newValue); }
+        get { return ChartUtils.bridgedObjCGetNSUIColorArray(swift: colors) }
+        set { self.colors = ChartUtils.bridgedObjCGetNSUIColorArray(objc: newValue) }
     }
     
-    // the legend text array. a nil label will start a group.
-    /// (ObjC bridging functions, as Swift 1.2 does not bridge optionals in array to `NSNull`s)
+    /// This property is deprecated - Use `labels`
+    @available(*, deprecated=1.0, message="Use `labels`")
     public var labelsObjc: [NSObject]
     {
-        get { return ChartUtils.bridgedObjCGetStringArray(swift: labels); }
-        set { self.labels = ChartUtils.bridgedObjCGetStringArray(objc: newValue); }
+        get { return ChartUtils.bridgedObjCGetStringArray(swift: labels) }
+        set { self.labels = ChartUtils.bridgedObjCGetStringArray(objc: newValue) }
+    }
+    
+    /// This function is deprecated - Use `entries`
+    @available(*, deprecated=1.0, message="Use `entries`")
+    public func getLabel(index: Int) -> String?
+    {
+        return entries[index].label
+    }
+    
+    /// This function is deprecated - Use `Use `extra(entries:)`
+    @available(*, deprecated=1.0, message="Use `extra(entries:)`")
+    public func setExtra(colors colors: [NSUIColor?], labels: [String?])
+    {
+        var entries = [LegendEntry]()
+        
+        for i in 0 ..< min(colors.count, labels.count)
+        {
+            let entry = LegendEntry()
+            entry.formColor = colors[i]
+            entry.label = labels[i]
+            
+            if entry.formColor == nil
+            {
+                entry.form = .None
+            }
+            else if entry.formColor == NSUIColor.clearColor()
+            {
+                entry.form = .Empty
+            }
+            
+            entries.append(entry)
+        }
+        
+        self.extraEntries = entries
     }
     
-    /// colors and labels that will be appended to the end of the auto calculated colors and labels after calculating the legend.
-    /// (if the legend has already been calculated, you will need to call `notifyDataSetChanged()` to let the changes take effect)
+    /// This function is deprecated - Use `Use `extra(entries:)`
+    @available(*, deprecated=1.0, message="Use `extra(entries:)`")
     public func setExtra(colors colors: [NSObject], labels: [NSObject])
     {
-        if (colors.count != labels.count)
+        var entries = [LegendEntry]()
+        
+        for i in 0 ..< min(colors.count, labels.count)
         {
-            fatalError("ChartLegend:setExtra() - colors array and labels array need to be of same size")
+            let entry = LegendEntry()
+            entry.formColor = colors[i] as? NSUIColor
+            entry.label = labels[i] as? String
+            
+            if entry.formColor == nil
+            {
+                entry.form = .None
+            }
+            else if entry.formColor == NSUIColor.clearColor()
+            {
+                entry.form = .Empty
+            }
+            
+            entries.append(entry)
         }
         
-        self._extraLabels = ChartUtils.bridgedObjCGetStringArray(objc: labels)
-        self._extraColors = ChartUtils.bridgedObjCGetNSUIColorArray(objc: colors)
+        self.extraEntries = entries
     }
     
-    /// Sets a custom legend's labels and colors arrays.
-    /// The colors count should match the labels count.
-    /// * Each color is for the form drawn at the same index.
-    /// * A nil label will start a group.
-    /// * A nil color will avoid drawing a form, and a clearColor will leave a space for the form.
-    /// This will disable the feature that automatically calculates the legend labels and colors from the datasets.
-    /// Call `resetLegendToAuto(...)` to re-enable automatic calculation, and then if needed - call `notifyDataSetChanged()` on the chart to make it refresh the data.
+    /// This function is deprecated - Use `Use `setCustom(entries:)`
+    @available(*, deprecated=1.0, message="Use `setCustom(entries:)`")
+    public func setCustom(colors colors: [NSUIColor?], labels: [String?])
+    {
+        var entries = [LegendEntry]()
+        
+        for i in 0 ..< min(colors.count, labels.count)
+        {
+            let entry = LegendEntry()
+            entry.formColor = colors[i]
+            entry.label = labels[i]
+            
+            if entry.formColor == nil
+            {
+                entry.form = .None
+            }
+            else if entry.formColor == NSUIColor.clearColor()
+            {
+                entry.form = .Empty
+            }
+            
+            entries.append(entry)
+        }
+        
+        setCustom(entries: entries)
+    }
+    
+    /// This function is deprecated - Use `Use `setCustom(entries:)`
+    @available(*, deprecated=1.0, message="Use `setCustom(entries:)`")
     public func setCustom(colors colors: [NSObject], labels: [NSObject])
     {
-        if (colors.count != labels.count)
+        var entries = [LegendEntry]()
+        
+        for i in 0 ..< min(colors.count, labels.count)
         {
-            fatalError("ChartLegend:setCustom() - colors array and labels array need to be of same size")
+            let entry = LegendEntry()
+            entry.formColor = colors[i] as? NSUIColor
+            entry.label = labels[i] as? String
+            
+            if entry.formColor == nil
+            {
+                entry.form = .None
+            }
+            else if entry.formColor == NSUIColor.clearColor()
+            {
+                entry.form = .Empty
+            }
+            
+            entries.append(entry)
         }
         
-        self.labelsObjc = labels
-        self.colorsObjc = colors
-        _isLegendCustom = true
+        setCustom(entries: entries)
     }
 }
diff --git a/Charts/Classes/Components/LegendEntry.swift b/Charts/Classes/Components/LegendEntry.swift
new file mode 100644
index 00000000..0b2545ec
--- /dev/null
+++ b/Charts/Classes/Components/LegendEntry.swift
@@ -0,0 +1,69 @@
+//
+//  LegendEntry.swift
+//  Charts
+//
+//  Copyright 2015 Daniel Cohen Gindi & Philipp Jahoda
+//  A port of MPAndroidChart for iOS
+//  Licensed under Apache License 2.0
+//
+//  https://github.com/danielgindi/Charts
+//
+
+import Foundation
+import CoreGraphics
+
+#if !os(OSX)
+    import UIKit
+#endif
+
+@objc(ChartLegendEntry)
+public class LegendEntry: NSObject
+{
+    public override init()
+    {
+        super.init()
+    }
+    
+    /// - parameter label:          The legend entry text.
+    ///                             A `nil` label will start a group.
+    /// - parameter form:           The form to draw for this entry.
+    /// - parameter formSize:       Set as NaN to use the legend's default
+    /// - parameter formLineWidth:  Set as NaN to use the legend's default
+    /// - parameter formColor:      The color for drawing the form
+    public init(label: String?,
+                form: ChartLegend.Form,
+                formSize: CGFloat,
+                formLineWidth: CGFloat,
+                formColor: NSUIColor?)
+    {
+        self.label = label
+        self.form = form
+        self.formSize = formSize
+        self.formLineWidth = formLineWidth
+        self.formColor = formColor
+    }
+    
+    /// The legend entry text.
+    /// A `nil` label will start a group.
+    public var label: String?
+    
+    /// The form to draw for this entry.
+    ///
+    /// `None` will avoid drawing a form, and any related space.
+    /// `Empty` will avoid drawing a form, but keep its space.
+    /// `Default` will use the Legend's default.
+    public var form: ChartLegend.Form = .Default
+    
+    /// Form size will be considered except for when .None is used
+    ///
+    /// Set as NaN to use the legend's default
+    public var formSize: CGFloat = CGFloat.NaN
+    
+    /// Line width used for shapes that consist of lines.
+    ///
+    /// Set as NaN to use the legend's default
+    public var formLineWidth: CGFloat = CGFloat.NaN
+    
+    /// The color for drawing the form
+    public var formColor: NSUIColor?
+}
\ No newline at end of file
diff --git a/Charts/Classes/Data/Implementations/ChartBaseDataSet.swift b/Charts/Classes/Data/Implementations/ChartBaseDataSet.swift
index a99cfea8..ed6bff7d 100644
--- a/Charts/Classes/Data/Implementations/ChartBaseDataSet.swift
+++ b/Charts/Classes/Data/Implementations/ChartBaseDataSet.swift
@@ -314,6 +314,19 @@ public class ChartBaseDataSet: NSObject, IChartDataSet
     /// the font for the value-text labels
     public var valueFont: NSUIFont = NSUIFont.systemFontOfSize(7.0)
     
+    /// The form to draw for this dataset in the legend.
+    public var form = ChartLegend.Form.Default
+    
+    /// The form size to draw for this dataset in the legend.
+    ///
+    /// Return `NaN` to use the default legend form size.
+    public var formSize: CGFloat = CGFloat.NaN
+    
+    /// The line width for drawing the form of this dataset in the legend
+    ///
+    /// Return `NaN` to use the default legend form line width.
+    public var formLineWidth: CGFloat = CGFloat.NaN
+    
     /// Set this to true to draw y-values on the chart
     public var drawValuesEnabled = true
     
diff --git a/Charts/Classes/Data/Interfaces/IChartDataSet.swift b/Charts/Classes/Data/Interfaces/IChartDataSet.swift
index 46307793..f3db98e6 100644
--- a/Charts/Classes/Data/Interfaces/IChartDataSet.swift
+++ b/Charts/Classes/Data/Interfaces/IChartDataSet.swift
@@ -185,6 +185,21 @@ public protocol IChartDataSet
     /// the font for the value-text labels
     var valueFont: NSUIFont { get set }
     
+    /// The form to draw for this dataset in the legend.
+    ///
+    /// Return `.Default` to use the default legend form.
+    var form: ChartLegend.Form { get }
+    
+    /// The form size to draw for this dataset in the legend.
+    ///
+    /// Return `NaN` to use the default legend form size.
+    var formSize: CGFloat { get }
+    
+    /// The line width for drawing the form of this dataset in the legend
+    ///
+    /// Return `NaN` to use the default legend form line width.
+    var formLineWidth: CGFloat { get }
+    
     /// Set this to true to draw y-values on the chart
     var drawValuesEnabled: Bool { get set }
     
diff --git a/Charts/Classes/Renderers/LegendRenderer.swift b/Charts/Classes/Renderers/LegendRenderer.swift
index d7932b8b..a1106091 100755
--- a/Charts/Classes/Renderers/LegendRenderer.swift
+++ b/Charts/Classes/Renderers/LegendRenderer.swift
@@ -39,8 +39,7 @@ public class LegendRenderer: Renderer
         
         if (!legend.isLegendCustom)
         {
-            var labels = [String?]()
-            var colors = [NSUIColor?]()
+            var entries: [LegendEntry] = []
             
             // loop for building up the colors and labels used in the legend
             for i in 0..<data.dataSetCount
@@ -58,15 +57,30 @@ public class LegendRenderer: Renderer
                     
                     for j in 0..<min(clrs.count, bds.stackSize)
                     {
-                        labels.append(sLabels[j % sLabels.count])
-                        colors.append(clrs[j])
+                        entries.append(
+                            LegendEntry(
+                                label: sLabels[j % sLabels.count],
+                                form: dataSet.form,
+                                formSize: dataSet.formSize,
+                                formLineWidth: dataSet.formLineWidth,
+                                formColor: clrs[j]
+                            )
+                        )
                     }
                     
-                    if (bds.label != nil)
+                    if dataSet.label != nil
                     {
                         // add the legend description label
-                        colors.append(nil)
-                        labels.append(bds.label)
+                        
+                        entries.append(
+                            LegendEntry(
+                                label: dataSet.label,
+                                form: .None,
+                                formSize: CGFloat.NaN,
+                                formLineWidth: CGFloat.NaN,
+                                formColor: nil
+                            )
+                        )
                     }
                 }
                 else if (dataSet is IPieChartDataSet)
@@ -75,47 +89,88 @@ public class LegendRenderer: Renderer
                     
                     for j in 0..<min(clrs.count, entryCount)
                     {
-                        labels.append((pds.entryForIndex(j) as? PieChartDataEntry)?.label)
-                        colors.append(clrs[j])
+                        entries.append(
+                            LegendEntry(
+                                label: (pds.entryForIndex(j) as? PieChartDataEntry)?.label,
+                                form: dataSet.form,
+                                formSize: dataSet.formSize,
+                                formLineWidth: dataSet.formLineWidth,
+                                formColor: clrs[j]
+                            )
+                        )
                     }
                     
-                    if (pds.label != nil)
+                    if dataSet.label != nil
                     {
                         // add the legend description label
-                        colors.append(nil)
-                        labels.append(pds.label)
+                        
+                        entries.append(
+                            LegendEntry(
+                                label: dataSet.label,
+                                form: .None,
+                                formSize: CGFloat.NaN,
+                                formLineWidth: CGFloat.NaN,
+                                formColor: nil
+                            )
+                        )
                     }
                 }
                 else if (dataSet is ICandleChartDataSet
                     && (dataSet as! ICandleChartDataSet).decreasingColor != nil)
                 {
-                    colors.append((dataSet as! ICandleChartDataSet).decreasingColor)
-                    colors.append((dataSet as! ICandleChartDataSet).increasingColor)
-                    labels.append(nil)
-                    labels.append(dataSet.label)
+                    let candleDataSet = dataSet as! ICandleChartDataSet
+                    
+                    entries.append(
+                        LegendEntry(
+                            label: nil,
+                            form: dataSet.form,
+                            formSize: dataSet.formSize,
+                            formLineWidth: dataSet.formLineWidth,
+                            formColor: candleDataSet.decreasingColor
+                        )
+                    )
+                    
+                    entries.append(
+                        LegendEntry(
+                            label: dataSet.label,
+                            form: dataSet.form,
+                            formSize: dataSet.formSize,
+                            formLineWidth: dataSet.formLineWidth,
+                            formColor: candleDataSet.increasingColor
+                        )
+                    )
                 }
                 else
                 { // all others
                     
                     for j in 0..<min(clrs.count, entryCount)
                     {
+                        let label: String?
+                        
                         // if multiple colors are set for a DataSet, group them
                         if (j < clrs.count - 1 && j < entryCount - 1)
                         {
-                            labels.append(nil)
+                            label = nil
                         }
                         else
                         { // add label to the last entry
-                            labels.append(dataSet.label)
+                            label = dataSet.label
                         }
                         
-                        colors.append(clrs[j])
+                        entries.append(
+                            LegendEntry(
+                                label: label,
+                                form: dataSet.form,
+                                formSize: dataSet.formSize,
+                                formLineWidth: dataSet.formLineWidth,
+                                formColor: clrs[j]
+                            )
+                        )
                     }
                 }
             }
             
-            legend.colors = colors + legend._extraColors
-            legend.labels = labels + legend._extraLabels
+            legend.entries = entries + legend.extraEntries
         }
         
         // calculate all dimensions of the legend
@@ -139,10 +194,9 @@ public class LegendRenderer: Renderer
         let labelLineHeight = labelFont.lineHeight
         let formYOffset = labelLineHeight / 2.0
 
-        var labels = legend.labels
-        var colors = legend.colors
+        var entries = legend.entries
         
-        let formSize = legend.formSize
+        let defaultFormSize = legend.formSize
         let formToTextSpace = legend.formToTextSpace
         let xEntrySpace = legend.xEntrySpace
         let yEntrySpace = legend.yEntrySpace
@@ -244,8 +298,12 @@ public class LegendRenderer: Renderer
             
             var lineIndex: Int = 0
             
-            for i in 0..<labels.count
+            for i in 0 ..< entries.count
             {
+                let e = entries[i]
+                let drawingForm = e.form != .None
+                let formSize = isnan(e.formSize) ? defaultFormSize : e.formSize
+                
                 if (i < calculatedLabelBreakPoints.count && calculatedLabelBreakPoints[i])
                 {
                     posX = originPosX
@@ -262,17 +320,21 @@ public class LegendRenderer: Renderer
                     lineIndex += 1
                 }
                 
-                let drawingForm = colors[i] != nil
-                let isStacked = labels[i] == nil // grouped forms have null labels
+                let isStacked = e.label == nil // grouped forms have null labels
                 
-                if (drawingForm)
+                if drawingForm
                 {
                     if (direction == .RightToLeft)
                     {
                         posX -= formSize
                     }
                     
-                    drawForm(context: context, x: posX, y: posY + formYOffset, colorIndex: i, legend: legend)
+                    drawForm(
+                        context: context,
+                        x: posX,
+                        y: posY + formYOffset,
+                        entry: e,
+                        legend: legend)
                     
                     if (direction == .LeftToRight)
                     {
@@ -292,7 +354,13 @@ public class LegendRenderer: Renderer
                         posX -= calculatedLabelSizes[i].width
                     }
                     
-                    drawLabel(context: context, x: posX, y: posY, label: labels[i]!, font: labelFont, textColor: labelTextColor)
+                    drawLabel(
+                        context: context,
+                        x: posX,
+                        y: posY,
+                        label: e.label!,
+                        font: labelFont,
+                        textColor: labelTextColor)
                     
                     if (direction == .LeftToRight)
                     {
@@ -334,9 +402,12 @@ public class LegendRenderer: Renderer
                 posY = viewPortHandler.chartHeight / 2.0 - legend.neededHeight / 2.0 + legend.yOffset
             }
             
-            for i in 0..<labels.count
+            for i in 0 ..< entries.count
             {
-                let drawingForm = colors[i] != nil
+                let e = entries[i]
+                let drawingForm = e.form != .None
+                let formSize = isnan(e.formSize) ? defaultFormSize : e.formSize
+                
                 var posX = originPosX
                 
                 if (drawingForm)
@@ -350,7 +421,12 @@ public class LegendRenderer: Renderer
                         posX -= formSize - stack
                     }
                     
-                    drawForm(context: context, x: posX, y: posY + formYOffset, colorIndex: i, legend: legend)
+                    drawForm(
+                        context: context,
+                        x: posX,
+                        y: posY + formYOffset,
+                        entry: e,
+                        legend: legend)
                     
                     if (direction == .LeftToRight)
                     {
@@ -358,7 +434,7 @@ public class LegendRenderer: Renderer
                     }
                 }
                 
-                if (labels[i] != nil)
+                if (e.label != nil)
                 {
                     if (drawingForm && !wasStacked)
                     {
@@ -371,17 +447,17 @@ public class LegendRenderer: Renderer
                     
                     if (direction == .RightToLeft)
                     {
-                        posX -= (labels[i] as NSString!).sizeWithAttributes([NSFontAttributeName: labelFont]).width
+                        posX -= (e.label as NSString!).sizeWithAttributes([NSFontAttributeName: labelFont]).width
                     }
                     
                     if (!wasStacked)
                     {
-                        drawLabel(context: context, x: posX, y: posY, label: labels[i]!, font: labelFont, textColor: labelTextColor)
+                        drawLabel(context: context, x: posX, y: posY, label: e.label!, font: labelFont, textColor: labelTextColor)
                     }
                     else
                     {
                         posY += labelLineHeight + yEntrySpace
-                        drawLabel(context: context, x: posX, y: posY, label: labels[i]!, font: labelFont, textColor: labelTextColor)
+                        drawLabel(context: context, x: posX, y: posY, label: e.label!, font: labelFont, textColor: labelTextColor)
                     }
                     
                     // make a step down
@@ -400,33 +476,59 @@ public class LegendRenderer: Renderer
     private var _formLineSegmentsBuffer = [CGPoint](count: 2, repeatedValue: CGPoint())
     
     /// Draws the Legend-form at the given position with the color at the given index.
-    public func drawForm(context context: CGContext, x: CGFloat, y: CGFloat, colorIndex: Int, legend: ChartLegend)
+    public func drawForm(
+        context context: CGContext,
+                x: CGFloat,
+                y: CGFloat,
+                entry: LegendEntry,
+                legend: ChartLegend)
     {
-        guard let formColor = legend.colors[colorIndex] where formColor != NSUIColor.clearColor() else {
-            return
+        guard let formColor = entry.formColor
+            where formColor != NSUIColor.clearColor()
+            else { return }
+        
+        var form = entry.form
+        if form == .Default
+        {
+            form = legend.form
         }
         
-        let formsize = legend.formSize
+        let formSize = isnan(entry.formSize) ? legend.formSize : entry.formSize
         
         CGContextSaveGState(context)
         defer { CGContextRestoreGState(context) }
         
-        switch (legend.form)
+        switch form
         {
+        case .None:
+            // Do nothing
+            break
+            
+        case .Empty:
+            // Do not draw, but keep space for the form
+            break
+            
+        case .Default: fallthrough
         case .Circle:
+            
             CGContextSetFillColorWithColor(context, formColor.CGColor)
-            CGContextFillEllipseInRect(context, CGRect(x: x, y: y - formsize / 2.0, width: formsize, height: formsize))
+            CGContextFillEllipseInRect(context, CGRect(x: x, y: y - formSize / 2.0, width: formSize, height: formSize))
+            
         case .Square:
+            
             CGContextSetFillColorWithColor(context, formColor.CGColor)
-            CGContextFillRect(context, CGRect(x: x, y: y - formsize / 2.0, width: formsize, height: formsize))
+            CGContextFillRect(context, CGRect(x: x, y: y - formSize / 2.0, width: formSize, height: formSize))
+            
         case .Line:
             
-            CGContextSetLineWidth(context, legend.formLineWidth)
+            let formLineWidth = isnan(entry.formLineWidth) ? legend.formLineWidth : entry.formLineWidth
+            
+            CGContextSetLineWidth(context, formLineWidth)
             CGContextSetStrokeColorWithColor(context, formColor.CGColor)
             
             _formLineSegmentsBuffer[0].x = x
             _formLineSegmentsBuffer[0].y = y
-            _formLineSegmentsBuffer[1].x = x + formsize
+            _formLineSegmentsBuffer[1].x = x + formSize
             _formLineSegmentsBuffer[1].y = y
             CGContextStrokeLineSegments(context, _formLineSegmentsBuffer, 2)
         }
