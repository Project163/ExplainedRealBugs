diff --git a/lib/active_admin/resource_collection.rb b/lib/active_admin/resource_collection.rb
index cb273eb4..5abe7817 100644
--- a/lib/active_admin/resource_collection.rb
+++ b/lib/active_admin/resource_collection.rb
@@ -4,14 +4,19 @@ module ActiveAdmin
   class ResourceCollection
     include Enumerable
     extend Forwardable
-    def_delegators :@resources, :empty?, :has_key?, :keys, :values, :[]=
+    def_delegators :@collection, :empty?, :has_key?, :keys, :values, :size
 
     def initialize
-      @resources = {}
+      @collection = {}
     end
 
     def add(resource)
-      @resources[resource.resource_name] ||= resource
+      if match = @collection[resource.resource_name]
+        raise_if_mismatched! match, resource
+        match
+      else
+        @collection[resource.resource_name] = resource
+      end
     end
 
     # Changes `each` to pass in the value, instead of both the key and value.
@@ -19,23 +24,46 @@ module ActiveAdmin
       values.each &block
     end
 
-    # Finds a resource based on the resource name, the resource class, or the base class.
-    def [](klass)
-      if match = @resources[klass]
-        match
-      elsif match = real_resources.detect{ |r| [r.resource_name.to_s, r.resource_class.to_s].include? klass.to_s }
-        match
-      elsif klass.respond_to? :base_class
-        real_resources.detect{ |r| r.resource_class.to_s == klass.base_class.to_s }
-      end
+    def [](obj)
+      @collection[obj] || find_resource(obj)
     end
 
     private
 
-    # REFACTOR: ResourceCollection currently stores Resource and Page objects. That doesn't
-    # make sense, because by definition a ResourceCollection is a collection of resources.
-    def real_resources
-      select{ |r| r.respond_to? :resource_class }
+    # Finds a resource based on the resource name, resource class, or base class.
+    def find_resource(obj)
+      resources.detect do |r|
+        r.resource_name.to_s == obj.to_s || r.resource_class.to_s == obj.to_s
+      end ||
+      if obj.respond_to? :base_class
+        resources.detect{ |r| r.resource_class.to_s == obj.base_class.to_s }
+      end
+    end
+
+    def resources
+      select{ |r| r.class <= Resource } # can otherwise be a Page
+    end
+
+    def raise_if_mismatched!(existing, given)
+      if existing.class != given.class
+        raise IncorrectClass.new existing, given
+      elsif given.class <= Resource && existing.resource_class != given.resource_class
+        raise ConfigMismatch.new existing, given
+      end
+    end
+
+    class IncorrectClass < StandardError
+      def initialize(existing, given)
+        super "You're trying to register #{given.resource_name} which is a #{given.class}, " +
+              "but #{existing.resource_name}, a #{existing.class} has already claimed that name."
+      end
+    end
+
+    class ConfigMismatch < StandardError
+      def initialize(existing, given)
+        super "You're trying to register #{given.resource_class} as #{given.resource_name}, " +
+              "but the existing #{existing.class} config was built for #{existing.resource_class}!"
+      end
     end
 
   end
diff --git a/spec/unit/resource_collection_spec.rb b/spec/unit/resource_collection_spec.rb
index c70eefa3..7231b711 100644
--- a/spec/unit/resource_collection_spec.rb
+++ b/spec/unit/resource_collection_spec.rb
@@ -1,15 +1,20 @@
 require 'spec_helper'
 require 'active_admin/resource_collection'
 
-include ActiveAdmin
-
 describe ActiveAdmin::ResourceCollection do
   let(:application) { ActiveAdmin::Application.new }
-  let(:namespace)   { ActiveAdmin::Namespace.new(application, :admin) }
-
-  let(:collection){ ResourceCollection.new }
-
-  let(:resource){ double resource_name: "MyResource" }
+  let(:namespace)   { ActiveAdmin::Namespace.new application, :admin }
+  let(:collection)  { ActiveAdmin::ResourceCollection.new }
+  let(:resource)    { double resource_name: "MyResource" }
+
+  it { should respond_to :[]       }
+  it { should respond_to :add      }
+  it { should respond_to :each     }
+  it { should respond_to :has_key? }
+  it { should respond_to :keys     }
+  it { should respond_to :values   }
+  it { should respond_to :size     }
+  it { should respond_to :to_a     }
 
   it "should have no resources when new" do
     expect(collection).to be_empty
@@ -25,7 +30,7 @@ describe ActiveAdmin::ResourceCollection do
     expect(collection.keys).to eq [resource.resource_name]
   end
 
-  describe "adding a new resource" do
+  describe "#add" do
     it "should return the resource" do
       expect(collection.add(resource)).to eq resource
     end
@@ -44,11 +49,42 @@ describe ActiveAdmin::ResourceCollection do
       collection.add(resource); collection.add(resource)
       expect(collection.values).to eq [resource]
     end
+
+    it "shouldn't allow a resource name mismatch to occur" do
+      expect {
+        ActiveAdmin.register Category
+        ActiveAdmin.register Post, as: "Category"
+      }.to raise_error ActiveAdmin::ResourceCollection::ConfigMismatch
+    end
+
+    it "shouldn't allow a Page/Resource mismatch to occur" do
+      expect {
+        ActiveAdmin.register User
+        ActiveAdmin.register_page 'User'
+      }.to raise_error ActiveAdmin::ResourceCollection::IncorrectClass
+    end
+
+    describe "should store both renamed and non-renamed resources" do
+      let(:resource) { ActiveAdmin::Resource.new namespace, Category }
+      let(:renamed)  { ActiveAdmin::Resource.new namespace, Category, as: "Subcategory" }
+
+      it "when the renamed version is added first" do
+        collection.add renamed
+        collection.add resource
+        expect(collection.values).to include(resource, renamed)
+      end
+
+      it "when the renamed version is added last" do
+        collection.add resource
+        collection.add renamed
+        expect(collection.values).to include(resource, renamed)
+      end
+    end
   end
 
   describe "#[]" do
-    let(:resource)              { Resource.new(namespace, resource_class) }
-    let(:inherited_resource)    { Resource.new(namespace, inherited_resource_class) }
+    let(:resource)              { ActiveAdmin::Resource.new namespace, resource_class }
+    let(:inherited_resource)    { ActiveAdmin::Resource.new namespace, inherited_resource_class }
 
     let(:resource_class)           { User }
     let(:inherited_resource_class) { Publisher }
@@ -96,7 +132,7 @@ describe ActiveAdmin::ResourceCollection do
     end
 
     context "with a renamed resource" do
-      let(:renamed_resource) { Resource.new(namespace, resource_class, :as => name) }
+      let(:renamed_resource) { ActiveAdmin::Resource.new namespace, resource_class, as: name }
       let(:name)             { "Administrators" }
 
       before do
@@ -117,44 +153,6 @@ describe ActiveAdmin::ResourceCollection do
     end
   end
 
-  describe ".add" do
-    let(:resource)         { Resource.new(namespace, Category) }
-    let(:resource_renamed) { Resource.new(namespace, Category, as: "Subcategory") }
-
-    context "when renamed resource is added first" do
-      before do
-        collection.add(resource_renamed)
-        collection.add(resource)
-      end
-
-      it "contains both resources" do
-        expect(collection.values).to include(resource, resource_renamed)
-      end
-    end
-
-    context "when resource is added first" do
-      before do
-        collection.add(resource)
-        collection.add(resource_renamed)
-      end
-
-      it "contains both resources" do
-        expect(collection.values).to include(resource, resource_renamed)
-      end
-    end
-
-    context "when a duplicate resource is added" do
-      let(:resource_duplicate) { Resource.new(namespace, Category) }
-
-      before do
-        collection.add(resource)
-        collection.add(resource_duplicate)
-      end
-
-      it "the collection contains one instance of that resource" do
-        expect(collection.values).to eq([resource])
-      end
-    end
-  end
+  pending "specs for subclasses of Page and Resource"
 
 end
