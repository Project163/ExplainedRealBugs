diff --git a/crates/bevy_color/src/hsva.rs b/crates/bevy_color/src/hsva.rs
index dd959d266..d536cc129 100644
--- a/crates/bevy_color/src/hsva.rs
+++ b/crates/bevy_color/src/hsva.rs
@@ -1,4 +1,4 @@
-use crate::{Alpha, ClampColor, Hue, Hwba, Lcha, LinearRgba, Srgba, StandardColor, Xyza};
+use crate::{Alpha, ClampColor, Hue, Hwba, Lcha, LinearRgba, Mix, Srgba, StandardColor, Xyza};
 use bevy_reflect::prelude::*;
 use serde::{Deserialize, Serialize};
 
@@ -69,6 +69,27 @@ impl Default for Hsva {
     }
 }
 
+impl Mix for Hsva {
+    #[inline]
+    fn mix(&self, other: &Self, factor: f32) -> Self {
+        let n_factor = 1.0 - factor;
+        // TODO: Refactor this into EuclideanModulo::lerp_modulo
+        let shortest_angle = ((((other.hue - self.hue) % 360.) + 540.) % 360.) - 180.;
+        let mut hue = self.hue + shortest_angle * factor;
+        if hue < 0. {
+            hue += 360.;
+        } else if hue >= 360. {
+            hue -= 360.;
+        }
+        Self {
+            hue,
+            saturation: self.saturation * n_factor + other.saturation * factor,
+            value: self.value * n_factor + other.value * factor,
+            alpha: self.alpha * n_factor + other.alpha * factor,
+        }
+    }
+}
+
 impl Alpha for Hsva {
     #[inline]
     fn with_alpha(&self, alpha: f32) -> Self {
diff --git a/crates/bevy_color/src/hwba.rs b/crates/bevy_color/src/hwba.rs
index a83473d06..dc8a96c25 100644
--- a/crates/bevy_color/src/hwba.rs
+++ b/crates/bevy_color/src/hwba.rs
@@ -2,7 +2,7 @@
 //! in [_HWB - A More Intuitive Hue-Based Color Model_] by _Smith et al_.
 //!
 //! [_HWB - A More Intuitive Hue-Based Color Model_]: https://web.archive.org/web/20240226005220/http://alvyray.com/Papers/CG/HWB_JGTv208.pdf
-use crate::{Alpha, ClampColor, Hue, Lcha, LinearRgba, Srgba, StandardColor, Xyza};
+use crate::{Alpha, ClampColor, Hue, Lcha, LinearRgba, Mix, Srgba, StandardColor, Xyza};
 use bevy_reflect::prelude::*;
 use serde::{Deserialize, Serialize};
 
@@ -73,6 +73,27 @@ impl Default for Hwba {
     }
 }
 
+impl Mix for Hwba {
+    #[inline]
+    fn mix(&self, other: &Self, factor: f32) -> Self {
+        let n_factor = 1.0 - factor;
+        // TODO: Refactor this into EuclideanModulo::lerp_modulo
+        let shortest_angle = ((((other.hue - self.hue) % 360.) + 540.) % 360.) - 180.;
+        let mut hue = self.hue + shortest_angle * factor;
+        if hue < 0. {
+            hue += 360.;
+        } else if hue >= 360. {
+            hue -= 360.;
+        }
+        Self {
+            hue,
+            whiteness: self.whiteness * n_factor + other.whiteness * factor,
+            blackness: self.blackness * n_factor + other.blackness * factor,
+            alpha: self.alpha * n_factor + other.alpha * factor,
+        }
+    }
+}
+
 impl Alpha for Hwba {
     #[inline]
     fn with_alpha(&self, alpha: f32) -> Self {
