diff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs
index f18c03397..ef6b35e99 100644
--- a/crates/bevy_asset/src/lib.rs
+++ b/crates/bevy_asset/src/lib.rs
@@ -46,10 +46,10 @@ use crate::{
     io::{embedded::EmbeddedAssetRegistry, AssetSourceBuilder, AssetSourceBuilders, AssetSourceId},
     processor::{AssetProcessor, Process},
 };
-use bevy_app::{App, First, MainScheduleOrder, Plugin, PostUpdate};
+use bevy_app::{App, First, Plugin, PreUpdate};
 use bevy_ecs::{
     reflect::AppTypeRegistry,
-    schedule::{IntoSystemConfigs, IntoSystemSetConfigs, ScheduleLabel, SystemSet},
+    schedule::{IntoSystemConfigs, IntoSystemSetConfigs, SystemSet},
     system::Resource,
     world::FromWorld,
 };
@@ -146,7 +146,6 @@ impl AssetPlugin {
 
 impl Plugin for AssetPlugin {
     fn build(&self, app: &mut App) {
-        app.init_schedule(UpdateAssets).init_schedule(AssetEvents);
         let embedded = EmbeddedAssetRegistry::default();
         {
             let mut sources = app
@@ -218,16 +217,9 @@ impl Plugin for AssetPlugin {
             .init_asset::<LoadedUntypedAsset>()
             .init_asset::<()>()
             .add_event::<UntypedAssetLoadFailedEvent>()
-            .configure_sets(
-                UpdateAssets,
-                TrackAssets.after(handle_internal_asset_events),
-            )
-            .add_systems(UpdateAssets, handle_internal_asset_events)
+            .configure_sets(PreUpdate, TrackAssets.after(handle_internal_asset_events))
+            .add_systems(PreUpdate, handle_internal_asset_events)
             .register_type::<AssetPath>();
-
-        let mut order = app.world.resource_mut::<MainScheduleOrder>();
-        order.insert_after(First, UpdateAssets);
-        order.insert_after(PostUpdate, AssetEvents);
     }
 }
 
@@ -387,10 +379,13 @@ impl AssetApp for App {
             .register_type::<Handle<A>>()
             .register_type::<AssetId<A>>()
             .add_systems(
-                AssetEvents,
-                Assets::<A>::asset_events.run_if(Assets::<A>::asset_events_condition),
+                First,
+                Assets::<A>::asset_events
+                    .before(bevy_ecs::event::event_update_system::<AssetEvent<A>>)
+                    .run_if(Assets::<A>::asset_events_condition)
+                    .in_set(AssetEvents),
             )
-            .add_systems(UpdateAssets, Assets::<A>::track_assets.in_set(TrackAssets))
+            .add_systems(PreUpdate, Assets::<A>::track_assets.in_set(TrackAssets))
     }
 
     fn register_asset_reflect<A>(&mut self) -> &mut Self
@@ -422,14 +417,10 @@ impl AssetApp for App {
 #[derive(SystemSet, Hash, Debug, PartialEq, Eq, Clone)]
 pub struct TrackAssets;
 
-/// Schedule where [`Assets`] resources are updated.
-#[derive(Debug, Hash, PartialEq, Eq, Clone, ScheduleLabel)]
-pub struct UpdateAssets;
-
-/// Schedule where events accumulated in [`Assets`] are applied to the [`AssetEvent`] [`Events`] resource.
+/// A system set where events accumulated in [`Assets`] are applied to the [`AssetEvent`] [`Events`] resource.
 ///
 /// [`Events`]: bevy_ecs::event::Events
-#[derive(Debug, Hash, PartialEq, Eq, Clone, ScheduleLabel)]
+#[derive(Debug, Hash, PartialEq, Eq, Clone, SystemSet)]
 pub struct AssetEvents;
 
 #[cfg(test)]
