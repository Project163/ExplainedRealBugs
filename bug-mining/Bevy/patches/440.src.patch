diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index c7d49dfa3..82231a503 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -58,8 +58,8 @@ pub mod prelude {
         },
         system::{
             Commands, Deferred, EntityCommand, EntityCommands, In, InMut, InRef, IntoSystem, Local,
-            NonSend, NonSendMut, ParallelCommands, ParamSet, Query, QuerySingle, ReadOnlySystem,
-            Res, ResMut, Resource, System, SystemIn, SystemInput, SystemParamBuilder,
+            NonSend, NonSendMut, ParallelCommands, ParamSet, Query, ReadOnlySystem, Res, ResMut,
+            Resource, Single, System, SystemIn, SystemInput, SystemParamBuilder,
             SystemParamFunction,
         },
         world::{
diff --git a/crates/bevy_ecs/src/system/query.rs b/crates/bevy_ecs/src/system/query.rs
index 13155057f..5e9e3d29e 100644
--- a/crates/bevy_ecs/src/system/query.rs
+++ b/crates/bevy_ecs/src/system/query.rs
@@ -1639,15 +1639,15 @@ impl<'w, 'q, Q: QueryData, F: QueryFilter> From<&'q mut Query<'w, '_, Q, F>>
 /// This [`SystemParam`](crate::system::SystemParam) fails validation if zero or more than one matching entity exists.
 /// This will cause systems that use this parameter to be skipped.
 ///
-/// Use [`Option<QuerySingle<D, F>>`] instead if zero or one matching entities can exist.
+/// Use [`Option<Single<D, F>>`] instead if zero or one matching entities can exist.
 ///
 /// See [`Query`] for more details.
-pub struct QuerySingle<'w, D: QueryData, F: QueryFilter = ()> {
+pub struct Single<'w, D: QueryData, F: QueryFilter = ()> {
     pub(crate) item: D::Item<'w>,
     pub(crate) _filter: PhantomData<F>,
 }
 
-impl<'w, D: QueryData, F: QueryFilter> Deref for QuerySingle<'w, D, F> {
+impl<'w, D: QueryData, F: QueryFilter> Deref for Single<'w, D, F> {
     type Target = D::Item<'w>;
 
     fn deref(&self) -> &Self::Target {
@@ -1655,13 +1655,13 @@ impl<'w, D: QueryData, F: QueryFilter> Deref for QuerySingle<'w, D, F> {
     }
 }
 
-impl<'w, D: QueryData, F: QueryFilter> DerefMut for QuerySingle<'w, D, F> {
+impl<'w, D: QueryData, F: QueryFilter> DerefMut for Single<'w, D, F> {
     fn deref_mut(&mut self) -> &mut Self::Target {
         &mut self.item
     }
 }
 
-impl<'w, D: QueryData, F: QueryFilter> QuerySingle<'w, D, F> {
+impl<'w, D: QueryData, F: QueryFilter> Single<'w, D, F> {
     /// Returns the inner item with ownership.
     pub fn into_inner(self) -> D::Item<'w> {
         self.item
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index fdcf36a01..2d05a2377 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -10,7 +10,7 @@ use crate::{
         QuerySingleError, QueryState, ReadOnlyQueryData,
     },
     storage::{ResourceData, SparseSetIndex},
-    system::{Query, QuerySingle, SystemMeta},
+    system::{Query, Single, SystemMeta},
     world::{unsafe_world_cell::UnsafeWorldCell, DeferredWorld, FromWorld, World},
 };
 use bevy_ecs_macros::impl_param_set;
@@ -367,11 +367,9 @@ fn assert_component_access_compatibility(
 
 // SAFETY: Relevant query ComponentId and ArchetypeComponentId access is applied to SystemMeta. If
 // this Query conflicts with any prior access, a panic will occur.
-unsafe impl<'a, D: QueryData + 'static, F: QueryFilter + 'static> SystemParam
-    for QuerySingle<'a, D, F>
-{
+unsafe impl<'a, D: QueryData + 'static, F: QueryFilter + 'static> SystemParam for Single<'a, D, F> {
     type State = QueryState<D, F>;
-    type Item<'w, 's> = QuerySingle<'w, D, F>;
+    type Item<'w, 's> = Single<'w, D, F>;
 
     fn init_state(world: &mut World, system_meta: &mut SystemMeta) -> Self::State {
         Query::init_state(world, system_meta)
@@ -399,7 +397,7 @@ unsafe impl<'a, D: QueryData + 'static, F: QueryFilter + 'static> SystemParam
             unsafe { state.get_single_unchecked_manual(world, system_meta.last_run, change_tick) };
         let single =
             result.expect("The query was expected to contain exactly one matching entity.");
-        QuerySingle {
+        Single {
             item: single,
             _filter: PhantomData,
         }
@@ -428,13 +426,13 @@ unsafe impl<'a, D: QueryData + 'static, F: QueryFilter + 'static> SystemParam
 // SAFETY: Relevant query ComponentId and ArchetypeComponentId access is applied to SystemMeta. If
 // this Query conflicts with any prior access, a panic will occur.
 unsafe impl<'a, D: QueryData + 'static, F: QueryFilter + 'static> SystemParam
-    for Option<QuerySingle<'a, D, F>>
+    for Option<Single<'a, D, F>>
 {
     type State = QueryState<D, F>;
-    type Item<'w, 's> = Option<QuerySingle<'w, D, F>>;
+    type Item<'w, 's> = Option<Single<'w, D, F>>;
 
     fn init_state(world: &mut World, system_meta: &mut SystemMeta) -> Self::State {
-        QuerySingle::init_state(world, system_meta)
+        Single::init_state(world, system_meta)
     }
 
     unsafe fn new_archetype(
@@ -443,7 +441,7 @@ unsafe impl<'a, D: QueryData + 'static, F: QueryFilter + 'static> SystemParam
         system_meta: &mut SystemMeta,
     ) {
         // SAFETY: Delegate to existing `SystemParam` implementations.
-        unsafe { QuerySingle::new_archetype(state, archetype, system_meta) };
+        unsafe { Single::new_archetype(state, archetype, system_meta) };
     }
 
     #[inline]
@@ -458,7 +456,7 @@ unsafe impl<'a, D: QueryData + 'static, F: QueryFilter + 'static> SystemParam
         let result =
             unsafe { state.get_single_unchecked_manual(world, system_meta.last_run, change_tick) };
         match result {
-            Ok(single) => Some(QuerySingle {
+            Ok(single) => Some(Single {
                 item: single,
                 _filter: PhantomData,
             }),
@@ -489,13 +487,13 @@ unsafe impl<'a, D: QueryData + 'static, F: QueryFilter + 'static> SystemParam
 
 // SAFETY: QueryState is constrained to read-only fetches, so it only reads World.
 unsafe impl<'a, D: ReadOnlyQueryData + 'static, F: QueryFilter + 'static> ReadOnlySystemParam
-    for QuerySingle<'a, D, F>
+    for Single<'a, D, F>
 {
 }
 
 // SAFETY: QueryState is constrained to read-only fetches, so it only reads World.
 unsafe impl<'a, D: ReadOnlyQueryData + 'static, F: QueryFilter + 'static> ReadOnlySystemParam
-    for Option<QuerySingle<'a, D, F>>
+    for Option<Single<'a, D, F>>
 {
 }
 
diff --git a/examples/ecs/fallible_params.rs b/examples/ecs/fallible_params.rs
index 6965fbcf1..06fefc044 100644
--- a/examples/ecs/fallible_params.rs
+++ b/examples/ecs/fallible_params.rs
@@ -3,8 +3,8 @@
 //!
 //! Fallible parameters include:
 //! - [`Res<R>`], [`ResMut<R>`] - If resource doesn't exist.
-//! - [`QuerySingle<D, F>`] - If there is no or more than one entities matching.
-//! - [`Option<QuerySingle<D, F>>`] - If there are more than one entities matching.
+//! - [`Single<D, F>`] - If there is no or more than one entities matching.
+//! - [`Option<Single<D, F>>`] - If there are more than one entities matching.
 
 use bevy::prelude::*;
 use rand::Rng;
@@ -121,9 +121,9 @@ fn move_targets(mut enemies: Query<(&mut Transform, &mut Enemy)>, time: Res<Time
 /// If there are too many enemies, the player will cease all action (the system will not run).
 fn move_pointer(
     // `QuerySingle` ensures the system runs ONLY when exactly one matching entity exists.
-    mut player: QuerySingle<(&mut Transform, &Player)>,
+    mut player: Single<(&mut Transform, &Player)>,
     // `Option<QuerySingle>` ensures that the system runs ONLY when zero or one matching entity exists.
-    enemy: Option<QuerySingle<&Transform, (With<Enemy>, Without<Player>)>>,
+    enemy: Option<Single<&Transform, (With<Enemy>, Without<Player>)>>,
     time: Res<Time>,
 ) {
     let (player_transform, player) = &mut *player;
