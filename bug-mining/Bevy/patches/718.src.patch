diff --git a/crates/bevy_ecs/src/query/access.rs b/crates/bevy_ecs/src/query/access.rs
index da8c2ef68..659150789 100644
--- a/crates/bevy_ecs/src/query/access.rs
+++ b/crates/bevy_ecs/src/query/access.rs
@@ -3,9 +3,10 @@ use crate::storage::SparseSetIndex;
 use crate::world::World;
 use alloc::{format, string::String, vec, vec::Vec};
 use core::{fmt, fmt::Debug, marker::PhantomData};
-use derive_more::derive::From;
+use derive_more::From;
 use disqualified::ShortName;
 use fixedbitset::FixedBitSet;
+use thiserror::Error;
 
 /// A wrapper struct to make Debug representations of [`FixedBitSet`] easier
 /// to read, when used to store [`SparseSetIndex`].
@@ -773,38 +774,99 @@ impl<T: SparseSetIndex> Access<T> {
         self.archetypal.ones().map(T::get_sparse_set_index)
     }
 
-    /// Returns an iterator over the component IDs that this `Access` either
-    /// reads and writes or can't read or write.
+    /// Returns an iterator over the component IDs and their [`ComponentAccessKind`].
     ///
-    /// The returned flag specifies whether the list consists of the components
-    /// that the access *can* read or write (false) or whether the list consists
-    /// of the components that the access *can't* read or write (true).
+    /// Returns `Err(UnboundedAccess)` if the access is unbounded.
+    /// This typically occurs when an [`Access`] is marked as accessing all
+    /// components, and then adding exceptions.
     ///
-    /// Because this method depends on internal implementation details of
-    /// `Access`, it's not recommended. Prefer to manage your own lists of
-    /// accessible components if your application needs to do that.
-    #[doc(hidden)]
-    // TODO: this should be deprecated and removed, see https://github.com/bevyengine/bevy/issues/16339
-    pub fn component_reads_and_writes(&self) -> (impl Iterator<Item = T> + '_, bool) {
-        (
-            self.component_read_and_writes
-                .ones()
-                .map(T::get_sparse_set_index),
-            self.component_read_and_writes_inverted,
-        )
+    /// # Examples
+    ///
+    /// ```rust
+    /// # use bevy_ecs::query::{Access, ComponentAccessKind};
+    /// let mut access = Access::<usize>::default();
+    ///
+    /// access.add_component_read(1);
+    /// access.add_component_write(2);
+    /// access.add_archetypal(3);
+    ///
+    /// let result = access
+    ///     .try_iter_component_access()
+    ///     .map(Iterator::collect::<Vec<_>>);
+    ///
+    /// assert_eq!(
+    ///     result,
+    ///     Ok(vec![
+    ///         ComponentAccessKind::Shared(1),
+    ///         ComponentAccessKind::Exclusive(2),
+    ///         ComponentAccessKind::Archetypal(3),
+    ///     ]),
+    /// );
+    /// ```
+    pub fn try_iter_component_access(
+        &self,
+    ) -> Result<impl Iterator<Item = ComponentAccessKind<T>> + '_, UnboundedAccessError> {
+        // component_writes_inverted is only ever true when component_read_and_writes_inverted is
+        // also true. Therefore it is sufficient to check just component_read_and_writes_inverted.
+        if self.component_read_and_writes_inverted {
+            return Err(UnboundedAccessError {
+                writes_inverted: self.component_writes_inverted,
+                read_and_writes_inverted: self.component_read_and_writes_inverted,
+            });
+        }
+
+        let reads_and_writes = self.component_read_and_writes.ones().map(|index| {
+            let sparse_index = T::get_sparse_set_index(index);
+
+            if self.component_writes.contains(index) {
+                ComponentAccessKind::Exclusive(sparse_index)
+            } else {
+                ComponentAccessKind::Shared(sparse_index)
+            }
+        });
+
+        let archetypal = self
+            .archetypal
+            .ones()
+            .filter(|&index| {
+                !self.component_writes.contains(index)
+                    && !self.component_read_and_writes.contains(index)
+            })
+            .map(|index| ComponentAccessKind::Archetypal(T::get_sparse_set_index(index)));
+
+        Ok(reads_and_writes.chain(archetypal))
     }
+}
 
-    /// Returns an iterator over the component IDs that this `Access` either
-    /// writes or can't write.
-    ///
-    /// The returned flag specifies whether the list consists of the components
-    /// that the access *can* write (false) or whether the list consists of the
-    /// components that the access *can't* write (true).
-    pub(crate) fn component_writes(&self) -> (impl Iterator<Item = T> + '_, bool) {
-        (
-            self.component_writes.ones().map(T::get_sparse_set_index),
-            self.component_writes_inverted,
-        )
+/// Error returned when attempting to iterate over items included in an [`Access`]
+/// if the access excludes items rather than including them.
+#[derive(Clone, Copy, PartialEq, Eq, Debug, Error)]
+#[error("Access is unbounded")]
+pub struct UnboundedAccessError {
+    /// [`Access`] is defined in terms of _excluding_ [exclusive](ComponentAccessKind::Exclusive)
+    /// access.
+    pub writes_inverted: bool,
+    /// [`Access`] is defined in terms of _excluding_ [shared](ComponentAccessKind::Shared) and
+    /// [exclusive](ComponentAccessKind::Exclusive) access.
+    pub read_and_writes_inverted: bool,
+}
+
+/// Describes the level of access for a particular component as defined in an [`Access`].
+#[derive(PartialEq, Eq, Hash, Debug, Clone, Copy)]
+pub enum ComponentAccessKind<T> {
+    /// Archetypical access, such as `Has<Foo>`.
+    Archetypal(T),
+    /// Shared access, such as `&Foo`.
+    Shared(T),
+    /// Exclusive access, such as `&mut Foo`.
+    Exclusive(T),
+}
+
+impl<T> ComponentAccessKind<T> {
+    /// Gets the index of this `ComponentAccessKind`.
+    pub fn index(&self) -> &T {
+        let (Self::Archetypal(value) | Self::Shared(value) | Self::Exclusive(value)) = self;
+        value
     }
 }
 
@@ -1360,9 +1422,10 @@ impl<T: SparseSetIndex> Default for FilteredAccessSet<T> {
 #[cfg(test)]
 mod tests {
     use crate::query::{
-        access::AccessFilters, Access, AccessConflicts, FilteredAccess, FilteredAccessSet,
+        access::AccessFilters, Access, AccessConflicts, ComponentAccessKind, FilteredAccess,
+        FilteredAccessSet, UnboundedAccessError,
     };
-    use alloc::vec;
+    use alloc::{vec, vec::Vec};
     use core::marker::PhantomData;
     use fixedbitset::FixedBitSet;
 
@@ -1634,4 +1697,70 @@ mod tests {
 
         assert_eq!(access_a, expected);
     }
+
+    #[test]
+    fn try_iter_component_access_simple() {
+        let mut access = Access::<usize>::default();
+
+        access.add_component_read(1);
+        access.add_component_read(2);
+        access.add_component_write(3);
+        access.add_archetypal(5);
+
+        let result = access
+            .try_iter_component_access()
+            .map(Iterator::collect::<Vec<_>>);
+
+        assert_eq!(
+            result,
+            Ok(vec![
+                ComponentAccessKind::Shared(1),
+                ComponentAccessKind::Shared(2),
+                ComponentAccessKind::Exclusive(3),
+                ComponentAccessKind::Archetypal(5),
+            ]),
+        );
+    }
+
+    #[test]
+    fn try_iter_component_access_unbounded_write_all() {
+        let mut access = Access::<usize>::default();
+
+        access.add_component_read(1);
+        access.add_component_read(2);
+        access.write_all();
+
+        let result = access
+            .try_iter_component_access()
+            .map(Iterator::collect::<Vec<_>>);
+
+        assert_eq!(
+            result,
+            Err(UnboundedAccessError {
+                writes_inverted: true,
+                read_and_writes_inverted: true
+            }),
+        );
+    }
+
+    #[test]
+    fn try_iter_component_access_unbounded_read_all() {
+        let mut access = Access::<usize>::default();
+
+        access.add_component_read(1);
+        access.add_component_read(2);
+        access.read_all();
+
+        let result = access
+            .try_iter_component_access()
+            .map(Iterator::collect::<Vec<_>>);
+
+        assert_eq!(
+            result,
+            Err(UnboundedAccessError {
+                writes_inverted: false,
+                read_and_writes_inverted: true
+            }),
+        );
+    }
 }
diff --git a/crates/bevy_ecs/src/query/builder.rs b/crates/bevy_ecs/src/query/builder.rs
index 428f6a63e..81819cb9a 100644
--- a/crates/bevy_ecs/src/query/builder.rs
+++ b/crates/bevy_ecs/src/query/builder.rs
@@ -81,14 +81,14 @@ impl<'w, D: QueryData, F: QueryFilter> QueryBuilder<'w, D, F> {
                 .is_some_and(|info| info.storage_type() == StorageType::Table)
         };
 
-        let (mut component_reads_and_writes, component_reads_and_writes_inverted) =
-            self.access.access().component_reads_and_writes();
-        if component_reads_and_writes_inverted {
+        let Ok(component_accesses) = self.access.access().try_iter_component_access() else {
+            // Access is unbounded, pessimistically assume it's sparse.
             return false;
-        }
+        };
 
-        component_reads_and_writes.all(is_dense)
-            && self.access.access().archetypal().all(is_dense)
+        component_accesses
+            .map(|access| *access.index())
+            .all(is_dense)
             && !self.access.access().has_read_all_components()
             && self.access.with_filters().all(is_dense)
             && self.access.without_filters().all(is_dense)
diff --git a/crates/bevy_ecs/src/query/state.rs b/crates/bevy_ecs/src/query/state.rs
index ce58ee9cf..f6a40610b 100644
--- a/crates/bevy_ecs/src/query/state.rs
+++ b/crates/bevy_ecs/src/query/state.rs
@@ -21,8 +21,8 @@ use log::warn;
 use tracing::Span;
 
 use super::{
-    NopWorldQuery, QueryBuilder, QueryData, QueryEntityError, QueryFilter, QueryManyIter,
-    QueryManyUniqueIter, QuerySingleError, ROQueryItem, ReadOnlyQueryData,
+    ComponentAccessKind, NopWorldQuery, QueryBuilder, QueryData, QueryEntityError, QueryFilter,
+    QueryManyIter, QueryManyUniqueIter, QuerySingleError, ROQueryItem, ReadOnlyQueryData,
 };
 
 /// An ID for either a table or an archetype. Used for Query iteration.
@@ -681,23 +681,22 @@ impl<D: QueryData, F: QueryFilter> QueryState<D, F> {
         access: &mut Access<ArchetypeComponentId>,
     ) {
         // As a fast path, we can iterate directly over the components involved
-        // if the `access` isn't inverted.
-        let (component_reads_and_writes, component_reads_and_writes_inverted) =
-            self.component_access.access.component_reads_and_writes();
-        let (component_writes, component_writes_inverted) =
-            self.component_access.access.component_writes();
-
-        if !component_reads_and_writes_inverted && !component_writes_inverted {
-            component_reads_and_writes.for_each(|id| {
-                if let Some(id) = archetype.get_archetype_component_id(id) {
-                    access.add_component_read(id);
-                }
-            });
-            component_writes.for_each(|id| {
-                if let Some(id) = archetype.get_archetype_component_id(id) {
-                    access.add_component_write(id);
+        // if the `access` is finite.
+        if let Ok(iter) = self.component_access.access.try_iter_component_access() {
+            iter.for_each(|component_access| {
+                if let Some(id) = archetype.get_archetype_component_id(*component_access.index()) {
+                    match component_access {
+                        ComponentAccessKind::Archetypal(_) => {}
+                        ComponentAccessKind::Shared(_) => {
+                            access.add_component_read(id);
+                        }
+                        ComponentAccessKind::Exclusive(_) => {
+                            access.add_component_write(id);
+                        }
+                    }
                 }
             });
+
             return;
         }
 
diff --git a/examples/ecs/dynamic.rs b/examples/ecs/dynamic.rs
index 09db13ae2..bd993d441 100644
--- a/examples/ecs/dynamic.rs
+++ b/examples/ecs/dynamic.rs
@@ -13,7 +13,7 @@ use bevy::{
         component::{
             ComponentCloneBehavior, ComponentDescriptor, ComponentId, ComponentInfo, StorageType,
         },
-        query::QueryData,
+        query::{ComponentAccessKind, QueryData},
         world::FilteredEntityMut,
     },
     prelude::*,
@@ -157,9 +157,10 @@ fn main() {
                 query.iter_mut(&mut world).for_each(|filtered_entity| {
                     let terms = filtered_entity
                         .access()
-                        .component_reads_and_writes()
-                        .0
-                        .map(|id| {
+                        .try_iter_component_access()
+                        .unwrap()
+                        .map(|component_access| {
+                            let id = *component_access.index();
                             let ptr = filtered_entity.get_by_id(id).unwrap();
                             let info = component_info.get(&id).unwrap();
                             let len = info.layout().size() / size_of::<u64>();
@@ -175,7 +176,7 @@ fn main() {
                             };
 
                             // If we have write access, increment each value once
-                            if filtered_entity.access().has_component_write(id) {
+                            if matches!(component_access, ComponentAccessKind::Exclusive(_)) {
                                 data.iter_mut().for_each(|data| {
                                     *data += 1;
                                 });
