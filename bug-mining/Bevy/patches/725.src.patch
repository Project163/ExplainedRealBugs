diff --git a/crates/bevy_ecs/Cargo.toml b/crates/bevy_ecs/Cargo.toml
index 9a9c15de9..2b8d2f0d5 100644
--- a/crates/bevy_ecs/Cargo.toml
+++ b/crates/bevy_ecs/Cargo.toml
@@ -37,7 +37,7 @@ reflect_functions = ["bevy_reflect", "bevy_reflect/functions"]
 configurable_error_handler = []
 
 ## Enables automatic backtrace capturing in BevyError
-backtrace = []
+backtrace = ["std"]
 
 # Debugging Features
 
diff --git a/crates/bevy_ecs/src/error/bevy_error.rs b/crates/bevy_ecs/src/error/bevy_error.rs
index 73777bad7..9632d89bc 100644
--- a/crates/bevy_ecs/src/error/bevy_error.rs
+++ b/crates/bevy_ecs/src/error/bevy_error.rs
@@ -117,7 +117,7 @@ impl Debug for BevyError {
                 }
                 if !full_backtrace {
                     if std::thread::panicking() {
-                        SKIP_NORMAL_BACKTRACE.store(1, core::sync::atomic::Ordering::Relaxed);
+                        SKIP_NORMAL_BACKTRACE.set(true);
                     }
                     writeln!(f, "{FILTER_MESSAGE}")?;
                 }
@@ -132,22 +132,23 @@ impl Debug for BevyError {
 const FILTER_MESSAGE: &str = "note: Some \"noisy\" backtrace lines have been filtered out. Run with `BEVY_BACKTRACE=full` for a verbose backtrace.";
 
 #[cfg(feature = "backtrace")]
-static SKIP_NORMAL_BACKTRACE: core::sync::atomic::AtomicUsize =
-    core::sync::atomic::AtomicUsize::new(0);
+std::thread_local! {
+    static SKIP_NORMAL_BACKTRACE: core::cell::Cell<bool> =
+        const { core::cell::Cell::new(false) };
+}
 
 /// When called, this will skip the currently configured panic hook when a [`BevyError`] backtrace has already been printed.
-#[cfg(feature = "std")]
+#[cfg(feature = "backtrace")]
 pub fn bevy_error_panic_hook(
     current_hook: impl Fn(&std::panic::PanicHookInfo),
 ) -> impl Fn(&std::panic::PanicHookInfo) {
     move |info| {
-        if SKIP_NORMAL_BACKTRACE.load(core::sync::atomic::Ordering::Relaxed) > 0 {
+        if SKIP_NORMAL_BACKTRACE.replace(false) {
             if let Some(payload) = info.payload().downcast_ref::<&str>() {
                 std::println!("{payload}");
             } else if let Some(payload) = info.payload().downcast_ref::<alloc::string::String>() {
                 std::println!("{payload}");
             }
-            SKIP_NORMAL_BACKTRACE.store(0, core::sync::atomic::Ordering::Relaxed);
             return;
         }
 
