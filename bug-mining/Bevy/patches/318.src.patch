diff --git a/examples/camera/first_person_view_model.rs b/examples/camera/first_person_view_model.rs
index d2e6c2437..9a91eb324 100644
--- a/examples/camera/first_person_view_model.rs
+++ b/examples/camera/first_person_view_model.rs
@@ -43,7 +43,7 @@
 //! | arrow down           | Increase FOV  |
 
 use bevy::color::palettes::tailwind;
-use bevy::input::mouse::MouseMotion;
+use bevy::input::mouse::AccumulatedMouseMotion;
 use bevy::pbr::NotShadowCaster;
 use bevy::prelude::*;
 use bevy::render::view::RenderLayers;
@@ -219,13 +219,15 @@ fn spawn_text(mut commands: Commands) {
 }
 
 fn move_player(
-    mut mouse_motion: EventReader<MouseMotion>,
+    accumulated_mouse_motion: Res<AccumulatedMouseMotion>,
     mut player: Query<&mut Transform, With<Player>>,
 ) {
     let mut transform = player.single_mut();
-    for motion in mouse_motion.read() {
-        let yaw = -motion.delta.x * 0.003;
-        let pitch = -motion.delta.y * 0.002;
+    let delta = accumulated_mouse_motion.delta;
+
+    if delta != Vec2::ZERO {
+        let yaw = -delta.x * 0.003;
+        let pitch = -delta.y * 0.002;
         // Order of rotations is important, see <https://gamedev.stackexchange.com/a/136175/103059>
         transform.rotate_y(yaw);
         transform.rotate_local_x(pitch);
diff --git a/examples/helpers/camera_controller.rs b/examples/helpers/camera_controller.rs
index 75e428aa3..86defefb9 100644
--- a/examples/helpers/camera_controller.rs
+++ b/examples/helpers/camera_controller.rs
@@ -3,7 +3,7 @@
 //! - Copy the code for the [`CameraControllerPlugin`] and add the plugin to your App.
 //! - Attach the [`CameraController`] component to an entity with a [`Camera3dBundle`].
 
-use bevy::input::mouse::{MouseMotion, MouseScrollUnit, MouseWheel};
+use bevy::input::mouse::{AccumulatedMouseMotion, AccumulatedMouseScroll, MouseScrollUnit};
 use bevy::prelude::*;
 use bevy::window::CursorGrabMode;
 use std::{f32::consts::*, fmt};
@@ -101,8 +101,8 @@ Freecam Controls:
 fn run_camera_controller(
     time: Res<Time>,
     mut windows: Query<&mut Window>,
-    mut mouse_events: EventReader<MouseMotion>,
-    mut scroll_events: EventReader<MouseWheel>,
+    accumulated_mouse_motion: Res<AccumulatedMouseMotion>,
+    accumulated_mouse_scroll: Res<AccumulatedMouseScroll>,
     mouse_button_input: Res<ButtonInput<MouseButton>>,
     key_input: Res<ButtonInput<KeyCode>>,
     mut toggle_cursor_grab: Local<bool>,
@@ -120,18 +120,16 @@ fn run_camera_controller(
             info!("{}", *controller);
         }
         if !controller.enabled {
-            mouse_events.clear();
             return;
         }
 
         let mut scroll = 0.0;
-        for scroll_event in scroll_events.read() {
-            let amount = match scroll_event.unit {
-                MouseScrollUnit::Line => scroll_event.y,
-                MouseScrollUnit::Pixel => scroll_event.y / 16.0,
-            };
-            scroll += amount;
-        }
+
+        let amount = match accumulated_mouse_scroll.unit {
+            MouseScrollUnit::Line => accumulated_mouse_scroll.delta.y,
+            MouseScrollUnit::Pixel => accumulated_mouse_scroll.delta.y / 16.0,
+        };
+        scroll += amount;
         controller.walk_speed += scroll * controller.scroll_factor * controller.walk_speed;
         controller.run_speed = controller.walk_speed * 3.0;
 
@@ -212,21 +210,13 @@ fn run_camera_controller(
         }
 
         // Handle mouse input
-        let mut mouse_delta = Vec2::ZERO;
-        if cursor_grab {
-            for mouse_event in mouse_events.read() {
-                mouse_delta += mouse_event.delta;
-            }
-        } else {
-            mouse_events.clear();
-        }
-
-        if mouse_delta != Vec2::ZERO {
+        if accumulated_mouse_motion.delta != Vec2::ZERO && cursor_grab {
             // Apply look update
             controller.pitch = (controller.pitch
-                - mouse_delta.y * RADIANS_PER_DOT * controller.sensitivity)
+                - accumulated_mouse_motion.delta.y * RADIANS_PER_DOT * controller.sensitivity)
                 .clamp(-PI / 2., PI / 2.);
-            controller.yaw -= mouse_delta.x * RADIANS_PER_DOT * controller.sensitivity;
+            controller.yaw -=
+                accumulated_mouse_motion.delta.x * RADIANS_PER_DOT * controller.sensitivity;
             transform.rotation =
                 Quat::from_euler(EulerRot::ZYX, 0.0, controller.yaw, controller.pitch);
         }
diff --git a/examples/math/random_sampling.rs b/examples/math/random_sampling.rs
index 0a8a0bb62..55d509a09 100644
--- a/examples/math/random_sampling.rs
+++ b/examples/math/random_sampling.rs
@@ -1,7 +1,7 @@
 //! This example shows how to sample random points from primitive shapes.
 
 use bevy::{
-    input::mouse::{MouseButtonInput, MouseMotion},
+    input::mouse::{AccumulatedMouseMotion, MouseButtonInput},
     math::prelude::*,
     prelude::*,
     render::mesh::SphereKind,
@@ -119,7 +119,7 @@ fn setup(
             R: Restart (erase all samples).\n\
             S: Add one random sample.\n\
             D: Add 100 random samples.\n\
-            Rotate camera by panning left/right.",
+            Rotate camera by holding left mouse and panning left/right.",
             TextStyle::default(),
         )
         .with_style(Style {
@@ -230,8 +230,8 @@ fn handle_keypress(
 
 // Handle user mouse input for panning the camera around:
 fn handle_mouse(
+    accumulated_mouse_motion: Res<AccumulatedMouseMotion>,
     mut button_events: EventReader<MouseButtonInput>,
-    mut motion_events: EventReader<MouseMotion>,
     mut camera: Query<&mut Transform, With<Camera>>,
     mut mouse_pressed: ResMut<MousePressed>,
 ) {
@@ -247,7 +247,9 @@ fn handle_mouse(
     if !mouse_pressed.0 {
         return;
     }
-    let displacement: f32 = motion_events.read().map(|motion| motion.delta.x).sum();
-    let mut camera_transform = camera.single_mut();
-    camera_transform.rotate_around(Vec3::ZERO, Quat::from_rotation_y(-displacement / 150.));
+    if accumulated_mouse_motion.delta != Vec2::ZERO {
+        let displacement = accumulated_mouse_motion.delta.x;
+        let mut camera_transform = camera.single_mut();
+        camera_transform.rotate_around(Vec3::ZERO, Quat::from_rotation_y(-displacement / 150.));
+    }
 }
diff --git a/examples/math/sampling_primitives.rs b/examples/math/sampling_primitives.rs
index 8335fe96b..6aa6feece 100644
--- a/examples/math/sampling_primitives.rs
+++ b/examples/math/sampling_primitives.rs
@@ -4,7 +4,7 @@ use std::f32::consts::PI;
 
 use bevy::{
     core_pipeline::{bloom::BloomSettings, tonemapping::Tonemapping},
-    input::mouse::{MouseButtonInput, MouseMotion, MouseWheel},
+    input::mouse::{AccumulatedMouseMotion, AccumulatedMouseScroll, MouseButtonInput},
     math::prelude::*,
     prelude::*,
 };
@@ -392,7 +392,7 @@ fn setup(
             R: Restart (erase all samples).\n\
             S: Add one random sample.\n\
             D: Add 100 random samples.\n\
-            Rotate camera by panning via mouse.\n\
+            Rotate camera by holding left mouse and panning.\n\
             Zoom camera by scrolling via mouse or +/-.\n\
             Move camera by L/R arrow keys.\n\
             Tab: Toggle this text",
@@ -523,9 +523,9 @@ fn handle_keypress(
 
 // Handle user mouse input for panning the camera around:
 fn handle_mouse(
+    accumulated_mouse_motion: Res<AccumulatedMouseMotion>,
+    accumulated_mouse_scroll: Res<AccumulatedMouseScroll>,
     mut button_events: EventReader<MouseButtonInput>,
-    mut motion_events: EventReader<MouseMotion>,
-    mut scroll_events: EventReader<MouseWheel>,
     mut camera: Query<&mut CameraRig>,
     mut mouse_pressed: ResMut<MousePressed>,
 ) {
@@ -539,25 +539,25 @@ fn handle_mouse(
 
     let mut camera_rig = camera.single_mut();
 
-    let mouse_scroll = scroll_events
-        .read()
-        .fold(0.0, |acc, scroll_event| acc + scroll_event.y);
-    camera_rig.distance -= mouse_scroll / 15.0 * MAX_CAMERA_DISTANCE;
-    camera_rig.distance = camera_rig
-        .distance
-        .clamp(MIN_CAMERA_DISTANCE, MAX_CAMERA_DISTANCE);
+    if accumulated_mouse_scroll.delta != Vec2::ZERO {
+        let mouse_scroll = accumulated_mouse_scroll.delta.y;
+        camera_rig.distance -= mouse_scroll / 15.0 * MAX_CAMERA_DISTANCE;
+        camera_rig.distance = camera_rig
+            .distance
+            .clamp(MIN_CAMERA_DISTANCE, MAX_CAMERA_DISTANCE);
+    }
 
     // If the mouse is not pressed, just ignore motion events
     if !mouse_pressed.0 {
         return;
     }
-    let displacement = motion_events
-        .read()
-        .fold(Vec2::ZERO, |acc, mouse_motion| acc + mouse_motion.delta);
-    camera_rig.yaw += displacement.x / 90.;
-    camera_rig.pitch += displacement.y / 90.;
-    // The extra 0.01 is to disallow weird behaviour at the poles of the rotation
-    camera_rig.pitch = camera_rig.pitch.clamp(-PI / 2.01, PI / 2.01);
+    if accumulated_mouse_motion.delta != Vec2::ZERO {
+        let displacement = accumulated_mouse_motion.delta;
+        camera_rig.yaw += displacement.x / 90.;
+        camera_rig.pitch += displacement.y / 90.;
+        // The extra 0.01 is to disallow weird behaviour at the poles of the rotation
+        camera_rig.pitch = camera_rig.pitch.clamp(-PI / 2.01, PI / 2.01);
+    }
 }
 
 #[allow(clippy::too_many_arguments)]
diff --git a/examples/transforms/align.rs b/examples/transforms/align.rs
index 4b773688c..681523b1b 100644
--- a/examples/transforms/align.rs
+++ b/examples/transforms/align.rs
@@ -1,7 +1,7 @@
 //! This example shows how to align the orientations of objects in 3D space along two axes using the `Transform::align` API.
 
 use bevy::color::palettes::basic::{GRAY, RED, WHITE};
-use bevy::input::mouse::{MouseButtonInput, MouseMotion};
+use bevy::input::mouse::{AccumulatedMouseMotion, MouseButtonInput};
 use bevy::prelude::*;
 use rand::{Rng, SeedableRng};
 use rand_chacha::ChaCha8Rng;
@@ -209,8 +209,8 @@ fn handle_keypress(
 
 // Handle user mouse input for panning the camera around
 fn handle_mouse(
+    accumulated_mouse_motion: Res<AccumulatedMouseMotion>,
     mut button_events: EventReader<MouseButtonInput>,
-    mut motion_events: EventReader<MouseMotion>,
     mut camera: Query<&mut Transform, With<Camera>>,
     mut mouse_pressed: ResMut<MousePressed>,
 ) {
@@ -226,11 +226,11 @@ fn handle_mouse(
     if !mouse_pressed.0 {
         return;
     }
-    let displacement = motion_events
-        .read()
-        .fold(0., |acc, mouse_motion| acc + mouse_motion.delta.x);
-    let mut camera_transform = camera.single_mut();
-    camera_transform.rotate_around(Vec3::ZERO, Quat::from_rotation_y(-displacement / 75.));
+    if accumulated_mouse_motion.delta != Vec2::ZERO {
+        let displacement = accumulated_mouse_motion.delta.x;
+        let mut camera_transform = camera.single_mut();
+        camera_transform.rotate_around(Vec3::ZERO, Quat::from_rotation_y(-displacement / 75.));
+    }
 }
 
 // Helper functions (i.e. non-system functions)
