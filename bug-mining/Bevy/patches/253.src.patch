diff --git a/Cargo.toml b/Cargo.toml
index 9d06f9868..c59b9bc75 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -354,6 +354,7 @@ serde = { version = "1", features = ["derive"] }
 bytemuck = "1.7"
 # Needed to poll Task examples
 futures-lite = "2.0.1"
+async-std = "1.12"
 crossbeam-channel = "0.5.0"
 argh = "0.1.12"
 thiserror = "1.0"
diff --git a/examples/async_tasks/async_compute.rs b/examples/async_tasks/async_compute.rs
index bf4b8a26e..563b9e4e4 100644
--- a/examples/async_tasks/async_compute.rs
+++ b/examples/async_tasks/async_compute.rs
@@ -8,7 +8,7 @@ use bevy::{
     tasks::{block_on, futures_lite::future, AsyncComputeTaskPool, Task},
 };
 use rand::Rng;
-use std::{thread, time::Duration};
+use std::time::Duration;
 
 fn main() {
     App::new()
@@ -60,12 +60,10 @@ fn spawn_tasks(mut commands: Commands) {
                 // spawn() can be used to poll for the result
                 let entity = commands.spawn_empty().id();
                 let task = thread_pool.spawn(async move {
-                    let mut rng = rand::thread_rng();
-
-                    let duration = Duration::from_secs_f32(rng.gen_range(0.05..0.2));
+                    let duration = Duration::from_secs_f32(rand::thread_rng().gen_range(0.05..5.0));
 
                     // Pretend this is a time-intensive function. :)
-                    thread::sleep(duration);
+                    async_std::task::sleep(duration).await;
 
                     // Such hard work, all done!
                     let transform = Transform::from_xyz(x as f32, y as f32, z as f32);
