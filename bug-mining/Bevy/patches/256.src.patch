diff --git a/crates/bevy_winit/src/system.rs b/crates/bevy_winit/src/system.rs
index 84975bf1e..48b0a5ef6 100644
--- a/crates/bevy_winit/src/system.rs
+++ b/crates/bevy_winit/src/system.rs
@@ -15,6 +15,8 @@ use bevy_window::{
 use winit::dpi::{LogicalPosition, LogicalSize, PhysicalPosition, PhysicalSize};
 use winit::event_loop::ActiveEventLoop;
 
+use bevy_app::AppExit;
+use bevy_ecs::prelude::EventReader;
 use bevy_ecs::query::With;
 #[cfg(target_os = "ios")]
 use winit::platform::ios::WindowExtIOS;
@@ -116,14 +118,16 @@ pub fn create_windows<F: QueryFilter + 'static>(
     }
 }
 
+#[allow(clippy::too_many_arguments)]
 pub(crate) fn despawn_windows(
     closing: Query<Entity, With<ClosingWindow>>,
     mut closed: RemovedComponents<Window>,
-    window_entities: Query<&Window>,
+    window_entities: Query<Entity, With<Window>>,
     mut closing_events: EventWriter<WindowClosing>,
     mut closed_events: EventWriter<WindowClosed>,
     mut winit_windows: NonSendMut<WinitWindows>,
     mut windows_to_drop: Local<Vec<WindowWrapper<winit::window::Window>>>,
+    mut exit_events: EventReader<AppExit>,
 ) {
     // Drop all the windows that are waiting to be closed
     windows_to_drop.clear();
@@ -146,6 +150,15 @@ pub(crate) fn despawn_windows(
             closed_events.send(WindowClosed { window });
         }
     }
+
+    // On macOS, when exiting, we need to tell the rendering thread the windows are about to
+    // close to ensure that they are dropped on the main thread. Otherwise, the app will hang.
+    if !exit_events.is_empty() {
+        exit_events.clear();
+        for window in window_entities.iter() {
+            closing_events.send(WindowClosing { window });
+        }
+    }
 }
 
 /// The cached state of the window so we can check which properties were changed from within the app.
