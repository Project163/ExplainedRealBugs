diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_system.rs b/benches/benches/bevy_ecs/iteration/iter_simple_system.rs
index 903ff0819..5b08bfd7e 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_system.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_system.rs
@@ -42,6 +42,6 @@ impl Benchmark {
 
     #[inline(never)]
     pub fn run(&mut self) {
-        self.1.run((), &mut self.0);
+        self.1.run((), &mut self.0).unwrap();
     }
 }
diff --git a/crates/bevy_ecs/src/change_detection.rs b/crates/bevy_ecs/src/change_detection.rs
index 006b738ca..05b76207b 100644
--- a/crates/bevy_ecs/src/change_detection.rs
+++ b/crates/bevy_ecs/src/change_detection.rs
@@ -188,10 +188,10 @@ pub trait DetectChangesMut: DetectChanges {
     /// #
     /// # // first time `reset_score` runs, the score is changed.
     /// # schedule.run(&mut world);
-    /// # assert!(score_changed.run((), &mut world));
+    /// # assert!(score_changed.run((), &mut world).unwrap());
     /// # // second time `reset_score` runs, the score is not changed.
     /// # schedule.run(&mut world);
-    /// # assert!(!score_changed.run((), &mut world));
+    /// # assert!(!score_changed.run((), &mut world).unwrap());
     /// ```
     #[inline]
     #[track_caller]
@@ -263,12 +263,12 @@ pub trait DetectChangesMut: DetectChanges {
     /// #
     /// # // first time `reset_score` runs, the score is changed.
     /// # schedule.run(&mut world);
-    /// # assert!(score_changed.run((), &mut world));
-    /// # assert!(score_changed_event.run((), &mut world));
+    /// # assert!(score_changed.run((), &mut world).unwrap());
+    /// # assert!(score_changed_event.run((), &mut world).unwrap());
     /// # // second time `reset_score` runs, the score is not changed.
     /// # schedule.run(&mut world);
-    /// # assert!(!score_changed.run((), &mut world));
-    /// # assert!(!score_changed_event.run((), &mut world));
+    /// # assert!(!score_changed.run((), &mut world).unwrap());
+    /// # assert!(!score_changed_event.run((), &mut world).unwrap());
     /// ```
     #[inline]
     #[must_use = "If you don't need to handle the previous value, use `set_if_neq` instead."]
@@ -315,10 +315,10 @@ pub trait DetectChangesMut: DetectChanges {
     /// #
     /// # // first time `reset_score` runs, the score is changed.
     /// # schedule.run(&mut world);
-    /// # assert!(message_changed.run((), &mut world));
+    /// # assert!(message_changed.run((), &mut world).unwrap());
     /// # // second time `reset_score` runs, the score is not changed.
     /// # schedule.run(&mut world);
-    /// # assert!(!message_changed.run((), &mut world));
+    /// # assert!(!message_changed.run((), &mut world).unwrap());
     /// ```
     fn clone_from_if_neq<T>(&mut self, value: &T) -> bool
     where
@@ -1566,7 +1566,7 @@ mod tests {
 
         // world: 1, system last ran: 0, component changed: 1
         // The spawn will be detected since it happened after the system "last ran".
-        assert!(change_detected_system.run((), &mut world));
+        assert!(change_detected_system.run((), &mut world).unwrap());
 
         // world: 1 + MAX_CHANGE_AGE
         let change_tick = world.change_tick.get_mut();
@@ -1576,7 +1576,7 @@ mod tests {
         // Since we clamp things to `MAX_CHANGE_AGE` for determinism,
         // `ComponentTicks::is_changed` will now see `MAX_CHANGE_AGE > MAX_CHANGE_AGE`
         // and return `false`.
-        assert!(!change_expired_system.run((), &mut world));
+        assert!(!change_expired_system.run((), &mut world).unwrap());
     }
 
     #[test]
diff --git a/crates/bevy_ecs/src/event/mod.rs b/crates/bevy_ecs/src/event/mod.rs
index fd624d1ab..d9ee15a2d 100644
--- a/crates/bevy_ecs/src/event/mod.rs
+++ b/crates/bevy_ecs/src/event/mod.rs
@@ -528,20 +528,20 @@ mod tests {
             });
         reader.initialize(&mut world);
 
-        let last = reader.run((), &mut world);
+        let last = reader.run((), &mut world).unwrap();
         assert!(last.is_none(), "EventReader should be empty");
 
         world.send_event(TestEvent { i: 0 });
-        let last = reader.run((), &mut world);
+        let last = reader.run((), &mut world).unwrap();
         assert_eq!(last, Some(TestEvent { i: 0 }));
 
         world.send_event(TestEvent { i: 1 });
         world.send_event(TestEvent { i: 2 });
         world.send_event(TestEvent { i: 3 });
-        let last = reader.run((), &mut world);
+        let last = reader.run((), &mut world).unwrap();
         assert_eq!(last, Some(TestEvent { i: 3 }));
 
-        let last = reader.run((), &mut world);
+        let last = reader.run((), &mut world).unwrap();
         assert!(last.is_none(), "EventReader should be empty");
     }
 
@@ -558,20 +558,20 @@ mod tests {
             });
         mutator.initialize(&mut world);
 
-        let last = mutator.run((), &mut world);
+        let last = mutator.run((), &mut world).unwrap();
         assert!(last.is_none(), "EventMutator should be empty");
 
         world.send_event(TestEvent { i: 0 });
-        let last = mutator.run((), &mut world);
+        let last = mutator.run((), &mut world).unwrap();
         assert_eq!(last, Some(TestEvent { i: 0 }));
 
         world.send_event(TestEvent { i: 1 });
         world.send_event(TestEvent { i: 2 });
         world.send_event(TestEvent { i: 3 });
-        let last = mutator.run((), &mut world);
+        let last = mutator.run((), &mut world).unwrap();
         assert_eq!(last, Some(TestEvent { i: 3 }));
 
-        let last = mutator.run((), &mut world);
+        let last = mutator.run((), &mut world).unwrap();
         assert!(last.is_none(), "EventMutator should be empty");
     }
 
diff --git a/crates/bevy_ecs/src/observer/runner.rs b/crates/bevy_ecs/src/observer/runner.rs
index acc2830a7..f25e742ee 100644
--- a/crates/bevy_ecs/src/observer/runner.rs
+++ b/crates/bevy_ecs/src/observer/runner.rs
@@ -3,8 +3,12 @@
 use core::any::Any;
 
 use crate::{
-    error::ErrorContext, observer::ObserverTrigger, prelude::*, query::DebugCheckedUnwrap,
-    system::ObserverSystem, world::DeferredWorld,
+    error::ErrorContext,
+    observer::ObserverTrigger,
+    prelude::*,
+    query::DebugCheckedUnwrap,
+    system::{ObserverSystem, RunSystemError},
+    world::DeferredWorld,
 };
 use bevy_ptr::PtrMut;
 
@@ -64,37 +68,23 @@ pub(super) fn observer_system_runner<E: Event, B: Bundle, S: ObserverSystem<E, B
         #[cfg(feature = "hotpatching")]
         (*system).refresh_hotpatch();
 
-        match (*system).validate_param_unsafe(world) {
-            Ok(()) => {
-                if let Err(err) = (*system).run_unsafe(trigger, world) {
-                    let handler = state
-                        .error_handler
-                        .unwrap_or_else(|| world.default_error_handler());
-                    handler(
-                        err,
-                        ErrorContext::Observer {
-                            name: (*system).name(),
-                            last_run: (*system).get_last_run(),
-                        },
-                    );
-                };
-                (*system).queue_deferred(world.into_deferred());
-            }
-            Err(e) => {
-                if !e.skipped {
-                    let handler = state
-                        .error_handler
-                        .unwrap_or_else(|| world.default_error_handler());
-                    handler(
-                        e.into(),
-                        ErrorContext::Observer {
-                            name: (*system).name(),
-                            last_run: (*system).get_last_run(),
-                        },
-                    );
-                }
-            }
-        }
+        if let Err(RunSystemError::Failed(err)) = (*system)
+            .validate_param_unsafe(world)
+            .map_err(From::from)
+            .and_then(|()| (*system).run_unsafe(trigger, world))
+        {
+            let handler = state
+                .error_handler
+                .unwrap_or_else(|| world.default_error_handler());
+            handler(
+                err,
+                ErrorContext::Observer {
+                    name: (*system).name(),
+                    last_run: (*system).get_last_run(),
+                },
+            );
+        };
+        (*system).queue_deferred(world.into_deferred());
     }
 }
 
diff --git a/crates/bevy_ecs/src/query/mod.rs b/crates/bevy_ecs/src/query/mod.rs
index 0bd3bbed2..94772cc9b 100644
--- a/crates/bevy_ecs/src/query/mod.rs
+++ b/crates/bevy_ecs/src/query/mod.rs
@@ -717,7 +717,7 @@ mod tests {
             }
             let mut system = IntoSystem::into_system(system);
             system.initialize(&mut world);
-            system.run((), &mut world);
+            system.run((), &mut world).unwrap();
         }
         {
             fn system(has_a: Query<Entity, With<A>>, mut b_query: Query<&mut B>) {
@@ -728,7 +728,7 @@ mod tests {
             }
             let mut system = IntoSystem::into_system(system);
             system.initialize(&mut world);
-            system.run((), &mut world);
+            system.run((), &mut world).unwrap();
         }
         {
             fn system(query: Query<(Option<&A>, &B)>) {
@@ -741,7 +741,7 @@ mod tests {
             }
             let mut system = IntoSystem::into_system(system);
             system.initialize(&mut world);
-            system.run((), &mut world);
+            system.run((), &mut world).unwrap();
         }
     }
 
diff --git a/crates/bevy_ecs/src/schedule/condition.rs b/crates/bevy_ecs/src/schedule/condition.rs
index 9a7ce5d50..1a4a7a810 100644
--- a/crates/bevy_ecs/src/schedule/condition.rs
+++ b/crates/bevy_ecs/src/schedule/condition.rs
@@ -3,8 +3,8 @@ use bevy_utils::prelude::DebugName;
 use core::ops::Not;
 
 use crate::system::{
-    Adapt, AdapterSystem, CombinatorSystem, Combine, IntoSystem, ReadOnlySystem, System, SystemIn,
-    SystemInput,
+    Adapt, AdapterSystem, CombinatorSystem, Combine, IntoSystem, ReadOnlySystem, RunSystemError,
+    System, SystemIn, SystemInput,
 };
 
 /// A type-erased run condition stored in a [`Box`].
@@ -12,18 +12,8 @@ pub type BoxedCondition<In = ()> = Box<dyn ReadOnlySystem<In = In, Out = bool>>;
 
 /// A system that determines if one or more scheduled systems should run.
 ///
-/// `SystemCondition` is sealed and implemented for functions and closures with
-/// [read-only](crate::system::ReadOnlySystemParam) parameters that convert into
-/// [`System<Out = bool>`](System), [`System<Out = Result<(), BevyError>>`](System) or
-/// [`System<Out = Result<bool, BevyError>>`](System).
-///
-/// `SystemCondition` offers a private method
-/// (called by [`run_if`](crate::schedule::IntoScheduleConfigs::run_if) and the provided methods)
-/// that converts the implementing system into a condition (system) returning a bool.
-/// Depending on the output type of the implementing system:
-/// - `bool`: the implementing system is used as the condition;
-/// - `Result<(), BevyError>`: the condition returns `true` if and only if the implementing system returns `Ok(())`;
-/// - `Result<bool, BevyError>`: the condition returns `true` if and only if the implementing system returns `Ok(true)`.
+/// Implemented for functions and closures that convert into [`System<Out=bool>`](System)
+/// with [read-only](crate::system::ReadOnlySystemParam) parameters.
 ///
 /// # Marker type parameter
 ///
@@ -42,7 +32,7 @@ pub type BoxedCondition<In = ()> = Box<dyn ReadOnlySystem<In = In, Out = bool>>;
 /// ```
 ///
 /// # Examples
-/// A condition that returns `true` every other time it's called.
+/// A condition that returns true every other time it's called.
 /// ```
 /// # use bevy_ecs::prelude::*;
 /// fn every_other_time() -> impl SystemCondition<()> {
@@ -65,12 +55,12 @@ pub type BoxedCondition<In = ()> = Box<dyn ReadOnlySystem<In = In, Out = bool>>;
 /// # assert!(!world.resource::<DidRun>().0);
 /// ```
 ///
-/// A condition that takes a `bool` as an input and returns it unchanged.
+/// A condition that takes a bool as an input and returns it unchanged.
 ///
 /// ```
 /// # use bevy_ecs::prelude::*;
 /// fn identity() -> impl SystemCondition<(), In<bool>> {
-///     IntoSystem::into_system(|In(x)| x)
+///     IntoSystem::into_system(|In(x): In<bool>| x)
 /// }
 ///
 /// # fn always_true() -> bool { true }
@@ -82,30 +72,8 @@ pub type BoxedCondition<In = ()> = Box<dyn ReadOnlySystem<In = In, Out = bool>>;
 /// # world.insert_resource(DidRun(false));
 /// # app.run(&mut world);
 /// # assert!(world.resource::<DidRun>().0);
-/// ```
-///
-/// A condition returning a `Result<(), BevyError>`
-///
-/// ```
-/// # use bevy_ecs::prelude::*;
-/// # #[derive(Component)] struct Player;
-/// fn player_exists(q_player: Query<(), With<Player>>) -> Result {
-///     Ok(q_player.single()?)
-/// }
-///
-/// # let mut app = Schedule::default();
-/// # #[derive(Resource)] struct DidRun(bool);
-/// # fn my_system(mut did_run: ResMut<DidRun>) { did_run.0 = true; }
-/// app.add_systems(my_system.run_if(player_exists));
-/// # let mut world = World::new();
-/// # world.insert_resource(DidRun(false));
-/// # app.run(&mut world);
-/// # assert!(!world.resource::<DidRun>().0);
-/// # world.spawn(Player);
-/// # app.run(&mut world);
-/// # assert!(world.resource::<DidRun>().0);
-pub trait SystemCondition<Marker, In: SystemInput = (), Out = bool>:
-    sealed::SystemCondition<Marker, In, Out>
+pub trait SystemCondition<Marker, In: SystemInput = ()>:
+    sealed::SystemCondition<Marker, In>
 {
     /// Returns a new run condition that only returns `true`
     /// if both this one and the passed `and` return `true`.
@@ -404,61 +372,28 @@ pub trait SystemCondition<Marker, In: SystemInput = (), Out = bool>:
     }
 }
 
-impl<Marker, In: SystemInput, Out, F> SystemCondition<Marker, In, Out> for F where
-    F: sealed::SystemCondition<Marker, In, Out>
+impl<Marker, In: SystemInput, F> SystemCondition<Marker, In> for F where
+    F: sealed::SystemCondition<Marker, In>
 {
 }
 
 mod sealed {
-    use crate::{
-        error::BevyError,
-        system::{IntoSystem, ReadOnlySystem, SystemInput},
-    };
+    use crate::system::{IntoSystem, ReadOnlySystem, SystemInput};
 
-    pub trait SystemCondition<Marker, In: SystemInput, Out>:
-        IntoSystem<In, Out, Marker, System = Self::ReadOnlySystem>
+    pub trait SystemCondition<Marker, In: SystemInput>:
+        IntoSystem<In, bool, Marker, System = Self::ReadOnlySystem>
     {
         // This associated type is necessary to let the compiler
         // know that `Self::System` is `ReadOnlySystem`.
-        type ReadOnlySystem: ReadOnlySystem<In = In, Out = Out>;
-
-        fn into_condition_system(self) -> impl ReadOnlySystem<In = In, Out = bool>;
+        type ReadOnlySystem: ReadOnlySystem<In = In, Out = bool>;
     }
 
-    impl<Marker, In: SystemInput, F> SystemCondition<Marker, In, bool> for F
+    impl<Marker, In: SystemInput, F> SystemCondition<Marker, In> for F
     where
         F: IntoSystem<In, bool, Marker>,
         F::System: ReadOnlySystem,
     {
         type ReadOnlySystem = F::System;
-
-        fn into_condition_system(self) -> impl ReadOnlySystem<In = In, Out = bool> {
-            IntoSystem::into_system(self)
-        }
-    }
-
-    impl<Marker, In: SystemInput, F> SystemCondition<Marker, In, Result<(), BevyError>> for F
-    where
-        F: IntoSystem<In, Result<(), BevyError>, Marker>,
-        F::System: ReadOnlySystem,
-    {
-        type ReadOnlySystem = F::System;
-
-        fn into_condition_system(self) -> impl ReadOnlySystem<In = In, Out = bool> {
-            IntoSystem::into_system(self.map(|result| result.is_ok()))
-        }
-    }
-
-    impl<Marker, In: SystemInput, F> SystemCondition<Marker, In, Result<bool, BevyError>> for F
-    where
-        F: IntoSystem<In, Result<bool, BevyError>, Marker>,
-        F::System: ReadOnlySystem,
-    {
-        type ReadOnlySystem = F::System;
-
-        fn into_condition_system(self) -> impl ReadOnlySystem<In = In, Out = bool> {
-            IntoSystem::into_system(self.map(|result| matches!(result, Ok(true))))
-        }
     }
 }
 
@@ -1176,9 +1111,9 @@ impl<S: System<Out: Not>> Adapt<S> for NotMarker {
     fn adapt(
         &mut self,
         input: <Self::In as SystemInput>::Inner<'_>,
-        run_system: impl FnOnce(SystemIn<'_, S>) -> S::Out,
-    ) -> Self::Out {
-        !run_system(input)
+        run_system: impl FnOnce(SystemIn<'_, S>) -> Result<S::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        run_system(input).map(Not::not)
     }
 }
 
@@ -1214,10 +1149,10 @@ where
 
     fn combine(
         input: <Self::In as SystemInput>::Inner<'_>,
-        a: impl FnOnce(SystemIn<'_, A>) -> A::Out,
-        b: impl FnOnce(SystemIn<'_, A>) -> B::Out,
-    ) -> Self::Out {
-        a(input) && b(input)
+        a: impl FnOnce(SystemIn<'_, A>) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(a(input)? && b(input)?)
     }
 }
 
@@ -1235,10 +1170,10 @@ where
 
     fn combine(
         input: <Self::In as SystemInput>::Inner<'_>,
-        a: impl FnOnce(SystemIn<'_, A>) -> A::Out,
-        b: impl FnOnce(SystemIn<'_, B>) -> B::Out,
-    ) -> Self::Out {
-        !(a(input) && b(input))
+        a: impl FnOnce(SystemIn<'_, A>) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(!(a(input)? && b(input)?))
     }
 }
 
@@ -1256,10 +1191,10 @@ where
 
     fn combine(
         input: <Self::In as SystemInput>::Inner<'_>,
-        a: impl FnOnce(SystemIn<'_, A>) -> A::Out,
-        b: impl FnOnce(SystemIn<'_, B>) -> B::Out,
-    ) -> Self::Out {
-        !(a(input) || b(input))
+        a: impl FnOnce(SystemIn<'_, A>) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(!(a(input)? || b(input)?))
     }
 }
 
@@ -1277,10 +1212,10 @@ where
 
     fn combine(
         input: <Self::In as SystemInput>::Inner<'_>,
-        a: impl FnOnce(SystemIn<'_, A>) -> A::Out,
-        b: impl FnOnce(SystemIn<'_, B>) -> B::Out,
-    ) -> Self::Out {
-        a(input) || b(input)
+        a: impl FnOnce(SystemIn<'_, A>) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(a(input)? || b(input)?)
     }
 }
 
@@ -1298,10 +1233,10 @@ where
 
     fn combine(
         input: <Self::In as SystemInput>::Inner<'_>,
-        a: impl FnOnce(SystemIn<'_, A>) -> A::Out,
-        b: impl FnOnce(SystemIn<'_, B>) -> B::Out,
-    ) -> Self::Out {
-        !(a(input) ^ b(input))
+        a: impl FnOnce(SystemIn<'_, A>) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(!(a(input)? ^ b(input)?))
     }
 }
 
@@ -1319,10 +1254,10 @@ where
 
     fn combine(
         input: <Self::In as SystemInput>::Inner<'_>,
-        a: impl FnOnce(SystemIn<'_, A>) -> A::Out,
-        b: impl FnOnce(SystemIn<'_, B>) -> B::Out,
-    ) -> Self::Out {
-        a(input) ^ b(input)
+        a: impl FnOnce(SystemIn<'_, A>) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, A>) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        Ok(a(input)? ^ b(input)?)
     }
 }
 
diff --git a/crates/bevy_ecs/src/schedule/config.rs b/crates/bevy_ecs/src/schedule/config.rs
index 4826d0a66..a8dbfc810 100644
--- a/crates/bevy_ecs/src/schedule/config.rs
+++ b/crates/bevy_ecs/src/schedule/config.rs
@@ -2,8 +2,6 @@ use alloc::{boxed::Box, vec, vec::Vec};
 use variadics_please::all_tuples;
 
 use crate::{
-    error::Result,
-    never::Never,
     schedule::{
         auto_insert_apply_deferred::IgnoreDeferred,
         condition::{BoxedCondition, SystemCondition},
@@ -11,11 +9,11 @@ use crate::{
         set::{InternedSystemSet, IntoSystemSet, SystemSet},
         Chain,
     },
-    system::{BoxedSystem, InfallibleSystemWrapper, IntoSystem, ScheduleSystem, System},
+    system::{BoxedSystem, IntoSystem, ScheduleSystem, System},
 };
 
-fn new_condition<M, Out>(condition: impl SystemCondition<M, (), Out>) -> BoxedCondition {
-    let condition_system = condition.into_condition_system();
+fn new_condition<M>(condition: impl SystemCondition<M>) -> BoxedCondition {
+    let condition_system = IntoSystem::into_system(condition);
     assert!(
         condition_system.is_send(),
         "SystemCondition `{}` accesses `NonSend` resources. This is not currently supported.",
@@ -447,7 +445,7 @@ pub trait IntoScheduleConfigs<T: Schedulable<Metadata = GraphInfo, GroupMetadata
     ///
     /// Use [`distributive_run_if`](IntoScheduleConfigs::distributive_run_if) if you want the
     /// condition to be evaluated for each individual system, right before one is run.
-    fn run_if<M, Out>(self, condition: impl SystemCondition<M, (), Out>) -> ScheduleConfigs<T> {
+    fn run_if<M>(self, condition: impl SystemCondition<M>) -> ScheduleConfigs<T> {
         self.into_configs().run_if(condition)
     }
 
@@ -535,7 +533,7 @@ impl<T: Schedulable<Metadata = GraphInfo, GroupMetadata = Chain>> IntoScheduleCo
         self
     }
 
-    fn run_if<M, Out>(mut self, condition: impl SystemCondition<M, (), Out>) -> ScheduleConfigs<T> {
+    fn run_if<M>(mut self, condition: impl SystemCondition<M>) -> ScheduleConfigs<T> {
         self.run_if_dyn(new_condition(condition));
         self
     }
@@ -560,37 +558,9 @@ impl<T: Schedulable<Metadata = GraphInfo, GroupMetadata = Chain>> IntoScheduleCo
     }
 }
 
-/// Marker component to allow for conflicting implementations of [`IntoScheduleConfigs`]
-#[doc(hidden)]
-pub struct Infallible;
-
-impl<F, Marker> IntoScheduleConfigs<ScheduleSystem, (Infallible, Marker)> for F
+impl<F, Marker> IntoScheduleConfigs<ScheduleSystem, Marker> for F
 where
     F: IntoSystem<(), (), Marker>,
-{
-    fn into_configs(self) -> ScheduleConfigs<ScheduleSystem> {
-        let wrapper = InfallibleSystemWrapper::new(IntoSystem::into_system(self));
-        ScheduleConfigs::ScheduleConfig(ScheduleSystem::into_config(Box::new(wrapper)))
-    }
-}
-
-impl<F, Marker> IntoScheduleConfigs<ScheduleSystem, (Never, Marker)> for F
-where
-    F: IntoSystem<(), Never, Marker>,
-{
-    fn into_configs(self) -> ScheduleConfigs<ScheduleSystem> {
-        let wrapper = InfallibleSystemWrapper::new(IntoSystem::into_system(self));
-        ScheduleConfigs::ScheduleConfig(ScheduleSystem::into_config(Box::new(wrapper)))
-    }
-}
-
-/// Marker component to allow for conflicting implementations of [`IntoScheduleConfigs`]
-#[doc(hidden)]
-pub struct Fallible;
-
-impl<F, Marker> IntoScheduleConfigs<ScheduleSystem, (Fallible, Marker)> for F
-where
-    F: IntoSystem<(), Result, Marker>,
 {
     fn into_configs(self) -> ScheduleConfigs<ScheduleSystem> {
         let boxed_system = Box::new(IntoSystem::into_system(self));
@@ -598,7 +568,7 @@ where
     }
 }
 
-impl IntoScheduleConfigs<ScheduleSystem, ()> for BoxedSystem<(), Result> {
+impl IntoScheduleConfigs<ScheduleSystem, ()> for BoxedSystem<(), ()> {
     fn into_configs(self) -> ScheduleConfigs<ScheduleSystem> {
         ScheduleConfigs::ScheduleConfig(ScheduleSystem::into_config(self))
     }
diff --git a/crates/bevy_ecs/src/schedule/executor/mod.rs b/crates/bevy_ecs/src/schedule/executor/mod.rs
index d0ec714eb..12030c258 100644
--- a/crates/bevy_ecs/src/schedule/executor/mod.rs
+++ b/crates/bevy_ecs/src/schedule/executor/mod.rs
@@ -24,7 +24,10 @@ use crate::{
         ConditionWithAccess, InternedSystemSet, SystemKey, SystemSetKey, SystemTypeSet,
         SystemWithAccess,
     },
-    system::{ScheduleSystem, System, SystemIn, SystemParamValidationError, SystemStateFlags},
+    system::{
+        RunSystemError, ScheduleSystem, System, SystemIn, SystemParamValidationError,
+        SystemStateFlags,
+    },
     world::{unsafe_world_cell::UnsafeWorldCell, DeferredWorld, World},
 };
 
@@ -160,7 +163,7 @@ pub(super) fn is_apply_deferred(system: &ScheduleSystem) -> bool {
 
 impl System for ApplyDeferred {
     type In = ();
-    type Out = Result<()>;
+    type Out = ();
 
     fn name(&self) -> DebugName {
         DebugName::borrowed("bevy_ecs::apply_deferred")
@@ -175,7 +178,7 @@ impl System for ApplyDeferred {
         &mut self,
         _input: SystemIn<'_, Self>,
         _world: UnsafeWorldCell,
-    ) -> Self::Out {
+    ) -> Result<Self::Out, RunSystemError> {
         // This system does nothing on its own. The executor will apply deferred
         // commands from other systems instead of running this system.
         Ok(())
@@ -185,7 +188,11 @@ impl System for ApplyDeferred {
     #[inline]
     fn refresh_hotpatch(&mut self) {}
 
-    fn run(&mut self, _input: SystemIn<'_, Self>, _world: &mut World) -> Self::Out {
+    fn run(
+        &mut self,
+        _input: SystemIn<'_, Self>,
+        _world: &mut World,
+    ) -> Result<Self::Out, RunSystemError> {
         // This system does nothing on its own. The executor will apply deferred
         // commands from other systems instead of running this system.
         Ok(())
@@ -245,7 +252,7 @@ mod __rust_begin_short_backtrace {
     use crate::world::unsafe_world_cell::UnsafeWorldCell;
     use crate::{
         error::Result,
-        system::{ReadOnlySystem, ScheduleSystem},
+        system::{ReadOnlySystem, RunSystemError, ScheduleSystem},
         world::World,
     };
 
@@ -254,7 +261,10 @@ mod __rust_begin_short_backtrace {
     // This is only used by `MultiThreadedExecutor`, and would be dead code without `std`.
     #[cfg(feature = "std")]
     #[inline(never)]
-    pub(super) unsafe fn run_unsafe(system: &mut ScheduleSystem, world: UnsafeWorldCell) -> Result {
+    pub(super) unsafe fn run_unsafe(
+        system: &mut ScheduleSystem,
+        world: UnsafeWorldCell,
+    ) -> Result<(), RunSystemError> {
         let result = system.run_unsafe((), world);
         // Call `black_box` to prevent this frame from being tail-call optimized away
         black_box(());
@@ -269,13 +279,16 @@ mod __rust_begin_short_backtrace {
     pub(super) unsafe fn readonly_run_unsafe<O: 'static>(
         system: &mut dyn ReadOnlySystem<In = (), Out = O>,
         world: UnsafeWorldCell,
-    ) -> O {
+    ) -> Result<O, RunSystemError> {
         // Call `black_box` to prevent this frame from being tail-call optimized away
         black_box(system.run_unsafe((), world))
     }
 
     #[inline(never)]
-    pub(super) fn run(system: &mut ScheduleSystem, world: &mut World) -> Result {
+    pub(super) fn run(
+        system: &mut ScheduleSystem,
+        world: &mut World,
+    ) -> Result<(), RunSystemError> {
         let result = system.run((), world);
         // Call `black_box` to prevent this frame from being tail-call optimized away
         black_box(());
@@ -286,7 +299,7 @@ mod __rust_begin_short_backtrace {
     pub(super) fn run_without_applying_deferred(
         system: &mut ScheduleSystem,
         world: &mut World,
-    ) -> Result {
+    ) -> Result<(), RunSystemError> {
         let result = system.run_without_applying_deferred((), world);
         // Call `black_box` to prevent this frame from being tail-call optimized away
         black_box(());
@@ -297,7 +310,7 @@ mod __rust_begin_short_backtrace {
     pub(super) fn readonly_run<O: 'static>(
         system: &mut dyn ReadOnlySystem<In = (), Out = O>,
         world: &mut World,
-    ) -> O {
+    ) -> Result<O, RunSystemError> {
         // Call `black_box` to prevent this frame from being tail-call optimized away
         black_box(system.run((), world))
     }
@@ -429,13 +442,16 @@ mod tests {
 
     #[test]
     fn piped_system_second_system_skipped() {
+        // This system will be run before the second system is validated
         fn pipe_out(mut counter: ResMut<Counter>) -> u8 {
             counter.0 += 1;
             42
         }
 
         // This system should be skipped when run due to no matching entity
-        fn pipe_in(_input: In<u8>, _single: Single<&TestComponent>) {}
+        fn pipe_in(_input: In<u8>, _single: Single<&TestComponent>, mut counter: ResMut<Counter>) {
+            counter.0 += 1;
+        }
 
         let mut world = World::new();
         world.init_resource::<Counter>();
@@ -444,7 +460,7 @@ mod tests {
         schedule.add_systems(pipe_out.pipe(pipe_in));
         schedule.run(&mut world);
         let counter = world.resource::<Counter>();
-        assert_eq!(counter.0, 0);
+        assert_eq!(counter.0, 1);
     }
 
     #[test]
diff --git a/crates/bevy_ecs/src/schedule/executor/multi_threaded.rs b/crates/bevy_ecs/src/schedule/executor/multi_threaded.rs
index 7938a00e0..006faa8fe 100644
--- a/crates/bevy_ecs/src/schedule/executor/multi_threaded.rs
+++ b/crates/bevy_ecs/src/schedule/executor/multi_threaded.rs
@@ -19,7 +19,7 @@ use crate::{
         is_apply_deferred, ConditionWithAccess, ExecutorKind, SystemExecutor, SystemSchedule,
         SystemWithAccess,
     },
-    system::ScheduleSystem,
+    system::{RunSystemError, ScheduleSystem},
     world::{unsafe_world_cell::UnsafeWorldCell, World},
 };
 #[cfg(feature = "hotpatching")]
@@ -677,10 +677,12 @@ impl ExecutorState {
                 // access the world data used by the system.
                 // - `is_exclusive` returned false
                 unsafe {
-                    if let Err(err) = __rust_begin_short_backtrace::run_unsafe(
-                        system,
-                        context.environment.world_cell,
-                    ) {
+                    if let Err(RunSystemError::Failed(err)) =
+                        __rust_begin_short_backtrace::run_unsafe(
+                            system,
+                            context.environment.world_cell,
+                        )
+                    {
                         (context.error_handler)(
                             err,
                             ErrorContext::System {
@@ -729,7 +731,9 @@ impl ExecutorState {
                 // that no other systems currently have access to the world.
                 let world = unsafe { context.environment.world_cell.world_mut() };
                 let res = std::panic::catch_unwind(AssertUnwindSafe(|| {
-                    if let Err(err) = __rust_begin_short_backtrace::run(system, world) {
+                    if let Err(RunSystemError::Failed(err)) =
+                        __rust_begin_short_backtrace::run(system, world)
+                    {
                         (context.error_handler)(
                             err,
                             ErrorContext::System {
@@ -830,25 +834,29 @@ unsafe fn evaluate_and_fold_conditions(
             // SAFETY:
             // - The caller ensures that `world` has permission to read any data
             //   required by the condition.
-            match unsafe { condition.validate_param_unsafe(world) } {
-                Ok(()) => (),
-                Err(e) => {
-                    if !e.skipped {
+            unsafe { condition.validate_param_unsafe(world) }
+                .map_err(From::from)
+                .and_then(|()| {
+                    // SAFETY:
+                    // - The caller ensures that `world` has permission to read any data
+                    //   required by the condition.
+                    // - `update_archetype_component_access` has been called for condition.
+                    unsafe {
+                        __rust_begin_short_backtrace::readonly_run_unsafe(&mut **condition, world)
+                    }
+                })
+                .unwrap_or_else(|err| {
+                    if let RunSystemError::Failed(err) = err {
                         error_handler(
-                            e.into(),
+                            err,
                             ErrorContext::System {
                                 name: condition.name(),
                                 last_run: condition.get_last_run(),
                             },
                         );
-                    }
-                    return false;
-                }
-            }
-            // SAFETY:
-            // - The caller ensures that `world` has permission to read any data
-            //   required by the condition.
-            unsafe { __rust_begin_short_backtrace::readonly_run_unsafe(&mut **condition, world) }
+                    };
+                    false
+                })
         })
         .fold(true, |acc, res| acc && res)
 }
diff --git a/crates/bevy_ecs/src/schedule/executor/simple.rs b/crates/bevy_ecs/src/schedule/executor/simple.rs
index f0d655eab..17f3f3b8a 100644
--- a/crates/bevy_ecs/src/schedule/executor/simple.rs
+++ b/crates/bevy_ecs/src/schedule/executor/simple.rs
@@ -15,6 +15,7 @@ use crate::{
         executor::is_apply_deferred, ConditionWithAccess, ExecutorKind, SystemExecutor,
         SystemSchedule,
     },
+    system::RunSystemError,
     world::World,
 };
 #[cfg(feature = "hotpatching")]
@@ -107,24 +108,6 @@ impl SystemExecutor for SimpleExecutor {
             should_run &= system_conditions_met;
 
             let system = &mut schedule.systems[system_index].system;
-            if should_run {
-                let valid_params = match system.validate_param(world) {
-                    Ok(()) => true,
-                    Err(e) => {
-                        if !e.skipped {
-                            error_handler(
-                                e.into(),
-                                ErrorContext::System {
-                                    name: system.name(),
-                                    last_run: system.get_last_run(),
-                                },
-                            );
-                        }
-                        false
-                    }
-                };
-                should_run &= valid_params;
-            }
 
             #[cfg(feature = "trace")]
             should_run_span.exit();
@@ -146,7 +129,9 @@ impl SystemExecutor for SimpleExecutor {
             }
 
             let f = AssertUnwindSafe(|| {
-                if let Err(err) = __rust_begin_short_backtrace::run(system, world) {
+                if let Err(RunSystemError::Failed(err)) =
+                    __rust_begin_short_backtrace::run(system, world)
+                {
                     error_handler(
                         err,
                         ErrorContext::System {
@@ -213,26 +198,24 @@ fn evaluate_and_fold_conditions(
     conditions
         .iter_mut()
         .map(|ConditionWithAccess { condition, .. }| {
-            match condition.validate_param(world) {
-                Ok(()) => (),
-                Err(e) => {
-                    if !e.skipped {
+            #[cfg(feature = "hotpatching")]
+            if should_update_hotpatch {
+                condition.refresh_hotpatch();
+            }
+            __rust_begin_short_backtrace::readonly_run(&mut **condition, world).unwrap_or_else(
+                |err| {
+                    if let RunSystemError::Failed(err) = err {
                         error_handler(
-                            e.into(),
+                            err,
                             ErrorContext::System {
                                 name: condition.name(),
                                 last_run: condition.get_last_run(),
                             },
                         );
-                    }
-                    return false;
-                }
-            }
-            #[cfg(feature = "hotpatching")]
-            if should_update_hotpatch {
-                condition.refresh_hotpatch();
-            }
-            __rust_begin_short_backtrace::readonly_run(&mut **condition, world)
+                    };
+                    false
+                },
+            )
         })
         .fold(true, |acc, res| acc && res)
 }
diff --git a/crates/bevy_ecs/src/schedule/executor/single_threaded.rs b/crates/bevy_ecs/src/schedule/executor/single_threaded.rs
index 21b8d2289..4d321bdaf 100644
--- a/crates/bevy_ecs/src/schedule/executor/single_threaded.rs
+++ b/crates/bevy_ecs/src/schedule/executor/single_threaded.rs
@@ -12,6 +12,7 @@ use crate::{
     schedule::{
         is_apply_deferred, ConditionWithAccess, ExecutorKind, SystemExecutor, SystemSchedule,
     },
+    system::RunSystemError,
     world::World,
 };
 #[cfg(feature = "hotpatching")]
@@ -108,25 +109,6 @@ impl SystemExecutor for SingleThreadedExecutor {
             should_run &= system_conditions_met;
 
             let system = &mut schedule.systems[system_index].system;
-            if should_run {
-                let valid_params = match system.validate_param(world) {
-                    Ok(()) => true,
-                    Err(e) => {
-                        if !e.skipped {
-                            error_handler(
-                                e.into(),
-                                ErrorContext::System {
-                                    name: system.name(),
-                                    last_run: system.get_last_run(),
-                                },
-                            );
-                        }
-                        false
-                    }
-                };
-
-                should_run &= valid_params;
-            }
 
             #[cfg(feature = "trace")]
             should_run_span.exit();
@@ -149,7 +131,7 @@ impl SystemExecutor for SingleThreadedExecutor {
             }
 
             let f = AssertUnwindSafe(|| {
-                if let Err(err) =
+                if let Err(RunSystemError::Failed(err)) =
                     __rust_begin_short_backtrace::run_without_applying_deferred(system, world)
                 {
                     error_handler(
@@ -232,26 +214,24 @@ fn evaluate_and_fold_conditions(
     conditions
         .iter_mut()
         .map(|ConditionWithAccess { condition, .. }| {
-            match condition.validate_param(world) {
-                Ok(()) => (),
-                Err(e) => {
-                    if !e.skipped {
+            #[cfg(feature = "hotpatching")]
+            if should_update_hotpatch {
+                condition.refresh_hotpatch();
+            }
+            __rust_begin_short_backtrace::readonly_run(&mut **condition, world).unwrap_or_else(
+                |err| {
+                    if let RunSystemError::Failed(err) = err {
                         error_handler(
-                            e.into(),
+                            err,
                             ErrorContext::System {
                                 name: condition.name(),
                                 last_run: condition.get_last_run(),
                             },
                         );
-                    }
-                    return false;
-                }
-            }
-            #[cfg(feature = "hotpatching")]
-            if should_update_hotpatch {
-                condition.refresh_hotpatch();
-            }
-            __rust_begin_short_backtrace::readonly_run(&mut **condition, world)
+                    };
+                    false
+                },
+            )
         })
         .fold(true, |acc, res| acc && res)
 }
diff --git a/crates/bevy_ecs/src/schedule/mod.rs b/crates/bevy_ecs/src/schedule/mod.rs
index 12f58a7cd..80189d58c 100644
--- a/crates/bevy_ecs/src/schedule/mod.rs
+++ b/crates/bevy_ecs/src/schedule/mod.rs
@@ -31,7 +31,6 @@ mod tests {
     use alloc::{vec, vec::Vec};
     use core::sync::atomic::{AtomicU32, Ordering};
 
-    use crate::error::BevyError;
     pub use crate::{
         prelude::World,
         resource::Resource,
@@ -256,7 +255,10 @@ mod tests {
 
     mod conditions {
 
-        use crate::change_detection::DetectChanges;
+        use crate::{
+            change_detection::DetectChanges,
+            error::{ignore, DefaultErrorHandler, Result},
+        };
 
         use super::*;
 
@@ -280,42 +282,23 @@ mod tests {
             assert_eq!(world.resource::<SystemOrder>().0, vec![0]);
         }
 
-        #[test]
-        fn system_with_condition_result_unit() {
-            let mut world = World::default();
-            let mut schedule = Schedule::default();
-
-            world.init_resource::<SystemOrder>();
-
-            schedule.add_systems(
-                make_function_system(0).run_if(|| Err::<(), BevyError>(core::fmt::Error.into())),
-            );
-
-            schedule.run(&mut world);
-            assert_eq!(world.resource::<SystemOrder>().0, vec![]);
-
-            schedule.add_systems(make_function_system(1).run_if(|| Ok(())));
-
-            schedule.run(&mut world);
-            assert_eq!(world.resource::<SystemOrder>().0, vec![1]);
-        }
-
         #[test]
         fn system_with_condition_result_bool() {
             let mut world = World::default();
+            world.insert_resource(DefaultErrorHandler(ignore));
             let mut schedule = Schedule::default();
 
             world.init_resource::<SystemOrder>();
 
             schedule.add_systems((
-                make_function_system(0).run_if(|| Err::<bool, BevyError>(core::fmt::Error.into())),
-                make_function_system(1).run_if(|| Ok(false)),
+                make_function_system(0).run_if(|| -> Result<bool> { Err(core::fmt::Error.into()) }),
+                make_function_system(1).run_if(|| -> Result<bool> { Ok(false) }),
             ));
 
             schedule.run(&mut world);
             assert_eq!(world.resource::<SystemOrder>().0, vec![]);
 
-            schedule.add_systems(make_function_system(2).run_if(|| Ok(true)));
+            schedule.add_systems(make_function_system(2).run_if(|| -> Result<bool> { Ok(true) }));
 
             schedule.run(&mut world);
             assert_eq!(world.resource::<SystemOrder>().0, vec![2]);
diff --git a/crates/bevy_ecs/src/schedule/set.rs b/crates/bevy_ecs/src/schedule/set.rs
index da91f616e..b0a3e95cb 100644
--- a/crates/bevy_ecs/src/schedule/set.rs
+++ b/crates/bevy_ecs/src/schedule/set.rs
@@ -14,7 +14,7 @@ use crate::{
     define_label,
     intern::Interned,
     system::{
-        ExclusiveFunctionSystem, ExclusiveSystemParamFunction, FunctionSystem,
+        ExclusiveFunctionSystem, ExclusiveSystemParamFunction, FunctionSystem, IntoResult,
         IsExclusiveFunctionSystem, IsFunctionSystem, SystemParamFunction,
     },
 };
@@ -291,13 +291,14 @@ impl<S: SystemSet> IntoSystemSet<()> for S {
 impl<Marker, F> IntoSystemSet<(IsFunctionSystem, Marker)> for F
 where
     Marker: 'static,
+    F::Out: IntoResult<()>,
     F: SystemParamFunction<Marker>,
 {
-    type Set = SystemTypeSet<FunctionSystem<Marker, F>>;
+    type Set = SystemTypeSet<FunctionSystem<Marker, (), F>>;
 
     #[inline]
     fn into_system_set(self) -> Self::Set {
-        SystemTypeSet::<FunctionSystem<Marker, F>>::new()
+        SystemTypeSet::<FunctionSystem<Marker, (), F>>::new()
     }
 }
 
@@ -305,13 +306,14 @@ where
 impl<Marker, F> IntoSystemSet<(IsExclusiveFunctionSystem, Marker)> for F
 where
     Marker: 'static,
+    F::Out: IntoResult<()>,
     F: ExclusiveSystemParamFunction<Marker>,
 {
-    type Set = SystemTypeSet<ExclusiveFunctionSystem<Marker, F>>;
+    type Set = SystemTypeSet<ExclusiveFunctionSystem<Marker, (), F>>;
 
     #[inline]
     fn into_system_set(self) -> Self::Set {
-        SystemTypeSet::<ExclusiveFunctionSystem<Marker, F>>::new()
+        SystemTypeSet::<ExclusiveFunctionSystem<Marker, (), F>>::new()
     }
 }
 
@@ -320,6 +322,7 @@ mod tests {
     use crate::{
         resource::Resource,
         schedule::{tests::ResMut, Schedule},
+        system::{IntoSystem, System},
     };
 
     use super::*;
@@ -546,4 +549,22 @@ mod tests {
             GenericSet::<u64>(PhantomData).intern()
         );
     }
+
+    #[test]
+    fn system_set_matches_default_system_set() {
+        fn system() {}
+        let set_from_into_system_set = IntoSystemSet::into_system_set(system).intern();
+        let system = IntoSystem::into_system(system);
+        let set_from_system = system.default_system_sets()[0];
+        assert_eq!(set_from_into_system_set, set_from_system);
+    }
+
+    #[test]
+    fn system_set_matches_default_system_set_exclusive() {
+        fn system(_: &mut crate::world::World) {}
+        let set_from_into_system_set = IntoSystemSet::into_system_set(system).intern();
+        let system = IntoSystem::into_system(system);
+        let set_from_system = system.default_system_sets()[0];
+        assert_eq!(set_from_into_system_set, set_from_system);
+    }
 }
diff --git a/crates/bevy_ecs/src/system/adapter_system.rs b/crates/bevy_ecs/src/system/adapter_system.rs
index c655ed940..6b1334862 100644
--- a/crates/bevy_ecs/src/system/adapter_system.rs
+++ b/crates/bevy_ecs/src/system/adapter_system.rs
@@ -1,7 +1,7 @@
 use alloc::vec::Vec;
 use bevy_utils::prelude::DebugName;
 
-use super::{IntoSystem, ReadOnlySystem, System, SystemParamValidationError};
+use super::{IntoSystem, ReadOnlySystem, RunSystemError, System, SystemParamValidationError};
 use crate::{
     schedule::InternedSystemSet,
     system::{input::SystemInput, SystemIn},
@@ -14,7 +14,7 @@ use crate::{
 ///
 /// ```
 /// # use bevy_ecs::prelude::*;
-/// use bevy_ecs::system::{Adapt, AdapterSystem};
+/// use bevy_ecs::system::{Adapt, AdapterSystem, RunSystemError};
 ///
 /// // A system adapter that inverts the result of a system.
 /// // NOTE: Instead of manually implementing this, you can just use `bevy_ecs::schedule::common_conditions::not`.
@@ -34,15 +34,16 @@ use crate::{
 ///     fn adapt(
 ///         &mut self,
 ///         input: <Self::In as SystemInput>::Inner<'_>,
-///         run_system: impl FnOnce(SystemIn<'_, S>) -> S::Out,
-///     ) -> Self::Out {
-///         !run_system(input)
+///         run_system: impl FnOnce(SystemIn<'_, S>) -> Result<S::Out, RunSystemError>,
+///     ) -> Result<Self::Out, RunSystemError> {
+///         let result = run_system(input)?;
+///         Ok(!result)
 ///     }
 /// }
 /// # let mut world = World::new();
 /// # let mut system = NotSystem::new(NotMarker, IntoSystem::into_system(|| false), "".into());
 /// # system.initialize(&mut world);
-/// # assert!(system.run((), &mut world));
+/// # assert!(system.run((), &mut world).unwrap());
 /// ```
 #[diagnostic::on_unimplemented(
     message = "`{Self}` can not adapt a system of type `{S}`",
@@ -59,8 +60,8 @@ pub trait Adapt<S: System>: Send + Sync + 'static {
     fn adapt(
         &mut self,
         input: <Self::In as SystemInput>::Inner<'_>,
-        run_system: impl FnOnce(SystemIn<'_, S>) -> S::Out,
-    ) -> Self::Out;
+        run_system: impl FnOnce(SystemIn<'_, S>) -> Result<S::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError>;
 }
 
 /// An [`IntoSystem`] creating an instance of [`AdapterSystem`].
@@ -138,7 +139,7 @@ where
         &mut self,
         input: SystemIn<'_, Self>,
         world: UnsafeWorldCell,
-    ) -> Self::Out {
+    ) -> Result<Self::Out, RunSystemError> {
         // SAFETY: `system.run_unsafe` has the same invariants as `self.run_unsafe`.
         self.func.adapt(input, |input| unsafe {
             self.system.run_unsafe(input, world)
@@ -213,8 +214,8 @@ where
     fn adapt(
         &mut self,
         input: <Self::In as SystemInput>::Inner<'_>,
-        run_system: impl FnOnce(SystemIn<'_, S>) -> S::Out,
-    ) -> Out {
-        self(run_system(input))
+        run_system: impl FnOnce(SystemIn<'_, S>) -> Result<S::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError> {
+        run_system(input).map(self)
     }
 }
diff --git a/crates/bevy_ecs/src/system/builder.rs b/crates/bevy_ecs/src/system/builder.rs
index 7aea73131..4f4366b5e 100644
--- a/crates/bevy_ecs/src/system/builder.rs
+++ b/crates/bevy_ecs/src/system/builder.rs
@@ -622,6 +622,7 @@ unsafe impl<P: SystemParam, B: SystemParamBuilder<P>> SystemParamBuilder<When<P>
 mod tests {
     use crate::{
         entity::Entities,
+        error::Result,
         prelude::{Component, Query},
         reflect::ReflectResource,
         system::{Local, RunSystemOnce},
@@ -654,6 +655,10 @@ mod tests {
         query.iter().count()
     }
 
+    fn query_system_result(query: Query<()>) -> Result<usize> {
+        Ok(query.iter().count())
+    }
+
     fn multi_param_system(a: Local<u64>, b: Local<u64>) -> u64 {
         *a + *b + 1
     }
@@ -687,6 +692,44 @@ mod tests {
         assert_eq!(output, 1);
     }
 
+    #[test]
+    fn query_builder_result_fallible() {
+        let mut world = World::new();
+
+        world.spawn(A);
+        world.spawn_empty();
+
+        let system = (QueryParamBuilder::new(|query| {
+            query.with::<A>();
+        }),)
+            .build_state(&mut world)
+            .build_system(query_system_result);
+
+        // The type annotation here is necessary since the system
+        // could also return `Result<usize>`
+        let output: usize = world.run_system_once(system).unwrap();
+        assert_eq!(output, 1);
+    }
+
+    #[test]
+    fn query_builder_result_infallible() {
+        let mut world = World::new();
+
+        world.spawn(A);
+        world.spawn_empty();
+
+        let system = (QueryParamBuilder::new(|query| {
+            query.with::<A>();
+        }),)
+            .build_state(&mut world)
+            .build_system(query_system_result);
+
+        // The type annotation here is necessary since the system
+        // could also return `usize`
+        let output: Result<usize> = world.run_system_once(system).unwrap();
+        assert_eq!(output.unwrap(), 1);
+    }
+
     #[test]
     fn query_builder_state() {
         let mut world = World::new();
diff --git a/crates/bevy_ecs/src/system/combinator.rs b/crates/bevy_ecs/src/system/combinator.rs
index d48c599f2..1fc69d1c4 100644
--- a/crates/bevy_ecs/src/system/combinator.rs
+++ b/crates/bevy_ecs/src/system/combinator.rs
@@ -11,7 +11,7 @@ use crate::{
     world::unsafe_world_cell::UnsafeWorldCell,
 };
 
-use super::{IntoSystem, ReadOnlySystem, System};
+use super::{IntoSystem, ReadOnlySystem, RunSystemError, System};
 
 /// Customizes the behavior of a [`CombinatorSystem`].
 ///
@@ -19,7 +19,7 @@ use super::{IntoSystem, ReadOnlySystem, System};
 ///
 /// ```
 /// use bevy_ecs::prelude::*;
-/// use bevy_ecs::system::{CombinatorSystem, Combine};
+/// use bevy_ecs::system::{CombinatorSystem, Combine, RunSystemError};
 ///
 /// // A system combinator that performs an exclusive-or (XOR)
 /// // operation on the output of two systems.
@@ -38,10 +38,10 @@ use super::{IntoSystem, ReadOnlySystem, System};
 ///
 ///     fn combine(
 ///         _input: Self::In,
-///         a: impl FnOnce(A::In) -> A::Out,
-///         b: impl FnOnce(B::In) -> B::Out,
-///     ) -> Self::Out {
-///         a(()) ^ b(())
+///         a: impl FnOnce(A::In) -> Result<A::Out, RunSystemError>,
+///         b: impl FnOnce(B::In) -> Result<B::Out, RunSystemError>,
+///     ) -> Result<Self::Out, RunSystemError> {
+///         Ok(a(())? ^ b(())?)
 ///     }
 /// }
 ///
@@ -101,9 +101,9 @@ pub trait Combine<A: System, B: System> {
     /// See the trait-level docs for [`Combine`] for an example implementation.
     fn combine(
         input: <Self::In as SystemInput>::Inner<'_>,
-        a: impl FnOnce(SystemIn<'_, A>) -> A::Out,
-        b: impl FnOnce(SystemIn<'_, B>) -> B::Out,
-    ) -> Self::Out;
+        a: impl FnOnce(SystemIn<'_, A>) -> Result<A::Out, RunSystemError>,
+        b: impl FnOnce(SystemIn<'_, B>) -> Result<B::Out, RunSystemError>,
+    ) -> Result<Self::Out, RunSystemError>;
 }
 
 /// A [`System`] defined by combining two other systems.
@@ -152,7 +152,7 @@ where
         &mut self,
         input: SystemIn<'_, Self>,
         world: UnsafeWorldCell,
-    ) -> Self::Out {
+    ) -> Result<Self::Out, RunSystemError> {
         Func::combine(
             input,
             // SAFETY: The world accesses for both underlying systems have been registered,
@@ -161,8 +161,13 @@ where
             // Since these closures are `!Send + !Sync + !'static`, they can never be called
             // in parallel, so their world accesses will not conflict with each other.
             |input| unsafe { self.a.run_unsafe(input, world) },
+            // `Self::validate_param_unsafe` already validated the first system,
+            // but we still need to validate the second system once the first one runs.
             // SAFETY: See the comment above.
-            |input| unsafe { self.b.run_unsafe(input, world) },
+            |input| unsafe {
+                self.b.validate_param_unsafe(world)?;
+                self.b.run_unsafe(input, world)
+            },
         )
     }
 
@@ -190,6 +195,10 @@ where
         &mut self,
         world: UnsafeWorldCell,
     ) -> Result<(), SystemParamValidationError> {
+        // We only validate parameters for the first system,
+        // since it may make changes to the world that affect
+        // whether the second system has valid parameters.
+        // The second system will be validated in `Self::run_unsafe`.
         // SAFETY: Delegate to other `System` implementations.
         unsafe { self.a.validate_param_unsafe(world) }
     }
@@ -301,7 +310,7 @@ where
 ///     // pipe the `parse_message_system`'s output into the `filter_system`s input
 ///     let mut piped_system = IntoSystem::into_system(parse_message_system.pipe(filter_system));
 ///     piped_system.initialize(&mut world);
-///     assert_eq!(piped_system.run((), &mut world), Some(42));
+///     assert_eq!(piped_system.run((), &mut world).unwrap(), Some(42));
 /// }
 ///
 /// #[derive(Resource)]
@@ -355,8 +364,11 @@ where
         &mut self,
         input: SystemIn<'_, Self>,
         world: UnsafeWorldCell,
-    ) -> Self::Out {
-        let value = self.a.run_unsafe(input, world);
+    ) -> Result<Self::Out, RunSystemError> {
+        let value = self.a.run_unsafe(input, world)?;
+        // `Self::validate_param_unsafe` already validated the first system,
+        // but we still need to validate the second system once the first one runs.
+        self.b.validate_param_unsafe(world)?;
         self.b.run_unsafe(value, world)
     }
 
@@ -377,27 +389,16 @@ where
         self.b.queue_deferred(world);
     }
 
-    /// This method uses "early out" logic: if the first system fails validation,
-    /// the second system is not validated.
-    ///
-    /// Because the system validation is performed upfront, this can lead to situations
-    /// where later systems pass validation, but fail at runtime due to changes made earlier
-    /// in the piped systems.
-    // TODO: ensure that systems are only validated just before they are run.
-    // Fixing this will require fundamentally rethinking how piped systems work:
-    // they're currently treated as a single system from the perspective of the scheduler.
-    // See https://github.com/bevyengine/bevy/issues/18796
     unsafe fn validate_param_unsafe(
         &mut self,
         world: UnsafeWorldCell,
     ) -> Result<(), SystemParamValidationError> {
+        // We only validate parameters for the first system,
+        // since it may make changes to the world that affect
+        // whether the second system has valid parameters.
+        // The second system will be validated in `Self::run_unsafe`.
         // SAFETY: Delegate to the `System` implementation for `a`.
-        unsafe { self.a.validate_param_unsafe(world) }?;
-
-        // SAFETY: Delegate to the `System` implementation for `b`.
-        unsafe { self.b.validate_param_unsafe(world) }?;
-
-        Ok(())
+        unsafe { self.a.validate_param_unsafe(world) }
     }
 
     fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
diff --git a/crates/bevy_ecs/src/system/commands/command.rs b/crates/bevy_ecs/src/system/commands/command.rs
index 5f1f61185..164758cca 100644
--- a/crates/bevy_ecs/src/system/commands/command.rs
+++ b/crates/bevy_ecs/src/system/commands/command.rs
@@ -144,11 +144,10 @@ where
 
 /// A [`Command`] that runs the given system,
 /// caching its [`SystemId`] in a [`CachedSystemId`](crate::system::CachedSystemId) resource.
-pub fn run_system_cached<O, M, S>(system: S) -> impl Command<Result>
+pub fn run_system_cached<M, S>(system: S) -> impl Command<Result>
 where
-    O: 'static,
     M: 'static,
-    S: IntoSystem<(), O, M> + Send + 'static,
+    S: IntoSystem<(), (), M> + Send + 'static,
 {
     move |world: &mut World| -> Result {
         world.run_system_cached(system)?;
@@ -158,15 +157,11 @@ where
 
 /// A [`Command`] that runs the given system with the given input value,
 /// caching its [`SystemId`] in a [`CachedSystemId`](crate::system::CachedSystemId) resource.
-pub fn run_system_cached_with<I, O, M, S>(
-    system: S,
-    input: I::Inner<'static>,
-) -> impl Command<Result>
+pub fn run_system_cached_with<I, M, S>(system: S, input: I::Inner<'static>) -> impl Command<Result>
 where
     I: SystemInput<Inner<'static>: Send> + Send + 'static,
-    O: 'static,
     M: 'static,
-    S: IntoSystem<I, O, M> + Send + 'static,
+    S: IntoSystem<I, (), M> + Send + 'static,
 {
     move |world: &mut World| -> Result {
         world.run_system_cached_with(system, input)?;
@@ -180,7 +175,7 @@ where
 pub fn unregister_system<I, O>(system_id: SystemId<I, O>) -> impl Command<Result>
 where
     I: SystemInput + Send + 'static,
-    O: 'static,
+    O: Send + 'static,
 {
     move |world: &mut World| -> Result {
         world.unregister_system(system_id)?;
diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index e066446b5..d345368ab 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -476,7 +476,7 @@ impl<'w, 's> Commands<'w, 's> {
     ///     // Return from the system successfully.
     ///     Ok(())
     /// }
-    /// # bevy_ecs::system::assert_is_system(example_system);
+    /// # bevy_ecs::system::assert_is_system::<(), (), _>(example_system);
     /// ```
     ///
     /// # See also
@@ -877,7 +877,7 @@ impl<'w, 's> Commands<'w, 's> {
     ///
     /// It will internally return a [`RegisteredSystemError`](crate::system::system_registry::RegisteredSystemError),
     /// which will be handled by [logging the error at the `warn` level](warn).
-    pub fn run_system<O: 'static>(&mut self, id: SystemId<(), O>) {
+    pub fn run_system(&mut self, id: SystemId) {
         self.queue(command::run_system(id).handle_error_with(warn));
     }
 
@@ -970,7 +970,7 @@ impl<'w, 's> Commands<'w, 's> {
     ) -> SystemId<I, O>
     where
         I: SystemInput + Send + 'static,
-        O: 'static,
+        O: Send + 'static,
     {
         let entity = self.spawn_empty().id();
         let system = RegisteredSystem::<I, O>::new(Box::new(IntoSystem::into_system(system)));
@@ -995,7 +995,7 @@ impl<'w, 's> Commands<'w, 's> {
     pub fn unregister_system<I, O>(&mut self, system_id: SystemId<I, O>)
     where
         I: SystemInput + Send + 'static,
-        O: 'static,
+        O: Send + 'static,
     {
         self.queue(command::unregister_system(system_id).handle_error_with(warn));
     }
@@ -1044,11 +1044,10 @@ impl<'w, 's> Commands<'w, 's> {
     /// consider passing them in as inputs via [`Commands::run_system_cached_with`].
     ///
     /// If that's not an option, consider [`Commands::register_system`] instead.
-    pub fn run_system_cached<O, M, S>(&mut self, system: S)
+    pub fn run_system_cached<M, S>(&mut self, system: S)
     where
-        O: 'static,
         M: 'static,
-        S: IntoSystem<(), O, M> + Send + 'static,
+        S: IntoSystem<(), (), M> + Send + 'static,
     {
         self.queue(command::run_system_cached(system).handle_error_with(warn));
     }
@@ -1075,12 +1074,11 @@ impl<'w, 's> Commands<'w, 's> {
     /// consider passing them in as inputs.
     ///
     /// If that's not an option, consider [`Commands::register_system`] instead.
-    pub fn run_system_cached_with<I, O, M, S>(&mut self, system: S, input: I::Inner<'static>)
+    pub fn run_system_cached_with<I, M, S>(&mut self, system: S, input: I::Inner<'static>)
     where
         I: SystemInput<Inner<'static>: Send> + Send + 'static,
-        O: 'static,
         M: 'static,
-        S: IntoSystem<I, O, M> + Send + 'static,
+        S: IntoSystem<I, (), M> + Send + 'static,
     {
         self.queue(command::run_system_cached_with(system, input).handle_error_with(warn));
     }
diff --git a/crates/bevy_ecs/src/system/exclusive_function_system.rs b/crates/bevy_ecs/src/system/exclusive_function_system.rs
index 3a053f89d..241f9955d 100644
--- a/crates/bevy_ecs/src/system/exclusive_function_system.rs
+++ b/crates/bevy_ecs/src/system/exclusive_function_system.rs
@@ -1,10 +1,11 @@
 use crate::{
     component::{CheckChangeTicks, ComponentId, Tick},
+    error::Result,
     query::FilteredAccessSet,
     schedule::{InternedSystemSet, SystemSet},
     system::{
-        check_system_change_tick, ExclusiveSystemParam, ExclusiveSystemParamItem, IntoSystem,
-        System, SystemIn, SystemInput, SystemMeta,
+        check_system_change_tick, ExclusiveSystemParam, ExclusiveSystemParamItem, IntoResult,
+        IntoSystem, System, SystemIn, SystemInput, SystemMeta,
     },
     world::{unsafe_world_cell::UnsafeWorldCell, World},
 };
@@ -14,7 +15,7 @@ use bevy_utils::prelude::DebugName;
 use core::marker::PhantomData;
 use variadics_please::all_tuples;
 
-use super::{SystemParamValidationError, SystemStateFlags};
+use super::{RunSystemError, SystemParamValidationError, SystemStateFlags};
 
 /// A function system that runs with exclusive [`World`] access.
 ///
@@ -22,7 +23,7 @@ use super::{SystemParamValidationError, SystemStateFlags};
 /// [`ExclusiveSystemParam`]s.
 ///
 /// [`ExclusiveFunctionSystem`] must be `.initialized` before they can be run.
-pub struct ExclusiveFunctionSystem<Marker, F>
+pub struct ExclusiveFunctionSystem<Marker, Out, F>
 where
     F: ExclusiveSystemParamFunction<Marker>,
 {
@@ -32,10 +33,10 @@ where
     param_state: Option<<F::Param as ExclusiveSystemParam>::State>,
     system_meta: SystemMeta,
     // NOTE: PhantomData<fn()-> T> gives this safe Send/Sync impls
-    marker: PhantomData<fn() -> Marker>,
+    marker: PhantomData<fn() -> (Marker, Out)>,
 }
 
-impl<Marker, F> ExclusiveFunctionSystem<Marker, F>
+impl<Marker, Out, F> ExclusiveFunctionSystem<Marker, Out, F>
 where
     F: ExclusiveSystemParamFunction<Marker>,
 {
@@ -52,12 +53,14 @@ where
 #[doc(hidden)]
 pub struct IsExclusiveFunctionSystem;
 
-impl<Marker, F> IntoSystem<F::In, F::Out, (IsExclusiveFunctionSystem, Marker)> for F
+impl<Out, Marker, F> IntoSystem<F::In, Out, (IsExclusiveFunctionSystem, Marker, Out)> for F
 where
+    Out: 'static,
     Marker: 'static,
+    F::Out: IntoResult<Out>,
     F: ExclusiveSystemParamFunction<Marker>,
 {
-    type System = ExclusiveFunctionSystem<Marker, F>;
+    type System = ExclusiveFunctionSystem<Marker, Out, F>;
     fn into_system(func: Self) -> Self::System {
         ExclusiveFunctionSystem {
             func,
@@ -75,13 +78,15 @@ where
 
 const PARAM_MESSAGE: &str = "System's param_state was not found. Did you forget to initialize this system before running it?";
 
-impl<Marker, F> System for ExclusiveFunctionSystem<Marker, F>
+impl<Marker, Out, F> System for ExclusiveFunctionSystem<Marker, Out, F>
 where
     Marker: 'static,
+    Out: 'static,
+    F::Out: IntoResult<Out>,
     F: ExclusiveSystemParamFunction<Marker>,
 {
     type In = F::In;
-    type Out = F::Out;
+    type Out = Out;
 
     #[inline]
     fn name(&self) -> DebugName {
@@ -102,7 +107,7 @@ where
         &mut self,
         input: SystemIn<'_, Self>,
         world: UnsafeWorldCell,
-    ) -> Self::Out {
+    ) -> Result<Self::Out, RunSystemError> {
         // SAFETY: The safety is upheld by the caller.
         let world = unsafe { world.world_mut() };
         world.last_change_tick_scope(self.system_meta.last_run, |world| {
@@ -132,7 +137,7 @@ where
             world.flush();
             self.system_meta.last_run = world.increment_change_tick();
 
-            out
+            IntoResult::into_result(out)
         })
     }
 
diff --git a/crates/bevy_ecs/src/system/function_system.rs b/crates/bevy_ecs/src/system/function_system.rs
index 600966280..35d7e709e 100644
--- a/crates/bevy_ecs/src/system/function_system.rs
+++ b/crates/bevy_ecs/src/system/function_system.rs
@@ -1,5 +1,7 @@
 use crate::{
     component::{CheckChangeTicks, ComponentId, Tick},
+    error::{BevyError, Result},
+    never::Never,
     prelude::FromWorld,
     query::FilteredAccessSet,
     schedule::{InternedSystemSet, SystemSet},
@@ -19,7 +21,8 @@ use variadics_please::all_tuples;
 use tracing::{info_span, Span};
 
 use super::{
-    IntoSystem, ReadOnlySystem, SystemParamBuilder, SystemParamValidationError, SystemStateFlags,
+    IntoSystem, ReadOnlySystem, RunSystemError, SystemParamBuilder, SystemParamValidationError,
+    SystemStateFlags,
 };
 
 /// The metadata of a [`System`].
@@ -210,15 +213,16 @@ macro_rules! impl_build_system {
             /// This method signature allows type inference of closure parameters for a system with no input.
             /// You can use [`SystemState::build_system_with_input()`] if you have input, or [`SystemState::build_any_system()`] if you don't need type inference.
             pub fn build_system<
+                InnerOut: IntoResult<Out>,
                 Out: 'static,
                 Marker,
-                F: FnMut($(SystemParamItem<$param>),*) -> Out
-                    + SystemParamFunction<Marker, Param = ($($param,)*), In = (), Out = Out>
+                F: FnMut($(SystemParamItem<$param>),*) -> InnerOut
+                    + SystemParamFunction<Marker, Param = ($($param,)*), In = (), Out = InnerOut>
             >
             (
                 self,
                 func: F,
-            ) -> FunctionSystem<Marker, F>
+            ) -> FunctionSystem<Marker, Out, F>
             {
                 self.build_any_system(func)
             }
@@ -228,14 +232,15 @@ macro_rules! impl_build_system {
             /// You can use [`SystemState::build_system()`] if you have no input, or [`SystemState::build_any_system()`] if you don't need type inference.
             pub fn build_system_with_input<
                 Input: SystemInput,
+                InnerOut: IntoResult<Out>,
                 Out: 'static,
                 Marker,
-                F: FnMut(Input, $(SystemParamItem<$param>),*) -> Out
-                    + SystemParamFunction<Marker, Param = ($($param,)*), In = Input, Out = Out>,
+                F: FnMut(Input, $(SystemParamItem<$param>),*) -> InnerOut
+                    + SystemParamFunction<Marker, Param = ($($param,)*), In = Input, Out = InnerOut>,
             >(
                 self,
                 func: F,
-            ) -> FunctionSystem<Marker, F> {
+            ) -> FunctionSystem<Marker, Out, F> {
                 self.build_any_system(func)
             }
         }
@@ -286,10 +291,10 @@ impl<Param: SystemParam> SystemState<Param> {
     /// Create a [`FunctionSystem`] from a [`SystemState`].
     /// This method signature allows any system function, but the compiler will not perform type inference on closure parameters.
     /// You can use [`SystemState::build_system()`] or [`SystemState::build_system_with_input()`] to get type inference on parameters.
-    pub fn build_any_system<Marker, F: SystemParamFunction<Marker, Param = Param>>(
-        self,
-        func: F,
-    ) -> FunctionSystem<Marker, F> {
+    pub fn build_any_system<Marker, Out, F>(self, func: F) -> FunctionSystem<Marker, Out, F>
+    where
+        F: SystemParamFunction<Marker, Param = Param, Out: IntoResult<Out>>,
+    {
         FunctionSystem {
             func,
             #[cfg(feature = "hotpatching")]
@@ -502,7 +507,7 @@ impl<Param: SystemParam> FromWorld for SystemState<Param> {
 ///
 /// The [`Clone`] implementation for [`FunctionSystem`] returns a new instance which
 /// is NOT initialized. The cloned system must also be `.initialized` before it can be run.
-pub struct FunctionSystem<Marker, F>
+pub struct FunctionSystem<Marker, Out, F>
 where
     F: SystemParamFunction<Marker>,
 {
@@ -512,7 +517,7 @@ where
     state: Option<FunctionSystemState<F::Param>>,
     system_meta: SystemMeta,
     // NOTE: PhantomData<fn()-> T> gives this safe Send/Sync impls
-    marker: PhantomData<fn() -> Marker>,
+    marker: PhantomData<fn() -> (Marker, Out)>,
 }
 
 /// The state of a [`FunctionSystem`], which must be initialized with
@@ -527,7 +532,7 @@ struct FunctionSystemState<P: SystemParam> {
     world_id: WorldId,
 }
 
-impl<Marker, F> FunctionSystem<Marker, F>
+impl<Marker, Out, F> FunctionSystem<Marker, Out, F>
 where
     F: SystemParamFunction<Marker>,
 {
@@ -541,7 +546,7 @@ where
 }
 
 // De-initializes the cloned system.
-impl<Marker, F> Clone for FunctionSystem<Marker, F>
+impl<Marker, Out, F> Clone for FunctionSystem<Marker, Out, F>
 where
     F: SystemParamFunction<Marker> + Clone,
 {
@@ -562,12 +567,13 @@ where
 #[doc(hidden)]
 pub struct IsFunctionSystem;
 
-impl<Marker, F> IntoSystem<F::In, F::Out, (IsFunctionSystem, Marker)> for F
+impl<Marker, Out, F> IntoSystem<F::In, Out, (IsFunctionSystem, Marker)> for F
 where
+    Out: 'static,
     Marker: 'static,
-    F: SystemParamFunction<Marker>,
+    F: SystemParamFunction<Marker, Out: IntoResult<Out>>,
 {
-    type System = FunctionSystem<Marker, F>;
+    type System = FunctionSystem<Marker, Out, F>;
     fn into_system(func: Self) -> Self::System {
         FunctionSystem {
             func,
@@ -581,7 +587,48 @@ where
     }
 }
 
-impl<Marker, F> FunctionSystem<Marker, F>
+/// A type that may be converted to the output of a [`System`].
+/// This is used to allow systems to return either a plain value or a [`Result`].
+pub trait IntoResult<Out>: Sized {
+    /// Converts this type into the system output type.
+    fn into_result(self) -> Result<Out, RunSystemError>;
+}
+
+impl<T> IntoResult<T> for T {
+    fn into_result(self) -> Result<T, RunSystemError> {
+        Ok(self)
+    }
+}
+
+impl<T> IntoResult<T> for Result<T, RunSystemError> {
+    fn into_result(self) -> Result<T, RunSystemError> {
+        self
+    }
+}
+
+impl<T> IntoResult<T> for Result<T, BevyError> {
+    fn into_result(self) -> Result<T, RunSystemError> {
+        Ok(self?)
+    }
+}
+
+// The `!` impl can't be generic in `Out`, since that would overlap with
+// `impl<T> IntoResult<T> for T` when `T` = `!`.
+// Use explicit impls for `()` and `bool` so diverging functions
+// can be used for systems and conditions.
+impl IntoResult<()> for Never {
+    fn into_result(self) -> Result<(), RunSystemError> {
+        self
+    }
+}
+
+impl IntoResult<bool> for Never {
+    fn into_result(self) -> Result<bool, RunSystemError> {
+        self
+    }
+}
+
+impl<Marker, Out, F> FunctionSystem<Marker, Out, F>
 where
     F: SystemParamFunction<Marker>,
 {
@@ -592,13 +639,14 @@ where
         "System's state was not found. Did you forget to initialize this system before running it?";
 }
 
-impl<Marker, F> System for FunctionSystem<Marker, F>
+impl<Marker, Out, F> System for FunctionSystem<Marker, Out, F>
 where
     Marker: 'static,
-    F: SystemParamFunction<Marker>,
+    Out: 'static,
+    F: SystemParamFunction<Marker, Out: IntoResult<Out>>,
 {
     type In = F::In;
-    type Out = F::Out;
+    type Out = Out;
 
     #[inline]
     fn name(&self) -> DebugName {
@@ -615,7 +663,7 @@ where
         &mut self,
         input: SystemIn<'_, Self>,
         world: UnsafeWorldCell,
-    ) -> Self::Out {
+    ) -> Result<Self::Out, RunSystemError> {
         #[cfg(feature = "trace")]
         let _span_guard = self.system_meta.system_span.enter();
 
@@ -645,7 +693,7 @@ where
         let out = self.func.run(input, params);
 
         self.system_meta.last_run = change_tick;
-        out
+        IntoResult::into_result(out)
     }
 
     #[cfg(feature = "hotpatching")]
@@ -732,10 +780,11 @@ where
 }
 
 /// SAFETY: `F`'s param is [`ReadOnlySystemParam`], so this system will only read from the world.
-unsafe impl<Marker, F> ReadOnlySystem for FunctionSystem<Marker, F>
+unsafe impl<Marker, Out, F> ReadOnlySystem for FunctionSystem<Marker, Out, F>
 where
     Marker: 'static,
-    F: SystemParamFunction<Marker>,
+    Out: 'static,
+    F: SystemParamFunction<Marker, Out: IntoResult<Out>>,
     F::Param: ReadOnlySystemParam,
 {
 }
@@ -785,7 +834,7 @@ where
 ///     // pipe the `parse_message_system`'s output into the `filter_system`s input
 ///     let mut piped_system = IntoSystem::into_system(pipe(parse_message, filter));
 ///     piped_system.initialize(&mut world);
-///     assert_eq!(piped_system.run((), &mut world), Some(42));
+///     assert_eq!(piped_system.run((), &mut world).unwrap(), Some(42));
 /// }
 ///
 /// #[derive(Resource)]
diff --git a/crates/bevy_ecs/src/system/input.rs b/crates/bevy_ecs/src/system/input.rs
index cb75016ee..c8d799b05 100644
--- a/crates/bevy_ecs/src/system/input.rs
+++ b/crates/bevy_ecs/src/system/input.rs
@@ -80,7 +80,7 @@ pub type SystemIn<'a, S> = <<S as System>::In as SystemInput>::Inner<'a>;
 /// let mut square_system = IntoSystem::into_system(square);
 /// square_system.initialize(&mut world);
 ///
-/// assert_eq!(square_system.run(12, &mut world), 144);
+/// assert_eq!(square_system.run(12, &mut world).unwrap(), 144);
 /// ```
 ///
 /// [`SystemParam`]: crate::system::SystemParam
@@ -318,9 +318,9 @@ mod tests {
         let mut a = 12;
         let b = 24;
 
-        assert_eq!(by_value.run((a, b), &mut world), 36);
-        assert_eq!(by_ref.run((&a, &b), &mut world), 36);
-        by_mut.run((&mut a, b), &mut world);
+        assert_eq!(by_value.run((a, b), &mut world).unwrap(), 36);
+        assert_eq!(by_ref.run((&a, &b), &mut world).unwrap(), 36);
+        by_mut.run((&mut a, b), &mut world).unwrap();
         assert_eq!(a, 36);
     }
 }
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index 7a04e2fae..26c767b05 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -390,7 +390,7 @@ pub fn assert_system_does_not_conflict<Out, Params, S: IntoSystem<(), Out, Param
     let mut world = World::new();
     let mut system = IntoSystem::into_system(sys);
     system.initialize(&mut world);
-    system.run((), &mut world);
+    system.run((), &mut world).unwrap();
 }
 
 #[cfg(test)]
@@ -461,7 +461,7 @@ mod tests {
         world.spawn(A);
 
         system.initialize(&mut world);
-        system.run((), &mut world);
+        system.run((), &mut world).unwrap();
     }
 
     fn run_system<Marker, S: IntoScheduleConfigs<ScheduleSystem, Marker>>(
@@ -1192,11 +1192,11 @@ mod tests {
 
         let mut without_filter = IntoSystem::into_system(without_filter);
         without_filter.initialize(&mut world);
-        without_filter.run((), &mut world);
+        without_filter.run((), &mut world).unwrap();
 
         let mut with_filter = IntoSystem::into_system(with_filter);
         with_filter.initialize(&mut world);
-        with_filter.run((), &mut world);
+        with_filter.run((), &mut world).unwrap();
     }
 
     #[test]
@@ -1786,29 +1786,33 @@ mod tests {
         let mut sys = IntoSystem::into_system(first.pipe(second));
         sys.initialize(&mut world);
 
-        sys.run(default(), &mut world);
+        sys.run(default(), &mut world).unwrap();
 
         // The second system should observe a change made in the first system.
-        let info = sys.run(
-            Info {
-                do_first: true,
-                ..default()
-            },
-            &mut world,
-        );
+        let info = sys
+            .run(
+                Info {
+                    do_first: true,
+                    ..default()
+                },
+                &mut world,
+            )
+            .unwrap();
         assert!(!info.first_flag);
         assert!(info.second_flag);
 
         // When a change is made in the second system, the first system
         // should observe it the next time they are run.
-        let info1 = sys.run(
-            Info {
-                do_second: true,
-                ..default()
-            },
-            &mut world,
-        );
-        let info2 = sys.run(default(), &mut world);
+        let info1 = sys
+            .run(
+                Info {
+                    do_second: true,
+                    ..default()
+                },
+                &mut world,
+            )
+            .unwrap();
+        let info2 = sys.run(default(), &mut world).unwrap();
         assert!(!info1.first_flag);
         assert!(!info1.second_flag);
         assert!(info2.first_flag);
@@ -1845,7 +1849,9 @@ mod tests {
     }
 
     #[test]
-    #[should_panic]
+    #[should_panic(
+        expected = "Encountered an error in system `bevy_ecs::system::tests::simple_fallible_system::sys`: error"
+    )]
     fn simple_fallible_system() {
         fn sys() -> Result {
             Err("error")?;
@@ -1856,6 +1862,20 @@ mod tests {
         run_system(&mut world, sys);
     }
 
+    #[test]
+    #[should_panic(
+        expected = "Encountered an error in system `bevy_ecs::system::tests::simple_fallible_exclusive_system::sys`: error"
+    )]
+    fn simple_fallible_exclusive_system() {
+        fn sys(_world: &mut World) -> Result {
+            Err("error")?;
+            Ok(())
+        }
+
+        let mut world = World::new();
+        run_system(&mut world, sys);
+    }
+
     // Regression test for
     // https://github.com/bevyengine/bevy/issues/18778
     //
@@ -1917,7 +1937,7 @@ mod tests {
         let mut world = World::new();
         let mut system = IntoSystem::into_system(sys.with_input(42));
         system.initialize(&mut world);
-        system.run((), &mut world);
+        system.run((), &mut world).unwrap();
         assert_eq!(*system.value(), 43);
     }
 
@@ -1940,7 +1960,7 @@ mod tests {
         assert!(system.value().is_none());
         system.initialize(&mut world);
         assert!(system.value().is_some());
-        system.run((), &mut world);
+        system.run((), &mut world).unwrap();
         assert_eq!(system.value().unwrap().0, 6);
     }
 }
diff --git a/crates/bevy_ecs/src/system/observer_system.rs b/crates/bevy_ecs/src/system/observer_system.rs
index 243c2c3c3..862ebf71c 100644
--- a/crates/bevy_ecs/src/system/observer_system.rs
+++ b/crates/bevy_ecs/src/system/observer_system.rs
@@ -1,22 +1,12 @@
-use alloc::vec::Vec;
-use bevy_utils::prelude::DebugName;
-use core::marker::PhantomData;
-
 use crate::{
-    component::{CheckChangeTicks, ComponentId, Tick},
-    error::Result,
-    never::Never,
     prelude::{Bundle, On},
-    query::FilteredAccessSet,
-    schedule::{Fallible, Infallible},
-    system::{input::SystemIn, System},
-    world::{unsafe_world_cell::UnsafeWorldCell, DeferredWorld, World},
+    system::System,
 };
 
-use super::{IntoSystem, SystemParamValidationError};
+use super::IntoSystem;
 
 /// Implemented for [`System`]s that have [`On`] as the first argument.
-pub trait ObserverSystem<E: 'static, B: Bundle, Out = Result>:
+pub trait ObserverSystem<E: 'static, B: Bundle, Out = ()>:
     System<In = On<'static, E, B>, Out = Out> + Send + 'static
 {
 }
@@ -38,7 +28,7 @@ impl<E: 'static, B: Bundle, Out, T> ObserverSystem<E, B, Out> for T where
     label = "the trait `IntoObserverSystem` is not implemented",
     note = "for function `ObserverSystem`s, ensure the first argument is `On<T>` and any subsequent ones are `SystemParam`"
 )]
-pub trait IntoObserverSystem<E: 'static, B: Bundle, M, Out = Result>: Send + 'static {
+pub trait IntoObserverSystem<E: 'static, B: Bundle, M, Out = ()>: Send + 'static {
     /// The type of [`System`] that this instance converts into.
     type System: ObserverSystem<E, B, Out>;
 
@@ -46,7 +36,7 @@ pub trait IntoObserverSystem<E: 'static, B: Bundle, M, Out = Result>: Send + 'st
     fn into_system(this: Self) -> Self::System;
 }
 
-impl<E, B, M, S, Out> IntoObserverSystem<E, B, (Fallible, M), Out> for S
+impl<E, B, M, Out, S> IntoObserverSystem<E, B, M, Out> for S
 where
     S: IntoSystem<On<'static, E, B>, Out, M> + Send + 'static,
     S::System: ObserverSystem<E, B, Out>,
@@ -60,128 +50,6 @@ where
     }
 }
 
-impl<E, B, M, S> IntoObserverSystem<E, B, (Infallible, M), Result> for S
-where
-    S: IntoSystem<On<'static, E, B>, (), M> + Send + 'static,
-    S::System: ObserverSystem<E, B, ()>,
-    E: Send + Sync + 'static,
-    B: Bundle,
-{
-    type System = InfallibleObserverWrapper<E, B, S::System, ()>;
-
-    fn into_system(this: Self) -> Self::System {
-        InfallibleObserverWrapper::new(IntoSystem::into_system(this))
-    }
-}
-
-impl<E, B, M, S> IntoObserverSystem<E, B, (Never, M), Result> for S
-where
-    S: IntoSystem<On<'static, E, B>, Never, M> + Send + 'static,
-    E: Send + Sync + 'static,
-    B: Bundle,
-{
-    type System = InfallibleObserverWrapper<E, B, S::System, Never>;
-
-    fn into_system(this: Self) -> Self::System {
-        InfallibleObserverWrapper::new(IntoSystem::into_system(this))
-    }
-}
-
-/// A wrapper that converts an observer system that returns `()` into one that returns `Ok(())`.
-pub struct InfallibleObserverWrapper<E, B, S, Out> {
-    observer: S,
-    _marker: PhantomData<(E, B, Out)>,
-}
-
-impl<E, B, S, Out> InfallibleObserverWrapper<E, B, S, Out> {
-    /// Create a new `InfallibleObserverWrapper`.
-    pub fn new(observer: S) -> Self {
-        Self {
-            observer,
-            _marker: PhantomData,
-        }
-    }
-}
-
-impl<E, B, S, Out> System for InfallibleObserverWrapper<E, B, S, Out>
-where
-    S: ObserverSystem<E, B, Out>,
-    E: Send + Sync + 'static,
-    B: Bundle,
-    Out: Send + Sync + 'static,
-{
-    type In = On<'static, E, B>;
-    type Out = Result;
-
-    #[inline]
-    fn name(&self) -> DebugName {
-        self.observer.name()
-    }
-
-    #[inline]
-    fn flags(&self) -> super::SystemStateFlags {
-        self.observer.flags()
-    }
-
-    #[inline]
-    unsafe fn run_unsafe(
-        &mut self,
-        input: SystemIn<'_, Self>,
-        world: UnsafeWorldCell,
-    ) -> Self::Out {
-        self.observer.run_unsafe(input, world);
-        Ok(())
-    }
-
-    #[cfg(feature = "hotpatching")]
-    #[inline]
-    fn refresh_hotpatch(&mut self) {
-        self.observer.refresh_hotpatch();
-    }
-
-    #[inline]
-    fn apply_deferred(&mut self, world: &mut World) {
-        self.observer.apply_deferred(world);
-    }
-
-    #[inline]
-    fn queue_deferred(&mut self, world: DeferredWorld) {
-        self.observer.queue_deferred(world);
-    }
-
-    #[inline]
-    unsafe fn validate_param_unsafe(
-        &mut self,
-        world: UnsafeWorldCell,
-    ) -> Result<(), SystemParamValidationError> {
-        self.observer.validate_param_unsafe(world)
-    }
-
-    #[inline]
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
-        self.observer.initialize(world)
-    }
-
-    #[inline]
-    fn check_change_tick(&mut self, check: CheckChangeTicks) {
-        self.observer.check_change_tick(check);
-    }
-
-    #[inline]
-    fn get_last_run(&self) -> Tick {
-        self.observer.get_last_run()
-    }
-
-    #[inline]
-    fn set_last_run(&mut self, last_run: Tick) {
-        self.observer.set_last_run(last_run);
-    }
-
-    fn default_system_sets(&self) -> Vec<crate::schedule::InternedSystemSet> {
-        self.observer.default_system_sets()
-    }
-}
-
 #[cfg(test)]
 mod tests {
     use crate::{
diff --git a/crates/bevy_ecs/src/system/schedule_system.rs b/crates/bevy_ecs/src/system/schedule_system.rs
index ca4bdd446..e2a853dbe 100644
--- a/crates/bevy_ecs/src/system/schedule_system.rs
+++ b/crates/bevy_ecs/src/system/schedule_system.rs
@@ -1,103 +1,15 @@
-use alloc::vec::Vec;
 use bevy_utils::prelude::DebugName;
 
 use crate::{
     component::{CheckChangeTicks, ComponentId, Tick},
     error::Result,
     query::FilteredAccessSet,
-    system::{input::SystemIn, BoxedSystem, System, SystemInput},
+    system::{input::SystemIn, BoxedSystem, RunSystemError, System, SystemInput},
     world::{unsafe_world_cell::UnsafeWorldCell, DeferredWorld, FromWorld, World},
 };
 
 use super::{IntoSystem, SystemParamValidationError, SystemStateFlags};
 
-/// A wrapper system to change a system that returns `()` to return `Ok(())` to make it into a [`ScheduleSystem`]
-pub struct InfallibleSystemWrapper<S: System<In = ()>>(S);
-
-impl<S: System<In = ()>> InfallibleSystemWrapper<S> {
-    /// Create a new `OkWrapperSystem`
-    pub fn new(system: S) -> Self {
-        Self(IntoSystem::into_system(system))
-    }
-}
-
-impl<S: System<In = ()>> System for InfallibleSystemWrapper<S> {
-    type In = ();
-    type Out = Result;
-
-    #[inline]
-    fn name(&self) -> DebugName {
-        self.0.name()
-    }
-
-    fn type_id(&self) -> core::any::TypeId {
-        self.0.type_id()
-    }
-
-    #[inline]
-    fn flags(&self) -> SystemStateFlags {
-        self.0.flags()
-    }
-
-    #[inline]
-    unsafe fn run_unsafe(
-        &mut self,
-        input: SystemIn<'_, Self>,
-        world: UnsafeWorldCell,
-    ) -> Self::Out {
-        self.0.run_unsafe(input, world);
-        Ok(())
-    }
-
-    #[cfg(feature = "hotpatching")]
-    #[inline]
-    fn refresh_hotpatch(&mut self) {
-        self.0.refresh_hotpatch();
-    }
-
-    #[inline]
-    fn apply_deferred(&mut self, world: &mut World) {
-        self.0.apply_deferred(world);
-    }
-
-    #[inline]
-    fn queue_deferred(&mut self, world: DeferredWorld) {
-        self.0.queue_deferred(world);
-    }
-
-    #[inline]
-    unsafe fn validate_param_unsafe(
-        &mut self,
-        world: UnsafeWorldCell,
-    ) -> Result<(), SystemParamValidationError> {
-        self.0.validate_param_unsafe(world)
-    }
-
-    #[inline]
-    fn initialize(&mut self, world: &mut World) -> FilteredAccessSet<ComponentId> {
-        self.0.initialize(world)
-    }
-
-    #[inline]
-    fn check_change_tick(&mut self, check: CheckChangeTicks) {
-        self.0.check_change_tick(check);
-    }
-
-    #[inline]
-    fn get_last_run(&self) -> Tick {
-        self.0.get_last_run()
-    }
-
-    #[inline]
-    fn set_last_run(&mut self, last_run: Tick) {
-        self.0.set_last_run(last_run);
-    }
-
-    fn default_system_sets(&self) -> Vec<crate::schedule::InternedSystemSet> {
-        self.0.default_system_sets()
-    }
-}
-
 /// See [`IntoSystem::with_input`] for details.
 pub struct WithInputWrapper<S, T>
 where
@@ -153,7 +65,7 @@ where
         &mut self,
         _input: SystemIn<'_, Self>,
         world: UnsafeWorldCell,
-    ) -> Self::Out {
+    ) -> Result<Self::Out, RunSystemError> {
         self.system.run_unsafe(&mut self.value, world)
     }
 
@@ -246,7 +158,7 @@ where
         &mut self,
         _input: SystemIn<'_, Self>,
         world: UnsafeWorldCell,
-    ) -> Self::Out {
+    ) -> Result<Self::Out, RunSystemError> {
         let value = self
             .value
             .as_mut()
@@ -296,4 +208,4 @@ where
 }
 
 /// Type alias for a `BoxedSystem` that a `Schedule` can store.
-pub type ScheduleSystem = BoxedSystem<(), Result>;
+pub type ScheduleSystem = BoxedSystem<(), ()>;
diff --git a/crates/bevy_ecs/src/system/system.rs b/crates/bevy_ecs/src/system/system.rs
index d4521e76f..aad37c09d 100644
--- a/crates/bevy_ecs/src/system/system.rs
+++ b/crates/bevy_ecs/src/system/system.rs
@@ -4,12 +4,12 @@
 )]
 use bevy_utils::prelude::DebugName;
 use bitflags::bitflags;
-use core::fmt::Debug;
+use core::fmt::{Debug, Display};
 use log::warn;
-use thiserror::Error;
 
 use crate::{
     component::{CheckChangeTicks, ComponentId, Tick},
+    error::BevyError,
     query::FilteredAccessSet,
     schedule::InternedSystemSet,
     system::{input::SystemInput, SystemIn},
@@ -17,7 +17,7 @@ use crate::{
 };
 
 use alloc::{boxed::Box, vec::Vec};
-use core::any::TypeId;
+use core::any::{Any, TypeId};
 
 use super::{IntoSystem, SystemParamValidationError};
 
@@ -94,8 +94,11 @@ pub trait System: Send + Sync + 'static {
     ///   simultaneous accesses while the system is running.
     /// - If [`System::is_exclusive`] returns `true`, then it must be valid to call
     ///   [`UnsafeWorldCell::world_mut`] on `world`.
-    unsafe fn run_unsafe(&mut self, input: SystemIn<'_, Self>, world: UnsafeWorldCell)
-        -> Self::Out;
+    unsafe fn run_unsafe(
+        &mut self,
+        input: SystemIn<'_, Self>,
+        world: UnsafeWorldCell,
+    ) -> Result<Self::Out, RunSystemError>;
 
     /// Refresh the inner pointer based on the latest hot patch jump table
     #[cfg(feature = "hotpatching")]
@@ -108,10 +111,14 @@ pub trait System: Send + Sync + 'static {
     /// Unlike [`System::run_unsafe`], this will apply deferred parameters *immediately*.
     ///
     /// [`run_readonly`]: ReadOnlySystem::run_readonly
-    fn run(&mut self, input: SystemIn<'_, Self>, world: &mut World) -> Self::Out {
-        let ret = self.run_without_applying_deferred(input, world);
+    fn run(
+        &mut self,
+        input: SystemIn<'_, Self>,
+        world: &mut World,
+    ) -> Result<Self::Out, RunSystemError> {
+        let ret = self.run_without_applying_deferred(input, world)?;
         self.apply_deferred(world);
-        ret
+        Ok(ret)
     }
 
     /// Runs the system with the given input in the world.
@@ -121,10 +128,14 @@ pub trait System: Send + Sync + 'static {
         &mut self,
         input: SystemIn<'_, Self>,
         world: &mut World,
-    ) -> Self::Out {
+    ) -> Result<Self::Out, RunSystemError> {
         let world_cell = world.as_unsafe_world_cell();
         // SAFETY:
         // - We have exclusive access to the entire world.
+        unsafe { self.validate_param_unsafe(world_cell) }?;
+        // SAFETY:
+        // - We have exclusive access to the entire world.
+        // - `update_archetype_component_access` has been called.
         unsafe { self.run_unsafe(input, world_cell) }
     }
 
@@ -215,10 +226,18 @@ pub unsafe trait ReadOnlySystem: System {
     ///
     /// Unlike [`System::run`], this can be called with a shared reference to the world,
     /// since this system is known not to modify the world.
-    fn run_readonly(&mut self, input: SystemIn<'_, Self>, world: &World) -> Self::Out {
+    fn run_readonly(
+        &mut self,
+        input: SystemIn<'_, Self>,
+        world: &World,
+    ) -> Result<Self::Out, RunSystemError> {
         let world = world.as_unsafe_world_cell_readonly();
         // SAFETY:
         // - We have read-only access to the entire world.
+        unsafe { self.validate_param_unsafe(world) }?;
+        // SAFETY:
+        // - We have read-only access to the entire world.
+        // - `update_archetype_component_access` has been called.
         unsafe { self.run_unsafe(input, world) }
     }
 }
@@ -382,34 +401,56 @@ impl RunSystemOnce for &mut World {
     {
         let mut system: T::System = IntoSystem::into_system(system);
         system.initialize(self);
-        system
-            .validate_param(self)
-            .map_err(|err| RunSystemError::InvalidParams {
-                system: system.name(),
-                err,
-            })?;
-        Ok(system.run(input, self))
+        system.run(input, self)
     }
 }
 
 /// Running system failed.
-#[derive(Error, Debug)]
+#[derive(Debug)]
 pub enum RunSystemError {
     /// System could not be run due to parameters that failed validation.
-    /// This should not be considered an error if [`field@SystemParamValidationError::skipped`] is `true`.
-    #[error("System {system} did not run due to failed parameter validation: {err}")]
-    InvalidParams {
-        /// The identifier of the system that was run.
-        system: DebugName,
-        /// The returned parameter validation error.
-        err: SystemParamValidationError,
-    },
+    /// This is not considered an error.
+    Skipped(SystemParamValidationError),
+    /// System returned an error or failed required parameter validation.
+    Failed(BevyError),
+}
+
+impl Display for RunSystemError {
+    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
+        match self {
+            Self::Skipped(err) => write!(
+                f,
+                "System did not run due to failed parameter validation: {err}"
+            ),
+            Self::Failed(err) => write!(f, "{err}"),
+        }
+    }
+}
+
+impl<E: Any> From<E> for RunSystemError
+where
+    BevyError: From<E>,
+{
+    fn from(mut value: E) -> Self {
+        // Specialize the impl so that a skipped `SystemParamValidationError`
+        // is converted to `Skipped` instead of `Failed`.
+        // Note that the `downcast_mut` check is based on the static type,
+        // and can be optimized out after monomorphization.
+        let any: &mut dyn Any = &mut value;
+        if let Some(err) = any.downcast_mut::<SystemParamValidationError>() {
+            if err.skipped {
+                return Self::Skipped(core::mem::replace(err, SystemParamValidationError::EMPTY));
+            }
+        }
+        Self::Failed(From::from(value))
+    }
 }
 
 #[cfg(test)]
 mod tests {
     use super::*;
     use crate::prelude::*;
+    use alloc::string::ToString;
 
     #[test]
     fn run_system_once() {
@@ -481,6 +522,8 @@ mod tests {
         // This fails because `T` has not been added to the world yet.
         let result = world.run_system_once(system);
 
-        assert!(matches!(result, Err(RunSystemError::InvalidParams { .. })));
+        assert!(matches!(result, Err(RunSystemError::Failed { .. })));
+        let expected = "Parameter `Res<T>` failed validation: Resource does not exist\n";
+        assert!(result.unwrap_err().to_string().contains(expected));
     }
 }
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index d86d71b9d..d552bf1f1 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -999,10 +999,10 @@ unsafe impl<'w> SystemParam for DeferredWorld<'w> {
 /// write_system.initialize(world);
 /// read_system.initialize(world);
 ///
-/// assert_eq!(read_system.run((), world), 0);
+/// assert_eq!(read_system.run((), world).unwrap(), 0);
 /// write_system.run((), world);
 /// // Note how the read local is still 0 due to the locals not being shared.
-/// assert_eq!(read_system.run((), world), 0);
+/// assert_eq!(read_system.run((), world).unwrap(), 0);
 /// ```
 ///
 /// A simple way to set a different default value for a local is by wrapping the value with an Option.
@@ -1019,9 +1019,9 @@ unsafe impl<'w> SystemParam for DeferredWorld<'w> {
 /// counter_system.initialize(world);
 ///
 /// // Counter is initialized at 10, and increases to 11 on first run.
-/// assert_eq!(counter_system.run((), world), 11);
+/// assert_eq!(counter_system.run((), world).unwrap(), 11);
 /// // Counter is only increased by 1 on subsequent runs.
-/// assert_eq!(counter_system.run((), world), 12);
+/// assert_eq!(counter_system.run((), world).unwrap(), 12);
 /// ```
 ///
 /// N.B. A [`Local`]s value cannot be read or written to outside of the containing system.
@@ -2825,6 +2825,13 @@ impl SystemParamValidationError {
             field: field.into(),
         }
     }
+
+    pub(crate) const EMPTY: Self = Self {
+        skipped: false,
+        message: Cow::Borrowed(""),
+        param: DebugName::borrowed(""),
+        field: Cow::Borrowed(""),
+    };
 }
 
 impl Display for SystemParamValidationError {
diff --git a/crates/bevy_ecs/src/system/system_registry.rs b/crates/bevy_ecs/src/system/system_registry.rs
index e9c9cdba1..bc87cd4fe 100644
--- a/crates/bevy_ecs/src/system/system_registry.rs
+++ b/crates/bevy_ecs/src/system/system_registry.rs
@@ -3,7 +3,10 @@ use crate::reflect::ReflectComponent;
 use crate::{
     change_detection::Mut,
     entity::Entity,
-    system::{input::SystemInput, BoxedSystem, IntoSystem, SystemParamValidationError},
+    error::BevyError,
+    system::{
+        input::SystemInput, BoxedSystem, IntoSystem, RunSystemError, SystemParamValidationError,
+    },
     world::World,
 };
 use alloc::boxed::Box;
@@ -351,16 +354,10 @@ impl World {
             initialized = true;
         }
 
-        let result = system
-            .validate_param(self)
-            .map_err(|err| RegisteredSystemError::InvalidParams { system: id, err })
-            .map(|()| {
-                // Wait to run the commands until the system is available again.
-                // This is needed so the systems can recursively run themselves.
-                let ret = system.run_without_applying_deferred(input, self);
-                system.queue_deferred(self.into());
-                ret
-            });
+        // Wait to run the commands until the system is available again.
+        // This is needed so the systems can recursively run themselves.
+        let result = system.run_without_applying_deferred(input, self);
+        system.queue_deferred(self.into());
 
         // Return ownership of system trait object (if entity still exists)
         if let Ok(mut entity) = self.get_entity_mut(id.entity) {
@@ -372,7 +369,7 @@ impl World {
 
         // Run any commands enqueued by the system
         self.flush();
-        result
+        Ok(result?)
     }
 
     /// Registers a system or returns its cached [`SystemId`].
@@ -493,14 +490,21 @@ pub enum RegisteredSystemError<I: SystemInput = (), O = ()> {
     #[error("System {0:?} tried to remove itself")]
     SelfRemove(SystemId<I, O>),
     /// System could not be run due to parameters that failed validation.
-    /// This should not be considered an error if [`field@SystemParamValidationError::skipped`] is `true`.
-    #[error("System {system:?} did not run due to failed parameter validation: {err}")]
-    InvalidParams {
-        /// The identifier of the system that was run.
-        system: SystemId<I, O>,
-        /// The returned parameter validation error.
-        err: SystemParamValidationError,
-    },
+    /// This is not considered an error.
+    #[error("System did not run due to failed parameter validation: {0}")]
+    Skipped(SystemParamValidationError),
+    /// System returned an error or failed required parameter validation.
+    #[error("System returned error: {0}")]
+    Failed(BevyError),
+}
+
+impl<I: SystemInput, O> From<RunSystemError> for RegisteredSystemError<I, O> {
+    fn from(value: RunSystemError) -> Self {
+        match value {
+            RunSystemError::Skipped(err) => Self::Skipped(err),
+            RunSystemError::Failed(err) => Self::Failed(err),
+        }
+    }
 }
 
 impl<I: SystemInput, O> core::fmt::Debug for RegisteredSystemError<I, O> {
@@ -512,11 +516,8 @@ impl<I: SystemInput, O> core::fmt::Debug for RegisteredSystemError<I, O> {
             Self::SystemNotCached => write!(f, "SystemNotCached"),
             Self::Recursive(arg0) => f.debug_tuple("Recursive").field(arg0).finish(),
             Self::SelfRemove(arg0) => f.debug_tuple("SelfRemove").field(arg0).finish(),
-            Self::InvalidParams { system, err } => f
-                .debug_struct("InvalidParams")
-                .field("system", system)
-                .field("err", err)
-                .finish(),
+            Self::Skipped(arg0) => f.debug_tuple("Skipped").field(arg0).finish(),
+            Self::Failed(arg0) => f.debug_tuple("Failed").field(arg0).finish(),
         }
     }
 }
@@ -814,6 +815,19 @@ mod tests {
         assert_eq!(world.resource::<Counter>().0, 2);
     }
 
+    #[test]
+    #[should_panic(expected = "This system always fails")]
+    fn cached_fallible_system_commands_can_fail() {
+        use crate::system::command;
+        fn sys() -> Result {
+            Err("This system always fails".into())
+        }
+
+        let mut world = World::new();
+        world.commands().queue(command::run_system_cached(sys));
+        world.flush_commands();
+    }
+
     #[test]
     fn cached_system_adapters() {
         fn four() -> i32 {
@@ -835,10 +849,8 @@ mod tests {
 
     #[test]
     fn cached_system_into_same_system_type() {
-        use crate::error::Result;
-
         struct Foo;
-        impl IntoSystem<(), Result<()>, ()> for Foo {
+        impl IntoSystem<(), (), ()> for Foo {
             type System = ApplyDeferred;
             fn into_system(_: Self) -> Self::System {
                 ApplyDeferred
@@ -846,7 +858,7 @@ mod tests {
         }
 
         struct Bar;
-        impl IntoSystem<(), Result<()>, ()> for Bar {
+        impl IntoSystem<(), (), ()> for Bar {
             type System = ApplyDeferred;
             fn into_system(_: Self) -> Self::System {
                 ApplyDeferred
@@ -913,6 +925,7 @@ mod tests {
     #[test]
     fn run_system_invalid_params() {
         use crate::system::RegisteredSystemError;
+        use alloc::string::ToString;
 
         struct T;
         impl Resource for T {}
@@ -923,10 +936,9 @@ mod tests {
         // This fails because `T` has not been added to the world yet.
         let result = world.run_system(id);
 
-        assert!(matches!(
-            result,
-            Err(RegisteredSystemError::InvalidParams { .. })
-        ));
+        assert!(matches!(result, Err(RegisteredSystemError::Failed { .. })));
+        let expected = "System returned error: Parameter `Res<T>` failed validation: Resource does not exist\n";
+        assert!(result.unwrap_err().to_string().contains(expected));
     }
 
     #[test]
diff --git a/crates/bevy_utils/src/debug_info.rs b/crates/bevy_utils/src/debug_info.rs
index c50917d27..292b77d35 100644
--- a/crates/bevy_utils/src/debug_info.rs
+++ b/crates/bevy_utils/src/debug_info.rs
@@ -43,7 +43,7 @@ impl DebugName {
             reason = "The value will be ignored if the `debug` feature is not enabled"
         )
     )]
-    pub fn borrowed(value: &'static str) -> Self {
+    pub const fn borrowed(value: &'static str) -> Self {
         DebugName {
             #[cfg(feature = "debug")]
             name: Cow::Borrowed(value),
diff --git a/release-content/migration-guides/system_run_returns_result.md b/release-content/migration-guides/system_run_returns_result.md
new file mode 100644
index 000000000..e37a35bea
--- /dev/null
+++ b/release-content/migration-guides/system_run_returns_result.md
@@ -0,0 +1,66 @@
+---
+title: "`System::run` returns `Result`"
+pull_requests: [19145]
+---
+
+In order to support fallible systems and parameter-based system skipping like `Single` and `When<T>` in more places, `System::run` and related methods now return a `Result` instead of a plain value.  
+
+If you were calling `System::run`, `System::run_unsafe`, `System::run_without_applying_deferred`, or `ReadOnlySystem::run_readonly`, the simplest solution is to `unwrap()` the resulting `Result`.
+The only case where an infallible system will return `Err` is an invalid parameter, such as a missing resource, and those cases used to panic.
+
+If you were calling them from a function that returns `Result<T, BevyError>`, you can instead use the `?` operator.
+
+`System::run`, `System::run_without_applying_deferred`, and `ReadOnlySystem::run_readonly` will now call `System::validate_param_unsafe` and return `Err` if validation fails.
+If you were calling `validate_param` or `validate_param_unsafe` before calling one of those, it is no longer necessary.
+Note that `System::run_unsafe` still does *not* perform validation.
+
+If you were manually implementing `System`, the return type to `run_unsafe` has changed from `Out` to `Result<Out, RunSystemError>`.
+If you are implementing an infallible system, simply wrap the return value in `Ok`.
+If you were implementing a fallible system and had set `type Out = Result<T, BevyError>;`, instead set `type Out = T;`.
+
+If you have a system function that returns `Result` or `!` and are not restricting the return type, you may get type inference failures like this:
+
+```text
+error[E0283]: type annotations needed
+    --> lib.rs:100:5
+     |
+100  |     IntoSystem::into_system(example_system);
+     |     ^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `Out` declared on the trait `IntoSystem`
+     |
+note: multiple `impl`s satisfying `core::result::Result<(), bevy_error::BevyError>: function_system::IntoResult<_>` found
+   --> crates\bevy_ecs\src\system\function_system.rs:597:1
+```
+
+or
+
+```text
+error[E0283]: type annotations needed
+    --> lib.rs:100:11
+    |
+100 |     world.run_system_cached(system).unwrap();
+    |           ^^^^^^^^^^^^^^^^^ cannot infer type of the type parameter `O` declared on the method `run_system_cached`
+    |
+note: multiple `impl`s satisfying `core::result::Result<(), bevy_error::BevyError>: function_system::IntoResult<_>` found
+   --> crates\bevy_ecs\src\system\function_system.rs:597:1
+```
+
+A function that returns `Result<T, BevyError>` may be considered either a fallible system that returns `T` or an infallible system that returns `Result`, and a function that returns `!` may be considered a system that returns *any* type.
+You should be able to resolve them by providing an explicit type for `System::Out`.
+
+```rust
+fn example_system() -> Result { Ok(()) }
+// 0.16 - Output type is inferred to be `Result`
+IntoSystem::into_system(example_system)
+// 0.17 - Output type can be either `()` or `Result` and must be written explicitly
+IntoSystem::<_, (), _>::into_system(example_system);
+IntoSystem::<_, Result, _>::into_system(example_system);
+
+// 0.16 - Output type is inferred to be `Result`
+world.run_system_cached(example_system).unwrap().unwrap();
+// 0.17 - Output type can be either `()` or `Result` and must be written explicitly
+world.run_system_cached::<(), _, _>(example_system).unwrap();
+world.run_system_cached::<Result, _, _>(example_system).unwrap().unwrap();
+// or it may be inferred if the output type is specified elsewhere
+let _: () = world.run_system_cached(example_system).unwrap();
+let r: Result = world.run_system_cached(example_system).unwrap();
+```
