diff --git a/crates/bevy_render/src/view/visibility/mod.rs b/crates/bevy_render/src/view/visibility/mod.rs
index 2805c3114..3680ad097 100644
--- a/crates/bevy_render/src/view/visibility/mod.rs
+++ b/crates/bevy_render/src/view/visibility/mod.rs
@@ -412,7 +412,10 @@ pub fn update_frusta<T: Component + CameraProjection + Send + Sync + 'static>(
 fn visibility_propagate_system(
     changed: Query<
         (Entity, &Visibility, Option<&Parent>, Option<&Children>),
-        (With<InheritedVisibility>, Changed<Visibility>),
+        (
+            With<InheritedVisibility>,
+            Or<(Changed<Visibility>, Changed<Parent>)>,
+        ),
     >,
     mut visibility_query: Query<(&Visibility, &mut InheritedVisibility)>,
     children_query: Query<&Children, (With<Visibility>, With<InheritedVisibility>)>,
@@ -757,6 +760,58 @@ mod test {
         );
     }
 
+    #[test]
+    fn test_visibility_propagation_on_parent_change() {
+        // Setup the world and schedule
+        let mut app = App::new();
+
+        app.add_systems(Update, visibility_propagate_system);
+
+        // Create entities with visibility and hierarchy
+        let parent1 = app.world_mut().spawn((Visibility::Hidden,)).id();
+        let parent2 = app.world_mut().spawn((Visibility::Visible,)).id();
+        let child1 = app.world_mut().spawn((Visibility::Inherited,)).id();
+        let child2 = app.world_mut().spawn((Visibility::Inherited,)).id();
+
+        // Build hierarchy
+        app.world_mut()
+            .entity_mut(parent1)
+            .add_children(&[child1, child2]);
+
+        // Run the system initially to set up visibility
+        app.update();
+
+        // Change parent visibility to Hidden
+        app.world_mut()
+            .entity_mut(parent2)
+            .insert(Visibility::Visible);
+        // Simulate a change in the parent component
+        app.world_mut().entity_mut(child2).set_parent(parent2); // example of changing parent
+
+        // Run the system again to propagate changes
+        app.update();
+
+        let is_visible = |e: Entity| {
+            app.world()
+                .entity(e)
+                .get::<InheritedVisibility>()
+                .unwrap()
+                .get()
+        };
+
+        // Retrieve and assert visibility
+
+        assert!(
+            !is_visible(child1),
+            "Child1 should inherit visibility from parent"
+        );
+
+        assert!(
+            is_visible(child2),
+            "Child2 should inherit visibility from parent"
+        );
+    }
+
     #[test]
     fn visibility_propagation_unconditional_visible() {
         use Visibility::{Hidden, Inherited, Visible};
