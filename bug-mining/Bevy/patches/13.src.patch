diff --git a/crates/bevy_gizmos/src/circles.rs b/crates/bevy_gizmos/src/circles.rs
index 9c218fe3a..214399690 100644
--- a/crates/bevy_gizmos/src/circles.rs
+++ b/crates/bevy_gizmos/src/circles.rs
@@ -4,7 +4,7 @@
 //! and assorted support items.
 
 use crate::prelude::{GizmoConfigGroup, Gizmos};
-use bevy_math::{Quat, Vec2, Vec3};
+use bevy_math::{primitives::Direction3d, Quat, Vec2, Vec3};
 use bevy_render::color::Color;
 use std::f32::consts::TAU;
 
@@ -28,12 +28,12 @@ impl<'w, 's, T: GizmoConfigGroup> Gizmos<'w, 's, T> {
     /// # use bevy_render::prelude::*;
     /// # use bevy_math::prelude::*;
     /// fn system(mut gizmos: Gizmos) {
-    ///     gizmos.circle(Vec3::ZERO, Vec3::Z, 1., Color::GREEN);
+    ///     gizmos.circle(Vec3::ZERO, Direction3d::Z, 1., Color::GREEN);
     ///
     ///     // Circles have 32 line-segments by default.
     ///     // You may want to increase this for larger circles.
     ///     gizmos
-    ///         .circle(Vec3::ZERO, Vec3::Z, 5., Color::RED)
+    ///         .circle(Vec3::ZERO, Direction3d::Z, 5., Color::RED)
     ///         .segments(64);
     /// }
     /// # bevy_ecs::system::assert_is_system(system);
@@ -42,7 +42,7 @@ impl<'w, 's, T: GizmoConfigGroup> Gizmos<'w, 's, T> {
     pub fn circle(
         &mut self,
         position: Vec3,
-        normal: Vec3,
+        normal: Direction3d,
         radius: f32,
         color: Color,
     ) -> CircleBuilder<'_, 'w, 's, T> {
@@ -97,7 +97,7 @@ impl<'w, 's, T: GizmoConfigGroup> Gizmos<'w, 's, T> {
 pub struct CircleBuilder<'a, 'w, 's, T: GizmoConfigGroup> {
     gizmos: &'a mut Gizmos<'w, 's, T>,
     position: Vec3,
-    normal: Vec3,
+    normal: Direction3d,
     radius: f32,
     color: Color,
     segments: usize,
@@ -116,7 +116,7 @@ impl<T: GizmoConfigGroup> Drop for CircleBuilder<'_, '_, '_, T> {
         if !self.gizmos.enabled {
             return;
         }
-        let rotation = Quat::from_rotation_arc(Vec3::Z, self.normal);
+        let rotation = Quat::from_rotation_arc(Vec3::Z, *self.normal);
         let positions = circle_inner(self.radius, self.segments)
             .map(|vec2| self.position + rotation * vec2.extend(0.));
         self.gizmos.linestrip(positions, self.color);
diff --git a/crates/bevy_gizmos/src/gizmos.rs b/crates/bevy_gizmos/src/gizmos.rs
index f4541b7f5..b9c066287 100644
--- a/crates/bevy_gizmos/src/gizmos.rs
+++ b/crates/bevy_gizmos/src/gizmos.rs
@@ -8,7 +8,7 @@ use bevy_ecs::{
     system::{Deferred, ReadOnlySystemParam, Res, Resource, SystemBuffer, SystemMeta, SystemParam},
     world::{unsafe_world_cell::UnsafeWorldCell, World},
 };
-use bevy_math::{Mat2, Quat, Vec2, Vec3};
+use bevy_math::{primitives::Direction3d, Mat2, Quat, Vec2, Vec3};
 use bevy_render::color::Color;
 use bevy_transform::TransformPoint;
 
@@ -618,7 +618,12 @@ impl<T: GizmoConfigGroup> Drop for SphereBuilder<'_, '_, '_, T> {
         }
         for axis in Vec3::AXES {
             self.gizmos
-                .circle(self.position, self.rotation * axis, self.radius, self.color)
+                .circle(
+                    self.position,
+                    Direction3d::new_unchecked(self.rotation * axis),
+                    self.radius,
+                    self.color,
+                )
                 .segments(self.circle_segments);
         }
     }
diff --git a/examples/3d/3d_gizmos.rs b/examples/3d/3d_gizmos.rs
index 182342c55..f2bf53a52 100644
--- a/examples/3d/3d_gizmos.rs
+++ b/examples/3d/3d_gizmos.rs
@@ -2,6 +2,7 @@
 
 use std::f32::consts::PI;
 
+use bevy::math::primitives::Direction3d;
 use bevy::prelude::*;
 
 fn main() {
@@ -96,10 +97,10 @@ fn system(mut gizmos: Gizmos, mut my_gizmos: Gizmos<MyRoundGizmos>, time: Res<Ti
     }
 
     // Circles have 32 line-segments by default.
-    my_gizmos.circle(Vec3::ZERO, Vec3::Y, 3., Color::BLACK);
+    my_gizmos.circle(Vec3::ZERO, Direction3d::Y, 3., Color::BLACK);
     // You may want to increase this for larger circles or spheres.
     my_gizmos
-        .circle(Vec3::ZERO, Vec3::Y, 3.1, Color::NAVY)
+        .circle(Vec3::ZERO, Direction3d::Y, 3.1, Color::NAVY)
         .segments(64);
     my_gizmos
         .sphere(Vec3::ZERO, Quat::IDENTITY, 3.2, Color::BLACK)
diff --git a/examples/3d/3d_viewport_to_world.rs b/examples/3d/3d_viewport_to_world.rs
index 183783d0f..fda3a0fc1 100644
--- a/examples/3d/3d_viewport_to_world.rs
+++ b/examples/3d/3d_viewport_to_world.rs
@@ -1,5 +1,6 @@
 //! This example demonstrates how to use the `Camera::viewport_to_world` method.
 
+use bevy::math::primitives::Direction3d;
 use bevy::prelude::*;
 
 fn main() {
@@ -36,7 +37,12 @@ fn draw_cursor(
     let point = ray.get_point(distance);
 
     // Draw a circle just above the ground plane at that position.
-    gizmos.circle(point + ground.up() * 0.01, ground.up(), 0.2, Color::WHITE);
+    gizmos.circle(
+        point + ground.up() * 0.01,
+        Direction3d::new_unchecked(ground.up()), // Up vector is already normalized.
+        0.2,
+        Color::WHITE,
+    );
 }
 
 #[derive(Component)]
