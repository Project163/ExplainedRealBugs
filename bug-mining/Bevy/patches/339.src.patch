diff --git a/benches/Cargo.toml b/benches/Cargo.toml
index e36298004..5e28ffb44 100644
--- a/benches/Cargo.toml
+++ b/benches/Cargo.toml
@@ -13,13 +13,16 @@ criterion = { version = "0.3", features = ["html_reports"] }
 bevy_app = { path = "../crates/bevy_app" }
 bevy_ecs = { path = "../crates/bevy_ecs", features = ["multi_threaded"] }
 bevy_hierarchy = { path = "../crates/bevy_hierarchy" }
-bevy_internal = { path = "../crates/bevy_internal" }
 bevy_math = { path = "../crates/bevy_math" }
 bevy_reflect = { path = "../crates/bevy_reflect", features = ["functions"] }
 bevy_render = { path = "../crates/bevy_render" }
 bevy_tasks = { path = "../crates/bevy_tasks" }
 bevy_utils = { path = "../crates/bevy_utils" }
 
+# make bevy_render compile on linux. x11 vs wayland does not matter here as the benches do not actually use a window
+[target.'cfg(target_os = "linux")'.dev-dependencies]
+bevy_winit = { path = "../crates/bevy_winit", features = ["x11"] }
+
 [profile.release]
 opt-level = 3
 lto = true
diff --git a/benches/benches/bevy_reflect/struct.rs b/benches/benches/bevy_reflect/struct.rs
index 049570180..9c6163d24 100644
--- a/benches/benches/bevy_reflect/struct.rs
+++ b/benches/benches/bevy_reflect/struct.rs
@@ -1,6 +1,6 @@
 use std::time::Duration;
 
-use bevy_reflect::{DynamicStruct, GetField, Reflect, Struct};
+use bevy_reflect::{DynamicStruct, GetField, PartialReflect, Reflect, Struct};
 use criterion::{
     black_box, criterion_group, criterion_main, BatchSize, BenchmarkId, Criterion, Throughput,
 };
@@ -62,7 +62,7 @@ fn concrete_struct_apply(criterion: &mut Criterion) {
 
     // Use functions that produce trait objects of varying concrete types as the
     // input to the benchmark.
-    let inputs: &[fn() -> (Box<dyn Struct>, Box<dyn Reflect>)] = &[
+    let inputs: &[fn() -> (Box<dyn Struct>, Box<dyn PartialReflect>)] = &[
         || (Box::new(Struct16::default()), Box::new(Struct16::default())),
         || (Box::new(Struct32::default()), Box::new(Struct32::default())),
         || (Box::new(Struct64::default()), Box::new(Struct64::default())),
@@ -240,7 +240,7 @@ fn dynamic_struct_apply(criterion: &mut Criterion) {
     group.warm_up_time(WARM_UP_TIME);
     group.measurement_time(MEASUREMENT_TIME);
 
-    let patches: &[(fn() -> Box<dyn Reflect>, usize)] = &[
+    let patches: &[(fn() -> Box<dyn PartialReflect>, usize)] = &[
         (|| Box::new(Struct16::default()), 16),
         (|| Box::new(Struct32::default()), 32),
         (|| Box::new(Struct64::default()), 64),
diff --git a/tools/ci/src/commands/bench_check.rs b/tools/ci/src/commands/bench_check.rs
index 6aa205a59..9e72ab0a6 100644
--- a/tools/ci/src/commands/bench_check.rs
+++ b/tools/ci/src/commands/bench_check.rs
@@ -10,7 +10,10 @@ pub struct BenchCheckCommand {}
 impl Prepare for BenchCheckCommand {
     fn prepare<'a>(&self, sh: &'a xshell::Shell, _flags: Flag) -> Vec<PreparedCommand<'a>> {
         vec![PreparedCommand::new::<Self>(
-            cmd!(sh, "cargo check --benches --target-dir ../target"),
+            cmd!(
+                sh,
+                "cargo check --benches --target-dir ../target --manifest-path ./benches/Cargo.toml"
+            ),
             "Failed to check the benches.",
         )]
     }
