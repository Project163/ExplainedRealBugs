diff --git a/crates/bevy_ecs/src/archetype.rs b/crates/bevy_ecs/src/archetype.rs
index 6e6450a98..be502459d 100644
--- a/crates/bevy_ecs/src/archetype.rs
+++ b/crates/bevy_ecs/src/archetype.rs
@@ -370,6 +370,7 @@ impl Archetype {
             // SAFETY: We are creating an archetype that includes this component so it must exist
             let info = unsafe { components.get_info_unchecked(component_id) };
             info.update_archetype_flags(&mut flags);
+            observers.update_archetype_flags(component_id, &mut flags);
             archetype_components.insert(
                 component_id,
                 ArchetypeComponentInfo {
diff --git a/crates/bevy_ecs/src/observer/mod.rs b/crates/bevy_ecs/src/observer/mod.rs
index 08e87854c..b1876afdd 100644
--- a/crates/bevy_ecs/src/observer/mod.rs
+++ b/crates/bevy_ecs/src/observer/mod.rs
@@ -400,6 +400,10 @@ mod tests {
     #[derive(Component)]
     struct C;
 
+    #[derive(Component)]
+    #[component(storage = "SparseSet")]
+    struct S;
+
     #[derive(Event)]
     struct EventA;
 
@@ -444,6 +448,22 @@ mod tests {
         assert_eq!(3, world.resource::<R>().0);
     }
 
+    #[test]
+    fn observer_order_insert_remove_sparse() {
+        let mut world = World::new();
+        world.init_resource::<R>();
+
+        world.observe(|_: Trigger<OnAdd, S>, mut res: ResMut<R>| res.assert_order(0));
+        world.observe(|_: Trigger<OnInsert, S>, mut res: ResMut<R>| res.assert_order(1));
+        world.observe(|_: Trigger<OnRemove, S>, mut res: ResMut<R>| res.assert_order(2));
+
+        let mut entity = world.spawn_empty();
+        entity.insert(S);
+        entity.remove::<S>();
+        entity.flush();
+        assert_eq!(3, world.resource::<R>().0);
+    }
+
     #[test]
     fn observer_order_recursive() {
         let mut world = World::new();
