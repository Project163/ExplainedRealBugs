diff --git a/crates/bevy_picking/src/events.rs b/crates/bevy_picking/src/events.rs
index aea499581..bb2458b7a 100644
--- a/crates/bevy_picking/src/events.rs
+++ b/crates/bevy_picking/src/events.rs
@@ -31,7 +31,7 @@
 //!
 //! The events this module defines fall into a few broad categories:
 //! + Hovering and movement: [`Over`], [`Move`], and [`Out`].
-//! + Clicking and pressing: [`Down`], [`Up`], and [`Click`].
+//! + Clicking and pressing: [`Pressed`], [`Released`], and [`Click`].
 //! + Dragging and dropping: [`DragStart`], [`Drag`], [`DragEnd`], [`DragEnter`], [`DragOver`], [`DragDrop`], [`DragLeave`].
 //!
 //! When received by an observer, these events will always be wrapped by the [`Pointer`] type, which contains
@@ -167,7 +167,7 @@ pub struct Out {
 
 /// Fires when a pointer button is pressed over the `target` entity.
 #[derive(Clone, PartialEq, Debug, Reflect)]
-pub struct Down {
+pub struct Pressed {
     /// Pointer button pressed to trigger this event.
     pub button: PointerButton,
     /// Information about the picking intersection.
@@ -176,14 +176,14 @@ pub struct Down {
 
 /// Fires when a pointer button is released over the `target` entity.
 #[derive(Clone, PartialEq, Debug, Reflect)]
-pub struct Up {
+pub struct Released {
     /// Pointer button lifted to trigger this event.
     pub button: PointerButton,
     /// Information about the picking intersection.
     pub hit: HitData,
 }
 
-/// Fires when a pointer sends a pointer down event followed by a pointer up event, with the same
+/// Fires when a pointer sends a pointer pressed event followed by a pointer released event, with the same
 /// `target` entity for both events.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 pub struct Click {
@@ -204,7 +204,7 @@ pub struct Move {
     pub delta: Vec2,
 }
 
-/// Fires when the `target` entity receives a pointer down event followed by a pointer move event.
+/// Fires when the `target` entity receives a pointer pressed event followed by a pointer move event.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 pub struct DragStart {
     /// Pointer button pressed and moved to trigger this event.
@@ -224,10 +224,10 @@ pub struct Drag {
     pub delta: Vec2,
 }
 
-/// Fires when a pointer is dragging the `target` entity and a pointer up event is received.
+/// Fires when a pointer is dragging the `target` entity and a pointer released event is received.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 pub struct DragEnd {
-    /// Pointer button pressed, moved, and lifted to trigger this event.
+    /// Pointer button pressed, moved, and released to trigger this event.
     pub button: PointerButton,
     /// The vector of drag movement measured from start to final pointer position.
     pub distance: Vec2,
@@ -269,7 +269,7 @@ pub struct DragLeave {
 /// Fires when a pointer drops the `dropped` entity onto the `target` entity.
 #[derive(Clone, PartialEq, Debug, Reflect)]
 pub struct DragDrop {
-    /// Pointer button lifted to drop.
+    /// Pointer button released to drop.
     pub button: PointerButton,
     /// The entity that was dropped onto the `target` entity.
     pub dropped: Entity,
@@ -339,7 +339,7 @@ impl PointerState {
 pub struct PickingEventWriters<'w> {
     cancel_events: EventWriter<'w, Pointer<Cancel>>,
     click_events: EventWriter<'w, Pointer<Click>>,
-    down_events: EventWriter<'w, Pointer<Down>>,
+    pressed_events: EventWriter<'w, Pointer<Pressed>>,
     drag_drop_events: EventWriter<'w, Pointer<DragDrop>>,
     drag_end_events: EventWriter<'w, Pointer<DragEnd>>,
     drag_enter_events: EventWriter<'w, Pointer<DragEnter>>,
@@ -350,7 +350,7 @@ pub struct PickingEventWriters<'w> {
     move_events: EventWriter<'w, Pointer<Move>>,
     out_events: EventWriter<'w, Pointer<Out>>,
     over_events: EventWriter<'w, Pointer<Over>>,
-    up_events: EventWriter<'w, Pointer<Up>>,
+    released_events: EventWriter<'w, Pointer<Released>>,
 }
 
 /// Dispatches interaction events to the target entities.
@@ -360,7 +360,7 @@ pub struct PickingEventWriters<'w> {
 /// + [`DragEnter`] → [`Over`].
 /// + Any number of any of the following:
 ///   + For each movement: [`DragStart`] → [`Drag`] → [`DragOver`] → [`Move`].
-///   + For each button press: [`Down`] or [`Click`] → [`Up`] → [`DragDrop`] → [`DragEnd`] → [`DragLeave`].
+///   + For each button press: [`Pressed`] or [`Click`] → [`Released`] → [`DragDrop`] → [`DragEnd`] → [`DragLeave`].
 ///   + For each pointer cancellation: [`Cancel`].
 ///
 /// Additionally, across multiple frames, the following are also strictly
@@ -368,7 +368,7 @@ pub struct PickingEventWriters<'w> {
 /// + When a pointer moves over the target:
 ///   [`Over`], [`Move`], [`Out`].
 /// + When a pointer presses buttons on the target:
-///   [`Down`], [`Click`], [`Up`].
+///   [`Pressed`], [`Click`], [`Released`].
 /// + When a pointer drags the target:
 ///   [`DragStart`], [`Drag`], [`DragEnd`].
 /// + When a pointer drags something over the target:
@@ -390,7 +390,7 @@ pub struct PickingEventWriters<'w> {
 /// In the context of UI, this is especially problematic. Additional hierarchy-aware
 /// events will be added in a future release.
 ///
-/// Both [`Click`] and [`Up`] target the entity hovered in the *previous frame*,
+/// Both [`Click`] and [`Released`] target the entity hovered in the *previous frame*,
 /// rather than the current frame. This is because touch pointers hover nothing
 /// on the frame they are released. The end effect is that these two events can
 /// be received sequentally after an [`Out`] event (but always on the same frame
@@ -545,31 +545,31 @@ pub fn pointer_events(
 
                 // The sequence of events emitted depends on if this is a press or a release
                 match direction {
-                    PressDirection::Down => {
-                        // If it's a press, emit a Down event and mark the hovered entities as pressed
+                    PressDirection::Pressed => {
+                        // If it's a press, emit a Pressed event and mark the hovered entities as pressed
                         for (hovered_entity, hit) in hover_map
                             .get(&pointer_id)
                             .iter()
                             .flat_map(|h| h.iter().map(|(entity, data)| (*entity, data.clone())))
                         {
-                            let down_event = Pointer::new(
+                            let pressed_event = Pointer::new(
                                 pointer_id,
                                 location.clone(),
                                 hovered_entity,
-                                Down {
+                                Pressed {
                                     button,
                                     hit: hit.clone(),
                                 },
                             );
-                            commands.trigger_targets(down_event.clone(), hovered_entity);
-                            event_writers.down_events.send(down_event);
+                            commands.trigger_targets(pressed_event.clone(), hovered_entity);
+                            event_writers.pressed_events.send(pressed_event);
                             // Also insert the press into the state
                             state
                                 .pressing
                                 .insert(hovered_entity, (location.clone(), now, hit));
                         }
                     }
-                    PressDirection::Up => {
+                    PressDirection::Released => {
                         // Emit Click and Up events on all the previously hovered entities.
                         for (hovered_entity, hit) in previous_hover_map
                             .get(&pointer_id)
@@ -592,18 +592,18 @@ pub fn pointer_events(
                                 commands.trigger_targets(click_event.clone(), hovered_entity);
                                 event_writers.click_events.send(click_event);
                             }
-                            // Always send the Up event
-                            let up_event = Pointer::new(
+                            // Always send the Released event
+                            let released_event = Pointer::new(
                                 pointer_id,
                                 location.clone(),
                                 hovered_entity,
-                                Up {
+                                Released {
                                     button,
                                     hit: hit.clone(),
                                 },
                             );
-                            commands.trigger_targets(up_event.clone(), hovered_entity);
-                            event_writers.up_events.send(up_event);
+                            commands.trigger_targets(released_event.clone(), hovered_entity);
+                            event_writers.released_events.send(released_event);
                         }
 
                         // Then emit the drop events.
diff --git a/crates/bevy_picking/src/input.rs b/crates/bevy_picking/src/input.rs
index 7c32ffac2..321ed6b5e 100644
--- a/crates/bevy_picking/src/input.rs
+++ b/crates/bevy_picking/src/input.rs
@@ -152,8 +152,8 @@ pub fn mouse_pick_events(
                     MouseButton::Other(_) | MouseButton::Back | MouseButton::Forward => continue,
                 };
                 let direction = match input.state {
-                    ButtonState::Pressed => PressDirection::Down,
-                    ButtonState::Released => PressDirection::Up,
+                    ButtonState::Pressed => PressDirection::Pressed,
+                    ButtonState::Released => PressDirection::Released,
                 };
                 pointer_events.send(PointerInput::new(
                     PointerId::Mouse,
@@ -198,7 +198,7 @@ pub fn touch_pick_events(
                         pointer,
                         location,
                         PointerAction::Pressed {
-                            direction: PressDirection::Down,
+                            direction: PressDirection::Pressed,
                             button: PointerButton::Primary,
                         },
                     ));
@@ -226,7 +226,7 @@ pub fn touch_pick_events(
                         pointer,
                         location,
                         PointerAction::Pressed {
-                            direction: PressDirection::Up,
+                            direction: PressDirection::Released,
                             button: PointerButton::Primary,
                         },
                     ));
diff --git a/crates/bevy_picking/src/lib.rs b/crates/bevy_picking/src/lib.rs
index 3ff6f88d5..3dd24c6a6 100644
--- a/crates/bevy_picking/src/lib.rs
+++ b/crates/bevy_picking/src/lib.rs
@@ -400,7 +400,7 @@ impl Plugin for InteractionPlugin {
             .init_resource::<PointerState>()
             .add_event::<Pointer<Cancel>>()
             .add_event::<Pointer<Click>>()
-            .add_event::<Pointer<Down>>()
+            .add_event::<Pointer<Pressed>>()
             .add_event::<Pointer<DragDrop>>()
             .add_event::<Pointer<DragEnd>>()
             .add_event::<Pointer<DragEnter>>()
@@ -411,7 +411,7 @@ impl Plugin for InteractionPlugin {
             .add_event::<Pointer<Move>>()
             .add_event::<Pointer<Out>>()
             .add_event::<Pointer<Over>>()
-            .add_event::<Pointer<Up>>()
+            .add_event::<Pointer<Released>>()
             .add_systems(
                 PreUpdate,
                 (update_focus, pointer_events, update_interactions)
diff --git a/crates/bevy_picking/src/pointer.rs b/crates/bevy_picking/src/pointer.rs
index fd7ec7b1e..d8a65d958 100644
--- a/crates/bevy_picking/src/pointer.rs
+++ b/crates/bevy_picking/src/pointer.rs
@@ -146,9 +146,9 @@ impl PointerPress {
 #[derive(Debug, Clone, Copy, PartialEq, Eq, Reflect)]
 pub enum PressDirection {
     /// The pointer button was just pressed
-    Down,
+    Pressed,
     /// The pointer button was just released
-    Up,
+    Released,
 }
 
 /// The button that was just pressed or released
@@ -245,7 +245,7 @@ impl Location {
 pub enum PointerAction {
     /// A button has been pressed on the pointer.
     Pressed {
-        /// The press direction, either down or up.
+        /// The press state, either pressed or released.
         direction: PressDirection,
         /// The button that was pressed.
         button: PointerButton,
@@ -286,7 +286,7 @@ impl PointerInput {
     #[inline]
     pub fn button_just_pressed(&self, target_button: PointerButton) -> bool {
         if let PointerAction::Pressed { direction, button } = self.action {
-            direction == PressDirection::Down && button == target_button
+            direction == PressDirection::Pressed && button == target_button
         } else {
             false
         }
@@ -296,7 +296,7 @@ impl PointerInput {
     #[inline]
     pub fn button_just_released(&self, target_button: PointerButton) -> bool {
         if let PointerAction::Pressed { direction, button } = self.action {
-            direction == PressDirection::Up && button == target_button
+            direction == PressDirection::Released && button == target_button
         } else {
             false
         }
@@ -314,11 +314,11 @@ impl PointerInput {
                         .iter_mut()
                         .for_each(|(pointer_id, _, mut pointer)| {
                             if *pointer_id == event.pointer_id {
-                                let is_down = direction == PressDirection::Down;
+                                let is_pressed = direction == PressDirection::Pressed;
                                 match button {
-                                    PointerButton::Primary => pointer.primary = is_down,
-                                    PointerButton::Secondary => pointer.secondary = is_down,
-                                    PointerButton::Middle => pointer.middle = is_down,
+                                    PointerButton::Primary => pointer.primary = is_pressed,
+                                    PointerButton::Secondary => pointer.secondary = is_pressed,
+                                    PointerButton::Middle => pointer.middle = is_pressed,
                                 }
                             }
                         });
diff --git a/examples/picking/mesh_picking.rs b/examples/picking/mesh_picking.rs
index a273e5f7f..a6b1c0e9d 100644
--- a/examples/picking/mesh_picking.rs
+++ b/examples/picking/mesh_picking.rs
@@ -91,8 +91,8 @@ fn setup_scene(
             ))
             .observe(update_material_on::<Pointer<Over>>(hover_matl.clone()))
             .observe(update_material_on::<Pointer<Out>>(white_matl.clone()))
-            .observe(update_material_on::<Pointer<Down>>(pressed_matl.clone()))
-            .observe(update_material_on::<Pointer<Up>>(hover_matl.clone()))
+            .observe(update_material_on::<Pointer<Pressed>>(pressed_matl.clone()))
+            .observe(update_material_on::<Pointer<Released>>(hover_matl.clone()))
             .observe(rotate_on_drag);
     }
 
@@ -114,8 +114,8 @@ fn setup_scene(
             ))
             .observe(update_material_on::<Pointer<Over>>(hover_matl.clone()))
             .observe(update_material_on::<Pointer<Out>>(white_matl.clone()))
-            .observe(update_material_on::<Pointer<Down>>(pressed_matl.clone()))
-            .observe(update_material_on::<Pointer<Up>>(hover_matl.clone()))
+            .observe(update_material_on::<Pointer<Pressed>>(pressed_matl.clone()))
+            .observe(update_material_on::<Pointer<Released>>(hover_matl.clone()))
             .observe(rotate_on_drag);
     }
 
diff --git a/examples/picking/sprite_picking.rs b/examples/picking/sprite_picking.rs
index da7f79b04..417f590cf 100644
--- a/examples/picking/sprite_picking.rs
+++ b/examples/picking/sprite_picking.rs
@@ -63,8 +63,8 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                     ))
                     .observe(recolor_on::<Pointer<Over>>(Color::srgb(0.0, 1.0, 1.0)))
                     .observe(recolor_on::<Pointer<Out>>(Color::BLACK))
-                    .observe(recolor_on::<Pointer<Down>>(Color::srgb(1.0, 1.0, 0.0)))
-                    .observe(recolor_on::<Pointer<Up>>(Color::srgb(0.0, 1.0, 1.0)));
+                    .observe(recolor_on::<Pointer<Pressed>>(Color::srgb(1.0, 1.0, 0.0)))
+                    .observe(recolor_on::<Pointer<Released>>(Color::srgb(0.0, 1.0, 1.0)));
 
                 commands
                     .spawn((
@@ -82,8 +82,8 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                     ))
                     .observe(recolor_on::<Pointer<Over>>(Color::srgb(0.0, 1.0, 0.0)))
                     .observe(recolor_on::<Pointer<Out>>(Color::srgb(1.0, 0.0, 0.0)))
-                    .observe(recolor_on::<Pointer<Down>>(Color::srgb(0.0, 0.0, 1.0)))
-                    .observe(recolor_on::<Pointer<Up>>(Color::srgb(0.0, 1.0, 0.0)));
+                    .observe(recolor_on::<Pointer<Pressed>>(Color::srgb(0.0, 0.0, 1.0)))
+                    .observe(recolor_on::<Pointer<Released>>(Color::srgb(0.0, 1.0, 0.0)));
             }
         });
 }
@@ -143,8 +143,8 @@ fn setup_atlas(
         ))
         .observe(recolor_on::<Pointer<Over>>(Color::srgb(0.0, 1.0, 1.0)))
         .observe(recolor_on::<Pointer<Out>>(Color::srgb(1.0, 1.0, 1.0)))
-        .observe(recolor_on::<Pointer<Down>>(Color::srgb(1.0, 1.0, 0.0)))
-        .observe(recolor_on::<Pointer<Up>>(Color::srgb(0.0, 1.0, 1.0)));
+        .observe(recolor_on::<Pointer<Pressed>>(Color::srgb(1.0, 1.0, 0.0)))
+        .observe(recolor_on::<Pointer<Released>>(Color::srgb(0.0, 1.0, 1.0)));
 }
 
 // An observer listener that changes the target entity's color.
diff --git a/examples/ui/scroll.rs b/examples/ui/scroll.rs
index 0467f61ce..c28abddd2 100644
--- a/examples/ui/scroll.rs
+++ b/examples/ui/scroll.rs
@@ -89,7 +89,7 @@ fn setup(mut commands: Commands, asset_server: Res<AssetServer>) {
                                     ..default()
                                 })
                                 .observe(|
-                                    trigger: Trigger<Pointer<Down>>,
+                                    trigger: Trigger<Pointer<Pressed>>,
                                     mut commands: Commands
                                 | {
                                     if trigger.event().button == PointerButton::Primary {
