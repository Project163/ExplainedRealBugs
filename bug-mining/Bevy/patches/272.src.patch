diff --git a/crates/bevy_animation/src/lib.rs b/crates/bevy_animation/src/lib.rs
index 0023532a1..25ed18aaf 100644
--- a/crates/bevy_animation/src/lib.rs
+++ b/crates/bevy_animation/src/lib.rs
@@ -107,7 +107,7 @@ pub struct VariableCurve {
     ///
     /// - for `Interpolation::Step` and `Interpolation::Linear`, each keyframe is a single value
     /// - for `Interpolation::CubicSpline`, each keyframe is made of three values for `tangent_in`,
-    /// `keyframe_value` and `tangent_out`
+    ///     `keyframe_value` and `tangent_out`
     pub keyframes: Keyframes,
     /// Interpolation method to use between keyframes.
     pub interpolation: Interpolation,
diff --git a/crates/bevy_app/src/panic_handler.rs b/crates/bevy_app/src/panic_handler.rs
index d66062e10..89833a014 100644
--- a/crates/bevy_app/src/panic_handler.rs
+++ b/crates/bevy_app/src/panic_handler.rs
@@ -12,7 +12,7 @@ use crate::Plugin;
 /// Adds sensible panic handlers to Apps. This plugin is part of the `DefaultPlugins`. Adding
 /// this plugin will setup a panic hook appropriate to your target platform:
 /// * On WASM, uses [`console_error_panic_hook`](https://crates.io/crates/console_error_panic_hook), logging
-/// to the browser console.
+///     to the browser console.
 /// * Other platforms are currently not setup.
 ///
 /// ```no_run
diff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs
index 8556fbd41..bf3730224 100644
--- a/crates/bevy_asset/src/lib.rs
+++ b/crates/bevy_asset/src/lib.rs
@@ -306,8 +306,8 @@ pub trait AssetApp {
     /// * Initializing the [`AssetEvent`] resource for the [`Asset`]
     /// * Adding other relevant systems and resources for the [`Asset`]
     /// * Ignoring schedule ambiguities in [`Assets`] resource. Any time a system takes
-    /// mutable access to this resource this causes a conflict, but they rarely actually
-    /// modify the same underlying asset.
+    ///     mutable access to this resource this causes a conflict, but they rarely actually
+    ///     modify the same underlying asset.
     fn init_asset<A: Asset>(&mut self) -> &mut Self;
     /// Registers the asset type `T` using `[App::register]`,
     /// and adds [`ReflectAsset`] type data to `T` and [`ReflectHandle`] type data to [`Handle<T>`] in the type registry.
@@ -1511,6 +1511,7 @@ mod tests {
         Empty,
     }
 
+    #[allow(dead_code)]
     #[derive(Asset, TypePath)]
     pub struct StructTestAsset {
         #[dependency]
@@ -1519,6 +1520,7 @@ mod tests {
         embedded: TestAsset,
     }
 
+    #[allow(dead_code)]
     #[derive(Asset, TypePath)]
     pub struct TupleTestAsset(#[dependency] Handle<TestAsset>);
 }
diff --git a/crates/bevy_asset/src/path.rs b/crates/bevy_asset/src/path.rs
index b5eda7866..0e40eb8b1 100644
--- a/crates/bevy_asset/src/path.rs
+++ b/crates/bevy_asset/src/path.rs
@@ -17,7 +17,7 @@ use thiserror::Error;
 ///     This is optional. If one is not set the default source will be used (which is the `assets` folder by default).
 /// * [`AssetPath::path`]: The "virtual filesystem path" pointing to an asset source file.
 /// * [`AssetPath::label`]: An optional "named sub asset". When assets are loaded, they are
-/// allowed to load "sub assets" of any type, which are identified by a named "label".
+///     allowed to load "sub assets" of any type, which are identified by a named "label".
 ///
 /// Asset paths are generally constructed (and visualized) as strings:
 ///
diff --git a/crates/bevy_asset/src/processor/mod.rs b/crates/bevy_asset/src/processor/mod.rs
index bd33f9bb1..f3da27d83 100644
--- a/crates/bevy_asset/src/processor/mod.rs
+++ b/crates/bevy_asset/src/processor/mod.rs
@@ -170,7 +170,7 @@ impl AssetProcessor {
     /// * Scan the processed [`AssetReader`] to build the current view of already processed assets.
     /// * Scan the unprocessed [`AssetReader`] and remove any final processed assets that are invalid or no longer exist.
     /// * For each asset in the unprocessed [`AssetReader`], kick off a new "process job", which will process the asset
-    /// (if the latest version of the asset has not been processed).
+    ///     (if the latest version of the asset has not been processed).
     #[cfg(all(not(target_arch = "wasm32"), feature = "multi_threaded"))]
     pub fn process_assets(&self) {
         let start_time = std::time::Instant::now();
@@ -1098,6 +1098,7 @@ pub(crate) struct ProcessorAssetInfo {
     /// * when the processor is running in parallel with an app
     /// * when processing assets in parallel, the processor might read an asset's `process_dependencies` when processing new versions of those dependencies
     ///     * this second scenario almost certainly isn't possible with the current implementation, but its worth protecting against
+    ///
     /// This lock defends against those scenarios by ensuring readers don't read while processed files are being written. And it ensures
     /// Because this lock is shared across meta and asset bytes, readers can ensure they don't read "old" versions of metadata with "new" asset data.
     pub(crate) file_transaction_lock: Arc<async_lock::RwLock<()>>,
diff --git a/crates/bevy_asset/src/server/mod.rs b/crates/bevy_asset/src/server/mod.rs
index a75fb9a4a..f9427ad60 100644
--- a/crates/bevy_asset/src/server/mod.rs
+++ b/crates/bevy_asset/src/server/mod.rs
@@ -40,7 +40,7 @@ use crate::io::{AssetReader, AssetWriter};
 ///
 /// The general process to load an asset is:
 /// 1. Initialize a new [`Asset`] type with the [`AssetServer`] via [`AssetApp::init_asset`], which will internally call [`AssetServer::register_asset`]
-/// and set up related ECS [`Assets`] storage and systems.
+///     and set up related ECS [`Assets`] storage and systems.
 /// 2. Register one or more [`AssetLoader`]s for that asset with [`AssetApp::init_asset_loader`]
 /// 3. Add the asset to your asset folder (defaults to `assets`).
 /// 4. Call [`AssetServer::load`] with a path to your asset.
diff --git a/crates/bevy_core_pipeline/src/auto_exposure/compensation_curve.rs b/crates/bevy_core_pipeline/src/auto_exposure/compensation_curve.rs
index 880d13d91..6b648eeed 100644
--- a/crates/bevy_core_pipeline/src/auto_exposure/compensation_curve.rs
+++ b/crates/bevy_core_pipeline/src/auto_exposure/compensation_curve.rs
@@ -32,6 +32,7 @@ pub struct AutoExposureCompensationCurve {
     /// Each value in the LUT is a `u8` representing a normalized exposure compensation value:
     /// * `0` maps to `min_compensation`
     /// * `255` maps to `max_compensation`
+    ///
     /// The position in the LUT corresponds to the normalized log luminance value.
     /// * `0` maps to `min_log_lum`
     /// * `LUT_SIZE - 1` maps to `max_log_lum`
diff --git a/crates/bevy_core_pipeline/src/auto_exposure/settings.rs b/crates/bevy_core_pipeline/src/auto_exposure/settings.rs
index ccef945ef..c5d28c94c 100644
--- a/crates/bevy_core_pipeline/src/auto_exposure/settings.rs
+++ b/crates/bevy_core_pipeline/src/auto_exposure/settings.rs
@@ -67,6 +67,7 @@ pub struct AutoExposureSettings {
     /// The mask to apply when metering. The mask will cover the entire screen, where:
     /// * `(0.0, 0.0)` is the top-left corner,
     /// * `(1.0, 1.0)` is the bottom-right corner.
+    ///
     /// Only the red channel of the texture is used.
     /// The sample at the current screen position will be used to weight the contribution
     /// of each pixel to the histogram:
diff --git a/crates/bevy_dev_tools/src/lib.rs b/crates/bevy_dev_tools/src/lib.rs
index 58c1e8c17..16547d7ce 100644
--- a/crates/bevy_dev_tools/src/lib.rs
+++ b/crates/bevy_dev_tools/src/lib.rs
@@ -30,7 +30,7 @@ pub mod states;
 /// To enable developer tools, you can either:
 ///
 /// - Create a custom crate feature (e.g "`dev_mode`"), which enables the `bevy_dev_tools` feature
-/// along with any other development tools you might be using:
+///     along with any other development tools you might be using:
 ///
 /// ```toml
 /// [feature]
diff --git a/crates/bevy_ecs/src/event/collections.rs b/crates/bevy_ecs/src/event/collections.rs
index 79f7b8566..68928d4c1 100644
--- a/crates/bevy_ecs/src/event/collections.rs
+++ b/crates/bevy_ecs/src/event/collections.rs
@@ -68,7 +68,7 @@ use std::ops::{Deref, DerefMut};
 /// - [`EventReader`]s that read at least once per update will never drop events.
 /// - [`EventReader`]s that read once within two updates might still receive some events
 /// - [`EventReader`]s that read after two updates are guaranteed to drop all events that occurred
-/// before those updates.
+///     before those updates.
 ///
 /// The buffers in [`Events`] will grow indefinitely if [`update`](Events::update) is never called.
 ///
diff --git a/crates/bevy_ecs/src/query/access.rs b/crates/bevy_ecs/src/query/access.rs
index 3ee0e484a..27a8c9532 100644
--- a/crates/bevy_ecs/src/query/access.rs
+++ b/crates/bevy_ecs/src/query/access.rs
@@ -316,7 +316,7 @@ impl<T: SparseSetIndex> Access<T> {
 /// otherwise would allow for queries to be considered disjoint when they shouldn't:
 /// - `Query<(&mut T, Option<&U>)>` read/write `T`, read `U`, with `U`
 /// - `Query<&mut T, Without<U>>` read/write `T`, without `U`
-/// from this we could reasonably conclude that the queries are disjoint but they aren't.
+///     from this we could reasonably conclude that the queries are disjoint but they aren't.
 ///
 /// In order to solve this the actual access that `Query<(&mut T, Option<&U>)>` has
 /// is read/write `T`, read `U`. It must still have a read `U` access otherwise the following
diff --git a/crates/bevy_ecs/src/query/state.rs b/crates/bevy_ecs/src/query/state.rs
index b59822ef1..dcb20250c 100644
--- a/crates/bevy_ecs/src/query/state.rs
+++ b/crates/bevy_ecs/src/query/state.rs
@@ -44,9 +44,9 @@ pub(super) union StorageId {
 ///
 /// This data is cached between system runs, and is used to:
 /// - store metadata about which [`Table`] or [`Archetype`] are matched by the query. "Matched" means
-/// that the query will iterate over the data in the matched table/archetype.
+///     that the query will iterate over the data in the matched table/archetype.
 /// - cache the [`State`] needed to compute the [`Fetch`] struct used to retrieve data
-/// from a specific [`Table`] or [`Archetype`]
+///     from a specific [`Table`] or [`Archetype`]
 /// - build iterators that can iterate over the query results
 ///
 /// [`State`]: crate::query::world_query::WorldQuery::State
@@ -901,9 +901,9 @@ impl<D: QueryData, F: QueryFilter> QueryState<D, F> {
     /// # Safety
     ///
     /// * `world` must have permission to read all of the components returned from this call.
-    /// No mutable references may coexist with any of the returned references.
+    ///     No mutable references may coexist with any of the returned references.
     /// * This must be called on the same `World` that the `Query` was generated from:
-    /// use `QueryState::validate_world` to verify this.
+    ///     use `QueryState::validate_world` to verify this.
     pub(crate) unsafe fn get_many_read_only_manual<'w, const N: usize>(
         &self,
         world: UnsafeWorldCell<'w>,
diff --git a/crates/bevy_ecs/src/storage/blob_vec.rs b/crates/bevy_ecs/src/storage/blob_vec.rs
index 42bdd3fd4..5f6bbf12f 100644
--- a/crates/bevy_ecs/src/storage/blob_vec.rs
+++ b/crates/bevy_ecs/src/storage/blob_vec.rs
@@ -186,7 +186,7 @@ impl BlobVec {
     /// # Safety
     /// - index must be in bounds
     /// - the memory in the [`BlobVec`] starting at index `index`, of a size matching this [`BlobVec`]'s
-    /// `item_layout`, must have been previously allocated.
+    ///     `item_layout`, must have been previously allocated.
     #[inline]
     pub unsafe fn initialize_unchecked(&mut self, index: usize, value: OwningPtr<'_>) {
         debug_assert!(index < self.len());
@@ -199,10 +199,10 @@ impl BlobVec {
     /// # Safety
     /// - index must be in-bounds
     /// - the memory in the [`BlobVec`] starting at index `index`, of a size matching this
-    /// [`BlobVec`]'s `item_layout`, must have been previously initialized with an item matching
-    /// this [`BlobVec`]'s `item_layout`
+    ///     [`BlobVec`]'s `item_layout`, must have been previously initialized with an item matching
+    ///     this [`BlobVec`]'s `item_layout`
     /// - the memory at `*value` must also be previously initialized with an item matching this
-    /// [`BlobVec`]'s `item_layout`
+    ///     [`BlobVec`]'s `item_layout`
     pub unsafe fn replace_unchecked(&mut self, index: usize, value: OwningPtr<'_>) {
         debug_assert!(index < self.len());
 
diff --git a/crates/bevy_ecs/src/world/entity_ref.rs b/crates/bevy_ecs/src/world/entity_ref.rs
index 685166918..2d1073e0f 100644
--- a/crates/bevy_ecs/src/world/entity_ref.rs
+++ b/crates/bevy_ecs/src/world/entity_ref.rs
@@ -87,7 +87,7 @@ impl<'w> EntityRef<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    /// [`Self::contains_type_id`].
+    ///     [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.0.contains_id(component_id)
@@ -326,7 +326,7 @@ impl<'w> EntityMut<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    /// [`Self::contains_type_id`].
+    ///     [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.0.contains_id(component_id)
@@ -621,7 +621,7 @@ impl<'w> EntityWorldMut<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    /// [`Self::contains_type_id`].
+    ///     [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.as_unsafe_entity_cell_readonly()
@@ -1795,7 +1795,7 @@ impl<'w> FilteredEntityRef<'w> {
     /// # Safety
     /// - No `&mut World` can exist from the underlying `UnsafeWorldCell`
     /// - If `access` takes read access to a component no mutable reference to that
-    /// component can exist at the same time as the returned [`FilteredEntityMut`]
+    ///     component can exist at the same time as the returned [`FilteredEntityMut`]
     /// - If `access` takes any access for a component `entity` must have that component.
     pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: Access<ComponentId>) -> Self {
         Self { entity, access }
@@ -1851,7 +1851,7 @@ impl<'w> FilteredEntityRef<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    /// [`Self::contains_type_id`].
+    ///     [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.entity.contains_id(component_id)
@@ -2038,9 +2038,9 @@ impl<'w> FilteredEntityMut<'w> {
     /// # Safety
     /// - No `&mut World` can exist from the underlying `UnsafeWorldCell`
     /// - If `access` takes read access to a component no mutable reference to that
-    /// component can exist at the same time as the returned [`FilteredEntityMut`]
+    ///     component can exist at the same time as the returned [`FilteredEntityMut`]
     /// - If `access` takes write access to a component, no reference to that component
-    /// may exist at the same time as the returned [`FilteredEntityMut`]
+    ///     may exist at the same time as the returned [`FilteredEntityMut`]
     /// - If `access` takes any access for a component `entity` must have that component.
     pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: Access<ComponentId>) -> Self {
         Self { entity, access }
@@ -2108,7 +2108,7 @@ impl<'w> FilteredEntityMut<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    /// [`Self::contains_type_id`].
+    ///     [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.entity.contains_id(component_id)
@@ -2282,7 +2282,7 @@ pub enum TryFromFilteredError {
 /// # Safety
 ///
 /// - [`OwningPtr`] and [`StorageType`] iterators must correspond to the
-/// [`BundleInfo`] used to construct [`BundleInserter`]
+///     [`BundleInfo`] used to construct [`BundleInserter`]
 /// - [`Entity`] must correspond to [`EntityLocation`]
 unsafe fn insert_dynamic_bundle<
     'a,
diff --git a/crates/bevy_ecs/src/world/unsafe_world_cell.rs b/crates/bevy_ecs/src/world/unsafe_world_cell.rs
index 227846340..8de3d3af3 100644
--- a/crates/bevy_ecs/src/world/unsafe_world_cell.rs
+++ b/crates/bevy_ecs/src/world/unsafe_world_cell.rs
@@ -662,7 +662,7 @@ impl<'w> UnsafeEntityCell<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    /// [`Self::contains_type_id`].
+    ///     [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(self, component_id: ComponentId) -> bool {
         self.archetype().contains(component_id)
@@ -933,7 +933,7 @@ impl<'w> UnsafeWorldCell<'w> {
 ///
 /// # Safety
 /// - `location` must refer to an archetype that contains `entity`
-/// the archetype
+///     the archetype
 /// - `component_id` must be valid
 /// - `storage_type` must accurately reflect where the components for `component_id` are stored.
 /// - the caller must ensure that no aliasing rules are violated
@@ -994,7 +994,7 @@ unsafe fn get_component_and_ticks(
 ///
 /// # Safety
 /// - `location` must refer to an archetype that contains `entity`
-/// the archetype
+///     the archetype
 /// - `component_id` must be valid
 /// - `storage_type` must accurately reflect where the components for `component_id` are stored.
 /// - the caller must ensure that no aliasing rules are violated
diff --git a/crates/bevy_gizmos/src/arcs.rs b/crates/bevy_gizmos/src/arcs.rs
index 5505f667e..8c3957c44 100644
--- a/crates/bevy_gizmos/src/arcs.rs
+++ b/crates/bevy_gizmos/src/arcs.rs
@@ -23,7 +23,7 @@ where
     /// # Arguments
     /// - `position` sets the center of this circle.
     /// - `direction_angle` sets the counter-clockwise  angle in radians between `Vec2::Y` and
-    /// the vector from `position` to the midpoint of the arc.
+    ///     the vector from `position` to the midpoint of the arc.
     /// - `arc_angle` sets the length of this arc, in radians.
     /// - `radius` controls the distance from `position` to this arc, and thus its curvature.
     /// - `color` sets the color to draw the arc.
@@ -154,11 +154,11 @@ where
     ///
     /// # Arguments
     /// - `angle`: sets how much of a circle circumference is passed, e.g. PI is half a circle. This
-    /// value should be in the range (-2 * PI..=2 * PI)
+    ///     value should be in the range (-2 * PI..=2 * PI)
     /// - `radius`: distance between the arc and its center point
     /// - `position`: position of the arcs center point
     /// - `rotation`: defines orientation of the arc, by default we assume the arc is contained in a
-    /// plane parallel to the XZ plane and the default starting point is (`position + Vec3::X`)
+    ///     plane parallel to the XZ plane and the default starting point is (`position + Vec3::X`)
     /// - `color`: color of the arc
     ///
     /// # Builder methods
@@ -242,10 +242,10 @@ where
     ///
     /// # Notes
     /// - This method assumes that the points `from` and `to` are distinct from `center`. If one of
-    /// the points is coincident with `center`, nothing is rendered.
+    ///     the points is coincident with `center`, nothing is rendered.
     /// - The arc is drawn as a portion of a circle with a radius equal to the distance from the
-    /// `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
-    /// the results will behave as if this were the case
+    ///     `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
+    ///     the results will behave as if this were the case
     #[inline]
     pub fn short_arc_3d_between(
         &mut self,
@@ -289,10 +289,10 @@ where
     ///
     /// # Notes
     /// - This method assumes that the points `from` and `to` are distinct from `center`. If one of
-    /// the points is coincident with `center`, nothing is rendered.
+    ///     the points is coincident with `center`, nothing is rendered.
     /// - The arc is drawn as a portion of a circle with a radius equal to the distance from the
-    /// `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
-    /// the results will behave as if this were the case.
+    ///     `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
+    ///     the results will behave as if this were the case.
     #[inline]
     pub fn long_arc_3d_between(
         &mut self,
diff --git a/crates/bevy_gizmos/src/rounded_box.rs b/crates/bevy_gizmos/src/rounded_box.rs
index 679564b3b..976673974 100644
--- a/crates/bevy_gizmos/src/rounded_box.rs
+++ b/crates/bevy_gizmos/src/rounded_box.rs
@@ -222,7 +222,7 @@ impl<'w, 's, T: GizmoConfigGroup> Gizmos<'w, 's, T> {
     ///
     /// - The corner radius can be adjusted with the `.corner_radius(...)` method.
     /// - The resolution of the arcs at each corner (i.e. the level of detail) can be adjusted with the
-    /// `.arc_resolution(...)` method.
+    ///     `.arc_resolution(...)` method.
     ///
     /// # Example
     /// ```
@@ -278,7 +278,7 @@ impl<'w, 's, T: GizmoConfigGroup> Gizmos<'w, 's, T> {
     ///
     /// - The corner radius can be adjusted with the `.corner_radius(...)` method.
     /// - The resolution of the arcs at each corner (i.e. the level of detail) can be adjusted with the
-    /// `.arc_resolution(...)` method.
+    ///     `.arc_resolution(...)` method.
     ///
     /// # Example
     /// ```
@@ -334,7 +334,7 @@ impl<'w, 's, T: GizmoConfigGroup> Gizmos<'w, 's, T> {
     ///
     /// - The edge radius can be adjusted with the `.edge_radius(...)` method.
     /// - The resolution of the arcs at each edge (i.e. the level of detail) can be adjusted with the
-    /// `.arc_resolution(...)` method.
+    ///     `.arc_resolution(...)` method.
     ///
     /// # Example
     /// ```
diff --git a/crates/bevy_log/src/lib.rs b/crates/bevy_log/src/lib.rs
index 6e958eb61..0579a6ac6 100644
--- a/crates/bevy_log/src/lib.rs
+++ b/crates/bevy_log/src/lib.rs
@@ -66,11 +66,11 @@ pub(crate) struct FlushGuard(SyncCell<tracing_chrome::FlushGuard>);
 /// Adds logging to Apps. This plugin is part of the `DefaultPlugins`. Adding
 /// this plugin will setup a collector appropriate to your target platform:
 /// * Using [`tracing-subscriber`](https://crates.io/crates/tracing-subscriber) by default,
-/// logging to `stdout`.
+///     logging to `stdout`.
 /// * Using [`android_log-sys`](https://crates.io/crates/android_log-sys) on Android,
-/// logging to Android logs.
+///     logging to Android logs.
 /// * Using [`tracing-wasm`](https://crates.io/crates/tracing-wasm) in WASM, logging
-/// to the browser console.
+///     to the browser console.
 ///
 /// You can configure this plugin.
 /// ```no_run
diff --git a/crates/bevy_pbr/src/fog.rs b/crates/bevy_pbr/src/fog.rs
index 556778327..894ced95a 100644
--- a/crates/bevy_pbr/src/fog.rs
+++ b/crates/bevy_pbr/src/fog.rs
@@ -144,11 +144,11 @@ pub enum FogFalloff {
     /// ## Tips
     ///
     /// - Use the [`FogFalloff::from_visibility()`] convenience method to create an exponential falloff with the proper
-    /// density for a desired visibility distance in world units;
+    ///     density for a desired visibility distance in world units;
     /// - It's not _unusual_ to have very large or very small values for the density, depending on the scene
-    /// scale. Typically, for scenes with objects in the scale of thousands of units, you might want density values
-    /// in the ballpark of `0.001`. Conversely, for really small scale scenes you might want really high values of
-    /// density;
+    ///     scale. Typically, for scenes with objects in the scale of thousands of units, you might want density values
+    ///     in the ballpark of `0.001`. Conversely, for really small scale scenes you might want really high values of
+    ///     density;
     /// - Combine the `density` parameter with the [`FogSettings`] `color`'s alpha channel for easier artistic control.
     ///
     /// ## Formula
@@ -196,7 +196,7 @@ pub enum FogFalloff {
     /// ## Tips
     ///
     /// - Use the [`FogFalloff::from_visibility_squared()`] convenience method to create an exponential squared falloff
-    /// with the proper density for a desired visibility distance in world units;
+    ///     with the proper density for a desired visibility distance in world units;
     /// - Combine the `density` parameter with the [`FogSettings`] `color`'s alpha channel for easier artistic control.
     ///
     /// ## Formula
@@ -242,8 +242,8 @@ pub enum FogFalloff {
     /// ## Tips
     ///
     /// - Use the [`FogFalloff::from_visibility_colors()`] or [`FogFalloff::from_visibility_color()`] convenience methods
-    /// to create an atmospheric falloff with the proper densities for a desired visibility distance in world units and
-    /// extinction and inscattering colors;
+    ///     to create an atmospheric falloff with the proper densities for a desired visibility distance in world units and
+    ///     extinction and inscattering colors;
     /// - Combine the atmospheric fog parameters with the [`FogSettings`] `color`'s alpha channel for easier artistic control.
     ///
     /// ## Formula
diff --git a/crates/bevy_pbr/src/light_probe/irradiance_volume.rs b/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
index 978d34ee2..618da04fa 100644
--- a/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
+++ b/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
@@ -81,17 +81,17 @@
 //! less ideal for this use case:
 //!
 //! 1. The level 1 spherical harmonic coefficients can be negative. That
-//! prevents the use of the efficient [RGB9E5 texture format], which only
-//! encodes unsigned floating point numbers, and forces the use of the
-//! less-efficient [RGBA16F format] if hardware interpolation is desired.
+//!     prevents the use of the efficient [RGB9E5 texture format], which only
+//!     encodes unsigned floating point numbers, and forces the use of the
+//!     less-efficient [RGBA16F format] if hardware interpolation is desired.
 //!
 //! 2. As an alternative to RGBA16F, level 1 spherical harmonics can be
-//! normalized and scaled to the SH0 base color, as [Frostbite] does. This
-//! allows them to be packed in standard LDR RGBA8 textures. However, this
-//! prevents the use of hardware trilinear filtering, as the nonuniform scale
-//! factor means that hardware interpolation no longer produces correct results.
-//! The 8 texture fetches needed to interpolate between voxels can be upwards of
-//! twice as slow as the hardware interpolation.
+//!     normalized and scaled to the SH0 base color, as [Frostbite] does. This
+//!     allows them to be packed in standard LDR RGBA8 textures. However, this
+//!     prevents the use of hardware trilinear filtering, as the nonuniform scale
+//!     factor means that hardware interpolation no longer produces correct results.
+//!     The 8 texture fetches needed to interpolate between voxels can be upwards of
+//!     twice as slow as the hardware interpolation.
 //!
 //! The following chart summarizes the costs and benefits of ambient cubes,
 //! level 1 spherical harmonics, and level 2 spherical harmonics:
diff --git a/crates/bevy_pbr/src/light_probe/mod.rs b/crates/bevy_pbr/src/light_probe/mod.rs
index 97607d34a..18a4718a1 100644
--- a/crates/bevy_pbr/src/light_probe/mod.rs
+++ b/crates/bevy_pbr/src/light_probe/mod.rs
@@ -657,21 +657,21 @@ pub(crate) fn add_cubemap_texture_view<'a>(
 /// (a.k.a. bindless textures). This function checks for these pitfalls:
 ///
 /// 1. If GLSL support is enabled at the feature level, then in debug mode
-/// `naga_oil` will attempt to compile all shader modules under GLSL to check
-/// validity of names, even if GLSL isn't actually used. This will cause a crash
-/// if binding arrays are enabled, because binding arrays are currently
-/// unimplemented in the GLSL backend of Naga. Therefore, we disable binding
-/// arrays if the `shader_format_glsl` feature is present.
+///     `naga_oil` will attempt to compile all shader modules under GLSL to check
+///     validity of names, even if GLSL isn't actually used. This will cause a crash
+///     if binding arrays are enabled, because binding arrays are currently
+///     unimplemented in the GLSL backend of Naga. Therefore, we disable binding
+///     arrays if the `shader_format_glsl` feature is present.
 ///
 /// 2. If there aren't enough texture bindings available to accommodate all the
-/// binding arrays, the driver will panic. So we also bail out if there aren't
-/// enough texture bindings available in the fragment shader.
+///     binding arrays, the driver will panic. So we also bail out if there aren't
+///     enough texture bindings available in the fragment shader.
 ///
 /// 3. If binding arrays aren't supported on the hardware, then we obviously
-/// can't use them.
+///     can't use them.
 ///
 /// 4. If binding arrays are supported on the hardware, but they can only be
-/// accessed by uniform indices, that's not good enough, and we bail out.
+///     accessed by uniform indices, that's not good enough, and we bail out.
 ///
 /// If binding arrays aren't usable, we disable reflection probes and limit the
 /// number of irradiance volumes in the scene to 1.
diff --git a/crates/bevy_pbr/src/meshlet/mod.rs b/crates/bevy_pbr/src/meshlet/mod.rs
index 5176087d4..e9681dd4d 100644
--- a/crates/bevy_pbr/src/meshlet/mod.rs
+++ b/crates/bevy_pbr/src/meshlet/mod.rs
@@ -96,7 +96,7 @@ const MESHLET_MESH_MATERIAL_SHADER_HANDLE: Handle<Shader> =
 ///
 /// In comparison to Bevy's standard renderer:
 /// * Much more efficient culling. Meshlets can be culled individually, instead of all or nothing culling for entire meshes at a time.
-/// Additionally, occlusion culling can eliminate meshlets that would cause overdraw.
+///     Additionally, occlusion culling can eliminate meshlets that would cause overdraw.
 /// * Much more efficient batching. All geometry can be rasterized in a single indirect draw.
 /// * Scales better with large amounts of dense geometry and overdraw. Bevy's standard renderer will bottleneck sooner.
 /// * Near-seamless level of detail (LOD).
diff --git a/crates/bevy_pbr/src/pbr_material.rs b/crates/bevy_pbr/src/pbr_material.rs
index 852ba9f7b..1292fca5a 100644
--- a/crates/bevy_pbr/src/pbr_material.rs
+++ b/crates/bevy_pbr/src/pbr_material.rs
@@ -235,13 +235,13 @@ pub struct StandardMaterial {
     /// with distortion and blur effects.
     ///
     /// - [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) can be used to enable transmissive objects
-    /// to be seen through other transmissive objects, at the cost of additional draw calls and texture copies; (Use with caution!)
+    ///     to be seen through other transmissive objects, at the cost of additional draw calls and texture copies; (Use with caution!)
     ///     - If a simplified approximation of specular transmission using only environment map lighting is sufficient, consider setting
-    /// [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) to `0`.
+    ///         [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) to `0`.
     /// - If purely diffuse light transmission is needed, (i.e. “translucency”) consider using [`StandardMaterial::diffuse_transmission`] instead,
-    /// for a much less expensive effect.
+    ///     for a much less expensive effect.
     /// - Specular transmission is rendered before alpha blending, so any material with [`AlphaMode::Blend`], [`AlphaMode::Premultiplied`], [`AlphaMode::Add`] or [`AlphaMode::Multiply`]
-    ///   won't be visible through specular transmissive materials.
+    ///     won't be visible through specular transmissive materials.
     #[doc(alias = "refraction")]
     pub specular_transmission: f32,
 
diff --git a/crates/bevy_reflect/src/lib.rs b/crates/bevy_reflect/src/lib.rs
index 29b73c598..2d84fc63c 100644
--- a/crates/bevy_reflect/src/lib.rs
+++ b/crates/bevy_reflect/src/lib.rs
@@ -61,7 +61,7 @@
 //!
 //! Additionally, using the derive macro on enums requires a third condition to be met:
 //! * All fields and sub-elements must implement [`FromReflect`]—
-//! another important reflection trait discussed in a later section.
+//!     another important reflection trait discussed in a later section.
 //!
 //! # The `Reflect` Subtraits
 //!
diff --git a/crates/bevy_render/src/batching/gpu_preprocessing.rs b/crates/bevy_render/src/batching/gpu_preprocessing.rs
index 62cb9d8c8..dcb396a84 100644
--- a/crates/bevy_render/src/batching/gpu_preprocessing.rs
+++ b/crates/bevy_render/src/batching/gpu_preprocessing.rs
@@ -163,14 +163,14 @@ pub struct PreprocessWorkItem {
 /// that, we make the following two observations:
 ///
 /// 1. `instance_count` is in the same place in both structures. So we can
-/// access it regardless of the structure we're looking at.
+///     access it regardless of the structure we're looking at.
 ///
 /// 2. The second structure is one word larger than the first. Thus we need to
-/// pad out the first structure by one word in order to place both structures in
-/// an array. If we pad out `ArrayIndirectParameters` by copying the
-/// `first_instance` field into the padding, then the resulting union structure
-/// will always have a read-only copy of `first_instance` in the final word. We
-/// take advantage of this in the shader to reduce branching.
+///     pad out the first structure by one word in order to place both structures in
+///     an array. If we pad out `ArrayIndirectParameters` by copying the
+///     `first_instance` field into the padding, then the resulting union structure
+///     will always have a read-only copy of `first_instance` in the final word. We
+///     take advantage of this in the shader to reduce branching.
 #[derive(Clone, Copy, Pod, Zeroable, ShaderType)]
 #[repr(C)]
 pub struct IndirectParameters {
diff --git a/crates/bevy_render/src/camera/camera.rs b/crates/bevy_render/src/camera/camera.rs
index 97b94e276..4e5f577b8 100644
--- a/crates/bevy_render/src/camera/camera.rs
+++ b/crates/bevy_render/src/camera/camera.rs
@@ -353,7 +353,7 @@ impl Camera {
     /// - The computed coordinates are beyond the near or far plane
     /// - The logical viewport size cannot be computed. See [`logical_viewport_size`](Camera::logical_viewport_size)
     /// - The world coordinates cannot be mapped to the Normalized Device Coordinates. See [`world_to_ndc`](Camera::world_to_ndc)
-    /// May also panic if `glam_assert` is enabled. See [`world_to_ndc`](Camera::world_to_ndc).
+    ///     May also panic if `glam_assert` is enabled. See [`world_to_ndc`](Camera::world_to_ndc).
     #[doc(alias = "world_to_screen")]
     pub fn world_to_viewport(
         &self,
@@ -386,7 +386,7 @@ impl Camera {
     /// Returns `None` if any of these conditions occur:
     /// - The logical viewport size cannot be computed. See [`logical_viewport_size`](Camera::logical_viewport_size)
     /// - The near or far plane cannot be computed. This can happen if the `camera_transform`, the `world_position`, or the projection matrix defined by [`CameraProjection`] contain `NAN`.
-    /// Panics if the projection matrix is null and `glam_assert` is enabled.
+    ///     Panics if the projection matrix is null and `glam_assert` is enabled.
     pub fn viewport_to_world(
         &self,
         camera_transform: &GlobalTransform,
@@ -422,7 +422,7 @@ impl Camera {
     /// Returns `None` if any of these conditions occur:
     /// - The logical viewport size cannot be computed. See [`logical_viewport_size`](Camera::logical_viewport_size)
     /// - The viewport position cannot be mapped to the world. See [`ndc_to_world`](Camera::ndc_to_world)
-    /// May panic. See [`ndc_to_world`](Camera::ndc_to_world).
+    ///     May panic. See [`ndc_to_world`](Camera::ndc_to_world).
     pub fn viewport_to_world_2d(
         &self,
         camera_transform: &GlobalTransform,
diff --git a/crates/bevy_render/src/mesh/mesh/mod.rs b/crates/bevy_render/src/mesh/mesh/mod.rs
index 14bb05102..f8b0efe15 100644
--- a/crates/bevy_render/src/mesh/mesh/mod.rs
+++ b/crates/bevy_render/src/mesh/mesh/mod.rs
@@ -100,25 +100,25 @@ pub const VERTEX_ATTRIBUTE_BUFFER_ID: u64 = 10;
 /// ## Common points of confusion
 ///
 /// - UV maps in Bevy start at the top-left, see [`ATTRIBUTE_UV_0`](Mesh::ATTRIBUTE_UV_0),
-/// other APIs can have other conventions, `OpenGL` starts at bottom-left.
+///     other APIs can have other conventions, `OpenGL` starts at bottom-left.
 /// - It is possible and sometimes useful for multiple vertices to have the same
-/// [position attribute](Mesh::ATTRIBUTE_POSITION) value,
-/// it's a common technique in 3D modelling for complex UV mapping or other calculations.
+///     [position attribute](Mesh::ATTRIBUTE_POSITION) value,
+///     it's a common technique in 3D modelling for complex UV mapping or other calculations.
 /// - Bevy performs frustum culling based on the [`Aabb`] of meshes, which is calculated
-/// and added automatically for new meshes only. If a mesh is modified, the entity's [`Aabb`]
-/// needs to be updated manually or deleted so that it is re-calculated.
+///     and added automatically for new meshes only. If a mesh is modified, the entity's [`Aabb`]
+///     needs to be updated manually or deleted so that it is re-calculated.
 ///
 /// ## Use with `StandardMaterial`
 ///
 /// To render correctly with `StandardMaterial`, a mesh needs to have properly defined:
 /// - [`UVs`](Mesh::ATTRIBUTE_UV_0): Bevy needs to know how to map a texture onto the mesh
-/// (also true for `ColorMaterial`).
+///     (also true for `ColorMaterial`).
 /// - [`Normals`](Mesh::ATTRIBUTE_NORMAL): Bevy needs to know how light interacts with your mesh.
-/// [0.0, 0.0, 1.0] is very common for simple flat meshes on the XY plane,
-/// because simple meshes are smooth and they don't require complex light calculations.
+///     [0.0, 0.0, 1.0] is very common for simple flat meshes on the XY plane,
+///     because simple meshes are smooth and they don't require complex light calculations.
 /// - Vertex winding order: by default, `StandardMaterial.cull_mode` is [`Some(Face::Back)`](crate::render_resource::Face),
-/// which means that Bevy would *only* render the "front" of each triangle, which
-/// is the side of the triangle from where the vertices appear in a *counter-clockwise* order.
+///     which means that Bevy would *only* render the "front" of each triangle, which
+///     is the side of the triangle from where the vertices appear in a *counter-clockwise* order.
 #[derive(Asset, Debug, Clone, Reflect)]
 pub struct Mesh {
     #[reflect(ignore)]
diff --git a/crates/bevy_render/src/pipelined_rendering.rs b/crates/bevy_render/src/pipelined_rendering.rs
index d0f31ad60..b0db03989 100644
--- a/crates/bevy_render/src/pipelined_rendering.rs
+++ b/crates/bevy_render/src/pipelined_rendering.rs
@@ -91,12 +91,12 @@ impl Drop for RenderAppChannels {
 /// ```
 ///
 /// - `extract` is the step where data is copied from the main world to the render world.
-/// This is run on the main app's thread.
+///     This is run on the main app's thread.
 /// - On the render thread, we first apply the `extract commands`. This is not run during extract, so the
-/// main schedule can start sooner.
+///     main schedule can start sooner.
 /// - Then the `rendering schedule` is run. See [`RenderSet`](crate::RenderSet) for the standard steps in this process.
 /// - In parallel to the rendering thread the [`RenderExtractApp`] schedule runs. By
-/// default this schedule is empty. But it is useful if you need something to run before I/O processing.
+///     default, this schedule is empty. But it is useful if you need something to run before I/O processing.
 /// - Next all the `winit events` are processed.
 /// - And finally the `main app schedule` is run.
 /// - Once both the `main app schedule` and the `render schedule` are finished running, `extract` is run again.
diff --git a/crates/bevy_render/src/primitives/mod.rs b/crates/bevy_render/src/primitives/mod.rs
index bc09aefb0..89478063d 100644
--- a/crates/bevy_render/src/primitives/mod.rs
+++ b/crates/bevy_render/src/primitives/mod.rs
@@ -7,7 +7,7 @@ use bevy_reflect::prelude::*;
 /// An axis-aligned bounding box, defined by:
 /// - a center,
 /// - the distances from the center to each faces along the axis,
-/// the faces are orthogonal to the axis.
+///     the faces are orthogonal to the axis.
 ///
 /// It is typically used as a component on an entity to represent the local space
 /// occupied by this entity, with faces orthogonal to its local axis.
@@ -18,7 +18,7 @@ use bevy_reflect::prelude::*;
 ///
 /// It will be added automatically by the systems in [`CalculateBounds`] to entities that:
 /// - could be subject to frustum culling, for example with a [`Handle<Mesh>`]
-/// or `Sprite` component,
+///     or `Sprite` component,
 /// - don't have the [`NoFrustumCulling`] component.
 ///
 /// It won't be updated automatically if the space occupied by the entity changes,
diff --git a/crates/bevy_render/src/render_phase/mod.rs b/crates/bevy_render/src/render_phase/mod.rs
index 36ec549e0..f431074d0 100644
--- a/crates/bevy_render/src/render_phase/mod.rs
+++ b/crates/bevy_render/src/render_phase/mod.rs
@@ -718,15 +718,15 @@ where
 /// [`SortedPhaseItem`]s.
 ///
 /// * Binned phase items have a `BinKey` which specifies what bin they're to be
-/// placed in. All items in the same bin are eligible to be batched together.
-/// The `BinKey`s are sorted, but the individual bin items aren't. Binned phase
-/// items are good for opaque meshes, in which the order of rendering isn't
-/// important. Generally, binned phase items are faster than sorted phase items.
+///     placed in. All items in the same bin are eligible to be batched together.
+///     The `BinKey`s are sorted, but the individual bin items aren't. Binned phase
+///     items are good for opaque meshes, in which the order of rendering isn't
+///     important. Generally, binned phase items are faster than sorted phase items.
 ///
 /// * Sorted phase items, on the other hand, are placed into one large buffer
-/// and then sorted all at once. This is needed for transparent meshes, which
-/// have to be sorted back-to-front to render with the painter's algorithm.
-/// These types of phase items are generally slower than binned phase items.
+///     and then sorted all at once. This is needed for transparent meshes, which
+///     have to be sorted back-to-front to render with the painter's algorithm.
+///     These types of phase items are generally slower than binned phase items.
 pub trait PhaseItem: Sized + Send + Sync + 'static {
     /// Whether or not this `PhaseItem` should be subjected to automatic batching. (Default: `true`)
     const AUTOMATIC_BATCHING: bool = true;
@@ -764,12 +764,12 @@ pub trait PhaseItem: Sized + Send + Sync + 'static {
 /// instances they already have. These can be:
 ///
 /// * The *dynamic offset*: a `wgpu` dynamic offset into the uniform buffer of
-/// instance data. This is used on platforms that don't support storage
-/// buffers, to work around uniform buffer size limitations.
+///     instance data. This is used on platforms that don't support storage
+///     buffers, to work around uniform buffer size limitations.
 ///
 /// * The *indirect parameters index*: an index into the buffer that specifies
-/// the indirect parameters for this [`PhaseItem`]'s drawcall. This is used when
-/// indirect mode is on (as used for GPU culling).
+///     the indirect parameters for this [`PhaseItem`]'s drawcall. This is used when
+///     indirect mode is on (as used for GPU culling).
 ///
 /// Note that our indirect draw functionality requires storage buffers, so it's
 /// impossible to have both a dynamic offset and an indirect parameters index.
diff --git a/crates/bevy_render/src/render_resource/bind_group.rs b/crates/bevy_render/src/render_resource/bind_group.rs
index ff61060ce..39704525b 100644
--- a/crates/bevy_render/src/render_resource/bind_group.rs
+++ b/crates/bevy_render/src/render_resource/bind_group.rs
@@ -108,15 +108,15 @@ impl Deref for BindGroup {
 ///
 /// * `uniform(BINDING_INDEX)`
 ///     * The field will be converted to a shader-compatible type using the [`ShaderType`] trait, written to a [`Buffer`], and bound as a uniform.
-///     [`ShaderType`] is implemented for most math types already, such as [`f32`], [`Vec4`](bevy_math::Vec4), and
-///   [`LinearRgba`](bevy_color::LinearRgba). It can also be derived for custom structs.
+///         [`ShaderType`] is implemented for most math types already, such as [`f32`], [`Vec4`](bevy_math::Vec4), and
+///         [`LinearRgba`](bevy_color::LinearRgba). It can also be derived for custom structs.
 ///
 /// * `texture(BINDING_INDEX, arguments)`
 ///     * This field's [`Handle<Image>`](bevy_asset::Handle) will be used to look up the matching [`Texture`](crate::render_resource::Texture)
-///     GPU resource, which will be bound as a texture in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
-///     most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
-///     [`None`], the [`FallbackImage`] resource will be used instead. This attribute can be used in conjunction with a `sampler` binding attribute
-///    (with a different binding index) if a binding of the sampler for the [`Image`](crate::texture::Image) is also required.
+///         GPU resource, which will be bound as a texture in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
+///         most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
+///         [`None`], the [`FallbackImage`] resource will be used instead. This attribute can be used in conjunction with a `sampler` binding attribute
+///         (with a different binding index) if a binding of the sampler for the [`Image`](crate::texture::Image) is also required.
 ///
 /// | Arguments             | Values                                                                  | Default              |
 /// |-----------------------|-------------------------------------------------------------------------|----------------------|
@@ -128,9 +128,9 @@ impl Deref for BindGroup {
 ///
 /// * `storage_texture(BINDING_INDEX, arguments)`
 ///     * This field's [`Handle<Image>`](bevy_asset::Handle) will be used to look up the matching [`Texture`](crate::render_resource::Texture)
-///     GPU resource, which will be bound as a storage texture in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
-///     most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
-///     [`None`], the [`FallbackImage`] resource will be used instead.
+///         GPU resource, which will be bound as a storage texture in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
+///         most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
+///         [`None`], the [`FallbackImage`] resource will be used instead.
 ///
 /// | Arguments              | Values                                                                                     | Default       |
 /// |------------------------|--------------------------------------------------------------------------------------------|---------------|
@@ -141,10 +141,10 @@ impl Deref for BindGroup {
 ///
 /// * `sampler(BINDING_INDEX, arguments)`
 ///     * This field's [`Handle<Image>`](bevy_asset::Handle) will be used to look up the matching [`Sampler`] GPU
-///     resource, which will be bound as a sampler in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
-///     most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
-///     [`None`], the [`FallbackImage`] resource will be used instead. This attribute can be used in conjunction with a `texture` binding attribute
-///     (with a different binding index) if a binding of the texture for the [`Image`](crate::texture::Image) is also required.
+///         resource, which will be bound as a sampler in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
+///         most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
+///         [`None`], the [`FallbackImage`] resource will be used instead. This attribute can be used in conjunction with a `texture` binding attribute
+///         (with a different binding index) if a binding of the texture for the [`Image`](crate::texture::Image) is also required.
 ///
 /// | Arguments              | Values                                                                  | Default                |
 /// |------------------------|-------------------------------------------------------------------------|------------------------|
@@ -216,16 +216,16 @@ impl Deref for BindGroup {
 /// Some less common scenarios will require "struct-level" attributes. These are the currently supported struct-level attributes:
 /// * `uniform(BINDING_INDEX, ConvertedShaderType)`
 ///     * This also creates a [`Buffer`] using [`ShaderType`] and binds it as a uniform, much
-///     much like the field-level `uniform` attribute. The difference is that the entire [`AsBindGroup`] value is converted to `ConvertedShaderType`,
-///     which must implement [`ShaderType`], instead of a specific field implementing [`ShaderType`]. This is useful if more complicated conversion
-///     logic is required. The conversion is done using the [`AsBindGroupShaderType<ConvertedShaderType>`] trait, which is automatically implemented
-///     if `&Self` implements [`Into<ConvertedShaderType>`]. Only use [`AsBindGroupShaderType`] if access to resources like [`RenderAssets<GpuImage>`] is
-///     required.
+///         like the field-level `uniform` attribute. The difference is that the entire [`AsBindGroup`] value is converted to `ConvertedShaderType`,
+///         which must implement [`ShaderType`], instead of a specific field implementing [`ShaderType`]. This is useful if more complicated conversion
+///         logic is required. The conversion is done using the [`AsBindGroupShaderType<ConvertedShaderType>`] trait, which is automatically implemented
+///         if `&Self` implements [`Into<ConvertedShaderType>`]. Only use [`AsBindGroupShaderType`] if access to resources like [`RenderAssets<GpuImage>`] is
+///         required.
 /// * `bind_group_data(DataType)`
 ///     * The [`AsBindGroup`] type will be converted to some `DataType` using [`Into<DataType>`] and stored
-///     as [`AsBindGroup::Data`] as part of the [`AsBindGroup::as_bind_group`] call. This is useful if data needs to be stored alongside
-///     the generated bind group, such as a unique identifier for a material's bind group. The most common use case for this attribute
-///     is "shader pipeline specialization". See [`SpecializedRenderPipeline`](crate::render_resource::SpecializedRenderPipeline).
+///         as [`AsBindGroup::Data`] as part of the [`AsBindGroup::as_bind_group`] call. This is useful if data needs to be stored alongside
+///         the generated bind group, such as a unique identifier for a material's bind group. The most common use case for this attribute
+///         is "shader pipeline specialization". See [`SpecializedRenderPipeline`](crate::render_resource::SpecializedRenderPipeline).
 ///
 /// The previous `CoolMaterial` example illustrating "combining multiple field-level uniform attributes with the same binding index" can
 /// also be equivalently represented with a single struct-level uniform attribute:
diff --git a/crates/bevy_render/src/view/visibility/mod.rs b/crates/bevy_render/src/view/visibility/mod.rs
index d8f85ad24..ea7749fa9 100644
--- a/crates/bevy_render/src/view/visibility/mod.rs
+++ b/crates/bevy_render/src/view/visibility/mod.rs
@@ -155,7 +155,7 @@ pub struct VisibilityBundle {
 /// It can be used for example:
 /// - when a [`Mesh`] is updated but its [`Aabb`] is not, which might happen with animations,
 /// - when using some light effects, like wanting a [`Mesh`] out of the [`Frustum`]
-/// to appear in the reflection of a [`Mesh`] within.
+///     to appear in the reflection of a [`Mesh`] within.
 #[derive(Debug, Component, Default, Reflect)]
 #[reflect(Component, Default)]
 pub struct NoFrustumCulling;
diff --git a/crates/bevy_scene/src/dynamic_scene.rs b/crates/bevy_scene/src/dynamic_scene.rs
index 97e228443..992d7ef62 100644
--- a/crates/bevy_scene/src/dynamic_scene.rs
+++ b/crates/bevy_scene/src/dynamic_scene.rs
@@ -22,8 +22,8 @@ use serde::Serialize;
 /// * [`SceneSpawner::spawn_dynamic`](crate::SceneSpawner::spawn_dynamic)
 /// * adding the [`DynamicSceneBundle`](crate::DynamicSceneBundle) to an entity
 /// * adding the [`Handle<DynamicScene>`](bevy_asset::Handle) to an entity (the scene will only be
-/// visible if the entity already has [`Transform`](bevy_transform::components::Transform) and
-/// [`GlobalTransform`](bevy_transform::components::GlobalTransform) components)
+///     visible if the entity already has [`Transform`](bevy_transform::components::Transform) and
+///     [`GlobalTransform`](bevy_transform::components::GlobalTransform) components)
 /// * using the [`DynamicSceneBuilder`] to construct a `DynamicScene` from `World`.
 #[derive(Asset, TypePath, Default)]
 pub struct DynamicScene {
diff --git a/crates/bevy_scene/src/scene.rs b/crates/bevy_scene/src/scene.rs
index 0bbe86732..542a22c5d 100644
--- a/crates/bevy_scene/src/scene.rs
+++ b/crates/bevy_scene/src/scene.rs
@@ -11,8 +11,8 @@ use bevy_reflect::TypePath;
 /// * [`SceneSpawner::spawn`](crate::SceneSpawner::spawn)
 /// * adding the [`SceneBundle`](crate::SceneBundle) to an entity
 /// * adding the [`Handle<Scene>`](bevy_asset::Handle) to an entity (the scene will only be
-/// visible if the entity already has [`Transform`](bevy_transform::components::Transform) and
-/// [`GlobalTransform`](bevy_transform::components::GlobalTransform) components)
+///     visible if the entity already has [`Transform`](bevy_transform::components::Transform) and
+///     [`GlobalTransform`](bevy_transform::components::GlobalTransform) components)
 #[derive(Asset, TypePath, Debug)]
 pub struct Scene {
     /// The world of the scene, containing its entities and resources.
diff --git a/crates/bevy_sprite/src/lib.rs b/crates/bevy_sprite/src/lib.rs
index ecb1ce78c..8b8a74257 100644
--- a/crates/bevy_sprite/src/lib.rs
+++ b/crates/bevy_sprite/src/lib.rs
@@ -171,7 +171,7 @@ impl Plugin for SpritePlugin {
 /// System calculating and inserting an [`Aabb`] component to entities with either:
 /// - a `Mesh2dHandle` component,
 /// - a `Sprite` and `Handle<Image>` components,
-/// and without a [`NoFrustumCulling`] component.
+///     and without a [`NoFrustumCulling`] component.
 ///
 /// Used in system set [`VisibilitySystems::CalculateBounds`].
 pub fn calculate_bounds_2d(
diff --git a/crates/bevy_sprite/src/texture_slice/computed_slices.rs b/crates/bevy_sprite/src/texture_slice/computed_slices.rs
index c15fd264d..c49987e1b 100644
--- a/crates/bevy_sprite/src/texture_slice/computed_slices.rs
+++ b/crates/bevy_sprite/src/texture_slice/computed_slices.rs
@@ -82,7 +82,7 @@ impl ComputedTextureSlices {
 /// * `image_handle` - The texture to slice or tile
 /// * `images` - The image assets, use to retrieve the image dimensions
 /// * `atlas` - Optional texture atlas, if set the slicing will happen on the matching sub section
-/// of the texture
+///     of the texture
 /// * `atlas_layouts` - The atlas layout assets, used to retrieve the texture atlas section rect
 #[must_use]
 fn compute_sprite_slices(
diff --git a/crates/bevy_sprite/src/texture_slice/mod.rs b/crates/bevy_sprite/src/texture_slice/mod.rs
index 516f025ca..4cb6f3e2d 100644
--- a/crates/bevy_sprite/src/texture_slice/mod.rs
+++ b/crates/bevy_sprite/src/texture_slice/mod.rs
@@ -27,9 +27,9 @@ impl TextureSlice {
     /// # Arguments
     ///
     /// * `stretch_value` - The slice will repeat when the ratio between the *drawing dimensions* of texture and the
-    /// *original texture size* (rect) are above `stretch_value`.
-    /// - `tile_x` - should the slice be tiled horizontally
-    /// - `tile_y` - should the slice be tiled vertically
+    ///     *original texture size* (rect) are above `stretch_value`.
+    /// * `tile_x` - should the slice be tiled horizontally
+    /// * `tile_y` - should the slice be tiled vertically
     #[must_use]
     pub fn tiled(self, stretch_value: f32, (tile_x, tile_y): (bool, bool)) -> Vec<Self> {
         if !tile_x && !tile_y {
diff --git a/crates/bevy_text/src/text.rs b/crates/bevy_text/src/text.rs
index 15532e36c..5d1fce2d0 100644
--- a/crates/bevy_text/src/text.rs
+++ b/crates/bevy_text/src/text.rs
@@ -184,7 +184,7 @@ impl From<JustifyText> for glyph_brush_layout::HorizontalAlign {
 pub struct TextStyle {
     /// If this is not specified, then
     /// * if `default_font` feature is enabled (enabled by default in `bevy` crate),
-    ///  `FiraMono-subset.ttf` compiled into the library is used.
+    ///      `FiraMono-subset.ttf` compiled into the library is used.
     /// * otherwise no text will be rendered.
     pub font: Handle<Font>,
     /// The vertical height of rasterized glyphs in the font atlas in pixels.
diff --git a/crates/bevy_transform/src/components/transform.rs b/crates/bevy_transform/src/components/transform.rs
index f705b7124..a8cca9581 100644
--- a/crates/bevy_transform/src/components/transform.rs
+++ b/crates/bevy_transform/src/components/transform.rs
@@ -159,8 +159,8 @@ impl Transform {
     /// * if `main_axis` or `main_direction` fail converting to `Dir3` (e.g are zero), `Dir3::X` takes their place
     /// * if `secondary_axis` or `secondary_direction` fail converting, `Dir3::Y` takes their place
     /// * if `main_axis` is parallel with `secondary_axis` or `main_direction` is parallel with `secondary_direction`,
-    /// a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
-    /// counterparts
+    ///     a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
+    ///     counterparts
     ///
     /// See [`Transform::align`] for additional details.
     #[inline]
@@ -412,7 +412,7 @@ impl Transform {
     /// More precisely, the [`Transform::rotation`] produced will be such that:
     /// * applying it to `main_axis` results in `main_direction`
     /// * applying it to `secondary_axis` produces a vector that lies in the half-plane generated by `main_direction` and
-    /// `secondary_direction` (with positive contribution by `secondary_direction`)
+    ///     `secondary_direction` (with positive contribution by `secondary_direction`)
     ///
     /// [`Transform::look_to`] is recovered, for instance, when `main_axis` is `Dir3::NEG_Z` (the [`Transform::forward`]
     /// direction in the default orientation) and `secondary_axis` is `Dir3::Y` (the [`Transform::up`] direction in the default
@@ -422,8 +422,8 @@ impl Transform {
     /// * if `main_axis` or `main_direction` fail converting to `Dir3` (e.g are zero), `Dir3::X` takes their place
     /// * if `secondary_axis` or `secondary_direction` fail converting, `Dir3::Y` takes their place
     /// * if `main_axis` is parallel with `secondary_axis` or `main_direction` is parallel with `secondary_direction`,
-    /// a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
-    /// counterparts
+    ///     a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
+    ///     counterparts
     ///
     /// Example
     /// ```
diff --git a/crates/bevy_transform/src/systems.rs b/crates/bevy_transform/src/systems.rs
index 8ddba2478..442a49a32 100644
--- a/crates/bevy_transform/src/systems.rs
+++ b/crates/bevy_transform/src/systems.rs
@@ -104,9 +104,9 @@ pub fn propagate_transforms(
 /// # Safety
 ///
 /// - While this function is running, `transform_query` must not have any fetches for `entity`,
-/// nor any of its descendants.
+///     nor any of its descendants.
 /// - The caller must ensure that the hierarchy leading to `entity`
-/// is well-formed and must remain as a tree or a forest. Each entity must have at most one parent.
+///     is well-formed and must remain as a tree or a forest. Each entity must have at most one parent.
 #[allow(unsafe_code)]
 unsafe fn propagate_recursive(
     parent: &GlobalTransform,
diff --git a/crates/bevy_ui/src/texture_slice.rs b/crates/bevy_ui/src/texture_slice.rs
index 6712d53ad..f7e1a16ec 100644
--- a/crates/bevy_ui/src/texture_slice.rs
+++ b/crates/bevy_ui/src/texture_slice.rs
@@ -88,7 +88,7 @@ impl ComputedTextureSlices {
 /// * `image_handle` - The texture to slice or tile
 /// * `images` - The image assets, use to retrieve the image dimensions
 /// * `atlas` - Optional texture atlas, if set the slicing will happen on the matching sub section
-/// of the texture
+///     of the texture
 /// * `atlas_layouts` - The atlas layout assets, used to retrieve the texture atlas section rect
 #[must_use]
 fn compute_texture_slices(
diff --git a/crates/bevy_ui/src/widget/text.rs b/crates/bevy_ui/src/widget/text.rs
index 2fd25552d..40d08da15 100644
--- a/crates/bevy_ui/src/widget/text.rs
+++ b/crates/bevy_ui/src/widget/text.rs
@@ -117,9 +117,9 @@ fn create_text_measure(
 ///
 /// * Measures are regenerated if the target camera's scale factor (or primary window if no specific target) or [`UiScale`] is changed.
 /// * Changes that only modify the colors of a `Text` do not require a new `Measure`. This system
-/// is only able to detect that a `Text` component has changed and will regenerate the `Measure` on
-/// color changes. This can be expensive, particularly for large blocks of text, and the [`bypass_change_detection`](bevy_ecs::change_detection::DetectChangesMut::bypass_change_detection)
-/// method should be called when only changing the `Text`'s colors.
+///     is only able to detect that a `Text` component has changed and will regenerate the `Measure` on
+///     color changes. This can be expensive, particularly for large blocks of text, and the [`bypass_change_detection`](bevy_ecs::change_detection::DetectChangesMut::bypass_change_detection)
+///     method should be called when only changing the `Text`'s colors.
 pub fn measure_text_system(
     mut last_scale_factors: Local<EntityHashMap<f32>>,
     fonts: Res<Assets<Font>>,
diff --git a/crates/bevy_window/src/window.rs b/crates/bevy_window/src/window.rs
index 9ce2658f0..934983f3e 100644
--- a/crates/bevy_window/src/window.rs
+++ b/crates/bevy_window/src/window.rs
@@ -558,7 +558,7 @@ pub struct Cursor {
     /// ## Platform-specific
     ///
     /// - **`Windows`**, **`X11`**, and **`Wayland`**: The cursor is hidden only when inside the window.
-    /// To stop the cursor from leaving the window, change [`Cursor::grab_mode`] to [`CursorGrabMode::Locked`] or [`CursorGrabMode::Confined`]
+    ///     To stop the cursor from leaving the window, change [`Cursor::grab_mode`] to [`CursorGrabMode::Locked`] or [`CursorGrabMode::Confined`]
     /// - **`macOS`**: The cursor is hidden only when the window is focused.
     /// - **`iOS`** and **`Android`** do not have cursors
     pub visible: bool,
@@ -643,14 +643,14 @@ impl WindowPosition {
 ///
 /// There are three sizes associated with a window:
 /// - the physical size,
-/// which represents the actual height and width in physical pixels
-/// the window occupies on the monitor,
+///     which represents the actual height and width in physical pixels
+///     the window occupies on the monitor,
 /// - the logical size,
-/// which represents the size that should be used to scale elements
-/// inside the window, measured in logical pixels,
+///     which represents the size that should be used to scale elements
+///     inside the window, measured in logical pixels,
 /// - the requested size,
-/// measured in logical pixels, which is the value submitted
-/// to the API when creating the window, or requesting that it be resized.
+///     measured in logical pixels, which is the value submitted
+///     to the API when creating the window, or requesting that it be resized.
 ///
 /// ## Scale factor
 ///
diff --git a/crates/bevy_winit/src/winit_config.rs b/crates/bevy_winit/src/winit_config.rs
index 663281444..54efb4ee1 100644
--- a/crates/bevy_winit/src/winit_config.rs
+++ b/crates/bevy_winit/src/winit_config.rs
@@ -67,7 +67,7 @@ pub enum UpdateMode {
     /// - `wait` time has elapsed since the previous update
     /// - a redraw has been requested by [`RequestRedraw`](bevy_window::RequestRedraw)
     /// - new [window](`winit::event::WindowEvent`), [raw input](`winit::event::DeviceEvent`), or custom
-    /// events have appeared
+    ///     events have appeared
     /// - a redraw has been requested with the [`EventLoopProxy`](crate::EventLoopProxy)
     Reactive {
         /// The approximate time from the start of one update to the next.
diff --git a/examples/camera/first_person_view_model.rs b/examples/camera/first_person_view_model.rs
index 039058bfa..d2e6c2437 100644
--- a/examples/camera/first_person_view_model.rs
+++ b/examples/camera/first_person_view_model.rs
@@ -15,9 +15,9 @@
 //! be able to change its FOV to accommodate the player's preferences for the following reasons:
 //! - *Accessibility*: How prone is the player to motion sickness? A wider FOV can help.
 //! - *Tactical preference*: Does the player want to see more of the battlefield?
-//! Or have a more zoomed-in view for precision aiming?
+//!     Or have a more zoomed-in view for precision aiming?
 //! - *Physical considerations*: How well does the in-game FOV match the player's real-world FOV?
-//! Are they sitting in front of a monitor or playing on a TV in the living room? How big is the screen?
+//!     Are they sitting in front of a monitor or playing on a TV in the living room? How big is the screen?
 //!
 //! ## Implementation
 //!
@@ -27,12 +27,12 @@
 //! We use different `RenderLayers` to select what to render.
 //!
 //! - The world model camera has no explicit `RenderLayers` component, so it uses the layer 0.
-//! All static objects in the scene are also on layer 0 for the same reason.
+//!     All static objects in the scene are also on layer 0 for the same reason.
 //! - The view model camera has a `RenderLayers` component with layer 1, so it only renders objects
-//! explicitly assigned to layer 1. The arm of the player is one such object.
-//! The order of the view model camera is additionally bumped to 1 to ensure it renders on top of the world model.
+//!     explicitly assigned to layer 1. The arm of the player is one such object.
+//!     The order of the view model camera is additionally bumped to 1 to ensure it renders on top of the world model.
 //! - The light source in the scene must illuminate both the view model and the world model, so it is
-//! assigned to both layers 0 and 1.
+//!     assigned to both layers 0 and 1.
 //!
 //! ## Controls
 //!
diff --git a/examples/ecs/component_hooks.rs b/examples/ecs/component_hooks.rs
index ae0acfefd..30876601a 100644
--- a/examples/ecs/component_hooks.rs
+++ b/examples/ecs/component_hooks.rs
@@ -8,10 +8,10 @@
 //! Here are some cases where components hooks might be necessary:
 //!
 //! - Maintaining indexes: If you need to keep custom data structures (like a spatial index) in
-//! sync with the addition/removal of components.
+//!     sync with the addition/removal of components.
 //!
 //! - Enforcing structural rules: When you have systems that depend on specific relationships
-//! between components (like hierarchies or parent-child links) and need to maintain correctness.
+//!     between components (like hierarchies or parent-child links) and need to maintain correctness.
 
 use bevy::ecs::component::{ComponentHooks, StorageType};
 use bevy::prelude::*;
diff --git a/tools/example-showcase/src/main.rs b/tools/example-showcase/src/main.rs
index 4f301017f..dbdbbec64 100644
--- a/tools/example-showcase/src/main.rs
+++ b/tools/example-showcase/src/main.rs
@@ -495,7 +495,7 @@ header_message = \"Examples (WebGL2)\"
                 // and other characters that don't
                 // work well in a URL path.
                 let category_path = root_path.join(
-                    &to_show
+                    to_show
                         .category
                         .replace(['(', ')'], "")
                         .replace(' ', "-")
@@ -521,7 +521,7 @@ weight = {}
                         .unwrap();
                     categories.insert(to_show.category.clone(), 0);
                 }
-                let example_path = category_path.join(&to_show.technical_name.replace('_', "-"));
+                let example_path = category_path.join(to_show.technical_name.replace('_', "-"));
                 let _ = fs::create_dir_all(&example_path);
 
                 let code_path = example_path.join(Path::new(&to_show.path).file_name().unwrap());
@@ -675,7 +675,7 @@ header_message = \"Examples ({})\"
                 let category_path = root_path.join(&to_build.category);
                 let _ = fs::create_dir_all(&category_path);
 
-                let example_path = category_path.join(&to_build.technical_name.replace('_', "-"));
+                let example_path = category_path.join(to_build.technical_name.replace('_', "-"));
                 let _ = fs::create_dir_all(&example_path);
 
                 if website_hacks {
@@ -685,17 +685,17 @@ header_message = \"Examples ({})\"
 
                 let _ = fs::rename(
                     Path::new("examples/wasm/target/wasm_example.js"),
-                    &example_path.join("wasm_example.js"),
+                    example_path.join("wasm_example.js"),
                 );
                 if optimize_size {
                     let _ = fs::rename(
                         Path::new("examples/wasm/target/wasm_example_bg.wasm.optimized"),
-                        &example_path.join("wasm_example_bg.wasm"),
+                        example_path.join("wasm_example_bg.wasm"),
                     );
                 } else {
                     let _ = fs::rename(
                         Path::new("examples/wasm/target/wasm_example_bg.wasm"),
-                        &example_path.join("wasm_example_bg.wasm"),
+                        example_path.join("wasm_example_bg.wasm"),
                     );
                 }
                 pb.inc();
