diff --git a/crates/bevy_app/src/app.rs b/crates/bevy_app/src/app.rs
index cee160f0e..63b91b5df 100644
--- a/crates/bevy_app/src/app.rs
+++ b/crates/bevy_app/src/app.rs
@@ -1713,9 +1713,9 @@ mod tests {
         fn raise_exits(mut exits: EventWriter<AppExit>) {
             // Exit codes chosen by a fair dice roll.
             // Unlikely to overlap with default values.
-            exits.send(AppExit::Success);
-            exits.send(AppExit::from_code(4));
-            exits.send(AppExit::from_code(73));
+            exits.write(AppExit::Success);
+            exits.write(AppExit::from_code(4));
+            exits.write(AppExit::from_code(73));
         }
 
         let exit = App::new().add_systems(Update, raise_exits).run();
diff --git a/crates/bevy_app/src/terminal_ctrl_c_handler.rs b/crates/bevy_app/src/terminal_ctrl_c_handler.rs
index 0eb34ccdb..48af3c09f 100644
--- a/crates/bevy_app/src/terminal_ctrl_c_handler.rs
+++ b/crates/bevy_app/src/terminal_ctrl_c_handler.rs
@@ -50,7 +50,7 @@ impl TerminalCtrlCHandlerPlugin {
     /// Sends a [`AppExit`] event when the user presses `Ctrl+C` on the terminal.
     pub fn exit_on_flag(mut events: EventWriter<AppExit>) {
         if SHOULD_EXIT.load(Ordering::Relaxed) {
-            events.send(AppExit::from_code(130));
+            events.write(AppExit::from_code(130));
         }
     }
 }
diff --git a/crates/bevy_asset/src/asset_changed.rs b/crates/bevy_asset/src/asset_changed.rs
index f11283f48..5fc959ead 100644
--- a/crates/bevy_asset/src/asset_changed.rs
+++ b/crates/bevy_asset/src/asset_changed.rs
@@ -330,7 +330,7 @@ mod tests {
             _query: Query<&mut MyComponent, AssetChanged<MyComponent>>,
             mut exit: EventWriter<AppExit>,
         ) {
-            exit.send(AppExit::Error(NonZero::<u8>::MIN));
+            exit.write(AppExit::Error(NonZero::<u8>::MIN));
         }
         run_app(compatible_filter);
     }
diff --git a/crates/bevy_asset/src/assets.rs b/crates/bevy_asset/src/assets.rs
index ebc9a0f58..739b6b087 100644
--- a/crates/bevy_asset/src/assets.rs
+++ b/crates/bevy_asset/src/assets.rs
@@ -579,7 +579,7 @@ impl<A: Asset> Assets<A> {
                 };
             }
         }
-        events.send_batch(assets.queued_events.drain(..));
+        events.write_batch(assets.queued_events.drain(..));
     }
 
     /// A run condition for [`asset_events`]. The system will not run if there are no events to
diff --git a/crates/bevy_ecs/examples/events.rs b/crates/bevy_ecs/examples/events.rs
index aac9dc38b..711ba57e1 100644
--- a/crates/bevy_ecs/examples/events.rs
+++ b/crates/bevy_ecs/examples/events.rs
@@ -45,7 +45,7 @@ struct MyEvent {
 fn sending_system(mut event_writer: EventWriter<MyEvent>) {
     let random_value: f32 = rand::random();
     if random_value > 0.5 {
-        event_writer.send(MyEvent {
+        event_writer.write(MyEvent {
             message: "A random event with value > 0.5".to_string(),
             random_value,
         });
diff --git a/crates/bevy_ecs/src/change_detection.rs b/crates/bevy_ecs/src/change_detection.rs
index 8731fb8eb..542736e11 100644
--- a/crates/bevy_ecs/src/change_detection.rs
+++ b/crates/bevy_ecs/src/change_detection.rs
@@ -223,7 +223,7 @@ pub trait DetectChangesMut: DetectChanges {
     ///     let new_score = 0;
     ///     if let Some(Score(previous_score)) = score.replace_if_neq(Score(new_score)) {
     ///         // If `score` change, emit a `ScoreChanged` event.
-    ///         score_changed.send(ScoreChanged {
+    ///         score_changed.write(ScoreChanged {
     ///             current: new_score,
     ///             previous: previous_score,
     ///         });
diff --git a/crates/bevy_ecs/src/event/writer.rs b/crates/bevy_ecs/src/event/writer.rs
index ebdedce17..91dd13898 100644
--- a/crates/bevy_ecs/src/event/writer.rs
+++ b/crates/bevy_ecs/src/event/writer.rs
@@ -14,14 +14,14 @@ use bevy_ecs::{
 /// #[derive(Event)]
 /// pub struct MyEvent; // Custom event type.
 /// fn my_system(mut writer: EventWriter<MyEvent>) {
-///     writer.send(MyEvent);
+///     writer.write(MyEvent);
 /// }
 ///
 /// # bevy_ecs::system::assert_is_system(my_system);
 /// ```
 /// # Observers
 ///
-/// "Buffered" Events, such as those sent directly in [`Events`] or sent using [`EventWriter`], do _not_ automatically
+/// "Buffered" Events, such as those sent directly in [`Events`] or written using [`EventWriter`], do _not_ automatically
 /// trigger any [`Observer`]s watching for that event, as each [`Event`] has different requirements regarding _if_ it will
 /// be triggered, and if so, _when_ it will be triggered in the schedule.
 ///
@@ -32,7 +32,7 @@ use bevy_ecs::{
 ///
 /// # Untyped events
 ///
-/// `EventWriter` can only send events of one specific type, which must be known at compile-time.
+/// `EventWriter` can only write events of one specific type, which must be known at compile-time.
 /// This is not a problem most of the time, but you may find a situation where you cannot know
 /// ahead of time every kind of event you'll need to send. In this case, you can use the "type-erased event" pattern.
 ///
@@ -64,13 +64,48 @@ pub struct EventWriter<'w, E: Event> {
 }
 
 impl<'w, E: Event> EventWriter<'w, E> {
+    /// Writes an `event`, which can later be read by [`EventReader`](super::EventReader)s.
+    /// This method returns the [ID](`EventId`) of the written `event`.
+    ///
+    /// See [`Events`] for details.
+    #[doc(alias = "send")]
+    #[track_caller]
+    pub fn write(&mut self, event: E) -> EventId<E> {
+        self.events.send(event)
+    }
+
+    /// Sends a list of `events` all at once, which can later be read by [`EventReader`](super::EventReader)s.
+    /// This is more efficient than sending each event individually.
+    /// This method returns the [IDs](`EventId`) of the written `events`.
+    ///
+    /// See [`Events`] for details.
+    #[doc(alias = "send_batch")]
+    #[track_caller]
+    pub fn write_batch(&mut self, events: impl IntoIterator<Item = E>) -> SendBatchIds<E> {
+        self.events.send_batch(events)
+    }
+
+    /// Writes the default value of the event. Useful when the event is an empty struct.
+    /// This method returns the [ID](`EventId`) of the written `event`.
+    ///
+    /// See [`Events`] for details.
+    #[doc(alias = "send_default")]
+    #[track_caller]
+    pub fn write_default(&mut self) -> EventId<E>
+    where
+        E: Default,
+    {
+        self.events.send_default()
+    }
+
     /// Sends an `event`, which can later be read by [`EventReader`](super::EventReader)s.
     /// This method returns the [ID](`EventId`) of the sent `event`.
     ///
     /// See [`Events`] for details.
+    #[deprecated(since = "0.16.0", note = "Use `EventWriter::write` instead.")]
     #[track_caller]
     pub fn send(&mut self, event: E) -> EventId<E> {
-        self.events.send(event)
+        self.write(event)
     }
 
     /// Sends a list of `events` all at once, which can later be read by [`EventReader`](super::EventReader)s.
@@ -78,20 +113,22 @@ impl<'w, E: Event> EventWriter<'w, E> {
     /// This method returns the [IDs](`EventId`) of the sent `events`.
     ///
     /// See [`Events`] for details.
+    #[deprecated(since = "0.16.0", note = "Use `EventWriter::write_batch` instead.")]
     #[track_caller]
     pub fn send_batch(&mut self, events: impl IntoIterator<Item = E>) -> SendBatchIds<E> {
-        self.events.send_batch(events)
+        self.write_batch(events)
     }
 
     /// Sends the default value of the event. Useful when the event is an empty struct.
     /// This method returns the [ID](`EventId`) of the sent `event`.
     ///
     /// See [`Events`] for details.
+    #[deprecated(since = "0.16.0", note = "Use `EventWriter::write_default` instead.")]
     #[track_caller]
     pub fn send_default(&mut self) -> EventId<E>
     where
         E: Default,
     {
-        self.events.send_default()
+        self.write_default()
     }
 }
diff --git a/crates/bevy_ecs/src/system/system_param.rs b/crates/bevy_ecs/src/system/system_param.rs
index 8ef804a92..8cf3cfb30 100644
--- a/crates/bevy_ecs/src/system/system_param.rs
+++ b/crates/bevy_ecs/src/system/system_param.rs
@@ -685,7 +685,7 @@ unsafe impl<'w, 's, D: ReadOnlyQueryData + 'static, F: QueryFilter + 'static> Re
 ///         // ...
 ///         # let _event = event;
 ///     }
-///     set.p1().send(MyEvent::new());
+///     set.p1().write(MyEvent::new());
 ///
 ///     let entities = set.p2().entities();
 ///     // ...
diff --git a/crates/bevy_gilrs/src/gilrs_system.rs b/crates/bevy_gilrs/src/gilrs_system.rs
index 05f9aa02e..df1685d78 100644
--- a/crates/bevy_gilrs/src/gilrs_system.rs
+++ b/crates/bevy_gilrs/src/gilrs_system.rs
@@ -26,7 +26,7 @@ pub fn gilrs_event_startup_system(
         gamepads.id_to_entity.insert(id, entity);
         gamepads.entity_to_id.insert(entity, id);
 
-        events.send(GamepadConnectionEvent {
+        events.write(GamepadConnectionEvent {
             gamepad: entity,
             connection: GamepadConnection::Connected {
                 name: gamepad.name().to_string(),
@@ -69,8 +69,8 @@ pub fn gilrs_event_system(
                     },
                 );
 
-                events.send(event.clone().into());
-                connection_events.send(event);
+                events.write(event.clone().into());
+                connection_events.write(event);
             }
             EventType::Disconnected => {
                 let gamepad = gamepads
@@ -79,8 +79,8 @@ pub fn gilrs_event_system(
                     .copied()
                     .expect("mapping should exist from connection");
                 let event = GamepadConnectionEvent::new(gamepad, GamepadConnection::Disconnected);
-                events.send(event.clone().into());
-                connection_events.send(event);
+                events.write(event.clone().into());
+                connection_events.write(event);
             }
             EventType::ButtonChanged(gilrs_button, raw_value, _) => {
                 let Some(button) = convert_button(gilrs_button) else {
@@ -91,8 +91,8 @@ pub fn gilrs_event_system(
                     .get(&gilrs_event.id)
                     .copied()
                     .expect("mapping should exist from connection");
-                events.send(RawGamepadButtonChangedEvent::new(gamepad, button, raw_value).into());
-                button_events.send(RawGamepadButtonChangedEvent::new(
+                events.write(RawGamepadButtonChangedEvent::new(gamepad, button, raw_value).into());
+                button_events.write(RawGamepadButtonChangedEvent::new(
                     gamepad, button, raw_value,
                 ));
             }
@@ -105,8 +105,8 @@ pub fn gilrs_event_system(
                     .get(&gilrs_event.id)
                     .copied()
                     .expect("mapping should exist from connection");
-                events.send(RawGamepadAxisChangedEvent::new(gamepad, axis, raw_value).into());
-                axis_event.send(RawGamepadAxisChangedEvent::new(gamepad, axis, raw_value));
+                events.write(RawGamepadAxisChangedEvent::new(gamepad, axis, raw_value).into());
+                axis_event.write(RawGamepadAxisChangedEvent::new(gamepad, axis, raw_value));
             }
             _ => (),
         };
diff --git a/crates/bevy_input/src/gamepad.rs b/crates/bevy_input/src/gamepad.rs
index 2da9916a7..cdacd458f 100644
--- a/crates/bevy_input/src/gamepad.rs
+++ b/crates/bevy_input/src/gamepad.rs
@@ -1539,7 +1539,7 @@ pub fn gamepad_event_processing_system(
         match event {
             // Connections require inserting/removing components so they are done in a separate system
             RawGamepadEvent::Connection(send_event) => {
-                processed_events.send(GamepadEvent::from(send_event.clone()));
+                processed_events.write(GamepadEvent::from(send_event.clone()));
             }
             RawGamepadEvent::Axis(RawGamepadAxisChangedEvent {
                 gamepad,
@@ -1559,8 +1559,8 @@ pub fn gamepad_event_processing_system(
                 gamepad_axis.analog.set(axis, filtered_value.raw);
                 let send_event =
                     GamepadAxisChangedEvent::new(gamepad, axis, filtered_value.scaled.to_f32());
-                processed_axis_events.send(send_event);
-                processed_events.send(GamepadEvent::from(send_event));
+                processed_axis_events.write(send_event);
+                processed_events.write(GamepadEvent::from(send_event));
             }
             RawGamepadEvent::Button(RawGamepadButtonChangedEvent {
                 gamepad,
@@ -1583,7 +1583,7 @@ pub fn gamepad_event_processing_system(
                 if button_settings.is_released(filtered_value.raw) {
                     // Check if button was previously pressed
                     if gamepad_buttons.pressed(button) {
-                        processed_digital_events.send(GamepadButtonStateChangedEvent::new(
+                        processed_digital_events.write(GamepadButtonStateChangedEvent::new(
                             gamepad,
                             button,
                             ButtonState::Released,
@@ -1595,7 +1595,7 @@ pub fn gamepad_event_processing_system(
                 } else if button_settings.is_pressed(filtered_value.raw) {
                     // Check if button was previously not pressed
                     if !gamepad_buttons.pressed(button) {
-                        processed_digital_events.send(GamepadButtonStateChangedEvent::new(
+                        processed_digital_events.write(GamepadButtonStateChangedEvent::new(
                             gamepad,
                             button,
                             ButtonState::Pressed,
@@ -1615,8 +1615,8 @@ pub fn gamepad_event_processing_system(
                     button_state,
                     filtered_value.scaled.to_f32(),
                 );
-                processed_analog_events.send(send_event);
-                processed_events.send(GamepadEvent::from(send_event));
+                processed_analog_events.write(send_event);
+                processed_events.write(GamepadEvent::from(send_event));
             }
         }
     }
@@ -1699,7 +1699,7 @@ impl GamepadRumbleIntensity {
 ///     gamepads: Query<Entity, With<Gamepad>>,
 /// ) {
 ///     for entity in gamepads.iter() {
-///         rumble_requests.send(GamepadRumbleRequest::Add {
+///         rumble_requests.write(GamepadRumbleRequest::Add {
 ///             gamepad: entity,
 ///             intensity: GamepadRumbleIntensity::MAX,
 ///             duration: Duration::from_secs_f32(0.5),
diff --git a/crates/bevy_picking/src/events.rs b/crates/bevy_picking/src/events.rs
index 243208ca8..709346046 100644
--- a/crates/bevy_picking/src/events.rs
+++ b/crates/bevy_picking/src/events.rs
@@ -464,7 +464,7 @@ pub fn pointer_events(
                 Out { hit: hit.clone() },
             );
             commands.trigger_targets(out_event.clone(), hovered_entity);
-            event_writers.out_events.send(out_event);
+            event_writers.out_events.write(out_event);
 
             // Possibly send DragLeave events
             for button in PointerButton::iter() {
@@ -482,7 +482,7 @@ pub fn pointer_events(
                         },
                     );
                     commands.trigger_targets(drag_leave_event.clone(), hovered_entity);
-                    event_writers.drag_leave_events.send(drag_leave_event);
+                    event_writers.drag_leave_events.write(drag_leave_event);
                 }
             }
         }
@@ -528,7 +528,7 @@ pub fn pointer_events(
                         },
                     );
                     commands.trigger_targets(drag_enter_event.clone(), hovered_entity);
-                    event_writers.drag_enter_events.send(drag_enter_event);
+                    event_writers.drag_enter_events.write(drag_enter_event);
                 }
             }
 
@@ -540,7 +540,7 @@ pub fn pointer_events(
                 Over { hit: hit.clone() },
             );
             commands.trigger_targets(over_event.clone(), hovered_entity);
-            event_writers.over_events.send(over_event);
+            event_writers.over_events.write(over_event);
         }
     }
 
@@ -571,7 +571,7 @@ pub fn pointer_events(
                         },
                     );
                     commands.trigger_targets(pressed_event.clone(), hovered_entity);
-                    event_writers.pressed_events.send(pressed_event);
+                    event_writers.pressed_events.write(pressed_event);
                     // Also insert the press into the state
                     state
                         .pressing
@@ -600,7 +600,7 @@ pub fn pointer_events(
                             },
                         );
                         commands.trigger_targets(click_event.clone(), hovered_entity);
-                        event_writers.click_events.send(click_event);
+                        event_writers.click_events.write(click_event);
                     }
                     // Always send the Released event
                     let released_event = Pointer::new(
@@ -613,7 +613,7 @@ pub fn pointer_events(
                         },
                     );
                     commands.trigger_targets(released_event.clone(), hovered_entity);
-                    event_writers.released_events.send(released_event);
+                    event_writers.released_events.write(released_event);
                 }
 
                 // Then emit the drop events.
@@ -631,7 +631,7 @@ pub fn pointer_events(
                             },
                         );
                         commands.trigger_targets(drag_drop_event.clone(), *dragged_over);
-                        event_writers.drag_drop_events.send(drag_drop_event);
+                        event_writers.drag_drop_events.write(drag_drop_event);
                     }
                     // Emit DragEnd
                     let drag_end_event = Pointer::new(
@@ -644,7 +644,7 @@ pub fn pointer_events(
                         },
                     );
                     commands.trigger_targets(drag_end_event.clone(), drag_target);
-                    event_writers.drag_end_events.send(drag_end_event);
+                    event_writers.drag_end_events.write(drag_end_event);
                     // Emit DragLeave
                     for (dragged_over, hit) in state.dragging_over.iter() {
                         let drag_leave_event = Pointer::new(
@@ -658,7 +658,7 @@ pub fn pointer_events(
                             },
                         );
                         commands.trigger_targets(drag_leave_event.clone(), *dragged_over);
-                        event_writers.drag_leave_events.send(drag_leave_event);
+                        event_writers.drag_leave_events.write(drag_leave_event);
                     }
                 }
 
@@ -698,7 +698,7 @@ pub fn pointer_events(
                             },
                         );
                         commands.trigger_targets(drag_start_event.clone(), *press_target);
-                        event_writers.drag_start_events.send(drag_start_event);
+                        event_writers.drag_start_events.write(drag_start_event);
                     }
 
                     // Emit Drag events to the entities we are dragging
@@ -718,7 +718,7 @@ pub fn pointer_events(
                             },
                         );
                         commands.trigger_targets(drag_event.clone(), *drag_target);
-                        event_writers.drag_events.send(drag_event);
+                        event_writers.drag_events.write(drag_event);
 
                         // Update drag position
                         drag.latest_pos = location.position;
@@ -741,7 +741,7 @@ pub fn pointer_events(
                                 },
                             );
                             commands.trigger_targets(drag_over_event.clone(), hovered_entity);
-                            event_writers.drag_over_events.send(drag_over_event);
+                            event_writers.drag_over_events.write(drag_over_event);
                         }
                     }
                 }
@@ -762,7 +762,7 @@ pub fn pointer_events(
                         },
                     );
                     commands.trigger_targets(move_event.clone(), hovered_entity);
-                    event_writers.move_events.send(move_event);
+                    event_writers.move_events.write(move_event);
                 }
             }
             PointerAction::Scroll { x, y, unit } => {
@@ -784,7 +784,7 @@ pub fn pointer_events(
                         },
                     );
                     commands.trigger_targets(scroll_event.clone(), hovered_entity);
-                    event_writers.scroll_events.send(scroll_event);
+                    event_writers.scroll_events.write(scroll_event);
                 }
             }
             // Canceled
@@ -798,7 +798,7 @@ pub fn pointer_events(
                     let cancel_event =
                         Pointer::new(pointer_id, location.clone(), hovered_entity, Cancel { hit });
                     commands.trigger_targets(cancel_event.clone(), hovered_entity);
-                    event_writers.cancel_events.send(cancel_event);
+                    event_writers.cancel_events.write(cancel_event);
                 }
                 // Clear the state for the canceled pointer
                 pointer_state.clear(pointer_id);
diff --git a/crates/bevy_picking/src/input.rs b/crates/bevy_picking/src/input.rs
index eeb4adac1..02bea5a25 100644
--- a/crates/bevy_picking/src/input.rs
+++ b/crates/bevy_picking/src/input.rs
@@ -125,7 +125,7 @@ pub fn mouse_pick_events(
                     },
                     position: event.position,
                 };
-                pointer_events.send(PointerInput::new(
+                pointer_events.write(PointerInput::new(
                     PointerId::Mouse,
                     location,
                     PointerAction::Move {
@@ -155,7 +155,7 @@ pub fn mouse_pick_events(
                     ButtonState::Pressed => PointerAction::Press(button),
                     ButtonState::Released => PointerAction::Release(button),
                 };
-                pointer_events.send(PointerInput::new(PointerId::Mouse, location, action));
+                pointer_events.write(PointerInput::new(PointerId::Mouse, location, action));
             }
             WindowEvent::MouseWheel(event) => {
                 let MouseWheel { unit, x, y, window } = *event;
@@ -172,7 +172,7 @@ pub fn mouse_pick_events(
 
                 let action = PointerAction::Scroll { x, y, unit };
 
-                pointer_events.send(PointerInput::new(PointerId::Mouse, location, action));
+                pointer_events.write(PointerInput::new(PointerId::Mouse, location, action));
             }
             _ => {}
         }
@@ -207,7 +207,7 @@ pub fn touch_pick_events(
                     debug!("Spawning pointer {:?}", pointer);
                     commands.spawn((pointer, PointerLocation::new(location.clone())));
 
-                    pointer_events.send(PointerInput::new(
+                    pointer_events.write(PointerInput::new(
                         pointer,
                         location,
                         PointerAction::Press(PointerButton::Primary),
@@ -221,7 +221,7 @@ pub fn touch_pick_events(
                         if last_touch == touch {
                             continue;
                         }
-                        pointer_events.send(PointerInput::new(
+                        pointer_events.write(PointerInput::new(
                             pointer,
                             location,
                             PointerAction::Move {
@@ -232,7 +232,7 @@ pub fn touch_pick_events(
                     touch_cache.insert(touch.id, *touch);
                 }
                 TouchPhase::Ended => {
-                    pointer_events.send(PointerInput::new(
+                    pointer_events.write(PointerInput::new(
                         pointer,
                         location,
                         PointerAction::Release(PointerButton::Primary),
@@ -240,7 +240,7 @@ pub fn touch_pick_events(
                     touch_cache.remove(&touch.id);
                 }
                 TouchPhase::Canceled => {
-                    pointer_events.send(PointerInput::new(
+                    pointer_events.write(PointerInput::new(
                         pointer,
                         location,
                         PointerAction::Cancel,
diff --git a/crates/bevy_picking/src/lib.rs b/crates/bevy_picking/src/lib.rs
index 7b9c990ae..2fb61142d 100644
--- a/crates/bevy_picking/src/lib.rs
+++ b/crates/bevy_picking/src/lib.rs
@@ -64,7 +64,7 @@
 //!             commands.entity(trigger.target()).despawn();
 //!         })
 //!         .observe(|trigger: Trigger<Pointer<Over>>, mut events: EventWriter<Greeting>| {
-//!             events.send(Greeting);
+//!             events.write(Greeting);
 //!         });
 //! }
 //! ```
diff --git a/crates/bevy_picking/src/mesh_picking/mod.rs b/crates/bevy_picking/src/mesh_picking/mod.rs
index 5860fbc2b..6007168ee 100644
--- a/crates/bevy_picking/src/mesh_picking/mod.rs
+++ b/crates/bevy_picking/src/mesh_picking/mod.rs
@@ -128,7 +128,7 @@ pub fn update_hits(
             .collect::<Vec<_>>();
         let order = camera.order as f32;
         if !picks.is_empty() {
-            output.send(PointerHits::new(ray_id.pointer, picks, order));
+            output.write(PointerHits::new(ray_id.pointer, picks, order));
         }
     }
 }
diff --git a/crates/bevy_picking/src/window.rs b/crates/bevy_picking/src/window.rs
index de4b19eac..30093da79 100644
--- a/crates/bevy_picking/src/window.rs
+++ b/crates/bevy_picking/src/window.rs
@@ -39,7 +39,7 @@ pub fn update_window_hits(
         {
             let entity = window_ref.entity();
             let hit_data = HitData::new(entity, 0.0, None, None);
-            output_events.send(PointerHits::new(
+            output_events.write(PointerHits::new(
                 *pointer_id,
                 vec![(entity, hit_data)],
                 f32::NEG_INFINITY,
diff --git a/crates/bevy_sprite/src/picking_backend.rs b/crates/bevy_sprite/src/picking_backend.rs
index 18fe21891..480617a3f 100644
--- a/crates/bevy_sprite/src/picking_backend.rs
+++ b/crates/bevy_sprite/src/picking_backend.rs
@@ -246,6 +246,6 @@ fn sprite_picking(
             .collect();
 
         let order = camera.order as f32;
-        output.send(PointerHits::new(*pointer, picks, order));
+        output.write(PointerHits::new(*pointer, picks, order));
     }
 }
diff --git a/crates/bevy_state/src/state/transitions.rs b/crates/bevy_state/src/state/transitions.rs
index 4c4311a9d..2d9b5d92d 100644
--- a/crates/bevy_state/src/state/transitions.rs
+++ b/crates/bevy_state/src/state/transitions.rs
@@ -145,7 +145,7 @@ pub(crate) fn internal_apply_state_transition<S: States>(
 
                     // Transition events are sent even for same state transitions
                     // Although enter and exit schedules are not run by default.
-                    event.send(StateTransitionEvent {
+                    event.write(StateTransitionEvent {
                         exited: Some(exited.clone()),
                         entered: Some(entered.clone()),
                     });
@@ -154,7 +154,7 @@ pub(crate) fn internal_apply_state_transition<S: States>(
                     // If the [`State<S>`] resource does not exist, we create it, compute dependent states, send a transition event and register the `OnEnter` schedule.
                     commands.insert_resource(State(entered.clone()));
 
-                    event.send(StateTransitionEvent {
+                    event.write(StateTransitionEvent {
                         exited: None,
                         entered: Some(entered.clone()),
                     });
@@ -166,7 +166,7 @@ pub(crate) fn internal_apply_state_transition<S: States>(
             if let Some(resource) = current_state {
                 commands.remove_resource::<State<S>>();
 
-                event.send(StateTransitionEvent {
+                event.write(StateTransitionEvent {
                     exited: Some(resource.get().clone()),
                     entered: None,
                 });
diff --git a/crates/bevy_time/src/lib.rs b/crates/bevy_time/src/lib.rs
index 334ff549a..2f37ead16 100644
--- a/crates/bevy_time/src/lib.rs
+++ b/crates/bevy_time/src/lib.rs
@@ -294,13 +294,13 @@ mod tests {
             .add_event::<TestEvent<i32>>()
             .add_event::<TestEvent<()>>()
             .add_systems(Startup, move |mut ev2: EventWriter<TestEvent<()>>| {
-                ev2.send(TestEvent {
+                ev2.write(TestEvent {
                     sender: tx2.clone(),
                 });
             })
             .add_systems(Update, move |mut ev1: EventWriter<TestEvent<i32>>| {
                 // Keep adding events so this event type is processed every update
-                ev1.send(TestEvent {
+                ev1.write(TestEvent {
                     sender: tx1.clone(),
                 });
             })
diff --git a/crates/bevy_ui/src/picking_backend.rs b/crates/bevy_ui/src/picking_backend.rs
index afb2aecae..0a60cba1e 100644
--- a/crates/bevy_ui/src/picking_backend.rs
+++ b/crates/bevy_ui/src/picking_backend.rs
@@ -212,6 +212,6 @@ pub fn ui_picking(
             .unwrap_or_default() as f32
             + 0.5; // bevy ui can run on any camera, it's a special case
 
-        output.send(PointerHits::new(*pointer, picks, order));
+        output.write(PointerHits::new(*pointer, picks, order));
     }
 }
diff --git a/crates/bevy_window/src/system.rs b/crates/bevy_window/src/system.rs
index c7ec83889..8cc6f020a 100644
--- a/crates/bevy_window/src/system.rs
+++ b/crates/bevy_window/src/system.rs
@@ -13,7 +13,7 @@ use bevy_ecs::prelude::*;
 pub fn exit_on_all_closed(mut app_exit_events: EventWriter<AppExit>, windows: Query<&Window>) {
     if windows.is_empty() {
         log::info!("No windows are open, exiting");
-        app_exit_events.send(AppExit::Success);
+        app_exit_events.write(AppExit::Success);
     }
 }
 
@@ -28,7 +28,7 @@ pub fn exit_on_primary_closed(
 ) {
     if windows.is_empty() {
         log::info!("Primary window was closed, exiting");
-        app_exit_events.send(AppExit::Success);
+        app_exit_events.write(AppExit::Success);
     }
 }
 
diff --git a/crates/bevy_winit/src/accessibility.rs b/crates/bevy_winit/src/accessibility.rs
index 4a4e717e3..0b5b1e6b0 100644
--- a/crates/bevy_winit/src/accessibility.rs
+++ b/crates/bevy_winit/src/accessibility.rs
@@ -159,7 +159,7 @@ fn poll_receivers(
     for (_id, handler) in handlers.iter() {
         let mut handler = handler.lock().unwrap();
         while let Some(event) = handler.pop_front() {
-            actions.send(ActionRequestWrapper(event));
+            actions.write(ActionRequestWrapper(event));
         }
     }
 }
diff --git a/crates/bevy_winit/src/state.rs b/crates/bevy_winit/src/state.rs
index 0c1a02e0c..bfa7283d1 100644
--- a/crates/bevy_winit/src/state.rs
+++ b/crates/bevy_winit/src/state.rs
@@ -912,7 +912,7 @@ pub(crate) fn react_to_resize(
         .resolution
         .set_physical_resolution(size.width, size.height);
 
-    window_resized.send(WindowResized {
+    window_resized.write(WindowResized {
         window: window_entity,
         width: window.width(),
         height: window.height(),
@@ -928,7 +928,7 @@ pub(crate) fn react_to_scale_factor_change(
 ) {
     window.resolution.set_scale_factor(scale_factor as f32);
 
-    window_backend_scale_factor_changed.send(WindowBackendScaleFactorChanged {
+    window_backend_scale_factor_changed.write(WindowBackendScaleFactorChanged {
         window: window_entity,
         scale_factor,
     });
@@ -937,7 +937,7 @@ pub(crate) fn react_to_scale_factor_change(
     let scale_factor_override = window.resolution.scale_factor_override();
 
     if scale_factor_override.is_none() && !relative_eq!(scale_factor as f32, prior_factor) {
-        window_scale_factor_changed.send(WindowScaleFactorChanged {
+        window_scale_factor_changed.write(WindowScaleFactorChanged {
             window: window_entity,
             scale_factor,
         });
diff --git a/crates/bevy_winit/src/system.rs b/crates/bevy_winit/src/system.rs
index 2c481f960..49e73bcea 100644
--- a/crates/bevy_winit/src/system.rs
+++ b/crates/bevy_winit/src/system.rs
@@ -115,7 +115,7 @@ pub fn create_windows<F: QueryFilter + 'static>(
             }
         }
 
-        window_created_events.send(WindowCreated { window: entity });
+        window_created_events.write(WindowCreated { window: entity });
     }
 }
 
@@ -135,7 +135,7 @@ pub(crate) fn check_keyboard_focus_lost(
         }
     }
     if focus_lost & !focus_gained {
-        keyboard_focus.send(KeyboardFocusLost);
+        keyboard_focus.write(KeyboardFocusLost);
     }
 }
 
@@ -215,7 +215,7 @@ pub(crate) fn despawn_windows(
     // Drop all the windows that are waiting to be closed
     windows_to_drop.clear();
     for window in closing.iter() {
-        closing_events.send(WindowClosing { window });
+        closing_events.write(WindowClosing { window });
     }
     for window in closed.read() {
         info!("Closing window {}", window);
@@ -230,7 +230,7 @@ pub(crate) fn despawn_windows(
                 // Keeping the wrapper and dropping it next frame in this system ensure its dropped in the main thread
                 windows_to_drop.push(window);
             }
-            closed_events.send(WindowClosed { window });
+            closed_events.write(WindowClosed { window });
         }
     }
 
@@ -239,7 +239,7 @@ pub(crate) fn despawn_windows(
     if !exit_events.is_empty() {
         exit_events.clear();
         for window in window_entities.iter() {
-            closing_events.send(WindowClosing { window });
+            closing_events.write(WindowClosing { window });
         }
     }
 }
diff --git a/examples/3d/mixed_lighting.rs b/examples/3d/mixed_lighting.rs
index d82754982..0e9d08567 100644
--- a/examples/3d/mixed_lighting.rs
+++ b/examples/3d/mixed_lighting.rs
@@ -175,7 +175,7 @@ fn spawn_scene(commands: &mut Commands, asset_server: &AssetServer) {
              mut lighting_mode_change_event_writer: EventWriter<LightingModeChanged>| {
                 // When the scene loads, send a `LightingModeChanged` event so
                 // that we set up the lightmaps.
-                lighting_mode_change_event_writer.send(LightingModeChanged);
+                lighting_mode_change_event_writer.write(LightingModeChanged);
             },
         );
 }
@@ -393,7 +393,7 @@ fn handle_lighting_mode_change(
 ) {
     for event in widget_click_event_reader.read() {
         app_status.lighting_mode = **event;
-        lighting_mode_change_event_writer.send(LightingModeChanged);
+        lighting_mode_change_event_writer.write(LightingModeChanged);
     }
 }
 
diff --git a/examples/app/custom_loop.rs b/examples/app/custom_loop.rs
index 0dd3dfedd..b93da675f 100644
--- a/examples/app/custom_loop.rs
+++ b/examples/app/custom_loop.rs
@@ -35,7 +35,7 @@ fn print_system(input: Res<Input>) {
 
 fn exit_system(input: Res<Input>, mut exit_event: EventWriter<AppExit>) {
     if input.0 == "exit" {
-        exit_event.send(AppExit::Success);
+        exit_event.write(AppExit::Success);
     }
 }
 
diff --git a/examples/app/headless_renderer.rs b/examples/app/headless_renderer.rs
index 619404dc9..5d5b2f7d0 100644
--- a/examples/app/headless_renderer.rs
+++ b/examples/app/headless_renderer.rs
@@ -535,7 +535,7 @@ fn update(
                     };
                 }
                 if scene_controller.single_image {
-                    app_exit_writer.send(AppExit::Success);
+                    app_exit_writer.write(AppExit::Success);
                 }
             }
         } else {
diff --git a/examples/app/log_layers_ecs.rs b/examples/app/log_layers_ecs.rs
index 30cba02b8..f62198ad3 100644
--- a/examples/app/log_layers_ecs.rs
+++ b/examples/app/log_layers_ecs.rs
@@ -54,7 +54,7 @@ fn transfer_log_events(
     mut log_events: EventWriter<LogEvent>,
 ) {
     // Make sure to use `try_iter()` and not `iter()` to prevent blocking.
-    log_events.send_batch(receiver.try_iter());
+    log_events.write_batch(receiver.try_iter());
 }
 
 /// This is the [`Layer`] that we will use to capture log events and then send them to Bevy's
diff --git a/examples/async_tasks/external_source_external_thread.rs b/examples/async_tasks/external_source_external_thread.rs
index 92c7c60a8..1b7bb27b1 100644
--- a/examples/async_tasks/external_source_external_thread.rs
+++ b/examples/async_tasks/external_source_external_thread.rs
@@ -46,7 +46,7 @@ fn setup(mut commands: Commands) {
 // This system reads from the receiver and sends events to Bevy
 fn read_stream(receiver: Res<StreamReceiver>, mut events: EventWriter<StreamEvent>) {
     for from_stream in receiver.try_iter() {
-        events.send(StreamEvent(from_stream));
+        events.write(StreamEvent(from_stream));
     }
 }
 
diff --git a/examples/audio/pitch.rs b/examples/audio/pitch.rs
index 06aeccc3f..4a49a8885 100644
--- a/examples/audio/pitch.rs
+++ b/examples/audio/pitch.rs
@@ -50,6 +50,6 @@ fn keyboard_input_system(
         frequency.0 /= ops::powf(2.0f32, 1.0 / 12.0);
     }
     if keyboard_input.just_pressed(KeyCode::Space) {
-        events.send(PlayPitch);
+        events.write(PlayPitch);
     }
 }
diff --git a/examples/ecs/ecs_guide.rs b/examples/ecs/ecs_guide.rs
index 443b027e1..2b2fdb814 100644
--- a/examples/ecs/ecs_guide.rs
+++ b/examples/ecs/ecs_guide.rs
@@ -168,10 +168,10 @@ fn game_over_system(
 ) {
     if let Some(ref player) = game_state.winning_player {
         println!("{player} won the game!");
-        app_exit_events.send(AppExit::Success);
+        app_exit_events.write(AppExit::Success);
     } else if game_state.current_round == game_rules.max_rounds {
         println!("Ran out of rounds. Nobody wins!");
-        app_exit_events.send(AppExit::Success);
+        app_exit_events.write(AppExit::Success);
     }
 }
 
diff --git a/examples/ecs/event.rs b/examples/ecs/event.rs
index e085a874c..0949a0377 100644
--- a/examples/ecs/event.rs
+++ b/examples/ecs/event.rs
@@ -34,8 +34,8 @@ impl Default for DamageTimer {
 // This system reads 'DamageTimer', updates it, then sends a 'DealDamage' event
 // if the timer has finished.
 //
-// Events are sent using an 'EventWriter<T>' by calling 'send' or 'send_default'.
-// The 'send_default' method will send the event with the default value if the event
+// Events are sent using an 'EventWriter<T>' by calling 'write' or 'write_default'.
+// The 'write_default' method will send the event with the default value if the event
 // has a 'Default' implementation.
 fn deal_damage_over_time(
     time: Res<Time>,
@@ -43,8 +43,8 @@ fn deal_damage_over_time(
     mut events: EventWriter<DealDamage>,
 ) {
     if state.tick(time.delta()).finished() {
-        // Events can be sent with 'send' and constructed just like any other object.
-        events.send(DealDamage { amount: 10 });
+        // Events can be sent with 'write' and constructed just like any other object.
+        events.write(DealDamage { amount: 10 });
     }
 }
 
@@ -62,7 +62,7 @@ fn apply_armor_to_damage(
         event.amount -= 1;
         if event.amount <= 0 {
             // Zero-sized events can also be sent with 'send'
-            armor_events.send(ArmorBlockedDamage);
+            armor_events.write(ArmorBlockedDamage);
         }
     }
 }
@@ -80,8 +80,8 @@ fn apply_damage_to_health(
     for event in dmg_events.read() {
         info!("Applying {} damage", event.amount);
         if event.amount > 0 {
-            // Events with a 'Default' implementation can be sent with 'send_default'
-            rcvd_events.send_default();
+            // Events with a 'Default' implementation can be written with 'write_default'
+            rcvd_events.write_default();
         }
     }
 }
diff --git a/examples/ecs/observer_propagation.rs b/examples/ecs/observer_propagation.rs
index 0ca64686d..1ec1a69ea 100644
--- a/examples/ecs/observer_propagation.rs
+++ b/examples/ecs/observer_propagation.rs
@@ -118,7 +118,7 @@ fn take_damage(
     } else {
         warn!("ðŸ’€ {} has died a gruesome death", name);
         commands.entity(trigger.target()).despawn();
-        app_exit.send(AppExit::Success);
+        app_exit.write(AppExit::Success);
     }
 
     info!("(propagation reached root)\n");
diff --git a/examples/ecs/send_and_receive_events.rs b/examples/ecs/send_and_receive_events.rs
index 9cf38c8fe..c9cb33450 100644
--- a/examples/ecs/send_and_receive_events.rs
+++ b/examples/ecs/send_and_receive_events.rs
@@ -58,7 +58,7 @@ struct B;
 // not at compile time, as Bevy uses internal unsafe code to split the `World` into disjoint pieces.
 fn read_and_write_different_event_types(mut a: EventWriter<A>, mut b: EventReader<B>) {
     for _ in b.read() {}
-    a.send(A);
+    a.write(A);
 }
 
 /// A dummy event type.
@@ -73,22 +73,22 @@ struct DebugEvent {
 fn send_events(mut events: EventWriter<DebugEvent>, frame_count: Res<FrameCount>) {
     println!("Sending events for frame {}", frame_count.0);
 
-    events.send(DebugEvent {
+    events.write(DebugEvent {
         resend_from_param_set: false,
         resend_from_local_event_reader: false,
         times_sent: 1,
     });
-    events.send(DebugEvent {
+    events.write(DebugEvent {
         resend_from_param_set: true,
         resend_from_local_event_reader: false,
         times_sent: 1,
     });
-    events.send(DebugEvent {
+    events.write(DebugEvent {
         resend_from_param_set: false,
         resend_from_local_event_reader: true,
         times_sent: 1,
     });
-    events.send(DebugEvent {
+    events.write(DebugEvent {
         resend_from_param_set: true,
         resend_from_local_event_reader: true,
         times_sent: 1,
@@ -127,7 +127,7 @@ fn send_and_receive_param_set(
     // This is p1, as the second parameter in the `ParamSet` is the writer.
     for mut event in events_to_resend {
         event.times_sent += 1;
-        param_set.p1().send(event);
+        param_set.p1().write(event);
     }
 }
 
diff --git a/examples/games/breakout.rs b/examples/games/breakout.rs
index 6128f28f6..0a0b04f7a 100644
--- a/examples/games/breakout.rs
+++ b/examples/games/breakout.rs
@@ -356,8 +356,8 @@ fn check_for_collisions(
         );
 
         if let Some(collision) = collision {
-            // Sends a collision event so that other systems can react to the collision
-            collision_events.send_default();
+            // Writes a collision event so that other systems can react to the collision
+            collision_events.write_default();
 
             // Bricks should be despawned and increment the scoreboard on collision
             if maybe_brick.is_some() {
diff --git a/examples/games/desk_toy.rs b/examples/games/desk_toy.rs
index 90e384799..c25286dd9 100644
--- a/examples/games/desk_toy.rs
+++ b/examples/games/desk_toy.rs
@@ -315,7 +315,7 @@ fn quit(
         .distance(cursor_world_pos)
         < BEVY_LOGO_RADIUS
     {
-        app_exit.send(AppExit::Success);
+        app_exit.write(AppExit::Success);
     }
 }
 
diff --git a/examples/games/game_menu.rs b/examples/games/game_menu.rs
index 03056cbe3..4794d0e44 100644
--- a/examples/games/game_menu.rs
+++ b/examples/games/game_menu.rs
@@ -706,7 +706,7 @@ mod menu {
             if *interaction == Interaction::Pressed {
                 match menu_button_action {
                     MenuButtonAction::Quit => {
-                        app_exit_events.send(AppExit::Success);
+                        app_exit_events.write(AppExit::Success);
                     }
                     MenuButtonAction::Play => {
                         game_state.set(GameState::Game);
diff --git a/examples/helpers/widgets.rs b/examples/helpers/widgets.rs
index 1c9334b60..ce3168e55 100644
--- a/examples/helpers/widgets.rs
+++ b/examples/helpers/widgets.rs
@@ -171,7 +171,7 @@ pub fn handle_ui_interactions<T>(
 {
     for (interaction, click_event) in interactions.iter_mut() {
         if *interaction == Interaction::Pressed {
-            widget_click_events.send(WidgetClickEvent((**click_event).clone()));
+            widget_click_events.write(WidgetClickEvent((**click_event).clone()));
         }
     }
 }
diff --git a/examples/input/gamepad_rumble.rs b/examples/input/gamepad_rumble.rs
index c7e27800b..16b7a4c19 100644
--- a/examples/input/gamepad_rumble.rs
+++ b/examples/input/gamepad_rumble.rs
@@ -23,7 +23,7 @@ fn gamepad_system(
             info!(
                 "North face button: strong (low-frequency) with low intensity for rumble for 5 seconds. Press multiple times to increase intensity."
             );
-            rumble_requests.send(GamepadRumbleRequest::Add {
+            rumble_requests.write(GamepadRumbleRequest::Add {
                 gamepad: entity,
                 intensity: GamepadRumbleIntensity::strong_motor(0.1),
                 duration: Duration::from_secs(5),
@@ -32,7 +32,7 @@ fn gamepad_system(
 
         if gamepad.just_pressed(GamepadButton::East) {
             info!("East face button: maximum rumble on both motors for 5 seconds");
-            rumble_requests.send(GamepadRumbleRequest::Add {
+            rumble_requests.write(GamepadRumbleRequest::Add {
                 gamepad: entity,
                 duration: Duration::from_secs(5),
                 intensity: GamepadRumbleIntensity::MAX,
@@ -41,7 +41,7 @@ fn gamepad_system(
 
         if gamepad.just_pressed(GamepadButton::South) {
             info!("South face button: low-intensity rumble on the weak motor for 0.5 seconds");
-            rumble_requests.send(GamepadRumbleRequest::Add {
+            rumble_requests.write(GamepadRumbleRequest::Add {
                 gamepad: entity,
                 duration: Duration::from_secs_f32(0.5),
                 intensity: GamepadRumbleIntensity::weak_motor(0.25),
@@ -50,7 +50,7 @@ fn gamepad_system(
 
         if gamepad.just_pressed(GamepadButton::West) {
             info!("West face button: custom rumble intensity for 5 second");
-            rumble_requests.send(GamepadRumbleRequest::Add {
+            rumble_requests.write(GamepadRumbleRequest::Add {
                 gamepad: entity,
                 intensity: GamepadRumbleIntensity {
                     // intensity low-frequency motor, usually on the left-hand side
@@ -64,7 +64,7 @@ fn gamepad_system(
 
         if gamepad.just_pressed(GamepadButton::Start) {
             info!("Start button: Interrupt the current rumble");
-            rumble_requests.send(GamepadRumbleRequest::Stop { gamepad: entity });
+            rumble_requests.write(GamepadRumbleRequest::Stop { gamepad: entity });
         }
     }
 }
diff --git a/examples/ui/size_constraints.rs b/examples/ui/size_constraints.rs
index d3e608ca2..95b000866 100644
--- a/examples/ui/size_constraints.rs
+++ b/examples/ui/size_constraints.rs
@@ -269,7 +269,7 @@ fn update_buttons(
     for (button_id, interaction, constraint, value) in button_query.iter_mut() {
         match interaction {
             Interaction::Pressed => {
-                button_activated_event.send(ButtonActivatedEvent(button_id));
+                button_activated_event.write(ButtonActivatedEvent(button_id));
                 match constraint {
                     Constraint::FlexBasis => {
                         bar_node.flex_basis = value.0;
diff --git a/examples/window/low_power.rs b/examples/window/low_power.rs
index 8ec2e657f..cc75c9df6 100644
--- a/examples/window/low_power.rs
+++ b/examples/window/low_power.rs
@@ -87,7 +87,7 @@ fn update_winit(
             // when there are no inputs, so you send redraw requests while the animation is playing.
             // Note that in this example the RequestRedraw winit event will make the app run in the same
             // way as continuous
-            redraw_request_events.send(RequestRedraw);
+            redraw_request_events.write(RequestRedraw);
             WinitSettings::desktop_app()
         }
         ApplicationWithWakeUp => {
@@ -184,7 +184,7 @@ pub(crate) mod test_setup {
             Camera3d::default(),
             Transform::from_xyz(-2.0, 2.0, 2.0).looking_at(Vec3::ZERO, Vec3::Y),
         ));
-        event.send(RequestRedraw);
+        event.write(RequestRedraw);
         commands
             .spawn((
                 Text::default(),
diff --git a/tests/how_to_test_systems.rs b/tests/how_to_test_systems.rs
index 660d45749..63a38bc99 100644
--- a/tests/how_to_test_systems.rs
+++ b/tests/how_to_test_systems.rs
@@ -27,7 +27,7 @@ fn despawn_dead_enemies(
     for (entity, enemy) in &enemies {
         if enemy.hit_points == 0 {
             commands.entity(entity).despawn();
-            dead_enemies.send(EnemyDied(enemy.score_value));
+            dead_enemies.write(EnemyDied(enemy.score_value));
         }
     }
 }
