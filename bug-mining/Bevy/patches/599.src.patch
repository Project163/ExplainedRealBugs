diff --git a/crates/bevy_asset/src/asset_changed.rs b/crates/bevy_asset/src/asset_changed.rs
index b7902587d..9aafc157f 100644
--- a/crates/bevy_asset/src/asset_changed.rs
+++ b/crates/bevy_asset/src/asset_changed.rs
@@ -280,7 +280,7 @@ unsafe impl<A: AsAssetId> QueryFilter for AssetChanged<A> {
         entity: Entity,
         table_row: TableRow,
     ) -> bool {
-        fetch.inner.as_mut().map_or(false, |inner| {
+        fetch.inner.as_mut().is_some_and(|inner| {
             // SAFETY: We delegate to the inner `fetch` for `A`
             unsafe {
                 let handle = <&A>::fetch(inner, entity, table_row);
diff --git a/crates/bevy_ecs/macros/src/query_data.rs b/crates/bevy_ecs/macros/src/query_data.rs
index 3f198b1ad..972f7e33b 100644
--- a/crates/bevy_ecs/macros/src/query_data.rs
+++ b/crates/bevy_ecs/macros/src/query_data.rs
@@ -36,10 +36,10 @@ pub fn derive_query_data_impl(input: TokenStream) -> TokenStream {
 
     let mut attributes = QueryDataAttributes::default();
     for attr in &ast.attrs {
-        if !attr
+        if attr
             .path()
             .get_ident()
-            .map_or(false, |ident| ident == QUERY_DATA_ATTRIBUTE_NAME)
+            .is_none_or(|ident| ident != QUERY_DATA_ATTRIBUTE_NAME)
         {
             continue;
         }
@@ -382,7 +382,7 @@ fn read_world_query_field_info(field: &Field) -> syn::Result<QueryDataFieldInfo>
         if attr
             .path()
             .get_ident()
-            .map_or(false, |ident| ident == QUERY_DATA_ATTRIBUTE_NAME)
+            .is_some_and(|ident| ident == QUERY_DATA_ATTRIBUTE_NAME)
         {
             return Err(syn::Error::new_spanned(
                 attr,
diff --git a/crates/bevy_ecs/src/entity/mod.rs b/crates/bevy_ecs/src/entity/mod.rs
index cf2370d1c..758085aa9 100644
--- a/crates/bevy_ecs/src/entity/mod.rs
+++ b/crates/bevy_ecs/src/entity/mod.rs
@@ -804,7 +804,7 @@ impl Entities {
     // not reallocated since the generation is incremented in `free`
     pub fn contains(&self, entity: Entity) -> bool {
         self.resolve_from_id(entity.index())
-            .map_or(false, |e| e.generation() == entity.generation())
+            .is_some_and(|e| e.generation() == entity.generation())
     }
 
     /// Clears all [`Entity`] from the World.
diff --git a/crates/bevy_ecs/src/query/builder.rs b/crates/bevy_ecs/src/query/builder.rs
index af1af7749..aeb328afe 100644
--- a/crates/bevy_ecs/src/query/builder.rs
+++ b/crates/bevy_ecs/src/query/builder.rs
@@ -78,7 +78,7 @@ impl<'w, D: QueryData, F: QueryFilter> QueryBuilder<'w, D, F> {
             self.world()
                 .components()
                 .get_info(component_id)
-                .map_or(false, |info| info.storage_type() == StorageType::Table)
+                .is_some_and(|info| info.storage_type() == StorageType::Table)
         };
 
         #[allow(deprecated)]
diff --git a/crates/bevy_ecs/src/schedule/stepping.rs b/crates/bevy_ecs/src/schedule/stepping.rs
index ed796c29e..87929c616 100644
--- a/crates/bevy_ecs/src/schedule/stepping.rs
+++ b/crates/bevy_ecs/src/schedule/stepping.rs
@@ -168,14 +168,8 @@ impl Stepping {
         if self.action == Action::RunAll {
             return None;
         }
-        let label = match self.schedule_order.get(self.cursor.schedule) {
-            None => return None,
-            Some(label) => label,
-        };
-        let state = match self.schedule_states.get(label) {
-            None => return None,
-            Some(state) => state,
-        };
+        let label = self.schedule_order.get(self.cursor.schedule)?;
+        let state = self.schedule_states.get(label)?;
         state
             .node_ids
             .get(self.cursor.system)
diff --git a/crates/bevy_render/src/view/visibility/mod.rs b/crates/bevy_render/src/view/visibility/mod.rs
index 3e991a6cb..2805c3114 100644
--- a/crates/bevy_render/src/view/visibility/mod.rs
+++ b/crates/bevy_render/src/view/visibility/mod.rs
@@ -424,7 +424,7 @@ fn visibility_propagate_system(
             // fall back to true if no parent is found or parent lacks components
             Visibility::Inherited => parent
                 .and_then(|p| visibility_query.get(p.get()).ok())
-                .map_or(true, |(_, x)| x.get()),
+                .is_none_or(|(_, x)| x.get()),
         };
         let (_, mut inherited_visibility) = visibility_query
             .get_mut(entity)
diff --git a/crates/bevy_text/src/font_atlas_set.rs b/crates/bevy_text/src/font_atlas_set.rs
index 60374daf4..e830295b4 100644
--- a/crates/bevy_text/src/font_atlas_set.rs
+++ b/crates/bevy_text/src/font_atlas_set.rs
@@ -92,9 +92,7 @@ impl FontAtlasSet {
     pub fn has_glyph(&self, cache_key: cosmic_text::CacheKey, font_size: &FontAtlasKey) -> bool {
         self.font_atlases
             .get(font_size)
-            .map_or(false, |font_atlas| {
-                font_atlas.iter().any(|atlas| atlas.has_glyph(cache_key))
-            })
+            .is_some_and(|font_atlas| font_atlas.iter().any(|atlas| atlas.has_glyph(cache_key)))
     }
 
     /// Adds the given subpixel-offset glyph to the [`FontAtlas`]es in this set
