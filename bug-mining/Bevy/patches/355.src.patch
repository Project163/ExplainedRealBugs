diff --git a/crates/bevy_reflect/src/impls/std.rs b/crates/bevy_reflect/src/impls/std.rs
index 7aae12a69..6320090e6 100644
--- a/crates/bevy_reflect/src/impls/std.rs
+++ b/crates/bevy_reflect/src/impls/std.rs
@@ -107,6 +107,7 @@ impl_reflect_value!(::core::ops::RangeFrom<T: Clone + Send + Sync>());
 impl_reflect_value!(::core::ops::RangeTo<T: Clone + Send + Sync>());
 impl_reflect_value!(::core::ops::RangeToInclusive<T: Clone + Send + Sync>());
 impl_reflect_value!(::core::ops::RangeFull());
+impl_reflect_value!(::std::ops::Bound<T: Clone + Send + Sync>());
 impl_reflect_value!(::bevy_utils::Duration(
     Debug,
     Hash,
diff --git a/crates/bevy_reflect/src/lib.rs b/crates/bevy_reflect/src/lib.rs
index fca875b70..941105a85 100644
--- a/crates/bevy_reflect/src/lib.rs
+++ b/crates/bevy_reflect/src/lib.rs
@@ -2922,26 +2922,6 @@ bevy_reflect::tests::Test {
         );
     }
 
-    #[test]
-    fn should_reflect_external_crate_type() {
-        // This test relies on the external type not implementing `Reflect`,
-        // so let's just double-check that it does not
-        assert_not_impl_all!(std::collections::Bound<i32>: Reflect);
-
-        #[reflect_remote(std::collections::Bound<T>)]
-        enum MyBound<T> {
-            Included(T),
-            Excluded(T),
-            Unbounded,
-        }
-
-        #[derive(Reflect)]
-        struct MyType {
-            #[reflect(remote = MyBound<String>)]
-            bound: std::collections::Bound<String>,
-        }
-    }
-
     #[cfg(feature = "glam")]
     mod glam {
         use super::*;
