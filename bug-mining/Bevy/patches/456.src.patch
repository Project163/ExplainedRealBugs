diff --git a/crates/bevy_animation/Cargo.toml b/crates/bevy_animation/Cargo.toml
index d507f0334..33cec8775 100644
--- a/crates/bevy_animation/Cargo.toml
+++ b/crates/bevy_animation/Cargo.toml
@@ -27,7 +27,6 @@ bevy_utils = { path = "../bevy_utils", version = "0.15.0-dev" }
 bevy_ecs = { path = "../bevy_ecs", version = "0.15.0-dev" }
 bevy_transform = { path = "../bevy_transform", version = "0.15.0-dev" }
 bevy_hierarchy = { path = "../bevy_hierarchy", version = "0.15.0-dev" }
-bevy_text = { path = "../bevy_text", version = "0.15.0-dev" }
 
 # other
 petgraph = { version = "0.6", features = ["serde-1"] }
diff --git a/crates/bevy_animation/src/animation_curves.rs b/crates/bevy_animation/src/animation_curves.rs
index 82d84ee42..c0101ad5b 100644
--- a/crates/bevy_animation/src/animation_curves.rs
+++ b/crates/bevy_animation/src/animation_curves.rs
@@ -104,20 +104,20 @@ use crate::{
 /// You can implement this trait on a unit struct in order to support animating
 /// custom components other than transforms and morph weights. Use that type in
 /// conjunction with [`AnimatableCurve`] (and perhaps [`AnimatableKeyframeCurve`]
-/// to define the animation itself). For example, in order to animate font size of a
-/// text section from 24 pt. to 80 pt., you might use:
+/// to define the animation itself).
+/// For example, in order to animate field of view, you might use:
 ///
 ///     # use bevy_animation::prelude::AnimatableProperty;
 ///     # use bevy_reflect::Reflect;
-///     # use bevy_text::Text;
+///     # use bevy_render::camera::PerspectiveProjection;
 ///     #[derive(Reflect)]
-///     struct FontSizeProperty;
+///     struct FieldOfViewProperty;
 ///
-///     impl AnimatableProperty for FontSizeProperty {
-///         type Component = Text;
+///     impl AnimatableProperty for FieldOfViewProperty {
+///         type Component = PerspectiveProjection;
 ///         type Property = f32;
 ///         fn get_mut(component: &mut Self::Component) -> Option<&mut Self::Property> {
-///             Some(&mut component.sections.get_mut(0)?.style.font_size)
+///             Some(&mut component.fov)
 ///         }
 ///     }
 ///
@@ -127,15 +127,15 @@ use crate::{
 ///     # use bevy_animation::prelude::{AnimatableProperty, AnimatableKeyframeCurve, AnimatableCurve};
 ///     # use bevy_core::Name;
 ///     # use bevy_reflect::Reflect;
-///     # use bevy_text::Text;
+///     # use bevy_render::camera::PerspectiveProjection;
 ///     # let animation_target_id = AnimationTargetId::from(&Name::new("Test"));
 ///     # #[derive(Reflect)]
-///     # struct FontSizeProperty;
-///     # impl AnimatableProperty for FontSizeProperty {
-///     #     type Component = Text;
+///     # struct FieldOfViewProperty;
+///     # impl AnimatableProperty for FieldOfViewProperty {
+///     #     type Component = PerspectiveProjection;
 ///     #     type Property = f32;
 ///     #     fn get_mut(component: &mut Self::Component) -> Option<&mut Self::Property> {
-///     #         Some(&mut component.sections.get_mut(0)?.style.font_size)
+///     #         Some(&mut component.fov)
 ///     #     }
 ///     # }
 ///     let mut animation_clip = AnimationClip::default();
@@ -143,18 +143,18 @@ use crate::{
 ///         animation_target_id,
 ///         AnimatableKeyframeCurve::new(
 ///             [
-///                 (0.0, 24.0),
-///                 (1.0, 80.0),
+///                 (0.0, core::f32::consts::PI / 4.0),
+///                 (1.0, core::f32::consts::PI / 3.0),
 ///             ]
 ///         )
-///         .map(AnimatableCurve::<FontSizeProperty, _>::from_curve)
+///         .map(AnimatableCurve::<FieldOfViewProperty, _>::from_curve)
 ///         .expect("Failed to create font size curve")
 ///     );
 ///
 /// Here, the use of [`AnimatableKeyframeCurve`] creates a curve out of the given keyframe time-value
 /// pairs, using the [`Animatable`] implementation of `f32` to interpolate between them. The
-/// invocation of [`AnimatableCurve::from_curve`] with `FontSizeProperty` indicates that the `f32`
-/// output from that curve is to be used to animate the font size of a `Text` component (as
+/// invocation of [`AnimatableCurve::from_curve`] with `FieldOfViewProperty` indicates that the `f32`
+/// output from that curve is to be used to animate the font size of a `PerspectiveProjection` component (as
 /// configured above).
 ///
 /// [`AnimationClip`]: crate::AnimationClip
