diff --git a/crates/bevy_reflect/derive/src/derive_data.rs b/crates/bevy_reflect/derive/src/derive_data.rs
index bcff582a4..eeb6c6d24 100644
--- a/crates/bevy_reflect/derive/src/derive_data.rs
+++ b/crates/bevy_reflect/derive/src/derive_data.rs
@@ -937,7 +937,10 @@ impl<'a> ReflectEnum<'a> {
             }
         };
 
-        let body = if self.meta.is_remote_wrapper() {
+        let body = if variant_patterns.is_empty() {
+            // enum variant is empty, so &self will never exist
+            quote!(unreachable!())
+        } else if self.meta.is_remote_wrapper() {
             quote! {
                 let #this = <Self as #bevy_reflect_path::ReflectRemote>::as_remote(self);
                 #FQResult::Ok(#bevy_reflect_path::__macro_exports::alloc_utils::Box::new(<Self as #bevy_reflect_path::ReflectRemote>::into_wrapper(#inner)))
diff --git a/crates/bevy_reflect/src/lib.rs b/crates/bevy_reflect/src/lib.rs
index c3ad8c6bd..64d07513e 100644
--- a/crates/bevy_reflect/src/lib.rs
+++ b/crates/bevy_reflect/src/lib.rs
@@ -2643,6 +2643,14 @@ bevy_reflect::tests::Test {
         assert_not_impl_all!(Foo<Baz>: Reflect);
     }
 
+    #[test]
+    fn should_allow_empty_enums() {
+        #[derive(Reflect)]
+        enum Empty {}
+
+        assert_impl_all!(Empty: Reflect);
+    }
+
     #[test]
     fn recursive_typed_storage_does_not_hang() {
         #[derive(Reflect)]
