diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index d8a6c2de6..a0c63e6d1 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -170,6 +170,8 @@ jobs:
         with:
           target: wasm32-unknown-unknown
       - name: Check wasm
+        env:
+          RUSTFLAGS: "-D warnings"
         run: cargo check --target wasm32-unknown-unknown
 
   build-wasm-atomics:
@@ -195,7 +197,7 @@ jobs:
       - name: Check wasm
         run: cargo check --target wasm32-unknown-unknown -Z build-std=std,panic_abort
         env:
-          RUSTFLAGS: "-C target-feature=+atomics,+bulk-memory"
+          RUSTFLAGS: "-C target-feature=+atomics,+bulk-memory -D warnings"
 
   markdownlint:
     runs-on: ubuntu-latest
@@ -319,7 +321,7 @@ jobs:
         run: cargo run -p ci -- doc
         env:
           CARGO_INCREMENTAL: 0
-          RUSTFLAGS: "-C debuginfo=0"
+          RUSTFLAGS: "-C debuginfo=0 -D warnings"
       # This currently report a lot of false positives
       # Enable it again once it's fixed - https://github.com/bevyengine/bevy/issues/1983
       # - name: Installs cargo-deadlinks
diff --git a/crates/bevy_app/src/task_pool_plugin.rs b/crates/bevy_app/src/task_pool_plugin.rs
index 5623371da..a4bf9d12d 100644
--- a/crates/bevy_app/src/task_pool_plugin.rs
+++ b/crates/bevy_app/src/task_pool_plugin.rs
@@ -6,14 +6,16 @@
     )
 )]
 
-use crate::{App, Last, Plugin};
+use crate::{App, Plugin};
 
 use alloc::string::ToString;
-use bevy_ecs::prelude::*;
 use bevy_tasks::{AsyncComputeTaskPool, ComputeTaskPool, IoTaskPool, TaskPoolBuilder};
 use core::{fmt::Debug, marker::PhantomData};
 use log::trace;
 
+#[cfg(not(target_arch = "wasm32"))]
+use {crate::Last, bevy_ecs::prelude::NonSend};
+
 #[cfg(feature = "portable-atomic")]
 use portable_atomic_util::Arc;
 
@@ -187,6 +189,7 @@ impl TaskPoolOptions {
             remaining_threads = remaining_threads.saturating_sub(io_threads);
 
             IoTaskPool::get_or_init(|| {
+                #[cfg_attr(target_arch = "wasm32", expect(unused_mut))]
                 let mut builder = TaskPoolBuilder::default()
                     .num_threads(io_threads)
                     .thread_name("IO Task Pool".to_string());
@@ -215,6 +218,7 @@ impl TaskPoolOptions {
             remaining_threads = remaining_threads.saturating_sub(async_compute_threads);
 
             AsyncComputeTaskPool::get_or_init(|| {
+                #[cfg_attr(target_arch = "wasm32", expect(unused_mut))]
                 let mut builder = TaskPoolBuilder::default()
                     .num_threads(async_compute_threads)
                     .thread_name("Async Compute Task Pool".to_string());
@@ -243,6 +247,7 @@ impl TaskPoolOptions {
             trace!("Compute Threads: {}", compute_threads);
 
             ComputeTaskPool::get_or_init(|| {
+                #[cfg_attr(target_arch = "wasm32", expect(unused_mut))]
                 let mut builder = TaskPoolBuilder::default()
                     .num_threads(compute_threads)
                     .thread_name("Compute Task Pool".to_string());
diff --git a/crates/bevy_ecs/src/event/iterators.rs b/crates/bevy_ecs/src/event/iterators.rs
index 956072715..b2f9421aa 100644
--- a/crates/bevy_ecs/src/event/iterators.rs
+++ b/crates/bevy_ecs/src/event/iterators.rs
@@ -145,6 +145,7 @@ pub struct EventParIter<'a, E: Event> {
     reader: &'a mut EventCursor<E>,
     slices: [&'a [EventInstance<E>]; 2],
     batching_strategy: BatchingStrategy,
+    #[cfg(not(target_arch = "wasm32"))]
     unread: usize,
 }
 
@@ -170,6 +171,7 @@ impl<'a, E: Event> EventParIter<'a, E> {
             reader,
             slices: [a, b],
             batching_strategy: BatchingStrategy::default(),
+            #[cfg(not(target_arch = "wasm32"))]
             unread: unread_count,
         }
     }
@@ -206,6 +208,10 @@ impl<'a, E: Event> EventParIter<'a, E> {
     /// initialized and run from the ECS scheduler, this should never panic.
     ///
     /// [`ComputeTaskPool`]: bevy_tasks::ComputeTaskPool
+    #[cfg_attr(
+        target_arch = "wasm32",
+        expect(unused_mut, reason = "not mutated on this target")
+    )]
     pub fn for_each_with_id<FN: Fn(&'a E, EventId<E>) + Send + Sync + Clone>(mut self, func: FN) {
         #[cfg(target_arch = "wasm32")]
         {
diff --git a/crates/bevy_ecs/src/event/mut_iterators.rs b/crates/bevy_ecs/src/event/mut_iterators.rs
index f8f32236e..f1434db06 100644
--- a/crates/bevy_ecs/src/event/mut_iterators.rs
+++ b/crates/bevy_ecs/src/event/mut_iterators.rs
@@ -148,6 +148,7 @@ pub struct EventMutParIter<'a, E: Event> {
     mutator: &'a mut EventCursor<E>,
     slices: [&'a mut [EventInstance<E>]; 2],
     batching_strategy: BatchingStrategy,
+    #[cfg(not(target_arch = "wasm32"))]
     unread: usize,
 }
 
@@ -171,6 +172,7 @@ impl<'a, E: Event> EventMutParIter<'a, E> {
             mutator,
             slices: [a, b],
             batching_strategy: BatchingStrategy::default(),
+            #[cfg(not(target_arch = "wasm32"))]
             unread: unread_count,
         }
     }
@@ -207,6 +209,10 @@ impl<'a, E: Event> EventMutParIter<'a, E> {
     /// initialized and run from the ECS scheduler, this should never panic.
     ///
     /// [`ComputeTaskPool`]: bevy_tasks::ComputeTaskPool
+    #[cfg_attr(
+        target_arch = "wasm32",
+        expect(unused_mut, reason = "not mutated on this target")
+    )]
     pub fn for_each_with_id<FN: Fn(&'a mut E, EventId<E>) + Send + Sync + Clone>(
         mut self,
         func: FN,
diff --git a/crates/bevy_render/src/renderer/mod.rs b/crates/bevy_render/src/renderer/mod.rs
index 85213476b..c26bcfe49 100644
--- a/crates/bevy_render/src/renderer/mod.rs
+++ b/crates/bevy_render/src/renderer/mod.rs
@@ -2,6 +2,7 @@ mod graph_runner;
 mod render_device;
 
 use bevy_derive::{Deref, DerefMut};
+#[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
 use bevy_tasks::ComputeTaskPool;
 use bevy_utils::tracing::{error, info, info_span, warn};
 pub use graph_runner::*;
@@ -379,6 +380,7 @@ pub struct RenderContext<'w> {
     render_device: RenderDevice,
     command_encoder: Option<CommandEncoder>,
     command_buffer_queue: Vec<QueuedCommandBuffer<'w>>,
+    #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
     force_serial: bool,
     diagnostics_recorder: Option<Arc<DiagnosticsRecorder>>,
 }
@@ -387,6 +389,7 @@ impl<'w> RenderContext<'w> {
     /// Creates a new [`RenderContext`] from a [`RenderDevice`].
     pub fn new(
         render_device: RenderDevice,
+        #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
         adapter_info: AdapterInfo,
         diagnostics_recorder: Option<DiagnosticsRecorder>,
     ) -> Self {
@@ -394,7 +397,10 @@ impl<'w> RenderContext<'w> {
         #[cfg(target_os = "windows")]
         let force_serial =
             adapter_info.driver.contains("AMD") && adapter_info.backend == wgpu::Backend::Vulkan;
-        #[cfg(not(target_os = "windows"))]
+        #[cfg(not(any(
+            target_os = "windows",
+            all(target_arch = "wasm32", target_feature = "atomics")
+        )))]
         let force_serial = {
             drop(adapter_info);
             false
@@ -404,6 +410,7 @@ impl<'w> RenderContext<'w> {
             render_device,
             command_encoder: None,
             command_buffer_queue: Vec::new(),
+            #[cfg(not(all(target_arch = "wasm32", target_feature = "atomics")))]
             force_serial,
             diagnostics_recorder: diagnostics_recorder.map(Arc::new),
         }
diff --git a/crates/bevy_tasks/src/executor.rs b/crates/bevy_tasks/src/executor.rs
index 5d6eca4f8..e545daf84 100644
--- a/crates/bevy_tasks/src/executor.rs
+++ b/crates/bevy_tasks/src/executor.rs
@@ -14,7 +14,7 @@ use core::{
 };
 use derive_more::{Deref, DerefMut};
 
-#[cfg(feature = "multi_threaded")]
+#[cfg(all(feature = "multi_threaded", not(target_arch = "wasm32")))]
 pub use async_task::FallibleTask;
 
 #[cfg(feature = "async_executor")]
