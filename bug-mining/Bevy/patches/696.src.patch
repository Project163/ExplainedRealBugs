diff --git a/.github/workflows/ci.yml b/.github/workflows/ci.yml
index b0704a239..99e3edc98 100644
--- a/.github/workflows/ci.yml
+++ b/.github/workflows/ci.yml
@@ -335,6 +335,7 @@ jobs:
     timeout-minutes: 30
     steps:
       - uses: actions/checkout@v4
+      - uses: dtolnay/rust-toolchain@stable
       - name: check for missing metadata
         id: missing-metadata
         run: cargo run -p build-templated-pages -- check-missing examples
@@ -369,6 +370,7 @@ jobs:
     needs: check-missing-examples-in-docs
     steps:
       - uses: actions/checkout@v4
+      - uses: dtolnay/rust-toolchain@stable
       - name: check for missing features
         id: missing-features
         run: cargo run -p build-templated-pages -- check-missing features
@@ -412,6 +414,7 @@ jobs:
             ~/.cargo/git/db/
             target/
           key: ${{ runner.os }}-cargo-msrv-${{ hashFiles('**/Cargo.toml') }}
+      - uses: dtolnay/rust-toolchain@stable
       - name: get MSRV
         id: msrv
         run: |
diff --git a/Cargo.toml b/Cargo.toml
index c00d15190..9e507f7ec 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 categories = ["game-engines", "graphics", "gui", "rendering"]
 description = "A refreshingly simple data-driven game engine and app framework"
 exclude = ["assets/", "tools/", ".github/", "crates/", "examples/wasm/assets/"]
@@ -10,7 +10,7 @@ keywords = ["game", "engine", "gamedev", "graphics", "bevy"]
 license = "MIT OR Apache-2.0"
 repository = "https://github.com/bevyengine/bevy"
 documentation = "https://docs.rs/bevy"
-rust-version = "1.83.0"
+rust-version = "1.85.0"
 
 [workspace]
 resolver = "2"
diff --git a/benches/Cargo.toml b/benches/Cargo.toml
index 4fc852d1a..f5faeec23 100644
--- a/benches/Cargo.toml
+++ b/benches/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "benches"
-edition = "2021"
+edition = "2024"
 description = "Benchmarks that test Bevy's performance"
 publish = false
 license = "MIT OR Apache-2.0"
diff --git a/benches/benches/bevy_ecs/change_detection.rs b/benches/benches/bevy_ecs/change_detection.rs
index 84a8d4c39..92f3251ab 100644
--- a/benches/benches/bevy_ecs/change_detection.rs
+++ b/benches/benches/bevy_ecs/change_detection.rs
@@ -95,7 +95,7 @@ fn all_added_detection_generic<T: Component + Default>(group: &mut BenchGroup, e
                     let query = generic_filter_query::<Added<T>>(&mut world);
                     (world, query)
                 },
-                |(ref mut world, ref mut query)| {
+                |(world, query)| {
                     let mut count = 0;
                     for entity in query.iter(world) {
                         black_box(entity);
@@ -143,7 +143,7 @@ fn all_changed_detection_generic<T: Component<Mutability = Mutable> + Default +
                     let query = generic_filter_query::<Changed<T>>(&mut world);
                     (world, query)
                 },
-                |(ref mut world, ref mut query)| {
+                |(world, query)| {
                     let mut count = 0;
                     for entity in query.iter(world) {
                         black_box(entity);
@@ -196,7 +196,7 @@ fn few_changed_detection_generic<T: Component<Mutability = Mutable> + Default +
                     let query = generic_filter_query::<Changed<T>>(&mut world);
                     (world, query)
                 },
-                |(ref mut world, ref mut query)| {
+                |(world, query)| {
                     for entity in query.iter(world) {
                         black_box(entity);
                     }
@@ -237,7 +237,7 @@ fn none_changed_detection_generic<T: Component<Mutability = Mutable> + Default>(
                     let query = generic_filter_query::<Changed<T>>(&mut world);
                     (world, query)
                 },
-                |(ref mut world, ref mut query)| {
+                |(world, query)| {
                     let mut count = 0;
                     for entity in query.iter(world) {
                         black_box(entity);
@@ -343,7 +343,7 @@ fn multiple_archetype_none_changed_detection_generic<
                     let query = generic_filter_query::<Changed<T>>(&mut world);
                     (world, query)
                 },
-                |(ref mut world, ref mut query)| {
+                |(world, query)| {
                     let mut count = 0;
                     for entity in query.iter(world) {
                         black_box(entity);
diff --git a/benches/benches/bevy_ecs/components/add_remove.rs b/benches/benches/bevy_ecs/components/add_remove.rs
index b381ccb43..9b654e7a8 100644
--- a/benches/benches/bevy_ecs/components/add_remove.rs
+++ b/benches/benches/bevy_ecs/components/add_remove.rs
@@ -12,7 +12,7 @@ impl Benchmark {
         let mut world = World::default();
 
         let entities = world
-            .spawn_batch(core::iter::repeat(A(0.)).take(10000))
+            .spawn_batch(core::iter::repeat_n(A(0.), 10_000))
             .collect();
         Self(world, entities)
     }
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple.rs b/benches/benches/bevy_ecs/iteration/iter_simple.rs
index 1fc86f508..14cca6908 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple.rs
@@ -19,15 +19,15 @@ impl<'w> Benchmark<'w> {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Position(Vec3::X),
                 Rotation(Vec3::X),
                 Velocity(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         let query = world.query::<(&Velocity, &mut Position)>();
         Self(world, query)
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_foreach.rs b/benches/benches/bevy_ecs/iteration/iter_simple_foreach.rs
index f0a41d18b..19396e95b 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_foreach.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_foreach.rs
@@ -19,15 +19,15 @@ impl<'w> Benchmark<'w> {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Position(Vec3::X),
                 Rotation(Vec3::X),
                 Velocity(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         let query = world.query::<(&Velocity, &mut Position)>();
         Self(world, query)
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_foreach_sparse_set.rs b/benches/benches/bevy_ecs/iteration/iter_simple_foreach_sparse_set.rs
index 0075c2706..1e0db505c 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_foreach_sparse_set.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_foreach_sparse_set.rs
@@ -21,15 +21,15 @@ impl<'w> Benchmark<'w> {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Position(Vec3::X),
                 Rotation(Vec3::X),
                 Velocity(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         let query = world.query::<(&Velocity, &mut Position)>();
         Self(world, query)
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_foreach_wide.rs b/benches/benches/bevy_ecs/iteration/iter_simple_foreach_wide.rs
index 7dbd11d1e..505d624eb 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_foreach_wide.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_foreach_wide.rs
@@ -33,8 +33,8 @@ impl<'w> Benchmark<'w> {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Rotation(Vec3::X),
                 Position::<0>(Vec3::X),
@@ -47,9 +47,9 @@ impl<'w> Benchmark<'w> {
                 Velocity::<3>(Vec3::X),
                 Position::<4>(Vec3::X),
                 Velocity::<4>(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         let query = world.query();
         Self(world, query)
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_foreach_wide_sparse_set.rs b/benches/benches/bevy_ecs/iteration/iter_simple_foreach_wide_sparse_set.rs
index f520ffde4..88b58be0f 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_foreach_wide_sparse_set.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_foreach_wide_sparse_set.rs
@@ -35,8 +35,8 @@ impl<'w> Benchmark<'w> {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Rotation(Vec3::X),
                 Position::<0>(Vec3::X),
@@ -49,9 +49,9 @@ impl<'w> Benchmark<'w> {
                 Velocity::<3>(Vec3::X),
                 Position::<4>(Vec3::X),
                 Velocity::<4>(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         let query = world.query();
         Self(world, query)
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_sparse_set.rs b/benches/benches/bevy_ecs/iteration/iter_simple_sparse_set.rs
index e4ba37594..ed1c531c1 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_sparse_set.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_sparse_set.rs
@@ -21,15 +21,15 @@ impl<'w> Benchmark<'w> {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Position(Vec3::X),
                 Rotation(Vec3::X),
                 Velocity(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         let query = world.query::<(&Velocity, &mut Position)>();
         Self(world, query)
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_system.rs b/benches/benches/bevy_ecs/iteration/iter_simple_system.rs
index 18918ee23..2b6e82872 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_system.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_system.rs
@@ -19,15 +19,15 @@ impl Benchmark {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Position(Vec3::X),
                 Rotation(Vec3::X),
                 Velocity(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         fn query_system(mut query: Query<(&Velocity, &mut Position)>) {
             for (velocity, mut position) in &mut query {
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_wide.rs b/benches/benches/bevy_ecs/iteration/iter_simple_wide.rs
index 7d013b3bf..dccd1fe8b 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_wide.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_wide.rs
@@ -33,8 +33,8 @@ impl<'w> Benchmark<'w> {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Rotation(Vec3::X),
                 Position::<0>(Vec3::X),
@@ -47,9 +47,9 @@ impl<'w> Benchmark<'w> {
                 Velocity::<3>(Vec3::X),
                 Position::<4>(Vec3::X),
                 Velocity::<4>(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         let query = world.query();
         Self(world, query)
diff --git a/benches/benches/bevy_ecs/iteration/iter_simple_wide_sparse_set.rs b/benches/benches/bevy_ecs/iteration/iter_simple_wide_sparse_set.rs
index 28a6dbd85..49677dc1b 100644
--- a/benches/benches/bevy_ecs/iteration/iter_simple_wide_sparse_set.rs
+++ b/benches/benches/bevy_ecs/iteration/iter_simple_wide_sparse_set.rs
@@ -35,8 +35,8 @@ impl<'w> Benchmark<'w> {
     pub fn new() -> Self {
         let mut world = World::new();
 
-        world.spawn_batch(
-            core::iter::repeat((
+        world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Rotation(Vec3::X),
                 Position::<0>(Vec3::X),
@@ -49,9 +49,9 @@ impl<'w> Benchmark<'w> {
                 Velocity::<3>(Vec3::X),
                 Position::<4>(Vec3::X),
                 Velocity::<4>(Vec3::X),
-            ))
-            .take(10_000),
-        );
+            ),
+            10_000,
+        ));
 
         let query = world.query();
         Self(world, query)
diff --git a/benches/benches/bevy_ecs/iteration/par_iter_simple.rs b/benches/benches/bevy_ecs/iteration/par_iter_simple.rs
index 971598005..92259cb98 100644
--- a/benches/benches/bevy_ecs/iteration/par_iter_simple.rs
+++ b/benches/benches/bevy_ecs/iteration/par_iter_simple.rs
@@ -30,15 +30,15 @@ impl<'w> Benchmark<'w> {
 
         let mut world = World::new();
 
-        let iter = world.spawn_batch(
-            core::iter::repeat((
+        let iter = world.spawn_batch(core::iter::repeat_n(
+            (
                 Transform(Mat4::from_scale(Vec3::ONE)),
                 Position(Vec3::X),
                 Rotation(Vec3::X),
                 Velocity(Vec3::X),
-            ))
-            .take(100_000),
-        );
+            ),
+            100_000,
+        ));
         let entities = iter.into_iter().collect::<Vec<Entity>>();
         for i in 0..fragment {
             let mut e = world.entity_mut(entities[i as usize]);
diff --git a/benches/benches/bevy_ecs/world/entity_hash.rs b/benches/benches/bevy_ecs/world/entity_hash.rs
index 5e92443bf..af7987bb0 100644
--- a/benches/benches/bevy_ecs/world/entity_hash.rs
+++ b/benches/benches/bevy_ecs/world/entity_hash.rs
@@ -11,16 +11,16 @@ fn make_entity(rng: &mut impl Rng, size: usize) -> Entity {
     // * For ids, half are in [0, size), half are unboundedly larger.
     // * For generations, half are in [1, 3), half are unboundedly larger.
 
-    let x: f64 = rng.gen();
+    let x: f64 = rng.r#gen();
     let id = -(1.0 - x).log2() * (size as f64);
-    let x: f64 = rng.gen();
-    let gen = 1.0 + -(1.0 - x).log2() * 2.0;
+    let x: f64 = rng.r#gen();
+    let generation = 1.0 + -(1.0 - x).log2() * 2.0;
 
     // this is not reliable, but we're internal so a hack is ok
-    let bits = ((gen as u64) << 32) | (id as u64);
+    let bits = ((generation as u64) << 32) | (id as u64);
     let e = Entity::from_bits(bits);
     assert_eq!(e.index(), id as u32);
-    assert_eq!(e.generation(), gen as u32);
+    assert_eq!(e.generation(), generation as u32);
     e
 }
 
diff --git a/benches/benches/bevy_reflect/list.rs b/benches/benches/bevy_reflect/list.rs
index 872c2dd0c..c6c94ac2f 100644
--- a/benches/benches/bevy_reflect/list.rs
+++ b/benches/benches/bevy_reflect/list.rs
@@ -75,8 +75,8 @@ fn concrete_list_apply(criterion: &mut Criterion) {
     let mut group = create_group(criterion, bench!("concrete_list_apply"));
 
     let empty_base = |_: usize| Vec::<u64>::new;
-    let full_base = |size: usize| move || iter::repeat(0).take(size).collect::<Vec<u64>>();
-    let patch = |size: usize| iter::repeat(1).take(size).collect::<Vec<u64>>();
+    let full_base = |size: usize| move || iter::repeat_n(0, size).collect::<Vec<u64>>();
+    let patch = |size: usize| iter::repeat_n(1, size).collect::<Vec<u64>>();
 
     list_apply(&mut group, "empty_base_concrete_patch", empty_base, patch);
 
@@ -103,7 +103,7 @@ fn concrete_list_clone_dynamic(criterion: &mut Criterion) {
             BenchmarkId::from_parameter(size),
             &size,
             |bencher, &size| {
-                let v = iter::repeat(0).take(size).collect::<Vec<_>>();
+                let v = iter::repeat_n(0, size).collect::<Vec<_>>();
 
                 bencher.iter(|| black_box(&v).clone_dynamic());
             },
@@ -123,7 +123,7 @@ fn dynamic_list_push(criterion: &mut Criterion) {
             BenchmarkId::from_parameter(size),
             &size,
             |bencher, &size| {
-                let src = iter::repeat(()).take(size).collect::<Vec<_>>();
+                let src = iter::repeat_n((), size).collect::<Vec<_>>();
                 let dst = DynamicList::default();
 
                 bencher.iter_batched(
@@ -146,8 +146,8 @@ fn dynamic_list_apply(criterion: &mut Criterion) {
     let mut group = create_group(criterion, bench!("dynamic_list_apply"));
 
     let empty_base = |_: usize| || Vec::<u64>::new().clone_dynamic();
-    let full_base = |size: usize| move || iter::repeat(0).take(size).collect::<Vec<u64>>();
-    let patch = |size: usize| iter::repeat(1).take(size).collect::<Vec<u64>>();
+    let full_base = |size: usize| move || iter::repeat_n(0, size).collect::<Vec<u64>>();
+    let patch = |size: usize| iter::repeat_n(1, size).collect::<Vec<u64>>();
 
     list_apply(&mut group, "empty_base_concrete_patch", empty_base, patch);
 
diff --git a/benches/benches/bevy_reflect/map.rs b/benches/benches/bevy_reflect/map.rs
index 4525ed859..cd0ed1884 100644
--- a/benches/benches/bevy_reflect/map.rs
+++ b/benches/benches/bevy_reflect/map.rs
@@ -145,7 +145,7 @@ fn u64_to_n_byte_key(k: u64, n: usize) -> String {
     write!(&mut key, "{}", k).unwrap();
 
     // Pad key to n bytes.
-    key.extend(iter::repeat('\0').take(n - key.len()));
+    key.extend(iter::repeat_n('\0', n - key.len()));
     key
 }
 
diff --git a/crates/bevy_a11y/Cargo.toml b/crates/bevy_a11y/Cargo.toml
index 0037ccf29..4da104062 100644
--- a/crates/bevy_a11y/Cargo.toml
+++ b/crates/bevy_a11y/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_a11y"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides accessibility support for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_animation/Cargo.toml b/crates/bevy_animation/Cargo.toml
index 5b906fed7..a1e890017 100644
--- a/crates/bevy_animation/Cargo.toml
+++ b/crates/bevy_animation/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_animation"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides animation functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_animation/src/graph.rs b/crates/bevy_animation/src/graph.rs
index 1729841f0..146bd8da3 100644
--- a/crates/bevy_animation/src/graph.rs
+++ b/crates/bevy_animation/src/graph.rs
@@ -884,10 +884,10 @@ impl ThreadedAnimationGraph {
 
         self.sorted_edge_ranges.clear();
         self.sorted_edge_ranges
-            .extend(iter::repeat(0..0).take(node_count));
+            .extend(iter::repeat_n(0..0, node_count));
 
         self.computed_masks.clear();
-        self.computed_masks.extend(iter::repeat(0).take(node_count));
+        self.computed_masks.extend(iter::repeat_n(0, node_count));
     }
 
     /// Recursively constructs the [`ThreadedAnimationGraph`] for the subtree
diff --git a/crates/bevy_app/Cargo.toml b/crates/bevy_app/Cargo.toml
index e4fb9748c..d62428abd 100644
--- a/crates/bevy_app/Cargo.toml
+++ b/crates/bevy_app/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_app"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides core App functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_app/src/app.rs b/crates/bevy_app/src/app.rs
index 63b91b5df..9799693af 100644
--- a/crates/bevy_app/src/app.rs
+++ b/crates/bevy_app/src/app.rs
@@ -1435,7 +1435,7 @@ impl Termination for AppExit {
 
 #[cfg(test)]
 mod tests {
-    use core::{iter, marker::PhantomData};
+    use core::marker::PhantomData;
     use std::sync::Mutex;
 
     use bevy_ecs::{
@@ -1659,7 +1659,7 @@ mod tests {
         struct Foo;
 
         let mut app = App::new();
-        app.world_mut().spawn_batch(iter::repeat(Foo).take(5));
+        app.world_mut().spawn_batch(core::iter::repeat_n(Foo, 5));
 
         fn despawn_one_foo(mut commands: Commands, foos: Query<Entity, With<Foo>>) {
             if let Some(e) = foos.iter().next() {
diff --git a/crates/bevy_app/src/panic_handler.rs b/crates/bevy_app/src/panic_handler.rs
index 56d66da72..5a2ae097f 100644
--- a/crates/bevy_app/src/panic_handler.rs
+++ b/crates/bevy_app/src/panic_handler.rs
@@ -11,7 +11,7 @@ use crate::{App, Plugin};
 /// Adds sensible panic handlers to Apps. This plugin is part of the `DefaultPlugins`. Adding
 /// this plugin will setup a panic hook appropriate to your target platform:
 /// * On Wasm, uses [`console_error_panic_hook`](https://crates.io/crates/console_error_panic_hook), logging
-///     to the browser console.
+///   to the browser console.
 /// * Other platforms are currently not setup.
 ///
 /// ```no_run
diff --git a/crates/bevy_asset/Cargo.toml b/crates/bevy_asset/Cargo.toml
index 7022eb4d5..f462cac50 100644
--- a/crates/bevy_asset/Cargo.toml
+++ b/crates/bevy_asset/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_asset"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides asset functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_asset/macros/Cargo.toml b/crates/bevy_asset/macros/Cargo.toml
index 9b6c4f56a..43562ae80 100644
--- a/crates/bevy_asset/macros/Cargo.toml
+++ b/crates/bevy_asset/macros/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_asset_macros"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Derive implementations for bevy_asset"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_asset/src/lib.rs b/crates/bevy_asset/src/lib.rs
index f0b8e92a9..7d1d6dc32 100644
--- a/crates/bevy_asset/src/lib.rs
+++ b/crates/bevy_asset/src/lib.rs
@@ -499,8 +499,8 @@ pub trait AssetApp {
     /// * Initializing the [`AssetEvent`] resource for the [`Asset`]
     /// * Adding other relevant systems and resources for the [`Asset`]
     /// * Ignoring schedule ambiguities in [`Assets`] resource. Any time a system takes
-    ///     mutable access to this resource this causes a conflict, but they rarely actually
-    ///     modify the same underlying asset.
+    ///   mutable access to this resource this causes a conflict, but they rarely actually
+    ///   modify the same underlying asset.
     fn init_asset<A: Asset>(&mut self) -> &mut Self;
     /// Registers the asset type `T` using `[App::register]`,
     /// and adds [`ReflectAsset`] type data to `T` and [`ReflectHandle`] type data to [`Handle<T>`] in the type registry.
diff --git a/crates/bevy_asset/src/loader.rs b/crates/bevy_asset/src/loader.rs
index 3be672e0c..caccaa1b0 100644
--- a/crates/bevy_asset/src/loader.rs
+++ b/crates/bevy_asset/src/loader.rs
@@ -552,8 +552,8 @@ impl<'a> LoadContext<'a> {
         let path = path.into();
         let source = self.asset_server.get_source(path.source())?;
         let asset_reader = match self.asset_server.mode() {
-            AssetServerMode::Unprocessed { .. } => source.reader(),
-            AssetServerMode::Processed { .. } => source.processed_reader()?,
+            AssetServerMode::Unprocessed => source.reader(),
+            AssetServerMode::Processed => source.processed_reader()?,
         };
         let mut reader = asset_reader.read(path.path()).await?;
         let hash = if self.populate_hashes {
diff --git a/crates/bevy_asset/src/path.rs b/crates/bevy_asset/src/path.rs
index 3038c52fb..f21bb96db 100644
--- a/crates/bevy_asset/src/path.rs
+++ b/crates/bevy_asset/src/path.rs
@@ -18,10 +18,10 @@ use thiserror::Error;
 ///
 /// Asset paths consist of three main parts:
 /// * [`AssetPath::source`]: The name of the [`AssetSource`](crate::io::AssetSource) to load the asset from.
-///     This is optional. If one is not set the default source will be used (which is the `assets` folder by default).
+///   This is optional. If one is not set the default source will be used (which is the `assets` folder by default).
 /// * [`AssetPath::path`]: The "virtual filesystem path" pointing to an asset source file.
 /// * [`AssetPath::label`]: An optional "named sub asset". When assets are loaded, they are
-///     allowed to load "sub assets" of any type, which are identified by a named "label".
+///   allowed to load "sub assets" of any type, which are identified by a named "label".
 ///
 /// Asset paths are generally constructed (and visualized) as strings:
 ///
diff --git a/crates/bevy_asset/src/processor/mod.rs b/crates/bevy_asset/src/processor/mod.rs
index bfc9a295d..d0db3dc90 100644
--- a/crates/bevy_asset/src/processor/mod.rs
+++ b/crates/bevy_asset/src/processor/mod.rs
@@ -207,10 +207,13 @@ impl AssetProcessor {
     /// Processes all assets. This will:
     /// * For each "processed [`AssetSource`]:
     /// * Scan the [`ProcessorTransactionLog`] and recover from any failures detected
-    /// * Scan the processed [`AssetReader`](crate::io::AssetReader) to build the current view of already processed assets.
-    /// * Scan the unprocessed [`AssetReader`](crate::io::AssetReader) and remove any final processed assets that are invalid or no longer exist.
-    /// * For each asset in the unprocessed [`AssetReader`](crate::io::AssetReader), kick off a new "process job", which will process the asset
-    ///     (if the latest version of the asset has not been processed).
+    /// * Scan the processed [`AssetReader`](crate::io::AssetReader) to build the current view of
+    ///   already processed assets.
+    /// * Scan the unprocessed [`AssetReader`](crate::io::AssetReader) and remove any final
+    ///   processed assets that are invalid or no longer exist.
+    /// * For each asset in the unprocessed [`AssetReader`](crate::io::AssetReader), kick off a new
+    ///   "process job", which will process the asset
+    ///   (if the latest version of the asset has not been processed).
     #[cfg(all(not(target_arch = "wasm32"), feature = "multi_threaded"))]
     pub fn process_assets(&self) {
         let start_time = std::time::Instant::now();
diff --git a/crates/bevy_asset/src/server/mod.rs b/crates/bevy_asset/src/server/mod.rs
index e65bbd2b6..fec52f78d 100644
--- a/crates/bevy_asset/src/server/mod.rs
+++ b/crates/bevy_asset/src/server/mod.rs
@@ -38,12 +38,13 @@ use std::path::{Path, PathBuf};
 use thiserror::Error;
 use tracing::{error, info};
 
-/// Loads and tracks the state of [`Asset`] values from a configured [`AssetReader`](crate::io::AssetReader). This can be used to kick off new asset loads and
-/// retrieve their current load states.
+/// Loads and tracks the state of [`Asset`] values from a configured [`AssetReader`](crate::io::AssetReader).
+/// This can be used to kick off new asset loads and retrieve their current load states.
 ///
 /// The general process to load an asset is:
-/// 1. Initialize a new [`Asset`] type with the [`AssetServer`] via [`AssetApp::init_asset`], which will internally call [`AssetServer::register_asset`]
-///     and set up related ECS [`Assets`] storage and systems.
+/// 1. Initialize a new [`Asset`] type with the [`AssetServer`] via [`AssetApp::init_asset`], which
+///    will internally call [`AssetServer::register_asset`] and set up related ECS [`Assets`]
+///    storage and systems.
 /// 2. Register one or more [`AssetLoader`]s for that asset with [`AssetApp::init_asset_loader`]
 /// 3. Add the asset to your asset folder (defaults to `assets`).
 /// 4. Call [`AssetServer::load`] with a path to your asset.
@@ -923,8 +924,8 @@ impl AssetServer {
                 };
 
                 let asset_reader = match server.data.mode {
-                    AssetServerMode::Unprocessed { .. } => source.reader(),
-                    AssetServerMode::Processed { .. } => match source.processed_reader() {
+                    AssetServerMode::Unprocessed => source.reader(),
+                    AssetServerMode::Processed => match source.processed_reader() {
                         Ok(reader) => reader,
                         Err(_) => {
                             error!(
@@ -1235,8 +1236,8 @@ impl AssetServer {
         // Then the meta reader, if meta exists, will correspond to the meta for the current "version" of the asset.
         // See ProcessedAssetInfo::file_transaction_lock for more context
         let asset_reader = match self.data.mode {
-            AssetServerMode::Unprocessed { .. } => source.reader(),
-            AssetServerMode::Processed { .. } => source.processed_reader()?,
+            AssetServerMode::Unprocessed => source.reader(),
+            AssetServerMode::Processed => source.processed_reader()?,
         };
         let reader = asset_reader.read(asset_path.path()).await?;
         let read_meta = match &self.data.meta_check {
@@ -1584,14 +1585,14 @@ pub fn handle_internal_asset_events(world: &mut World) {
 
         for source in server.data.sources.iter() {
             match server.data.mode {
-                AssetServerMode::Unprocessed { .. } => {
+                AssetServerMode::Unprocessed => {
                     if let Some(receiver) = source.event_receiver() {
                         for event in receiver.try_iter() {
                             handle_event(source.id(), event);
                         }
                     }
                 }
-                AssetServerMode::Processed { .. } => {
+                AssetServerMode::Processed => {
                     if let Some(receiver) = source.processed_event_receiver() {
                         for event in receiver.try_iter() {
                             handle_event(source.id(), event);
diff --git a/crates/bevy_audio/Cargo.toml b/crates/bevy_audio/Cargo.toml
index 4d7967977..e6e875bc7 100644
--- a/crates/bevy_audio/Cargo.toml
+++ b/crates/bevy_audio/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_audio"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides audio functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_color/Cargo.toml b/crates/bevy_color/Cargo.toml
index 7115963e7..b1ab628e3 100644
--- a/crates/bevy_color/Cargo.toml
+++ b/crates/bevy_color/Cargo.toml
@@ -1,13 +1,13 @@
 [package]
 name = "bevy_color"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Types for representing and manipulating color values"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
 license = "MIT OR Apache-2.0"
 keywords = ["bevy", "color"]
-rust-version = "1.83.0"
+rust-version = "1.85.0"
 
 [dependencies]
 bevy_math = { path = "../bevy_math", version = "0.16.0-dev", default-features = false, features = [
diff --git a/crates/bevy_color/crates/gen_tests/Cargo.toml b/crates/bevy_color/crates/gen_tests/Cargo.toml
index 357e7aaba..e0f5940d5 100644
--- a/crates/bevy_color/crates/gen_tests/Cargo.toml
+++ b/crates/bevy_color/crates/gen_tests/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "gen_tests"
 version = "0.1.0"
-edition = "2021"
+edition = "2024"
 publish = false
 
 [workspace]
diff --git a/crates/bevy_core_pipeline/Cargo.toml b/crates/bevy_core_pipeline/Cargo.toml
index 399404036..1530a116a 100644
--- a/crates/bevy_core_pipeline/Cargo.toml
+++ b/crates/bevy_core_pipeline/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_core_pipeline"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 authors = [
   "Bevy Contributors <bevyengine@gmail.com>",
   "Carter Anderson <mcanders1@gmail.com>",
diff --git a/crates/bevy_core_pipeline/src/bloom/mod.rs b/crates/bevy_core_pipeline/src/bloom/mod.rs
index 938f2f243..295b04c6a 100644
--- a/crates/bevy_core_pipeline/src/bloom/mod.rs
+++ b/crates/bevy_core_pipeline/src/bloom/mod.rs
@@ -152,7 +152,8 @@ impl ViewNode for BloomNode {
         render_context.command_encoder().push_debug_group("bloom");
 
         let diagnostics = render_context.diagnostic_recorder();
-        let time_span = diagnostics.time_span(render_context.command_encoder(), "bloom");
+        let command_encoder = render_context.command_encoder();
+        let time_span = diagnostics.time_span(command_encoder, "bloom");
 
         // First downsample pass
         {
diff --git a/crates/bevy_derive/Cargo.toml b/crates/bevy_derive/Cargo.toml
index 3cac10ce0..1c4cb4adc 100644
--- a/crates/bevy_derive/Cargo.toml
+++ b/crates/bevy_derive/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_derive"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides derive implementations for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_derive/compile_fail/Cargo.toml b/crates/bevy_derive/compile_fail/Cargo.toml
index 45dcf8aaa..a9ad3e95e 100644
--- a/crates/bevy_derive/compile_fail/Cargo.toml
+++ b/crates/bevy_derive/compile_fail/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "bevy_derive_compile_fail"
-edition = "2021"
+edition = "2024"
 description = "Compile fail tests for Bevy Engine's various macros"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_derive/src/bevy_main.rs b/crates/bevy_derive/src/bevy_main.rs
index 8111a3133..a9339b139 100644
--- a/crates/bevy_derive/src/bevy_main.rs
+++ b/crates/bevy_derive/src/bevy_main.rs
@@ -10,14 +10,20 @@ pub fn bevy_main(_attr: TokenStream, item: TokenStream) -> TokenStream {
     );
 
     TokenStream::from(quote! {
-        #[no_mangle]
+        // SAFETY: `#[bevy_main]` should only be placed on a single `main` function
+        // TODO: Potentially make `bevy_main` and unsafe attribute as there is a safety
+        // guarantee required from the caller.
+        #[unsafe(no_mangle)]
         #[cfg(target_os = "android")]
         fn android_main(android_app: bevy::window::android_activity::AndroidApp) {
             let _ = bevy::window::ANDROID_APP.set(android_app);
             main();
         }
 
-        #[no_mangle]
+        // SAFETY: `#[bevy_main]` should only be placed on a single `main` function
+        // TODO: Potentially make `bevy_main` and unsafe attribute as there is a safety
+        // guarantee required from the caller.
+        #[unsafe(no_mangle)]
         #[cfg(target_os = "ios")]
         extern "C" fn main_rs() {
             main();
diff --git a/crates/bevy_dev_tools/Cargo.toml b/crates/bevy_dev_tools/Cargo.toml
index 0b9618d20..ad0f2c515 100644
--- a/crates/bevy_dev_tools/Cargo.toml
+++ b/crates/bevy_dev_tools/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_dev_tools"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Collection of developer tools for the Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_dev_tools/src/lib.rs b/crates/bevy_dev_tools/src/lib.rs
index 0f9dc7561..1dfd47340 100644
--- a/crates/bevy_dev_tools/src/lib.rs
+++ b/crates/bevy_dev_tools/src/lib.rs
@@ -29,7 +29,7 @@ pub mod states;
 /// To enable developer tools, you can either:
 ///
 /// - Create a custom crate feature (e.g "`dev_mode`"), which enables the `bevy_dev_tools` feature
-///     along with any other development tools you might be using:
+///   along with any other development tools you might be using:
 ///
 /// ```toml
 /// [feature]
diff --git a/crates/bevy_diagnostic/Cargo.toml b/crates/bevy_diagnostic/Cargo.toml
index a21e09eb9..80afd7022 100644
--- a/crates/bevy_diagnostic/Cargo.toml
+++ b/crates/bevy_diagnostic/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_diagnostic"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides diagnostic functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_dylib/Cargo.toml b/crates/bevy_dylib/Cargo.toml
index de96856f9..26aec33b8 100644
--- a/crates/bevy_dylib/Cargo.toml
+++ b/crates/bevy_dylib/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_dylib"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Force the Bevy Engine to be dynamically linked for faster linking"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_ecs/Cargo.toml b/crates/bevy_ecs/Cargo.toml
index bd3d02d03..89a13c5e9 100644
--- a/crates/bevy_ecs/Cargo.toml
+++ b/crates/bevy_ecs/Cargo.toml
@@ -1,14 +1,14 @@
 [package]
 name = "bevy_ecs"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Bevy Engine's entity component system"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
 license = "MIT OR Apache-2.0"
 keywords = ["ecs", "game", "bevy"]
 categories = ["game-engines", "data-structures"]
-rust-version = "1.83.0"
+rust-version = "1.85.0"
 
 [features]
 default = ["std", "bevy_reflect", "async_executor"]
diff --git a/crates/bevy_ecs/compile_fail/Cargo.toml b/crates/bevy_ecs/compile_fail/Cargo.toml
index 76f7ec8b8..48e3857f5 100644
--- a/crates/bevy_ecs/compile_fail/Cargo.toml
+++ b/crates/bevy_ecs/compile_fail/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "bevy_ecs_compile_fail"
-edition = "2021"
+edition = "2024"
 description = "Compile fail tests for Bevy Engine's entity component system"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_ecs/macros/Cargo.toml b/crates/bevy_ecs/macros/Cargo.toml
index f1ea54894..3325a102d 100644
--- a/crates/bevy_ecs/macros/Cargo.toml
+++ b/crates/bevy_ecs/macros/Cargo.toml
@@ -2,7 +2,7 @@
 name = "bevy_ecs_macros"
 version = "0.16.0-dev"
 description = "Bevy ECS Macros"
-edition = "2021"
+edition = "2024"
 license = "MIT OR Apache-2.0"
 
 [lib]
diff --git a/crates/bevy_ecs/macros/src/component.rs b/crates/bevy_ecs/macros/src/component.rs
index 76732c0b8..13f41c3b3 100644
--- a/crates/bevy_ecs/macros/src/component.rs
+++ b/crates/bevy_ecs/macros/src/component.rs
@@ -257,7 +257,7 @@ pub fn derive_component(input: TokenStream) -> TokenStream {
 
 fn visit_entities(data: &Data, bevy_ecs_path: &Path, is_relationship: bool) -> TokenStream2 {
     match data {
-        Data::Struct(DataStruct { ref fields, .. }) => {
+        Data::Struct(DataStruct { fields, .. }) => {
             let mut visited_fields = Vec::new();
             let mut visited_indices = Vec::new();
             match fields {
@@ -343,8 +343,8 @@ fn visit_entities(data: &Data, bevy_ecs_path: &Path, is_relationship: bool) -> T
                         let field_member = ident_or_index(field.ident.as_ref(), index);
                         let field_ident = format_ident!("field_{}", field_member);
 
-                        variant_fields.push(quote!(#field_member: ref #field_ident));
-                        variant_fields_mut.push(quote!(#field_member: ref mut #field_ident));
+                        variant_fields.push(quote!(#field_member: #field_ident));
+                        variant_fields_mut.push(quote!(#field_member: #field_ident));
 
                         visit_variant_fields.push(quote!(#field_ident.visit_entities(&mut func);));
                         visit_variant_fields_mut
diff --git a/crates/bevy_ecs/src/change_detection.rs b/crates/bevy_ecs/src/change_detection.rs
index 542736e11..0bdecb593 100644
--- a/crates/bevy_ecs/src/change_detection.rs
+++ b/crates/bevy_ecs/src/change_detection.rs
@@ -811,7 +811,7 @@ impl<'w, T: ?Sized> Ref<'w, T> {
     /// - `added` - A [`Tick`] that stores the tick when the wrapped value was created.
     /// - `changed` - A [`Tick`] that stores the last time the wrapped value was changed.
     /// - `last_run` - A [`Tick`], occurring before `this_run`, which is used
-    ///    as a reference to determine whether the wrapped value is newly added or changed.
+    ///   as a reference to determine whether the wrapped value is newly added or changed.
     /// - `this_run` - A [`Tick`] corresponding to the current point in time -- "now".
     pub fn new(
         value: &'w T,
diff --git a/crates/bevy_ecs/src/entity/unique_slice.rs b/crates/bevy_ecs/src/entity/unique_slice.rs
index f3a6f66de..507d98b09 100644
--- a/crates/bevy_ecs/src/entity/unique_slice.rs
+++ b/crates/bevy_ecs/src/entity/unique_slice.rs
@@ -1280,7 +1280,6 @@ impl<T: TrustedEntityBorrow> IndexMut<RangeToInclusive<usize>> for UniqueEntityS
 /// the [`IntoIterator`] impls on it and [`UniqueEntityVec`].
 ///
 /// [`iter`]: `UniqueEntitySlice::iter`
-/// [`into_iter`]: UniqueEntitySlice::into_iter
 pub type Iter<'a, T> = UniqueEntityIter<slice::Iter<'a, T>>;
 
 impl<'a, T: TrustedEntityBorrow> UniqueEntityIter<slice::Iter<'a, T>> {
diff --git a/crates/bevy_ecs/src/entity/unique_vec.rs b/crates/bevy_ecs/src/entity/unique_vec.rs
index 9ea1f9c7a..785d4fd7c 100644
--- a/crates/bevy_ecs/src/entity/unique_vec.rs
+++ b/crates/bevy_ecs/src/entity/unique_vec.rs
@@ -809,7 +809,7 @@ impl<T: TrustedEntityBorrow> Extend<T> for UniqueEntityVec<T> {
         let reserve = if self.is_empty() {
             iter.size_hint().0
         } else {
-            (iter.size_hint().0 + 1) / 2
+            iter.size_hint().0.div_ceil(2)
         };
         self.reserve(reserve);
         // Internal iteration (fold/for_each) is known to result in better code generation
@@ -836,7 +836,7 @@ impl<'a, T: TrustedEntityBorrow + Copy + 'a> Extend<&'a T> for UniqueEntityVec<T
         let reserve = if self.is_empty() {
             iter.size_hint().0
         } else {
-            (iter.size_hint().0 + 1) / 2
+            iter.size_hint().0.div_ceil(2)
         };
         self.reserve(reserve);
         // Internal iteration (fold/for_each) is known to result in better code generation
diff --git a/crates/bevy_ecs/src/event/collections.rs b/crates/bevy_ecs/src/event/collections.rs
index faa52ecd1..cebba5a55 100644
--- a/crates/bevy_ecs/src/event/collections.rs
+++ b/crates/bevy_ecs/src/event/collections.rs
@@ -73,7 +73,7 @@ use {
 /// - [`EventReader`]s that read at least once per update will never drop events.
 /// - [`EventReader`]s that read once within two updates might still receive some events
 /// - [`EventReader`]s that read after two updates are guaranteed to drop all events that occurred
-///     before those updates.
+///   before those updates.
 ///
 /// The buffers in [`Events`] will grow indefinitely if [`update`](Events::update) is never called.
 ///
diff --git a/crates/bevy_ecs/src/lib.rs b/crates/bevy_ecs/src/lib.rs
index 26b888f23..8d415d746 100644
--- a/crates/bevy_ecs/src/lib.rs
+++ b/crates/bevy_ecs/src/lib.rs
@@ -2,13 +2,6 @@
     unsafe_op_in_unsafe_fn,
     reason = "See #11590. To be removed once all applicable unsafe code has an unsafe block with a safety comment."
 )]
-#![cfg_attr(
-    test,
-    expect(
-        dependency_on_unit_never_type_fallback,
-        reason = "See #17340. To be removed once Edition 2024 is released"
-    )
-)]
 #![doc = include_str!("../README.md")]
 #![cfg_attr(
     any(docsrs, docsrs_dep),
diff --git a/crates/bevy_ecs/src/observer/mod.rs b/crates/bevy_ecs/src/observer/mod.rs
index c44e96136..d0aa36460 100644
--- a/crates/bevy_ecs/src/observer/mod.rs
+++ b/crates/bevy_ecs/src/observer/mod.rs
@@ -1115,11 +1115,10 @@ mod tests {
     fn observer_despawn() {
         let mut world = World::new();
 
-        let observer = world
-            .add_observer(|_: Trigger<OnAdd, A>| {
-                panic!("Observer triggered after being despawned.")
-            })
-            .id();
+        let system: fn(Trigger<OnAdd, A>) = |_| {
+            panic!("Observer triggered after being despawned.");
+        };
+        let observer = world.add_observer(system).id();
         world.despawn(observer);
         world.spawn(A).flush();
     }
@@ -1136,11 +1135,11 @@ mod tests {
             res.observed("remove_a");
         });
 
-        let observer = world
-            .add_observer(|_: Trigger<OnRemove, B>| {
-                panic!("Observer triggered after being despawned.")
-            })
-            .flush();
+        let system: fn(Trigger<OnRemove, B>) = |_: Trigger<OnRemove, B>| {
+            panic!("Observer triggered after being despawned.");
+        };
+
+        let observer = world.add_observer(system).flush();
         world.despawn(observer);
 
         world.despawn(entity);
@@ -1166,9 +1165,10 @@ mod tests {
         let mut world = World::new();
         world.init_resource::<Order>();
 
-        world
-            .spawn_empty()
-            .observe(|_: Trigger<EventA>| panic!("Trigger routed to non-targeted entity."));
+        let system: fn(Trigger<EventA>) = |_| {
+            panic!("Trigger routed to non-targeted entity.");
+        };
+        world.spawn_empty().observe(system);
         world.add_observer(move |obs: Trigger<EventA>, mut res: ResMut<Order>| {
             assert_eq!(obs.target(), Entity::PLACEHOLDER);
             res.observed("event_a");
@@ -1187,9 +1187,11 @@ mod tests {
         let mut world = World::new();
         world.init_resource::<Order>();
 
-        world
-            .spawn_empty()
-            .observe(|_: Trigger<EventA>| panic!("Trigger routed to non-targeted entity."));
+        let system: fn(Trigger<EventA>) = |_| {
+            panic!("Trigger routed to non-targeted entity.");
+        };
+
+        world.spawn_empty().observe(system);
         let entity = world
             .spawn_empty()
             .observe(|_: Trigger<EventA>, mut res: ResMut<Order>| res.observed("a_1"))
diff --git a/crates/bevy_ecs/src/query/access.rs b/crates/bevy_ecs/src/query/access.rs
index 089d6914c..da8c2ef68 100644
--- a/crates/bevy_ecs/src/query/access.rs
+++ b/crates/bevy_ecs/src/query/access.rs
@@ -819,7 +819,7 @@ impl<T: SparseSetIndex> Access<T> {
 /// otherwise would allow for queries to be considered disjoint when they shouldn't:
 /// - `Query<(&mut T, Option<&U>)>` read/write `T`, read `U`, with `U`
 /// - `Query<&mut T, Without<U>>` read/write `T`, without `U`
-///     from this we could reasonably conclude that the queries are disjoint but they aren't.
+///   from this we could reasonably conclude that the queries are disjoint but they aren't.
 ///
 /// In order to solve this the actual access that `Query<(&mut T, Option<&U>)>` has
 /// is read/write `T`, read `U`. It must still have a read `U` access otherwise the following
diff --git a/crates/bevy_ecs/src/query/filter.rs b/crates/bevy_ecs/src/query/filter.rs
index 9e4f36a96..e4e1f0fd6 100644
--- a/crates/bevy_ecs/src/query/filter.rs
+++ b/crates/bevy_ecs/src/query/filter.rs
@@ -66,9 +66,7 @@ use variadics_please::all_tuples;
 /// # bevy_ecs::system::assert_is_system(my_system);
 /// ```
 ///
-/// [`matches_component_set`]: Self::matches_component_set
 /// [`Query`]: crate::system::Query
-/// [`State`]: Self::State
 ///
 /// # Safety
 ///
diff --git a/crates/bevy_ecs/src/query/state.rs b/crates/bevy_ecs/src/query/state.rs
index 1e851285d..1dfcb922d 100644
--- a/crates/bevy_ecs/src/query/state.rs
+++ b/crates/bevy_ecs/src/query/state.rs
@@ -51,9 +51,9 @@ pub(super) union StorageId {
 ///
 /// This data is cached between system runs, and is used to:
 /// - store metadata about which [`Table`] or [`Archetype`] are matched by the query. "Matched" means
-///     that the query will iterate over the data in the matched table/archetype.
+///   that the query will iterate over the data in the matched table/archetype.
 /// - cache the [`State`] needed to compute the [`Fetch`] struct used to retrieve data
-///     from a specific [`Table`] or [`Archetype`]
+///   from a specific [`Table`] or [`Archetype`]
 /// - build iterators that can iterate over the query results
 ///
 /// [`State`]: crate::query::world_query::WorldQuery::State
diff --git a/crates/bevy_ecs/src/reflect/entity_commands.rs b/crates/bevy_ecs/src/reflect/entity_commands.rs
index 9aef8105a..725c61265 100644
--- a/crates/bevy_ecs/src/reflect/entity_commands.rs
+++ b/crates/bevy_ecs/src/reflect/entity_commands.rs
@@ -20,7 +20,7 @@ pub trait ReflectCommandExt {
     ///
     /// - If the entity doesn't exist.
     /// - If [`AppTypeRegistry`] does not have the reflection data for the given
-    ///     [`Component`](crate::component::Component) or [`Bundle`](crate::bundle::Bundle).
+    ///   [`Component`](crate::component::Component) or [`Bundle`](crate::bundle::Bundle).
     /// - If the component or bundle data is invalid. See [`PartialReflect::apply`] for further details.
     /// - If [`AppTypeRegistry`] is not present in the [`World`].
     ///
@@ -212,7 +212,7 @@ impl<'w> EntityWorldMut<'w> {
     ///
     /// - If the entity has been despawned while this `EntityWorldMut` is still alive.
     /// - If [`AppTypeRegistry`] does not have the reflection data for the given
-    ///     [`Component`](crate::component::Component) or [`Bundle`](crate::bundle::Bundle).
+    ///   [`Component`](crate::component::Component) or [`Bundle`](crate::bundle::Bundle).
     /// - If the component or bundle data is invalid. See [`PartialReflect::apply`] for further details.
     /// - If [`AppTypeRegistry`] is not present in the [`World`].
     ///
@@ -243,7 +243,7 @@ impl<'w> EntityWorldMut<'w> {
     ///
     /// - If the entity has been despawned while this `EntityWorldMut` is still alive.
     /// - If the given [`Resource`] does not have the reflection data for the given
-    ///     [`Component`](crate::component::Component) or [`Bundle`](crate::bundle::Bundle).
+    ///   [`Component`](crate::component::Component) or [`Bundle`](crate::bundle::Bundle).
     /// - If the component or bundle data is invalid. See [`PartialReflect::apply`] for further details.
     /// - If the given [`Resource`] is not present in the [`World`].
     pub fn insert_reflect_with_registry<T: Resource + AsRef<TypeRegistry>>(
diff --git a/crates/bevy_ecs/src/schedule/graph/mod.rs b/crates/bevy_ecs/src/schedule/graph/mod.rs
index ed25b612e..a7ef79dbe 100644
--- a/crates/bevy_ecs/src/schedule/graph/mod.rs
+++ b/crates/bevy_ecs/src/schedule/graph/mod.rs
@@ -276,7 +276,7 @@ pub fn simple_cycles_in_component(graph: &DiGraph, scc: &[NodeId]) -> Vec<Vec<No
         stack.clear();
         stack.push((root, subgraph.neighbors(root)));
         while !stack.is_empty() {
-            let (ref node, successors) = stack.last_mut().unwrap();
+            let &mut (ref node, ref mut successors) = stack.last_mut().unwrap();
             if let Some(next) = successors.next() {
                 if next == root {
                     // found a cycle
diff --git a/crates/bevy_ecs/src/schedule/mod.rs b/crates/bevy_ecs/src/schedule/mod.rs
index eb48b2c4f..d7a66faa6 100644
--- a/crates/bevy_ecs/src/schedule/mod.rs
+++ b/crates/bevy_ecs/src/schedule/mod.rs
@@ -1192,7 +1192,7 @@ mod tests {
                 let mut schedule = Schedule::new(TestSchedule);
                 schedule
                     .set_executor_kind($executor)
-                    .add_systems(|| panic!("Executor ignored Stepping"));
+                    .add_systems(|| -> () { panic!("Executor ignored Stepping") });
 
                 // Add our schedule to stepping & and enable stepping; this should
                 // prevent any systems in the schedule from running
diff --git a/crates/bevy_ecs/src/schedule/schedule.rs b/crates/bevy_ecs/src/schedule/schedule.rs
index a613a8745..18f3fadd6 100644
--- a/crates/bevy_ecs/src/schedule/schedule.rs
+++ b/crates/bevy_ecs/src/schedule/schedule.rs
@@ -2062,12 +2062,12 @@ mod tests {
         let mut world = World::new();
         let mut schedule = Schedule::default();
 
+        let system: fn() = || {
+            panic!("This system must not run");
+        };
+
         schedule.configure_sets(Set.run_if(|| false));
-        schedule.add_systems(
-            (|| panic!("This system must not run"))
-                .ambiguous_with(|| ())
-                .in_set(Set),
-        );
+        schedule.add_systems(system.ambiguous_with(|| ()).in_set(Set));
         schedule.run(&mut world);
     }
 
diff --git a/crates/bevy_ecs/src/schedule/stepping.rs b/crates/bevy_ecs/src/schedule/stepping.rs
index f26da4cad..7902460da 100644
--- a/crates/bevy_ecs/src/schedule/stepping.rs
+++ b/crates/bevy_ecs/src/schedule/stepping.rs
@@ -1348,7 +1348,9 @@ mod tests {
         //
         // first system will be configured as `run_if(|| false)`, so it can
         // just panic if called
-        let first_system = move || panic!("first_system should not be run");
+        let first_system: fn() = move || {
+            panic!("first_system should not be run");
+        };
 
         // The second system, we need to know when it has been called, so we'll
         // add a resource for tracking if it has been run.  The system will
diff --git a/crates/bevy_ecs/src/storage/blob_array.rs b/crates/bevy_ecs/src/storage/blob_array.rs
index d10f3f145..9b738a763 100644
--- a/crates/bevy_ecs/src/storage/blob_array.rs
+++ b/crates/bevy_ecs/src/storage/blob_array.rs
@@ -76,7 +76,7 @@ impl BlobArray {
     ///
     /// # Safety
     /// - The element at index `index` is safe to access.
-    ///     (If the safety requirements of every method that has been used on `Self` have been fulfilled, the caller just needs to ensure that `index` < `len`)
+    ///   (If the safety requirements of every method that has been used on `Self` have been fulfilled, the caller just needs to ensure that `index` < `len`)
     ///
     /// [`Vec::len`]: alloc::vec::Vec::len
     #[inline]
@@ -99,7 +99,7 @@ impl BlobArray {
     ///
     /// # Safety
     /// - The element with at index `index` is safe to access.
-    ///     (If the safety requirements of every method that has been used on `Self` have been fulfilled, the caller just needs to ensure that `index` < `len`)
+    ///   (If the safety requirements of every method that has been used on `Self` have been fulfilled, the caller just needs to ensure that `index` < `len`)
     ///
     /// [`Vec::len`]: alloc::vec::Vec::len
     #[inline]
@@ -156,7 +156,7 @@ impl BlobArray {
     ///
     /// # Safety
     /// - For every element with index `i`, if `i` < `len`: It must be safe to call [`Self::get_unchecked_mut`] with `i`.
-    ///     (If the safety requirements of every method that has been used on `Self` have been fulfilled, the caller just needs to ensure that `len` is correct.)
+    ///   (If the safety requirements of every method that has been used on `Self` have been fulfilled, the caller just needs to ensure that `len` is correct.)
     ///
     /// [`Vec::clear`]: alloc::vec::Vec::clear
     pub unsafe fn clear(&mut self, len: usize) {
@@ -289,7 +289,7 @@ impl BlobArray {
     /// # Safety
     /// - `index` must be in bounds (`index` < capacity)
     /// - The [`Layout`] of the value must match the layout of the blobs stored in this array,
-    ///     and it must be safe to use the `drop` function of this [`BlobArray`] to drop `value`.
+    ///   and it must be safe to use the `drop` function of this [`BlobArray`] to drop `value`.
     /// - `value` must not point to the same value that is being initialized.
     #[inline]
     pub unsafe fn initialize_unchecked(&mut self, index: usize, value: OwningPtr<'_>) {
@@ -305,7 +305,7 @@ impl BlobArray {
     /// # Safety
     /// - Index must be in-bounds (`index` < `len`)
     /// - `value`'s [`Layout`] must match this [`BlobArray`]'s `item_layout`,
-    ///     and it must be safe to use the `drop` function of this [`BlobArray`] to drop `value`.
+    ///   and it must be safe to use the `drop` function of this [`BlobArray`] to drop `value`.
     /// - `value` must not point to the same value that is being replaced.
     pub unsafe fn replace_unchecked(&mut self, index: usize, value: OwningPtr<'_>) {
         #[cfg(debug_assertions)]
diff --git a/crates/bevy_ecs/src/storage/blob_vec.rs b/crates/bevy_ecs/src/storage/blob_vec.rs
index 971cf80fa..2451fccb1 100644
--- a/crates/bevy_ecs/src/storage/blob_vec.rs
+++ b/crates/bevy_ecs/src/storage/blob_vec.rs
@@ -176,7 +176,7 @@ impl BlobVec {
     /// # Safety
     /// - index must be in bounds
     /// - the memory in the [`BlobVec`] starting at index `index`, of a size matching this [`BlobVec`]'s
-    ///     `item_layout`, must have been previously allocated.
+    ///   `item_layout`, must have been previously allocated.
     #[inline]
     pub unsafe fn initialize_unchecked(&mut self, index: usize, value: OwningPtr<'_>) {
         debug_assert!(index < self.len());
@@ -189,10 +189,10 @@ impl BlobVec {
     /// # Safety
     /// - index must be in-bounds
     /// - the memory in the [`BlobVec`] starting at index `index`, of a size matching this
-    ///     [`BlobVec`]'s `item_layout`, must have been previously initialized with an item matching
-    ///     this [`BlobVec`]'s `item_layout`
+    ///   [`BlobVec`]'s `item_layout`, must have been previously initialized with an item matching
+    ///   this [`BlobVec`]'s `item_layout`
     /// - the memory at `*value` must also be previously initialized with an item matching this
-    ///     [`BlobVec`]'s `item_layout`
+    ///   [`BlobVec`]'s `item_layout`
     pub unsafe fn replace_unchecked(&mut self, index: usize, value: OwningPtr<'_>) {
         debug_assert!(index < self.len());
 
diff --git a/crates/bevy_ecs/src/system/commands/mod.rs b/crates/bevy_ecs/src/system/commands/mod.rs
index 0208a4f67..bee44ec8d 100644
--- a/crates/bevy_ecs/src/system/commands/mod.rs
+++ b/crates/bevy_ecs/src/system/commands/mod.rs
@@ -82,7 +82,6 @@ use crate::{
 /// // NOTE: type inference fails here, so annotations are required on the closure.
 /// commands.queue(|w: &mut World| {
 ///     // Mutate the world however you want...
-///     # todo!();
 /// });
 /// # }
 /// ```
diff --git a/crates/bevy_ecs/src/system/mod.rs b/crates/bevy_ecs/src/system/mod.rs
index 4fe489d25..a8a340453 100644
--- a/crates/bevy_ecs/src/system/mod.rs
+++ b/crates/bevy_ecs/src/system/mod.rs
@@ -1648,7 +1648,10 @@ mod tests {
     #[should_panic]
     fn panic_inside_system() {
         let mut world = World::new();
-        run_system(&mut world, || panic!("this system panics"));
+        let system: fn() = || {
+            panic!("this system panics");
+        };
+        run_system(&mut world, system);
     }
 
     #[test]
diff --git a/crates/bevy_ecs/src/world/entity_ref.rs b/crates/bevy_ecs/src/world/entity_ref.rs
index 17367e56d..4feb96bcc 100644
--- a/crates/bevy_ecs/src/world/entity_ref.rs
+++ b/crates/bevy_ecs/src/world/entity_ref.rs
@@ -105,7 +105,7 @@ impl<'w> EntityRef<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    ///     [`Self::contains_type_id`].
+    ///   [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.cell.contains_id(component_id)
@@ -510,7 +510,7 @@ impl<'w> EntityMut<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    ///     [`Self::contains_type_id`].
+    ///   [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.cell.contains_id(component_id)
@@ -1134,7 +1134,7 @@ impl<'w> EntityWorldMut<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    ///     [`Self::contains_type_id`].
+    ///   [`Self::contains_type_id`].
     ///
     /// # Panics
     ///
@@ -3052,7 +3052,7 @@ impl<'w> FilteredEntityRef<'w> {
     /// # Safety
     /// - No `&mut World` can exist from the underlying `UnsafeWorldCell`
     /// - If `access` takes read access to a component no mutable reference to that
-    ///     component can exist at the same time as the returned [`FilteredEntityMut`]
+    ///   component can exist at the same time as the returned [`FilteredEntityMut`]
     /// - If `access` takes any access for a component `entity` must have that component.
     #[inline]
     pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: Access<ComponentId>) -> Self {
@@ -3103,7 +3103,7 @@ impl<'w> FilteredEntityRef<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    ///     [`Self::contains_type_id`].
+    ///   [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.entity.contains_id(component_id)
@@ -3382,9 +3382,9 @@ impl<'w> FilteredEntityMut<'w> {
     /// # Safety
     /// - No `&mut World` can exist from the underlying `UnsafeWorldCell`
     /// - If `access` takes read access to a component no mutable reference to that
-    ///     component can exist at the same time as the returned [`FilteredEntityMut`]
+    ///   component can exist at the same time as the returned [`FilteredEntityMut`]
     /// - If `access` takes write access to a component, no reference to that component
-    ///     may exist at the same time as the returned [`FilteredEntityMut`]
+    ///   may exist at the same time as the returned [`FilteredEntityMut`]
     /// - If `access` takes any access for a component `entity` must have that component.
     #[inline]
     pub(crate) unsafe fn new(entity: UnsafeEntityCell<'w>, access: Access<ComponentId>) -> Self {
@@ -3448,7 +3448,7 @@ impl<'w> FilteredEntityMut<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    ///     [`Self::contains_type_id`].
+    ///   [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.entity.contains_id(component_id)
@@ -3812,7 +3812,7 @@ where
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    ///     [`Self::contains_type_id`].
+    ///   [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.entity.contains_id(component_id)
@@ -4037,7 +4037,7 @@ where
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    ///     [`Self::contains_type_id`].
+    ///   [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(&self, component_id: ComponentId) -> bool {
         self.entity.contains_id(component_id)
@@ -4146,7 +4146,7 @@ where
 /// # Safety
 ///
 /// - [`OwningPtr`] and [`StorageType`] iterators must correspond to the
-///     [`BundleInfo`] used to construct [`BundleInserter`]
+///   [`BundleInfo`] used to construct [`BundleInserter`]
 /// - [`Entity`] must correspond to [`EntityLocation`]
 unsafe fn insert_dynamic_bundle<
     'a,
diff --git a/crates/bevy_ecs/src/world/unsafe_world_cell.rs b/crates/bevy_ecs/src/world/unsafe_world_cell.rs
index cbaffb299..b2afb6735 100644
--- a/crates/bevy_ecs/src/world/unsafe_world_cell.rs
+++ b/crates/bevy_ecs/src/world/unsafe_world_cell.rs
@@ -748,7 +748,7 @@ impl<'w> UnsafeEntityCell<'w> {
     ///
     /// - If you know the concrete type of the component, you should prefer [`Self::contains`].
     /// - If you know the component's [`TypeId`] but not its [`ComponentId`], consider using
-    ///     [`Self::contains_type_id`].
+    ///   [`Self::contains_type_id`].
     #[inline]
     pub fn contains_id(self, component_id: ComponentId) -> bool {
         self.archetype().contains(component_id)
@@ -1125,7 +1125,7 @@ impl<'w> UnsafeWorldCell<'w> {
 ///
 /// # Safety
 /// - `location` must refer to an archetype that contains `entity`
-///     the archetype
+///   the archetype
 /// - `component_id` must be valid
 /// - `storage_type` must accurately reflect where the components for `component_id` are stored.
 /// - the caller must ensure that no aliasing rules are violated
@@ -1195,7 +1195,7 @@ unsafe fn get_component_and_ticks(
 ///
 /// # Safety
 /// - `location` must refer to an archetype that contains `entity`
-///     the archetype
+///   the archetype
 /// - `component_id` must be valid
 /// - `storage_type` must accurately reflect where the components for `component_id` are stored.
 /// - the caller must ensure that no aliasing rules are violated
diff --git a/crates/bevy_encase_derive/Cargo.toml b/crates/bevy_encase_derive/Cargo.toml
index f35c44db3..b2f1b92d8 100644
--- a/crates/bevy_encase_derive/Cargo.toml
+++ b/crates/bevy_encase_derive/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_encase_derive"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Bevy derive macro for encase"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_gilrs/Cargo.toml b/crates/bevy_gilrs/Cargo.toml
index 9b3996c05..eff9c4bf4 100644
--- a/crates/bevy_gilrs/Cargo.toml
+++ b/crates/bevy_gilrs/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_gilrs"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Gamepad system made using Gilrs for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_gizmos/Cargo.toml b/crates/bevy_gizmos/Cargo.toml
index 6e51c6094..3a264c624 100644
--- a/crates/bevy_gizmos/Cargo.toml
+++ b/crates/bevy_gizmos/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_gizmos"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides gizmos for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_gizmos/macros/Cargo.toml b/crates/bevy_gizmos/macros/Cargo.toml
index 3862914d7..b38a3c537 100644
--- a/crates/bevy_gizmos/macros/Cargo.toml
+++ b/crates/bevy_gizmos/macros/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_gizmos_macros"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Derive implementations for bevy_gizmos"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_gizmos/src/arcs.rs b/crates/bevy_gizmos/src/arcs.rs
index 65f5f67ee..41647f9fe 100644
--- a/crates/bevy_gizmos/src/arcs.rs
+++ b/crates/bevy_gizmos/src/arcs.rs
@@ -136,11 +136,11 @@ where
     ///
     /// # Arguments
     /// - `angle`: sets how much of a circle circumference is passed, e.g. PI is half a circle. This
-    ///     value should be in the range (-2 * PI..=2 * PI)
+    ///   value should be in the range (-2 * PI..=2 * PI)
     /// - `radius`: distance between the arc and its center point
     /// - `isometry` defines the translation and rotation of the arc.
-    ///              - the translation specifies the center of the arc
-    ///              - the rotation is counter-clockwise starting from `Vec3::Y`
+    ///   - the translation specifies the center of the arc
+    ///   - the rotation is counter-clockwise starting from `Vec3::Y`
     /// - `color`: color of the arc
     ///
     /// # Builder methods
@@ -219,10 +219,10 @@ where
     ///
     /// # Notes
     /// - This method assumes that the points `from` and `to` are distinct from `center`. If one of
-    ///     the points is coincident with `center`, nothing is rendered.
+    ///   the points is coincident with `center`, nothing is rendered.
     /// - The arc is drawn as a portion of a circle with a radius equal to the distance from the
-    ///     `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
-    ///     the results will behave as if this were the case
+    ///   `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
+    ///   the results will behave as if this were the case
     #[inline]
     pub fn short_arc_3d_between(
         &mut self,
@@ -265,10 +265,10 @@ where
     ///
     /// # Notes
     /// - This method assumes that the points `from` and `to` are distinct from `center`. If one of
-    ///     the points is coincident with `center`, nothing is rendered.
+    ///   the points is coincident with `center`, nothing is rendered.
     /// - The arc is drawn as a portion of a circle with a radius equal to the distance from the
-    ///     `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
-    ///     the results will behave as if this were the case.
+    ///   `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
+    ///   the results will behave as if this were the case.
     #[inline]
     pub fn long_arc_3d_between(
         &mut self,
@@ -352,10 +352,10 @@ where
     ///
     /// # Notes
     /// - This method assumes that the points `from` and `to` are distinct from `center`. If one of
-    ///     the points is coincident with `center`, nothing is rendered.
+    ///   the points is coincident with `center`, nothing is rendered.
     /// - The arc is drawn as a portion of a circle with a radius equal to the distance from the
-    ///     `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
-    ///     the results will behave as if this were the case
+    ///   `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
+    ///   the results will behave as if this were the case
     #[inline]
     pub fn short_arc_2d_between(
         &mut self,
@@ -398,10 +398,10 @@ where
     ///
     /// # Notes
     /// - This method assumes that the points `from` and `to` are distinct from `center`. If one of
-    ///     the points is coincident with `center`, nothing is rendered.
+    ///   the points is coincident with `center`, nothing is rendered.
     /// - The arc is drawn as a portion of a circle with a radius equal to the distance from the
-    ///     `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
-    ///     the results will behave as if this were the case.
+    ///   `center` to `from`. If the distance from `center` to `to` is not equal to the radius, then
+    ///   the results will behave as if this were the case.
     #[inline]
     pub fn long_arc_2d_between(
         &mut self,
diff --git a/crates/bevy_gizmos/src/gizmos.rs b/crates/bevy_gizmos/src/gizmos.rs
index b1fe363f5..2d8c523e0 100644
--- a/crates/bevy_gizmos/src/gizmos.rs
+++ b/crates/bevy_gizmos/src/gizmos.rs
@@ -820,8 +820,7 @@ where
         let polymorphic_color: Color = color.into();
         let linear_color = LinearRgba::from(polymorphic_color);
 
-        self.list_colors
-            .extend(iter::repeat(linear_color).take(count));
+        self.list_colors.extend(iter::repeat_n(linear_color, count));
     }
 
     #[inline]
diff --git a/crates/bevy_gizmos/src/grid.rs b/crates/bevy_gizmos/src/grid.rs
index 42742e196..cdcfc4123 100644
--- a/crates/bevy_gizmos/src/grid.rs
+++ b/crates/bevy_gizmos/src/grid.rs
@@ -186,10 +186,9 @@ where
     /// # Arguments
     ///
     /// - `isometry` defines the translation and rotation of the grid.
-    ///              - the translation specifies the center of the grid
-    ///              - defines the orientation of the grid, by default
-    ///                we assume the grid is contained in a plane parallel
-    ///                to the XY plane
+    ///   - the translation specifies the center of the grid
+    ///   - defines the orientation of the grid, by default we assume the grid is contained in a
+    ///     plane parallel to the XY plane
     /// - `cell_count`: defines the amount of cells in the x and y axes
     /// - `spacing`: defines the distance between cells along the x and y axes
     /// - `color`: color of the grid
@@ -241,9 +240,8 @@ where
     /// # Arguments
     ///
     /// - `isometry` defines the translation and rotation of the grid.
-    ///              - the translation specifies the center of the grid
-    ///              - defines the orientation of the grid, by default
-    ///                we assume the grid is aligned with all axes
+    ///   - the translation specifies the center of the grid
+    ///   - defines the orientation of the grid, by default we assume the grid is aligned with all axes
     /// - `cell_count`: defines the amount of cells in the x, y and z axes
     /// - `spacing`: defines the distance between cells along the x, y and z axes
     /// - `color`: color of the grid
@@ -295,9 +293,8 @@ where
     /// # Arguments
     ///
     /// - `isometry` defines the translation and rotation of the grid.
-    ///              - the translation specifies the center of the grid
-    ///              - defines the orientation of the grid, by default
-    ///                we assume the grid is aligned with all axes
+    ///   - the translation specifies the center of the grid
+    ///   - defines the orientation of the grid, by default we assume the grid is aligned with all axes
     /// - `cell_count`: defines the amount of cells in the x and y axes
     /// - `spacing`: defines the distance between cells along the x and y axes
     /// - `color`: color of the grid
diff --git a/crates/bevy_gizmos/src/rounded_box.rs b/crates/bevy_gizmos/src/rounded_box.rs
index 6f0df7ac0..530d4f861 100644
--- a/crates/bevy_gizmos/src/rounded_box.rs
+++ b/crates/bevy_gizmos/src/rounded_box.rs
@@ -238,10 +238,9 @@ where
     /// # Arguments
     ///
     /// - `isometry` defines the translation and rotation of the rectangle.
-    ///              - the translation specifies the center of the rectangle
-    ///              - defines orientation of the rectangle, by default we
-    ///                assume the rectangle is contained in a plane parallel
-    ///                to the XY plane.
+    ///   - the translation specifies the center of the rectangle
+    ///   - defines orientation of the rectangle, by default we assume the rectangle is contained in
+    ///     a plane parallel to the XY plane.
     /// - `size`: defines the size of the rectangle. This refers to the 'outer size', similar to a bounding box.
     /// - `color`: color of the rectangle
     ///
@@ -249,7 +248,7 @@ where
     ///
     /// - The corner radius can be adjusted with the `.corner_radius(...)` method.
     /// - The resolution of the arcs at each corner (i.e. the level of detail) can be adjusted with the
-    ///     `.arc_resolution(...)` method.
+    ///   `.arc_resolution(...)` method.
     ///
     /// # Example
     /// ```
@@ -293,9 +292,8 @@ where
     /// # Arguments
     ///
     /// - `isometry` defines the translation and rotation of the rectangle.
-    ///              - the translation specifies the center of the rectangle
-    ///              - defines orientation of the rectangle, by default we
-    ///                assume the rectangle aligned with all axes.
+    ///   - the translation specifies the center of the rectangle
+    ///   - defines orientation of the rectangle, by default we assume the rectangle aligned with all axes.
     /// - `size`: defines the size of the rectangle. This refers to the 'outer size', similar to a bounding box.
     /// - `color`: color of the rectangle
     ///
@@ -303,7 +301,7 @@ where
     ///
     /// - The corner radius can be adjusted with the `.corner_radius(...)` method.
     /// - The resolution of the arcs at each corner (i.e. the level of detail) can be adjusted with the
-    ///     `.arc_resolution(...)` method.
+    ///   `.arc_resolution(...)` method.
     ///
     /// # Example
     /// ```
@@ -351,9 +349,8 @@ where
     /// # Arguments
     ///
     /// - `isometry` defines the translation and rotation of the cuboid.
-    ///              - the translation specifies the center of the cuboid
-    ///              - defines orientation of the cuboid, by default we
-    ///                assume the cuboid aligned with all axes.
+    ///   - the translation specifies the center of the cuboid
+    ///   - defines orientation of the cuboid, by default we assume the cuboid aligned with all axes.
     /// - `size`: defines the size of the cuboid. This refers to the 'outer size', similar to a bounding box.
     /// - `color`: color of the cuboid
     ///
@@ -361,7 +358,7 @@ where
     ///
     /// - The edge radius can be adjusted with the `.edge_radius(...)` method.
     /// - The resolution of the arcs at each edge (i.e. the level of detail) can be adjusted with the
-    ///     `.arc_resolution(...)` method.
+    ///   `.arc_resolution(...)` method.
     ///
     /// # Example
     /// ```
diff --git a/crates/bevy_gltf/Cargo.toml b/crates/bevy_gltf/Cargo.toml
index da0d97ad9..9df182f70 100644
--- a/crates/bevy_gltf/Cargo.toml
+++ b/crates/bevy_gltf/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_gltf"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Bevy Engine GLTF loading"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_image/Cargo.toml b/crates/bevy_image/Cargo.toml
index ceab1de1c..f503315ad 100644
--- a/crates/bevy_image/Cargo.toml
+++ b/crates/bevy_image/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_image"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides image types for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_input/Cargo.toml b/crates/bevy_input/Cargo.toml
index fbbec96a7..2b09ed5e2 100644
--- a/crates/bevy_input/Cargo.toml
+++ b/crates/bevy_input/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_input"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides input functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_input_focus/Cargo.toml b/crates/bevy_input_focus/Cargo.toml
index 49aaed4dc..72a159cf0 100644
--- a/crates/bevy_input_focus/Cargo.toml
+++ b/crates/bevy_input_focus/Cargo.toml
@@ -1,13 +1,13 @@
 [package]
 name = "bevy_input_focus"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Keyboard focus management"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
 license = "MIT OR Apache-2.0"
 keywords = ["bevy"]
-rust-version = "1.83.0"
+rust-version = "1.85.0"
 
 [features]
 default = ["std", "bevy_reflect", "bevy_ecs/async_executor"]
diff --git a/crates/bevy_internal/Cargo.toml b/crates/bevy_internal/Cargo.toml
index 6a128c9c3..a4ffcffc5 100644
--- a/crates/bevy_internal/Cargo.toml
+++ b/crates/bevy_internal/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_internal"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "An internal Bevy crate used to facilitate optional dynamic linking via the 'dynamic_linking' feature"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_log/Cargo.toml b/crates/bevy_log/Cargo.toml
index 6110734f9..1eca34f49 100644
--- a/crates/bevy_log/Cargo.toml
+++ b/crates/bevy_log/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_log"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides logging for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_log/src/lib.rs b/crates/bevy_log/src/lib.rs
index f0743f022..0a4db7fb8 100644
--- a/crates/bevy_log/src/lib.rs
+++ b/crates/bevy_log/src/lib.rs
@@ -80,11 +80,11 @@ pub(crate) struct FlushGuard(SyncCell<tracing_chrome::FlushGuard>);
 /// Adds logging to Apps. This plugin is part of the `DefaultPlugins`. Adding
 /// this plugin will setup a collector appropriate to your target platform:
 /// * Using [`tracing-subscriber`](https://crates.io/crates/tracing-subscriber) by default,
-///     logging to `stdout`.
+///   logging to `stdout`.
 /// * Using [`android_log-sys`](https://crates.io/crates/android_log-sys) on Android,
-///     logging to Android logs.
+///   logging to Android logs.
 /// * Using [`tracing-wasm`](https://crates.io/crates/tracing-wasm) in Wasm, logging
-///     to the browser console.
+///   to the browser console.
 ///
 /// You can configure this plugin.
 /// ```no_run
@@ -117,7 +117,10 @@ pub(crate) struct FlushGuard(SyncCell<tracing_chrome::FlushGuard>);
 /// # use bevy_app::{App, NoopPluginGroup as DefaultPlugins, PluginGroup};
 /// # use bevy_log::LogPlugin;
 /// fn main() {
+/// #   // SAFETY: Single-threaded
+/// #   unsafe {
 ///     std::env::set_var("NO_COLOR", "1");
+/// #   }
 ///     App::new()
 ///        .add_plugins(DefaultPlugins)
 ///        .run();
diff --git a/crates/bevy_macro_utils/Cargo.toml b/crates/bevy_macro_utils/Cargo.toml
index 4fb0e8291..fd1332867 100644
--- a/crates/bevy_macro_utils/Cargo.toml
+++ b/crates/bevy_macro_utils/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_macro_utils"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "A collection of utils for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_math/Cargo.toml b/crates/bevy_math/Cargo.toml
index a4c098d20..d7e4f83ce 100644
--- a/crates/bevy_math/Cargo.toml
+++ b/crates/bevy_math/Cargo.toml
@@ -1,13 +1,13 @@
 [package]
 name = "bevy_math"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides math functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
 license = "MIT OR Apache-2.0"
 keywords = ["bevy"]
-rust-version = "1.83.0"
+rust-version = "1.85.0"
 
 [dependencies]
 glam = { version = "0.29", default-features = false, features = ["bytemuck"] }
diff --git a/crates/bevy_math/src/cubic_splines/mod.rs b/crates/bevy_math/src/cubic_splines/mod.rs
index 32e13f672..9feedd317 100644
--- a/crates/bevy_math/src/cubic_splines/mod.rs
+++ b/crates/bevy_math/src/cubic_splines/mod.rs
@@ -746,10 +746,9 @@ impl<P: VectorSpace> CubicNurbs<P> {
         }
         let last_knots_value = control_points - 3;
         Some(
-            core::iter::repeat(0.0)
-                .take(4)
+            core::iter::repeat_n(0.0, 4)
                 .chain((1..last_knots_value).map(|v| v as f32))
-                .chain(core::iter::repeat(last_knots_value as f32).take(4))
+                .chain(core::iter::repeat_n(last_knots_value as f32, 4))
                 .collect(),
         )
     }
diff --git a/crates/bevy_math/src/sampling/shape_sampling.rs b/crates/bevy_math/src/sampling/shape_sampling.rs
index d1371114b..3be0ead1d 100644
--- a/crates/bevy_math/src/sampling/shape_sampling.rs
+++ b/crates/bevy_math/src/sampling/shape_sampling.rs
@@ -234,7 +234,7 @@ impl ShapeSample for Rectangle {
 
     fn sample_boundary<R: Rng + ?Sized>(&self, rng: &mut R) -> Vec2 {
         let primary_side = rng.gen_range(-1.0..1.0);
-        let other_side = if rng.gen() { -1.0 } else { 1.0 };
+        let other_side = if rng.r#gen() { -1.0 } else { 1.0 };
 
         if self.half_size.x + self.half_size.y > 0.0 {
             if rng.gen_bool((self.half_size.x / (self.half_size.x + self.half_size.y)) as f64) {
@@ -261,7 +261,7 @@ impl ShapeSample for Cuboid {
     fn sample_boundary<R: Rng + ?Sized>(&self, rng: &mut R) -> Vec3 {
         let primary_side1 = rng.gen_range(-1.0..1.0);
         let primary_side2 = rng.gen_range(-1.0..1.0);
-        let other_side = if rng.gen() { -1.0 } else { 1.0 };
+        let other_side = if rng.r#gen() { -1.0 } else { 1.0 };
 
         if let Ok(dist) = WeightedIndex::new([
             self.half_size.y * self.half_size.z,
@@ -425,7 +425,7 @@ impl ShapeSample for Cylinder {
         if self.radius + 2.0 * self.half_height > 0.0 {
             if rng.gen_bool((self.radius / (self.radius + 2.0 * self.half_height)) as f64) {
                 let Vec2 { x, y: z } = self.base().sample_interior(rng);
-                if rng.gen() {
+                if rng.r#gen() {
                     Vec3::new(x, self.half_height, z)
                 } else {
                     Vec3::new(x, -self.half_height, z)
diff --git a/crates/bevy_math/src/sampling/standard.rs b/crates/bevy_math/src/sampling/standard.rs
index 6750d5c6d..d4e82fdc8 100644
--- a/crates/bevy_math/src/sampling/standard.rs
+++ b/crates/bevy_math/src/sampling/standard.rs
@@ -12,7 +12,7 @@
 //! let random_direction1: Dir3 = random();
 //!
 //! // Random direction using the rng constructed above
-//! let random_direction2: Dir3 = rng.gen();
+//! let random_direction2: Dir3 = rng.r#gen();
 //!
 //! // The same as the previous but with different syntax
 //! let random_direction3 = Dir3::from_rng(&mut rng);
@@ -49,7 +49,7 @@ where
 {
     /// Construct a value of this type uniformly at random using `rng` as the source of randomness.
     fn from_rng<R: Rng + ?Sized>(rng: &mut R) -> Self {
-        rng.gen()
+        rng.r#gen()
     }
 }
 
diff --git a/crates/bevy_mesh/Cargo.toml b/crates/bevy_mesh/Cargo.toml
index ffcc2f72e..7d0ffdf5b 100644
--- a/crates/bevy_mesh/Cargo.toml
+++ b/crates/bevy_mesh/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_mesh"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides mesh types for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_mesh/src/mesh.rs b/crates/bevy_mesh/src/mesh.rs
index a07924df2..26363d50e 100644
--- a/crates/bevy_mesh/src/mesh.rs
+++ b/crates/bevy_mesh/src/mesh.rs
@@ -85,25 +85,25 @@ pub const VERTEX_ATTRIBUTE_BUFFER_ID: u64 = 10;
 /// ## Common points of confusion
 ///
 /// - UV maps in Bevy start at the top-left, see [`ATTRIBUTE_UV_0`](Mesh::ATTRIBUTE_UV_0),
-///     other APIs can have other conventions, `OpenGL` starts at bottom-left.
+///   other APIs can have other conventions, `OpenGL` starts at bottom-left.
 /// - It is possible and sometimes useful for multiple vertices to have the same
-///     [position attribute](Mesh::ATTRIBUTE_POSITION) value,
-///     it's a common technique in 3D modeling for complex UV mapping or other calculations.
+///   [position attribute](Mesh::ATTRIBUTE_POSITION) value,
+///   it's a common technique in 3D modeling for complex UV mapping or other calculations.
 /// - Bevy performs frustum culling based on the `Aabb` of meshes, which is calculated
-///     and added automatically for new meshes only. If a mesh is modified, the entity's `Aabb`
-///     needs to be updated manually or deleted so that it is re-calculated.
+///   and added automatically for new meshes only. If a mesh is modified, the entity's `Aabb`
+///   needs to be updated manually or deleted so that it is re-calculated.
 ///
 /// ## Use with `StandardMaterial`
 ///
 /// To render correctly with `StandardMaterial`, a mesh needs to have properly defined:
 /// - [`UVs`](Mesh::ATTRIBUTE_UV_0): Bevy needs to know how to map a texture onto the mesh
-///     (also true for `ColorMaterial`).
+///   (also true for `ColorMaterial`).
 /// - [`Normals`](Mesh::ATTRIBUTE_NORMAL): Bevy needs to know how light interacts with your mesh.
-///     [0.0, 0.0, 1.0] is very common for simple flat meshes on the XY plane,
-///     because simple meshes are smooth and they don't require complex light calculations.
+///   [0.0, 0.0, 1.0] is very common for simple flat meshes on the XY plane,
+///   because simple meshes are smooth and they don't require complex light calculations.
 /// - Vertex winding order: by default, `StandardMaterial.cull_mode` is `Some(Face::Back)`,
-///     which means that Bevy would *only* render the "front" of each triangle, which
-///     is the side of the triangle from where the vertices appear in a *counter-clockwise* order.
+///   which means that Bevy would *only* render the "front" of each triangle, which
+///   is the side of the triangle from where the vertices appear in a *counter-clockwise* order.
 #[derive(Asset, Debug, Clone, Reflect)]
 pub struct Mesh {
     #[reflect(ignore)]
@@ -881,7 +881,7 @@ impl Mesh {
             "mesh transform scale cannot be zero on more than one axis"
         );
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut positions)) =
+        if let Some(VertexAttributeValues::Float32x3(positions)) =
             self.attribute_mut(Mesh::ATTRIBUTE_POSITION)
         {
             // Apply scale, rotation, and translation to vertex positions
@@ -898,7 +898,7 @@ impl Mesh {
             return;
         }
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut normals)) =
+        if let Some(VertexAttributeValues::Float32x3(normals)) =
             self.attribute_mut(Mesh::ATTRIBUTE_NORMAL)
         {
             // Transform normals, taking into account non-uniform scaling and rotation
@@ -909,7 +909,7 @@ impl Mesh {
             });
         }
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut tangents)) =
+        if let Some(VertexAttributeValues::Float32x3(tangents)) =
             self.attribute_mut(Mesh::ATTRIBUTE_TANGENT)
         {
             // Transform tangents, taking into account non-uniform scaling and rotation
@@ -936,7 +936,7 @@ impl Mesh {
             return;
         }
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut positions)) =
+        if let Some(VertexAttributeValues::Float32x3(positions)) =
             self.attribute_mut(Mesh::ATTRIBUTE_POSITION)
         {
             // Apply translation to vertex positions
@@ -958,7 +958,7 @@ impl Mesh {
     ///
     /// `Aabb` of entities with modified mesh are not updated automatically.
     pub fn rotate_by(&mut self, rotation: Quat) {
-        if let Some(VertexAttributeValues::Float32x3(ref mut positions)) =
+        if let Some(VertexAttributeValues::Float32x3(positions)) =
             self.attribute_mut(Mesh::ATTRIBUTE_POSITION)
         {
             // Apply rotation to vertex positions
@@ -972,7 +972,7 @@ impl Mesh {
             return;
         }
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut normals)) =
+        if let Some(VertexAttributeValues::Float32x3(normals)) =
             self.attribute_mut(Mesh::ATTRIBUTE_NORMAL)
         {
             // Transform normals
@@ -981,7 +981,7 @@ impl Mesh {
             });
         }
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut tangents)) =
+        if let Some(VertexAttributeValues::Float32x3(tangents)) =
             self.attribute_mut(Mesh::ATTRIBUTE_TANGENT)
         {
             // Transform tangents
@@ -1010,7 +1010,7 @@ impl Mesh {
             "mesh transform scale cannot be zero on more than one axis"
         );
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut positions)) =
+        if let Some(VertexAttributeValues::Float32x3(positions)) =
             self.attribute_mut(Mesh::ATTRIBUTE_POSITION)
         {
             // Apply scale to vertex positions
@@ -1024,7 +1024,7 @@ impl Mesh {
             return;
         }
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut normals)) =
+        if let Some(VertexAttributeValues::Float32x3(normals)) =
             self.attribute_mut(Mesh::ATTRIBUTE_NORMAL)
         {
             // Transform normals, taking into account non-uniform scaling
@@ -1033,7 +1033,7 @@ impl Mesh {
             });
         }
 
-        if let Some(VertexAttributeValues::Float32x3(ref mut tangents)) =
+        if let Some(VertexAttributeValues::Float32x3(tangents)) =
             self.attribute_mut(Mesh::ATTRIBUTE_TANGENT)
         {
             // Transform tangents, taking into account non-uniform scaling
@@ -1096,7 +1096,7 @@ impl Mesh {
     /// Normalize joint weights so they sum to 1.
     pub fn normalize_joint_weights(&mut self) {
         if let Some(joints) = self.attribute_mut(Self::ATTRIBUTE_JOINT_WEIGHT) {
-            let VertexAttributeValues::Float32x4(ref mut joints) = joints else {
+            let VertexAttributeValues::Float32x4(joints) = joints else {
                 panic!("unexpected joint weight format");
             };
 
diff --git a/crates/bevy_mesh/src/morph.rs b/crates/bevy_mesh/src/morph.rs
index 0c2c2c948..b2a46305a 100644
--- a/crates/bevy_mesh/src/morph.rs
+++ b/crates/bevy_mesh/src/morph.rs
@@ -5,7 +5,6 @@ use bevy_image::Image;
 use bevy_math::Vec3;
 use bevy_reflect::prelude::*;
 use bytemuck::{Pod, Zeroable};
-use core::iter;
 use thiserror::Error;
 use wgpu_types::{Extent3d, TextureDimension, TextureFormat};
 
@@ -77,7 +76,7 @@ impl MorphTargetImage {
                     buffer.extend_from_slice(bytemuck::bytes_of(&to_add));
                 }
                 // Pad each layer so that they fit width * height
-                buffer.extend(iter::repeat(0).take(padding as usize * size_of::<f32>()));
+                buffer.extend(core::iter::repeat_n(0, padding as usize * size_of::<f32>()));
                 debug_assert_eq!(buffer.len(), layer_byte_count);
                 buffer
             })
diff --git a/crates/bevy_mikktspace/Cargo.toml b/crates/bevy_mikktspace/Cargo.toml
index 0ab431aa8..08eca4cc6 100644
--- a/crates/bevy_mikktspace/Cargo.toml
+++ b/crates/bevy_mikktspace/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_mikktspace"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 authors = [
   "Benjamin Wasty <benny.wasty@gmail.com>",
   "David Harvey-Macaulay <alteous@outlook.com>",
@@ -13,7 +13,7 @@ homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
 license = "Zlib AND (MIT OR Apache-2.0)"
 keywords = ["bevy", "3D", "graphics", "algorithm", "tangent"]
-rust-version = "1.76.0"
+rust-version = "1.85.0"
 
 [features]
 default = ["std"]
diff --git a/crates/bevy_mikktspace/examples/generate.rs b/crates/bevy_mikktspace/examples/generate.rs
index 6ca3fa36d..764d07085 100644
--- a/crates/bevy_mikktspace/examples/generate.rs
+++ b/crates/bevy_mikktspace/examples/generate.rs
@@ -1,6 +1,10 @@
 //! This example demonstrates how to generate a mesh.
 
-#![allow(clippy::bool_assert_comparison, clippy::useless_conversion)]
+#![allow(
+    clippy::bool_assert_comparison,
+    clippy::useless_conversion,
+    reason = "Crate auto-generated with many non-idiomatic decisions. See #7372 for details."
+)]
 
 use glam::{Vec2, Vec3};
 
diff --git a/crates/bevy_mikktspace/tests/regression_test.rs b/crates/bevy_mikktspace/tests/regression_test.rs
index a0632b76e..bd6718ad3 100644
--- a/crates/bevy_mikktspace/tests/regression_test.rs
+++ b/crates/bevy_mikktspace/tests/regression_test.rs
@@ -2,7 +2,8 @@
 #![expect(
     clippy::bool_assert_comparison,
     clippy::semicolon_if_nothing_returned,
-    clippy::useless_conversion
+    clippy::useless_conversion,
+    reason = "Crate auto-generated with many non-idiomatic decisions. See #7372 for details."
 )]
 
 use bevy_mikktspace::{generate_tangents, Geometry};
diff --git a/crates/bevy_pbr/Cargo.toml b/crates/bevy_pbr/Cargo.toml
index 0b97ceedb..970bef928 100644
--- a/crates/bevy_pbr/Cargo.toml
+++ b/crates/bevy_pbr/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_pbr"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Adds PBR rendering to Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_pbr/src/cluster/assign.rs b/crates/bevy_pbr/src/cluster/assign.rs
index 36a4aadfb..1b7b3563d 100644
--- a/crates/bevy_pbr/src/cluster/assign.rs
+++ b/crates/bevy_pbr/src/cluster/assign.rs
@@ -496,7 +496,7 @@ pub(crate) fn assign_objects_to_clusters(
 
         // initialize empty cluster bounding spheres
         cluster_aabb_spheres.clear();
-        cluster_aabb_spheres.extend(core::iter::repeat(None).take(cluster_count));
+        cluster_aabb_spheres.extend(core::iter::repeat_n(None, cluster_count));
 
         // Calculate the x/y/z cluster frustum planes in view space
         let mut x_planes = Vec::with_capacity(clusters.dimensions.x as usize + 1);
@@ -845,7 +845,7 @@ pub(crate) fn assign_objects_to_clusters(
                                 }
                             }
 
-                            ClusterableObjectType::Decal { .. } => {
+                            ClusterableObjectType::Decal => {
                                 // Decals currently affect all clusters in their
                                 // bounding sphere.
                                 //
diff --git a/crates/bevy_pbr/src/fog.rs b/crates/bevy_pbr/src/fog.rs
index 831ec6928..6d2b6bdfd 100644
--- a/crates/bevy_pbr/src/fog.rs
+++ b/crates/bevy_pbr/src/fog.rs
@@ -141,11 +141,11 @@ pub enum FogFalloff {
     /// ## Tips
     ///
     /// - Use the [`FogFalloff::from_visibility()`] convenience method to create an exponential falloff with the proper
-    ///     density for a desired visibility distance in world units;
+    ///   density for a desired visibility distance in world units;
     /// - It's not _unusual_ to have very large or very small values for the density, depending on the scene
-    ///     scale. Typically, for scenes with objects in the scale of thousands of units, you might want density values
-    ///     in the ballpark of `0.001`. Conversely, for really small scale scenes you might want really high values of
-    ///     density;
+    ///   scale. Typically, for scenes with objects in the scale of thousands of units, you might want density values
+    ///   in the ballpark of `0.001`. Conversely, for really small scale scenes you might want really high values of
+    ///   density;
     /// - Combine the `density` parameter with the [`DistanceFog`] `color`'s alpha channel for easier artistic control.
     ///
     /// ## Formula
@@ -193,7 +193,7 @@ pub enum FogFalloff {
     /// ## Tips
     ///
     /// - Use the [`FogFalloff::from_visibility_squared()`] convenience method to create an exponential squared falloff
-    ///     with the proper density for a desired visibility distance in world units;
+    ///   with the proper density for a desired visibility distance in world units;
     /// - Combine the `density` parameter with the [`DistanceFog`] `color`'s alpha channel for easier artistic control.
     ///
     /// ## Formula
@@ -239,8 +239,8 @@ pub enum FogFalloff {
     /// ## Tips
     ///
     /// - Use the [`FogFalloff::from_visibility_colors()`] or [`FogFalloff::from_visibility_color()`] convenience methods
-    ///     to create an atmospheric falloff with the proper densities for a desired visibility distance in world units and
-    ///     extinction and inscattering colors;
+    ///   to create an atmospheric falloff with the proper densities for a desired visibility distance in world units and
+    ///   extinction and inscattering colors;
     /// - Combine the atmospheric fog parameters with the [`DistanceFog`] `color`'s alpha channel for easier artistic control.
     ///
     /// ## Formula
diff --git a/crates/bevy_pbr/src/light_probe/irradiance_volume.rs b/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
index 799329e98..246321ff8 100644
--- a/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
+++ b/crates/bevy_pbr/src/light_probe/irradiance_volume.rs
@@ -81,17 +81,17 @@
 //! less ideal for this use case:
 //!
 //! 1. The level 1 spherical harmonic coefficients can be negative. That
-//!     prevents the use of the efficient [RGB9E5 texture format], which only
-//!     encodes unsigned floating point numbers, and forces the use of the
-//!     less-efficient [RGBA16F format] if hardware interpolation is desired.
+//!    prevents the use of the efficient [RGB9E5 texture format], which only
+//!    encodes unsigned floating point numbers, and forces the use of the
+//!    less-efficient [RGBA16F format] if hardware interpolation is desired.
 //!
 //! 2. As an alternative to RGBA16F, level 1 spherical harmonics can be
-//!     normalized and scaled to the SH0 base color, as [Frostbite] does. This
-//!     allows them to be packed in standard LDR RGBA8 textures. However, this
-//!     prevents the use of hardware trilinear filtering, as the nonuniform scale
-//!     factor means that hardware interpolation no longer produces correct results.
-//!     The 8 texture fetches needed to interpolate between voxels can be upwards of
-//!     twice as slow as the hardware interpolation.
+//!    normalized and scaled to the SH0 base color, as [Frostbite] does. This
+//!    allows them to be packed in standard LDR RGBA8 textures. However, this
+//!    prevents the use of hardware trilinear filtering, as the nonuniform scale
+//!    factor means that hardware interpolation no longer produces correct results.
+//!    The 8 texture fetches needed to interpolate between voxels can be upwards of
+//!    twice as slow as the hardware interpolation.
 //!
 //! The following chart summarizes the costs and benefits of ambient cubes,
 //! level 1 spherical harmonics, and level 2 spherical harmonics:
diff --git a/crates/bevy_pbr/src/light_probe/mod.rs b/crates/bevy_pbr/src/light_probe/mod.rs
index 3ef3e78db..c728a1cc6 100644
--- a/crates/bevy_pbr/src/light_probe/mod.rs
+++ b/crates/bevy_pbr/src/light_probe/mod.rs
@@ -769,22 +769,22 @@ pub(crate) fn add_cubemap_texture_view<'a>(
 /// (a.k.a. bindless textures). This function checks for these pitfalls:
 ///
 /// 1. If GLSL support is enabled at the feature level, then in debug mode
-///     `naga_oil` will attempt to compile all shader modules under GLSL to check
-///     validity of names, even if GLSL isn't actually used. This will cause a crash
-///     if binding arrays are enabled, because binding arrays are currently
-///     unimplemented in the GLSL backend of Naga. Therefore, we disable binding
-///     arrays if the `shader_format_glsl` feature is present.
+///    `naga_oil` will attempt to compile all shader modules under GLSL to check
+///    validity of names, even if GLSL isn't actually used. This will cause a crash
+///    if binding arrays are enabled, because binding arrays are currently
+///    unimplemented in the GLSL backend of Naga. Therefore, we disable binding
+///    arrays if the `shader_format_glsl` feature is present.
 ///
 /// 2. If there aren't enough texture bindings available to accommodate all the
-///     binding arrays, the driver will panic. So we also bail out if there aren't
-///     enough texture bindings available in the fragment shader.
+///    binding arrays, the driver will panic. So we also bail out if there aren't
+///    enough texture bindings available in the fragment shader.
 ///
 /// 3. If binding arrays aren't supported on the hardware, then we obviously
 ///    can't use them. Adreno <= 610 claims to support bindless, but seems to be
 ///    too buggy to be usable.
 ///
 /// 4. If binding arrays are supported on the hardware, but they can only be
-///     accessed by uniform indices, that's not good enough, and we bail out.
+///    accessed by uniform indices, that's not good enough, and we bail out.
 ///
 /// If binding arrays aren't usable, we disable reflection probes and limit the
 /// number of irradiance volumes in the scene to 1.
diff --git a/crates/bevy_pbr/src/material.rs b/crates/bevy_pbr/src/material.rs
index b32d57440..ed2f080ad 100644
--- a/crates/bevy_pbr/src/material.rs
+++ b/crates/bevy_pbr/src/material.rs
@@ -1229,8 +1229,8 @@ impl<M: Material> RenderAsset for PreparedMaterial<M> {
             render_device,
             pipeline,
             default_opaque_render_method,
-            ref mut bind_group_allocator,
-            ref mut render_material_bindings,
+            bind_group_allocator,
+            render_material_bindings,
             opaque_draw_functions,
             alpha_mask_draw_functions,
             transmissive_draw_functions,
@@ -1239,7 +1239,7 @@ impl<M: Material> RenderAsset for PreparedMaterial<M> {
             alpha_mask_prepass_draw_functions,
             opaque_deferred_draw_functions,
             alpha_mask_deferred_draw_functions,
-            ref mut material_param,
+            material_param,
         ): &mut SystemParamItem<Self::Param>,
     ) -> Result<Self, PrepareAssetError<Self::SourceAsset>> {
         let draw_opaque_pbr = opaque_draw_functions.read().id::<DrawMaterial<M>>();
@@ -1394,14 +1394,9 @@ impl<M: Material> RenderAsset for PreparedMaterial<M> {
 
     fn unload_asset(
         source_asset: AssetId<Self::SourceAsset>,
-        (
-            _,
-            _,
-            _,
-            ref mut bind_group_allocator,
-            ref mut render_material_bindings,
-            ..,
-        ): &mut SystemParamItem<Self::Param>,
+        (_, _, _, bind_group_allocator, render_material_bindings, ..): &mut SystemParamItem<
+            Self::Param,
+        >,
     ) {
         let Some(material_binding_id) = render_material_bindings.remove(&source_asset.untyped())
         else {
diff --git a/crates/bevy_pbr/src/meshlet/from_mesh.rs b/crates/bevy_pbr/src/meshlet/from_mesh.rs
index 7b959eef4..016722b09 100644
--- a/crates/bevy_pbr/src/meshlet/from_mesh.rs
+++ b/crates/bevy_pbr/src/meshlet/from_mesh.rs
@@ -102,11 +102,13 @@ impl MeshletMesh {
                 },
             })
             .collect::<Vec<_>>();
-        let mut simplification_errors = iter::repeat(MeshletSimplificationError {
-            group_error: f16::ZERO,
-            parent_group_error: f16::MAX,
-        })
-        .take(meshlets.len())
+        let mut simplification_errors = iter::repeat_n(
+            MeshletSimplificationError {
+                group_error: f16::ZERO,
+                parent_group_error: f16::MAX,
+            },
+            meshlets.len(),
+        )
         .collect::<Vec<_>>();
 
         let mut vertex_locks = vec![false; vertices.vertex_count];
@@ -187,13 +189,13 @@ impl MeshletMesh {
                         },
                     }
                 }));
-                simplification_errors.extend(
-                    iter::repeat(MeshletSimplificationError {
+                simplification_errors.extend(iter::repeat_n(
+                    MeshletSimplificationError {
                         group_error,
                         parent_group_error: f16::MAX,
-                    })
-                    .take(new_meshlet_ids.len()),
-                );
+                    },
+                    new_meshlet_ids.len(),
+                ));
             }
 
             // Set simplification queue to the list of newly created meshlets
diff --git a/crates/bevy_pbr/src/meshlet/resource_manager.rs b/crates/bevy_pbr/src/meshlet/resource_manager.rs
index 1d3828b95..9fb1387ae 100644
--- a/crates/bevy_pbr/src/meshlet/resource_manager.rs
+++ b/crates/bevy_pbr/src/meshlet/resource_manager.rs
@@ -455,7 +455,7 @@ pub fn prepare_meshlet_per_frame_resources(
                 let index = instance_index / 32;
                 let bit = instance_index - index * 32;
                 if vec.len() <= index {
-                    vec.extend(iter::repeat(0).take(index - vec.len() + 1));
+                    vec.extend(iter::repeat_n(0, index - vec.len() + 1));
                 }
                 vec[index] |= 1 << bit;
             }
diff --git a/crates/bevy_pbr/src/pbr_material.rs b/crates/bevy_pbr/src/pbr_material.rs
index 44d1b960d..0eee3cfd8 100644
--- a/crates/bevy_pbr/src/pbr_material.rs
+++ b/crates/bevy_pbr/src/pbr_material.rs
@@ -249,13 +249,13 @@ pub struct StandardMaterial {
     /// with distortion and blur effects.
     ///
     /// - [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) can be used to enable transmissive objects
-    ///     to be seen through other transmissive objects, at the cost of additional draw calls and texture copies; (Use with caution!)
-    ///     - If a simplified approximation of specular transmission using only environment map lighting is sufficient, consider setting
-    ///         [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) to `0`.
+    ///   to be seen through other transmissive objects, at the cost of additional draw calls and texture copies; (Use with caution!)
+    ///   - If a simplified approximation of specular transmission using only environment map lighting is sufficient, consider setting
+    ///     [`Camera3d::screen_space_specular_transmission_steps`](bevy_core_pipeline::core_3d::Camera3d::screen_space_specular_transmission_steps) to `0`.
     /// - If purely diffuse light transmission is needed, (i.e. translucency) consider using [`StandardMaterial::diffuse_transmission`] instead,
-    ///     for a much less expensive effect.
+    ///   for a much less expensive effect.
     /// - Specular transmission is rendered before alpha blending, so any material with [`AlphaMode::Blend`], [`AlphaMode::Premultiplied`], [`AlphaMode::Add`] or [`AlphaMode::Multiply`]
-    ///     won't be visible through specular transmissive materials.
+    ///   won't be visible through specular transmissive materials.
     #[doc(alias = "refraction")]
     pub specular_transmission: f32,
 
diff --git a/crates/bevy_pbr/src/render/gpu_preprocess.rs b/crates/bevy_pbr/src/render/gpu_preprocess.rs
index fbb54cb1e..e6f8addee 100644
--- a/crates/bevy_pbr/src/render/gpu_preprocess.rs
+++ b/crates/bevy_pbr/src/render/gpu_preprocess.rs
@@ -918,8 +918,8 @@ impl Node for LateGpuPreprocessNode {
                         ..
                     },
                     Some(PhasePreprocessBindGroups::IndirectOcclusionCulling {
-                        late_indexed: ref maybe_late_indexed_bind_group,
-                        late_non_indexed: ref maybe_late_non_indexed_bind_group,
+                        late_indexed: maybe_late_indexed_bind_group,
+                        late_non_indexed: maybe_late_non_indexed_bind_group,
                         ..
                     }),
                     Some(late_indexed_indirect_parameters_buffer),
@@ -1747,9 +1747,9 @@ pub fn prepare_preprocess_bind_groups(
 ) {
     // Grab the `BatchedInstanceBuffers`.
     let BatchedInstanceBuffers {
-        current_input_buffer: ref current_input_buffer_vec,
-        previous_input_buffer: ref previous_input_buffer_vec,
-        ref phase_instance_buffers,
+        current_input_buffer: current_input_buffer_vec,
+        previous_input_buffer: previous_input_buffer_vec,
+        phase_instance_buffers,
     } = batched_instance_buffers.into_inner();
 
     let (Some(current_input_buffer), Some(previous_input_buffer)) = (
diff --git a/crates/bevy_pbr/src/render/mesh.rs b/crates/bevy_pbr/src/render/mesh.rs
index fb9737f7e..433df17c5 100644
--- a/crates/bevy_pbr/src/render/mesh.rs
+++ b/crates/bevy_pbr/src/render/mesh.rs
@@ -1675,7 +1675,7 @@ pub fn collect_meshes_for_gpu_building(
     frame_count: Res<FrameCount>,
     mut meshes_to_reextract_next_frame: ResMut<MeshesToReextractNextFrame>,
 ) {
-    let RenderMeshInstances::GpuBuilding(ref mut render_mesh_instances) =
+    let RenderMeshInstances::GpuBuilding(render_mesh_instances) =
         render_mesh_instances.into_inner()
     else {
         return;
@@ -1686,8 +1686,8 @@ pub fn collect_meshes_for_gpu_building(
 
     // Collect render mesh instances. Build up the uniform buffer.
     let gpu_preprocessing::BatchedInstanceBuffers {
-        ref mut current_input_buffer,
-        ref mut previous_input_buffer,
+        current_input_buffer,
+        previous_input_buffer,
         ..
     } = batched_instance_buffers.into_inner();
 
diff --git a/crates/bevy_picking/Cargo.toml b/crates/bevy_picking/Cargo.toml
index 70d470ffc..55d8e0216 100644
--- a/crates/bevy_picking/Cargo.toml
+++ b/crates/bevy_picking/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_picking"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides screen picking functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_platform_support/Cargo.toml b/crates/bevy_platform_support/Cargo.toml
index 630b928f2..cd45267b5 100644
--- a/crates/bevy_platform_support/Cargo.toml
+++ b/crates/bevy_platform_support/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_platform_support"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Platform compatibility support for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_ptr/Cargo.toml b/crates/bevy_ptr/Cargo.toml
index d2c3db4fb..0f56880bd 100644
--- a/crates/bevy_ptr/Cargo.toml
+++ b/crates/bevy_ptr/Cargo.toml
@@ -1,13 +1,13 @@
 [package]
 name = "bevy_ptr"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Utilities for working with untyped pointers in a more safe way"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
 license = "MIT OR Apache-2.0"
 keywords = ["bevy", "no_std"]
-rust-version = "1.81.0"
+rust-version = "1.85.0"
 
 [dependencies]
 
diff --git a/crates/bevy_ptr/src/lib.rs b/crates/bevy_ptr/src/lib.rs
index adb72409f..e09cdb519 100644
--- a/crates/bevy_ptr/src/lib.rs
+++ b/crates/bevy_ptr/src/lib.rs
@@ -413,9 +413,10 @@ impl<'a> OwningPtr<'a> {
     /// Consumes a value and creates an [`OwningPtr`] to it while ensuring a double drop does not happen.
     #[inline]
     pub fn make<T, F: FnOnce(OwningPtr<'_>) -> R, R>(val: T, f: F) -> R {
+        let mut val = ManuallyDrop::new(val);
         // SAFETY: The value behind the pointer will not get dropped or observed later,
         // so it's safe to promote it to an owning pointer.
-        f(unsafe { Self::make_internal(&mut ManuallyDrop::new(val)) })
+        f(unsafe { Self::make_internal(&mut val) })
     }
 }
 
diff --git a/crates/bevy_reflect/Cargo.toml b/crates/bevy_reflect/Cargo.toml
index c15784d22..e2bfbd46d 100644
--- a/crates/bevy_reflect/Cargo.toml
+++ b/crates/bevy_reflect/Cargo.toml
@@ -1,13 +1,13 @@
 [package]
 name = "bevy_reflect"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Dynamically interact with rust types"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
 license = "MIT OR Apache-2.0"
 keywords = ["bevy"]
-rust-version = "1.81.0"
+rust-version = "1.85.0"
 
 [features]
 default = ["std", "smallvec", "debug"]
diff --git a/crates/bevy_reflect/compile_fail/Cargo.toml b/crates/bevy_reflect/compile_fail/Cargo.toml
index 14e5eb226..178711c5d 100644
--- a/crates/bevy_reflect/compile_fail/Cargo.toml
+++ b/crates/bevy_reflect/compile_fail/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "bevy_reflect_compile_fail"
-edition = "2021"
+edition = "2024"
 description = "Compile fail tests for Bevy Engine's reflection system"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_reflect/derive/Cargo.toml b/crates/bevy_reflect/derive/Cargo.toml
index bbdca03ca..45899d52f 100644
--- a/crates/bevy_reflect/derive/Cargo.toml
+++ b/crates/bevy_reflect/derive/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_reflect_derive"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Derive implementations for bevy_reflect"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_reflect/src/lib.rs b/crates/bevy_reflect/src/lib.rs
index 2845c716c..cf38c1da5 100644
--- a/crates/bevy_reflect/src/lib.rs
+++ b/crates/bevy_reflect/src/lib.rs
@@ -112,7 +112,7 @@
 //!
 //! Additionally, using the derive macro on enums requires a third condition to be met:
 //! * All fields and sub-elements must implement [`FromReflect`]
-//!     another important reflection trait discussed in a later section.
+//!   another important reflection trait discussed in a later section.
 //!
 //! # The Reflection Subtraits
 //!
diff --git a/crates/bevy_reflect/src/map.rs b/crates/bevy_reflect/src/map.rs
index f71689d59..1ce685b12 100644
--- a/crates/bevy_reflect/src/map.rs
+++ b/crates/bevy_reflect/src/map.rs
@@ -206,7 +206,6 @@ macro_rules! hash_error {
                 ),
             }
         }
-        .as_str()
     }}
 }
 
@@ -244,7 +243,7 @@ impl DynamicMap {
     }
 
     fn internal_hash(value: &dyn PartialReflect) -> u64 {
-        value.reflect_hash().expect(hash_error!(value))
+        value.reflect_hash().expect(&hash_error!(value))
     }
 
     fn internal_eq<'a>(
diff --git a/crates/bevy_reflect/src/serde/type_data.rs b/crates/bevy_reflect/src/serde/type_data.rs
index 8df80c700..f1b0129a3 100644
--- a/crates/bevy_reflect/src/serde/type_data.rs
+++ b/crates/bevy_reflect/src/serde/type_data.rs
@@ -14,9 +14,9 @@ impl SerializationData {
     /// # Arguments
     ///
     /// * `skipped_iter`: The iterator of field indices to be skipped during (de)serialization.
-    ///                   Indices are assigned only to reflected fields.
-    ///                   Ignored fields (i.e. those marked `#[reflect(ignore)]`) are implicitly skipped
-    ///                   and do not need to be included in this iterator.
+    ///   Indices are assigned only to reflected fields.
+    ///   Ignored fields (i.e. those marked `#[reflect(ignore)]`) are implicitly skipped
+    ///   and do not need to be included in this iterator.
     pub fn new<I: Iterator<Item = (usize, SkippedField)>>(skipped_iter: I) -> Self {
         Self {
             skipped_fields: skipped_iter.collect(),
diff --git a/crates/bevy_reflect/src/set.rs b/crates/bevy_reflect/src/set.rs
index 52b4e8b9a..799499a8a 100644
--- a/crates/bevy_reflect/src/set.rs
+++ b/crates/bevy_reflect/src/set.rs
@@ -167,7 +167,7 @@ impl DynamicSet {
     }
 
     fn internal_hash(value: &dyn PartialReflect) -> u64 {
-        value.reflect_hash().expect(hash_error!(value))
+        value.reflect_hash().expect(&hash_error!(value))
     }
 
     fn internal_eq(
diff --git a/crates/bevy_remote/Cargo.toml b/crates/bevy_remote/Cargo.toml
index 9d2f6f25f..d6c26a76c 100644
--- a/crates/bevy_remote/Cargo.toml
+++ b/crates/bevy_remote/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_remote"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "The Bevy Remote Protocol"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_remote/src/lib.rs b/crates/bevy_remote/src/lib.rs
index 75ba79d58..ca3792b7e 100644
--- a/crates/bevy_remote/src/lib.rs
+++ b/crates/bevy_remote/src/lib.rs
@@ -137,7 +137,7 @@
 //!     see _below_ example for a query to list all the type names in **your** project.
 //!   - `option` (optional): An array of fully-qualified type names of components to fetch optionally.
 //!   - `has` (optional): An array of fully-qualified type names of components whose presence will be
-//!      reported as boolean values.
+//!     reported as boolean values.
 //! - `filter` (optional):
 //!   - `with` (optional): An array of fully-qualified type names of components that must be present
 //!     on entities in order for them to be included in results.
diff --git a/crates/bevy_render/Cargo.toml b/crates/bevy_render/Cargo.toml
index 416718563..7da865a0d 100644
--- a/crates/bevy_render/Cargo.toml
+++ b/crates/bevy_render/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_render"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides rendering functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_render/macros/Cargo.toml b/crates/bevy_render/macros/Cargo.toml
index 237cc516c..c3fc40b23 100644
--- a/crates/bevy_render/macros/Cargo.toml
+++ b/crates/bevy_render/macros/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_render_macros"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Derive implementations for bevy_render"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_render/src/batching/gpu_preprocessing.rs b/crates/bevy_render/src/batching/gpu_preprocessing.rs
index 661bc901f..3e29f72ba 100644
--- a/crates/bevy_render/src/batching/gpu_preprocessing.rs
+++ b/crates/bevy_render/src/batching/gpu_preprocessing.rs
@@ -1580,7 +1580,7 @@ pub fn batch_and_prepare_binned_render_phase<BPI, GFBD>(
             }
 
             // Reserve space in the occlusion culling buffers, if necessary.
-            if let Some(ref mut gpu_occlusion_culling_buffers) = gpu_occlusion_culling_buffers {
+            if let Some(gpu_occlusion_culling_buffers) = gpu_occlusion_culling_buffers {
                 gpu_occlusion_culling_buffers
                     .late_indexed
                     .add_multiple(indexed_preparer.work_item_count);
@@ -1985,9 +1985,9 @@ pub fn write_batched_instance_buffers<GFBD>(
     GFBD: GetFullBatchData,
 {
     let BatchedInstanceBuffers {
-        ref mut current_input_buffer,
-        ref mut previous_input_buffer,
-        ref mut phase_instance_buffers,
+        current_input_buffer,
+        previous_input_buffer,
+        phase_instance_buffers,
     } = gpu_array_buffer.into_inner();
 
     current_input_buffer
diff --git a/crates/bevy_render/src/mesh/allocator.rs b/crates/bevy_render/src/mesh/allocator.rs
index 712fbc627..cb023f1a9 100644
--- a/crates/bevy_render/src/mesh/allocator.rs
+++ b/crates/bevy_render/src/mesh/allocator.rs
@@ -409,7 +409,7 @@ impl MeshAllocator {
         slab_id: SlabId,
     ) -> Option<MeshBufferSlice> {
         match self.slabs.get(&slab_id)? {
-            Slab::General(ref general_slab) => {
+            Slab::General(general_slab) => {
                 let slab_allocation = general_slab.resident_allocations.get(mesh_id)?;
                 Some(MeshBufferSlice {
                     buffer: general_slab.buffer.as_ref()?,
@@ -420,7 +420,7 @@ impl MeshAllocator {
                 })
             }
 
-            Slab::LargeObject(ref large_object_slab) => {
+            Slab::LargeObject(large_object_slab) => {
                 let buffer = large_object_slab.buffer.as_ref()?;
                 Some(MeshBufferSlice {
                     buffer,
@@ -555,7 +555,7 @@ impl MeshAllocator {
 
         match *slab {
             Slab::General(ref mut general_slab) => {
-                let (Some(ref buffer), Some(allocated_range)) = (
+                let (Some(buffer), Some(allocated_range)) = (
                     &general_slab.buffer,
                     general_slab.pending_allocations.remove(mesh_id),
                 ) else {
@@ -706,7 +706,7 @@ impl MeshAllocator {
         // that succeeds.
         let mut mesh_allocation = None;
         for &slab_id in &*candidate_slabs {
-            let Some(Slab::General(ref mut slab)) = self.slabs.get_mut(&slab_id) else {
+            let Some(Slab::General(slab)) = self.slabs.get_mut(&slab_id) else {
                 unreachable!("Slab not found")
             };
 
@@ -763,9 +763,7 @@ impl MeshAllocator {
         // Mark the allocation as pending. Don't copy it in just yet; further
         // meshes loaded this frame may result in its final allocation location
         // changing.
-        if let Some(Slab::General(ref mut general_slab)) =
-            self.slabs.get_mut(&mesh_allocation.slab_id)
-        {
+        if let Some(Slab::General(general_slab)) = self.slabs.get_mut(&mesh_allocation.slab_id) {
             general_slab
                 .pending_allocations
                 .insert(*mesh_id, mesh_allocation.slab_allocation);
diff --git a/crates/bevy_render/src/mesh/mod.rs b/crates/bevy_render/src/mesh/mod.rs
index 40fb08d98..fbd530c14 100644
--- a/crates/bevy_render/src/mesh/mod.rs
+++ b/crates/bevy_render/src/mesh/mod.rs
@@ -208,7 +208,7 @@ impl RenderAsset for RenderMesh {
     fn prepare_asset(
         mesh: Self::SourceAsset,
         _: AssetId<Self::SourceAsset>,
-        (images, ref mut mesh_vertex_buffer_layouts): &mut SystemParamItem<Self::Param>,
+        (images, mesh_vertex_buffer_layouts): &mut SystemParamItem<Self::Param>,
     ) -> Result<Self, PrepareAssetError<Self::SourceAsset>> {
         let morph_targets = match mesh.morph_targets() {
             Some(mt) => {
diff --git a/crates/bevy_render/src/pipelined_rendering.rs b/crates/bevy_render/src/pipelined_rendering.rs
index ed54a6301..fb665e469 100644
--- a/crates/bevy_render/src/pipelined_rendering.rs
+++ b/crates/bevy_render/src/pipelined_rendering.rs
@@ -92,14 +92,14 @@ impl Drop for RenderAppChannels {
 /// ```
 ///
 /// - `sync` is the step where the entity-entity mapping between the main and render world is updated.
-///     This is run on the main app's thread. For more information checkout [`SyncWorldPlugin`].
+///   This is run on the main app's thread. For more information checkout [`SyncWorldPlugin`].
 /// - `extract` is the step where data is copied from the main world to the render world.
-///     This is run on the main app's thread.
+///   This is run on the main app's thread.
 /// - On the render thread, we first apply the `extract commands`. This is not run during extract, so the
-///     main schedule can start sooner.
+///   main schedule can start sooner.
 /// - Then the `rendering schedule` is run. See [`RenderSet`](crate::RenderSet) for the standard steps in this process.
 /// - In parallel to the rendering thread the [`RenderExtractApp`] schedule runs. By
-///     default, this schedule is empty. But it is useful if you need something to run before I/O processing.
+///   default, this schedule is empty. But it is useful if you need something to run before I/O processing.
 /// - Next all the `winit events` are processed.
 /// - And finally the `main app schedule` is run.
 /// - Once both the `main app schedule` and the `render schedule` are finished running, `extract` is run again.
diff --git a/crates/bevy_render/src/primitives/mod.rs b/crates/bevy_render/src/primitives/mod.rs
index 9123e95b5..10cbe4bd9 100644
--- a/crates/bevy_render/src/primitives/mod.rs
+++ b/crates/bevy_render/src/primitives/mod.rs
@@ -7,7 +7,7 @@ use bevy_reflect::prelude::*;
 /// An axis-aligned bounding box, defined by:
 /// - a center,
 /// - the distances from the center to each faces along the axis,
-///     the faces are orthogonal to the axis.
+///   the faces are orthogonal to the axis.
 ///
 /// It is typically used as a component on an entity to represent the local space
 /// occupied by this entity, with faces orthogonal to its local axis.
@@ -18,7 +18,7 @@ use bevy_reflect::prelude::*;
 ///
 /// It will be added automatically by the systems in [`CalculateBounds`] to entities that:
 /// - could be subject to frustum culling, for example with a [`Mesh3d`]
-///     or `Sprite` component,
+///   or `Sprite` component,
 /// - don't have the [`NoFrustumCulling`] component.
 ///
 /// It won't be updated automatically if the space occupied by the entity changes,
diff --git a/crates/bevy_render/src/render_phase/mod.rs b/crates/bevy_render/src/render_phase/mod.rs
index ede05bb2f..24a7bc4b6 100644
--- a/crates/bevy_render/src/render_phase/mod.rs
+++ b/crates/bevy_render/src/render_phase/mod.rs
@@ -712,7 +712,7 @@ where
                             }
                         },
                     },
-                    UnbatchableBinnedEntityIndexSet::Dense(ref dynamic_offsets) => {
+                    UnbatchableBinnedEntityIndexSet::Dense(dynamic_offsets) => {
                         dynamic_offsets[entity_index].clone()
                     }
                 };
@@ -1003,7 +1003,7 @@ impl UnbatchableBinnedEntityIndexSet {
                     },
                 })
             }
-            UnbatchableBinnedEntityIndexSet::Dense(ref indices) => {
+            UnbatchableBinnedEntityIndexSet::Dense(indices) => {
                 indices.get(entity_index as usize).cloned()
             }
         }
@@ -1223,7 +1223,7 @@ impl UnbatchableBinnedEntityIndexSet {
             }
 
             UnbatchableBinnedEntityIndexSet::Sparse {
-                ref mut instance_range,
+                instance_range,
                 first_indirect_parameters_index,
             } if instance_range.end == indices.instance_index
                 && ((first_indirect_parameters_index.is_none()
@@ -1261,7 +1261,7 @@ impl UnbatchableBinnedEntityIndexSet {
                 *self = UnbatchableBinnedEntityIndexSet::Dense(new_dynamic_offsets);
             }
 
-            UnbatchableBinnedEntityIndexSet::Dense(ref mut dense_indices) => {
+            UnbatchableBinnedEntityIndexSet::Dense(dense_indices) => {
                 dense_indices.push(indices);
             }
         }
@@ -1383,15 +1383,15 @@ where
 /// [`SortedPhaseItem`]s.
 ///
 /// * Binned phase items have a `BinKey` which specifies what bin they're to be
-///     placed in. All items in the same bin are eligible to be batched together.
-///     The `BinKey`s are sorted, but the individual bin items aren't. Binned phase
-///     items are good for opaque meshes, in which the order of rendering isn't
-///     important. Generally, binned phase items are faster than sorted phase items.
+///   placed in. All items in the same bin are eligible to be batched together.
+///   The `BinKey`s are sorted, but the individual bin items aren't. Binned phase
+///   items are good for opaque meshes, in which the order of rendering isn't
+///   important. Generally, binned phase items are faster than sorted phase items.
 ///
 /// * Sorted phase items, on the other hand, are placed into one large buffer
-///     and then sorted all at once. This is needed for transparent meshes, which
-///     have to be sorted back-to-front to render with the painter's algorithm.
-///     These types of phase items are generally slower than binned phase items.
+///   and then sorted all at once. This is needed for transparent meshes, which
+///   have to be sorted back-to-front to render with the painter's algorithm.
+///   These types of phase items are generally slower than binned phase items.
 pub trait PhaseItem: Sized + Send + Sync + 'static {
     /// Whether or not this `PhaseItem` should be subjected to automatic batching. (Default: `true`)
     const AUTOMATIC_BATCHING: bool = true;
@@ -1432,12 +1432,12 @@ pub trait PhaseItem: Sized + Send + Sync + 'static {
 /// instances they already have. These can be:
 ///
 /// * The *dynamic offset*: a `wgpu` dynamic offset into the uniform buffer of
-///     instance data. This is used on platforms that don't support storage
-///     buffers, to work around uniform buffer size limitations.
+///   instance data. This is used on platforms that don't support storage
+///   buffers, to work around uniform buffer size limitations.
 ///
 /// * The *indirect parameters index*: an index into the buffer that specifies
-///     the indirect parameters for this [`PhaseItem`]'s drawcall. This is used when
-///     indirect mode is on (as used for GPU culling).
+///   the indirect parameters for this [`PhaseItem`]'s drawcall. This is used when
+///   indirect mode is on (as used for GPU culling).
 ///
 /// Note that our indirect draw functionality requires storage buffers, so it's
 /// impossible to have both a dynamic offset and an indirect parameters index.
diff --git a/crates/bevy_render/src/render_resource/bind_group.rs b/crates/bevy_render/src/render_resource/bind_group.rs
index 9fe835bb1..6db28ec55 100644
--- a/crates/bevy_render/src/render_resource/bind_group.rs
+++ b/crates/bevy_render/src/render_resource/bind_group.rs
@@ -148,16 +148,16 @@ impl Deref for BindGroup {
 /// ## `uniform(BINDING_INDEX)`
 ///
 ///  * The field will be converted to a shader-compatible type using the [`ShaderType`] trait, written to a [`Buffer`], and bound as a uniform.
-///      [`ShaderType`] is implemented for most math types already, such as [`f32`], [`Vec4`](bevy_math::Vec4), and
-///      [`LinearRgba`](bevy_color::LinearRgba). It can also be derived for custom structs.
+///    [`ShaderType`] is implemented for most math types already, such as [`f32`], [`Vec4`](bevy_math::Vec4), and
+///    [`LinearRgba`](bevy_color::LinearRgba). It can also be derived for custom structs.
 ///
 /// ## `texture(BINDING_INDEX, arguments)`
 ///
 ///  * This field's [`Handle<Image>`](bevy_asset::Handle) will be used to look up the matching [`Texture`](crate::render_resource::Texture)
-///      GPU resource, which will be bound as a texture in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
-///      most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
-///      [`None`], the [`crate::texture::FallbackImage`] resource will be used instead. This attribute can be used in conjunction with a `sampler` binding attribute
-///      (with a different binding index) if a binding of the sampler for the [`Image`](bevy_image::Image) is also required.
+///    GPU resource, which will be bound as a texture in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
+///    most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
+///    [`None`], the [`crate::texture::FallbackImage`] resource will be used instead. This attribute can be used in conjunction with a `sampler` binding attribute
+///    (with a different binding index) if a binding of the sampler for the [`Image`](bevy_image::Image) is also required.
 ///
 /// | Arguments             | Values                                                                  | Default              |
 /// |-----------------------|-------------------------------------------------------------------------|----------------------|
@@ -170,9 +170,9 @@ impl Deref for BindGroup {
 /// ## `storage_texture(BINDING_INDEX, arguments)`
 ///
 /// * This field's [`Handle<Image>`](bevy_asset::Handle) will be used to look up the matching [`Texture`](crate::render_resource::Texture)
-///     GPU resource, which will be bound as a storage texture in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
-///     most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
-///     [`None`], the [`crate::texture::FallbackImage`] resource will be used instead.
+///   GPU resource, which will be bound as a storage texture in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
+///   most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
+///   [`None`], the [`crate::texture::FallbackImage`] resource will be used instead.
 ///
 /// | Arguments              | Values                                                                                     | Default       |
 /// |------------------------|--------------------------------------------------------------------------------------------|---------------|
@@ -184,10 +184,10 @@ impl Deref for BindGroup {
 /// ## `sampler(BINDING_INDEX, arguments)`
 ///
 /// * This field's [`Handle<Image>`](bevy_asset::Handle) will be used to look up the matching [`Sampler`] GPU
-///     resource, which will be bound as a sampler in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
-///     most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
-///     [`None`], the [`crate::texture::FallbackImage`] resource will be used instead. This attribute can be used in conjunction with a `texture` binding attribute
-///     (with a different binding index) if a binding of the texture for the [`Image`](bevy_image::Image) is also required.
+///   resource, which will be bound as a sampler in shaders. The field will be assumed to implement [`Into<Option<Handle<Image>>>`]. In practice,
+///   most fields should be a [`Handle<Image>`](bevy_asset::Handle) or [`Option<Handle<Image>>`]. If the value of an [`Option<Handle<Image>>`] is
+///   [`None`], the [`crate::texture::FallbackImage`] resource will be used instead. This attribute can be used in conjunction with a `texture` binding attribute
+///   (with a different binding index) if a binding of the texture for the [`Image`](bevy_image::Image) is also required.
 ///
 /// | Arguments              | Values                                                                  | Default                |
 /// |------------------------|-------------------------------------------------------------------------|------------------------|
@@ -294,9 +294,9 @@ impl Deref for BindGroup {
 /// ## `bind_group_data(DataType)`
 ///
 /// * The [`AsBindGroup`] type will be converted to some `DataType` using [`Into<DataType>`] and stored
-///     as [`AsBindGroup::Data`] as part of the [`AsBindGroup::as_bind_group`] call. This is useful if data needs to be stored alongside
-///     the generated bind group, such as a unique identifier for a material's bind group. The most common use case for this attribute
-///     is "shader pipeline specialization". See [`SpecializedRenderPipeline`](crate::render_resource::SpecializedRenderPipeline).
+///   as [`AsBindGroup::Data`] as part of the [`AsBindGroup::as_bind_group`] call. This is useful if data needs to be stored alongside
+///   the generated bind group, such as a unique identifier for a material's bind group. The most common use case for this attribute
+///   is "shader pipeline specialization". See [`SpecializedRenderPipeline`](crate::render_resource::SpecializedRenderPipeline).
 ///
 /// ## `bindless`
 ///
diff --git a/crates/bevy_render/src/render_resource/buffer_vec.rs b/crates/bevy_render/src/render_resource/buffer_vec.rs
index 207702421..4e6c787fb 100644
--- a/crates/bevy_render/src/render_resource/buffer_vec.rs
+++ b/crates/bevy_render/src/render_resource/buffer_vec.rs
@@ -316,7 +316,7 @@ where
 
         // TODO: Consider using unsafe code to push uninitialized, to prevent
         // the zeroing. It shows up in profiles.
-        self.data.extend(iter::repeat(0).take(element_size));
+        self.data.extend(iter::repeat_n(0, element_size));
 
         // Take a slice of the new data for `write_into` to use. This is
         // important: it hoists the bounds check up here so that the compiler
diff --git a/crates/bevy_render/src/render_resource/pipeline_cache.rs b/crates/bevy_render/src/render_resource/pipeline_cache.rs
index fb82a495d..37211edb0 100644
--- a/crates/bevy_render/src/render_resource/pipeline_cache.rs
+++ b/crates/bevy_render/src/render_resource/pipeline_cache.rs
@@ -882,16 +882,14 @@ impl PipelineCache {
                 };
             }
 
-            CachedPipelineState::Creating(ref mut task) => {
-                match bevy_tasks::futures::check_ready(task) {
-                    Some(Ok(pipeline)) => {
-                        cached_pipeline.state = CachedPipelineState::Ok(pipeline);
-                        return;
-                    }
-                    Some(Err(err)) => cached_pipeline.state = CachedPipelineState::Err(err),
-                    _ => (),
+            CachedPipelineState::Creating(task) => match bevy_tasks::futures::check_ready(task) {
+                Some(Ok(pipeline)) => {
+                    cached_pipeline.state = CachedPipelineState::Ok(pipeline);
+                    return;
                 }
-            }
+                Some(Err(err)) => cached_pipeline.state = CachedPipelineState::Err(err),
+                _ => (),
+            },
 
             CachedPipelineState::Err(err) => match err {
                 // Retry
diff --git a/crates/bevy_render/src/renderer/mod.rs b/crates/bevy_render/src/renderer/mod.rs
index 584523419..7d81db5a1 100644
--- a/crates/bevy_render/src/renderer/mod.rs
+++ b/crates/bevy_render/src/renderer/mod.rs
@@ -421,7 +421,7 @@ impl<'w> RenderContext<'w> {
 
     /// Gets the diagnostics recorder, used to track elapsed time and pipeline statistics
     /// of various render and compute passes.
-    pub fn diagnostic_recorder(&self) -> impl RecordDiagnostics {
+    pub fn diagnostic_recorder(&self) -> impl RecordDiagnostics + use<> {
         self.diagnostics_recorder.clone()
     }
 
diff --git a/crates/bevy_render/src/view/visibility/mod.rs b/crates/bevy_render/src/view/visibility/mod.rs
index 09dc516b6..ce8428585 100644
--- a/crates/bevy_render/src/view/visibility/mod.rs
+++ b/crates/bevy_render/src/view/visibility/mod.rs
@@ -204,7 +204,7 @@ impl ViewVisibility {
 /// It can be used for example:
 /// - when a [`Mesh`] is updated but its [`Aabb`] is not, which might happen with animations,
 /// - when using some light effects, like wanting a [`Mesh`] out of the [`Frustum`]
-///     to appear in the reflection of a [`Mesh`] within.
+///   to appear in the reflection of a [`Mesh`] within.
 #[derive(Debug, Component, Default, Reflect)]
 #[reflect(Component, Default, Debug)]
 pub struct NoFrustumCulling;
diff --git a/crates/bevy_scene/Cargo.toml b/crates/bevy_scene/Cargo.toml
index ac263fe73..617ad9324 100644
--- a/crates/bevy_scene/Cargo.toml
+++ b/crates/bevy_scene/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_scene"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides scene functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_sprite/Cargo.toml b/crates/bevy_sprite/Cargo.toml
index dc9c10154..78c22edf9 100644
--- a/crates/bevy_sprite/Cargo.toml
+++ b/crates/bevy_sprite/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_sprite"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides sprite functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_sprite/src/lib.rs b/crates/bevy_sprite/src/lib.rs
index 568701725..1107e6c38 100644
--- a/crates/bevy_sprite/src/lib.rs
+++ b/crates/bevy_sprite/src/lib.rs
@@ -171,7 +171,7 @@ impl Plugin for SpritePlugin {
 /// System calculating and inserting an [`Aabb`] component to entities with either:
 /// - a `Mesh2d` component,
 /// - a `Sprite` and `Handle<Image>` components,
-///     and without a [`NoFrustumCulling`] component.
+///   and without a [`NoFrustumCulling`] component.
 ///
 /// Used in system set [`VisibilitySystems::CalculateBounds`].
 pub fn calculate_bounds_2d(
diff --git a/crates/bevy_sprite/src/texture_slice/mod.rs b/crates/bevy_sprite/src/texture_slice/mod.rs
index 7ea01d583..7b1a1e33e 100644
--- a/crates/bevy_sprite/src/texture_slice/mod.rs
+++ b/crates/bevy_sprite/src/texture_slice/mod.rs
@@ -27,7 +27,7 @@ impl TextureSlice {
     /// # Arguments
     ///
     /// * `stretch_value` - The slice will repeat when the ratio between the *drawing dimensions* of texture and the
-    ///     *original texture size* (rect) are above `stretch_value`.
+    ///   *original texture size* (rect) are above `stretch_value`.
     /// * `tile_x` - should the slice be tiled horizontally
     /// * `tile_y` - should the slice be tiled vertically
     #[must_use]
diff --git a/crates/bevy_state/Cargo.toml b/crates/bevy_state/Cargo.toml
index e6ef17c19..942596102 100644
--- a/crates/bevy_state/Cargo.toml
+++ b/crates/bevy_state/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_state"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Finite state machines for Bevy"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_state/macros/Cargo.toml b/crates/bevy_state/macros/Cargo.toml
index 2b734d2d1..2f569f395 100644
--- a/crates/bevy_state/macros/Cargo.toml
+++ b/crates/bevy_state/macros/Cargo.toml
@@ -2,7 +2,7 @@
 name = "bevy_state_macros"
 version = "0.16.0-dev"
 description = "Macros for bevy_state"
-edition = "2021"
+edition = "2024"
 license = "MIT OR Apache-2.0"
 
 [lib]
diff --git a/crates/bevy_tasks/Cargo.toml b/crates/bevy_tasks/Cargo.toml
index 1020c6112..089aa917c 100644
--- a/crates/bevy_tasks/Cargo.toml
+++ b/crates/bevy_tasks/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_tasks"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "A task executor for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_tasks/src/lib.rs b/crates/bevy_tasks/src/lib.rs
index 220f3dcae..605596006 100644
--- a/crates/bevy_tasks/src/lib.rs
+++ b/crates/bevy_tasks/src/lib.rs
@@ -33,8 +33,8 @@ pub use conditional_send::*;
 
 /// Use [`ConditionalSendFuture`] for a future with an optional Send trait bound, as on certain platforms (eg. Wasm),
 /// futures aren't Send.
-pub trait ConditionalSendFuture: core::future::Future + ConditionalSend {}
-impl<T: core::future::Future + ConditionalSend> ConditionalSendFuture for T {}
+pub trait ConditionalSendFuture: Future + ConditionalSend {}
+impl<T: Future + ConditionalSend> ConditionalSendFuture for T {}
 
 use alloc::boxed::Box;
 
diff --git a/crates/bevy_text/Cargo.toml b/crates/bevy_text/Cargo.toml
index a5e8dea07..2966f30d7 100644
--- a/crates/bevy_text/Cargo.toml
+++ b/crates/bevy_text/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_text"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides text functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_time/Cargo.toml b/crates/bevy_time/Cargo.toml
index f209e0174..97fcda1b0 100644
--- a/crates/bevy_time/Cargo.toml
+++ b/crates/bevy_time/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_time"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides time functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_transform/Cargo.toml b/crates/bevy_transform/Cargo.toml
index 56db18a2f..bab7607b9 100644
--- a/crates/bevy_transform/Cargo.toml
+++ b/crates/bevy_transform/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_transform"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides transform functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_transform/src/components/global_transform.rs b/crates/bevy_transform/src/components/global_transform.rs
index ecd59fac9..557c1dd6f 100644
--- a/crates/bevy_transform/src/components/global_transform.rs
+++ b/crates/bevy_transform/src/components/global_transform.rs
@@ -23,7 +23,7 @@ use {
 ///
 /// * To get the global transform of an entity, you should get its [`GlobalTransform`].
 /// * For transform hierarchies to work correctly, you must have both a [`Transform`] and a [`GlobalTransform`].
-///     [`GlobalTransform`] is automatically inserted whenever [`Transform`] is inserted.
+///   [`GlobalTransform`] is automatically inserted whenever [`Transform`] is inserted.
 ///
 /// ## [`Transform`] and [`GlobalTransform`]
 ///
diff --git a/crates/bevy_transform/src/components/transform.rs b/crates/bevy_transform/src/components/transform.rs
index baa3a6619..294901584 100644
--- a/crates/bevy_transform/src/components/transform.rs
+++ b/crates/bevy_transform/src/components/transform.rs
@@ -201,8 +201,8 @@ impl Transform {
     /// * if `main_axis` or `main_direction` fail converting to `Dir3` (e.g are zero), `Dir3::X` takes their place
     /// * if `secondary_axis` or `secondary_direction` fail converting, `Dir3::Y` takes their place
     /// * if `main_axis` is parallel with `secondary_axis` or `main_direction` is parallel with `secondary_direction`,
-    ///     a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
-    ///     counterparts
+    ///   a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
+    ///   counterparts
     ///
     /// See [`Transform::align`] for additional details.
     #[inline]
@@ -480,7 +480,7 @@ impl Transform {
     /// More precisely, the [`Transform::rotation`] produced will be such that:
     /// * applying it to `main_axis` results in `main_direction`
     /// * applying it to `secondary_axis` produces a vector that lies in the half-plane generated by `main_direction` and
-    ///     `secondary_direction` (with positive contribution by `secondary_direction`)
+    ///   `secondary_direction` (with positive contribution by `secondary_direction`)
     ///
     /// [`Transform::look_to`] is recovered, for instance, when `main_axis` is `Dir3::NEG_Z` (the [`Transform::forward`]
     /// direction in the default orientation) and `secondary_axis` is `Dir3::Y` (the [`Transform::up`] direction in the default
@@ -490,8 +490,8 @@ impl Transform {
     /// * if `main_axis` or `main_direction` fail converting to `Dir3` (e.g are zero), `Dir3::X` takes their place
     /// * if `secondary_axis` or `secondary_direction` fail converting, `Dir3::Y` takes their place
     /// * if `main_axis` is parallel with `secondary_axis` or `main_direction` is parallel with `secondary_direction`,
-    ///     a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
-    ///     counterparts
+    ///   a rotation is constructed which takes `main_axis` to `main_direction` along a great circle, ignoring the secondary
+    ///   counterparts
     ///
     /// Example
     /// ```
diff --git a/crates/bevy_transform/src/systems.rs b/crates/bevy_transform/src/systems.rs
index d9c6f0932..45bc4d91a 100644
--- a/crates/bevy_transform/src/systems.rs
+++ b/crates/bevy_transform/src/systems.rs
@@ -157,9 +157,9 @@ mod serial {
     /// # Safety
     ///
     /// - While this function is running, `transform_query` must not have any fetches for `entity`,
-    ///     nor any of its descendants.
+    ///   nor any of its descendants.
     /// - The caller must ensure that the hierarchy leading to `entity` is well-formed and must
-    ///     remain as a tree or a forest. Each entity must have at most one parent.
+    ///   remain as a tree or a forest. Each entity must have at most one parent.
     #[expect(
         unsafe_code,
         reason = "This function uses `Query::get_unchecked()`, which can result in multiple mutable references if the preconditions are not met."
@@ -245,17 +245,15 @@ mod serial {
 #[cfg(feature = "std")]
 mod parallel {
     use crate::prelude::*;
+    use alloc::{sync::Arc, vec::Vec};
     use bevy_ecs::{entity::UniqueEntityIter, prelude::*, system::lifetimeless::Read};
     use bevy_tasks::{ComputeTaskPool, TaskPool};
     use bevy_utils::Parallel;
     use core::sync::atomic::{AtomicI32, Ordering};
     // TODO: this implementation could be used in no_std if there are equivalents of these.
-    use std::{
-        sync::{
-            mpsc::{Receiver, Sender},
-            Arc, Mutex,
-        },
-        vec::Vec,
+    use std::sync::{
+        mpsc::{Receiver, Sender},
+        Mutex,
     };
 
     /// Update [`GlobalTransform`] component of entities based on entity hierarchy and [`Transform`]
@@ -877,33 +875,32 @@ mod test {
         app.world_mut()
             .spawn(Transform::IDENTITY)
             .add_children(&[child]);
-        core::mem::swap(
-            #[expect(
-                unsafe_code,
-                reason = "ChildOf is not mutable but this is for a test to produce a scenario that cannot happen"
-            )]
-            // SAFETY: ChildOf is not mutable but this is for a test to produce a scenario that
-            // cannot happen
-            unsafe {
-                &mut *app
-                    .world_mut()
-                    .entity_mut(child)
-                    .get_mut_assume_mutable::<ChildOf>()
-                    .unwrap()
-            },
-            // SAFETY: ChildOf is not mutable but this is for a test to produce a scenario that
-            // cannot happen
-            #[expect(
-                unsafe_code,
-                reason = "ChildOf is not mutable but this is for a test to produce a scenario that cannot happen"
-            )]
-            unsafe {
-                &mut *temp
-                    .entity_mut(grandchild)
-                    .get_mut_assume_mutable::<ChildOf>()
-                    .unwrap()
-            },
-        );
+
+        let mut child_entity = app.world_mut().entity_mut(child);
+
+        let mut grandchild_entity = temp.entity_mut(grandchild);
+
+        #[expect(
+            unsafe_code,
+            reason = "ChildOf is not mutable but this is for a test to produce a scenario that cannot happen"
+        )]
+        // SAFETY: ChildOf is not mutable but this is for a test to produce a scenario that
+        // cannot happen
+        let mut a = unsafe { child_entity.get_mut_assume_mutable::<ChildOf>().unwrap() };
+
+        // SAFETY: ChildOf is not mutable but this is for a test to produce a scenario that
+        // cannot happen
+        #[expect(
+            unsafe_code,
+            reason = "ChildOf is not mutable but this is for a test to produce a scenario that cannot happen"
+        )]
+        let mut b = unsafe {
+            grandchild_entity
+                .get_mut_assume_mutable::<ChildOf>()
+                .unwrap()
+        };
+
+        core::mem::swap(a.as_mut(), b.as_mut());
 
         app.update();
     }
diff --git a/crates/bevy_ui/Cargo.toml b/crates/bevy_ui/Cargo.toml
index c287ede55..2273f401d 100644
--- a/crates/bevy_ui/Cargo.toml
+++ b/crates/bevy_ui/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_ui"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "A custom ECS-driven UI framework built specifically for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_ui/src/render/ui_material_pipeline.rs b/crates/bevy_ui/src/render/ui_material_pipeline.rs
index 202f37492..8267668c0 100644
--- a/crates/bevy_ui/src/render/ui_material_pipeline.rs
+++ b/crates/bevy_ui/src/render/ui_material_pipeline.rs
@@ -597,7 +597,7 @@ impl<M: UiMaterial> RenderAsset for PreparedUiMaterial<M> {
     fn prepare_asset(
         material: Self::SourceAsset,
         _: AssetId<Self::SourceAsset>,
-        (render_device, pipeline, ref mut material_param): &mut SystemParamItem<Self::Param>,
+        (render_device, pipeline, material_param): &mut SystemParamItem<Self::Param>,
     ) -> Result<Self, PrepareAssetError<Self::SourceAsset>> {
         match material.as_bind_group(&pipeline.ui_layout, render_device, material_param) {
             Ok(prepared) => Ok(PreparedUiMaterial {
diff --git a/crates/bevy_ui/src/widget/text.rs b/crates/bevy_ui/src/widget/text.rs
index e1be21095..42c91fd83 100644
--- a/crates/bevy_ui/src/widget/text.rs
+++ b/crates/bevy_ui/src/widget/text.rs
@@ -242,9 +242,9 @@ fn create_text_measure<'a>(
 ///
 /// * Measures are regenerated on changes to either [`ComputedTextBlock`] or [`ComputedNodeTarget`].
 /// * Changes that only modify the colors of a `Text` do not require a new `Measure`. This system
-///     is only able to detect that a `Text` component has changed and will regenerate the `Measure` on
-///     color changes. This can be expensive, particularly for large blocks of text, and the [`bypass_change_detection`](bevy_ecs::change_detection::DetectChangesMut::bypass_change_detection)
-///     method should be called when only changing the `Text`'s colors.
+///   is only able to detect that a `Text` component has changed and will regenerate the `Measure` on
+///   color changes. This can be expensive, particularly for large blocks of text, and the [`bypass_change_detection`](bevy_ecs::change_detection::DetectChangesMut::bypass_change_detection)
+///   method should be called when only changing the `Text`'s colors.
 pub fn measure_text_system(
     fonts: Res<Assets<Font>>,
     mut text_query: Query<
diff --git a/crates/bevy_utils/Cargo.toml b/crates/bevy_utils/Cargo.toml
index 1b8682f20..ce50c4c45 100644
--- a/crates/bevy_utils/Cargo.toml
+++ b/crates/bevy_utils/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_utils"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "A collection of utils for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_window/Cargo.toml b/crates/bevy_window/Cargo.toml
index eb6dd3d78..2920c8836 100644
--- a/crates/bevy_window/Cargo.toml
+++ b/crates/bevy_window/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_window"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "Provides windowing functionality for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_window/src/window.rs b/crates/bevy_window/src/window.rs
index 1acf96ee4..bc4ca5f23 100644
--- a/crates/bevy_window/src/window.rs
+++ b/crates/bevy_window/src/window.rs
@@ -663,7 +663,7 @@ impl WindowResizeConstraints {
     /// Will output warnings if it isn't.
     #[must_use]
     pub fn check_constraints(&self) -> Self {
-        let WindowResizeConstraints {
+        let &WindowResizeConstraints {
             mut min_width,
             mut min_height,
             mut max_width,
@@ -708,7 +708,7 @@ pub struct CursorOptions {
     /// ## Platform-specific
     ///
     /// - **`Windows`**, **`X11`**, and **`Wayland`**: The cursor is hidden only when inside the window.
-    ///     To stop the cursor from leaving the window, change [`CursorOptions::grab_mode`] to [`CursorGrabMode::Locked`] or [`CursorGrabMode::Confined`]
+    ///   To stop the cursor from leaving the window, change [`CursorOptions::grab_mode`] to [`CursorGrabMode::Locked`] or [`CursorGrabMode::Confined`]
     /// - **`macOS`**: The cursor is hidden only when the window is focused.
     /// - **`iOS`** and **`Android`** do not have cursors
     pub visible: bool,
@@ -792,14 +792,14 @@ impl WindowPosition {
 ///
 /// There are three sizes associated with a window:
 /// - the physical size,
-///     which represents the actual height and width in physical pixels
-///     the window occupies on the monitor,
+///   which represents the actual height and width in physical pixels
+///   the window occupies on the monitor,
 /// - the logical size,
-///     which represents the size that should be used to scale elements
-///     inside the window, measured in logical pixels,
+///   which represents the size that should be used to scale elements
+///   inside the window, measured in logical pixels,
 /// - the requested size,
-///     measured in logical pixels, which is the value submitted
-///     to the API when creating the window, or requesting that it be resized.
+///   measured in logical pixels, which is the value submitted
+///   to the API when creating the window, or requesting that it be resized.
 ///
 /// ## Scale factor
 ///
diff --git a/crates/bevy_winit/Cargo.toml b/crates/bevy_winit/Cargo.toml
index 9df34c214..fa57f117f 100644
--- a/crates/bevy_winit/Cargo.toml
+++ b/crates/bevy_winit/Cargo.toml
@@ -1,7 +1,7 @@
 [package]
 name = "bevy_winit"
 version = "0.16.0-dev"
-edition = "2021"
+edition = "2024"
 description = "A winit window and input backend for Bevy Engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/crates/bevy_winit/src/winit_config.rs b/crates/bevy_winit/src/winit_config.rs
index feeeb8d3b..1b2cf8ad4 100644
--- a/crates/bevy_winit/src/winit_config.rs
+++ b/crates/bevy_winit/src/winit_config.rs
@@ -80,7 +80,7 @@ pub enum UpdateMode {
     /// - `wait` time has elapsed since the previous update
     /// - a redraw has been requested by [`RequestRedraw`](bevy_window::RequestRedraw)
     /// - new [window](`winit::event::WindowEvent`), [raw input](`winit::event::DeviceEvent`), or custom
-    ///     events have appeared
+    ///   events have appeared
     /// - a redraw has been requested with the [`EventLoopProxy`](crate::EventLoopProxy)
     Reactive {
         /// The approximate time from the start of one update to the next.
diff --git a/errors/Cargo.toml b/errors/Cargo.toml
index 8e11214e7..cfe187ebb 100644
--- a/errors/Cargo.toml
+++ b/errors/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "errors"
-edition = "2021"
+edition = "2024"
 description = "Documentation and tests for Bevy's error codes"
 publish = false
 license = "MIT OR Apache-2.0"
diff --git a/examples/2d/cpu_draw.rs b/examples/2d/cpu_draw.rs
index adf7f63b9..ba98e1051 100644
--- a/examples/2d/cpu_draw.rs
+++ b/examples/2d/cpu_draw.rs
@@ -101,7 +101,11 @@ fn draw(
 ) {
     if *i == 0 {
         // Generate a random color on first run.
-        *draw_color = Color::linear_rgb(seeded_rng.0.gen(), seeded_rng.0.gen(), seeded_rng.0.gen());
+        *draw_color = Color::linear_rgb(
+            seeded_rng.0.r#gen(),
+            seeded_rng.0.r#gen(),
+            seeded_rng.0.r#gen(),
+        );
     }
 
     // Get the image from Bevy's asset storage.
@@ -124,7 +128,11 @@ fn draw(
     // If the old color is our current color, change our drawing color.
     let tolerance = 1.0 / 255.0;
     if old_color.distance(&draw_color) <= tolerance {
-        *draw_color = Color::linear_rgb(seeded_rng.0.gen(), seeded_rng.0.gen(), seeded_rng.0.gen());
+        *draw_color = Color::linear_rgb(
+            seeded_rng.0.r#gen(),
+            seeded_rng.0.r#gen(),
+            seeded_rng.0.r#gen(),
+        );
     }
 
     // Set the new color, but keep old alpha value from image.
diff --git a/examples/3d/decal.rs b/examples/3d/decal.rs
index 2f27af3bb..7fd45cd53 100644
--- a/examples/3d/decal.rs
+++ b/examples/3d/decal.rs
@@ -64,7 +64,7 @@ fn setup(
     let mut rng = ChaCha8Rng::seed_from_u64(19878367467713);
     for i in 0..num_obs {
         for j in 0..num_obs {
-            let rotation_axis: [f32; 3] = rng.gen();
+            let rotation_axis: [f32; 3] = rng.r#gen();
             let rotation_vec: Vec3 = rotation_axis.into();
             let rotation: u32 = rng.gen_range(0..360);
             let transform = Transform::from_xyz(
diff --git a/examples/3d/fog.rs b/examples/3d/fog.rs
index 1df8c3ce4..9793ae0ad 100644
--- a/examples/3d/fog.rs
+++ b/examples/3d/fog.rs
@@ -185,11 +185,7 @@ fn update_system(
     }
 
     // Linear Fog Controls
-    if let FogFalloff::Linear {
-        ref mut start,
-        ref mut end,
-    } = &mut fog.falloff
-    {
+    if let FogFalloff::Linear { start, end } = &mut fog.falloff {
         text.push_str("\nA / S - Move Start Distance\nZ / X - Move End Distance");
 
         if keycode.pressed(KeyCode::KeyA) {
@@ -207,7 +203,7 @@ fn update_system(
     }
 
     // Exponential Fog Controls
-    if let FogFalloff::Exponential { ref mut density } = &mut fog.falloff {
+    if let FogFalloff::Exponential { density } = &mut fog.falloff {
         text.push_str("\nA / S - Change Density");
 
         if keycode.pressed(KeyCode::KeyA) {
@@ -222,7 +218,7 @@ fn update_system(
     }
 
     // ExponentialSquared Fog Controls
-    if let FogFalloff::ExponentialSquared { ref mut density } = &mut fog.falloff {
+    if let FogFalloff::ExponentialSquared { density } = &mut fog.falloff {
         text.push_str("\nA / S - Change Density");
 
         if keycode.pressed(KeyCode::KeyA) {
diff --git a/examples/3d/transparency_3d.rs b/examples/3d/transparency_3d.rs
index 35cb7c1d1..37fa25b52 100644
--- a/examples/3d/transparency_3d.rs
+++ b/examples/3d/transparency_3d.rs
@@ -100,7 +100,7 @@ fn setup(
 /// Each blend mode responds differently to this:
 /// - [`Opaque`](AlphaMode::Opaque): Ignores alpha channel altogether, these materials stay completely opaque.
 /// - [`Mask(f32)`](AlphaMode::Mask): Object appears when the alpha value goes above the mask's threshold, disappears
-///                when the alpha value goes back below the threshold.
+///   when the alpha value goes back below the threshold.
 /// - [`Blend`](AlphaMode::Blend): Object fades in and out smoothly.
 /// - [`AlphaToCoverage`](AlphaMode::AlphaToCoverage): Object fades in and out
 ///   in steps corresponding to the number of multisample antialiasing (MSAA)
diff --git a/examples/animation/animated_mesh_events.rs b/examples/animation/animated_mesh_events.rs
index 2c79aa88d..2048f573f 100644
--- a/examples/animation/animated_mesh_events.rs
+++ b/examples/animation/animated_mesh_events.rs
@@ -50,7 +50,7 @@ fn observe_on_step(
     let translation = transforms.get(trigger.target()).unwrap().translation();
     // Spawn a bunch of particles.
     for _ in 0..14 {
-        let horizontal = seeded_rng.0.gen::<Dir2>() * seeded_rng.0.gen_range(8.0..12.0);
+        let horizontal = seeded_rng.0.r#gen::<Dir2>() * seeded_rng.0.gen_range(8.0..12.0);
         let vertical = seeded_rng.0.gen_range(0.0..4.0);
         let size = seeded_rng.0.gen_range(0.2..1.0);
 
diff --git a/examples/animation/animation_graph.rs b/examples/animation/animation_graph.rs
index afe01c288..76da8a664 100644
--- a/examples/animation/animation_graph.rs
+++ b/examples/animation/animation_graph.rs
@@ -299,7 +299,7 @@ fn setup_node_rects(commands: &mut Commands) {
                 Outline::new(Val::Px(1.), Val::ZERO, Color::WHITE),
             ));
 
-            if let NodeType::Clip(ref clip) = node_type {
+            if let NodeType::Clip(clip) = node_type {
                 container.insert((
                     Interaction::None,
                     RelativeCursorPosition::default(),
diff --git a/examples/asset/multi_asset_sync.rs b/examples/asset/multi_asset_sync.rs
index 5ec34b0d4..758bb4a06 100644
--- a/examples/asset/multi_asset_sync.rs
+++ b/examples/asset/multi_asset_sync.rs
@@ -105,7 +105,7 @@ impl AssetBarrier {
     }
 
     /// Wait for all [`AssetBarrierGuard`]s to be dropped asynchronously.
-    pub fn wait_async(&self) -> impl Future<Output = ()> + 'static {
+    pub fn wait_async(&self) -> impl Future<Output = ()> + 'static + use<> {
         let shared = self.0.clone();
         async move {
             loop {
diff --git a/examples/camera/first_person_view_model.rs b/examples/camera/first_person_view_model.rs
index 78168eac5..56a24e911 100644
--- a/examples/camera/first_person_view_model.rs
+++ b/examples/camera/first_person_view_model.rs
@@ -15,9 +15,9 @@
 //! be able to change its FOV to accommodate the player's preferences for the following reasons:
 //! - *Accessibility*: How prone is the player to motion sickness? A wider FOV can help.
 //! - *Tactical preference*: Does the player want to see more of the battlefield?
-//!     Or have a more zoomed-in view for precision aiming?
+//!   Or have a more zoomed-in view for precision aiming?
 //! - *Physical considerations*: How well does the in-game FOV match the player's real-world FOV?
-//!     Are they sitting in front of a monitor or playing on a TV in the living room? How big is the screen?
+//!   Are they sitting in front of a monitor or playing on a TV in the living room? How big is the screen?
 //!
 //! ## Implementation
 //!
@@ -27,12 +27,12 @@
 //! We use different `RenderLayers` to select what to render.
 //!
 //! - The world model camera has no explicit `RenderLayers` component, so it uses the layer 0.
-//!     All static objects in the scene are also on layer 0 for the same reason.
+//!   All static objects in the scene are also on layer 0 for the same reason.
 //! - The view model camera has a `RenderLayers` component with layer 1, so it only renders objects
-//!     explicitly assigned to layer 1. The arm of the player is one such object.
-//!     The order of the view model camera is additionally bumped to 1 to ensure it renders on top of the world model.
+//!   explicitly assigned to layer 1. The arm of the player is one such object.
+//!   The order of the view model camera is additionally bumped to 1 to ensure it renders on top of the world model.
 //! - The light source in the scene must illuminate both the view model and the world model, so it is
-//!     assigned to both layers 0 and 1.
+//!   assigned to both layers 0 and 1.
 //!
 //! ## Controls
 //!
@@ -243,7 +243,7 @@ fn change_fov(
     input: Res<ButtonInput<KeyCode>>,
     mut world_model_projection: Single<&mut Projection, With<WorldModelCamera>>,
 ) {
-    let Projection::Perspective(ref mut perspective) = world_model_projection.as_mut() else {
+    let Projection::Perspective(perspective) = world_model_projection.as_mut() else {
         unreachable!(
             "The `Projection` component was explicitly built with `Projection::Perspective`"
         );
diff --git a/examples/ecs/component_hooks.rs b/examples/ecs/component_hooks.rs
index 836779c4e..ba9606fe5 100644
--- a/examples/ecs/component_hooks.rs
+++ b/examples/ecs/component_hooks.rs
@@ -8,10 +8,10 @@
 //! Here are some cases where components hooks might be necessary:
 //!
 //! - Maintaining indexes: If you need to keep custom data structures (like a spatial index) in
-//!     sync with the addition/removal of components.
+//!   sync with the addition/removal of components.
 //!
 //! - Enforcing structural rules: When you have systems that depend on specific relationships
-//!     between components (like hierarchies or parent-child links) and need to maintain correctness.
+//!   between components (like hierarchies or parent-child links) and need to maintain correctness.
 
 use bevy::{
     ecs::component::{ComponentHook, HookContext, Mutable, StorageType},
diff --git a/examples/ecs/observers.rs b/examples/ecs/observers.rs
index 6d8027f01..0f057db10 100644
--- a/examples/ecs/observers.rs
+++ b/examples/ecs/observers.rs
@@ -52,10 +52,10 @@ impl Mine {
     fn random(rand: &mut ChaCha8Rng) -> Self {
         Mine {
             pos: Vec2::new(
-                (rand.gen::<f32>() - 0.5) * 1200.0,
-                (rand.gen::<f32>() - 0.5) * 600.0,
+                (rand.r#gen::<f32>() - 0.5) * 1200.0,
+                (rand.r#gen::<f32>() - 0.5) * 600.0,
             ),
-            size: 4.0 + rand.gen::<f32>() * 16.0,
+            size: 4.0 + rand.r#gen::<f32>() * 16.0,
         }
     }
 }
diff --git a/examples/ecs/parallel_query.rs b/examples/ecs/parallel_query.rs
index 18bc3fc18..24a862b17 100644
--- a/examples/ecs/parallel_query.rs
+++ b/examples/ecs/parallel_query.rs
@@ -19,7 +19,7 @@ fn spawn_system(mut commands: Commands, asset_server: Res<AssetServer>) {
             Sprite::from_image(texture.clone()),
             Transform::from_scale(Vec3::splat(0.1))
                 .with_translation(Vec2::splat(0.0).extend(z as f32)),
-            Velocity(20.0 * Vec2::new(rng.gen::<f32>() - 0.5, rng.gen::<f32>() - 0.5)),
+            Velocity(20.0 * Vec2::new(rng.r#gen::<f32>() - 0.5, rng.r#gen::<f32>() - 0.5)),
         ));
     }
 }
diff --git a/examples/games/contributors.rs b/examples/games/contributors.rs
index 59f03eba6..30a9ce8a9 100644
--- a/examples/games/contributors.rs
+++ b/examples/games/contributors.rs
@@ -98,14 +98,14 @@ fn setup_contributor_selection(
         let transform = Transform::from_xyz(
             rng.gen_range(-400.0..400.0),
             rng.gen_range(0.0..400.0),
-            rng.gen(),
+            rng.r#gen(),
         );
         let dir = rng.gen_range(-1.0..1.0);
         let velocity = Vec3::new(dir * 500.0, 0.0, 0.0);
         let hue = name_to_hue(&name);
 
         // Some sprites should be flipped for variety
-        let flipped = rng.gen();
+        let flipped = rng.r#gen();
 
         let entity = commands
             .spawn((
diff --git a/examples/gizmos/axes.rs b/examples/gizmos/axes.rs
index 1ecfa340b..d90d498ec 100644
--- a/examples/gizmos/axes.rs
+++ b/examples/gizmos/axes.rs
@@ -147,22 +147,22 @@ fn random_transform(rng: &mut impl Rng) -> Transform {
 }
 
 fn random_translation(rng: &mut impl Rng) -> Vec3 {
-    let x = rng.gen::<f32>() * (TRANSLATION_BOUND_UPPER_X - TRANSLATION_BOUND_LOWER_X)
+    let x = rng.r#gen::<f32>() * (TRANSLATION_BOUND_UPPER_X - TRANSLATION_BOUND_LOWER_X)
         + TRANSLATION_BOUND_LOWER_X;
-    let y = rng.gen::<f32>() * (TRANSLATION_BOUND_UPPER_Y - TRANSLATION_BOUND_LOWER_Y)
+    let y = rng.r#gen::<f32>() * (TRANSLATION_BOUND_UPPER_Y - TRANSLATION_BOUND_LOWER_Y)
         + TRANSLATION_BOUND_LOWER_Y;
-    let z = rng.gen::<f32>() * (TRANSLATION_BOUND_UPPER_Z - TRANSLATION_BOUND_LOWER_Z)
+    let z = rng.r#gen::<f32>() * (TRANSLATION_BOUND_UPPER_Z - TRANSLATION_BOUND_LOWER_Z)
         + TRANSLATION_BOUND_LOWER_Z;
 
     Vec3::new(x, y, z)
 }
 
 fn random_scale(rng: &mut impl Rng) -> Vec3 {
-    let x_factor_log = rng.gen::<f32>() * (SCALING_BOUND_UPPER_LOG - SCALING_BOUND_LOWER_LOG)
+    let x_factor_log = rng.r#gen::<f32>() * (SCALING_BOUND_UPPER_LOG - SCALING_BOUND_LOWER_LOG)
         + SCALING_BOUND_LOWER_LOG;
-    let y_factor_log = rng.gen::<f32>() * (SCALING_BOUND_UPPER_LOG - SCALING_BOUND_LOWER_LOG)
+    let y_factor_log = rng.r#gen::<f32>() * (SCALING_BOUND_UPPER_LOG - SCALING_BOUND_LOWER_LOG)
         + SCALING_BOUND_LOWER_LOG;
-    let z_factor_log = rng.gen::<f32>() * (SCALING_BOUND_UPPER_LOG - SCALING_BOUND_LOWER_LOG)
+    let z_factor_log = rng.r#gen::<f32>() * (SCALING_BOUND_UPPER_LOG - SCALING_BOUND_LOWER_LOG)
         + SCALING_BOUND_LOWER_LOG;
 
     Vec3::new(
@@ -186,14 +186,14 @@ fn elerp(v1: Vec3, v2: Vec3, t: f32) -> Vec3 {
 
 fn random_rotation(rng: &mut impl Rng) -> Quat {
     let dir = random_direction(rng);
-    let angle = rng.gen::<f32>() * 2. * PI;
+    let angle = rng.r#gen::<f32>() * 2. * PI;
 
     Quat::from_axis_angle(dir, angle)
 }
 
 fn random_direction(rng: &mut impl Rng) -> Vec3 {
-    let height = rng.gen::<f32>() * 2. - 1.;
-    let theta = rng.gen::<f32>() * 2. * PI;
+    let height = rng.r#gen::<f32>() * 2. - 1.;
+    let theta = rng.r#gen::<f32>() * 2. * PI;
 
     build_direction(height, theta)
 }
diff --git a/examples/mobile/Cargo.toml b/examples/mobile/Cargo.toml
index f23ff7e7e..d54c7deee 100644
--- a/examples/mobile/Cargo.toml
+++ b/examples/mobile/Cargo.toml
@@ -2,7 +2,7 @@
 name = "bevy_mobile_example"
 # Version is required by `cargo-apk`, though this value will never change.
 version = "0.0.0"
-edition = "2021"
+edition = "2024"
 description = "Example for building an iOS or Android app with Bevy"
 publish = false
 license = "MIT OR Apache-2.0"
diff --git a/examples/mobile/android_basic/Cargo.toml b/examples/mobile/android_basic/Cargo.toml
index 85e996a1b..d1cc7fe47 100644
--- a/examples/mobile/android_basic/Cargo.toml
+++ b/examples/mobile/android_basic/Cargo.toml
@@ -2,7 +2,7 @@
 name = "bevy_mobile_example"
 # Version is required by `cargo-apk`, though this value will never change.
 version = "0.0.0"
-edition = "2021"
+edition = "2024"
 description = "Example for building an iOS or Android app with Bevy"
 publish = false
 license = "MIT OR Apache-2.0"
diff --git a/examples/movement/physics_in_fixed_timestep.rs b/examples/movement/physics_in_fixed_timestep.rs
index b477c3c86..2e105f9a0 100644
--- a/examples/movement/physics_in_fixed_timestep.rs
+++ b/examples/movement/physics_in_fixed_timestep.rs
@@ -59,16 +59,16 @@
 //! - The player's previous position in the physics simulation is stored in a `PreviousPhysicalTranslation` component.
 //! - The player's visual representation is stored in Bevy's regular `Transform` component.
 //! - Every frame, we go through the following steps:
-//!    - Accumulate the player's input and set the current speed in the `handle_input` system.
-//!        This is run in the `RunFixedMainLoop` schedule, ordered in `RunFixedMainLoopSystem::BeforeFixedMainLoop`,
-//!        which runs before the fixed timestep loop. This is run every frame.
-//!    - Advance the physics simulation by one fixed timestep in the `advance_physics` system.
-//!        Accumulated input is consumed here.
-//!        This is run in the `FixedUpdate` schedule, which runs zero or multiple times per frame.
-//!    - Update the player's visual representation in the `interpolate_rendered_transform` system.
-//!        This interpolates between the player's previous and current position in the physics simulation.
-//!        It is run in the `RunFixedMainLoop` schedule, ordered in `RunFixedMainLoopSystem::AfterFixedMainLoop`,
-//!        which runs after the fixed timestep loop. This is run every frame.
+//!   - Accumulate the player's input and set the current speed in the `handle_input` system.
+//!     This is run in the `RunFixedMainLoop` schedule, ordered in `RunFixedMainLoopSystem::BeforeFixedMainLoop`,
+//!     which runs before the fixed timestep loop. This is run every frame.
+//!   - Advance the physics simulation by one fixed timestep in the `advance_physics` system.
+//!     Accumulated input is consumed here.
+//!     This is run in the `FixedUpdate` schedule, which runs zero or multiple times per frame.
+//!   - Update the player's visual representation in the `interpolate_rendered_transform` system.
+//!     This interpolates between the player's previous and current position in the physics simulation.
+//!     It is run in the `RunFixedMainLoop` schedule, ordered in `RunFixedMainLoopSystem::AfterFixedMainLoop`,
+//!     which runs after the fixed timestep loop. This is run every frame.
 //!
 //!
 //! ## Controls
diff --git a/examples/stress_tests/bevymark.rs b/examples/stress_tests/bevymark.rs
index ae1d5ac5b..1ee719d93 100644
--- a/examples/stress_tests/bevymark.rs
+++ b/examples/stress_tests/bevymark.rs
@@ -345,7 +345,7 @@ fn mouse_handler(
     let rng = rng.as_mut().unwrap();
 
     if mouse_button_input.just_released(MouseButton::Left) {
-        counter.color = Color::linear_rgb(rng.gen(), rng.gen(), rng.gen());
+        counter.color = Color::linear_rgb(rng.r#gen(), rng.r#gen(), rng.r#gen());
     }
 
     if mouse_button_input.pressed(MouseButton::Left) {
@@ -371,7 +371,7 @@ fn bird_velocity_transform(
     waves: Option<usize>,
     dt: f32,
 ) -> (Transform, Vec3) {
-    let mut velocity = Vec3::new(MAX_VELOCITY * (velocity_rng.gen::<f32>() - 0.5), 0., 0.);
+    let mut velocity = Vec3::new(MAX_VELOCITY * (velocity_rng.r#gen::<f32>() - 0.5), 0., 0.);
 
     if let Some(waves) = waves {
         // Step the movement and handle collisions as if the wave had been spawned at fixed time intervals
@@ -414,7 +414,7 @@ fn spawn_birds(
                     let bird_z = if args.ordered_z {
                         (current_count + count) as f32 * 0.00001
                     } else {
-                        bird_resources.transform_rng.gen::<f32>()
+                        bird_resources.transform_rng.r#gen::<f32>()
                     };
 
                     let (transform, velocity) = bird_velocity_transform(
@@ -427,9 +427,9 @@ fn spawn_birds(
 
                     let color = if args.vary_per_instance {
                         Color::linear_rgb(
-                            bird_resources.color_rng.gen(),
-                            bird_resources.color_rng.gen(),
-                            bird_resources.color_rng.gen(),
+                            bird_resources.color_rng.r#gen(),
+                            bird_resources.color_rng.r#gen(),
+                            bird_resources.color_rng.r#gen(),
                         )
                     } else {
                         color
@@ -457,7 +457,7 @@ fn spawn_birds(
                     let bird_z = if args.ordered_z {
                         (current_count + count) as f32 * 0.00001
                     } else {
-                        bird_resources.transform_rng.gen::<f32>()
+                        bird_resources.transform_rng.r#gen::<f32>()
                     };
 
                     let (transform, velocity) = bird_velocity_transform(
@@ -492,9 +492,9 @@ fn spawn_birds(
 
     counter.count += spawn_count;
     counter.color = Color::linear_rgb(
-        bird_resources.color_rng.gen(),
-        bird_resources.color_rng.gen(),
-        bird_resources.color_rng.gen(),
+        bird_resources.color_rng.r#gen(),
+        bird_resources.color_rng.r#gen(),
+        bird_resources.color_rng.r#gen(),
     );
 }
 
@@ -575,7 +575,7 @@ fn init_textures(textures: &mut Vec<Handle<Image>>, args: &Args, images: &mut As
     // This isn't strictly required in practical use unless you need your app to be deterministic.
     let mut color_rng = ChaCha8Rng::seed_from_u64(42);
     while textures.len() < args.material_texture_count {
-        let pixel = [color_rng.gen(), color_rng.gen(), color_rng.gen(), 255];
+        let pixel = [color_rng.r#gen(), color_rng.r#gen(), color_rng.r#gen(), 255];
         textures.push(images.add(Image::new_fill(
             Extent3d {
                 width: BIRD_TEXTURE_SIZE as u32,
@@ -622,7 +622,7 @@ fn init_materials(
     materials.extend(
         std::iter::repeat_with(|| {
             assets.add(ColorMaterial {
-                color: Color::srgb_u8(color_rng.gen(), color_rng.gen(), color_rng.gen()),
+                color: Color::srgb_u8(color_rng.r#gen(), color_rng.r#gen(), color_rng.r#gen()),
                 texture: textures.choose(&mut texture_rng).cloned(),
                 alpha_mode,
             })
diff --git a/examples/stress_tests/many_animated_sprites.rs b/examples/stress_tests/many_animated_sprites.rs
index 326673587..e34a03195 100644
--- a/examples/stress_tests/many_animated_sprites.rs
+++ b/examples/stress_tests/many_animated_sprites.rs
@@ -75,11 +75,11 @@ fn setup(
     for y in -half_y..half_y {
         for x in -half_x..half_x {
             let position = Vec2::new(x as f32, y as f32);
-            let translation = (position * tile_size).extend(rng.gen::<f32>());
-            let rotation = Quat::from_rotation_z(rng.gen::<f32>());
-            let scale = Vec3::splat(rng.gen::<f32>() * 2.0);
+            let translation = (position * tile_size).extend(rng.r#gen::<f32>());
+            let rotation = Quat::from_rotation_z(rng.r#gen::<f32>());
+            let scale = Vec3::splat(rng.r#gen::<f32>() * 2.0);
             let mut timer = Timer::from_seconds(0.1, TimerMode::Repeating);
-            timer.set_elapsed(Duration::from_secs_f32(rng.gen::<f32>()));
+            timer.set_elapsed(Duration::from_secs_f32(rng.r#gen::<f32>()));
 
             commands.spawn((
                 Sprite {
diff --git a/examples/stress_tests/many_cubes.rs b/examples/stress_tests/many_cubes.rs
index 6cf7f4084..1d8a50313 100644
--- a/examples/stress_tests/many_cubes.rs
+++ b/examples/stress_tests/many_cubes.rs
@@ -262,7 +262,7 @@ fn init_textures(args: &Args, images: &mut Assets<Image>) -> Vec<Handle<Image>>
     // This isn't strictly required in practical use unless you need your app to be deterministic.
     let mut color_rng = ChaCha8Rng::seed_from_u64(42);
     let color_bytes: Vec<u8> = (0..(args.material_texture_count * 4))
-        .map(|i| if (i % 4) == 3 { 255 } else { color_rng.gen() })
+        .map(|i| if (i % 4) == 3 { 255 } else { color_rng.r#gen() })
         .collect();
     color_bytes
         .chunks(4)
@@ -311,7 +311,7 @@ fn init_materials(
     materials.extend(
         std::iter::repeat_with(|| {
             assets.add(StandardMaterial {
-                base_color: Color::srgb_u8(color_rng.gen(), color_rng.gen(), color_rng.gen()),
+                base_color: Color::srgb_u8(color_rng.r#gen(), color_rng.r#gen(), color_rng.r#gen()),
                 base_color_texture: textures.choose(&mut texture_rng).cloned(),
                 ..default()
             })
diff --git a/examples/stress_tests/many_sprites.rs b/examples/stress_tests/many_sprites.rs
index 0931822e9..5bf65efb2 100644
--- a/examples/stress_tests/many_sprites.rs
+++ b/examples/stress_tests/many_sprites.rs
@@ -77,9 +77,9 @@ fn setup(mut commands: Commands, assets: Res<AssetServer>, color_tint: Res<Color
     for y in -half_y..half_y {
         for x in -half_x..half_x {
             let position = Vec2::new(x as f32, y as f32);
-            let translation = (position * tile_size).extend(rng.gen::<f32>());
-            let rotation = Quat::from_rotation_z(rng.gen::<f32>());
-            let scale = Vec3::splat(rng.gen::<f32>() * 2.0);
+            let translation = (position * tile_size).extend(rng.r#gen::<f32>());
+            let rotation = Quat::from_rotation_z(rng.r#gen::<f32>());
+            let scale = Vec3::splat(rng.r#gen::<f32>() * 2.0);
 
             sprites.push((
                 Sprite {
diff --git a/examples/stress_tests/many_text2d.rs b/examples/stress_tests/many_text2d.rs
index 22a7d8251..65c133a81 100644
--- a/examples/stress_tests/many_text2d.rs
+++ b/examples/stress_tests/many_text2d.rs
@@ -122,9 +122,9 @@ fn setup(mut commands: Commands, font: Res<FontHandle>, args: Res<Args>) {
     for y in -half_y..half_y {
         for x in -half_x..half_x {
             let position = Vec2::new(x as f32, y as f32);
-            let translation = (position * tile_size).extend(rng.gen::<f32>());
-            let rotation = Quat::from_rotation_z(rng.gen::<f32>());
-            let scale = Vec3::splat(rng.gen::<f32>() * 2.0);
+            let translation = (position * tile_size).extend(rng.r#gen::<f32>());
+            let rotation = Quat::from_rotation_z(rng.r#gen::<f32>());
+            let scale = Vec3::splat(rng.r#gen::<f32>() * 2.0);
             let color = Hsla::hsl(rng.gen_range(0.0..360.0), 0.8, 0.8);
 
             text2ds.push((
diff --git a/examples/stress_tests/transform_hierarchy.rs b/examples/stress_tests/transform_hierarchy.rs
index 67448051e..49ff27b4e 100644
--- a/examples/stress_tests/transform_hierarchy.rs
+++ b/examples/stress_tests/transform_hierarchy.rs
@@ -298,8 +298,8 @@ fn setup(mut commands: Commands, cfg: Res<Cfg>) {
                     &mut commands,
                     &cfg.update_filter,
                     Transform::from_xyz(
-                        rng.gen::<f32>() * 500.0 - 250.0,
-                        rng.gen::<f32>() * 500.0 - 250.0,
+                        rng.r#gen::<f32>() * 500.0 - 250.0,
+                        rng.r#gen::<f32>() * 500.0 - 250.0,
                         0.0,
                     ),
                 ));
@@ -315,8 +315,8 @@ fn setup(mut commands: Commands, cfg: Res<Cfg>) {
                         ..cfg.update_filter
                     },
                     Transform::from_xyz(
-                        rng.gen::<f32>() * 500.0 - 250.0,
-                        rng.gen::<f32>() * 500.0 - 250.0,
+                        rng.r#gen::<f32>() * 500.0 - 250.0,
+                        rng.r#gen::<f32>() * 500.0 - 250.0,
                         0.0,
                     ),
                 ));
@@ -405,7 +405,7 @@ fn spawn_tree(
             let mut cmd = commands.spawn_empty();
 
             // check whether or not to update this node
-            let update = (rng.gen::<f32>() <= update_filter.probability)
+            let update = (rng.r#gen::<f32>() <= update_filter.probability)
                 && (depth >= update_filter.min_depth && depth <= update_filter.max_depth);
 
             if update {
@@ -447,7 +447,7 @@ fn gen_tree(depth: u32, branch_width: u32) -> Vec<usize> {
     // the tree is built using this pattern:
     // 0, 0, 0, ... 1, 1, 1, ... 2, 2, 2, ... (count - 1)
     (0..count)
-        .flat_map(|i| std::iter::repeat(i).take(branch_width.try_into().unwrap()))
+        .flat_map(|i| std::iter::repeat_n(i, branch_width.try_into().unwrap()))
         .collect()
 }
 
diff --git a/examples/transforms/align.rs b/examples/transforms/align.rs
index da3e52eaa..7e9fdd377 100644
--- a/examples/transforms/align.rs
+++ b/examples/transforms/align.rs
@@ -75,8 +75,8 @@ fn setup(
     ));
 
     // Initialize random axes
-    let first = seeded_rng.gen();
-    let second = seeded_rng.gen();
+    let first = seeded_rng.r#gen();
+    let second = seeded_rng.r#gen();
     commands.spawn(RandomAxes(first, second));
 
     // Finally, our ship that is going to rotate
@@ -165,8 +165,8 @@ fn handle_keypress(
 ) {
     if keyboard.just_pressed(KeyCode::KeyR) {
         // Randomize the target axes
-        let first = seeded_rng.0.gen();
-        let second = seeded_rng.0.gen();
+        let first = seeded_rng.0.r#gen();
+        let second = seeded_rng.0.r#gen();
         **random_axes = RandomAxes(first, second);
 
         // Stop the ship and set it up to transform from its present orientation to the new one
diff --git a/examples/ui/button.rs b/examples/ui/button.rs
index 5f6c61573..33210b4df 100644
--- a/examples/ui/button.rs
+++ b/examples/ui/button.rs
@@ -57,7 +57,7 @@ fn setup(mut commands: Commands, assets: Res<AssetServer>) {
     commands.spawn(button(&assets));
 }
 
-fn button(asset_server: &AssetServer) -> impl Bundle {
+fn button(asset_server: &AssetServer) -> impl Bundle + use<> {
     (
         Node {
             width: Val::Percent(100.0),
diff --git a/examples/ui/font_atlas_debug.rs b/examples/ui/font_atlas_debug.rs
index 32059e7e2..06aa4b5ba 100644
--- a/examples/ui/font_atlas_debug.rs
+++ b/examples/ui/font_atlas_debug.rs
@@ -74,7 +74,7 @@ fn text_update_system(
     }
 
     for mut text in &mut query {
-        let c = seeded_rng.gen::<u8>() as char;
+        let c = seeded_rng.r#gen::<u8>() as char;
         let string = &mut **text;
         if !string.contains(c) {
             string.push(c);
diff --git a/rustfmt.toml b/rustfmt.toml
index 467c4533c..8769775ec 100644
--- a/rustfmt.toml
+++ b/rustfmt.toml
@@ -1,5 +1,6 @@
 use_field_init_shorthand = true
 newline_style = "Unix"
+style_edition = "2021"
 
 # The following lines may be uncommented on nightly Rust.
 # Once these features have stabilized, they should be added to the always-enabled options above.
diff --git a/tests-integration/remapped-test/Cargo.toml b/tests-integration/remapped-test/Cargo.toml
index 808692ada..9a8feaa64 100644
--- a/tests-integration/remapped-test/Cargo.toml
+++ b/tests-integration/remapped-test/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "remapped-test"
-edition = "2021"
+edition = "2024"
 
 [dependencies]
 bevi = { path = "../../", package = "bevy" }
diff --git a/tests-integration/simple-ecs-test/Cargo.toml b/tests-integration/simple-ecs-test/Cargo.toml
index b61c40eb6..d7e3abf37 100644
--- a/tests-integration/simple-ecs-test/Cargo.toml
+++ b/tests-integration/simple-ecs-test/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "simple-ecs-test"
-edition = "2021"
+edition = "2024"
 
 # We depend on bevy in both normal and dev dependencies to verify that the proc macros still work.
 
diff --git a/tools/build-easefunction-graphs/Cargo.toml b/tools/build-easefunction-graphs/Cargo.toml
index 3fac58b26..697ea0df1 100644
--- a/tools/build-easefunction-graphs/Cargo.toml
+++ b/tools/build-easefunction-graphs/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "build-easefunction-graphs"
-edition = "2021"
+edition = "2024"
 description = "Tool that generates a svg for each EaseFunction to be included in the docs"
 publish = false
 license = "MIT OR Apache-2.0"
diff --git a/tools/build-templated-pages/Cargo.toml b/tools/build-templated-pages/Cargo.toml
index d19e553dd..70e5d827a 100644
--- a/tools/build-templated-pages/Cargo.toml
+++ b/tools/build-templated-pages/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "build-templated-pages"
-edition = "2021"
+edition = "2024"
 description = "Tool that checks and fixes undocumented features and examples"
 publish = false
 license = "MIT OR Apache-2.0"
diff --git a/tools/build-wasm-example/Cargo.toml b/tools/build-wasm-example/Cargo.toml
index 2ed005c0a..561297f29 100644
--- a/tools/build-wasm-example/Cargo.toml
+++ b/tools/build-wasm-example/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "build-wasm-example"
-edition = "2021"
+edition = "2024"
 description = "Tool for building example for Wasm"
 publish = false
 license = "MIT OR Apache-2.0"
diff --git a/tools/ci/Cargo.toml b/tools/ci/Cargo.toml
index baf019789..65d6b7b1b 100644
--- a/tools/ci/Cargo.toml
+++ b/tools/ci/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "ci"
-edition = "2021"
+edition = "2024"
 description = "Tool that enables running CI checks locally."
 publish = false
 license = "MIT OR Apache-2.0"
diff --git a/tools/compile_fail_utils/Cargo.toml b/tools/compile_fail_utils/Cargo.toml
index 96c56b4da..7fa33d796 100644
--- a/tools/compile_fail_utils/Cargo.toml
+++ b/tools/compile_fail_utils/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "compile_fail_utils"
-edition = "2021"
+edition = "2024"
 description = "Utils for compile tests used in the engine"
 homepage = "https://bevyengine.org"
 repository = "https://github.com/bevyengine/bevy"
diff --git a/tools/example-showcase/Cargo.toml b/tools/example-showcase/Cargo.toml
index c24b90b57..f97dab44a 100644
--- a/tools/example-showcase/Cargo.toml
+++ b/tools/example-showcase/Cargo.toml
@@ -1,6 +1,6 @@
 [package]
 name = "example-showcase"
-edition = "2021"
+edition = "2024"
 description = "Tool for running examples or generating a showcase page for the website."
 publish = false
 license = "MIT OR Apache-2.0"
