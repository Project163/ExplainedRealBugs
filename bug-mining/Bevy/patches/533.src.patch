diff --git a/benches/benches/bevy_ecs/benches.rs b/benches/benches/bevy_ecs/benches.rs
index af5a38c96..58300bda9 100644
--- a/benches/benches/bevy_ecs/benches.rs
+++ b/benches/benches/bevy_ecs/benches.rs
@@ -1,3 +1,5 @@
+#![expect(dead_code, reason = "Many fields are unused/unread as they are just for benchmarking purposes.")]
+
 use criterion::criterion_main;
 
 mod components;
diff --git a/benches/benches/bevy_ecs/components/add_remove.rs b/benches/benches/bevy_ecs/components/add_remove.rs
index a41f8ed95..b381ccb43 100644
--- a/benches/benches/bevy_ecs/components/add_remove.rs
+++ b/benches/benches/bevy_ecs/components/add_remove.rs
@@ -1,6 +1,6 @@
-use bevy::prelude::*;
+use bevy_ecs::prelude::*;
 
-#[derive(Component)]
+#[derive(Component, Clone)]
 struct A(f32);
 #[derive(Component)]
 struct B(f32);
@@ -12,19 +12,18 @@ impl Benchmark {
         let mut world = World::default();
 
         let entities = world
-            .spawn_batch((0..10000).map(|_| A(0.0)))
-            .collect::<Vec<_>>();
-
+            .spawn_batch(core::iter::repeat(A(0.)).take(10000))
+            .collect();
         Self(world, entities)
     }
 
     pub fn run(&mut self) {
         for entity in &self.1 {
-            self.0.insert_one(*entity, B(0.0)).unwrap();
+            self.0.entity_mut(*entity).insert(B(0.));
         }
 
         for entity in &self.1 {
-            self.0.remove_one::<B>(*entity).unwrap();
+            self.0.entity_mut(*entity).remove::<B>();
         }
     }
 }
diff --git a/benches/benches/bevy_ecs/components/mod.rs b/benches/benches/bevy_ecs/components/mod.rs
index 592f40fba..f696d3387 100644
--- a/benches/benches/bevy_ecs/components/mod.rs
+++ b/benches/benches/bevy_ecs/components/mod.rs
@@ -5,6 +5,7 @@ mod add_remove_big_table;
 mod add_remove_sparse_set;
 mod add_remove_table;
 mod add_remove_very_big_table;
+mod add_remove;
 mod archetype_updates;
 mod insert_simple;
 mod insert_simple_unbatched;
