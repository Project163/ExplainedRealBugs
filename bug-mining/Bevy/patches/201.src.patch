diff --git a/crates/bevy_time/Cargo.toml b/crates/bevy_time/Cargo.toml
index a2ea432d8..9fcfaf93d 100644
--- a/crates/bevy_time/Cargo.toml
+++ b/crates/bevy_time/Cargo.toml
@@ -9,7 +9,7 @@ license = "MIT OR Apache-2.0"
 keywords = ["bevy"]
 
 [features]
-default = []
+default = ["bevy_reflect"]
 serialize = ["serde"]
 
 [dependencies]
@@ -20,7 +20,7 @@ bevy_ecs = { path = "../bevy_ecs", version = "0.14.0-dev", features = [
 ] }
 bevy_reflect = { path = "../bevy_reflect", version = "0.14.0-dev", features = [
   "bevy",
-] }
+], optional = true }
 bevy_utils = { path = "../bevy_utils", version = "0.14.0-dev" }
 
 # other
diff --git a/crates/bevy_time/src/fixed.rs b/crates/bevy_time/src/fixed.rs
index 9e5314d4d..a49763905 100644
--- a/crates/bevy_time/src/fixed.rs
+++ b/crates/bevy_time/src/fixed.rs
@@ -1,5 +1,6 @@
 use bevy_app::FixedMain;
 use bevy_ecs::world::World;
+#[cfg(feature = "bevy_reflect")]
 use bevy_reflect::Reflect;
 use bevy_utils::Duration;
 
@@ -63,7 +64,8 @@ use crate::{time::Time, virt::Virtual};
 /// [`FixedUpdate`](bevy_app::FixedUpdate), even if it is still during the same
 /// frame. Any [`overstep()`](Time::overstep) present in the accumulator will be
 /// processed according to the new [`timestep()`](Time::timestep) value.
-#[derive(Debug, Copy, Clone, Reflect)]
+#[derive(Debug, Copy, Clone)]
+#[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 pub struct Fixed {
     timestep: Duration,
     overstep: Duration,
diff --git a/crates/bevy_time/src/lib.rs b/crates/bevy_time/src/lib.rs
index 912a600bb..9778e1517 100644
--- a/crates/bevy_time/src/lib.rs
+++ b/crates/bevy_time/src/lib.rs
@@ -51,13 +51,18 @@ impl Plugin for TimePlugin {
             .init_resource::<Time<Real>>()
             .init_resource::<Time<Virtual>>()
             .init_resource::<Time<Fixed>>()
-            .init_resource::<TimeUpdateStrategy>()
-            .register_type::<Time>()
-            .register_type::<Time<Real>>()
-            .register_type::<Time<Virtual>>()
-            .register_type::<Time<Fixed>>()
-            .register_type::<Timer>()
-            .add_systems(First, time_system.in_set(TimeSystem))
+            .init_resource::<TimeUpdateStrategy>();
+
+        #[cfg(feature = "bevy_reflect")]
+        {
+            app.register_type::<Time>()
+                .register_type::<Time<Real>>()
+                .register_type::<Time<Virtual>>()
+                .register_type::<Time<Fixed>>()
+                .register_type::<Timer>();
+        }
+
+        app.add_systems(First, time_system.in_set(TimeSystem))
             .add_systems(RunFixedMainLoop, run_fixed_main_schedule);
 
         // ensure the events are not dropped until `FixedMain` systems can observe them
diff --git a/crates/bevy_time/src/real.rs b/crates/bevy_time/src/real.rs
index 90b7b8042..bd397435b 100644
--- a/crates/bevy_time/src/real.rs
+++ b/crates/bevy_time/src/real.rs
@@ -1,3 +1,4 @@
+#[cfg(feature = "bevy_reflect")]
 use bevy_reflect::Reflect;
 use bevy_utils::{Duration, Instant};
 
@@ -28,7 +29,8 @@ use crate::time::Time;
 /// [`Instant`]s for [`startup()`](Time::startup),
 /// [`first_update()`](Time::first_update) and
 /// [`last_update()`](Time::last_update) are recorded and accessible.
-#[derive(Debug, Copy, Clone, Reflect)]
+#[derive(Debug, Copy, Clone)]
+#[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 pub struct Real {
     startup: Instant,
     first_update: Option<Instant>,
diff --git a/crates/bevy_time/src/stopwatch.rs b/crates/bevy_time/src/stopwatch.rs
index b0362c6e9..632d4c176 100644
--- a/crates/bevy_time/src/stopwatch.rs
+++ b/crates/bevy_time/src/stopwatch.rs
@@ -1,3 +1,4 @@
+#[cfg(feature = "bevy_reflect")]
 use bevy_reflect::{prelude::*, Reflect};
 use bevy_utils::Duration;
 
@@ -22,9 +23,9 @@ use bevy_utils::Duration;
 /// assert!(stopwatch.paused());
 /// assert_eq!(stopwatch.elapsed_secs(), 0.0);
 /// ```
-#[derive(Clone, Debug, Default, PartialEq, Eq, Reflect)]
+#[derive(Clone, Debug, Default, PartialEq, Eq)]
 #[cfg_attr(feature = "serialize", derive(serde::Deserialize, serde::Serialize))]
-#[reflect(Default)]
+#[cfg_attr(feature = "bevy_reflect", derive(Reflect), reflect(Default))]
 pub struct Stopwatch {
     elapsed: Duration,
     paused: bool,
diff --git a/crates/bevy_time/src/time.rs b/crates/bevy_time/src/time.rs
index f2bc66863..36feb7fe7 100644
--- a/crates/bevy_time/src/time.rs
+++ b/crates/bevy_time/src/time.rs
@@ -1,4 +1,7 @@
-use bevy_ecs::{reflect::ReflectResource, system::Resource};
+#[cfg(feature = "bevy_reflect")]
+use bevy_ecs::reflect::ReflectResource;
+use bevy_ecs::system::Resource;
+#[cfg(feature = "bevy_reflect")]
 use bevy_reflect::{std_traits::ReflectDefault, Reflect};
 use bevy_utils::Duration;
 
@@ -183,8 +186,8 @@ use bevy_utils::Duration;
 ///     }
 /// }
 /// ```
-#[derive(Resource, Debug, Copy, Clone, Reflect)]
-#[reflect(Resource, Default)]
+#[derive(Resource, Debug, Copy, Clone)]
+#[cfg_attr(feature = "bevy_reflect", derive(Reflect), reflect(Resource, Default))]
 pub struct Time<T: Default = ()> {
     context: T,
     wrap_period: Duration,
diff --git a/crates/bevy_time/src/timer.rs b/crates/bevy_time/src/timer.rs
index 838384357..7995f986a 100644
--- a/crates/bevy_time/src/timer.rs
+++ b/crates/bevy_time/src/timer.rs
@@ -1,4 +1,5 @@
 use crate::Stopwatch;
+#[cfg(feature = "bevy_reflect")]
 use bevy_reflect::prelude::*;
 use bevy_utils::Duration;
 
@@ -9,9 +10,9 @@ use bevy_utils::Duration;
 /// exceeded, and can still be reset at any given point.
 ///
 /// Paused timers will not have elapsed time increased.
-#[derive(Clone, Debug, Default, PartialEq, Eq, Reflect)]
+#[derive(Clone, Debug, Default, PartialEq, Eq)]
 #[cfg_attr(feature = "serialize", derive(serde::Deserialize, serde::Serialize))]
-#[reflect(Default)]
+#[cfg_attr(feature = "bevy_reflect", derive(Reflect), reflect(Default))]
 pub struct Timer {
     stopwatch: Stopwatch,
     duration: Duration,
@@ -425,9 +426,9 @@ impl Timer {
 }
 
 /// Specifies [`Timer`] behavior.
-#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash, Default, Reflect)]
+#[derive(Debug, Clone, Copy, Eq, PartialEq, Hash, Default)]
 #[cfg_attr(feature = "serialize", derive(serde::Deserialize, serde::Serialize))]
-#[reflect(Default)]
+#[cfg_attr(feature = "bevy_reflect", derive(Reflect), reflect(Default))]
 pub enum TimerMode {
     /// Run once and stop.
     #[default]
diff --git a/crates/bevy_time/src/virt.rs b/crates/bevy_time/src/virt.rs
index 0f8676c9f..58eade333 100644
--- a/crates/bevy_time/src/virt.rs
+++ b/crates/bevy_time/src/virt.rs
@@ -1,3 +1,4 @@
+#[cfg(feature = "bevy_reflect")]
 use bevy_reflect::Reflect;
 use bevy_utils::{tracing::debug, Duration};
 
@@ -67,7 +68,8 @@ use crate::{real::Real, time::Time};
 /// time. You should also consider how stable your FPS is, as the limit will
 /// also dictate how big of an FPS drop you can accept without losing time and
 /// falling behind real time.
-#[derive(Debug, Copy, Clone, Reflect)]
+#[derive(Debug, Copy, Clone)]
+#[cfg_attr(feature = "bevy_reflect", derive(Reflect))]
 pub struct Virtual {
     max_delta: Duration,
     paused: bool,
