diff --git a/crates/bevy_asset/src/handle.rs b/crates/bevy_asset/src/handle.rs
index d14c32597..40bdac7e3 100644
--- a/crates/bevy_asset/src/handle.rs
+++ b/crates/bevy_asset/src/handle.rs
@@ -249,13 +249,6 @@ impl<A: Asset> PartialEq for Handle<A> {
 
 impl<A: Asset> Eq for Handle<A> {}
 
-impl<A: Asset> From<Handle<A>> for AssetId<A> {
-    #[inline]
-    fn from(value: Handle<A>) -> Self {
-        value.id()
-    }
-}
-
 impl<A: Asset> From<&Handle<A>> for AssetId<A> {
     #[inline]
     fn from(value: &Handle<A>) -> Self {
@@ -263,13 +256,6 @@ impl<A: Asset> From<&Handle<A>> for AssetId<A> {
     }
 }
 
-impl<A: Asset> From<Handle<A>> for UntypedAssetId {
-    #[inline]
-    fn from(value: Handle<A>) -> Self {
-        value.id().into()
-    }
-}
-
 impl<A: Asset> From<&Handle<A>> for UntypedAssetId {
     #[inline]
     fn from(value: &Handle<A>) -> Self {
@@ -429,13 +415,6 @@ impl PartialOrd for UntypedHandle {
     }
 }
 
-impl From<UntypedHandle> for UntypedAssetId {
-    #[inline]
-    fn from(value: UntypedHandle) -> Self {
-        value.id()
-    }
-}
-
 impl From<&UntypedHandle> for UntypedAssetId {
     #[inline]
     fn from(value: &UntypedHandle) -> Self {
diff --git a/crates/bevy_asset/src/io/embedded/mod.rs b/crates/bevy_asset/src/io/embedded/mod.rs
index b953e1e66..d8f85c315 100644
--- a/crates/bevy_asset/src/io/embedded/mod.rs
+++ b/crates/bevy_asset/src/io/embedded/mod.rs
@@ -254,7 +254,7 @@ pub fn watched_path(_source_file_path: &'static str, _asset_path: &'static str)
 macro_rules! load_internal_asset {
     ($app: ident, $handle: expr, $path_str: expr, $loader: expr) => {{
         let mut assets = $app.world.resource_mut::<$crate::Assets<_>>();
-        assets.insert($handle, ($loader)(
+        assets.insert($handle.id(), ($loader)(
             include_str!($path_str),
             std::path::Path::new(file!())
                 .parent()
@@ -266,7 +266,7 @@ macro_rules! load_internal_asset {
     // we can't support params without variadic arguments, so internal assets with additional params can't be hot-reloaded
     ($app: ident, $handle: ident, $path_str: expr, $loader: expr $(, $param:expr)+) => {{
         let mut assets = $app.world.resource_mut::<$crate::Assets<_>>();
-        assets.insert($handle, ($loader)(
+        assets.insert($handle.id(), ($loader)(
             include_str!($path_str),
             std::path::Path::new(file!())
                 .parent()
@@ -284,7 +284,7 @@ macro_rules! load_internal_binary_asset {
     ($app: ident, $handle: expr, $path_str: expr, $loader: expr) => {{
         let mut assets = $app.world.resource_mut::<$crate::Assets<_>>();
         assets.insert(
-            $handle,
+            $handle.id(),
             ($loader)(
                 include_bytes!($path_str).as_ref(),
                 std::path::Path::new(file!())
diff --git a/crates/bevy_asset/src/reflect.rs b/crates/bevy_asset/src/reflect.rs
index dd95df852..41d891127 100644
--- a/crates/bevy_asset/src/reflect.rs
+++ b/crates/bevy_asset/src/reflect.rs
@@ -149,7 +149,7 @@ impl<A: Asset + FromReflect> FromType<A> for ReflectAsset {
                 let mut assets = world.resource_mut::<Assets<A>>();
                 let value: A = FromReflect::from_reflect(value)
                     .expect("could not call `FromReflect::from_reflect` in `ReflectAsset::set`");
-                assets.insert(handle.typed_debug_checked(), value);
+                assets.insert(&handle.typed_debug_checked(), value);
             },
             len: |world| {
                 let assets = world.resource::<Assets<A>>();
@@ -161,7 +161,7 @@ impl<A: Asset + FromReflect> FromType<A> for ReflectAsset {
             },
             remove: |world, handle| {
                 let mut assets = world.resource_mut::<Assets<A>>();
-                let value = assets.remove(handle.typed_debug_checked());
+                let value = assets.remove(&handle.typed_debug_checked());
                 value.map(|value| Box::new(value) as Box<dyn Reflect>)
             },
         }
diff --git a/crates/bevy_pbr/src/lib.rs b/crates/bevy_pbr/src/lib.rs
index c969db794..429aa8513 100644
--- a/crates/bevy_pbr/src/lib.rs
+++ b/crates/bevy_pbr/src/lib.rs
@@ -328,7 +328,7 @@ impl Plugin for PbrPlugin {
         }
 
         app.world.resource_mut::<Assets<StandardMaterial>>().insert(
-            Handle::<StandardMaterial>::default(),
+            &Handle::<StandardMaterial>::default(),
             StandardMaterial {
                 base_color: Color::srgb(1.0, 0.0, 0.5),
                 unlit: true,
diff --git a/crates/bevy_render/src/texture/mod.rs b/crates/bevy_render/src/texture/mod.rs
index 986ae7d10..0d186f9aa 100644
--- a/crates/bevy_render/src/texture/mod.rs
+++ b/crates/bevy_render/src/texture/mod.rs
@@ -90,7 +90,7 @@ impl Plugin for ImagePlugin {
             .register_asset_reflect::<Image>();
         app.world
             .resource_mut::<Assets<Image>>()
-            .insert(Handle::default(), Image::default());
+            .insert(&Handle::default(), Image::default());
         #[cfg(feature = "basis-universal")]
         if let Some(processor) = app
             .world
diff --git a/crates/bevy_scene/src/scene_spawner.rs b/crates/bevy_scene/src/scene_spawner.rs
index 86c0c30d9..08a9695f7 100644
--- a/crates/bevy_scene/src/scene_spawner.rs
+++ b/crates/bevy_scene/src/scene_spawner.rs
@@ -482,7 +482,7 @@ mod tests {
 
         let scene_id = world.resource_mut::<Assets<DynamicScene>>().add(scene);
         let instance_id = scene_spawner
-            .spawn_dynamic_sync(&mut world, scene_id)
+            .spawn_dynamic_sync(&mut world, &scene_id)
             .unwrap();
 
         // verify we spawned exactly one new entity with our expected component
diff --git a/crates/bevy_sprite/src/mesh2d/color_material.rs b/crates/bevy_sprite/src/mesh2d/color_material.rs
index 59d489361..6a5f26463 100644
--- a/crates/bevy_sprite/src/mesh2d/color_material.rs
+++ b/crates/bevy_sprite/src/mesh2d/color_material.rs
@@ -25,7 +25,7 @@ impl Plugin for ColorMaterialPlugin {
             .register_asset_reflect::<ColorMaterial>();
 
         app.world.resource_mut::<Assets<ColorMaterial>>().insert(
-            Handle::<ColorMaterial>::default(),
+            &Handle::<ColorMaterial>::default(),
             ColorMaterial {
                 color: Color::srgb(1.0, 0.0, 1.0),
                 ..Default::default()
diff --git a/examples/2d/mesh2d_manual.rs b/examples/2d/mesh2d_manual.rs
index acb0d3b6d..01f09c8f4 100644
--- a/examples/2d/mesh2d_manual.rs
+++ b/examples/2d/mesh2d_manual.rs
@@ -274,7 +274,7 @@ impl Plugin for ColoredMesh2dPlugin {
         // Load our custom shader
         let mut shaders = app.world.resource_mut::<Assets<Shader>>();
         shaders.insert(
-            COLORED_MESH2D_SHADER_HANDLE,
+            &COLORED_MESH2D_SHADER_HANDLE,
             Shader::from_wgsl(COLORED_MESH2D_SHADER, file!()),
         );
 
diff --git a/examples/shader/array_texture.rs b/examples/shader/array_texture.rs
index d09c233b7..636287a03 100644
--- a/examples/shader/array_texture.rs
+++ b/examples/shader/array_texture.rs
@@ -54,7 +54,7 @@ fn create_array_texture(
     mut materials: ResMut<Assets<ArrayTextureMaterial>>,
 ) {
     if loading_texture.is_loaded
-        || asset_server.load_state(loading_texture.handle.clone()) != LoadState::Loaded
+        || asset_server.load_state(loading_texture.handle.id()) != LoadState::Loaded
     {
         return;
     }
