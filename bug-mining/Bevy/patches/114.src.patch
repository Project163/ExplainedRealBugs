diff --git a/crates/bevy_asset/src/assets.rs b/crates/bevy_asset/src/assets.rs
index 9cf1b4e53..b04d8552f 100644
--- a/crates/bevy_asset/src/assets.rs
+++ b/crates/bevy_asset/src/assets.rs
@@ -549,23 +549,24 @@ impl<A: Asset> Assets<A> {
         while let Ok(drop_event) = assets.handle_provider.drop_receiver.try_recv() {
             let id = drop_event.id.typed();
 
-            assets.queued_events.push(AssetEvent::Unused { id });
-
-            let mut remove_asset = true;
-
             if drop_event.asset_server_managed {
-                let untyped_id = drop_event.id.untyped(TypeId::of::<A>());
+                let untyped_id = id.untyped();
                 if let Some(info) = infos.get(untyped_id) {
                     if let LoadState::Loading | LoadState::NotLoaded = info.load_state {
                         not_ready.push(drop_event);
                         continue;
                     }
                 }
-                remove_asset = infos.process_handle_drop(untyped_id);
-            }
-            if remove_asset {
-                assets.remove_dropped(id);
+
+                // the process_handle_drop call checks whether new handles have been created since the drop event was fired, before removing the asset
+                if !infos.process_handle_drop(untyped_id) {
+                    // a new handle has been created, or the asset doesn't exist
+                    continue;
+                }
             }
+
+            assets.queued_events.push(AssetEvent::Unused { id });
+            assets.remove_dropped(id);
         }
 
         // TODO: this is _extremely_ inefficient find a better fix
