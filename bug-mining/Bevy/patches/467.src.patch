diff --git a/crates/bevy_ui/src/lib.rs b/crates/bevy_ui/src/lib.rs
index f0e0b5868..af806e965 100644
--- a/crates/bevy_ui/src/lib.rs
+++ b/crates/bevy_ui/src/lib.rs
@@ -50,7 +50,7 @@ pub mod prelude {
     pub use {
         crate::{
             geometry::*, node_bundles::*, ui_material::*, ui_node::*, widget::Button,
-            widget::Label, Interaction, UiMaterialPlugin, UiScale,
+            widget::Label, Interaction, UiMaterialHandle, UiMaterialPlugin, UiScale,
         },
         // `bevy_sprite` re-exports for texture slicing
         bevy_sprite::{BorderRect, ImageScaleMode, SliceScaleMode, TextureSlicer},
diff --git a/crates/bevy_ui/src/node_bundles.rs b/crates/bevy_ui/src/node_bundles.rs
index faec98665..957a93024 100644
--- a/crates/bevy_ui/src/node_bundles.rs
+++ b/crates/bevy_ui/src/node_bundles.rs
@@ -3,9 +3,8 @@
 use crate::{
     widget::{Button, UiImageSize},
     BackgroundColor, BorderColor, BorderRadius, ContentSize, FocusPolicy, Interaction, Node,
-    ScrollPosition, Style, UiImage, UiMaterial, ZIndex,
+    ScrollPosition, Style, UiImage, UiMaterial, UiMaterialHandle, ZIndex,
 };
-use bevy_asset::Handle;
 use bevy_ecs::bundle::Bundle;
 use bevy_render::view::{InheritedVisibility, ViewVisibility, Visibility};
 use bevy_transform::prelude::{GlobalTransform, Transform};
@@ -294,7 +293,7 @@ pub struct MaterialNodeBundle<M: UiMaterial> {
     /// In some cases these styles also affect how the node drawn/painted.
     pub style: Style,
     /// The [`UiMaterial`] used to render the node.
-    pub material: Handle<M>,
+    pub material: UiMaterialHandle<M>,
     /// Whether this node should block interaction with lower nodes
     pub focus_policy: FocusPolicy,
     /// The transform of the node
diff --git a/crates/bevy_ui/src/render/ui_material_pipeline.rs b/crates/bevy_ui/src/render/ui_material_pipeline.rs
index 71cbb2dcb..ac2bb134e 100644
--- a/crates/bevy_ui/src/render/ui_material_pipeline.rs
+++ b/crates/bevy_ui/src/render/ui_material_pipeline.rs
@@ -60,7 +60,7 @@ where
             Shader::from_wgsl
         );
         app.init_asset::<M>().add_plugins((
-            ExtractComponentPlugin::<Handle<M>>::extract_visible(),
+            ExtractComponentPlugin::<UiMaterialHandle<M>>::extract_visible(),
             RenderAssetPlugin::<PreparedUiMaterial<M>>::default(),
         ));
 
@@ -364,7 +364,7 @@ pub fn extract_ui_material_nodes<M: UiMaterial>(
             (
                 &Node,
                 &GlobalTransform,
-                &Handle<M>,
+                &UiMaterialHandle<M>,
                 &ViewVisibility,
                 Option<&CalculatedClip>,
                 Option<&TargetCamera>,
diff --git a/crates/bevy_ui/src/ui_material.rs b/crates/bevy_ui/src/ui_material.rs
index 68d727cdb..4c5a788d2 100644
--- a/crates/bevy_ui/src/ui_material.rs
+++ b/crates/bevy_ui/src/ui_material.rs
@@ -1,7 +1,13 @@
 use core::hash::Hash;
 
-use bevy_asset::Asset;
-use bevy_render::render_resource::{AsBindGroup, RenderPipelineDescriptor, ShaderRef};
+use bevy_asset::{Asset, AssetId, Handle};
+use bevy_derive::{Deref, DerefMut};
+use bevy_ecs::{component::Component, reflect::ReflectComponent};
+use bevy_reflect::{prelude::ReflectDefault, Reflect};
+use bevy_render::{
+    extract_component::ExtractComponent,
+    render_resource::{AsBindGroup, RenderPipelineDescriptor, ShaderRef},
+};
 
 /// Materials are used alongside [`UiMaterialPlugin`](crate::UiMaterialPlugin) and [`MaterialNodeBundle`](crate::prelude::MaterialNodeBundle)
 /// to spawn entities that are rendered with a specific [`UiMaterial`] type. They serve as an easy to use high level
@@ -56,10 +62,10 @@ use bevy_render::render_resource::{AsBindGroup, RenderPipelineDescriptor, Shader
 ///             width: Val::Percent(100.0),
 ///             ..Default::default()
 ///         },
-///         material: materials.add(CustomMaterial {
+///         material: UiMaterialHandle(materials.add(CustomMaterial {
 ///             color: LinearRgba::RED,
 ///             color_texture: asset_server.load("some_image.png"),
-///         }),
+///         })),
 ///         ..Default::default()
 ///     });
 /// }
@@ -145,3 +151,31 @@ where
         self.bind_group_data.hash(state);
     }
 }
+
+#[derive(Component, Clone, Debug, Deref, DerefMut, Reflect, PartialEq, Eq, ExtractComponent)]
+#[reflect(Component, Default)]
+pub struct UiMaterialHandle<M: UiMaterial>(pub Handle<M>);
+
+impl<M: UiMaterial> Default for UiMaterialHandle<M> {
+    fn default() -> Self {
+        Self(Handle::default())
+    }
+}
+
+impl<M: UiMaterial> From<Handle<M>> for UiMaterialHandle<M> {
+    fn from(handle: Handle<M>) -> Self {
+        Self(handle)
+    }
+}
+
+impl<M: UiMaterial> From<UiMaterialHandle<M>> for AssetId<M> {
+    fn from(material: UiMaterialHandle<M>) -> Self {
+        material.id()
+    }
+}
+
+impl<M: UiMaterial> From<&UiMaterialHandle<M>> for AssetId<M> {
+    fn from(material: &UiMaterialHandle<M>) -> Self {
+        material.id()
+    }
+}
diff --git a/examples/ui/ui_material.rs b/examples/ui/ui_material.rs
index 7ab11f39b..5a8cf3fde 100644
--- a/examples/ui/ui_material.rs
+++ b/examples/ui/ui_material.rs
@@ -43,12 +43,12 @@ fn setup(
                     border: UiRect::all(Val::Px(10.)),
                     ..default()
                 },
-                material: ui_materials.add(CustomUiMaterial {
+                material: UiMaterialHandle(ui_materials.add(CustomUiMaterial {
                     color: LinearRgba::WHITE.to_f32_array().into(),
                     slider: 0.5,
                     color_texture: asset_server.load("branding/banner.png"),
                     border_color: LinearRgba::WHITE.to_f32_array().into(),
-                }),
+                })),
                 ..default()
             });
         });
@@ -82,7 +82,7 @@ impl UiMaterial for CustomUiMaterial {
 // Also updates the color of the image to a rainbow color
 fn animate(
     mut materials: ResMut<Assets<CustomUiMaterial>>,
-    q: Query<&Handle<CustomUiMaterial>>,
+    q: Query<&UiMaterialHandle<CustomUiMaterial>>,
     time: Res<Time>,
 ) {
     let duration = 2.0;
