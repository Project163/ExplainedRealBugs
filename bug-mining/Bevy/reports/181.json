{"url":"https://api.github.com/repos/bevyengine/bevy/issues/11476","repository_url":"https://api.github.com/repos/bevyengine/bevy","labels_url":"https://api.github.com/repos/bevyengine/bevy/issues/11476/labels{/name}","comments_url":"https://api.github.com/repos/bevyengine/bevy/issues/11476/comments","events_url":"https://api.github.com/repos/bevyengine/bevy/issues/11476/events","html_url":"https://github.com/bevyengine/bevy/issues/11476","id":2094142641,"node_id":"I_kwDODf6-U8580hSx","number":11476,"title":"Custom pipeline in mesh2d_manual also draws normal 2d meshes","user":{"login":"rparrett","id":200550,"node_id":"MDQ6VXNlcjIwMDU1MA==","avatar_url":"https://avatars.githubusercontent.com/u/200550?v=4","gravatar_id":"","url":"https://api.github.com/users/rparrett","html_url":"https://github.com/rparrett","followers_url":"https://api.github.com/users/rparrett/followers","following_url":"https://api.github.com/users/rparrett/following{/other_user}","gists_url":"https://api.github.com/users/rparrett/gists{/gist_id}","starred_url":"https://api.github.com/users/rparrett/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/rparrett/subscriptions","organizations_url":"https://api.github.com/users/rparrett/orgs","repos_url":"https://api.github.com/users/rparrett/repos","events_url":"https://api.github.com/users/rparrett/events{/privacy}","received_events_url":"https://api.github.com/users/rparrett/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1795619323,"node_id":"MDU6TGFiZWwxNzk1NjE5MzIz","url":"https://api.github.com/repos/bevyengine/bevy/labels/C-Bug","name":"C-Bug","color":"d73a4a","default":false,"description":"An unexpected or incorrect behavior"},{"id":2045383863,"node_id":"MDU6TGFiZWwyMDQ1MzgzODYz","url":"https://api.github.com/repos/bevyengine/bevy/labels/A-Rendering","name":"A-Rendering","color":"C6A751","default":false,"description":"Drawing game state to the screen"},{"id":2272053786,"node_id":"MDU6TGFiZWwyMjcyMDUzNzg2","url":"https://api.github.com/repos/bevyengine/bevy/labels/C-Examples","name":"C-Examples","color":"b8b8b8","default":false,"description":"An addition or correction to our examples"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":0,"created_at":"2024-01-22T15:14:06Z","updated_at":"2024-04-25T17:34:40Z","closed_at":"2024-04-25T17:34:40Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"## Bevy version\r\n\r\nmain (9abf565138fc12d45c42b500f2c8fbbc1391599e)\r\nmain (ade70b3925b27f76b669ac5fd9e2c31f824d7667)\r\n\r\n## Relevant system information\r\n\r\n```\r\nAdapterInfo { name: \"Apple M1 Max\", vendor: 0, device: 0, device_type: IntegratedGpu, driver: \"\", driver_info: \"\", backend: Metal }\r\nSystemInfo { os: \"MacOS 14.2.1 \", kernel: \"23.2.0\", cpu: \"\", core_count: \"10\", memory: \"64.0 GiB\" }\r\n```\r\n\r\n## What you did\r\n\r\nRun this modified version of the `mesh2d_manual` example. The only modification is the addition of the `hexagon` system.\r\n\r\n\r\n<details>\r\n<summary>Expand Code</summary>\r\n\r\n```rust\r\n//! This example shows how to manually render 2d items using \"mid level render apis\" with a custom\r\n//! pipeline for 2d meshes.\r\n//! It doesn't use the [`Material2d`] abstraction, but changes the vertex buffer to include vertex color.\r\n//! Check out the \"mesh2d\" example for simpler / higher level 2d meshes.\r\n//!\r\n//! [`Material2d`]: bevy::sprite::Material2d\r\n\r\nuse bevy::{\r\n    color::palettes::basic::YELLOW,\r\n    core_pipeline::core_2d::Transparent2d,\r\n    math::FloatOrd,\r\n    prelude::*,\r\n    render::{\r\n        mesh::{GpuMesh, Indices, MeshVertexAttribute},\r\n        render_asset::{RenderAssetUsages, RenderAssets},\r\n        render_phase::{AddRenderCommand, DrawFunctions, SetItemPipeline, SortedRenderPhase},\r\n        render_resource::{\r\n            BlendState, ColorTargetState, ColorWrites, Face, FragmentState, FrontFace,\r\n            MultisampleState, PipelineCache, PolygonMode, PrimitiveState, PrimitiveTopology,\r\n            RenderPipelineDescriptor, SpecializedRenderPipeline, SpecializedRenderPipelines,\r\n            TextureFormat, VertexBufferLayout, VertexFormat, VertexState, VertexStepMode,\r\n        },\r\n        texture::BevyDefault,\r\n        view::{ExtractedView, ViewTarget, VisibleEntities},\r\n        Extract, Render, RenderApp, RenderSet,\r\n    },\r\n    sprite::{\r\n        extract_mesh2d, DrawMesh2d, Material2dBindGroupId, Mesh2dHandle, Mesh2dPipeline,\r\n        Mesh2dPipelineKey, Mesh2dTransforms, MeshFlags, RenderMesh2dInstance,\r\n        RenderMesh2dInstances, SetMesh2dBindGroup, SetMesh2dViewBindGroup, WithMesh2d,\r\n    },\r\n};\r\nuse bevy_internal::sprite::MaterialMesh2dBundle;\r\nuse std::f32::consts::PI;\r\n\r\nfn main() {\r\n    App::new()\r\n        .add_plugins((DefaultPlugins, ColoredMesh2dPlugin))\r\n        .add_systems(Startup, star)\r\n        .add_systems(Startup, hexagon)\r\n        .run();\r\n}\r\n\r\nfn star(\r\n    mut commands: Commands,\r\n    // We will add a new Mesh for the star being created\r\n    mut meshes: ResMut<Assets<Mesh>>,\r\n) {\r\n    // Let's define the mesh for the object we want to draw: a nice star.\r\n    // We will specify here what kind of topology is used to define the mesh,\r\n    // that is, how triangles are built from the vertices. We will use a\r\n    // triangle list, meaning that each vertex of the triangle has to be\r\n    // specified. We set `RenderAssetUsages::RENDER_WORLD`, meaning this mesh\r\n    // will not be accessible in future frames from the `meshes` resource, in\r\n    // order to save on memory once it has been uploaded to the GPU.\r\n    let mut star = Mesh::new(\r\n        PrimitiveTopology::TriangleList,\r\n        RenderAssetUsages::RENDER_WORLD,\r\n    );\r\n\r\n    // Vertices need to have a position attribute. We will use the following\r\n    // vertices (I hope you can spot the star in the schema).\r\n    //\r\n    //        1\r\n    //\r\n    //     10   2\r\n    // 9      0      3\r\n    //     8     4\r\n    //        6\r\n    //   7        5\r\n    //\r\n    // These vertices are specified in 3D space.\r\n    let mut v_pos = vec![[0.0, 0.0, 0.0]];\r\n    for i in 0..10 {\r\n        // The angle between each vertex is 1/10 of a full rotation.\r\n        let a = i as f32 * PI / 5.0;\r\n        // The radius of inner vertices (even indices) is 100. For outer vertices (odd indices) it's 200.\r\n        let r = (1 - i % 2) as f32 * 100.0 + 100.0;\r\n        // Add the vertex position.\r\n        v_pos.push([r * a.sin(), r * a.cos(), 0.0]);\r\n    }\r\n    // Set the position attribute\r\n    star.insert_attribute(Mesh::ATTRIBUTE_POSITION, v_pos);\r\n    // And a RGB color attribute as well\r\n    let mut v_color: Vec<u32> = vec![LinearRgba::BLACK.as_u32()];\r\n    v_color.extend_from_slice(&[LinearRgba::from(YELLOW).as_u32(); 10]);\r\n    star.insert_attribute(\r\n        MeshVertexAttribute::new(\"Vertex_Color\", 1, VertexFormat::Uint32),\r\n        v_color,\r\n    );\r\n\r\n    // Now, we specify the indices of the vertex that are going to compose the\r\n    // triangles in our star. Vertices in triangles have to be specified in CCW\r\n    // winding (that will be the front face, colored). Since we are using\r\n    // triangle list, we will specify each triangle as 3 vertices\r\n    //   First triangle: 0, 2, 1\r\n    //   Second triangle: 0, 3, 2\r\n    //   Third triangle: 0, 4, 3\r\n    //   etc\r\n    //   Last triangle: 0, 1, 10\r\n    let mut indices = vec![0, 1, 10];\r\n    for i in 2..=10 {\r\n        indices.extend_from_slice(&[0, i, i - 1]);\r\n    }\r\n    star.insert_indices(Indices::U32(indices));\r\n\r\n    // We can now spawn the entities for the star and the camera\r\n    commands.spawn((\r\n        // We use a marker component to identify the custom colored meshes\r\n        ColoredMesh2d,\r\n        // The `Handle<Mesh>` needs to be wrapped in a `Mesh2dHandle` to use 2d rendering instead of 3d\r\n        Mesh2dHandle(meshes.add(star)),\r\n        // This bundle's components are needed for something to be rendered\r\n        SpatialBundle::INHERITED_IDENTITY,\r\n    ));\r\n\r\n    // Spawn the camera\r\n    commands.spawn(Camera2dBundle::default());\r\n}\r\n\r\n/// A marker component for colored 2d meshes\r\n#[derive(Component, Default)]\r\npub struct ColoredMesh2d;\r\n\r\n/// Custom pipeline for 2d meshes with vertex colors\r\n#[derive(Resource)]\r\npub struct ColoredMesh2dPipeline {\r\n    /// this pipeline wraps the standard [`Mesh2dPipeline`]\r\n    mesh2d_pipeline: Mesh2dPipeline,\r\n}\r\n\r\nimpl FromWorld for ColoredMesh2dPipeline {\r\n    fn from_world(world: &mut World) -> Self {\r\n        Self {\r\n            mesh2d_pipeline: Mesh2dPipeline::from_world(world),\r\n        }\r\n    }\r\n}\r\n\r\n// We implement `SpecializedPipeline` to customize the default rendering from `Mesh2dPipeline`\r\nimpl SpecializedRenderPipeline for ColoredMesh2dPipeline {\r\n    type Key = Mesh2dPipelineKey;\r\n\r\n    fn specialize(&self, key: Self::Key) -> RenderPipelineDescriptor {\r\n        // Customize how to store the meshes' vertex attributes in the vertex buffer\r\n        // Our meshes only have position and color\r\n        let formats = vec![\r\n            // Position\r\n            VertexFormat::Float32x3,\r\n            // Color\r\n            VertexFormat::Uint32,\r\n        ];\r\n\r\n        let vertex_layout =\r\n            VertexBufferLayout::from_vertex_formats(VertexStepMode::Vertex, formats);\r\n\r\n        let format = match key.contains(Mesh2dPipelineKey::HDR) {\r\n            true => ViewTarget::TEXTURE_FORMAT_HDR,\r\n            false => TextureFormat::bevy_default(),\r\n        };\r\n\r\n        RenderPipelineDescriptor {\r\n            vertex: VertexState {\r\n                // Use our custom shader\r\n                shader: COLORED_MESH2D_SHADER_HANDLE,\r\n                entry_point: \"vertex\".into(),\r\n                shader_defs: vec![],\r\n                // Use our custom vertex buffer\r\n                buffers: vec![vertex_layout],\r\n            },\r\n            fragment: Some(FragmentState {\r\n                // Use our custom shader\r\n                shader: COLORED_MESH2D_SHADER_HANDLE,\r\n                shader_defs: vec![],\r\n                entry_point: \"fragment\".into(),\r\n                targets: vec![Some(ColorTargetState {\r\n                    format,\r\n                    blend: Some(BlendState::ALPHA_BLENDING),\r\n                    write_mask: ColorWrites::ALL,\r\n                })],\r\n            }),\r\n            // Use the two standard uniforms for 2d meshes\r\n            layout: vec![\r\n                // Bind group 0 is the view uniform\r\n                self.mesh2d_pipeline.view_layout.clone(),\r\n                // Bind group 1 is the mesh uniform\r\n                self.mesh2d_pipeline.mesh_layout.clone(),\r\n            ],\r\n            push_constant_ranges: vec![],\r\n            primitive: PrimitiveState {\r\n                front_face: FrontFace::Ccw,\r\n                cull_mode: Some(Face::Back),\r\n                unclipped_depth: false,\r\n                polygon_mode: PolygonMode::Fill,\r\n                conservative: false,\r\n                topology: key.primitive_topology(),\r\n                strip_index_format: None,\r\n            },\r\n            depth_stencil: None,\r\n            multisample: MultisampleState {\r\n                count: key.msaa_samples(),\r\n                mask: !0,\r\n                alpha_to_coverage_enabled: false,\r\n            },\r\n            label: Some(\"colored_mesh2d_pipeline\".into()),\r\n        }\r\n    }\r\n}\r\n\r\n// This specifies how to render a colored 2d mesh\r\ntype DrawColoredMesh2d = (\r\n    // Set the pipeline\r\n    SetItemPipeline,\r\n    // Set the view uniform as bind group 0\r\n    SetMesh2dViewBindGroup<0>,\r\n    // Set the mesh uniform as bind group 1\r\n    SetMesh2dBindGroup<1>,\r\n    // Draw the mesh\r\n    DrawMesh2d,\r\n);\r\n\r\n// The custom shader can be inline like here, included from another file at build time\r\n// using `include_str!()`, or loaded like any other asset with `asset_server.load()`.\r\nconst COLORED_MESH2D_SHADER: &str = r\"\r\n// Import the standard 2d mesh uniforms and set their bind groups\r\n#import bevy_sprite::mesh2d_functions\r\n\r\n// The structure of the vertex buffer is as specified in `specialize()`\r\nstruct Vertex {\r\n    @builtin(instance_index) instance_index: u32,\r\n    @location(0) position: vec3<f32>,\r\n    @location(1) color: u32,\r\n};\r\n\r\nstruct VertexOutput {\r\n    // The vertex shader must set the on-screen position of the vertex\r\n    @builtin(position) clip_position: vec4<f32>,\r\n    // We pass the vertex color to the fragment shader in location 0\r\n    @location(0) color: vec4<f32>,\r\n};\r\n\r\n/// Entry point for the vertex shader\r\n@vertex\r\nfn vertex(vertex: Vertex) -> VertexOutput {\r\n    var out: VertexOutput;\r\n    // Project the world position of the mesh into screen position\r\n    let model = mesh2d_functions::get_model_matrix(vertex.instance_index);\r\n    out.clip_position = mesh2d_functions::mesh2d_position_local_to_clip(model, vec4<f32>(vertex.position, 1.0));\r\n    // Unpack the `u32` from the vertex buffer into the `vec4<f32>` used by the fragment shader\r\n    out.color = vec4<f32>((vec4<u32>(vertex.color) >> vec4<u32>(0u, 8u, 16u, 24u)) & vec4<u32>(255u)) / 255.0;\r\n    return out;\r\n}\r\n\r\n// The input of the fragment shader must correspond to the output of the vertex shader for all `location`s\r\nstruct FragmentInput {\r\n    // The color is interpolated between vertices by default\r\n    @location(0) color: vec4<f32>,\r\n};\r\n\r\n/// Entry point for the fragment shader\r\n@fragment\r\nfn fragment(in: FragmentInput) -> @location(0) vec4<f32> {\r\n    return in.color;\r\n}\r\n\";\r\n\r\n/// Plugin that renders [`ColoredMesh2d`]s\r\npub struct ColoredMesh2dPlugin;\r\n\r\n/// Handle to the custom shader with a unique random ID\r\npub const COLORED_MESH2D_SHADER_HANDLE: Handle<Shader> =\r\n    Handle::weak_from_u128(13828845428412094821);\r\n\r\nimpl Plugin for ColoredMesh2dPlugin {\r\n    fn build(&self, app: &mut App) {\r\n        // Load our custom shader\r\n        let mut shaders = app.world_mut().resource_mut::<Assets<Shader>>();\r\n        shaders.insert(\r\n            &COLORED_MESH2D_SHADER_HANDLE,\r\n            Shader::from_wgsl(COLORED_MESH2D_SHADER, file!()),\r\n        );\r\n\r\n        // Register our custom draw function, and add our render systems\r\n        app.get_sub_app_mut(RenderApp)\r\n            .unwrap()\r\n            .add_render_command::<Transparent2d, DrawColoredMesh2d>()\r\n            .init_resource::<SpecializedRenderPipelines<ColoredMesh2dPipeline>>()\r\n            .add_systems(\r\n                ExtractSchedule,\r\n                extract_colored_mesh2d.after(extract_mesh2d),\r\n            )\r\n            .add_systems(Render, queue_colored_mesh2d.in_set(RenderSet::QueueMeshes));\r\n    }\r\n\r\n    fn finish(&self, app: &mut App) {\r\n        // Register our custom pipeline\r\n        app.get_sub_app_mut(RenderApp)\r\n            .unwrap()\r\n            .init_resource::<ColoredMesh2dPipeline>();\r\n    }\r\n}\r\n\r\n/// Extract the [`ColoredMesh2d`] marker component into the render app\r\npub fn extract_colored_mesh2d(\r\n    mut commands: Commands,\r\n    mut previous_len: Local<usize>,\r\n    // When extracting, you must use `Extract` to mark the `SystemParam`s\r\n    // which should be taken from the main world.\r\n    query: Extract<\r\n        Query<(Entity, &ViewVisibility, &GlobalTransform, &Mesh2dHandle), With<ColoredMesh2d>>,\r\n    >,\r\n    mut render_mesh_instances: ResMut<RenderMesh2dInstances>,\r\n) {\r\n    let mut values = Vec::with_capacity(*previous_len);\r\n    for (entity, view_visibility, transform, handle) in &query {\r\n        if !view_visibility.get() {\r\n            continue;\r\n        }\r\n\r\n        let transforms = Mesh2dTransforms {\r\n            transform: (&transform.affine()).into(),\r\n            flags: MeshFlags::empty().bits(),\r\n        };\r\n\r\n        values.push((entity, ColoredMesh2d));\r\n        render_mesh_instances.insert(\r\n            entity,\r\n            RenderMesh2dInstance {\r\n                mesh_asset_id: handle.0.id(),\r\n                transforms,\r\n                material_bind_group_id: Material2dBindGroupId::default(),\r\n                automatic_batching: false,\r\n            },\r\n        );\r\n    }\r\n    *previous_len = values.len();\r\n    commands.insert_or_spawn_batch(values);\r\n}\r\n\r\n/// Queue the 2d meshes marked with [`ColoredMesh2d`] using our custom pipeline and draw function\r\n#[allow(clippy::too_many_arguments)]\r\npub fn queue_colored_mesh2d(\r\n    transparent_draw_functions: Res<DrawFunctions<Transparent2d>>,\r\n    colored_mesh2d_pipeline: Res<ColoredMesh2dPipeline>,\r\n    mut pipelines: ResMut<SpecializedRenderPipelines<ColoredMesh2dPipeline>>,\r\n    pipeline_cache: Res<PipelineCache>,\r\n    msaa: Res<Msaa>,\r\n    render_meshes: Res<RenderAssets<GpuMesh>>,\r\n    render_mesh_instances: Res<RenderMesh2dInstances>,\r\n    mut views: Query<(\r\n        &VisibleEntities,\r\n        &mut SortedRenderPhase<Transparent2d>,\r\n        &ExtractedView,\r\n    )>,\r\n) {\r\n    if render_mesh_instances.is_empty() {\r\n        return;\r\n    }\r\n    // Iterate each view (a camera is a view)\r\n    for (visible_entities, mut transparent_phase, view) in &mut views {\r\n        let draw_colored_mesh2d = transparent_draw_functions.read().id::<DrawColoredMesh2d>();\r\n\r\n        let mesh_key = Mesh2dPipelineKey::from_msaa_samples(msaa.samples())\r\n            | Mesh2dPipelineKey::from_hdr(view.hdr);\r\n\r\n        // Queue all entities visible to that view\r\n        for visible_entity in visible_entities.iter::<WithMesh2d>() {\r\n            if let Some(mesh_instance) = render_mesh_instances.get(visible_entity) {\r\n                let mesh2d_handle = mesh_instance.mesh_asset_id;\r\n                let mesh2d_transforms = &mesh_instance.transforms;\r\n                // Get our specialized pipeline\r\n                let mut mesh2d_key = mesh_key;\r\n                if let Some(mesh) = render_meshes.get(mesh2d_handle) {\r\n                    mesh2d_key |=\r\n                        Mesh2dPipelineKey::from_primitive_topology(mesh.primitive_topology());\r\n                }\r\n\r\n                let pipeline_id =\r\n                    pipelines.specialize(&pipeline_cache, &colored_mesh2d_pipeline, mesh2d_key);\r\n\r\n                let mesh_z = mesh2d_transforms.transform.translation.z;\r\n                transparent_phase.add(Transparent2d {\r\n                    entity: *visible_entity,\r\n                    draw_function: draw_colored_mesh2d,\r\n                    pipeline: pipeline_id,\r\n                    // The 2d render items are sorted according to their z value before rendering,\r\n                    // in order to get correct transparency\r\n                    sort_key: FloatOrd(mesh_z),\r\n                    // This material is not batched\r\n                    batch_range: 0..1,\r\n                    dynamic_offset: None,\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfn hexagon(\r\n    mut commands: Commands,\r\n    mut meshes: ResMut<Assets<Mesh>>,\r\n    mut materials: ResMut<Assets<ColorMaterial>>,\r\n) {\r\n    commands.spawn(MaterialMesh2dBundle {\r\n        mesh: meshes.add(RegularPolygon::new(150., 6)).into(),\r\n        material: materials.add(Color::from(bevy::color::palettes::css::TURQUOISE)),\r\n        transform: Transform::from_translation(Vec3::new(350., 0., 0.)),\r\n        ..default()\r\n    });\r\n}\r\n```\r\n</details>\r\n\r\n\r\n## What went wrong\r\n\r\nI expected a solid colored hexagon next to the gradiant-shaded star. But about half of the time, I see this instead:\r\n\r\n<img width=\"1280\" alt=\"image\" src=\"https://github.com/bevyengine/bevy/assets/200550/b07e936c-8c7a-4285-b191-3d6a1d53fe2a\">\r\n\r\nSo it seems that an additional hexagon is also drawn, and is randomly drawn above or below the other hexagon, or something along those lines.\r\n\r\n## Additional information\r\n\r\nAdditional context and confirmation that the linked PR seems to solve the issue in a Discord help thread here: https://discord.com/channels/691052431525675048/1198995408337256558.\r\n\r\nWhat I expect to see / what happens on some runs:\r\n\r\n<img width=\"1280\" alt=\"image\" src=\"https://github.com/bevyengine/bevy/assets/200550/1f9e0ba7-f138-4322-ab9d-eaa40087edbd\">\r\n\r\n","closed_by":{"login":"superdump","id":302146,"node_id":"MDQ6VXNlcjMwMjE0Ng==","avatar_url":"https://avatars.githubusercontent.com/u/302146?v=4","gravatar_id":"","url":"https://api.github.com/users/superdump","html_url":"https://github.com/superdump","followers_url":"https://api.github.com/users/superdump/followers","following_url":"https://api.github.com/users/superdump/following{/other_user}","gists_url":"https://api.github.com/users/superdump/gists{/gist_id}","starred_url":"https://api.github.com/users/superdump/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/superdump/subscriptions","organizations_url":"https://api.github.com/users/superdump/orgs","repos_url":"https://api.github.com/users/superdump/repos","events_url":"https://api.github.com/users/superdump/events{/privacy}","received_events_url":"https://api.github.com/users/superdump/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/bevyengine/bevy/issues/11476/reactions","total_count":0,"+1":0,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/bevyengine/bevy/issues/11476/timeline","performed_via_github_app":null,"state_reason":"completed"}