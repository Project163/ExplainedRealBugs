{"url":"https://api.github.com/repos/bevyengine/bevy/issues/15367","repository_url":"https://api.github.com/repos/bevyengine/bevy","labels_url":"https://api.github.com/repos/bevyengine/bevy/issues/15367/labels{/name}","comments_url":"https://api.github.com/repos/bevyengine/bevy/issues/15367/comments","events_url":"https://api.github.com/repos/bevyengine/bevy/issues/15367/events","html_url":"https://github.com/bevyengine/bevy/issues/15367","id":2541163912,"node_id":"I_kwDODf6-U86XdxWI","number":15367,"title":"Allow plugins to define component requirements","user":{"login":"Jondolf","id":57632562,"node_id":"MDQ6VXNlcjU3NjMyNTYy","avatar_url":"https://avatars.githubusercontent.com/u/57632562?v=4","gravatar_id":"","url":"https://api.github.com/users/Jondolf","html_url":"https://github.com/Jondolf","followers_url":"https://api.github.com/users/Jondolf/followers","following_url":"https://api.github.com/users/Jondolf/following{/other_user}","gists_url":"https://api.github.com/users/Jondolf/gists{/gist_id}","starred_url":"https://api.github.com/users/Jondolf/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/Jondolf/subscriptions","organizations_url":"https://api.github.com/users/Jondolf/orgs","repos_url":"https://api.github.com/users/Jondolf/repos","events_url":"https://api.github.com/users/Jondolf/events{/privacy}","received_events_url":"https://api.github.com/users/Jondolf/received_events","type":"User","user_view_type":"public","site_admin":false},"labels":[{"id":1795619326,"node_id":"MDU6TGFiZWwxNzk1NjE5MzI2","url":"https://api.github.com/repos/bevyengine/bevy/labels/C-Feature","name":"C-Feature","color":"b8b8b8","default":false,"description":"A new feature, making something new possible"},{"id":2197761682,"node_id":"MDU6TGFiZWwyMTk3NzYxNjgy","url":"https://api.github.com/repos/bevyengine/bevy/labels/A-ECS","name":"A-ECS","color":"c6a751","default":false,"description":"Entities, components, systems, and events"},{"id":3166151441,"node_id":"MDU6TGFiZWwzMTY2MTUxNDQx","url":"https://api.github.com/repos/bevyengine/bevy/labels/S-Ready-For-Implementation","name":"S-Ready-For-Implementation","color":"D876E3","default":false,"description":"This issue is ready for an implementation PR. Go for it!"},{"id":6899552399,"node_id":"LA_kwDODf6-U88AAAABmz7Qjw","url":"https://api.github.com/repos/bevyengine/bevy/labels/X-Contentious","name":"X-Contentious","color":"D93F0B","default":false,"description":"There are nontrivial implications that should be thought through"},{"id":6899554715,"node_id":"LA_kwDODf6-U88AAAABmz7Zmw","url":"https://api.github.com/repos/bevyengine/bevy/labels/X-Blessed","name":"X-Blessed","color":"D93F0B","default":false,"description":"Has a large architectural impact or tradeoffs, but the design has been endorsed by decision makers"}],"state":"closed","locked":false,"assignee":null,"assignees":[],"milestone":null,"comments":7,"created_at":"2024-09-22T16:54:00Z","updated_at":"2024-09-30T19:36:16Z","closed_at":"2024-09-30T19:36:16Z","author_association":"CONTRIBUTOR","type":null,"active_lock_reason":null,"sub_issues_summary":{"total":0,"completed":0,"percent_completed":0},"issue_dependencies_summary":{"blocked_by":0,"total_blocked_by":0,"blocking":0,"total_blocking":0},"body":"This is similar to #14927, but more scoped, and with a slightly more flexible API.\r\n\r\n## What problem does this solve or what need does it fill?\r\n\r\nCurrently, required components work only through the `require` attribute on component types. For example:\r\n\r\n```rust\r\n#[derive(Component)]\r\n#[require(Mass, SleepTimer, ...)]\r\npub struct RigidBody;\r\n\r\n#[derive(Component, Default)]\r\npub struct Mass(pub f32);\r\n\r\n#[derive(Component, Default)]\r\npub struct SleepTimer(pub Timer);\r\n```\r\n\r\nThe above works, nice! However, there's a problem. We only want mass properties for rigid bodies with the `Dynamic` marker component, as static and kinematic bodies shouldn't have any mass components. Additionally, `SleepTimer` is only relevant when the `SleepPlugin` is enabled, and only for dynamic rigid bodies. If sleeping is disabled, there's no reason to insert sleeping components for everything!\r\n\r\nWe could use component lifecycle hooks to add the components conditionally, but this is also problematic. It causes additional archetype moves for each `insert` command, and you can also only have one instance of each lifecycle hook per component, which could cause conflicts if the component already has a hook registered, either by itself or by another plugin. The next option is to use observers, but that feels less semantically correct, runs after hooks, and incurs a larger overhead.\r\n\r\nNot being able to define component requirements externally and conditionally harms composability and usability. The natural way of organizing and encapsulating functionality in Bevy is a plugin, but they currently have no way of defining these relationships. Instead, all the requirements are forced to be on the type definition directly, which leaks implementation details they shouldn't always need to care about. This also hurts third party plugins, as they might want to make their own components required by external components, or even define their own versions of components that are required by some shared component.\r\n\r\n> [!NOTE]\r\n> For the earlier example specifically, we could technically get around some of the issues with separate `DynamicBody`, `KinematicBody`, and `StaticBody` components that maybe require some shared `RigidBodyMarker` component. This is a broader issue though, and a lot of the same arguments still apply, especially around composability and third party requirements.\r\n\r\n## What solution would you like?\r\n\r\nAdd an `add_require` method to `App`. It takes two type arguments: a bundle defining the components that must be present, and the required components that should be added when they are present.\r\n\r\nThe earlier `Mass` case could be handled like this:\r\n\r\n```rust\r\nstruct MassPropertyPlugin;\r\n\r\nimpl Plugin for MassPropertyPlugin {\r\n    fn plugin(app: &mut App) {\r\n        // Add `Mass` only for dynamic rigid bodies.\r\n        // Both components must be present.\r\n        app.add_require::<(RigidBody, Dynamic), Mass>();\r\n    }\r\n}\r\n```\r\n\r\nand the sleeping case like this:\r\n\r\n```rust\r\nstruct SleepingPlugin;\r\n\r\nimpl Plugin for SleepingPlugin {\r\n    fn plugin(app: &mut App) {\r\n        // Add `SleepTimer` only for dynamic rigid bodies.\r\n        app.add_require::<(RigidBody, Dynamic), SleepTimer>();\r\n    }\r\n}\r\n```\r\n\r\nThe second type parameter could even be a bundle, letting you insert multiple components with a single requirement relationship.\r\n\r\nCustom constructors can be provided using `add_require_with`:\r\n\r\n```rust\r\napp.add_require_with::<RigidBody, SleepTimer>(my_constructor);\r\n```\r\n\r\nThese methods have a few nice benefits over the type-level `require` attribute:\r\n\r\n- In addition to \"component requirements\", we also have \"bundle requirements\". All components in a bundle must be present for the component to be inserted, allowing basic conditional insertion.\r\n- Requirements are optional and composable through plugins. The core `RigidBody` shouldn't need to care about sleeping unless the plugin for it is enabled.\r\n- Third party crates can define their own requirements for first party types. For example, \"each `Handle<Mesh>` should require my custom rendering data components\". This also gets around the orphan rule.\r\n- Users can replace built-in components with their own versions. Let's say `GlobalTransform` required `Transform`, but we instead wanted to use our own `CustomTransform` type. This isn't possible when the requirement is encoded at the type level. Instead, we might want to have a `TransformPlugin` that defines a relationship like `app.add_require::<GlobalTransform, Transform>`. This would still allow us to replace it with our own plugin that defines `app.add_require::<GlobalTransform, CustomTransform>`.\r\n\t- Note: This likely isn't how we should actually handle custom transforms. It's mainly just a simple example of how this could be useful in general.\r\n\r\n## Discussion\r\n\r\n### Breaking Assumptions? Removing Requirements?\r\n\r\nIs this abstraction breaking, and does it invalidate assumptions made by other code? The suggestion to *remove* requirements was heavily controversial in #14927. [Quoting Cart](https://github.com/bevyengine/bevy/issues/14927#issuecomment-2310942757):\r\n\r\n> In general I think this \\[Required Component Overrides\\] is a pattern we should not be encouraging. If some third party `SpecialComponent` requires `Transform`, then that third party code (and _other_ third parties that depend on it) can and _should_ be written under the assumption that it will have a Transform.\r\n>\r\n> A developer choosing to break that assumption risks breaking third party code in unexpected and arbitrary ways. And as these dependencies update, they risk adding _new_ cases that also break.\r\n\r\nI 100% agree with this sentiment. Being able to arbitrarily *remove* constraints like this from any plugin is risky and can easily break things.\r\n\r\nHowever, requirements being additive and composable through plugins is not as big of an issue in my opinion. That requirement is semantically tied to the *plugin*, not the component, and you need to explicitly disable a plugin to remove its requirement constraints. This could indeed break logic that depends on that constraint, but the same is also true for systems and resources. Disabling a plugin just means that you are disabling some piece of functionality, and you can always reimplement it with your own version.\r\n\r\nThat's a big part of what makes Bevy great in my opinion. Plugins are organizational units that encapsulate and compose functionality in a clean and structured manner, and you can freely replace them with your own versions if you want to. I think this should extend to components to some extent.\r\n\r\nTo be clear, this shouldn't be the default way to define requirement constraints. The type-level `require` attribute should still be used in the vast majority of cases, especially for *true* requirements. For example, a `RigidBody` should *always* require a `PhysicsTransform`. However, for components that only make sense in the context of optional plugins (like `SleepPlugin`) or are defined in third party code, there should be an external way to define requirements.\r\n\r\n### `QueryFilter`\r\n\r\nInstead of `add_require` taking a bundle, it could take a full `QueryFilter`. This would add the specified components only when the filter is satisfied.\r\n\r\nHowever, I think this would quickly become confusing and technically challenging (impossible?), especially for things like `Added<T>` and `Changed<T>`.\r\n\r\nThe only useful functionality other than taking a bundle would be a way to define `Without<T>` filters, so you could do e.g. `app.add_require::<(RigidBody, Without<Static>), Mass>`, meaning that `Mass` is required by all rigid bodies that are *not* static.\r\n\r\n## What alternative(s) have you considered?\r\n\r\nKeep inserting components manually using lifecycle hooks where possible, and using observers where it isn't.\r\n\r\nI just want some form of:\r\n\r\n- conditional requirements, i.e. only requiring components if some other components are/aren't also present\r\n- allowing plugins to define component requirements.\r\n\r\nWhat this looks like isn't as important to me, as long as it's possible. I don't think forcing the use of hooks or observers for this is a good solution, unless doing it through required components is impossible from a technical standpoint.","closed_by":{"login":"alice-i-cecile","id":3579909,"node_id":"MDQ6VXNlcjM1Nzk5MDk=","avatar_url":"https://avatars.githubusercontent.com/u/3579909?v=4","gravatar_id":"","url":"https://api.github.com/users/alice-i-cecile","html_url":"https://github.com/alice-i-cecile","followers_url":"https://api.github.com/users/alice-i-cecile/followers","following_url":"https://api.github.com/users/alice-i-cecile/following{/other_user}","gists_url":"https://api.github.com/users/alice-i-cecile/gists{/gist_id}","starred_url":"https://api.github.com/users/alice-i-cecile/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/alice-i-cecile/subscriptions","organizations_url":"https://api.github.com/users/alice-i-cecile/orgs","repos_url":"https://api.github.com/users/alice-i-cecile/repos","events_url":"https://api.github.com/users/alice-i-cecile/events{/privacy}","received_events_url":"https://api.github.com/users/alice-i-cecile/received_events","type":"User","user_view_type":"public","site_admin":false},"reactions":{"url":"https://api.github.com/repos/bevyengine/bevy/issues/15367/reactions","total_count":2,"+1":2,"-1":0,"laugh":0,"hooray":0,"confused":0,"heart":0,"rocket":0,"eyes":0},"timeline_url":"https://api.github.com/repos/bevyengine/bevy/issues/15367/timeline","performed_via_github_app":null,"state_reason":"completed"}