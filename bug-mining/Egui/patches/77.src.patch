diff --git a/crates/egui/src/context.rs b/crates/egui/src/context.rs
index 53ce7661..ec899461 100644
--- a/crates/egui/src/context.rs
+++ b/crates/egui/src/context.rs
@@ -2418,12 +2418,18 @@ impl Context {
 
         self.write(|ctx| {
             let tessellation_options = ctx.memory.options.tessellation_options;
-            let texture_atlas = ctx
-                .fonts
-                .get(&pixels_per_point.into())
-                .expect("tessellate called with a different pixels_per_point than the font atlas was created with. \
-                         You should use egui::FullOutput::pixels_per_point when tessellating.")
-                .texture_atlas();
+            let texture_atlas = if let Some(fonts) = ctx.fonts.get(&pixels_per_point.into()) {
+                fonts.texture_atlas()
+            } else {
+                #[cfg(feature = "log")]
+                log::warn!("No font size matching {pixels_per_point} pixels per point found.");
+                ctx.fonts
+                    .iter()
+                    .next()
+                    .expect("No fonts loaded")
+                    .1
+                    .texture_atlas()
+            };
             let (font_tex_size, prepared_discs) = {
                 let atlas = texture_atlas.lock();
                 (atlas.size(), atlas.prepared_discs())
diff --git a/crates/egui/src/layers.rs b/crates/egui/src/layers.rs
index 66bbd338..9105ece2 100644
--- a/crates/egui/src/layers.rs
+++ b/crates/egui/src/layers.rs
@@ -153,6 +153,12 @@ impl PaintList {
     /// and then later setting it using `paint_list.set(idx, cr, frame);`.
     #[inline(always)]
     pub fn set(&mut self, idx: ShapeIdx, clip_rect: Rect, shape: Shape) {
+        if self.0.len() <= idx.0 {
+            #[cfg(feature = "log")]
+            log::warn!("Index {} is out of bounds for PaintList", idx.0);
+            return;
+        }
+
         self.0[idx.0] = ClippedShape { clip_rect, shape };
     }
 
