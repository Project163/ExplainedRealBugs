diff --git a/src/modules/git_status.rs b/src/modules/git_status.rs
index 4d55c9c1..1cbf0da7 100644
--- a/src/modules/git_status.rs
+++ b/src/modules/git_status.rs
@@ -260,7 +260,6 @@ fn get_repo_status(repository: &mut Repository) -> Result<RepoStatus, git2::Erro
     status_options
         .renames_from_rewrites(true)
         .renames_head_to_index(true)
-        .renames_index_to_workdir(true)
         .include_unmodified(true);
 
     let statuses = repository.statuses(Some(&mut status_options))?;
diff --git a/tests/testsuite/git_status.rs b/tests/testsuite/git_status.rs
index 80f642fe..ed6d85c0 100644
--- a/tests/testsuite/git_status.rs
+++ b/tests/testsuite/git_status.rs
@@ -503,6 +503,53 @@ fn shows_deleted_file_with_count() -> io::Result<()> {
     remove_dir_all(repo_dir)
 }
 
+// Whenever a file is manually renamed, git itself ('git status') does not treat such file as renamed,
+// but as untracked instead. The following test checks if manually deleted and manually renamed
+// files are tracked by git_status module in the same way 'git status' does.
+#[test]
+#[ignore]
+fn ignore_manually_renamed() -> io::Result<()> {
+    let repo_dir = common::create_fixture_repo()?;
+    File::create(repo_dir.join("a"))?.sync_all()?;
+    File::create(repo_dir.join("b"))?.sync_all()?;
+    Command::new("git")
+        .args(&["add", "--all"])
+        .current_dir(&repo_dir)
+        .output()?;
+    Command::new("git")
+        .args(&["commit", "-m", "add new files"])
+        .current_dir(&repo_dir)
+        .output()?;
+
+    fs::remove_file(repo_dir.join("a"))?;
+    fs::rename(repo_dir.join("b"), repo_dir.join("c"))?;
+    barrier();
+
+    let output = common::render_module("git_status")
+        .arg("--path")
+        .arg(&repo_dir)
+        .env_clear()
+        .use_config(toml::toml! {
+            [git_status]
+            prefix = ""
+            suffix = ""
+            style = ""
+            ahead = "A"
+            deleted = "D"
+            untracked = "U"
+            renamed = "R"
+        })
+        .output()?;
+
+    let actual = String::from_utf8(output.stdout).unwrap();
+    assert!(actual.contains('A'));
+    assert!(actual.contains('D'));
+    assert!(actual.contains('U'));
+    assert!(!actual.contains('R'));
+
+    remove_dir_all(repo_dir)
+}
+
 fn ahead(repo_dir: &PathBuf) -> io::Result<()> {
     File::create(repo_dir.join("readme.md"))?.sync_all()?;
 
