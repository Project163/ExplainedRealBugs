diff --git a/.golangci.yml b/.golangci.yml
index 6391bf59..4029779e 100644
--- a/.golangci.yml
+++ b/.golangci.yml
@@ -4,7 +4,7 @@ linters-settings:
   golint:
     min-confidence: 0
   gocyclo:
-    min-complexity: 20
+    min-complexity: 25
   maligned:
     suggest-new: true
   dupl:
diff --git a/appveyor.yml b/appveyor.yml
index bfcd5593..eea7f002 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -50,7 +50,7 @@ build_script:
   - echo %GOPATH%
 
 test_script:
-  - ps: go test -timeout 20m -race -v $(go list ./... | sls -n "vendor|fixtures|examples")
+  - ps: go test -timeout 20m -v $(go list ./... | sls -n "vendor|fixtures|examples")
 
 #artifacts:
 #  - path: '%GOPATH%\bin\*.exe'
diff --git a/cmd/swagger/commands/expand.go b/cmd/swagger/commands/expand.go
index 1e2686fe..1df1b355 100644
--- a/cmd/swagger/commands/expand.go
+++ b/cmd/swagger/commands/expand.go
@@ -8,13 +8,18 @@ import (
 
 	"github.com/go-openapi/loads"
 	"github.com/go-openapi/spec"
+	"github.com/go-openapi/swag"
 	flags "github.com/jessevdk/go-flags"
+	yaml "gopkg.in/yaml.v2"
 )
 
-// ExpandSpec is a command that expands the $refs in a swagger document
+// ExpandSpec is a command that expands the $refs in a swagger document.
+//
+// There are no specific options for this expansion.
 type ExpandSpec struct {
-	Compact bool           `long:"compact" description:"when present, doesn't prettify the json"`
+	Compact bool           `long:"compact" description:"applies to JSON formated specs. When present, doesn't prettify the json"`
 	Output  flags.Filename `long:"output" short:"o" description:"the file to write to"`
+	Format  string         `long:"format" description:"the format for the spec document" default:"json" choice:"yaml" choice:"json"`
 }
 
 // Execute expands the spec
@@ -34,16 +39,28 @@ func (c *ExpandSpec) Execute(args []string) error {
 		return err
 	}
 
-	return writeToFile(exp.Spec(), !c.Compact, string(c.Output))
+	return writeToFile(exp.Spec(), !c.Compact, c.Format, string(c.Output))
 }
 
-func writeToFile(swspec *spec.Swagger, pretty bool, output string) error {
+func writeToFile(swspec *spec.Swagger, pretty bool, format string, output string) error {
 	var b []byte
 	var err error
-	if pretty {
+	asJSON := format == "json"
+
+	if pretty && asJSON {
 		b, err = json.MarshalIndent(swspec, "", "  ")
+	} else if asJSON {
+		b, err = json.Marshal(swspec)
 	} else {
+		// marshals as YAML
 		b, err = json.Marshal(swspec)
+		if err == nil {
+			d, ery := swag.BytesToYAMLDoc(b)
+			if ery != nil {
+				return ery
+			}
+			b, err = yaml.Marshal(d)
+		}
 	}
 	if err != nil {
 		return err
diff --git a/cmd/swagger/commands/expand_test.go b/cmd/swagger/commands/expand_test.go
new file mode 100644
index 00000000..94da6130
--- /dev/null
+++ b/cmd/swagger/commands/expand_test.go
@@ -0,0 +1,32 @@
+package commands
+
+import (
+	"os"
+	"path/filepath"
+	"testing"
+
+	flags "github.com/jessevdk/go-flags"
+)
+
+// Commands requires at least one arg
+func TestCmd_Expand(t *testing.T) {
+	v := &ExpandSpec{}
+	testRequireParam(t, v)
+}
+
+func TestCmd_Expand_NoError(t *testing.T) {
+	specDoc := filepath.Join(fixtureBase, "bugs", "1536", "fixture-1536.yaml")
+	outDir, output := getOutput(t, specDoc, "flatten", "fixture-1536-flat-expand.json")
+	defer os.RemoveAll(outDir)
+	v := &ExpandSpec{
+		Format:  "json",
+		Compact: false,
+		Output:  flags.Filename(output),
+	}
+	testProduceOutput(t, v, specDoc, output)
+}
+
+func TestCmd_Expand_Error(t *testing.T) {
+	v := &ExpandSpec{}
+	testValidRefs(t, v)
+}
diff --git a/cmd/swagger/commands/flatten.go b/cmd/swagger/commands/flatten.go
index 84eb9552..4ee39e2d 100644
--- a/cmd/swagger/commands/flatten.go
+++ b/cmd/swagger/commands/flatten.go
@@ -2,19 +2,21 @@ package commands
 
 import (
 	"errors"
-	"log"
 
 	"github.com/go-openapi/analysis"
 	"github.com/go-openapi/loads"
+	"github.com/go-swagger/go-swagger/cmd/swagger/commands/generate"
 	flags "github.com/jessevdk/go-flags"
 )
 
 // FlattenSpec is a command that flattens a swagger document
-// Which will expand the remote references in a spec and move inline schemas to definitions
+// which will expand the remote references in a spec and move inline schemas to definitions
 // after flattening there are no complex inlined anymore
 type FlattenSpec struct {
-	Compact bool           `long:"compact" description:"when present, doesn't prettify the json"`
+	Compact bool           `long:"compact" description:"applies to JSON formated specs. When present, doesn't prettify the json"`
 	Output  flags.Filename `long:"output" short:"o" description:"the file to write to"`
+	Format  string         `long:"format" description:"the format for the spec document" default:"json" choice:"yaml" choice:"json"`
+	generate.FlattenCmdOptions
 }
 
 // Execute expands the spec
@@ -26,15 +28,21 @@ func (c *FlattenSpec) Execute(args []string) error {
 	swaggerDoc := args[0]
 	specDoc, err := loads.Spec(swaggerDoc)
 	if err != nil {
-		log.Fatalln(err)
+		return err
 	}
 
-	if er := analysis.Flatten(analysis.FlattenOpts{
-		BasePath: specDoc.SpecFilePath(),
-		Spec:     analysis.New(specDoc.Spec()),
-	}); er != nil {
-		log.Fatalln(er)
+	flattenOpts := c.FlattenCmdOptions.SetFlattenOptions(&analysis.FlattenOpts{
+		// defaults
+		Minimal:      true,
+		Verbose:      true,
+		Expand:       false,
+		RemoveUnused: false,
+	})
+	flattenOpts.BasePath = specDoc.SpecFilePath()
+	flattenOpts.Spec = analysis.New(specDoc.Spec())
+	if err := analysis.Flatten(*flattenOpts); err != nil {
+		return err
 	}
 
-	return writeToFile(specDoc.Spec(), !c.Compact, string(c.Output))
+	return writeToFile(specDoc.Spec(), !c.Compact, c.Format, string(c.Output))
 }
diff --git a/cmd/swagger/commands/flatten_test.go b/cmd/swagger/commands/flatten_test.go
new file mode 100644
index 00000000..3f2ba931
--- /dev/null
+++ b/cmd/swagger/commands/flatten_test.go
@@ -0,0 +1,77 @@
+package commands
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"testing"
+
+	flags "github.com/jessevdk/go-flags"
+	"github.com/stretchr/testify/assert"
+)
+
+type executable interface {
+	Execute([]string) error
+}
+
+func testValidRefs(t *testing.T, v executable) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	specDoc := filepath.Join(fixtureBase, "expansion", "invalid-refs.json")
+	result := v.Execute([]string{specDoc})
+	assert.Error(t, result)
+}
+
+func testRequireParam(t *testing.T, v executable) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	result := v.Execute([]string{})
+	assert.Error(t, result)
+
+	result = v.Execute([]string{"nowhere.json"})
+	assert.Error(t, result)
+}
+
+func getOutput(t *testing.T, specDoc, prefix, filename string) (string, string) {
+	outDir, err := ioutil.TempDir(filepath.Dir(specDoc), "flatten")
+	if !assert.NoError(t, err) {
+		t.FailNow()
+	}
+	return outDir, filepath.Join(outDir, filename)
+}
+
+func testProduceOutput(t *testing.T, v executable, specDoc, output string) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	result := v.Execute([]string{specDoc})
+	assert.NoError(t, result)
+	_, exists := os.Stat(output)
+	assert.True(t, !os.IsNotExist(exists))
+}
+
+// Commands requires at least one arg
+func TestCmd_Flatten(t *testing.T) {
+	v := &FlattenSpec{}
+	testRequireParam(t, v)
+}
+
+func TestCmd_Flatten_Default(t *testing.T) {
+	specDoc := filepath.Join(fixtureBase, "bugs", "1536", "fixture-1536.yaml")
+	outDir, output := getOutput(t, specDoc, "flatten", "fixture-1536-flat-minimal.json")
+	defer os.RemoveAll(outDir)
+	v := &FlattenSpec{
+		Format:  "json",
+		Compact: true,
+		Output:  flags.Filename(output),
+	}
+	testProduceOutput(t, v, specDoc, output)
+}
+
+func TestCmd_Flatten_Error(t *testing.T) {
+	v := &FlattenSpec{}
+	testValidRefs(t, v)
+}
diff --git a/cmd/swagger/commands/generate/client.go b/cmd/swagger/commands/generate/client.go
index 1e11b331..4105b36f 100644
--- a/cmd/swagger/commands/generate/client.go
+++ b/cmd/swagger/commands/generate/client.go
@@ -15,7 +15,6 @@
 package generate
 
 import (
-	"io/ioutil"
 	"log"
 
 	"github.com/go-swagger/go-swagger/generator"
@@ -35,23 +34,9 @@ type Client struct {
 	SkipOperations  bool     `long:"skip-operations" description:"no operations will be generated when this flag is specified"`
 	DumpData        bool     `long:"dump-data" description:"when present dumps the json for the template generator instead of generating files"`
 	SkipValidation  bool     `long:"skip-validation" description:"skips validation of spec prior to generation"`
-	SkipFlattening  bool     `long:"skip-flatten" description:"skips flattening of spec prior to generation"`
 }
 
 func (c *Client) getOpts() (*generator.GenOpts, error) {
-	var copyrightstr string
-	copyrightfile := string(c.CopyrightFile)
-	if copyrightfile != "" {
-		//Read the Copyright from file path in opts
-		bytebuffer, err := ioutil.ReadFile(copyrightfile)
-		if err != nil {
-			return nil, err
-		}
-		copyrightstr = string(bytebuffer)
-	} else {
-		copyrightstr = ""
-	}
-
 	return &generator.GenOpts{
 		Spec: string(c.Spec),
 
@@ -69,17 +54,19 @@ func (c *Client) getOpts() (*generator.GenOpts, error) {
 		IncludeParameters: !c.SkipOperations,
 		IncludeResponses:  !c.SkipOperations,
 		ValidateSpec:      !c.SkipValidation,
-		FlattenSpec:       !c.SkipFlattening,
 		Tags:              c.Tags,
 		IncludeSupport:    true,
 		TemplateDir:       string(c.TemplateDir),
 		DumpData:          c.DumpData,
 		ExistingModels:    c.ExistingModels,
-		Copyright:         copyrightstr,
 		IsClient:          true,
 	}, nil
 }
 
+func (c *Client) getShared() *shared {
+	return &c.shared
+}
+
 func (c *Client) generate(opts *generator.GenOpts) error {
 	return generator.GenerateClient(c.Name, c.Models, c.Operations, opts)
 }
diff --git a/cmd/swagger/commands/generate/client_test.go b/cmd/swagger/commands/generate/client_test.go
new file mode 100644
index 00000000..3cd87db6
--- /dev/null
+++ b/cmd/swagger/commands/generate/client_test.go
@@ -0,0 +1,59 @@
+package generate_test
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+
+	"github.com/go-swagger/go-swagger/cmd/swagger/commands/generate"
+	flags "github.com/jessevdk/go-flags"
+)
+
+func TestGenerateClient(t *testing.T) {
+	specs := []string{
+		"tasklist.basic.yml",
+		"todolist.simplequery.yml",
+	}
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	base := filepath.FromSlash("../../../../")
+	for i, spec := range specs {
+		_ = t.Run(spec, func(t *testing.T) {
+			path := filepath.Join(base, "fixtures/codegen", spec)
+			generated, err := ioutil.TempDir(filepath.Dir(path), "generated")
+			if err != nil {
+				t.Fatalf("TempDir()=%s", generated)
+			}
+			defer func() {
+				_ = os.RemoveAll(generated)
+			}()
+			m := &generate.Client{}
+			_, _ = flags.Parse(m)
+			if i == 0 {
+				m.CopyrightFile = flags.Filename(filepath.Join(base, "LICENSE"))
+			}
+			m.Spec = flags.Filename(path)
+			m.Target = flags.Filename(generated)
+
+			if err := m.Execute([]string{}); err != nil {
+				t.Error(err)
+			}
+		})
+	}
+}
+
+func TestGenerateClient_Check(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	m := &generate.Client{}
+	_, _ = flags.Parse(m)
+	m.CopyrightFile = "nullePart"
+	err := m.Execute([]string{})
+	assert.Error(t, err)
+}
diff --git a/cmd/swagger/commands/generate/model.go b/cmd/swagger/commands/generate/model.go
index 101ee988..2e14d43a 100644
--- a/cmd/swagger/commands/generate/model.go
+++ b/cmd/swagger/commands/generate/model.go
@@ -25,7 +25,6 @@ type Model struct {
 	Name           []string `long:"name" short:"n" description:"the model to generate"`
 	NoStruct       bool     `long:"skip-struct" description:"when present will not generate the model struct"`
 	DumpData       bool     `long:"dump-data" description:"when present dumps the json for the template generator instead of generating files"`
-	SkipFlattening bool     `long:"skip-flatten" description:"skips flattening of spec prior to generation"`
 	SkipValidation bool     `long:"skip-validation" description:"skips validation of spec prior to generation"`
 }
 
@@ -37,7 +36,7 @@ func (m *Model) Execute(args []string) error {
 	}
 
 	if m.ExistingModels != "" {
-		log.Println("Warning: Ignoring existing-models flag when generating models.")
+		log.Println("warning: Ignoring existing-models flag when generating models.")
 	}
 	s := &Server{
 		shared:         m.shared,
@@ -48,7 +47,6 @@ func (m *Model) Execute(args []string) error {
 		SkipSupport:    true,
 		SkipOperations: true,
 		SkipModels:     m.NoStruct,
-		SkipFlattening: m.SkipFlattening,
 		SkipValidation: m.SkipValidation,
 	}
 	return s.Execute(args)
diff --git a/cmd/swagger/commands/generate/model_test.go b/cmd/swagger/commands/generate/model_test.go
index 4748d9f0..434879b0 100644
--- a/cmd/swagger/commands/generate/model_test.go
+++ b/cmd/swagger/commands/generate/model_test.go
@@ -9,6 +9,7 @@ import (
 
 	"github.com/go-swagger/go-swagger/cmd/swagger/commands/generate"
 	flags "github.com/jessevdk/go-flags"
+	"github.com/stretchr/testify/assert"
 )
 
 func TestGenerateModel(t *testing.T) {
@@ -27,16 +28,21 @@ func TestGenerateModel(t *testing.T) {
 	defer log.SetOutput(os.Stdout)
 
 	base := filepath.FromSlash("../../../../")
-	for _, spec := range specs {
+	for i, spec := range specs {
 		_ = t.Run(spec, func(t *testing.T) {
 			path := filepath.Join(base, "fixtures/codegen", spec)
 			generated, err := ioutil.TempDir(filepath.Dir(path), "generated")
 			if err != nil {
 				t.Fatalf("TempDir()=%s", generated)
 			}
-			defer os.RemoveAll(generated)
+			defer func() {
+				_ = os.RemoveAll(generated)
+			}()
 			m := &generate.Model{}
-			flags.Parse(m)
+			_, _ = flags.Parse(m)
+			if i == 0 {
+				m.ExistingModels = "nonExisting"
+			}
 			m.Spec = flags.Filename(path)
 			m.Target = flags.Filename(generated)
 
@@ -46,3 +52,15 @@ func TestGenerateModel(t *testing.T) {
 		})
 	}
 }
+
+func TestGenerateModel_Check(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	m := &generate.Model{}
+	_, _ = flags.Parse(m)
+	m.DumpData = true
+	m.Name = []string{"model1", "model2"}
+	err := m.Execute([]string{})
+	assert.Error(t, err)
+}
diff --git a/cmd/swagger/commands/generate/operation.go b/cmd/swagger/commands/generate/operation.go
index 0df91b58..dc1f2c25 100644
--- a/cmd/swagger/commands/generate/operation.go
+++ b/cmd/swagger/commands/generate/operation.go
@@ -33,7 +33,6 @@ type Operation struct {
 	NoResponses    bool     `long:"skip-responses" description:"when present will not generate the response model struct"`
 	NoURLBuilder   bool     `long:"skip-url-builder" description:"when present will not generate a URL builder"`
 	DumpData       bool     `long:"dump-data" description:"when present dumps the json for the template generator instead of generating files"`
-	SkipFlattening bool     `long:"skip-flatten" description:"skips flattening of spec prior to generation"`
 	SkipValidation bool     `long:"skip-validation" description:"skips validation of spec prior to generation"`
 }
 
@@ -54,11 +53,14 @@ func (o *Operation) getOpts() (*generator.GenOpts, error) {
 		IncludeParameters: !o.NoStruct,
 		IncludeURLBuilder: !o.NoURLBuilder,
 		Tags:              o.Tags,
-		FlattenSpec:       !o.SkipFlattening,
 		ValidateSpec:      !o.SkipValidation,
 	}, nil
 }
 
+func (o *Operation) getShared() *shared {
+	return &o.shared
+}
+
 func (o *Operation) generate(opts *generator.GenOpts) error {
 	return generator.GenerateServerOperation(o.Name, opts)
 }
diff --git a/cmd/swagger/commands/generate/operation_test.go b/cmd/swagger/commands/generate/operation_test.go
new file mode 100644
index 00000000..71fc12d5
--- /dev/null
+++ b/cmd/swagger/commands/generate/operation_test.go
@@ -0,0 +1,59 @@
+package generate_test
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+
+	"github.com/go-swagger/go-swagger/cmd/swagger/commands/generate"
+	flags "github.com/jessevdk/go-flags"
+)
+
+func TestGenerateOperation(t *testing.T) {
+	specs := []string{
+		"tasklist.basic.yml",
+	}
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	base := filepath.FromSlash("../../../../")
+	for i, spec := range specs {
+		_ = t.Run(spec, func(t *testing.T) {
+			path := filepath.Join(base, "fixtures/codegen", spec)
+			generated, err := ioutil.TempDir(filepath.Dir(path), "generated")
+			if err != nil {
+				t.Fatalf("TempDir()=%s", generated)
+			}
+			defer func() {
+				_ = os.RemoveAll(generated)
+			}()
+			m := &generate.Operation{}
+			if i == 0 {
+				m.CopyrightFile = flags.Filename(filepath.Join(base, "LICENSE"))
+			}
+			_, _ = flags.ParseArgs(m, []string{"--name=listTasks"})
+			m.Spec = flags.Filename(path)
+			m.Target = flags.Filename(generated)
+
+			if err := m.Execute([]string{}); err != nil {
+				t.Error(err)
+			}
+		})
+	}
+}
+
+func TestGenerateOperation_Check(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	m := &generate.Operation{}
+	_, _ = flags.ParseArgs(m, []string{"--name=op1", "--name=op2"})
+	m.DumpData = true
+	m.Name = []string{"op1", "op2"}
+	err := m.Execute([]string{})
+	assert.Error(t, err)
+}
diff --git a/cmd/swagger/commands/generate/server.go b/cmd/swagger/commands/generate/server.go
index e352afb4..8af3375b 100644
--- a/cmd/swagger/commands/generate/server.go
+++ b/cmd/swagger/commands/generate/server.go
@@ -15,7 +15,6 @@
 package generate
 
 import (
-	"io/ioutil"
 	"log"
 	"strings"
 
@@ -41,23 +40,9 @@ type Server struct {
 	FlagStrategy      string   `long:"flag-strategy" description:"the strategy to provide flags for the server" default:"go-flags" choice:"go-flags" choice:"pflag"`
 	CompatibilityMode string   `long:"compatibility-mode" description:"the compatibility mode for the tls server" default:"modern" choice:"modern" choice:"intermediate"`
 	SkipValidation    bool     `long:"skip-validation" description:"skips validation of spec prior to generation"`
-	SkipFlattening    bool     `long:"skip-flatten" description:"skips flattening of spec prior to generation"`
 }
 
 func (s *Server) getOpts() (*generator.GenOpts, error) {
-	var copyrightstr string
-	copyrightfile := string(s.CopyrightFile)
-	if copyrightfile != "" {
-		//Read the Copyright from file path in opts
-		bytebuffer, err := ioutil.ReadFile(copyrightfile)
-		if err != nil {
-			return nil, err
-		}
-		copyrightstr = string(bytebuffer)
-	} else {
-		copyrightstr = ""
-	}
-
 	return &generator.GenOpts{
 		Spec:              string(s.Spec),
 		Target:            string(s.Target),
@@ -76,7 +61,6 @@ func (s *Server) getOpts() (*generator.GenOpts, error) {
 		IncludeMain:       !s.ExcludeMain,
 		IncludeSupport:    !s.SkipSupport,
 		ValidateSpec:      !s.SkipValidation,
-		FlattenSpec:       !s.SkipFlattening,
 		ExcludeSpec:       s.ExcludeSpec,
 		TemplateDir:       string(s.TemplateDir),
 		WithContext:       s.WithContext,
@@ -88,18 +72,23 @@ func (s *Server) getOpts() (*generator.GenOpts, error) {
 		FlagStrategy:      s.FlagStrategy,
 		CompatibilityMode: s.CompatibilityMode,
 		ExistingModels:    s.ExistingModels,
-		Copyright:         copyrightstr,
 	}, nil
 }
 
+func (s *Server) getShared() *shared {
+	return &s.shared
+}
+
 func (s *Server) generate(opts *generator.GenOpts) error {
 	return generator.GenerateServer(s.Name, s.Models, s.Operations, opts)
 }
 
 func (s *Server) log(rp string) {
-	flagsPackage := "github.com/jessevdk/go-flags"
+	var flagsPackage string
 	if strings.HasPrefix(s.FlagStrategy, "pflag") {
 		flagsPackage = "github.com/spf13/pflag"
+	} else {
+		flagsPackage = "github.com/jessevdk/go-flags"
 	}
 
 	log.Printf(`Generation completed!
diff --git a/cmd/swagger/commands/generate/server_test.go b/cmd/swagger/commands/generate/server_test.go
new file mode 100644
index 00000000..4e14d83b
--- /dev/null
+++ b/cmd/swagger/commands/generate/server_test.go
@@ -0,0 +1,62 @@
+package generate_test
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+
+	"github.com/go-swagger/go-swagger/cmd/swagger/commands/generate"
+	flags "github.com/jessevdk/go-flags"
+)
+
+func TestGenerateServer(t *testing.T) {
+	specs := []string{
+		"billforward.discriminators.yml",
+		"todolist.simplequery.yml",
+	}
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	base := filepath.FromSlash("../../../../")
+	for i, spec := range specs {
+		_ = t.Run(spec, func(t *testing.T) {
+			path := filepath.Join(base, "fixtures/codegen", spec)
+			generated, err := ioutil.TempDir(filepath.Dir(path), "generated")
+			if err != nil {
+				t.Fatalf("TempDir()=%s", generated)
+			}
+			defer func() {
+				_ = os.RemoveAll(generated)
+			}()
+			m := &generate.Server{}
+			_, _ = flags.Parse(m)
+			if i == 0 {
+				m.CopyrightFile = flags.Filename(filepath.Join(base, "LICENSE"))
+			}
+			if i == 1 {
+				m.FlagStrategy = "pflag"
+			}
+			m.Spec = flags.Filename(path)
+			m.Target = flags.Filename(generated)
+
+			if err := m.Execute([]string{}); err != nil {
+				t.Error(err)
+			}
+		})
+	}
+}
+
+func TestGenerateServer_Checks(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	m := &generate.Server{}
+	_, _ = flags.Parse(m)
+	m.CopyrightFile = "nowhere"
+	err := m.Execute([]string{})
+	assert.Error(t, err)
+}
diff --git a/cmd/swagger/commands/generate/shared.go b/cmd/swagger/commands/generate/shared.go
index 4cadbd00..efd3ec8d 100644
--- a/cmd/swagger/commands/generate/shared.go
+++ b/cmd/swagger/commands/generate/shared.go
@@ -1,16 +1,73 @@
 package generate
 
 import (
+	"io/ioutil"
 	"log"
 	"os"
 	"path/filepath"
 
+	"github.com/go-openapi/analysis"
 	"github.com/go-openapi/swag"
 	"github.com/go-swagger/go-swagger/generator"
 	flags "github.com/jessevdk/go-flags"
 	"github.com/spf13/viper"
 )
 
+// FlattenCmdOptions determines options to the flatten spec preprocessing
+type FlattenCmdOptions struct {
+	WithExpand  bool     `long:"with-expand" description:"expands all $ref's in spec prior to generation (shorthand to --with-flatten=expand)"`
+	WithFlatten []string `long:"with-flatten" description:"flattens all $ref's in spec prior to generation" choice:"minimal" choice:"full" choice:"expand" choice:"verbose" choice:"noverbose" choice:"remove-unused" default:"minimal" default:"verbose"`
+}
+
+// SetFlattenOptions builds flatten options from command line args
+func (f *FlattenCmdOptions) SetFlattenOptions(dflt *analysis.FlattenOpts) (res *analysis.FlattenOpts) {
+	res = &analysis.FlattenOpts{}
+	if dflt != nil {
+		*res = *dflt
+	}
+	if f == nil {
+		return
+	}
+	verboseIsSet := false
+	minimalIsSet := false
+	//removeUnusedIsSet := false
+	expandIsSet := false
+	if f.WithExpand {
+		res.Expand = true
+		expandIsSet = true
+	}
+	for _, opt := range f.WithFlatten {
+		if opt == "verbose" {
+			res.Verbose = true
+			verboseIsSet = true
+		}
+		if opt == "noverbose" && !verboseIsSet {
+			// verbose flag takes precedence
+			res.Verbose = false
+			verboseIsSet = true
+		}
+		if opt == "remove-unused" {
+			res.RemoveUnused = true
+			//removeUnusedIsSet = true
+		}
+		if opt == "expand" {
+			res.Expand = true
+			expandIsSet = true
+		}
+		if opt == "full" && !minimalIsSet && !expandIsSet {
+			// minimal flag takes precedence
+			res.Minimal = false
+			minimalIsSet = true
+		}
+		if opt == "minimal" && !expandIsSet {
+			// expand flag takes precedence
+			res.Minimal = true
+			minimalIsSet = true
+		}
+	}
+	return
+}
+
 type shared struct {
 	Spec                  flags.Filename `long:"spec" short:"f" description:"the spec file to use (default swagger.{json,yml,yaml})"`
 	APIPackage            string         `long:"api-package" short:"a" description:"the package to save the operations" default:"operations"`
@@ -23,11 +80,12 @@ type shared struct {
 	CopyrightFile         flags.Filename `long:"copyright-file" short:"r" description:"copyright file used to add copyright header"`
 	ExistingModels        string         `long:"existing-models" description:"use pre-generated models e.g. github.com/foobar/model"`
 	AdditionalInitialisms []string       `long:"additional-initialism" description:"consecutive capitals that should be considered intialisms"`
-	genOpts               *generator.GenOpts
+	FlattenCmdOptions
 }
 
 type sharedCommand interface {
 	getOpts() (*generator.GenOpts, error)
+	getShared() *shared
 	getConfigFile() flags.Filename
 	getAdditionalInitialisms() []string
 	generate(*generator.GenOpts) error
@@ -42,16 +100,32 @@ func (s *shared) getAdditionalInitialisms() []string {
 	return s.AdditionalInitialisms
 }
 
+func (s *shared) setCopyright() (string, error) {
+	var copyrightstr string
+	copyrightfile := string(s.CopyrightFile)
+	if copyrightfile != "" {
+		//Read the Copyright from file path in opts
+		bytebuffer, err := ioutil.ReadFile(copyrightfile)
+		if err != nil {
+			return "", err
+		}
+		copyrightstr = string(bytebuffer)
+	} else {
+		copyrightstr = ""
+	}
+	return copyrightstr, nil
+}
+
 func createSwagger(s sharedCommand) error {
-	cfg, err := readConfig(string(s.getConfigFile()))
-	if err != nil {
-		return err
+	cfg, erc := readConfig(string(s.getConfigFile()))
+	if erc != nil {
+		return erc
 	}
 	setDebug(cfg)
 
-	opts, err := s.getOpts()
-	if err != nil {
-		return err
+	opts, ero := s.getOpts()
+	if ero != nil {
+		return ero
 	}
 
 	if err := opts.EnsureDefaults(); err != nil {
@@ -64,13 +138,24 @@ func createSwagger(s sharedCommand) error {
 
 	swag.AddInitialisms(s.getAdditionalInitialisms()...)
 
+	if sharedOpts := s.getShared(); sharedOpts != nil {
+		// process shared options
+		opts.FlattenOpts = sharedOpts.FlattenCmdOptions.SetFlattenOptions(opts.FlattenOpts)
+
+		copyrightStr, erc := sharedOpts.setCopyright()
+		if erc != nil {
+			return erc
+		}
+		opts.Copyright = copyrightStr
+	}
+
 	if err := s.generate(opts); err != nil {
 		return err
 	}
 
-	basepath, err := filepath.Abs(".")
-	if err != nil {
-		return err
+	basepath, era := filepath.Abs(".")
+	if era != nil {
+		return era
 	}
 
 	targetAbs, err := filepath.Abs(opts.Target)
@@ -94,7 +179,7 @@ func readConfig(filename string) (*viper.Viper, error) {
 
 	abspath, err := filepath.Abs(filename)
 	if err != nil {
-		log.Fatalln(err)
+		return nil, err
 	}
 	log.Println("trying to read config from", abspath)
 	return generator.ReadConfig(abspath)
diff --git a/cmd/swagger/commands/generate/shared_test.go b/cmd/swagger/commands/generate/shared_test.go
new file mode 100644
index 00000000..320dda97
--- /dev/null
+++ b/cmd/swagger/commands/generate/shared_test.go
@@ -0,0 +1,120 @@
+package generate
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+	"testing"
+
+	"github.com/go-openapi/analysis"
+	"github.com/stretchr/testify/assert"
+)
+
+func resetDefaultOpts() *analysis.FlattenOpts {
+	return &analysis.FlattenOpts{
+		Verbose:      true,
+		Minimal:      true,
+		Expand:       false,
+		RemoveUnused: false,
+	}
+}
+
+func Test_Shared_SetFlattenOptions(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	// testing multiple options settings for flatten:
+	// - verbose | noverbose
+	// - remove-unused
+	// - expand
+	// - minimal
+
+	var fixt *FlattenCmdOptions
+
+	res := fixt.SetFlattenOptions(nil)
+	assert.NotNil(t, res)
+
+	defaultOpts := resetDefaultOpts()
+
+	res = fixt.SetFlattenOptions(defaultOpts)
+	if !assert.NotNil(t, res) {
+		t.FailNow()
+		return
+	}
+	assert.Equal(t, *defaultOpts, *res)
+
+	fixt = &FlattenCmdOptions{
+		WithExpand:  false,
+		WithFlatten: []string{"noverbose"},
+	}
+	res = fixt.SetFlattenOptions(defaultOpts)
+	assert.Equal(t, analysis.FlattenOpts{
+		Verbose:      false,
+		Minimal:      true,
+		Expand:       false,
+		RemoveUnused: false,
+	}, *res)
+
+	fixt = &FlattenCmdOptions{
+		WithExpand:  false,
+		WithFlatten: []string{"noverbose", "full"},
+	}
+	res = fixt.SetFlattenOptions(defaultOpts)
+	assert.Equal(t, analysis.FlattenOpts{
+		Verbose:      false,
+		Minimal:      false,
+		Expand:       false,
+		RemoveUnused: false,
+	}, *res)
+
+	fixt = &FlattenCmdOptions{
+		WithExpand:  false,
+		WithFlatten: []string{"verbose", "noverbose", "full"},
+	}
+	res = fixt.SetFlattenOptions(defaultOpts)
+	assert.Equal(t, analysis.FlattenOpts{
+		Verbose:      true,
+		Minimal:      false,
+		Expand:       false,
+		RemoveUnused: false,
+	}, *res)
+
+	fixt = &FlattenCmdOptions{
+		WithExpand:  false,
+		WithFlatten: []string{"verbose", "noverbose", "full", "expand", "remove-unused"},
+	}
+	res = fixt.SetFlattenOptions(defaultOpts)
+	assert.Equal(t, analysis.FlattenOpts{
+		Verbose:      true,
+		Minimal:      false,
+		Expand:       true,
+		RemoveUnused: true,
+	}, *res)
+
+	fixt = &FlattenCmdOptions{
+		WithExpand:  false,
+		WithFlatten: []string{"minimal", "verbose", "noverbose", "full"},
+	}
+	res = fixt.SetFlattenOptions(defaultOpts)
+	assert.Equal(t, analysis.FlattenOpts{
+		Verbose:      true,
+		Minimal:      true,
+		Expand:       false,
+		RemoveUnused: false,
+	}, *res)
+
+	fixt = &FlattenCmdOptions{
+		WithExpand:  true,
+		WithFlatten: []string{"minimal", "noverbose", "full"},
+	}
+	res = fixt.SetFlattenOptions(defaultOpts)
+	assert.Equal(t, analysis.FlattenOpts{
+		Verbose:      false,
+		Minimal:      true,
+		Expand:       true,
+		RemoveUnused: false,
+	}, *res)
+}
+
+func Test_Shared_ReadConfig(t *testing.T) {
+}
diff --git a/cmd/swagger/commands/generate/support.go b/cmd/swagger/commands/generate/support.go
index f52a95a6..6a0443dd 100644
--- a/cmd/swagger/commands/generate/support.go
+++ b/cmd/swagger/commands/generate/support.go
@@ -46,6 +46,10 @@ func (s *Support) getOpts() (*generator.GenOpts, error) {
 	}, nil
 }
 
+func (s *Support) getShared() *shared {
+	return &s.shared
+}
+
 func (s *Support) generate(opts *generator.GenOpts) error {
 	return generator.GenerateSupport(s.Name, nil, nil, opts)
 }
@@ -57,8 +61,8 @@ func (s *Support) log(rp string) {
 For this generation to compile you need to have some packages in your vendor or GOPATH:
 
   * github.com/go-openapi/runtime
-  * github.com/asaskevich/govalidator		
-  * github.com/jessevdk/go-flags		
+  * github.com/asaskevich/govalidator
+  * github.com/jessevdk/go-flags
   * golang.org/x/net/context/ctxhttp
 
 You can get these now with: go get -u -f %s/...
diff --git a/cmd/swagger/commands/generate/support_test.go b/cmd/swagger/commands/generate/support_test.go
new file mode 100644
index 00000000..f5f57156
--- /dev/null
+++ b/cmd/swagger/commands/generate/support_test.go
@@ -0,0 +1,45 @@
+package generate_test
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/go-swagger/go-swagger/cmd/swagger/commands/generate"
+	flags "github.com/jessevdk/go-flags"
+)
+
+func TestGenerateSupport(t *testing.T) {
+	specs := []string{
+		"tasklist.basic.yml",
+	}
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	base := filepath.FromSlash("../../../../")
+	for i, spec := range specs {
+		_ = t.Run(spec, func(t *testing.T) {
+			path := filepath.Join(base, "fixtures/codegen", spec)
+			generated, err := ioutil.TempDir(filepath.Dir(path), "generated")
+			if err != nil {
+				t.Fatalf("TempDir()=%s", generated)
+			}
+			defer func() {
+				_ = os.RemoveAll(generated)
+			}()
+			m := &generate.Support{}
+			if i == 0 {
+				m.CopyrightFile = flags.Filename(filepath.Join(base, "LICENSE"))
+			}
+			_, _ = flags.Parse(m)
+			m.Spec = flags.Filename(path)
+			m.Target = flags.Filename(generated)
+
+			if err := m.Execute([]string{}); err != nil {
+				t.Error(err)
+			}
+		})
+	}
+}
diff --git a/cmd/swagger/commands/mixin.go b/cmd/swagger/commands/mixin.go
index 0d9a7308..1b61535d 100644
--- a/cmd/swagger/commands/mixin.go
+++ b/cmd/swagger/commands/mixin.go
@@ -1,7 +1,7 @@
 package commands
 
 import (
-	"encoding/json"
+	"errors"
 	"io"
 	"log"
 	"os"
@@ -9,13 +9,22 @@ import (
 	"github.com/go-openapi/analysis"
 	"github.com/go-openapi/loads"
 	"github.com/go-openapi/spec"
+	flags "github.com/jessevdk/go-flags"
+)
+
+const (
+	// Output messages
+	nothingToDo = "Nothing to do. Need some swagger files to merge.\nUSAGE: swagger mixin [-c <expected#Collisions>] <primary-swagger-file> <mixin-swagger-file>..."
 )
 
 // MixinSpec holds command line flag definitions specific to the mixin
 // command. The flags are defined using struct field tags with the
 // "github.com/jessevdk/go-flags" format.
 type MixinSpec struct {
-	ExpectedCollisionCount uint `short:"c" description:"expected # of rejected mixin paths, defs, etc due to existing key. Non-zero exit if does not match actual."`
+	ExpectedCollisionCount uint           `short:"c" description:"expected # of rejected mixin paths, defs, etc due to existing key. Non-zero exit if does not match actual."`
+	Compact                bool           `long:"compact" description:"applies to JSON formated specs. When present, doesn't prettify the json"`
+	Output                 flags.Filename `long:"output" short:"o" description:"the file to write to"`
+	Format                 string         `long:"format" description:"the format for the spec document" default:"json" choice:"yaml" choice:"json"`
 }
 
 // Execute runs the mixin command which merges Swagger 2.0 specs into
@@ -38,19 +47,19 @@ type MixinSpec struct {
 func (c *MixinSpec) Execute(args []string) error {
 
 	if len(args) < 2 {
-		log.Fatalln("Nothing to do. Need some swagger files to merge.\nUSAGE: swagger mixin [-c <expected#Collisions>] <primary-swagger-file> <mixin-swagger-file>...")
+		return errors.New(nothingToDo)
 	}
 
 	log.Printf("args[0] = %v\n", args[0])
 	log.Printf("args[1:] = %v\n", args[1:])
-	collisions, err := MixinFiles(args[0], args[1:], os.Stdout)
+	collisions, err := c.MixinFiles(args[0], args[1:], os.Stdout)
 
 	for _, warn := range collisions {
 		log.Println(warn)
 	}
 
 	if err != nil {
-		log.Fatalln(err)
+		return err
 	}
 
 	if len(collisions) != int(c.ExpectedCollisionCount) {
@@ -68,9 +77,9 @@ func (c *MixinSpec) Execute(args []string) error {
 // swagger files, adds the mixins to primary, calls
 // FixEmptyResponseDescriptions on the primary, and writes the primary
 // with mixins to the given writer in JSON.  Returns the warning
-// messages for collsions that occured during mixin process and any
+// messages for collisions that occured during mixin process and any
 // error.
-func MixinFiles(primaryFile string, mixinFiles []string, w io.Writer) ([]string, error) {
+func (c *MixinSpec) MixinFiles(primaryFile string, mixinFiles []string, w io.Writer) ([]string, error) {
 
 	primaryDoc, err := loads.Spec(primaryFile)
 	if err != nil {
@@ -90,15 +99,5 @@ func MixinFiles(primaryFile string, mixinFiles []string, w io.Writer) ([]string,
 	collisions := analysis.Mixin(primary, mixins...)
 	analysis.FixEmptyResponseDescriptions(primary)
 
-	bs, err := json.MarshalIndent(primary, "", "  ")
-	if err != nil {
-		return nil, err
-	}
-
-	_, err = w.Write(bs)
-	if err != nil {
-		return nil, err
-	}
-
-	return collisions, nil
+	return collisions, writeToFile(primary, !c.Compact, c.Format, string(c.Output))
 }
diff --git a/cmd/swagger/commands/mixin_test.go b/cmd/swagger/commands/mixin_test.go
new file mode 100644
index 00000000..2bd0c02f
--- /dev/null
+++ b/cmd/swagger/commands/mixin_test.go
@@ -0,0 +1,55 @@
+package commands
+
+import (
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"testing"
+
+	flags "github.com/jessevdk/go-flags"
+	"github.com/stretchr/testify/assert"
+)
+
+var fixtureBase = filepath.FromSlash("../../../fixtures")
+
+// Commands requires at least one arg
+func TestCmd_Mixin(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	v := MixinSpec{}
+	result := v.Execute([]string{})
+	assert.Error(t, result)
+
+	result = v.Execute([]string{"nowhere.json"})
+	assert.Error(t, result)
+
+	result = v.Execute([]string{"nowhere.json", "notThere.json"})
+	assert.Error(t, result)
+
+	specDoc1 := filepath.Join(fixtureBase, "bugs", "1536", "fixture-1536.yaml")
+	result = v.Execute([]string{specDoc1, "notThere.json"})
+	assert.Error(t, result)
+}
+
+func TestCmd_Mixin_NoError(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	specDoc1 := filepath.Join(fixtureBase, "bugs", "1536", "fixture-1536.yaml")
+	specDoc2 := filepath.Join(fixtureBase, "bugs", "1536", "fixture-1536-2.yaml")
+	outDir, err := ioutil.TempDir(filepath.Dir(specDoc1), "mixed")
+	assert.NoError(t, err)
+	defer os.RemoveAll(outDir)
+	v := MixinSpec{
+		ExpectedCollisionCount: 3,
+		Format:                 "yaml",
+		Output:                 flags.Filename(filepath.Join(outDir, "fixture-1536-mixed.yaml")),
+	}
+
+	result := v.Execute([]string{specDoc1, specDoc2})
+	assert.NoError(t, result)
+	_, exists := os.Stat(filepath.Join(outDir, "fixture-1536-mixed.yaml"))
+	assert.True(t, !os.IsNotExist(exists))
+}
diff --git a/cmd/swagger/commands/validate.go b/cmd/swagger/commands/validate.go
index c351225e..2d639d19 100644
--- a/cmd/swagger/commands/validate.go
+++ b/cmd/swagger/commands/validate.go
@@ -50,7 +50,7 @@ func (c *ValidateSpec) Execute(args []string) error {
 
 	specDoc, err := loads.Spec(swaggerDoc)
 	if err != nil {
-		log.Fatalln(err)
+		return err
 	}
 
 	// Attempts to report about all errors
diff --git a/cmd/swagger/commands/validate_test.go b/cmd/swagger/commands/validate_test.go
index 4a0c3f73..1fd162cf 100644
--- a/cmd/swagger/commands/validate_test.go
+++ b/cmd/swagger/commands/validate_test.go
@@ -10,6 +10,18 @@ import (
 	"github.com/stretchr/testify/assert"
 )
 
+// Commands requires at least one arg
+func TestCmd_Validate_MissingArgs(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+	v := ValidateSpec{}
+	result := v.Execute([]string{})
+	assert.Error(t, result)
+
+	result = v.Execute([]string{"nowhere.json"})
+	assert.Error(t, result)
+}
+
 // Test proper validation: items in object error
 func TestCmd_Validate_Issue1238(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
@@ -51,9 +63,7 @@ func TestCmd_Validate_Issue342_ForbiddenProperty(t *testing.T) {
 	assert.Error(t, result)
 }
 
-/*
-TODO: fixture 342-2 (a variant of invalid specification), cannot be tested because it calls log.Fatal()
-
+//fixture 342-2 (a variant of invalid specification) (cannot unmarshal)
 // Test proper validation: reference to shared top level parameter, but with incorrect
 // yaml syntax: use map key instead of array item.
 // NOTE: this error message is not clear enough. The role of this test
@@ -63,17 +73,18 @@ func TestCmd_Validate_Issue342_CannotUnmarshal(t *testing.T) {
 	v := ValidateSpec{}
 	base := filepath.FromSlash("../../../")
 	specDoc := filepath.Join(base, "fixtures", "bugs", "342", "fixture-342-2.yaml")
-	assert.NotPanics(t, func() {
-		v.Execute([]string{specDoc})
-	})
-	// TODO: uncomment the following test when validation no more results in a log.Fatal() call
-	//result := v.Execute([]string{specDoc})
-	//if assert.Error(t, result, "This spec should not pass validation") {
-	//	//assert.Contains(t, result.Error(), "is invalid against swagger specification 2.0")
-	//	assert.Contains(t, result.Error(), "json: cannot unmarshal object into Go struct field SwaggerProps.paths of type []spec.Parameter")
-	//}
+	if !assert.NotPanics(t, func() {
+		_ = v.Execute([]string{specDoc})
+	}) {
+		t.FailNow()
+		return
+	}
+	result := v.Execute([]string{specDoc})
+	if assert.Error(t, result, "This spec should not pass validation") {
+		// assert.Contains(t, result.Error(), "is invalid against swagger specification 2.0")
+		assert.Contains(t, result.Error(), "json: cannot unmarshal object into Go struct field SwaggerProps.paths of type []spec.Parameter")
+	}
 }
-*/
 
 // This one is a correct version of issue#342 and it validates
 func TestCmd_Validate_Issue342_Correct(t *testing.T) {
diff --git a/docs/SUMMARY.md b/docs/SUMMARY.md
index 7376836f..666176b5 100644
--- a/docs/SUMMARY.md
+++ b/docs/SUMMARY.md
@@ -17,6 +17,9 @@
   - [Options and commands](usage/swagger.md)
   - [Serve UI](usage/serve_ui.md)
   - [Validate](usage/validate.md)
+  - [Flatten](usage/flatten.md)
+  - [Expand](usage/expand.md)
+  - [Mixin](usage/mixin.md)
   - Generate
     - [Dependencies & Requirements](generate/requirements.md)
     - [API Client](generate/client.md)
diff --git a/docs/usage/expand.md b/docs/usage/expand.md
new file mode 100644
index 00000000..b66b7742
--- /dev/null
+++ b/docs/usage/expand.md
@@ -0,0 +1,28 @@
+# Expand a swagger spec
+
+The toolkit has a command to expand a swagger specification.
+
+Expanding a specification resolve all $ref (remote or local) and replace them by their expanded
+content in the main spec document.
+
+### Usage
+
+To expand a specification:
+
+```
+Usage:
+  swagger [OPTIONS] expand [expand-OPTIONS]
+
+expands the $refs in a swagger document to inline schemas
+
+Application Options:
+  -q, --quiet                     silence logs
+
+Help Options:
+  -h, --help                      Show this help message
+
+[expand command options]
+          --compact               applies to JSON formated specs. When present, doesn't prettify the json
+      -o, --output=               the file to write to
+          --format=[yaml|json]    the format for the spec document (default: json)
+```
diff --git a/docs/usage/flatten.md b/docs/usage/flatten.md
new file mode 100644
index 00000000..87c988be
--- /dev/null
+++ b/docs/usage/flatten.md
@@ -0,0 +1,37 @@
+# Flatten a swagger spec
+
+The toolkit has a command to flatten a swagger specification.
+
+Flattening a specification bundles all remote $ref in the main spec document.
+
+Depending on flattening options, additional preprocessing may take place:
+
+- full flattening: replacing all inline complex constructs by a named entry in #/definitions
+- expand: replace all $ref's in the document by their expanded content
+
+The default behavior of flatten is to bundles remote refs into definitions and
+normalize JSON pointers to definitions.
+
+### Usage
+
+To flatten a specification:
+
+```
+Usage:
+  swagger [OPTIONS] flatten [flatten-OPTIONS]
+
+expand the remote references in a spec and move inline schemas to definitions, after flattening there are no complex inlined anymore
+
+Application Options:
+  -q, --quiet                                                                     silence logs
+
+Help Options:
+  -h, --help                                                                      Show this help message
+
+[flatten command options]
+          --compact                                                               applies to JSON formated specs. When present, doesn't prettify the json
+      -o, --output=                                                               the file to write to
+          --format=[yaml|json]                                                    the format for the spec document (default: json)
+          --with-expand                                                           expands all $ref's in spec prior to generation (equivalent to --with-flatten=expand)
+          --with-flatten=[minimal|full|expand|verbose|noverbose|remove-unused]    flattens all $ref's in spec prior to generation (default: minimal, verbose)
+```
diff --git a/docs/usage/mixin.md b/docs/usage/mixin.md
new file mode 100644
index 00000000..67d140f2
--- /dev/null
+++ b/docs/usage/mixin.md
@@ -0,0 +1,28 @@
+# Mixin several swagger specs
+
+The toolkit has a command to mixin swagger specification.
+
+Mixin merges several specs into the first (primary) spec given, and issues warnings when conflicts are detected.
+
+### Usage
+
+To mixin several specifications:
+
+```
+Usage:
+  swagger [OPTIONS] mixin [mixin-OPTIONS]
+
+merge additional specs into first/primary spec by copying their paths and definitions
+
+Application Options:
+  -q, --quiet                     silence logs
+
+Help Options:
+  -h, --help                      Show this help message
+
+[mixin command options]
+      -c=                         expected # of rejected mixin paths, defs, etc due to existing key. Non-zero exit if does not match actual.
+          --compact               applies to JSON formated specs. When present, doesn't prettify the json
+      -o, --output=               the file to write to
+          --format=[yaml|json]    the format for the spec document (default: json)
+```
diff --git a/fixtures/bugs/1277/cloudbreak.json b/fixtures/bugs/1277/cloudbreak.json
deleted file mode 100644
index ad2d32e0..00000000
--- a/fixtures/bugs/1277/cloudbreak.json
+++ /dev/null
@@ -1,10693 +0,0 @@
-{
-  "swagger" : "2.0",
-  "info" : {
-    "description" : "Cloudbreak is a powerful left surf that breaks over a coral reef, a mile off southwest the island of Tavarua, Fiji.\nCloudbreak is a cloud agnostic Hadoop as a Service API. Abstracts the provisioning and ease management and monitoring of on-demand clusters.\nSequenceIQ's Cloudbreak is a RESTful application development platform with the goal of helping developers to build solutions for deploying Hadoop YARN clusters in different environments.\nOnce it is deployed in your favourite servlet container it exposes a REST API allowing to span up Hadoop clusters of arbitary sizes and cloud providers. Provisioning Hadoop has never been easier.\nCloudbreak is built on the foundation of cloud providers API (Amazon AWS, Microsoft Azure, Google Cloud Platform, Openstack), Apache Ambari, Docker lightweight containers, Swarm and Consul.\nFor further product documentation follow the link: <a href=\"http://hortonworks.com/apache/cloudbreak/\">http://hortonworks.com/apache/cloudbreak/</a>",
-    "version" : "unspecified",
-    "title" : "Cloudbreak API"
-  },
-  "basePath" : "/api",
-  "tags" : [ {
-    "name" : "v1usages"
-  }, {
-    "name" : "v1constraints"
-  }, {
-    "name" : "v2connectors"
-  }, {
-    "name" : "v1stacks"
-  }, {
-    "name" : "v1topologies"
-  }, {
-    "name" : "cluster"
-  }, {
-    "name" : "v1ldap"
-  }, {
-    "name" : "v1networks"
-  }, {
-    "name" : "v1settings"
-  }, {
-    "name" : "v1clustertemplates"
-  }, {
-    "name" : "v1rdsconfigs"
-  }, {
-    "name" : "v1recipes"
-  }, {
-    "name" : "v1securitygroups"
-  }, {
-    "name" : "v1users"
-  }, {
-    "name" : "v1flexsubscriptions"
-  }, {
-    "name" : "v1events"
-  }, {
-    "name" : "v1util"
-  }, {
-    "name" : "v1blueprints"
-  }, {
-    "name" : "v1imagecatalogs"
-  }, {
-    "name" : "v1templates"
-  }, {
-    "name" : "v2stacks"
-  }, {
-    "name" : "v1smartsensesubscriptions"
-  }, {
-    "name" : "v1credentials"
-  }, {
-    "name" : "v1accountpreferences"
-  }, {
-    "name" : "v1connectors"
-  }, {
-    "name" : "v1subscriptions"
-  } ],
-  "schemes" : [ "http", "https" ],
-  "paths" : {
-    "/v1/accountpreferences" : {
-      "get" : {
-        "tags" : [ "v1accountpreferences" ],
-        "summary" : "retrieve account preferences for admin user",
-        "description" : "Account related preferences that could be managed by the account admins and different restrictions could be added to Cloudbreak resources.",
-        "operationId" : "getAccountPreferencesEndpoint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/AccountPreference"
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1accountpreferences" ],
-        "summary" : "post account preferences of admin user",
-        "description" : "Account related preferences that could be managed by the account admins and different restrictions could be added to Cloudbreak resources.",
-        "operationId" : "postAccountPreferencesEndpoint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/AccountPreference"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/AccountPreference"
-            }
-          }
-        }
-      },
-      "put" : {
-        "tags" : [ "v1accountpreferences" ],
-        "summary" : "update account preferences of admin user",
-        "description" : "Account related preferences that could be managed by the account admins and different restrictions could be added to Cloudbreak resources.",
-        "operationId" : "putAccountPreferencesEndpoint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/AccountPreference"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/AccountPreference"
-            }
-          }
-        }
-      }
-    },
-    "/v1/accountpreferences/isplatformselectiondisabled" : {
-      "get" : {
-        "tags" : [ "v1accountpreferences" ],
-        "summary" : "is platform selection disabled",
-        "description" : "Account related preferences that could be managed by the account admins and different restrictions could be added to Cloudbreak resources.",
-        "operationId" : "isPlatformSelectionDisabled",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "boolean"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/accountpreferences/validate" : {
-      "get" : {
-        "tags" : [ "v1accountpreferences" ],
-        "summary" : "validate account preferences of all stacks",
-        "description" : "Account related preferences that could be managed by the account admins and different restrictions could be added to Cloudbreak resources.",
-        "operationId" : "validateAccountPreferencesEndpoint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/blueprints/account" : {
-      "get" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "retrieve public and private (owned) blueprints",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "getPublicsBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/BlueprintResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "create blueprint as public resource",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "postPublicBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/BlueprintRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/BlueprintResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/blueprints/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "retrieve a public or private (owned) blueprint by name",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "getPublicBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/BlueprintResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "delete public (owned) or private blueprint by name",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "deletePublicBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/blueprints/user" : {
-      "get" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "retrieve private blueprints",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "getPrivatesBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/BlueprintResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "create blueprint as private resource",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "postPrivateBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/BlueprintRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/BlueprintResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/blueprints/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "retrieve a private blueprint by name",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "getPrivateBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/BlueprintResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "delete private blueprint by name",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "deletePrivateBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/blueprints/{id}" : {
-      "get" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "retrieve blueprint by id",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "getBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/BlueprintResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1blueprints" ],
-        "summary" : "delete blueprint by id",
-        "description" : "Ambari Blueprints are a declarative definition of a Hadoop cluster. With a Blueprint, you specify a stack, the component layout and the configurations to materialize a Hadoop cluster instance. Hostgroups defined in blueprints can be associated to different templates, thus you can spin up a highly available cluster running on different instance types. This will give you the option to group your Hadoop services based on resource needs (e.g. high I/O, CPU or memory) and create an infrastructure which fits your workload best.",
-        "operationId" : "deleteBlueprint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/clustertemplates/account" : {
-      "get" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "retrieve public and private (owned) cluster template",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "getPublicsClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/ClusterTemplateResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "create cluster template as public resource",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "postPublicClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/ClusterTemplateRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterTemplateResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/clustertemplates/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "retrieve a public or private (owned) cluster template by name",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "getPublicClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterTemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "delete public (owned) or private cluster template by name",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "deletePublicClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/clustertemplates/user" : {
-      "get" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "retrieve private cluster templates",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "getPrivatesClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/ClusterTemplateResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "create cluster template as private resource",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "postPrivateClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/ClusterTemplateRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterTemplateResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/clustertemplates/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "retrieve a private cluster template by name",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "getPrivateClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterTemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "delete private cluster template by name",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "deletePrivateClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/clustertemplates/{id}" : {
-      "get" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "retrieve cluster template by id",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "getClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterTemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1clustertemplates" ],
-        "summary" : "delete cluster template by id",
-        "description" : "Cluster templates are stored cluster configurations, which configurations are reusable any time",
-        "operationId" : "deleteClusterTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/connectors" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive available platforms",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getPlatforms",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "extended",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "object"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/custom" : {
-      "post" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive special properties",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getSpecialProperties",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "boolean"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/disktypes" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive available disk types",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getDisktypes",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformDisksJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/disktypes/{type}" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive disks by type",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getDisktypeByType",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "type",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "type" : "string"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/gateways" : {
-      "post" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive gateways with properties",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getGatewaysCredentialId",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/PlatformResourceRequestJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformGatewaysResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/ippools" : {
-      "post" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive ip pools with properties",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getIpPoolsCredentialId",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/PlatformResourceRequestJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformIpPoolsResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/networks" : {
-      "post" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive network properties",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getPlatformNetworks",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/PlatformResourceRequestJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "array",
-                "uniqueItems" : true,
-                "items" : {
-                  "$ref" : "#/definitions/PlatformNetworkResponse"
-                }
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/ochestrators" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive available orchestrator types",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getOrchestratortypes",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformOrchestratorsJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/ochestrators/{type}" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive orchestrators by type",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getOchestratorsByType",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "type",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "type" : "string"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/recommendation" : {
-      "post" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "creates a recommendation that advises cloud resources for the given blueprint",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "createRecommendation",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/RecommendationRequestJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RecommendationResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/regions" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive available regions",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getRegions",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformRegionsJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/regions/av/{type}" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive availability zones by type",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getRegionAvByType",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "type",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "array",
-                "items" : {
-                  "type" : "string"
-                }
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/regions/r/{type}" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive regions by type",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getRegionRByType",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "type",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "type" : "string"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/securitygroups" : {
-      "post" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive securitygroups properties",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getPlatformSecurityGroups",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/PlatformResourceRequestJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "array",
-                "uniqueItems" : true,
-                "items" : {
-                  "$ref" : "#/definitions/PlatformSecurityGroupResponse"
-                }
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/sshkeys" : {
-      "post" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive sshkeys properties",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getPlatformSShKeys",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/PlatformResourceRequestJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "array",
-                "uniqueItems" : true,
-                "items" : {
-                  "$ref" : "#/definitions/PlatformSshKeyResponse"
-                }
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/tagspecifications" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive tag specifications",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getTagSpecifications",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/TagSpecificationsJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/variants" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive available platform variants",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getPlatformVariants",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformVariantsJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/variants/{type}" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive a platform variant by type",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getPlatformVariantByType",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "type",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "type" : "string"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/vmtypes" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive available vm types",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getVmTypes",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "extended",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformVirtualMachinesJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/connectors/vmtypes/{type}" : {
-      "get" : {
-        "tags" : [ "v1connectors" ],
-        "summary" : "retrive available vm types",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getVmTypesByType",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "type",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "extended",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformVirtualMachinesJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/constraints/account" : {
-      "get" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "retrieve public and private (owned) constraint templates",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "getPublicsConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/ConstraintTemplateResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "create constraint template as public resource",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "postPublicConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/ConstraintTemplateRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ConstraintTemplateResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/constraints/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "retrieve a public or private (owned) constraint template by name",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "getPublicConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ConstraintTemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "delete public (owned) or private constraint template by name",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "deletePublicConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/constraints/user" : {
-      "get" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "retrieve private constraint templates",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "getPrivatesConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/ConstraintTemplateResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "create constraint template as private resource",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "postPrivateConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/ConstraintTemplateRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ConstraintTemplateResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/constraints/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "retrieve a private constraint template by name",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "getPrivateConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ConstraintTemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "delete private constraint template by name",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "deletePrivateConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/constraints/{id}" : {
-      "get" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "retrieve constraint template by id",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "getConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ConstraintTemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1constraints" ],
-        "summary" : "delete constraint template by id",
-        "description" : "A constraint template tells Cloudbreak the resource constraints (cpu, memory, disk) of the Ambari containers that will be deployed to the cluster. A constraint template must be created onenvironments where there is no one-to-one mapping between containers and nodes, like YARN.",
-        "operationId" : "deleteConstraint",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/credentials/account" : {
-      "get" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "retrieve public and private (owned) credentials",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "getPublicsCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/CredentialResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "create credential as public resource",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "postPublicCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/CredentialRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CredentialResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/credentials/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "retrieve a public or private (owned) credential by name",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "getPublicCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CredentialResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "delete public (owned) or private credential by name",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "deletePublicCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/credentials/accountinteractivelogin" : {
-      "post" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "interactive login",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "publicInteractiveLoginCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/CredentialRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "string"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/credentials/user" : {
-      "get" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "retrieve private credentials",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "getPrivatesCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/CredentialResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "create credential as private resource",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "postPrivateCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/CredentialRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CredentialResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/credentials/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "retrieve a private credential by name",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "getPrivateCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CredentialResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "delete private credential by name",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "deletePrivateCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/credentials/userinteractivelogin" : {
-      "post" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "interactive login",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "privateInteractiveLoginCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/CredentialRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "string"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/credentials/{id}" : {
-      "get" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "retrieve credential by id",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "getCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CredentialResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1credentials" ],
-        "summary" : "delete credential by id",
-        "description" : "Cloudbreak is launching Hadoop clusters on the user's behalf - on different cloud providers. One key point is that Cloudbreak does not store your Cloud provider account details (such as username, password, keys, private SSL certificates, etc). We work around the concept that Identity and Access Management is fully controlled by you - the end user. The Cloudbreak deployer is purely acting on behalf of the end user - without having access to the user's account.",
-        "operationId" : "deleteCredential",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/events" : {
-      "get" : {
-        "tags" : [ "v1events" ],
-        "summary" : "retrieve events by timestamp (long)",
-        "description" : "Events are used to track stack creation initiated by cloudbreak users. Events are generated by the backend when resources requested by the user become available or unavailable",
-        "operationId" : "getEvents",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "since",
-          "in" : "query",
-          "required" : false,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/CloudbreakEvent"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/events/struct/zip/{stackId}" : {
-      "get" : {
-        "tags" : [ "v1events" ],
-        "operationId" : "getStructuredEventsZip",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/octet-stream" ],
-        "parameters" : [ {
-          "name" : "stackId",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/events/struct/{stackId}" : {
-      "get" : {
-        "tags" : [ "v1events" ],
-        "operationId" : "getStructuredEvents",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "stackId",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/StructuredEvent"
-              }
-            },
-            "headers" : { }
-          }
-        }
-      }
-    },
-    "/v1/events/{stackId}" : {
-      "get" : {
-        "tags" : [ "v1events" ],
-        "summary" : "retrieve events by stackid (long)",
-        "description" : "Events are used to track stack creation initiated by cloudbreak users. Events are generated by the backend when resources requested by the user become available or unavailable",
-        "operationId" : "getEventsBySTackId",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "stackId",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/CloudbreakEvent"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/account" : {
-      "get" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "retrieve public and private (owned) Flex subscriptions",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "getPublicFlexSubscriptions",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/FlexSubscriptionResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "create Flex subscription as public resource",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "postPublicFlexSubscription",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/FlexSubscriptionRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/FlexSubscriptionResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/account/setdefault/{name}" : {
-      "put" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "sets the account default flag on the Flex subscription",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "putPublicDefaultFlexSubscriptionByName",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/account/setusedforcontroller/{name}" : {
-      "put" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "sets the account 'used for controller' flag on the Flex subscription",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "putPublicUsedForControllerFlexSubscriptionByName",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "retrieve a public or private (owned) Flex subscription by name",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "getPublicFlexSubscriptionByName",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/FlexSubscriptionResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "delete public (owned) or private Flex subscription by name",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "deletePublicFlexSubscriptionByName",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/setdefault/{id}" : {
-      "put" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "sets the account default flag on the Flex subscription",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "putDefaultFlexSubscriptionById",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/setusedforcontroller/{id}" : {
-      "put" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "sets the account 'used for controller' flag on the Flex subscription",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "putUsedForControllerFlexSubscriptionById",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/user" : {
-      "get" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "retrieve private Flex subscriptions",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "getPrivateFlexSubscriptions",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/FlexSubscriptionResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "create Flex subscription as private resource",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "postPrivateFlexSubscription",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/FlexSubscriptionRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/FlexSubscriptionResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "retrieve a private Flex subscription by name",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "getPrivateFlexSubscriptionByName",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/FlexSubscriptionResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "delete private Flex subscription by name",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "deletePrivateFlexSubscriptionByName",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/flexsubscriptions/{id}" : {
-      "get" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "retrieve Flex subscription by id",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "getFlexSubscriptionById",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/FlexSubscriptionResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1flexsubscriptions" ],
-        "summary" : "delete Flex subscription by id",
-        "description" : "Flex subscriptions could be configured.",
-        "operationId" : "deleteFlexSubscriptionById",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/imagecatalogs/{platform}" : {
-      "get" : {
-        "tags" : [ "v1imagecatalogs" ],
-        "summary" : "determines available images for the Cloudbreak version by the given provider",
-        "description" : "Provides an interface to determine available Virtual Machine images for the given version of Cloudbreak.",
-        "operationId" : "getImagesByProvider",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "platform",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ImagesResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/ldap/account" : {
-      "get" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "retrieve public and private (owned) LDAP configs",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "getPublicsLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/LdapConfigResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "create LDAP config as public resource",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "postPublicLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/LdapConfigRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/LdapConfigResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/ldap/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "retrieve a public or private (owned) LDAP config by name",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "getPublicLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/LdapConfigResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "delete public (owned) or private LDAP config by name",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "deletePublicLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/ldap/user" : {
-      "get" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "retrieve private LDAP configs",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "getPrivatesLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/LdapConfigResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "create LDAP config as private resource",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "postPrivateLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/LdapConfigRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/LdapConfigResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/ldap/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "retrieve a private LDAP config by name",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "getPrivateLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/LdapConfigResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "delete private LDAP config by name",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "deletePrivateLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/ldap/{id}" : {
-      "get" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "retrieve LDAP config by id",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "getLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/LdapConfigResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1ldap" ],
-        "summary" : "delete LDAP config by id",
-        "description" : "LDAP server integration enables the user to provide a central place to store usernames and passwords for the users of his/her clusters.",
-        "operationId" : "deleteLdap",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/networks/account" : {
-      "get" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "retrieve public and private (owned) networks",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "getPublicsNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/NetworkResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "create network as public resource",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "postPublicNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/NetworkRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/NetworkResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/networks/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "retrieve a public or private (owned) network by name",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "getPublicNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/NetworkResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "delete public (owned) or private network by name",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "deletePublicNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/networks/user" : {
-      "get" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "retrieve private networks",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "getPrivatesNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/NetworkResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "create network as private resource",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "postPrivateNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/NetworkRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/NetworkResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/networks/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "retrieve a private network by name",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "getPrivateNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/NetworkResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "delete private network by name",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "deletePrivateNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/networks/{id}" : {
-      "get" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "retrieve network by id",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "getNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/NetworkResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1networks" ],
-        "summary" : "delete network by id",
-        "description" : "Provider specific network settings could be configured by using Network resources.",
-        "operationId" : "deleteNetwork",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/rdsconfigs/account" : {
-      "get" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "retrieve public and private (owned) RDS configurations",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "getPublicsRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/RDSConfigResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "create RDS configuration as public resource",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "postPublicRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/RDSConfig"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RDSConfigResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/rdsconfigs/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "retrieve a public or private (owned) RDS configuration by name",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "getPublicRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RDSConfigResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "delete public (owned) or private RDS configuration by name",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "deletePublicRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/rdsconfigs/user" : {
-      "get" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "retrieve private RDS configurations",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "getPrivatesRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/RDSConfigResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "create RDS configuration as private resource",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "postPrivateRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/RDSConfig"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RDSConfigResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/rdsconfigs/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "retrieve a private RDS configuration by name",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "getPrivateRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RDSConfigResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "delete private RDS configuration by name",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "deletePrivateRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/rdsconfigs/{id}" : {
-      "get" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "retrieve RDS configuration by id",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "getRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RDSConfigResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1rdsconfigs" ],
-        "summary" : "delete RDS configuration by id",
-        "description" : "An RDS Configuration describe a connection to an external Relational Database Service that can be used as the Hive Metastore.",
-        "operationId" : "deleteRds",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/recipes/account" : {
-      "get" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "retrieve public and private (owned) recipes",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "getPublicsRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/RecipeResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "create recipe as public resource",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "postPublicRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/RecipeRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RecipeResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/recipes/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "retrieve a public or private (owned) recipe by name",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "getPublicRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RecipeResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "delete public (owned) or private recipe by name",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "deletePublicRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/recipes/user" : {
-      "get" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "retrieve private recipes",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "getPrivatesRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/RecipeResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "create recipe as private resource",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "postPrivateRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/RecipeRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RecipeResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/recipes/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "retrieve a private recipe by name",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "getPrivateRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RecipeResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "delete private recipe by name",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "deletePrivateRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/recipes/{id}" : {
-      "get" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "retrieve recipe by id",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "getRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RecipeResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1recipes" ],
-        "summary" : "delete recipe by id",
-        "description" : "Recipes are basically script extensions to a cluster that run on a set of nodes before or after the Ambari cluster installation.",
-        "operationId" : "deleteRecipe",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/securitygroups/account" : {
-      "get" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "retrieve public and private (owned) security groups",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "getPublicsSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/SecurityGroupResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "create security group as public resource",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "postPublicSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/SecurityGroupRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SecurityGroupResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/securitygroups/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "retrieve a public or private (owned) security group by name",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "getPublicSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SecurityGroupResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "delete public (owned) or private security group by name",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "deletePublicSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/securitygroups/user" : {
-      "get" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "retrieve private security groups",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "getPrivatesSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/SecurityGroupResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "create security group as private resource",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "postPrivateSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/SecurityGroupRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SecurityGroupResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/securitygroups/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "retrieve a private security group by name",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "getPrivateSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SecurityGroupResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "delete private security group by name",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "deletePrivateSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/securitygroups/{id}" : {
-      "get" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "retrieve security group by id",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "getSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SecurityGroupResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1securitygroups" ],
-        "summary" : "delete security group by id",
-        "description" : "Different inbound security rules(group) could be configured by using SecurityGroup resources and a group could be assigned to any Stack(cluster).",
-        "operationId" : "deleteSecurityGroup",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/settings/all" : {
-      "get" : {
-        "tags" : [ "v1settings" ],
-        "summary" : "retrive all available settings",
-        "description" : "Collecting Cloudbreak specific resource settings.",
-        "operationId" : "getAllSettings",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "object",
-                "additionalProperties" : {
-                  "type" : "object"
-                }
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/settings/database" : {
-      "get" : {
-        "tags" : [ "v1settings" ],
-        "summary" : "retrive available Ambari database settings",
-        "description" : "Collecting Cloudbreak specific resource settings.",
-        "operationId" : "getDatabaseConfigSettings",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "object"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/settings/recipe" : {
-      "get" : {
-        "tags" : [ "v1settings" ],
-        "summary" : "retrive available recipe settings",
-        "description" : "Collecting Cloudbreak specific resource settings.",
-        "operationId" : "getRecipeSettings",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "object"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/smartsensesubscriptions" : {
-      "get" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "retrieve default SmartSense subscription",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "getSmartSenseSubscription",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/smartsensesubscriptions/account" : {
-      "get" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "retrieve public and private (owned) SmartSense subscriptions",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "getPublicSmartSenseSubscriptions",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "create SmartSense subscription as public resource",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "postPublicSmartSenseSubscription",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/smartsensesubscriptions/account/{subscriptionId}" : {
-      "delete" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "delete public (owned) or private SmartSense subscription by subscription ID",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "deletePublicSmartSenseSubscriptionBySubscriptionId",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "subscriptionId",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/smartsensesubscriptions/user" : {
-      "get" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "retrieve private SmartSense subscriptions",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "getPrivateSmartSenseSubscriptions",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "create SmartSense subscription as private resource",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "postPrivateSmartSenseSubscription",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/smartsensesubscriptions/user/{subscriptionId}" : {
-      "delete" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "delete private SmartSense subscription by subscription ID",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "deletePrivateSmartSenseSubscriptionBySubscriptionId",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "subscriptionId",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/smartsensesubscriptions/{id}" : {
-      "get" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "retrieve SmartSense subscription by id",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "getSmartSenseSubscriptionById",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1smartsensesubscriptions" ],
-        "summary" : "delete SmartSense subscription by id",
-        "description" : "SmartSense subscriptions could be configured.",
-        "operationId" : "deleteSmartSenseSubscriptionById",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/account" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve public and private (owned) stacks",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getPublicsStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/StackResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "create stack as public resource",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "postPublicStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/StackRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve a public or private (owned) stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getPublicStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "entry",
-          "in" : "query",
-          "required" : false,
-          "type" : "array",
-          "items" : {
-            "type" : "string"
-          },
-          "collectionFormat" : "multi"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "delete public (owned) or private stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "deletePublicStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "forced",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        }, {
-          "name" : "deleteDependencies",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/account/{name}/cluster" : {
-      "get" : {
-        "tags" : [ "cluster" ],
-        "summary" : "retrieve cluster by stack name (public)",
-        "description" : "Clusters are materialised Hadoop services on a given infrastructure. They are built based on a Blueprint (running the components and services specified) and on a configured infrastructure Stack. Once a cluster is created and launched, it can be used the usual way as any Hadoop cluster. We suggest to start with the Cluster's Ambari UI for an overview of your cluster.",
-        "operationId" : "getPublicCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/all" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve all stacks",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getAllStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/AutoscaleStackResponse"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/ambari" : {
-      "post" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve stack by ambari address",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getStackForAmbari",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/AmbariAddress"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/platformVariants" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve available platform variants",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "variantsStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformVariantsJson"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/user" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve private stack",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getPrivatesStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/StackResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "create stack as private resource",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "postPrivateStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/StackRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve a private stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getPrivateStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "entry",
-          "in" : "query",
-          "required" : false,
-          "type" : "array",
-          "items" : {
-            "type" : "string"
-          },
-          "collectionFormat" : "multi"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "delete private stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "deletePrivateStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "forced",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        }, {
-          "name" : "deleteDependencies",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/user/{name}/cluster" : {
-      "get" : {
-        "tags" : [ "cluster" ],
-        "summary" : "retrieve cluster by stack name (private)",
-        "description" : "Clusters are materialised Hadoop services on a given infrastructure. They are built based on a Blueprint (running the components and services specified) and on a configured infrastructure Stack. Once a cluster is created and launched, it can be used the usual way as any Hadoop cluster. We suggest to start with the Cluster's Ambari UI for an overview of your cluster.",
-        "operationId" : "getPrivateCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/validate" : {
-      "post" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "validate stack",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "validateStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/StackValidationRequest"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve stack by id",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "entry",
-          "in" : "query",
-          "required" : false,
-          "type" : "array",
-          "items" : {
-            "type" : "string"
-          },
-          "collectionFormat" : "multi"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      },
-      "put" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "update stack by id",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "putStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/UpdateStack"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "delete stack by id",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "deleteStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "forced",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        }, {
-          "name" : "deleteDependencies",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}/certificate" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieves the TLS certificate used by the gateway",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getCertificateStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CertificateResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}/cluster" : {
-      "get" : {
-        "tags" : [ "cluster" ],
-        "summary" : "retrieve cluster by stack id",
-        "description" : "Clusters are materialised Hadoop services on a given infrastructure. They are built based on a Blueprint (running the components and services specified) and on a configured infrastructure Stack. Once a cluster is created and launched, it can be used the usual way as any Hadoop cluster. We suggest to start with the Cluster's Ambari UI for an overview of your cluster.",
-        "operationId" : "getCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterResponse"
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "cluster" ],
-        "summary" : "create cluster for stack",
-        "description" : "Clusters are materialised Hadoop services on a given infrastructure. They are built based on a Blueprint (running the components and services specified) and on a configured infrastructure Stack. Once a cluster is created and launched, it can be used the usual way as any Hadoop cluster. We suggest to start with the Cluster's Ambari UI for an overview of your cluster.",
-        "operationId" : "postCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/ClusterRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ClusterResponse"
-            }
-          }
-        }
-      },
-      "put" : {
-        "tags" : [ "cluster" ],
-        "summary" : "update cluster by stack id",
-        "description" : "Clusters are materialised Hadoop services on a given infrastructure. They are built based on a Blueprint (running the components and services specified) and on a configured infrastructure Stack. Once a cluster is created and launched, it can be used the usual way as any Hadoop cluster. We suggest to start with the Cluster's Ambari UI for an overview of your cluster.",
-        "operationId" : "putCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/UpdateCluster"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "cluster" ],
-        "summary" : "delete cluster on a specific stack",
-        "description" : "Clusters are materialised Hadoop services on a given infrastructure. They are built based on a Blueprint (running the components and services specified) and on a configured infrastructure Stack. Once a cluster is created and launched, it can be used the usual way as any Hadoop cluster. We suggest to start with the Cluster's Ambari UI for an overview of your cluster.",
-        "operationId" : "deleteCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}/cluster/config" : {
-      "post" : {
-        "tags" : [ "cluster" ],
-        "summary" : "get cluster properties with blueprint outputs",
-        "description" : "Clusters are materialised Hadoop services on a given infrastructure. They are built based on a Blueprint (running the components and services specified) and on a configured infrastructure Stack. Once a cluster is created and launched, it can be used the usual way as any Hadoop cluster. We suggest to start with the Cluster's Ambari UI for an overview of your cluster.",
-        "operationId" : "getConfigsCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/ConfigsRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/ConfigsResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}/cluster/failurereport" : {
-      "post" : {
-        "tags" : [ "cluster" ],
-        "summary" : "failure report",
-        "description" : "Endpoint to report the failed nodes in the given cluster. If recovery mode for the node's hostgroup is AUTO then autorecovery would be started. If recovery mode for the node's hostgroup is MANUAL, the nodes will be marked as unhealthy.",
-        "operationId" : "failureReportCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/FailureReport"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}/cluster/full" : {
-      "get" : {
-        "tags" : [ "cluster" ],
-        "summary" : "retrieve cluster by stack id",
-        "description" : "Clusters are materialised Hadoop services on a given infrastructure. They are built based on a Blueprint (running the components and services specified) and on a configured infrastructure Stack. Once a cluster is created and launched, it can be used the usual way as any Hadoop cluster. We suggest to start with the Cluster's Ambari UI for an overview of your cluster.",
-        "operationId" : "getFullCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/AutoscaleClusterResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}/cluster/manualrepair" : {
-      "post" : {
-        "tags" : [ "cluster" ],
-        "summary" : "repair the cluster",
-        "description" : "Removing the failed nodes and starting new nodes to substitute them.",
-        "operationId" : "repairCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/ClusterRepairRequest"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}/cluster/upgrade" : {
-      "post" : {
-        "tags" : [ "cluster" ],
-        "summary" : "upgrade the Ambari version",
-        "description" : "Ambari is used to provision the Hadoop clusters.",
-        "operationId" : "upgradeCluster",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/AmbariRepoDetails"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/stacks/{id}/status" : {
-      "get" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "retrieve stack status by stack id",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "statusStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "object"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/stacks/{stackId}/{instanceId}" : {
-      "delete" : {
-        "tags" : [ "v1stacks" ],
-        "summary" : "delete instance resource from stack",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "deleteInstanceStack",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "stackId",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "instanceId",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/subscriptions" : {
-      "post" : {
-        "tags" : [ "v1subscriptions" ],
-        "summary" : "retrive subscribe identifier",
-        "description" : "Accepting client subscriptions to notification events.",
-        "operationId" : "subscribeSubscription",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/SubscriptionRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/Id"
-            }
-          }
-        }
-      }
-    },
-    "/v1/templates/account" : {
-      "get" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "retrieve public and private (owned) templates",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "getPublicsTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/TemplateResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "create template as public resource",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "postPublicTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/TemplateRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/TemplateResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/templates/account/{name}" : {
-      "get" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "retrieve a public or private (owned) template by name",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "getPublicTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/TemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "delete public (owned) or private template by name",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "deletePublicTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/templates/user" : {
-      "get" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "retrieve private templates",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "getPrivatesTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/TemplateResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "create template as private resource",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "postPrivateTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/TemplateRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/TemplateResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/templates/user/{name}" : {
-      "get" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "retrieve a private template by name",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "getPrivateTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/TemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "delete private template by name",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "deletePrivateTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/templates/{id}" : {
-      "get" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "retrieve template by id",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "getTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/TemplateResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1templates" ],
-        "summary" : "delete template by id",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "deleteTemplate",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/topologies/account" : {
-      "get" : {
-        "tags" : [ "v1topologies" ],
-        "summary" : "retrieve topoligies",
-        "description" : "A topology gives system administrators an easy way to associate compute nodes with data centers and racks.",
-        "operationId" : "getPublicsTopology",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/TopologyResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v1topologies" ],
-        "summary" : "create topology as public resource",
-        "description" : "A topology gives system administrators an easy way to associate compute nodes with data centers and racks.",
-        "operationId" : "postPublicTopology",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/TopologyRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/TopologyResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v1/topologies/account/{id}" : {
-      "get" : {
-        "tags" : [ "v1topologies" ],
-        "summary" : "retrieve topology by id",
-        "description" : "A template gives developers and systems administrators an easy way to create and manage a collection of cloud infrastructure related resources, maintaining and updating them in an orderly and predictable fashion. Templates are cloud specific - and on top of the infrastructural setup they collect the information such as the used machine images, the datacenter location, instance types, and can capture and control region-specific infrastructure variations. We support heterogenous clusters - this one Hadoop cluster can be built by combining different templates.",
-        "operationId" : "getTopology",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/TopologyResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v1topologies" ],
-        "summary" : "delete topology by id",
-        "description" : "A topology gives system administrators an easy way to associate compute nodes with data centers and racks.",
-        "operationId" : "deleteTopology",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "forced",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/usages" : {
-      "get" : {
-        "tags" : [ "v1usages" ],
-        "summary" : "retrieve usages by filter parameters",
-        "description" : "Cloudbreak gives you an up to date overview of cluster usage based on different filtering criteria (start/end date, users, providers, region, etc)",
-        "operationId" : "getDeployerUsage",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "since",
-          "in" : "query",
-          "required" : false,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "filterenddate",
-          "in" : "query",
-          "required" : false,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "user",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        }, {
-          "name" : "account",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        }, {
-          "name" : "cloud",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        }, {
-          "name" : "zone",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/CloudbreakUsage"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/usages/account" : {
-      "get" : {
-        "tags" : [ "v1usages" ],
-        "summary" : "retrieve public and private (owned) usages by filter parameters",
-        "description" : "Cloudbreak gives you an up to date overview of cluster usage based on different filtering criteria (start/end date, users, providers, region, etc)",
-        "operationId" : "getAccountUsage",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "since",
-          "in" : "query",
-          "required" : false,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "filterenddate",
-          "in" : "query",
-          "required" : false,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "user",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        }, {
-          "name" : "cloud",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        }, {
-          "name" : "zone",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/CloudbreakUsage"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/usages/flex/daily" : {
-      "get" : {
-        "tags" : [ "v1usages" ],
-        "summary" : "retrieve Flex related daily usages",
-        "description" : "Cloudbreak gives you an up to date overview of cluster usage based on different filtering criteria (start/end date, users, providers, region, etc)",
-        "operationId" : "getDailyFlexUsage",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CloudbreakFlexUsage"
-            }
-          }
-        }
-      }
-    },
-    "/v1/usages/flex/latest" : {
-      "get" : {
-        "tags" : [ "v1usages" ],
-        "summary" : "retrieve Flex related latest usages, usages for the given day",
-        "description" : "Cloudbreak gives you an up to date overview of cluster usage based on different filtering criteria (start/end date, users, providers, region, etc)",
-        "operationId" : "getLatestFlexUsage",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CloudbreakFlexUsage"
-            }
-          }
-        }
-      }
-    },
-    "/v1/usages/user" : {
-      "get" : {
-        "tags" : [ "v1usages" ],
-        "summary" : "retrieve private usages by filter parameters",
-        "description" : "Cloudbreak gives you an up to date overview of cluster usage based on different filtering criteria (start/end date, users, providers, region, etc)",
-        "operationId" : "getUserUsage",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "since",
-          "in" : "query",
-          "required" : false,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "filterenddate",
-          "in" : "query",
-          "required" : false,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "cloud",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        }, {
-          "name" : "zone",
-          "in" : "query",
-          "required" : false,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/CloudbreakUsage"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v1/users/evict" : {
-      "delete" : {
-        "tags" : [ "v1users" ],
-        "summary" : "remove current user from cache",
-        "description" : "Users can be invited under an account by the administrator, and all resources (e.g. resources, networks, blueprints, credentials, clusters) can be shared across account users",
-        "operationId" : "evictCurrentUserDetails",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/User"
-            }
-          }
-        }
-      }
-    },
-    "/v1/users/profile" : {
-      "get" : {
-        "tags" : [ "v1users" ],
-        "summary" : "user related profile",
-        "description" : "Users can be invited under an account by the administrator, and all resources (e.g. resources, networks, blueprints, credentials, clusters) can be shared across account users",
-        "operationId" : "getUserProfile",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/UserProfileResponse"
-            }
-          }
-        }
-      },
-      "put" : {
-        "tags" : [ "v1users" ],
-        "summary" : "modify user related profile",
-        "description" : "Users can be invited under an account by the administrator, and all resources (e.g. resources, networks, blueprints, credentials, clusters) can be shared across account users",
-        "operationId" : "modifyProfile",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/UserProfileRequest"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v1/users/{id}" : {
-      "put" : {
-        "tags" : [ "v1users" ],
-        "summary" : "remove user from cache (by username)",
-        "description" : "Users can be invited under an account by the administrator, and all resources (e.g. resources, networks, blueprints, credentials, clusters) can be shared across account users",
-        "operationId" : "evictUserDetails",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/User"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "string"
-            }
-          }
-        }
-      }
-    },
-    "/v1/users/{id}/resources" : {
-      "get" : {
-        "tags" : [ "v1users" ],
-        "summary" : "check that account user has any resources",
-        "description" : "Users can be invited under an account by the administrator, and all resources (e.g. resources, networks, blueprints, credentials, clusters) can be shared across account users",
-        "operationId" : "hasResourcesUser",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "boolean"
-            }
-          }
-        }
-      }
-    },
-    "/v1/util/ambari-database" : {
-      "post" : {
-        "tags" : [ "v1util" ],
-        "summary" : "tests a database connection parameters",
-        "description" : "",
-        "operationId" : "testAmbariDatabaseUtil",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/AmbariDatabaseDetails"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/AmbariDatabaseTestResult"
-            }
-          }
-        }
-      }
-    },
-    "/v1/util/ldap" : {
-      "post" : {
-        "tags" : [ "v1util" ],
-        "summary" : "tests an LDAP connection",
-        "description" : "",
-        "operationId" : "testLdapConnectionUtil",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/LdapValidationRequest"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RdsTestResult"
-            }
-          }
-        }
-      }
-    },
-    "/v1/util/ldap/{id}" : {
-      "get" : {
-        "tags" : [ "v1util" ],
-        "summary" : "tests an already exists LDAP connection",
-        "description" : "",
-        "operationId" : "testLdapConnectionByIdUtil",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RdsTestResult"
-            }
-          }
-        }
-      }
-    },
-    "/v1/util/rds" : {
-      "post" : {
-        "tags" : [ "v1util" ],
-        "summary" : "tests an RDS connection",
-        "description" : "",
-        "operationId" : "testRdsConnectionUtil",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/RDSConfig"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RdsTestResult"
-            }
-          }
-        }
-      }
-    },
-    "/v1/util/rds-database" : {
-      "post" : {
-        "tags" : [ "v1util" ],
-        "summary" : "create a database connection parameters",
-        "description" : "",
-        "operationId" : "createRDSDatabaseUtil",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/RDSBuildRequest"
-          }
-        }, {
-          "name" : "target",
-          "in" : "query",
-          "required" : false,
-          "type" : "array",
-          "items" : {
-            "type" : "string"
-          },
-          "collectionFormat" : "multi"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RdsBuildResult"
-            }
-          }
-        }
-      }
-    },
-    "/v1/util/rds/{id}" : {
-      "get" : {
-        "tags" : [ "v1util" ],
-        "summary" : "tests an already exists RDS connection",
-        "description" : "",
-        "operationId" : "testRdsConnectionByIdUtil",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RdsTestResult"
-            }
-          }
-        }
-      }
-    },
-    "/v2/connectors/regions" : {
-      "post" : {
-        "tags" : [ "v2connectors" ],
-        "summary" : "retrive regions by type",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getRegionsByCredentialId",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/PlatformResourceRequestJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/RegionResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v2/connectors/vmtypes" : {
-      "post" : {
-        "tags" : [ "v2connectors" ],
-        "summary" : "retrive vmtype properties by credential",
-        "description" : "Each cloud provider has it's own specific resources like instance types and disk types. These endpoints are collecting them.",
-        "operationId" : "getVmTypesByCredentialId",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/PlatformResourceRequestJson"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformVmtypesResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v2/stacks/account" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve public and private (owned) stacks",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getPublicsStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/StackResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "create stack as public resource",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "postPublicStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/StackV2Request"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v2/stacks/account/{name}" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve a public or private (owned) stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getPublicStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "entry",
-          "in" : "query",
-          "required" : false,
-          "type" : "array",
-          "items" : {
-            "type" : "string"
-          },
-          "collectionFormat" : "multi"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "delete public (owned) or private stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "deletePublicStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "forced",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        }, {
-          "name" : "deleteDependencies",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/all" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve all stacks",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getAllStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/AutoscaleStackResponse"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v2/stacks/ambari" : {
-      "post" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve stack by ambari address",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getStackForAmbariV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/AmbariAddress"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v2/stacks/ambari_password/{name}" : {
-      "put" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "update stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "putpasswordStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/UserNamePassword"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/platformVariants" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve available platform variants",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "variantsStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/PlatformVariantsJson"
-            }
-          }
-        }
-      }
-    },
-    "/v2/stacks/reinstall/{name}" : {
-      "put" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "update stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "putreinstallStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/ReinstallRequestV2"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/repair/{name}" : {
-      "put" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "update stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "putrepairStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/scaling/{name}" : {
-      "put" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "update stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "putscalingStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/StackScaleRequestV2"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/start/{name}" : {
-      "put" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "update stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "putstartStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/stop/{name}" : {
-      "put" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "update stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "putstopStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/sync/{name}" : {
-      "put" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "update stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "putsyncStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/user" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve private stack",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getPrivatesStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "array",
-              "uniqueItems" : true,
-              "items" : {
-                "$ref" : "#/definitions/StackResponse"
-              }
-            }
-          }
-        }
-      },
-      "post" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "create stack as private resource",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "postPrivateStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/StackV2Request"
-          }
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v2/stacks/user/{name}" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve a private stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getPrivateStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "entry",
-          "in" : "query",
-          "required" : false,
-          "type" : "array",
-          "items" : {
-            "type" : "string"
-          },
-          "collectionFormat" : "multi"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "delete private stack by name",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "deletePrivateStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "name",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        }, {
-          "name" : "forced",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        }, {
-          "name" : "deleteDependencies",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/validate" : {
-      "post" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "validate stack",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "validateStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "in" : "body",
-          "name" : "body",
-          "required" : false,
-          "schema" : {
-            "$ref" : "#/definitions/StackValidationRequest"
-          }
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/{id}" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve stack by id",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "entry",
-          "in" : "query",
-          "required" : false,
-          "type" : "array",
-          "items" : {
-            "type" : "string"
-          },
-          "collectionFormat" : "multi"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/StackResponse"
-            }
-          }
-        }
-      },
-      "delete" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "delete stack by id",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "deleteStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "forced",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        }, {
-          "name" : "deleteDependencies",
-          "in" : "query",
-          "required" : false,
-          "type" : "boolean",
-          "default" : false
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    },
-    "/v2/stacks/{id}/certificate" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieves the TLS certificate used by the gateway",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "getCertificateStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "$ref" : "#/definitions/CertificateResponse"
-            }
-          }
-        }
-      }
-    },
-    "/v2/stacks/{id}/status" : {
-      "get" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "retrieve stack status by stack id",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "statusStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "id",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        } ],
-        "responses" : {
-          "200" : {
-            "description" : "successful operation",
-            "schema" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "object"
-              }
-            }
-          }
-        }
-      }
-    },
-    "/v2/stacks/{stackId}/{instanceId}" : {
-      "delete" : {
-        "tags" : [ "v2stacks" ],
-        "summary" : "delete instance resource from stack",
-        "description" : "Stacks are template instances - a running cloud infrastructure created based on a template. Stacks are always launched on behalf of a cloud user account. Stacks support a wide range of resources, allowing you to build a highly available, reliable, and scalable infrastructure for your application needs.",
-        "operationId" : "deleteInstanceStackV2",
-        "schemes" : [ "http", "https" ],
-        "consumes" : [ "application/json" ],
-        "produces" : [ "application/json" ],
-        "parameters" : [ {
-          "name" : "stackId",
-          "in" : "path",
-          "required" : true,
-          "type" : "integer",
-          "format" : "int64"
-        }, {
-          "name" : "instanceId",
-          "in" : "path",
-          "required" : true,
-          "type" : "string"
-        } ],
-        "responses" : {
-          "default" : {
-            "description" : "successful operation"
-          }
-        }
-      }
-    }
-  },
-  "definitions" : {
-    "ConstraintTemplateResponse" : {
-      "type" : "object",
-      "required" : [ "cpu", "disk", "memory", "name", "orchestratorType", "publicInAccount" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 5,
-          "maxLength" : 100,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "cpu" : {
-          "type" : "number",
-          "format" : "double",
-          "description" : "number of CPU cores needed for the Ambari node"
-        },
-        "memory" : {
-          "type" : "number",
-          "format" : "double",
-          "description" : "memory needed for the Ambari container (GB)"
-        },
-        "disk" : {
-          "type" : "number",
-          "format" : "double",
-          "description" : "disk size needed for an Ambari node (GB)"
-        },
-        "orchestratorType" : {
-          "type" : "string",
-          "description" : "type of orchestrator"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "publicInAccount" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        }
-      }
-    },
-    "instanceGroupsV2" : {
-      "type" : "object",
-      "required" : [ "group", "nodeCount" ],
-      "properties" : {
-        "nodeCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of nodes",
-          "minimum" : 0.0,
-          "maximum" : 100000.0
-        },
-        "group" : {
-          "type" : "string",
-          "description" : "name of the instance group"
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "type of the instance group",
-          "enum" : [ "GATEWAY", "CORE" ]
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for instance group",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "template" : {
-          "description" : "instancegroup related template",
-          "$ref" : "#/definitions/TemplateV2Request"
-        },
-        "securityGroup" : {
-          "description" : "instancegroup related securitygroup",
-          "$ref" : "#/definitions/SecurityGroupV2Request"
-        },
-        "recipeNames" : {
-          "type" : "array",
-          "description" : "referenced recipe names",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "string"
-          }
-        },
-        "recoveryMode" : {
-          "type" : "string",
-          "description" : "recovery mode of the hostgroup's nodes",
-          "enum" : [ "MANUAL", "AUTO" ]
-        }
-      }
-    },
-    "ClusterRequest" : {
-      "type" : "object",
-      "required" : [ "name", "password", "userName" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 5,
-          "maxLength" : 40,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "blueprint id for the cluster"
-        },
-        "blueprintName" : {
-          "type" : "string",
-          "description" : "blueprint name for the cluster"
-        },
-        "blueprint" : {
-          "description" : "blueprint for the cluster",
-          "$ref" : "#/definitions/BlueprintRequest"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "hostGroups" : {
-          "type" : "array",
-          "description" : "collection of hostgroups",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/HostGroupRequest"
-          }
-        },
-        "emailNeeded" : {
-          "type" : "boolean",
-          "description" : "send email about the result of the cluster installation",
-          "default" : false
-        },
-        "emailTo" : {
-          "type" : "string",
-          "description" : "send email to the requested address"
-        },
-        "gateway" : {
-          "$ref" : "#/definitions/GatewayJson"
-        },
-        "enableSecurity" : {
-          "type" : "boolean",
-          "description" : "enable Kerberos security",
-          "default" : false
-        },
-        "userName" : {
-          "type" : "string",
-          "description" : "ambari username",
-          "minLength" : 5,
-          "maxLength" : 15,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "password" : {
-          "type" : "string",
-          "description" : "ambari password",
-          "minLength" : 5,
-          "maxLength" : 100
-        },
-        "kerberos" : {
-          "$ref" : "#/definitions/KerberosRequest"
-        },
-        "ldapConfigId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "LDAP config id for the cluster"
-        },
-        "ldapConfig" : {
-          "description" : "LDAP config for the cluster",
-          "$ref" : "#/definitions/LdapConfigRequest"
-        },
-        "validateBlueprint" : {
-          "type" : "boolean",
-          "description" : "validate blueprint",
-          "default" : false
-        },
-        "ambariStackDetails" : {
-          "description" : "details of the Ambari stack",
-          "$ref" : "#/definitions/AmbariStackDetails"
-        },
-        "ambariRepoDetailsJson" : {
-          "description" : "details of the Ambari package repository",
-          "$ref" : "#/definitions/AmbariRepoDetails"
-        },
-        "rdsConfigIds" : {
-          "type" : "array",
-          "description" : "RDS configuration ids for the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "integer",
-            "format" : "int64"
-          }
-        },
-        "ambariDatabaseDetails" : {
-          "description" : "details of the external Ambari database",
-          "$ref" : "#/definitions/AmbariDatabaseDetails"
-        },
-        "rdsConfigJsons" : {
-          "type" : "array",
-          "description" : "details of the external database for Hadoop components",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/RDSConfig"
-          }
-        },
-        "fileSystem" : {
-          "description" : "external file system configuration",
-          "$ref" : "#/definitions/FileSystem"
-        },
-        "configStrategy" : {
-          "type" : "string",
-          "description" : "config recommendation strategy",
-          "enum" : [ "NEVER_APPLY", "ONLY_STACK_DEFAULTS_APPLY", "ALWAYS_APPLY", "ALWAYS_APPLY_DONT_OVERRIDE_CUSTOM_VALUES" ]
-        },
-        "blueprintInputs" : {
-          "type" : "array",
-          "description" : "blueprint inputs in the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/BlueprintInput"
-          }
-        },
-        "blueprintCustomProperties" : {
-          "type" : "string",
-          "description" : "blueprint custom properties"
-        },
-        "customContainer" : {
-          "description" : "custom containers",
-          "$ref" : "#/definitions/CustomContainerRequest"
-        },
-        "customQueue" : {
-          "type" : "string",
-          "description" : "custom queue for yarn orchestrator"
-        },
-        "executorType" : {
-          "type" : "string",
-          "description" : "executor type of cluster",
-          "enum" : [ "CONTAINER", "DEFAULT" ]
-        },
-        "connectedCluster" : {
-          "description" : "cluster can connect to a datalake you can define the parameters here",
-          "$ref" : "#/definitions/ConnectedClusterRequest"
-        }
-      }
-    },
-    "RDSConfig" : {
-      "type" : "object",
-      "required" : [ "connectionPassword", "connectionURL", "connectionUserName", "databaseType", "hdpVersion", "name" ],
-      "properties" : {
-        "connectionURL" : {
-          "type" : "string",
-          "description" : "JDBC connection URL in the form of jdbc:<db-type>://<address>:<port>/<db>",
-          "pattern" : "^jdbc:postgresql://[-\\w\\.]*:\\d{1,5}/?\\w*"
-        },
-        "databaseType" : {
-          "type" : "string",
-          "description" : "Type of the external database (allowed values: MYSQL, POSTGRES)",
-          "enum" : [ "POSTGRES" ]
-        },
-        "hdpVersion" : {
-          "type" : "string",
-          "description" : "HDP version for the RDS configuration"
-        },
-        "validated" : {
-          "type" : "boolean",
-          "description" : "If true, then the RDS configuration will be validated",
-          "default" : false
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "Type of rds (HIVE or RANGER)",
-          "enum" : [ "HIVE", "RANGER", "DRUID" ]
-        },
-        "properties" : {
-          "type" : "array",
-          "description" : "custom properties for rds connection",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/RdsConfigProperty"
-          }
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "Name of the RDS configuration resource"
-        },
-        "connectionUserName" : {
-          "type" : "string",
-          "description" : "Username to use for the jdbc connection"
-        },
-        "connectionPassword" : {
-          "type" : "string",
-          "description" : "Password to use for the jdbc connection"
-        }
-      }
-    },
-    "PlatformRegionsJson" : {
-      "type" : "object",
-      "properties" : {
-        "regions" : {
-          "type" : "object",
-          "description" : "regions",
-          "additionalProperties" : {
-            "type" : "array",
-            "items" : {
-              "type" : "string"
-            }
-          }
-        },
-        "displayNames" : {
-          "type" : "object",
-          "description" : "regions with displayNames",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "string"
-            }
-          }
-        },
-        "availabilityZones" : {
-          "type" : "object",
-          "description" : "availability zones",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "array",
-              "items" : {
-                "type" : "string"
-              }
-            }
-          }
-        },
-        "defaultRegions" : {
-          "type" : "object",
-          "description" : "default regions",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "SecurityGroupResponse" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "publicInAccount" ],
-      "properties" : {
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "securityGroupId" : {
-          "type" : "string",
-          "description" : "Exisiting security group id"
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "owner" : {
-          "type" : "string",
-          "description" : "id of the resource owner that is provided by OAuth provider"
-        },
-        "account" : {
-          "type" : "string",
-          "description" : "account id of the resource owner that is provided by OAuth provider"
-        },
-        "securityRules" : {
-          "type" : "array",
-          "description" : "list of security rules that relates to the security group",
-          "items" : {
-            "$ref" : "#/definitions/SecurityRuleResponse"
-          }
-        },
-        "publicInAccount" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        }
-      }
-    },
-    "PlatformNetworkResponse" : {
-      "type" : "object",
-      "properties" : {
-        "name" : {
-          "type" : "string"
-        },
-        "id" : {
-          "type" : "string"
-        },
-        "subnets" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "properties" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "OrchestratorResponse" : {
-      "type" : "object",
-      "required" : [ "type" ],
-      "properties" : {
-        "parameters" : {
-          "type" : "object",
-          "description" : "orchestrator specific parameters, like authentication details",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "apiEndpoint" : {
-          "type" : "string",
-          "description" : "endpoint for the container orchestration api"
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "type of the orchestrator"
-        }
-      }
-    },
-    "StackRepoDetailsJson" : {
-      "type" : "object",
-      "properties" : {
-        "stack" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "util" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "knox" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "HardwareInfoResponse" : {
-      "type" : "object",
-      "properties" : {
-        "instanceMetaData" : {
-          "description" : "metadata of instances",
-          "$ref" : "#/definitions/InstanceMetaData"
-        },
-        "hostMetadata" : {
-          "description" : "metadata of hosts",
-          "$ref" : "#/definitions/HostMetadata"
-        }
-      }
-    },
-    "ConnectedClusterRequest" : {
-      "type" : "object",
-      "properties" : {
-        "sourceClusterId" : {
-          "type" : "integer",
-          "format" : "int64"
-        },
-        "sourceClusterName" : {
-          "type" : "string"
-        }
-      }
-    },
-    "ReinstallRequestV2" : {
-      "type" : "object",
-      "required" : [ "blueprintName" ],
-      "properties" : {
-        "instanceGroups" : {
-          "type" : "array",
-          "description" : "collection of instance groupst",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/instanceGroupsV2"
-          }
-        },
-        "ambariStackDetails" : {
-          "description" : "details of the Ambari stack",
-          "$ref" : "#/definitions/AmbariStackDetails"
-        },
-        "blueprintName" : {
-          "type" : "string",
-          "description" : "blueprint name for the cluster"
-        }
-      }
-    },
-    "OrchestratorRequest" : {
-      "type" : "object",
-      "required" : [ "type" ],
-      "properties" : {
-        "parameters" : {
-          "type" : "object",
-          "description" : "orchestrator specific parameters, like authentication details",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "apiEndpoint" : {
-          "type" : "string",
-          "description" : "endpoint for the container orchestration api"
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "type of the orchestrator"
-        }
-      }
-    },
-    "AutoscaleStackResponse" : {
-      "type" : "object",
-      "required" : [ "name" ],
-      "properties" : {
-        "stackId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the stack"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the stack",
-          "minLength" : 5,
-          "maxLength" : 40,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "owner" : {
-          "type" : "string",
-          "description" : "id of the resource owner that is provided by OAuth provider"
-        },
-        "account" : {
-          "type" : "string",
-          "description" : "account id of the resource owner that is provided by OAuth provider"
-        },
-        "gatewayPort" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "port of the gateway secured proxy"
-        },
-        "ambariServerIp" : {
-          "type" : "string",
-          "description" : "public ambari ip of the stack"
-        },
-        "userName" : {
-          "type" : "string",
-          "description" : "ambari username"
-        },
-        "password" : {
-          "type" : "string",
-          "description" : "ambari password"
-        },
-        "status" : {
-          "type" : "string",
-          "description" : "status of the stack",
-          "enum" : [ "REQUESTED", "CREATE_IN_PROGRESS", "AVAILABLE", "UPDATE_IN_PROGRESS", "UPDATE_REQUESTED", "UPDATE_FAILED", "CREATE_FAILED", "ENABLE_SECURITY_FAILED", "DELETE_IN_PROGRESS", "DELETE_FAILED", "DELETE_COMPLETED", "STOPPED", "STOP_REQUESTED", "START_REQUESTED", "STOP_IN_PROGRESS", "START_IN_PROGRESS", "START_FAILED", "STOP_FAILED", "WAIT_FOR_SYNC" ]
-        },
-        "clusterStatus" : {
-          "type" : "string",
-          "description" : "status of the cluster",
-          "enum" : [ "REQUESTED", "CREATE_IN_PROGRESS", "AVAILABLE", "UPDATE_IN_PROGRESS", "UPDATE_REQUESTED", "UPDATE_FAILED", "CREATE_FAILED", "ENABLE_SECURITY_FAILED", "DELETE_IN_PROGRESS", "DELETE_FAILED", "DELETE_COMPLETED", "STOPPED", "STOP_REQUESTED", "START_REQUESTED", "STOP_IN_PROGRESS", "START_IN_PROGRESS", "START_FAILED", "STOP_FAILED", "WAIT_FOR_SYNC" ]
-        },
-        "created" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "creation time of the stack in long"
-        }
-      }
-    },
-    "IpPoolJson" : {
-      "type" : "object",
-      "properties" : {
-        "name" : {
-          "type" : "string"
-        },
-        "id" : {
-          "type" : "string"
-        },
-        "properties" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "AmbariDatabaseTestResult" : {
-      "type" : "object",
-      "required" : [ "error" ],
-      "properties" : {
-        "error" : {
-          "type" : "string",
-          "description" : "result of Ambari database test"
-        }
-      }
-    },
-    "PlatformSecurityGroupResponse" : {
-      "type" : "object",
-      "properties" : {
-        "groupName" : {
-          "type" : "string"
-        },
-        "groupId" : {
-          "type" : "string"
-        },
-        "properties" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "PlatformIpPoolsResponse" : {
-      "type" : "object",
-      "properties" : {
-        "ippools" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "array",
-            "uniqueItems" : true,
-            "items" : {
-              "$ref" : "#/definitions/IpPoolJson"
-            }
-          }
-        }
-      }
-    },
-    "TemplateRequest" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "instanceType", "name" ],
-      "properties" : {
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for template",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "volumeType" : {
-          "type" : "string",
-          "description" : "type of the volumes"
-        },
-        "instanceType" : {
-          "type" : "string",
-          "description" : "type of the instance"
-        },
-        "topologyId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the topology the resource belongs to"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "volumeCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of volumes"
-        },
-        "volumeSize" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "size of volumes"
-        }
-      }
-    },
-    "CloudbreakEvent" : {
-      "type" : "object",
-      "properties" : {
-        "eventType" : {
-          "type" : "string",
-          "description" : "type of the event"
-        },
-        "eventTimestamp" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "timestamp of the event"
-        },
-        "eventMessage" : {
-          "type" : "string",
-          "description" : "message of the event"
-        },
-        "owner" : {
-          "type" : "string",
-          "description" : "id of the resource owner that is provided by OAuth provider"
-        },
-        "account" : {
-          "type" : "string",
-          "description" : "account id of the resource owner that is provided by OAuth provider"
-        },
-        "cloud" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "region" : {
-          "type" : "string",
-          "description" : "region of the stack"
-        },
-        "availabilityZone" : {
-          "type" : "string",
-          "description" : "availability zone of the stack"
-        },
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "blueprint id for the cluster"
-        },
-        "blueprintName" : {
-          "type" : "string",
-          "description" : "gathered from blueprintName field from the blueprint JSON"
-        },
-        "clusterId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the cluster"
-        },
-        "clusterName" : {
-          "type" : "string",
-          "description" : "name of the cluster"
-        },
-        "stackId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the stack"
-        },
-        "stackName" : {
-          "type" : "string",
-          "description" : "name of the stack"
-        },
-        "stackStatus" : {
-          "type" : "string",
-          "description" : "status of the stack",
-          "enum" : [ "REQUESTED", "CREATE_IN_PROGRESS", "AVAILABLE", "UPDATE_IN_PROGRESS", "UPDATE_REQUESTED", "UPDATE_FAILED", "CREATE_FAILED", "ENABLE_SECURITY_FAILED", "DELETE_IN_PROGRESS", "DELETE_FAILED", "DELETE_COMPLETED", "STOPPED", "STOP_REQUESTED", "START_REQUESTED", "STOP_IN_PROGRESS", "START_IN_PROGRESS", "START_FAILED", "STOP_FAILED", "WAIT_FOR_SYNC" ]
-        },
-        "nodeCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of nodes"
-        },
-        "instanceGroup" : {
-          "type" : "string",
-          "description" : "name of the instance group"
-        },
-        "clusterStatus" : {
-          "type" : "string",
-          "description" : "status of the cluster",
-          "enum" : [ "REQUESTED", "CREATE_IN_PROGRESS", "AVAILABLE", "UPDATE_IN_PROGRESS", "UPDATE_REQUESTED", "UPDATE_FAILED", "CREATE_FAILED", "ENABLE_SECURITY_FAILED", "DELETE_IN_PROGRESS", "DELETE_FAILED", "DELETE_COMPLETED", "STOPPED", "STOP_REQUESTED", "START_REQUESTED", "STOP_IN_PROGRESS", "START_IN_PROGRESS", "START_FAILED", "STOP_FAILED", "WAIT_FOR_SYNC" ]
-        }
-      }
-    },
-    "StackDetailsJson" : {
-      "type" : "object",
-      "properties" : {
-        "version" : {
-          "type" : "string"
-        },
-        "repo" : {
-          "$ref" : "#/definitions/StackRepoDetailsJson"
-        }
-      }
-    },
-    "StackRequest" : {
-      "type" : "object",
-      "required" : [ "instanceGroups", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the stack",
-          "minLength" : 5,
-          "maxLength" : 40,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "availabilityZone" : {
-          "type" : "string",
-          "description" : "availability zone of the stack"
-        },
-        "region" : {
-          "type" : "string",
-          "description" : "region of the stack"
-        },
-        "platformVariant" : {
-          "type" : "string",
-          "description" : "cloud provider api variant"
-        },
-        "credentialId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "credential resource id for the stack"
-        },
-        "onFailureAction" : {
-          "type" : "string",
-          "description" : "action on failure",
-          "enum" : [ "ROLLBACK", "DO_NOTHING" ]
-        },
-        "networkId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "network resource id for the stack"
-        },
-        "ambariVersion" : {
-          "type" : "string",
-          "description" : "specific version of ambari"
-        },
-        "hdpVersion" : {
-          "type" : "string",
-          "description" : "specific version of HDP"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "additional cloud specific parameters for stack",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "customDomain" : {
-          "type" : "string",
-          "description" : "custom domain name for the nodes in the stack"
-        },
-        "customHostname" : {
-          "type" : "string",
-          "description" : "custom hostname for nodes in the stack"
-        },
-        "clusterNameAsSubdomain" : {
-          "type" : "boolean",
-          "description" : "using the cluster name to create subdomain",
-          "default" : false
-        },
-        "hostgroupNameAsHostname" : {
-          "type" : "boolean",
-          "description" : "using the hostgroup names to create hostnames",
-          "default" : false
-        },
-        "applicationTags" : {
-          "type" : "object",
-          "description" : "stack related application tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "userDefinedTags" : {
-          "type" : "object",
-          "description" : "stack related userdefined tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "defaultTags" : {
-          "type" : "object",
-          "description" : "stack related default tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "orchestrator" : {
-          "description" : "the details of the container orchestrator api to use",
-          "$ref" : "#/definitions/OrchestratorRequest"
-        },
-        "instanceGroups" : {
-          "type" : "array",
-          "description" : "collection of instance groupst",
-          "items" : {
-            "$ref" : "#/definitions/instanceGroups"
-          }
-        },
-        "failurePolicy" : {
-          "description" : "failure policy in case of failures",
-          "$ref" : "#/definitions/FailurePolicyRequest"
-        },
-        "credential" : {
-          "description" : "stack related credential",
-          "$ref" : "#/definitions/CredentialRequest"
-        },
-        "stackAuthentication" : {
-          "description" : "stack related authentication",
-          "$ref" : "#/definitions/StackAuthentication"
-        },
-        "network" : {
-          "description" : "stack related network",
-          "$ref" : "#/definitions/NetworkRequest"
-        },
-        "imageCatalog" : {
-          "type" : "string",
-          "description" : "custom image catalog URL"
-        },
-        "imageId" : {
-          "type" : "string",
-          "description" : "virtual machine image id from ImageCatalog, machines of the cluster will be started from this image"
-        },
-        "flexId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the related flex subscription"
-        },
-        "credentialSource" : {
-          "description" : "source credential object for cloning",
-          "$ref" : "#/definitions/CredentialSourceRequest"
-        },
-        "credentialName" : {
-          "type" : "string",
-          "description" : "credential resource name for the stack"
-        },
-        "clusterRequest" : {
-          "description" : "cluster request object on stack",
-          "$ref" : "#/definitions/ClusterRequest"
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider",
-          "readOnly" : true
-        }
-      }
-    },
-    "CloudbreakFlexUsage" : {
-      "type" : "object",
-      "properties" : {
-        "controller" : {
-          "$ref" : "#/definitions/FlexUsageControllerJson"
-        },
-        "products" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/FlexUsageProductJson"
-          }
-        }
-      }
-    },
-    "AmbariStackDetails" : {
-      "type" : "object",
-      "required" : [ "stack", "stackBaseURL", "stackRepoId", "utilsBaseURL", "utilsRepoId", "verify", "version" ],
-      "properties" : {
-        "stack" : {
-          "type" : "string",
-          "description" : "name of the stack, like HDP"
-        },
-        "version" : {
-          "type" : "string",
-          "description" : "version of the stack"
-        },
-        "os" : {
-          "type" : "string",
-          "description" : "operating system for the stack, like redhat6"
-        },
-        "stackRepoId" : {
-          "type" : "string",
-          "description" : "id of the stack repository"
-        },
-        "stackBaseURL" : {
-          "type" : "string",
-          "description" : "url of the stack repository"
-        },
-        "utilsRepoId" : {
-          "type" : "string",
-          "description" : "id of the stack utils repository"
-        },
-        "utilsBaseURL" : {
-          "type" : "string",
-          "description" : "url of the stack utils repository"
-        },
-        "verify" : {
-          "type" : "boolean",
-          "description" : "whether to verify or not the repo url",
-          "default" : false
-        }
-      }
-    },
-    "FlexUsageControllerJson" : {
-      "type" : "object",
-      "properties" : {
-        "guid" : {
-          "type" : "string"
-        },
-        "instanceId" : {
-          "type" : "string"
-        },
-        "region" : {
-          "type" : "string"
-        },
-        "provider" : {
-          "type" : "string"
-        },
-        "smartSenseId" : {
-          "type" : "string"
-        },
-        "userName" : {
-          "type" : "string"
-        }
-      }
-    },
-    "TagSpecificationsJson" : {
-      "type" : "object",
-      "properties" : {
-        "specifications" : {
-          "type" : "object",
-          "description" : "tag specifications",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "object"
-            }
-          }
-        }
-      }
-    },
-    "StackScaleRequestV2" : {
-      "type" : "object",
-      "required" : [ "desiredCount", "group" ],
-      "properties" : {
-        "group" : {
-          "type" : "string",
-          "description" : "name of the instance group"
-        },
-        "desiredCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "scaling adjustment of the instance groups"
-        }
-      }
-    },
-    "RdsBuildResult" : {
-      "type" : "object",
-      "required" : [ "results" ],
-      "properties" : {
-        "results" : {
-          "type" : "object",
-          "description" : "name of the created dbs",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "RecommendationRequestJson" : {
-      "type" : "object",
-      "properties" : {
-        "credentialId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "credential resource id for the request"
-        },
-        "credentialName" : {
-          "type" : "string",
-          "description" : "credential resource name for the request"
-        },
-        "region" : {
-          "type" : "string",
-          "description" : "Related region"
-        },
-        "platformVariant" : {
-          "type" : "string",
-          "description" : "cloud provider api variant"
-        },
-        "filters" : {
-          "type" : "object",
-          "description" : "filter for resources",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "availabilityZone" : {
-          "type" : "string",
-          "description" : "related availability zone"
-        },
-        "blueprintName" : {
-          "type" : "string",
-          "description" : "name that could indentify an existing blueprint"
-        },
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id that could indentify an existing blueprint"
-        }
-      }
-    },
-    "CustomContainerResponse" : {
-      "type" : "object",
-      "properties" : {
-        "definitions" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "NetworkResponse" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "name" ],
-      "properties" : {
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "subnetCIDR" : {
-          "type" : "string",
-          "description" : "the subnet definition of the network in CIDR format"
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "provider specific parameters of the specified network",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "topologyId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the topology the resource belongs to"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource",
-          "readOnly" : true
-        },
-        "publicInAccount" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "readOnly" : true,
-          "default" : false
-        }
-      }
-    },
-    "RDSBuildRequest" : {
-      "type" : "object",
-      "required" : [ "clusterName", "rdsConfigRequest" ],
-      "properties" : {
-        "rdsConfigRequest" : {
-          "description" : "rds config request",
-          "$ref" : "#/definitions/RDSConfig"
-        },
-        "clusterName" : {
-          "type" : "string",
-          "description" : "requested cluster name"
-        }
-      }
-    },
-    "DiskResponse" : {
-      "type" : "object",
-      "properties" : {
-        "type" : {
-          "type" : "string"
-        },
-        "name" : {
-          "type" : "string"
-        },
-        "displayName" : {
-          "type" : "string"
-        }
-      }
-    },
-    "Id" : {
-      "type" : "object",
-      "required" : [ "id" ],
-      "properties" : {
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        }
-      }
-    },
-    "HostGroupResponse" : {
-      "type" : "object",
-      "required" : [ "constraint", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "constraint" : {
-          "description" : "instance group or resource constraint for a hostgroup",
-          "$ref" : "#/definitions/Constraint"
-        },
-        "recipeIds" : {
-          "type" : "array",
-          "description" : "referenced recipe ids",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "integer",
-            "format" : "int64"
-          }
-        },
-        "recoveryMode" : {
-          "type" : "string",
-          "description" : "recovery mode of the hostgroup's nodes",
-          "enum" : [ "MANUAL", "AUTO" ]
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "recipes" : {
-          "type" : "array",
-          "description" : "referenced recipes",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/RecipeResponse"
-          }
-        },
-        "metadata" : {
-          "type" : "array",
-          "description" : "metadata of hosts",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/HostMetadata"
-          }
-        }
-      }
-    },
-    "LdapConfigResponse" : {
-      "type" : "object",
-      "required" : [ "bindDn", "name", "serverHost", "serverPort", "userSearchBase" ],
-      "properties" : {
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "serverHost" : {
-          "type" : "string",
-          "description" : "public host or IP address of LDAP server"
-        },
-        "serverPort" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "port of LDAP server (typically: 389 or 636 for LDAPS)",
-          "minimum" : 1.0,
-          "maximum" : 65535.0
-        },
-        "protocol" : {
-          "type" : "string",
-          "description" : "determines the protocol (LDAP or LDAP over SSL)"
-        },
-        "bindDn" : {
-          "type" : "string",
-          "description" : "bind distinguished name for connection test and group search (e.g. cn=admin,dc=example,dc=org)"
-        },
-        "userSearchBase" : {
-          "type" : "string",
-          "description" : "template for user search for authentication (e.g. dc=hadoop,dc=apache,dc=org)"
-        },
-        "groupSearchBase" : {
-          "type" : "string",
-          "description" : "template for group search for authorization (e.g. dc=hadoop,dc=apache,dc=org)"
-        },
-        "userNameAttribute" : {
-          "type" : "string",
-          "description" : "attribute name for simplified search filter (e.g. sAMAccountName in case of AD, UID or cn for LDAP)."
-        },
-        "domain" : {
-          "type" : "string",
-          "description" : "domain in LDAP server (e.g. ad.seq.com)."
-        },
-        "directoryType" : {
-          "type" : "string",
-          "description" : "directory type of server LDAP or AD",
-          "enum" : [ "LDAP", "ACTIVE_DIRECTORY" ]
-        },
-        "userObjectClass" : {
-          "type" : "string",
-          "description" : "User Object Class (defaults to person)"
-        },
-        "groupObjectClass" : {
-          "type" : "string",
-          "description" : "Group Object Class (defaults to groupOfNames)"
-        },
-        "groupNameAttribute" : {
-          "type" : "string",
-          "description" : "Group Id Attribute (defaults to cn)"
-        },
-        "groupMemberAttribute" : {
-          "type" : "string",
-          "description" : "Group Member Attribute (defaults to member)"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "public" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        }
-      }
-    },
-    "HostMetadata" : {
-      "type" : "object",
-      "required" : [ "groupName", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "groupName" : {
-          "type" : "string",
-          "description" : "name of the host group"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "state" : {
-          "type" : "string",
-          "description" : "state of the host"
-        }
-      }
-    },
-    "StructuredEvent" : {
-      "type" : "object",
-      "properties" : {
-        "type" : {
-          "type" : "string"
-        },
-        "operation" : {
-          "$ref" : "#/definitions/OperationDetails"
-        }
-      }
-    },
-    "VirtualMachinesResponse" : {
-      "type" : "object",
-      "properties" : {
-        "virtualMachines" : {
-          "type" : "array",
-          "description" : "virtual machines",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/VmTypeJson"
-          }
-        },
-        "defaultVirtualMachine" : {
-          "description" : "default virtual machines",
-          "$ref" : "#/definitions/VmTypeJson"
-        }
-      }
-    },
-    "BlueprintParameter" : {
-      "type" : "object",
-      "properties" : {
-        "name" : {
-          "type" : "string"
-        },
-        "description" : {
-          "type" : "string"
-        },
-        "referenceConfiguration" : {
-          "type" : "string"
-        }
-      }
-    },
-    "SecurityRuleRequest" : {
-      "type" : "object",
-      "required" : [ "ports", "protocol", "subnet" ],
-      "properties" : {
-        "subnet" : {
-          "type" : "string",
-          "description" : "definition of allowed subnet in CIDR format",
-          "pattern" : "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))$"
-        },
-        "ports" : {
-          "type" : "string",
-          "description" : "comma separated list of accessible ports",
-          "pattern" : "^[1-9][0-9]{0,4}(-[1-9][0-9]{0,4}){0,1}(,[1-9][0-9]{0,4}(-[1-9][0-9]{0,4}){0,1})*$"
-        },
-        "protocol" : {
-          "type" : "string",
-          "description" : "protocol of the rule"
-        },
-        "modifiable" : {
-          "type" : "boolean",
-          "description" : "flag for making the rule modifiable",
-          "default" : false
-        }
-      }
-    },
-    "AmbariRepoDetails" : {
-      "type" : "object",
-      "required" : [ "baseUrl", "gpgKeyUrl", "version" ],
-      "properties" : {
-        "version" : {
-          "type" : "string",
-          "description" : "version of the Ambari"
-        },
-        "baseUrl" : {
-          "type" : "string",
-          "description" : "url of the Ambari repository"
-        },
-        "gpgKeyUrl" : {
-          "type" : "string",
-          "description" : "gpg key of the Ambari repository"
-        }
-      }
-    },
-    "TopologyRequest" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 5,
-          "maxLength" : 100,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "nodes" : {
-          "type" : "object",
-          "description" : "topology mapping",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "CloudGatewayJson" : {
-      "type" : "object",
-      "properties" : {
-        "name" : {
-          "type" : "string"
-        },
-        "id" : {
-          "type" : "string"
-        },
-        "properties" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "ConfigsRequest" : {
-      "type" : "object",
-      "required" : [ "requests" ],
-      "properties" : {
-        "requests" : {
-          "type" : "array",
-          "description" : "request object",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/BlueprintParameter"
-          }
-        }
-      }
-    },
-    "ImageResponse" : {
-      "type" : "object",
-      "properties" : {
-        "date" : {
-          "type" : "string"
-        },
-        "description" : {
-          "type" : "string"
-        },
-        "os" : {
-          "type" : "string"
-        },
-        "uuid" : {
-          "type" : "string"
-        },
-        "version" : {
-          "type" : "string"
-        },
-        "repo" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "images" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "string"
-            }
-          }
-        },
-        "stackDetails" : {
-          "$ref" : "#/definitions/StackDetailsJson"
-        }
-      }
-    },
-    "TemplateResponse" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "instanceType", "name", "volumeCount", "volumeSize" ],
-      "properties" : {
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for template",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "volumeType" : {
-          "type" : "string",
-          "description" : "type of the volumes"
-        },
-        "instanceType" : {
-          "type" : "string",
-          "description" : "type of the instance"
-        },
-        "topologyId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the topology the resource belongs to"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "volumeCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of volumes"
-        },
-        "volumeSize" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "size of volumes"
-        },
-        "public" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        }
-      }
-    },
-    "AmbariDatabaseDetails" : {
-      "type" : "object",
-      "required" : [ "host", "name", "password", "port", "userName", "vendor" ],
-      "properties" : {
-        "vendor" : {
-          "type" : "string",
-          "description" : "vendor of the Ambari database",
-          "enum" : [ "POSTGRES", "MYSQL", "MARIADB", "MSSQL", "ORACLE", "SQLANYWHERE", "EMBEDDED" ]
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the Ambari database",
-          "pattern" : "^[^']+$"
-        },
-        "host" : {
-          "type" : "string",
-          "description" : "host of the Ambari database",
-          "pattern" : "^[a-zA-Z0-9]([a-zA-Z0-9-\\.]+)$"
-        },
-        "port" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "port of the Ambari database"
-        },
-        "userName" : {
-          "type" : "string",
-          "description" : "user name for the Ambari database",
-          "pattern" : "^[^']+$"
-        },
-        "password" : {
-          "type" : "string",
-          "description" : "password for the Ambari database",
-          "pattern" : "^[^']+$"
-        }
-      }
-    },
-    "UserProfileRequest" : {
-      "type" : "object",
-      "properties" : {
-        "credentialName" : {
-          "type" : "string"
-        },
-        "credentialId" : {
-          "type" : "integer",
-          "format" : "int64"
-        },
-        "uiProperties" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "ImagesResponse" : {
-      "type" : "object",
-      "properties" : {
-        "baseImages" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/BaseImageResponse"
-          }
-        },
-        "hdpImages" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/ImageResponse"
-          }
-        },
-        "hdfImages" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/ImageResponse"
-          }
-        }
-      }
-    },
-    "ClusterV2Request" : {
-      "type" : "object",
-      "properties" : {
-        "emailNeeded" : {
-          "type" : "boolean",
-          "description" : "send email about the result of the cluster installation",
-          "default" : false
-        },
-        "emailTo" : {
-          "type" : "string",
-          "description" : "send email to the requested address"
-        },
-        "ldapConfigId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "LDAP config id for the cluster"
-        },
-        "rdsConfigIds" : {
-          "type" : "array",
-          "description" : "RDS configuration ids for the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "integer",
-            "format" : "int64"
-          }
-        },
-        "rdsConfigJsons" : {
-          "type" : "array",
-          "description" : "details of the external database for Hadoop components",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/RDSConfig"
-          }
-        },
-        "fileSystem" : {
-          "description" : "external file system configuration",
-          "$ref" : "#/definitions/FileSystem"
-        },
-        "executorType" : {
-          "type" : "string",
-          "description" : "executor type of cluster",
-          "enum" : [ "CONTAINER", "DEFAULT" ]
-        },
-        "ambariRequest" : {
-          "description" : "ambari specific requests",
-          "$ref" : "#/definitions/AmbariV2Request"
-        },
-        "byosRequest" : {
-          "description" : "byos specific requests for cluster",
-          "$ref" : "#/definitions/ByosV2Request"
-        }
-      }
-    },
-    "GatewayJson" : {
-      "type" : "object",
-      "properties" : {
-        "enableGateway" : {
-          "type" : "boolean",
-          "description" : "enable Knox gateway security",
-          "default" : false
-        },
-        "path" : {
-          "type" : "string",
-          "description" : "Knox gateway path"
-        },
-        "topologyName" : {
-          "type" : "string",
-          "description" : "Knox topology name"
-        },
-        "exposedServices" : {
-          "type" : "array",
-          "description" : "exposed Knox services",
-          "items" : {
-            "type" : "string"
-          }
-        },
-        "ssoProvider" : {
-          "type" : "string",
-          "description" : "SSO provider cluster name"
-        },
-        "signCert" : {
-          "type" : "string",
-          "description" : "SSO Provider certificate"
-        },
-        "signPub" : {
-          "type" : "string",
-          "description" : "SSO Provider pub key"
-        },
-        "gatewayType" : {
-          "type" : "string",
-          "description" : "Knox gateway type",
-          "enum" : [ "CENTRAL", "INDIVIDUAL" ]
-        },
-        "ssoType" : {
-          "type" : "string",
-          "description" : "Knox SSO type",
-          "enum" : [ "SSO_PROVIDER", "SSO_CONSUMER", "NONE" ]
-        }
-      }
-    },
-    "AutoscaleClusterResponse" : {
-      "type" : "object",
-      "properties" : {
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "status" : {
-          "type" : "string",
-          "description" : "status of the cluster",
-          "enum" : [ "REQUESTED", "CREATE_IN_PROGRESS", "AVAILABLE", "UPDATE_IN_PROGRESS", "UPDATE_REQUESTED", "UPDATE_FAILED", "CREATE_FAILED", "ENABLE_SECURITY_FAILED", "DELETE_IN_PROGRESS", "DELETE_FAILED", "DELETE_COMPLETED", "STOPPED", "STOP_REQUESTED", "START_REQUESTED", "STOP_IN_PROGRESS", "START_IN_PROGRESS", "START_FAILED", "STOP_FAILED", "WAIT_FOR_SYNC" ]
-        },
-        "hoursUp" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "duration - how long the cluster is running in hours"
-        },
-        "minutesUp" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "duration - how long the cluster is running in minutes (minus hours)"
-        },
-        "cluster" : {
-          "type" : "string",
-          "description" : "name of the cluster"
-        },
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "blueprint id for the cluster"
-        },
-        "blueprint" : {
-          "description" : "blueprint for the cluster",
-          "$ref" : "#/definitions/BlueprintResponse"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource"
-        },
-        "statusReason" : {
-          "type" : "string",
-          "description" : "status message of the cluster"
-        },
-        "ambariServerIp" : {
-          "type" : "string",
-          "description" : "public ambari ip of the stack"
-        },
-        "ambariServerUrl" : {
-          "type" : "string",
-          "description" : "public ambari url"
-        },
-        "userName" : {
-          "type" : "string",
-          "description" : "ambari username"
-        },
-        "secure" : {
-          "type" : "boolean",
-          "default" : false
-        },
-        "hostGroups" : {
-          "type" : "array",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/HostGroupResponse"
-          }
-        },
-        "rdsConfigIds" : {
-          "type" : "array",
-          "description" : "RDS configuration ids for the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "integer",
-            "format" : "int64"
-          }
-        },
-        "rdsConfigs" : {
-          "type" : "array",
-          "description" : "RDS configurations for the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/RDSConfigResponse"
-          }
-        },
-        "serviceEndPoints" : {
-          "type" : "object",
-          "description" : "most important services in the cluster",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "configStrategy" : {
-          "type" : "string",
-          "description" : "config recommendation strategy",
-          "enum" : [ "NEVER_APPLY", "ONLY_STACK_DEFAULTS_APPLY", "ALWAYS_APPLY", "ALWAYS_APPLY_DONT_OVERRIDE_CUSTOM_VALUES" ]
-        },
-        "ldapConfigId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "LDAP config id for the cluster"
-        },
-        "ldapConfig" : {
-          "description" : "LDAP config for the cluster",
-          "$ref" : "#/definitions/LdapConfigResponse"
-        },
-        "attributes" : {
-          "type" : "object",
-          "description" : "Additional information for ambari cluster",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "blueprintInputs" : {
-          "type" : "array",
-          "description" : "blueprint inputs in the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/BlueprintInput"
-          }
-        },
-        "blueprintCustomProperties" : {
-          "type" : "string",
-          "description" : "blueprint custom properties"
-        },
-        "executorType" : {
-          "type" : "string",
-          "description" : "executor type of cluster",
-          "enum" : [ "CONTAINER", "DEFAULT" ]
-        },
-        "gateway" : {
-          "$ref" : "#/definitions/GatewayJson"
-        },
-        "customContainers" : {
-          "description" : "custom containers",
-          "$ref" : "#/definitions/CustomContainerResponse"
-        },
-        "ambariStackDetails" : {
-          "description" : "details of the Ambari stack",
-          "$ref" : "#/definitions/AmbariStackDetailsResponse"
-        },
-        "ambariRepoDetailsJson" : {
-          "description" : "details of the Ambari package repository",
-          "$ref" : "#/definitions/AmbariRepoDetails"
-        },
-        "ambariDatabaseDetails" : {
-          "description" : "details of the external Ambari database",
-          "$ref" : "#/definitions/AmbariDatabaseDetails"
-        },
-        "customQueue" : {
-          "type" : "string",
-          "description" : "custom queue for yarn orchestrator"
-        },
-        "password" : {
-          "type" : "string",
-          "description" : "ambari password"
-        }
-      }
-    },
-    "ClusterResponse" : {
-      "type" : "object",
-      "properties" : {
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "status" : {
-          "type" : "string",
-          "description" : "status of the cluster",
-          "enum" : [ "REQUESTED", "CREATE_IN_PROGRESS", "AVAILABLE", "UPDATE_IN_PROGRESS", "UPDATE_REQUESTED", "UPDATE_FAILED", "CREATE_FAILED", "ENABLE_SECURITY_FAILED", "DELETE_IN_PROGRESS", "DELETE_FAILED", "DELETE_COMPLETED", "STOPPED", "STOP_REQUESTED", "START_REQUESTED", "STOP_IN_PROGRESS", "START_IN_PROGRESS", "START_FAILED", "STOP_FAILED", "WAIT_FOR_SYNC" ]
-        },
-        "hoursUp" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "duration - how long the cluster is running in hours"
-        },
-        "minutesUp" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "duration - how long the cluster is running in minutes (minus hours)"
-        },
-        "cluster" : {
-          "type" : "string",
-          "description" : "name of the cluster"
-        },
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "blueprint id for the cluster"
-        },
-        "blueprint" : {
-          "description" : "blueprint for the cluster",
-          "$ref" : "#/definitions/BlueprintResponse"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource"
-        },
-        "statusReason" : {
-          "type" : "string",
-          "description" : "status message of the cluster"
-        },
-        "ambariServerIp" : {
-          "type" : "string",
-          "description" : "public ambari ip of the stack"
-        },
-        "ambariServerUrl" : {
-          "type" : "string",
-          "description" : "public ambari url"
-        },
-        "userName" : {
-          "type" : "string",
-          "description" : "ambari username"
-        },
-        "secure" : {
-          "type" : "boolean",
-          "default" : false
-        },
-        "hostGroups" : {
-          "type" : "array",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/HostGroupResponse"
-          }
-        },
-        "rdsConfigIds" : {
-          "type" : "array",
-          "description" : "RDS configuration ids for the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "integer",
-            "format" : "int64"
-          }
-        },
-        "rdsConfigs" : {
-          "type" : "array",
-          "description" : "RDS configurations for the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/RDSConfigResponse"
-          }
-        },
-        "serviceEndPoints" : {
-          "type" : "object",
-          "description" : "most important services in the cluster",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "configStrategy" : {
-          "type" : "string",
-          "description" : "config recommendation strategy",
-          "enum" : [ "NEVER_APPLY", "ONLY_STACK_DEFAULTS_APPLY", "ALWAYS_APPLY", "ALWAYS_APPLY_DONT_OVERRIDE_CUSTOM_VALUES" ]
-        },
-        "ldapConfigId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "LDAP config id for the cluster"
-        },
-        "ldapConfig" : {
-          "description" : "LDAP config for the cluster",
-          "$ref" : "#/definitions/LdapConfigResponse"
-        },
-        "attributes" : {
-          "type" : "object",
-          "description" : "Additional information for ambari cluster",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "blueprintInputs" : {
-          "type" : "array",
-          "description" : "blueprint inputs in the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/BlueprintInput"
-          }
-        },
-        "blueprintCustomProperties" : {
-          "type" : "string",
-          "description" : "blueprint custom properties"
-        },
-        "executorType" : {
-          "type" : "string",
-          "description" : "executor type of cluster",
-          "enum" : [ "CONTAINER", "DEFAULT" ]
-        },
-        "gateway" : {
-          "$ref" : "#/definitions/GatewayJson"
-        },
-        "customContainers" : {
-          "description" : "custom containers",
-          "$ref" : "#/definitions/CustomContainerResponse"
-        },
-        "ambariStackDetails" : {
-          "description" : "details of the Ambari stack",
-          "$ref" : "#/definitions/AmbariStackDetailsResponse"
-        },
-        "ambariRepoDetailsJson" : {
-          "description" : "details of the Ambari package repository",
-          "$ref" : "#/definitions/AmbariRepoDetails"
-        },
-        "ambariDatabaseDetails" : {
-          "description" : "details of the external Ambari database",
-          "$ref" : "#/definitions/AmbariDatabaseDetails"
-        },
-        "customQueue" : {
-          "type" : "string",
-          "description" : "custom queue for yarn orchestrator"
-        }
-      }
-    },
-    "VmTypeJson" : {
-      "type" : "object",
-      "properties" : {
-        "value" : {
-          "type" : "string"
-        },
-        "vmTypeMetaJson" : {
-          "$ref" : "#/definitions/VmTypeMetaJson"
-        }
-      }
-    },
-    "RdsConfigProperty" : {
-      "type" : "object",
-      "properties" : {
-        "name" : {
-          "type" : "string"
-        },
-        "value" : {
-          "type" : "string"
-        }
-      }
-    },
-    "PlatformOrchestratorsJson" : {
-      "type" : "object",
-      "properties" : {
-        "orchestrators" : {
-          "type" : "object",
-          "description" : "orchestrators",
-          "additionalProperties" : {
-            "type" : "array",
-            "items" : {
-              "type" : "string"
-            }
-          }
-        },
-        "defaults" : {
-          "type" : "object",
-          "description" : "default orchestrators",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "FailurePolicyResponse" : {
-      "type" : "object",
-      "required" : [ "adjustmentType" ],
-      "properties" : {
-        "threshold" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "threshold of failure policy"
-        },
-        "adjustmentType" : {
-          "type" : "string",
-          "description" : "type of  adjustment",
-          "enum" : [ "EXACT", "PERCENTAGE", "BEST_EFFORT" ]
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        }
-      }
-    },
-    "RecommendationResponse" : {
-      "type" : "object",
-      "properties" : {
-        "recommendations" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "$ref" : "#/definitions/VmTypeJson"
-          }
-        },
-        "virtualMachines" : {
-          "type" : "array",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/VmTypeJson"
-          }
-        },
-        "diskResponses" : {
-          "type" : "array",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/DiskResponse"
-          }
-        }
-      }
-    },
-    "BlueprintRequest" : {
-      "type" : "object",
-      "required" : [ "name" ],
-      "properties" : {
-        "ambariBlueprint" : {
-          "type" : "string",
-          "description" : "ambari blueprint JSON, set this or the url field"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "inputs" : {
-          "type" : "array",
-          "description" : "input parameters of the blueprint",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/BlueprintParameter"
-          }
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 1,
-          "maxLength" : 100
-        },
-        "url" : {
-          "type" : "string",
-          "description" : "url source of an ambari blueprint, set this or the ambariBlueprint field"
-        },
-        "properties" : {
-          "type" : "array",
-          "description" : "properties to extend the blueprint with",
-          "items" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "object",
-              "additionalProperties" : {
-                "type" : "string"
-              }
-            }
-          }
-        }
-      }
-    },
-    "ByosV2Request" : {
-      "type" : "object",
-      "properties" : {
-        "customContainer" : {
-          "description" : "custom containers",
-          "$ref" : "#/definitions/CustomContainerRequest"
-        },
-        "customQueue" : {
-          "type" : "string",
-          "description" : "custom queue for yarn orchestrator"
-        }
-      }
-    },
-    "AmbariAddress" : {
-      "type" : "object",
-      "required" : [ "ambariAddress" ],
-      "properties" : {
-        "ambariAddress" : {
-          "type" : "string",
-          "description" : "ambari server address"
-        }
-      }
-    },
-    "NetworkV2Request" : {
-      "type" : "object",
-      "properties" : {
-        "subnetCIDR" : {
-          "type" : "string",
-          "description" : "the subnet definition of the network in CIDR format"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "provider specific parameters of the specified network",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "AmbariV2Request" : {
-      "type" : "object",
-      "required" : [ "password", "userName" ],
-      "properties" : {
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "blueprint id for the cluster"
-        },
-        "blueprintName" : {
-          "type" : "string",
-          "description" : "blueprint name for the cluster"
-        },
-        "gateway" : {
-          "$ref" : "#/definitions/GatewayJson"
-        },
-        "enableSecurity" : {
-          "type" : "boolean",
-          "description" : "enable Kerberos security",
-          "default" : false
-        },
-        "userName" : {
-          "type" : "string",
-          "description" : "ambari username",
-          "minLength" : 5,
-          "maxLength" : 15,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "password" : {
-          "type" : "string",
-          "description" : "ambari password",
-          "minLength" : 5,
-          "maxLength" : 100
-        },
-        "kerberos" : {
-          "$ref" : "#/definitions/KerberosRequest"
-        },
-        "validateBlueprint" : {
-          "type" : "boolean",
-          "description" : "validate blueprint",
-          "default" : false
-        },
-        "ambariStackDetails" : {
-          "description" : "details of the Ambari stack",
-          "$ref" : "#/definitions/AmbariStackDetails"
-        },
-        "ambariRepoDetailsJson" : {
-          "description" : "details of the Ambari package repository",
-          "$ref" : "#/definitions/AmbariRepoDetails"
-        },
-        "ambariDatabaseDetails" : {
-          "description" : "details of the external Ambari database",
-          "$ref" : "#/definitions/AmbariDatabaseDetails"
-        },
-        "configStrategy" : {
-          "type" : "string",
-          "description" : "config recommendation strategy",
-          "enum" : [ "NEVER_APPLY", "ONLY_STACK_DEFAULTS_APPLY", "ALWAYS_APPLY", "ALWAYS_APPLY_DONT_OVERRIDE_CUSTOM_VALUES" ]
-        },
-        "blueprintInputs" : {
-          "type" : "array",
-          "description" : "blueprint inputs in the cluster",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/BlueprintInput"
-          }
-        },
-        "blueprintCustomProperties" : {
-          "type" : "string",
-          "description" : "blueprint custom properties"
-        },
-        "connectedCluster" : {
-          "description" : "cluster can connect to a datalake you can define the parameters here",
-          "$ref" : "#/definitions/ConnectedClusterRequest"
-        }
-      }
-    },
-    "AmbariStackDetailsResponse" : {
-      "type" : "object",
-      "properties" : {
-        "stack" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "util" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "knox" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "verify" : {
-          "type" : "boolean",
-          "default" : false
-        },
-        "hdpVersion" : {
-          "type" : "string"
-        }
-      }
-    },
-    "Constraint" : {
-      "type" : "object",
-      "required" : [ "hostCount" ],
-      "properties" : {
-        "instanceGroupName" : {
-          "type" : "string",
-          "description" : "name of an instance group where the hostgroup will be deployed"
-        },
-        "constraintTemplateName" : {
-          "type" : "string",
-          "description" : "name of a constraint template that defines the resource constraints for the hostgroup"
-        },
-        "hostCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of hosts in the hostgroup"
-        }
-      }
-    },
-    "CloudbreakDetailsJson" : {
-      "type" : "object",
-      "properties" : {
-        "version" : {
-          "type" : "string",
-          "description" : "version of the Cloudbreak that provisioned the stack"
-        }
-      }
-    },
-    "HostGroupRequest" : {
-      "type" : "object",
-      "required" : [ "constraint", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "constraint" : {
-          "description" : "instance group or resource constraint for a hostgroup",
-          "$ref" : "#/definitions/Constraint"
-        },
-        "recipeIds" : {
-          "type" : "array",
-          "description" : "referenced recipe ids",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "integer",
-            "format" : "int64"
-          }
-        },
-        "recoveryMode" : {
-          "type" : "string",
-          "description" : "recovery mode of the hostgroup's nodes",
-          "enum" : [ "MANUAL", "AUTO" ]
-        },
-        "recipes" : {
-          "type" : "array",
-          "description" : "referenced recipes",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/RecipeRequest"
-          }
-        },
-        "recipeNames" : {
-          "type" : "array",
-          "description" : "referenced recipe names",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "UpdateStack" : {
-      "type" : "object",
-      "properties" : {
-        "status" : {
-          "type" : "string",
-          "description" : "status of the scale request",
-          "enum" : [ "SYNC", "FULL_SYNC", "REPAIR_FAILED_NODES", "STOPPED", "STARTED" ]
-        },
-        "withClusterEvent" : {
-          "type" : "boolean",
-          "description" : "on stack update, update cluster too",
-          "default" : false
-        },
-        "instanceGroupAdjustment" : {
-          "description" : "instance group adjustment",
-          "$ref" : "#/definitions/InstanceGroupAdjustment"
-        }
-      }
-    },
-    "PlatformVariantsJson" : {
-      "type" : "object",
-      "properties" : {
-        "platformToVariants" : {
-          "type" : "object",
-          "description" : "platform variants",
-          "additionalProperties" : {
-            "type" : "array",
-            "items" : {
-              "type" : "string"
-            }
-          }
-        },
-        "defaultVariants" : {
-          "type" : "object",
-          "description" : "default variants",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "HostGroupAdjustment" : {
-      "type" : "object",
-      "required" : [ "hostGroup", "scalingAdjustment" ],
-      "properties" : {
-        "hostGroup" : {
-          "type" : "string",
-          "description" : "name of the host group"
-        },
-        "scalingAdjustment" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "scaling adjustment of the host groups"
-        },
-        "withStackUpdate" : {
-          "type" : "boolean",
-          "description" : "on cluster update, update stack too",
-          "default" : false
-        },
-        "validateNodeCount" : {
-          "type" : "boolean",
-          "description" : "validate node count during downscale",
-          "default" : false
-        }
-      }
-    },
-    "OperationDetails" : {
-      "type" : "object",
-      "properties" : {
-        "eventType" : {
-          "type" : "string"
-        },
-        "resourceId" : {
-          "type" : "integer",
-          "format" : "int64"
-        },
-        "resourceType" : {
-          "type" : "string"
-        },
-        "timestamp" : {
-          "type" : "integer",
-          "format" : "int64"
-        },
-        "account" : {
-          "type" : "string"
-        },
-        "userId" : {
-          "type" : "string"
-        },
-        "cloudbreakId" : {
-          "type" : "string"
-        },
-        "cloudbreakVersion" : {
-          "type" : "string"
-        }
-      }
-    },
-    "VmTypeMetaJson" : {
-      "type" : "object",
-      "properties" : {
-        "configs" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/VolumeParameterConfigJson"
-          }
-        },
-        "properties" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "SecurityGroupV2Request" : {
-      "type" : "object",
-      "properties" : {
-        "securityGroupId" : {
-          "type" : "string",
-          "description" : "Exisiting security group id"
-        },
-        "securityRules" : {
-          "type" : "array",
-          "description" : "list of security rules that relates to the security group",
-          "items" : {
-            "$ref" : "#/definitions/SecurityRuleRequest"
-          }
-        }
-      }
-    },
-    "FileSystem" : {
-      "type" : "object",
-      "required" : [ "name", "type" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the filesystem"
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "type of the filesystem",
-          "enum" : [ "WASB_INTEGRATED", "GCS", "WASB", "ADLS" ]
-        },
-        "defaultFs" : {
-          "type" : "boolean",
-          "description" : "true if fs.defaultFS should point to this filesystem",
-          "default" : false
-        },
-        "properties" : {
-          "type" : "object",
-          "description" : "configuration of the filesystem access as key-value pairs",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "TemplateV2Request" : {
-      "type" : "object",
-      "required" : [ "instanceType" ],
-      "properties" : {
-        "volumeCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of volumes"
-        },
-        "volumeSize" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "size of volumes"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for template",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "volumeType" : {
-          "type" : "string",
-          "description" : "type of the volumes"
-        },
-        "instanceType" : {
-          "type" : "string",
-          "description" : "type of the instance"
-        }
-      }
-    },
-    "StackAuthenticationResponse" : {
-      "type" : "object",
-      "properties" : {
-        "publicKey" : {
-          "type" : "string",
-          "description" : "public key for accessing instances"
-        },
-        "publicKeyId" : {
-          "type" : "string",
-          "description" : "public key id for accessing instances"
-        },
-        "loginUserName" : {
-          "type" : "string",
-          "description" : "authentication name for machines"
-        }
-      }
-    },
-    "TopologyResponse" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 5,
-          "maxLength" : 100,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "nodes" : {
-          "type" : "object",
-          "description" : "topology mapping",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        }
-      }
-    },
-    "PlatformVmtypesResponse" : {
-      "type" : "object",
-      "properties" : {
-        "vmTypes" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "$ref" : "#/definitions/VirtualMachinesResponse"
-          }
-        }
-      }
-    },
-    "UserNamePassword" : {
-      "type" : "object",
-      "required" : [ "oldPassword", "password", "userName" ],
-      "properties" : {
-        "userName" : {
-          "type" : "string",
-          "description" : "new user name in ambari",
-          "minLength" : 1,
-          "maxLength" : 2147483647
-        },
-        "oldPassword" : {
-          "type" : "string",
-          "description" : "old password in ambari",
-          "minLength" : 1,
-          "maxLength" : 2147483647
-        },
-        "password" : {
-          "type" : "string",
-          "description" : "new password in ambari",
-          "minLength" : 1,
-          "maxLength" : 2147483647
-        }
-      }
-    },
-    "FailurePolicyRequest" : {
-      "type" : "object",
-      "required" : [ "adjustmentType" ],
-      "properties" : {
-        "threshold" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "threshold of failure policy"
-        },
-        "adjustmentType" : {
-          "type" : "string",
-          "description" : "type of  adjustment",
-          "enum" : [ "EXACT", "PERCENTAGE", "BEST_EFFORT" ]
-        }
-      }
-    },
-    "RegionResponse" : {
-      "type" : "object",
-      "properties" : {
-        "regions" : {
-          "type" : "array",
-          "description" : "regions",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "string"
-          }
-        },
-        "displayNames" : {
-          "type" : "object",
-          "description" : "regions with displayNames",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "availabilityZones" : {
-          "type" : "object",
-          "description" : "availability zones",
-          "additionalProperties" : {
-            "type" : "array",
-            "items" : {
-              "type" : "string"
-            }
-          }
-        },
-        "defaultRegion" : {
-          "type" : "string",
-          "description" : "default regions"
-        }
-      }
-    },
-    "StackValidationRequest" : {
-      "type" : "object",
-      "required" : [ "hostGroups", "instanceGroups", "platform" ],
-      "properties" : {
-        "hostGroups" : {
-          "type" : "array",
-          "description" : "collection of hostgroups",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/HostGroupRequest"
-          }
-        },
-        "instanceGroups" : {
-          "type" : "array",
-          "description" : "collection of instance groupst",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/instanceGroups"
-          }
-        },
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "blueprint id for the cluster"
-        },
-        "blueprint" : {
-          "description" : "blueprint for the cluster",
-          "$ref" : "#/definitions/BlueprintRequest"
-        },
-        "networkId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "network resource id for the stack"
-        },
-        "network" : {
-          "description" : "stack related network",
-          "$ref" : "#/definitions/NetworkRequest"
-        },
-        "platform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "credentialId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "credential resource id for the stack"
-        },
-        "credentialName" : {
-          "type" : "string",
-          "description" : "credential resource name for the stack"
-        },
-        "credential" : {
-          "description" : "stack related credential",
-          "$ref" : "#/definitions/CredentialRequest"
-        },
-        "fileSystem" : {
-          "description" : "cluster related filesystem",
-          "$ref" : "#/definitions/FileSystem"
-        }
-      }
-    },
-    "CustomContainerRequest" : {
-      "type" : "object",
-      "properties" : {
-        "definitions" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "NetworkRequest" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "name" ],
-      "properties" : {
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "subnetCIDR" : {
-          "type" : "string",
-          "description" : "the subnet definition of the network in CIDR format"
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "provider specific parameters of the specified network",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "topologyId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the topology the resource belongs to"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        }
-      }
-    },
-    "FlexSubscriptionRequest" : {
-      "type" : "object",
-      "required" : [ "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "subscriptionId" : {
-          "type" : "string",
-          "description" : "Identifier of Flex subscription.",
-          "readOnly" : true,
-          "pattern" : "^(FLEX-[0-9]{10}$)"
-        },
-        "smartSenseSubscriptionId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "Identifier of SmartSense subscription Cloudbreak domain object json representation.",
-          "readOnly" : true
-        },
-        "usedForController" : {
-          "type" : "boolean",
-          "description" : "true if the flex subscription was used for the controller",
-          "default" : false
-        },
-        "default" : {
-          "type" : "boolean",
-          "default" : false
-        }
-      }
-    },
-    "CredentialResponse" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 5,
-          "maxLength" : 100,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for credential",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "topologyId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the topology the resource belongs to"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "public" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        }
-      }
-    },
-    "BaseImageResponse" : {
-      "type" : "object",
-      "properties" : {
-        "hdpStacks" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/StackDetailsJson"
-          }
-        },
-        "hdfStacks" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/StackDetailsJson"
-          }
-        },
-        "date" : {
-          "type" : "string"
-        },
-        "description" : {
-          "type" : "string"
-        },
-        "os" : {
-          "type" : "string"
-        },
-        "uuid" : {
-          "type" : "string"
-        },
-        "version" : {
-          "type" : "string"
-        },
-        "repo" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "images" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "string"
-            }
-          }
-        },
-        "stackDetails" : {
-          "$ref" : "#/definitions/StackDetailsJson"
-        }
-      }
-    },
-    "PlatformResourceRequestJson" : {
-      "type" : "object",
-      "properties" : {
-        "credentialId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "credential resource id for the request"
-        },
-        "credentialName" : {
-          "type" : "string",
-          "description" : "credential resource name for the request"
-        },
-        "region" : {
-          "type" : "string",
-          "description" : "Related region"
-        },
-        "platformVariant" : {
-          "type" : "string",
-          "description" : "cloud provider api variant"
-        },
-        "filters" : {
-          "type" : "object",
-          "description" : "filter for resources",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "availabilityZone" : {
-          "type" : "string",
-          "description" : "related availability zone"
-        }
-      }
-    },
-    "BlueprintResponse" : {
-      "type" : "object",
-      "required" : [ "name" ],
-      "properties" : {
-        "ambariBlueprint" : {
-          "type" : "string",
-          "description" : "ambari blueprint JSON, set this or the url field"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "inputs" : {
-          "type" : "array",
-          "description" : "input parameters of the blueprint",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/BlueprintParameter"
-          }
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "hostGroupCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of host groups"
-        },
-        "status" : {
-          "type" : "string",
-          "description" : "status of the blueprint",
-          "enum" : [ "DEFAULT", "DEFAULT_DELETED", "USER_MANAGED" ]
-        },
-        "public" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        }
-      }
-    },
-    "InstanceGroupAdjustment" : {
-      "type" : "object",
-      "required" : [ "instanceGroup", "scalingAdjustment" ],
-      "properties" : {
-        "instanceGroup" : {
-          "type" : "string",
-          "description" : "name of the instance group"
-        },
-        "scalingAdjustment" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "scaling adjustment of the instance groups"
-        }
-      }
-    },
-    "CredentialSourceRequest" : {
-      "type" : "object",
-      "required" : [ "sourceId", "sourceName" ],
-      "properties" : {
-        "sourceName" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "sourceId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for credential",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "FlexUsageComponentJson" : {
-      "type" : "object",
-      "properties" : {
-        "componentId" : {
-          "type" : "string"
-        },
-        "instances" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/FlexUsageComponentInstanceJson"
-          }
-        }
-      }
-    },
-    "RDSConfigResponse" : {
-      "type" : "object",
-      "required" : [ "connectionURL", "databaseType", "hdpVersion", "name" ],
-      "properties" : {
-        "connectionURL" : {
-          "type" : "string",
-          "description" : "JDBC connection URL in the form of jdbc:<db-type>://<address>:<port>/<db>",
-          "pattern" : "^jdbc:postgresql://[-\\w\\.]*:\\d{1,5}/?\\w*"
-        },
-        "databaseType" : {
-          "type" : "string",
-          "description" : "Type of the external database (allowed values: MYSQL, POSTGRES)",
-          "enum" : [ "POSTGRES" ]
-        },
-        "hdpVersion" : {
-          "type" : "string",
-          "description" : "HDP version for the RDS configuration"
-        },
-        "validated" : {
-          "type" : "boolean",
-          "description" : "If true, then the RDS configuration will be validated",
-          "default" : false
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "Type of rds (HIVE or RANGER)",
-          "enum" : [ "HIVE", "RANGER", "DRUID" ]
-        },
-        "properties" : {
-          "type" : "array",
-          "description" : "custom properties for rds connection",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/RdsConfigProperty"
-          }
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "Name of the RDS configuration resource"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "creationDate" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "creation time of the resource in long"
-        },
-        "publicInAccount" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        },
-        "clusterNames" : {
-          "type" : "array",
-          "description" : "list of clusters which use config",
-          "uniqueItems" : true,
-          "items" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "instanceGroups" : {
-      "type" : "object",
-      "required" : [ "group", "nodeCount" ],
-      "properties" : {
-        "templateId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "referenced template id"
-        },
-        "securityGroupId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "security group resource id for the instance group"
-        },
-        "nodeCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of nodes",
-          "minimum" : 0.0,
-          "maximum" : 100000.0
-        },
-        "group" : {
-          "type" : "string",
-          "description" : "name of the instance group"
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "type of the instance group",
-          "enum" : [ "GATEWAY", "CORE" ]
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for instance group",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "template" : {
-          "description" : "instancegroup related template",
-          "$ref" : "#/definitions/TemplateRequest"
-        },
-        "securityGroup" : {
-          "description" : "instancegroup related securitygroup",
-          "$ref" : "#/definitions/SecurityGroupRequest"
-        }
-      }
-    },
-    "ClusterTemplateRequest" : {
-      "type" : "object",
-      "required" : [ "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the cluster template"
-        },
-        "template" : {
-          "type" : "string",
-          "description" : "stringified template JSON"
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "type of the cluster template",
-          "enum" : [ "QUICK_START" ]
-        }
-      }
-    },
-    "PlatformDisksJson" : {
-      "type" : "object",
-      "properties" : {
-        "diskTypes" : {
-          "type" : "object",
-          "description" : "disk types",
-          "additionalProperties" : {
-            "type" : "array",
-            "items" : {
-              "type" : "string"
-            }
-          }
-        },
-        "defaultDisks" : {
-          "type" : "object",
-          "description" : "default disks",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "diskMappings" : {
-          "type" : "object",
-          "description" : "disk mappings",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "string"
-            }
-          }
-        },
-        "displayNames" : {
-          "type" : "object",
-          "description" : "disk displayNames",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "string"
-            }
-          }
-        }
-      }
-    },
-    "ConstraintTemplateRequest" : {
-      "type" : "object",
-      "required" : [ "cpu", "disk", "memory", "name", "orchestratorType" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 5,
-          "maxLength" : 100,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "cpu" : {
-          "type" : "number",
-          "format" : "double",
-          "description" : "number of CPU cores needed for the Ambari node"
-        },
-        "memory" : {
-          "type" : "number",
-          "format" : "double",
-          "description" : "memory needed for the Ambari container (GB)"
-        },
-        "disk" : {
-          "type" : "number",
-          "format" : "double",
-          "description" : "disk size needed for an Ambari node (GB)"
-        },
-        "orchestratorType" : {
-          "type" : "string",
-          "description" : "type of orchestrator"
-        }
-      }
-    },
-    "PlatformVirtualMachinesJson" : {
-      "type" : "object",
-      "properties" : {
-        "virtualMachines" : {
-          "type" : "object",
-          "description" : "virtual machines",
-          "additionalProperties" : {
-            "type" : "array",
-            "items" : {
-              "$ref" : "#/definitions/VmTypeJson"
-            }
-          }
-        },
-        "defaultVirtualMachines" : {
-          "type" : "object",
-          "description" : "default virtual machines",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "vmTypesPerZones" : {
-          "type" : "object",
-          "description" : "virtual machines per zones",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "array",
-              "items" : {
-                "$ref" : "#/definitions/VmTypeJson"
-              }
-            }
-          }
-        },
-        "defaultVmTypePerZones" : {
-          "type" : "object",
-          "description" : "default virtual machines per zones",
-          "additionalProperties" : {
-            "type" : "object",
-            "additionalProperties" : {
-              "type" : "string"
-            }
-          }
-        }
-      }
-    },
-    "UpdateCluster" : {
-      "type" : "object",
-      "properties" : {
-        "hostGroupAdjustment" : {
-          "description" : "host group adjustment",
-          "$ref" : "#/definitions/HostGroupAdjustment"
-        },
-        "status" : {
-          "type" : "string",
-          "description" : "request status",
-          "enum" : [ "SYNC", "FULL_SYNC", "REPAIR_FAILED_NODES", "STOPPED", "STARTED" ]
-        },
-        "userNamePasswordJson" : {
-          "description" : "user details",
-          "$ref" : "#/definitions/UserNamePassword"
-        },
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "blueprint id for the cluster"
-        },
-        "validateBlueprint" : {
-          "type" : "boolean",
-          "description" : "validate blueprint",
-          "default" : false
-        },
-        "hostgroups" : {
-          "type" : "array",
-          "description" : "collection of hostgroups",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/HostGroupRequest"
-          }
-        },
-        "ambariStackDetails" : {
-          "description" : "details of the Ambari stack",
-          "$ref" : "#/definitions/AmbariStackDetails"
-        }
-      }
-    },
-    "CredentialRequest" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 5,
-          "maxLength" : 100,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for credential",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "topologyId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the topology the resource belongs to"
-        }
-      }
-    },
-    "FailureReport" : {
-      "type" : "object",
-      "required" : [ "failedNodes" ],
-      "properties" : {
-        "failedNodes" : {
-          "type" : "array",
-          "description" : "List of failed nodes",
-          "items" : {
-            "type" : "string"
-          }
-        }
-      }
-    },
-    "StackAuthentication" : {
-      "type" : "object",
-      "properties" : {
-        "publicKey" : {
-          "type" : "string",
-          "description" : "public key for accessing instances"
-        },
-        "publicKeyId" : {
-          "type" : "string",
-          "description" : "public key id for accessing instances"
-        },
-        "loginUserName" : {
-          "type" : "string",
-          "description" : "authentication name for machines"
-        }
-      }
-    },
-    "User" : {
-      "type" : "object",
-      "properties" : {
-        "username" : {
-          "type" : "string"
-        }
-      }
-    },
-    "UserProfileResponse" : {
-      "type" : "object",
-      "properties" : {
-        "credential" : {
-          "$ref" : "#/definitions/CredentialResponse"
-        },
-        "owner" : {
-          "type" : "string"
-        },
-        "account" : {
-          "type" : "string"
-        },
-        "uiProperties" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "SecurityRuleResponse" : {
-      "type" : "object",
-      "required" : [ "ports", "protocol", "subnet" ],
-      "properties" : {
-        "subnet" : {
-          "type" : "string",
-          "description" : "definition of allowed subnet in CIDR format",
-          "pattern" : "^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\\/([0-9]|[1-2][0-9]|3[0-2]))$"
-        },
-        "ports" : {
-          "type" : "string",
-          "description" : "comma separated list of accessible ports",
-          "pattern" : "^[1-9][0-9]{0,4}(-[1-9][0-9]{0,4}){0,1}(,[1-9][0-9]{0,4}(-[1-9][0-9]{0,4}){0,1})*$"
-        },
-        "protocol" : {
-          "type" : "string",
-          "description" : "protocol of the rule"
-        },
-        "modifiable" : {
-          "type" : "boolean",
-          "description" : "flag for making the rule modifiable",
-          "default" : false
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        }
-      }
-    },
-    "VolumeParameterConfigJson" : {
-      "type" : "object",
-      "properties" : {
-        "volumeParameterType" : {
-          "type" : "string"
-        },
-        "minimumSize" : {
-          "type" : "integer",
-          "format" : "int32"
-        },
-        "maximumSize" : {
-          "type" : "integer",
-          "format" : "int32"
-        },
-        "minimumNumber" : {
-          "type" : "integer",
-          "format" : "int32"
-        },
-        "maximumNumber" : {
-          "type" : "integer",
-          "format" : "int32"
-        }
-      }
-    },
-    "SmartSenseSubscriptionJson" : {
-      "type" : "object",
-      "required" : [ "subscriptionId" ],
-      "properties" : {
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource",
-          "readOnly" : true
-        },
-        "subscriptionId" : {
-          "type" : "string",
-          "description" : "Identifier of SmartSense subscription.",
-          "pattern" : "^([a-zA-Z]{1}-[0-9]{8}-[a-zA-Z]{1}-[0-9]{8}$)"
-        },
-        "owner" : {
-          "type" : "string",
-          "description" : "id of the resource owner that is provided by OAuth provider",
-          "readOnly" : true
-        },
-        "account" : {
-          "type" : "string",
-          "description" : "account id of the resource owner that is provided by OAuth provider",
-          "readOnly" : true
-        },
-        "publicInAccount" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "readOnly" : true,
-          "default" : false
-        },
-        "autoGenerated" : {
-          "type" : "boolean",
-          "description" : "Flag of aut generated SmartSense subscription.",
-          "default" : false
-        }
-      }
-    },
-    "InstanceGroupResponse" : {
-      "type" : "object",
-      "required" : [ "group", "nodeCount" ],
-      "properties" : {
-        "templateId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "referenced template id"
-        },
-        "securityGroupId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "security group resource id for the instance group"
-        },
-        "nodeCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of nodes",
-          "minimum" : 0.0,
-          "maximum" : 100000.0
-        },
-        "group" : {
-          "type" : "string",
-          "description" : "name of the instance group"
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "type of the instance group",
-          "enum" : [ "GATEWAY", "CORE" ]
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "cloud specific parameters for instance group",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        },
-        "template" : {
-          "description" : "instancegroup related template",
-          "$ref" : "#/definitions/TemplateResponse"
-        },
-        "securityGroup" : {
-          "description" : "instancegroup related securitygroup",
-          "$ref" : "#/definitions/SecurityGroupResponse"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource",
-          "readOnly" : true
-        },
-        "metadata" : {
-          "type" : "array",
-          "description" : "metadata of instances",
-          "readOnly" : true,
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/InstanceMetaData"
-          }
-        }
-      }
-    },
-    "RdsTestResult" : {
-      "type" : "object",
-      "required" : [ "connectionResult" ],
-      "properties" : {
-        "connectionResult" : {
-          "type" : "string",
-          "description" : "result of Ldap connection test"
-        }
-      }
-    },
-    "CloudbreakUsage" : {
-      "type" : "object",
-      "properties" : {
-        "owner" : {
-          "type" : "string",
-          "description" : "id of the resource owner that is provided by OAuth provider"
-        },
-        "username" : {
-          "type" : "string",
-          "description" : "ambari username"
-        },
-        "account" : {
-          "type" : "string",
-          "description" : "account id of the resource owner that is provided by OAuth provider"
-        },
-        "day" : {
-          "type" : "string",
-          "description" : "the day the usage of resources happened"
-        },
-        "provider" : {
-          "type" : "string",
-          "description" : "cloud provider of the stack"
-        },
-        "region" : {
-          "type" : "string",
-          "description" : "region of the stack"
-        },
-        "availabilityZone" : {
-          "type" : "string",
-          "description" : "availability zone of the stack"
-        },
-        "instanceHours" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "hours since the instance is running"
-        },
-        "stackId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the stack"
-        },
-        "stackName" : {
-          "type" : "string",
-          "description" : "name of the stack"
-        },
-        "costs" : {
-          "type" : "number",
-          "format" : "double",
-          "description" : "computed costs of instance usage"
-        },
-        "instanceType" : {
-          "type" : "string",
-          "description" : "type of instance"
-        },
-        "instanceGroup" : {
-          "type" : "string",
-          "description" : "group name of instance"
-        },
-        "blueprintId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the blueprint"
-        },
-        "blueprintName" : {
-          "type" : "string",
-          "description" : "name of the blueprint"
-        },
-        "duration" : {
-          "type" : "string",
-          "description" : "time since the instances are running in millisec"
-        },
-        "instanceNum" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "number of instances running"
-        },
-        "peak" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "maximum number of instances running"
-        },
-        "flexId" : {
-          "type" : "string",
-          "description" : "flex subscription id"
-        },
-        "stackUuid" : {
-          "type" : "string",
-          "description" : "unique id of the cluster"
-        }
-      }
-    },
-    "StackV2Request" : {
-      "type" : "object",
-      "required" : [ "instanceGroups", "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the stack",
-          "minLength" : 5,
-          "maxLength" : 40,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "availabilityZone" : {
-          "type" : "string",
-          "description" : "availability zone of the stack"
-        },
-        "region" : {
-          "type" : "string",
-          "description" : "region of the stack"
-        },
-        "platformVariant" : {
-          "type" : "string",
-          "description" : "cloud provider api variant"
-        },
-        "onFailureAction" : {
-          "type" : "string",
-          "description" : "action on failure",
-          "enum" : [ "ROLLBACK", "DO_NOTHING" ]
-        },
-        "ambariVersion" : {
-          "type" : "string",
-          "description" : "specific version of ambari"
-        },
-        "hdpVersion" : {
-          "type" : "string",
-          "description" : "specific version of HDP"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "additional cloud specific parameters for stack",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "customDomain" : {
-          "type" : "string",
-          "description" : "custom domain name for the nodes in the stack"
-        },
-        "customHostname" : {
-          "type" : "string",
-          "description" : "custom hostname for nodes in the stack"
-        },
-        "clusterNameAsSubdomain" : {
-          "type" : "boolean",
-          "description" : "using the cluster name to create subdomain",
-          "default" : false
-        },
-        "hostgroupNameAsHostname" : {
-          "type" : "boolean",
-          "description" : "using the hostgroup names to create hostnames",
-          "default" : false
-        },
-        "applicationTags" : {
-          "type" : "object",
-          "description" : "stack related application tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "userDefinedTags" : {
-          "type" : "object",
-          "description" : "stack related userdefined tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "defaultTags" : {
-          "type" : "object",
-          "description" : "stack related default tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "orchestrator" : {
-          "description" : "the details of the container orchestrator api to use",
-          "$ref" : "#/definitions/OrchestratorRequest"
-        },
-        "instanceGroups" : {
-          "type" : "array",
-          "description" : "collection of instance groupst",
-          "items" : {
-            "$ref" : "#/definitions/instanceGroupsV2"
-          }
-        },
-        "failurePolicy" : {
-          "description" : "failure policy in case of failures",
-          "$ref" : "#/definitions/FailurePolicyRequest"
-        },
-        "stackAuthentication" : {
-          "description" : "stack related authentication",
-          "$ref" : "#/definitions/StackAuthentication"
-        },
-        "network" : {
-          "description" : "stack related network",
-          "$ref" : "#/definitions/NetworkV2Request"
-        },
-        "imageCatalog" : {
-          "type" : "string",
-          "description" : "custom image catalog URL"
-        },
-        "imageId" : {
-          "type" : "string",
-          "description" : "virtual machine image id from ImageCatalog, machines of the cluster will be started from this image"
-        },
-        "flexId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the related flex subscription"
-        },
-        "credentialName" : {
-          "type" : "string",
-          "description" : "credential resource name for the stack"
-        },
-        "clusterRequest" : {
-          "description" : "cluster request object on stack",
-          "$ref" : "#/definitions/ClusterV2Request"
-        }
-      }
-    },
-    "SubscriptionRequest" : {
-      "type" : "object",
-      "required" : [ "endpointUrl" ],
-      "properties" : {
-        "endpointUrl" : {
-          "type" : "string",
-          "description" : "url of the endpoint",
-          "pattern" : "^(https?:\\/\\/)((([\\da-z\\.-]+)\\.([a-z]{2,6}))|localhost|[1-9][0-9]{0,2}.[0-9]{1,3}.[0-9]{1,3}.[0-9]{1,3})(:[1-9][0-9]{1,4})?\\/([\\/\\w\\.-]*)\\/?$"
-        }
-      }
-    },
-    "ImageJson" : {
-      "type" : "object",
-      "properties" : {
-        "imageName" : {
-          "type" : "string",
-          "description" : "name of the image"
-        }
-      }
-    },
-    "PlatformGatewaysResponse" : {
-      "type" : "object",
-      "properties" : {
-        "gateways" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "array",
-            "uniqueItems" : true,
-            "items" : {
-              "$ref" : "#/definitions/CloudGatewayJson"
-            }
-          }
-        }
-      }
-    },
-    "LdapValidationRequest" : {
-      "type" : "object",
-      "required" : [ "bindDn", "bindPassword", "serverHost", "serverPort" ],
-      "properties" : {
-        "serverHost" : {
-          "type" : "string",
-          "description" : "public host or IP address of LDAP server"
-        },
-        "serverPort" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "port of LDAP server (typically: 389 or 636 for LDAPS)",
-          "minimum" : 1.0,
-          "maximum" : 65535.0
-        },
-        "protocol" : {
-          "type" : "string",
-          "description" : "determines the protocol (LDAP or LDAP over SSL)"
-        },
-        "bindDn" : {
-          "type" : "string",
-          "description" : "bind distinguished name for connection test and group search (e.g. cn=admin,dc=example,dc=org)"
-        },
-        "bindPassword" : {
-          "type" : "string",
-          "description" : "password for the provided bind DN"
-        }
-      }
-    },
-    "ClusterTemplateResponse" : {
-      "type" : "object",
-      "required" : [ "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the cluster template"
-        },
-        "template" : {
-          "type" : "string",
-          "description" : "stringified template JSON"
-        },
-        "type" : {
-          "type" : "string",
-          "description" : "type of the cluster template",
-          "enum" : [ "QUICK_START" ]
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        }
-      }
-    },
-    "PlatformSshKeyResponse" : {
-      "type" : "object",
-      "properties" : {
-        "name" : {
-          "type" : "string"
-        },
-        "properties" : {
-          "type" : "object",
-          "additionalProperties" : {
-            "type" : "object"
-          }
-        }
-      }
-    },
-    "RecipeResponse" : {
-      "type" : "object",
-      "required" : [ "recipeType" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 1,
-          "maxLength" : 100,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "recipeType" : {
-          "type" : "string",
-          "description" : "type of recipe",
-          "enum" : [ "PRE_AMBARI_START", "POST_AMBARI_START", "POST_CLUSTER_INSTALL" ]
-        },
-        "content" : {
-          "type" : "string",
-          "description" : "content of recipe"
-        },
-        "uri" : {
-          "type" : "string",
-          "description" : "recipe uri"
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource"
-        },
-        "public" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        }
-      }
-    },
-    "FlexSubscriptionResponse" : {
-      "type" : "object",
-      "required" : [ "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource"
-        },
-        "subscriptionId" : {
-          "type" : "string",
-          "description" : "Identifier of Flex subscription.",
-          "readOnly" : true,
-          "pattern" : "^(FLEX-[0-9]{10}$)"
-        },
-        "smartSenseSubscriptionId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "Identifier of SmartSense subscription Cloudbreak domain object json representation.",
-          "readOnly" : true
-        },
-        "usedForController" : {
-          "type" : "boolean",
-          "description" : "true if the flex subscription was used for the controller",
-          "default" : false
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the resource",
-          "readOnly" : true
-        },
-        "owner" : {
-          "type" : "string",
-          "description" : "id of the resource owner that is provided by OAuth provider",
-          "readOnly" : true
-        },
-        "account" : {
-          "type" : "string",
-          "description" : "account id of the resource owner that is provided by OAuth provider",
-          "readOnly" : true
-        },
-        "publicInAccount" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "readOnly" : true,
-          "default" : false
-        },
-        "smartSenseSubscription" : {
-          "description" : "The associated SmartSense subscription Cloudbreak domain object json representation.",
-          "readOnly" : true,
-          "$ref" : "#/definitions/SmartSenseSubscriptionJson"
-        },
-        "default" : {
-          "type" : "boolean",
-          "default" : false
-        }
-      }
-    },
-    "ConfigsResponse" : {
-      "type" : "object",
-      "required" : [ "inputs" ],
-      "properties" : {
-        "inputs" : {
-          "type" : "array",
-          "description" : "response object",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/BlueprintInput"
-          }
-        }
-      }
-    },
-    "CertificateResponse" : {
-      "type" : "object",
-      "properties" : {
-        "serverCert" : {
-          "type" : "array",
-          "description" : "server certificate used by the gateway",
-          "items" : {
-            "type" : "string",
-            "format" : "byte"
-          }
-        },
-        "clientKey" : {
-          "type" : "array",
-          "description" : "client key used by the gateway",
-          "items" : {
-            "type" : "string",
-            "format" : "byte"
-          }
-        },
-        "clientCert" : {
-          "type" : "array",
-          "description" : "client certificate used by the gateway",
-          "items" : {
-            "type" : "string",
-            "format" : "byte"
-          }
-        }
-      }
-    },
-    "FlexUsageProductJson" : {
-      "type" : "object",
-      "properties" : {
-        "productId" : {
-          "type" : "string"
-        },
-        "components" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/FlexUsageComponentJson"
-          }
-        }
-      }
-    },
-    "RecipeRequest" : {
-      "type" : "object",
-      "required" : [ "recipeType" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 1,
-          "maxLength" : 100,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "recipeType" : {
-          "type" : "string",
-          "description" : "type of recipe",
-          "enum" : [ "PRE_AMBARI_START", "POST_AMBARI_START", "POST_CLUSTER_INSTALL" ]
-        },
-        "content" : {
-          "type" : "string",
-          "description" : "content of recipe"
-        },
-        "uri" : {
-          "type" : "string",
-          "description" : "recipe uri"
-        }
-      }
-    },
-    "FlexUsageComponentInstanceJson" : {
-      "type" : "object",
-      "properties" : {
-        "guid" : {
-          "type" : "string"
-        },
-        "region" : {
-          "type" : "string"
-        },
-        "provider" : {
-          "type" : "string"
-        },
-        "flexSubscriptionId" : {
-          "type" : "string"
-        },
-        "creationTime" : {
-          "type" : "string"
-        },
-        "usageDate" : {
-          "type" : "string"
-        },
-        "peakUsage" : {
-          "type" : "integer",
-          "format" : "int32"
-        }
-      }
-    },
-    "InstanceMetaData" : {
-      "type" : "object",
-      "properties" : {
-        "privateIp" : {
-          "type" : "string",
-          "description" : "private ip of the insctance"
-        },
-        "publicIp" : {
-          "type" : "string",
-          "description" : "public ip of the instance"
-        },
-        "sshPort" : {
-          "type" : "integer",
-          "format" : "int32"
-        },
-        "instanceId" : {
-          "type" : "string",
-          "description" : "id of the instance"
-        },
-        "ambariServer" : {
-          "type" : "boolean",
-          "description" : "ambari server address",
-          "default" : false
-        },
-        "discoveryFQDN" : {
-          "type" : "string",
-          "description" : "the fully qualified domain name of the node in the service discovery cluster"
-        },
-        "instanceGroup" : {
-          "type" : "string",
-          "description" : "name of the instance group"
-        },
-        "instanceStatus" : {
-          "type" : "string",
-          "description" : "status of the instance",
-          "enum" : [ "REQUESTED", "CREATED", "UNREGISTERED", "REGISTERED", "DECOMMISSIONED", "TERMINATED", "FAILED", "STOPPED" ]
-        },
-        "instanceType" : {
-          "type" : "string",
-          "description" : "type of the instance",
-          "enum" : [ "GATEWAY", "GATEWAY_PRIMARY", "CORE" ]
-        }
-      }
-    },
-    "SecurityGroupRequest" : {
-      "type" : "object",
-      "required" : [ "cloudPlatform", "name" ],
-      "properties" : {
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "securityGroupId" : {
-          "type" : "string",
-          "description" : "Exisiting security group id"
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "securityRules" : {
-          "type" : "array",
-          "description" : "list of security rules that relates to the security group",
-          "items" : {
-            "$ref" : "#/definitions/SecurityRuleRequest"
-          }
-        }
-      }
-    },
-    "KerberosRequest" : {
-      "type" : "object",
-      "properties" : {
-        "masterKey" : {
-          "type" : "string",
-          "description" : "kerberos master key",
-          "minLength" : 3,
-          "maxLength" : 50
-        },
-        "admin" : {
-          "type" : "string",
-          "description" : "kerberos admin user",
-          "minLength" : 5,
-          "maxLength" : 15
-        },
-        "password" : {
-          "type" : "string",
-          "description" : "kerberos admin password",
-          "minLength" : 5,
-          "maxLength" : 50
-        },
-        "url" : {
-          "type" : "string"
-        },
-        "realm" : {
-          "type" : "string"
-        },
-        "principal" : {
-          "type" : "string"
-        },
-        "ldapUrl" : {
-          "type" : "string"
-        },
-        "containerDn" : {
-          "type" : "string"
-        },
-        "tcpAllowed" : {
-          "type" : "boolean",
-          "default" : false
-        }
-      }
-    },
-    "BlueprintInput" : {
-      "type" : "object",
-      "properties" : {
-        "name" : {
-          "type" : "string"
-        },
-        "propertyValue" : {
-          "type" : "string"
-        }
-      }
-    },
-    "LdapConfigRequest" : {
-      "type" : "object",
-      "required" : [ "bindDn", "bindPassword", "name", "serverHost", "serverPort", "userSearchBase" ],
-      "properties" : {
-        "description" : {
-          "type" : "string",
-          "description" : "description of the resource",
-          "minLength" : 0,
-          "maxLength" : 1000
-        },
-        "serverHost" : {
-          "type" : "string",
-          "description" : "public host or IP address of LDAP server"
-        },
-        "serverPort" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "port of LDAP server (typically: 389 or 636 for LDAPS)",
-          "minimum" : 1.0,
-          "maximum" : 65535.0
-        },
-        "protocol" : {
-          "type" : "string",
-          "description" : "determines the protocol (LDAP or LDAP over SSL)"
-        },
-        "bindDn" : {
-          "type" : "string",
-          "description" : "bind distinguished name for connection test and group search (e.g. cn=admin,dc=example,dc=org)"
-        },
-        "userSearchBase" : {
-          "type" : "string",
-          "description" : "template for user search for authentication (e.g. dc=hadoop,dc=apache,dc=org)"
-        },
-        "groupSearchBase" : {
-          "type" : "string",
-          "description" : "template for group search for authorization (e.g. dc=hadoop,dc=apache,dc=org)"
-        },
-        "userNameAttribute" : {
-          "type" : "string",
-          "description" : "attribute name for simplified search filter (e.g. sAMAccountName in case of AD, UID or cn for LDAP)."
-        },
-        "domain" : {
-          "type" : "string",
-          "description" : "domain in LDAP server (e.g. ad.seq.com)."
-        },
-        "directoryType" : {
-          "type" : "string",
-          "description" : "directory type of server LDAP or AD",
-          "enum" : [ "LDAP", "ACTIVE_DIRECTORY" ]
-        },
-        "userObjectClass" : {
-          "type" : "string",
-          "description" : "User Object Class (defaults to person)"
-        },
-        "groupObjectClass" : {
-          "type" : "string",
-          "description" : "Group Object Class (defaults to groupOfNames)"
-        },
-        "groupNameAttribute" : {
-          "type" : "string",
-          "description" : "Group Id Attribute (defaults to cn)"
-        },
-        "groupMemberAttribute" : {
-          "type" : "string",
-          "description" : "Group Member Attribute (defaults to member)"
-        },
-        "name" : {
-          "type" : "string",
-          "description" : "name of the resource",
-          "minLength" : 1,
-          "maxLength" : 100
-        },
-        "bindPassword" : {
-          "type" : "string",
-          "description" : "password for the provided bind DN"
-        }
-      }
-    },
-    "ClusterRepairRequest" : {
-      "type" : "object",
-      "required" : [ "hostGroups" ],
-      "properties" : {
-        "hostGroups" : {
-          "type" : "array",
-          "description" : "List of hostgroups where the failed nodes will be repaired",
-          "items" : {
-            "type" : "string"
-          }
-        },
-        "removeOnly" : {
-          "type" : "boolean",
-          "description" : "If true, the failed nodes will only be removed, otherwise the failed nodes will be removed and new nodes will be started.",
-          "default" : false
-        }
-      }
-    },
-    "StackResponse" : {
-      "type" : "object",
-      "required" : [ "name" ],
-      "properties" : {
-        "name" : {
-          "type" : "string",
-          "description" : "name of the stack",
-          "minLength" : 5,
-          "maxLength" : 40,
-          "pattern" : "([a-z][-a-z0-9]*[a-z0-9])"
-        },
-        "availabilityZone" : {
-          "type" : "string",
-          "description" : "availability zone of the stack"
-        },
-        "region" : {
-          "type" : "string",
-          "description" : "region of the stack"
-        },
-        "platformVariant" : {
-          "type" : "string",
-          "description" : "cloud provider api variant"
-        },
-        "credentialId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "credential resource id for the stack"
-        },
-        "onFailureAction" : {
-          "type" : "string",
-          "description" : "action on failure",
-          "enum" : [ "ROLLBACK", "DO_NOTHING" ]
-        },
-        "networkId" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "network resource id for the stack"
-        },
-        "ambariVersion" : {
-          "type" : "string",
-          "description" : "specific version of ambari"
-        },
-        "hdpVersion" : {
-          "type" : "string",
-          "description" : "specific version of HDP"
-        },
-        "parameters" : {
-          "type" : "object",
-          "description" : "additional cloud specific parameters for stack",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "customDomain" : {
-          "type" : "string",
-          "description" : "custom domain name for the nodes in the stack"
-        },
-        "customHostname" : {
-          "type" : "string",
-          "description" : "custom hostname for nodes in the stack"
-        },
-        "clusterNameAsSubdomain" : {
-          "type" : "boolean",
-          "description" : "using the cluster name to create subdomain",
-          "default" : false
-        },
-        "hostgroupNameAsHostname" : {
-          "type" : "boolean",
-          "description" : "using the hostgroup names to create hostnames",
-          "default" : false
-        },
-        "applicationTags" : {
-          "type" : "object",
-          "description" : "stack related application tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "userDefinedTags" : {
-          "type" : "object",
-          "description" : "stack related userdefined tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "defaultTags" : {
-          "type" : "object",
-          "description" : "stack related default tags",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        },
-        "id" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "id of the stack"
-        },
-        "owner" : {
-          "type" : "string",
-          "description" : "id of the resource owner that is provided by OAuth provider"
-        },
-        "account" : {
-          "type" : "string",
-          "description" : "account id of the resource owner that is provided by OAuth provider"
-        },
-        "status" : {
-          "type" : "string",
-          "description" : "status of the stack",
-          "enum" : [ "REQUESTED", "CREATE_IN_PROGRESS", "AVAILABLE", "UPDATE_IN_PROGRESS", "UPDATE_REQUESTED", "UPDATE_FAILED", "CREATE_FAILED", "ENABLE_SECURITY_FAILED", "DELETE_IN_PROGRESS", "DELETE_FAILED", "DELETE_COMPLETED", "STOPPED", "STOP_REQUESTED", "START_REQUESTED", "STOP_IN_PROGRESS", "START_IN_PROGRESS", "START_FAILED", "STOP_FAILED", "WAIT_FOR_SYNC" ]
-        },
-        "cluster" : {
-          "$ref" : "#/definitions/ClusterResponse"
-        },
-        "statusReason" : {
-          "type" : "string",
-          "description" : "status message of the stack"
-        },
-        "credential" : {
-          "description" : "stack related credential",
-          "$ref" : "#/definitions/CredentialResponse"
-        },
-        "network" : {
-          "description" : "stack related network",
-          "$ref" : "#/definitions/NetworkResponse"
-        },
-        "instanceGroups" : {
-          "type" : "array",
-          "items" : {
-            "$ref" : "#/definitions/InstanceGroupResponse"
-          }
-        },
-        "failurePolicy" : {
-          "description" : "failure policy in case of failures",
-          "$ref" : "#/definitions/FailurePolicyResponse"
-        },
-        "orchestrator" : {
-          "description" : "the details of the container orchestrator api to use",
-          "$ref" : "#/definitions/OrchestratorResponse"
-        },
-        "created" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "creation time of the stack in long"
-        },
-        "gatewayPort" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "port of the gateway secured proxy"
-        },
-        "image" : {
-          "description" : "image of the stack",
-          "$ref" : "#/definitions/ImageJson"
-        },
-        "cloudbreakDetails" : {
-          "description" : "details of the Cloudbreak that provisioned the stack",
-          "$ref" : "#/definitions/CloudbreakDetailsJson"
-        },
-        "flexSubscription" : {
-          "description" : "the related flex subscription",
-          "$ref" : "#/definitions/FlexSubscriptionResponse"
-        },
-        "stackAuthentication" : {
-          "description" : "stack related authentication",
-          "$ref" : "#/definitions/StackAuthenticationResponse"
-        },
-        "nodeCount" : {
-          "type" : "integer",
-          "format" : "int32",
-          "description" : "node count of the stack"
-        },
-        "hardwareInfos" : {
-          "type" : "array",
-          "description" : "hardware information where pairing hostmetadata with instancemetadata",
-          "uniqueItems" : true,
-          "items" : {
-            "$ref" : "#/definitions/HardwareInfoResponse"
-          }
-        },
-        "cloudbreakEvents" : {
-          "type" : "array",
-          "description" : "related events for a cloudbreak stack",
-          "items" : {
-            "$ref" : "#/definitions/CloudbreakEvent"
-          }
-        },
-        "cloudbreakUsages" : {
-          "type" : "array",
-          "description" : "usage information for a specific stack",
-          "items" : {
-            "$ref" : "#/definitions/CloudbreakUsage"
-          }
-        },
-        "cloudPlatform" : {
-          "type" : "string",
-          "description" : "type of cloud provider",
-          "readOnly" : true
-        },
-        "public" : {
-          "type" : "boolean",
-          "description" : "resource is visible in account",
-          "default" : false
-        }
-      }
-    },
-    "AccountPreference" : {
-      "type" : "object",
-      "required" : [ "clusterTimeToLive", "userTimeToLive" ],
-      "properties" : {
-        "maxNumberOfClusters" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "max number of clusters in the account (0 when unlimited)",
-          "minimum" : 0.0
-        },
-        "maxNumberOfNodesPerCluster" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "max number of vms in a cluster of account (0 when unlimited)",
-          "minimum" : 0.0
-        },
-        "maxNumberOfClustersPerUser" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "max number of clusters for user within the account (0 when unlimited)",
-          "minimum" : 0.0
-        },
-        "allowedInstanceTypes" : {
-          "type" : "array",
-          "description" : "allowed instance types in the account (empty list for no restriction)",
-          "items" : {
-            "type" : "string"
-          }
-        },
-        "clusterTimeToLive" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "lifecycle of the cluster in hours (0 for immortal clusters)",
-          "minimum" : 0.0
-        },
-        "userTimeToLive" : {
-          "type" : "integer",
-          "format" : "int64",
-          "description" : "lifecycle of the account and its clusters in hours (0 for immortal account)",
-          "minimum" : 0.0
-        },
-        "platforms" : {
-          "type" : "string",
-          "description" : "list of the cloudplatforms visible on the UI"
-        },
-        "defaultTags" : {
-          "type" : "object",
-          "description" : "default tags for the resources created",
-          "additionalProperties" : {
-            "type" : "string"
-          }
-        }
-      }
-    }
-  }
-}
diff --git a/fixtures/bugs/1277/fixture-1277.json b/fixtures/bugs/1277/fixture-cloudbreak-1277.json
similarity index 100%
rename from fixtures/bugs/1277/fixture-1277.json
rename to fixtures/bugs/1277/fixture-cloudbreak-1277.json
diff --git a/fixtures/bugs/1277/gen-fixtures.sh b/fixtures/bugs/1277/gen-fixtures.sh
index 30d40683..05281f20 100755
--- a/fixtures/bugs/1277/gen-fixtures.sh
+++ b/fixtures/bugs/1277/gen-fixtures.sh
@@ -3,7 +3,7 @@ if [[ ${1} == "--clean" ]] ; then
     clean=1
 fi
 # A small utility to build fixture servers
-testcases="fixture-1277.json"
+testcases="fixture-cloudbreak-1277.json"
 for testcase in ${testcases} ; do
     target=gen-${testcase%.json}
     spec=./${testcase}
diff --git a/fixtures/bugs/1487/fixture-allOf-flat.yaml b/fixtures/bugs/1487/fixture-allOf-flat.yaml
deleted file mode 100644
index 5b62d5c4..00000000
--- a/fixtures/bugs/1487/fixture-allOf-flat.yaml
+++ /dev/null
@@ -1,392 +0,0 @@
----
-  consumes: 
-    - "application/json"
-  produces: 
-    - "application/json"
-  swagger: "2.0"
-  info: 
-    description: "A test of enum validation generation for tuples and additionalItems.\nDerived from fixtures/codegen/todolist.enum.yml\n"
-    title: "fixture for enums with additional"
-    version: "1.0.0"
-  paths: 
-    /models: 
-      get: 
-        description: "Used to see if a codegen can render all the possible enum categories"
-        tags: 
-          - "testcgen"
-        summary: "many model variations"
-        operationId: "modelOp"
-        parameters: 
-          - 
-            name: "manyThings"
-            in: "body"
-            schema: 
-              $ref: "#/definitions/allThingsNested"
-        responses: 
-          default: 
-            description: "Generic Out"
-            schema: 
-              $ref: "#/definitions/allThings"
-  definitions: 
-    aliasedDate: 
-      type: "string"
-      format: "date"
-    aliasedNullableDate: 
-      type: "string"
-      format: "date"
-      x-nullable: true
-    allThings: 
-      type: "object"
-      allOf: 
-        - 
-          $ref: "#/definitions/allThingsAllOf0"
-        - 
-          $ref: "#/definitions/allThingsAllOf1"
-        - 
-          $ref: "#/definitions/allThingsAllOf2"
-        - 
-          $ref: "#/definitions/allThingsAllOf3"
-        - 
-          $ref: "#/definitions/allThingsAllOf4"
-        - 
-          $ref: "#/definitions/allThingsAllOf5"
-        - 
-          $ref: "#/definitions/allThingsAllOf6"
-        - 
-          $ref: "#/definitions/allThingsAllOf7"
-        - 
-          $ref: "#/definitions/allThingsAllOf8"
-        - 
-          $ref: "#/definitions/allThingsAllOf9"
-    allThingsAllOf0: 
-      type: "object"
-      required: 
-        - "origin"
-      properties: 
-        additionalProperties: 
-          type: "string"
-          enum: 
-            - "bookshop"
-            - "amazon"
-            - "library"
-        origin: 
-          type: "string"
-          enum: 
-            - "print"
-            - "e-book"
-            - "collection"
-            - "museum"
-        status: 
-          type: "string"
-          enum: 
-            - "OK"
-            - "KO"
-      x-go-gen-location: "models"
-    allThingsAllOf1: 
-      type: "object"
-      properties: 
-        mockId: 
-          type: "number"
-      additionalProperties: 
-        $ref: "#/definitions/allThingsAllOf1AdditionalProperties"
-      x-go-gen-location: "models"
-    allThingsAllOf1AdditionalProperties: 
-      type: "object"
-      required: 
-        - "mockB"
-      properties: 
-        mockA: 
-          type: "string"
-          pattern: "^[A-Z]$"
-        mockB: 
-          type: "string"
-          minLength: 1
-        mockC: 
-          type: "number"
-      x-go-gen-location: "models"
-    allThingsAllOf2: 
-      type: "object"
-      properties: 
-        origin2: 
-          type: "string"
-          enum: 
-            - "goPrint"
-            - "goE-book"
-            - "goCollection"
-            - "goMuseum"
-      additionalProperties: 
-        $ref: "#/definitions/allThingsAllOf2AdditionalProperties"
-      x-go-gen-location: "models"
-    allThingsAllOf2AdditionalProperties: 
-      type: "object"
-      properties: 
-        printerAddress: 
-          type: "string"
-        printerCountry: 
-          type: "string"
-          enum: 
-            - "US"
-            - "FR"
-            - "UK"
-            - "BE"
-            - "CA"
-            - "DE"
-        printerDate: 
-          type: "string"
-          format: "date"
-      additionalProperties: 
-        $ref: "#/definitions/allThingsAllOf2AdditionalPropertiesAdditionalProperties"
-      x-go-gen-location: "models"
-    allThingsAllOf2AdditionalPropertiesAdditionalProperties: 
-      type: "object"
-      properties: 
-        averageDelay: 
-          type: "string"
-          format: "duration"
-      x-go-gen-location: "models"
-    allThingsAllOf3: 
-      type: "object"
-      properties: 
-        discourse: 
-          type: "string"
-        hoursSpent: 
-          type: "number"
-      additionalProperties: true
-      x-go-gen-location: "models"
-    allThingsAllOf4: 
-      type: "object"
-      properties: 
-        blob: 
-          type: "integer"
-          minimum: 1
-      additionalProperties: 
-        $ref: "#/definitions/aliasedDate"
-      x-go-gen-location: "models"
-    allThingsAllOf5: 
-      type: "object"
-      properties: 
-        blob2: 
-          type: "integer"
-          minimum: 1
-      additionalProperties: 
-        $ref: "#/definitions/aliasedNullableDate"
-      x-go-gen-location: "models"
-    allThingsAllOf6: 
-      type: "object"
-      properties: 
-        nullableDate: 
-          $ref: "#/definitions/aliasedNullableDate"
-      x-go-gen-location: "models"
-    allThingsAllOf7: 
-      type: "object"
-      properties: 
-        blob3: 
-          type: "integer"
-          minimum: 1
-      additionalProperties: 
-        $ref: "#/definitions/aliasedNullableDate"
-      x-go-gen-location: "models"
-    allThingsAllOf8: 
-      type: "object"
-      required: 
-        - "blob4"
-      properties: 
-        blob4: 
-          type: "integer"
-          minimum: 1
-      additionalProperties: 
-        type: "string"
-        format: "date"
-      x-go-gen-location: "models"
-    allThingsAllOf9: 
-      type: "object"
-      properties: 
-        thisOneNotRequired: 
-          type: "integer"
-          maximum: 10
-      additionalProperties: 
-        type: "array"
-        uniqueItems: true
-        items: 
-          type: "string"
-          format: "uuid"
-      x-go-gen-location: "models"
-    allThingsNested: 
-      type: "object"
-      allOf: 
-        - 
-          $ref: "#definitions/allThings"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf1"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf2"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf3"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf4"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf5"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf6"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf7"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf8"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf9"
-        - 
-          $ref: "#/definitions/allThingsNestedAllOf10"
-    allThingsNestedAllOf1: 
-      type: "object"
-      required: 
-        - "origin"
-      properties: 
-        additionalProperties: 
-          type: "string"
-          enum: 
-            - "bookshop"
-            - "amazon"
-            - "library"
-        origin: 
-          type: "string"
-          enum: 
-            - "print"
-            - "e-book"
-            - "collection"
-            - "museum"
-        status: 
-          type: "string"
-          enum: 
-            - "OK"
-            - "KO"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf10: 
-      type: "object"
-      properties: 
-        thisOneNotRequired: 
-          type: "integer"
-          maximum: 10
-      additionalProperties: 
-        type: "array"
-        uniqueItems: true
-        items: 
-          type: "string"
-          format: "uuid"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf2: 
-      type: "object"
-      properties: 
-        mockId: 
-          type: "number"
-      additionalProperties: 
-        $ref: "#/definitions/allThingsNestedAllOf2AdditionalProperties"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf2AdditionalProperties: 
-      type: "object"
-      required: 
-        - "mockB"
-      properties: 
-        mockA: 
-          type: "string"
-          pattern: "^[A-Z]$"
-        mockB: 
-          type: "string"
-          minLength: 1
-        mockC: 
-          type: "number"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf3: 
-      type: "object"
-      properties: 
-        origin2: 
-          type: "string"
-          enum: 
-            - "goPrint"
-            - "goE-book"
-            - "goCollection"
-            - "goMuseum"
-      additionalProperties: 
-        $ref: "#/definitions/allThingsNestedAllOf3AdditionalProperties"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf3AdditionalProperties: 
-      type: "object"
-      properties: 
-        printerAddress: 
-          type: "string"
-        printerCountry: 
-          type: "string"
-          enum: 
-            - "US"
-            - "FR"
-            - "UK"
-            - "BE"
-            - "CA"
-            - "DE"
-        printerDate: 
-          type: "string"
-          format: "date"
-      additionalProperties: 
-        $ref: "#/definitions/allThingsNestedAllOf3AdditionalPropertiesAdditionalProperties"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf3AdditionalPropertiesAdditionalProperties: 
-      type: "object"
-      properties: 
-        averageDelay: 
-          type: "string"
-          format: "duration"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf4: 
-      type: "object"
-      properties: 
-        discourse: 
-          type: "string"
-        hoursSpent: 
-          type: "number"
-      additionalProperties: true
-      x-go-gen-location: "models"
-    allThingsNestedAllOf5: 
-      type: "object"
-      properties: 
-        blob: 
-          type: "integer"
-          minimum: 1
-      additionalProperties: 
-        $ref: "#/definitions/aliasedDate"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf6: 
-      type: "object"
-      properties: 
-        blob2: 
-          type: "integer"
-          minimum: 1
-      additionalProperties: 
-        $ref: "#/definitions/aliasedNullableDate"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf7: 
-      type: "object"
-      properties: 
-        nullableDate: 
-          $ref: "#/definitions/aliasedNullableDate"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf8: 
-      type: "object"
-      properties: 
-        blob3: 
-          type: "integer"
-          minimum: 1
-      additionalProperties: 
-        $ref: "#/definitions/aliasedNullableDate"
-      x-go-gen-location: "models"
-    allThingsNestedAllOf9: 
-      type: "object"
-      required: 
-        - "blob4"
-      properties: 
-        blob4: 
-          type: "integer"
-          minimum: 1
-      additionalProperties: 
-        type: "string"
-        format: "date"
-      x-go-gen-location: "models"
-
diff --git a/fixtures/bugs/1487/gen-fixtures.sh b/fixtures/bugs/1487/gen-fixtures.sh
index 67058dd5..cae17afa 100755
--- a/fixtures/bugs/1487/gen-fixtures.sh
+++ b/fixtures/bugs/1487/gen-fixtures.sh
@@ -34,23 +34,29 @@ testcases="${testcases} ../1277/cloudbreak.json"
 testcases="${testcases} ../../codegen/todolist.schemavalidation.yml"
 testcases="${testcases} ../../codegen/todolist.discriminators.yml"
 testcases="${testcases} ../../codegen/billforward.discriminators.yml"
-#export SWAGGER_DEBUG=1
-for opts in  "" "--skip-flatten" ; do
+
+# Generation options
+fullFlatten="--with-flatten=full"
+withExpand="--with-expand"
+minimal="--with-flatten=minimal"
+for opts in ${fullFlatten} ${withExpand} ${minimal} ; do
 for testcase in ${testcases} ; do
     grep -q discriminator ${testcase}
     discriminated=$?
-    if [[ ${discriminated} -eq 0 && ${opts} == "--skip-flatten" ]] ; then
+    if [[ ${discriminated} -eq 0 && ${opts} == ${withExpand} ]] ; then
         echo "Skipped ${testcase} with ${opts}: discriminator not supported with ${opts}"
         continue
     fi
-    if [[ ${testcase} == "../1479/fixture-1479-part.yaml" && ${opts} == "--skip-flatten" ]] ; then
+    if [[ ${testcase} == "../1479/fixture-1479-part.yaml" && ${opts} == ${withExpand} ]] ; then
         echo "Skipped ${testcase} with ${opts}: known issue with enum in anonymous allOf not validated. See you next PR"
         continue
     fi
 
     spec=${testcase}
     testcase=`basename ${testcase}`
-    if [[ -z ${opts} ]]; then
+    if [[ -z ${opts} || ${opts} == ${minimal} ]] ; then
+        target=./gen-${testcase%.*}-minimal
+    elif [[ ${opts} ==  ${fullFlatten} ]] ; then
         target=./gen-${testcase%.*}-flatten
     else
         target=./gen-${testcase%.*}-expand
diff --git a/fixtures/bugs/1513/enums.yaml b/fixtures/bugs/1513/enums.yaml
index 82d8e011..7e5ee207 100644
--- a/fixtures/bugs/1513/enums.yaml
+++ b/fixtures/bugs/1513/enums.yaml
@@ -6,7 +6,7 @@ paths:
 
   /example:
     put:
-      operationid: put-enum
+      operationId: put-enum
       parameters:
       - name: "something"
         in: "body"
diff --git a/fixtures/bugs/1536/gen-fixtures.sh b/fixtures/bugs/1536/gen-fixtures.sh
index e3ae005f..006a2b2d 100755
--- a/fixtures/bugs/1536/gen-fixtures.sh
+++ b/fixtures/bugs/1536/gen-fixtures.sh
@@ -14,15 +14,15 @@ testcases="${testcases} fixture-1536-2-responses.yaml"
 testcases="${testcases} ../../codegen/instagram.yml"
 testcases="${testcases} ../../codegen/todolist.responses.yml"
 testcases="${testcases} fixture-1536-models.yaml"
-for opts in  "" "--skip-flatten" ; do
+for opts in  "" "--with-expand" ; do
 for testcase in ${testcases} ; do
     grep -q discriminator ${testcase}
     discriminated=$?
-    if [[ ${discriminated} -eq 0 && ${opts} == "--skip-flatten" ]] ; then
+    if [[ ${discriminated} -eq 0 && ${opts} == "--with-expand" ]] ; then
         echo "Skipped ${testcase} with ${opts}: discriminator not supported with ${opts}"
         continue
     fi
-    if [[ ${testcase} == "../1479/fixture-1479-part.yaml" && ${opts} == "--skip-flatten" ]] ; then
+    if [[ ${testcase} == "../1479/fixture-1479-part.yaml" && ${opts} == "--with-expand" ]] ; then
         echo "Skipped ${testcase} with ${opts}: known issue with enum in anonymous allOf not validated. See you next PR"
         continue
     fi
diff --git a/fixtures/bugs/844/swagger-bis.json b/fixtures/bugs/844/swagger-bis.json
new file mode 100644
index 00000000..6c10d846
--- /dev/null
+++ b/fixtures/bugs/844/swagger-bis.json
@@ -0,0 +1,57 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "anyOf bug",
+    "version": "0.0.1",
+    "description": "repro",
+    "license": {
+      "name": "Apache 2.0",
+      "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
+    }
+  },
+  "definitions": {
+    "foo": {
+      "type": "object"
+    },
+    "bar": {
+      "type": "object"
+    }
+  },
+  "paths": {
+    "/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "getAllOfInBody",
+            "in": "body",
+            "schema": {
+                "allOf": [
+                    {
+                        "$ref": "#/definitions/foo"
+                    },
+                    {
+                        "$ref": "#/definitions/bar"
+                    }
+                ]
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "OK",
+            "schema": {
+                "allOf": [
+                    {
+                        "$ref": "#/definitions/foo"
+                    },
+                    {
+                        "$ref": "#/definitions/bar"
+                    }
+                ]
+            }
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/fixtures/enhancements/1572/.gitignore b/fixtures/enhancements/1572/.gitignore
new file mode 100644
index 00000000..1e16265b
--- /dev/null
+++ b/fixtures/enhancements/1572/.gitignore
@@ -0,0 +1,3 @@
+gen-*
+!gen-fixtures.sh
+*.log
diff --git a/fixtures/enhancements/1572/fixture-1572.yaml b/fixtures/enhancements/1572/fixture-1572.yaml
new file mode 100644
index 00000000..87e65d59
--- /dev/null
+++ b/fixtures/enhancements/1572/fixture-1572.yaml
@@ -0,0 +1,101 @@
+swagger: "2.0"
+info: 
+  title: "edge cases for operations schemas"
+  version: "0.0.1"
+  description: |
+      Run the following test caes and exercise the minimal flatten mode:
+        - [x] nil schema in body param / response
+        - [x] interface{} in body param /response
+        - [x] additional schema reused from model (body param and response) (with maps or arrays)
+        - [x] primitive body / response
+        - [x] $ref'ed response and param (check that minimal flatten expands it)
+        - [] x-go-name in inline operation schema (body param and response)
+
+  license: 
+    name: "Apache 2.0"
+    url: "http://www.apache.org/licenses/LICENSE-2.0.html"
+
+parameters:
+  ref1:
+    name: nullBody
+    in: body
+    required: true
+    # null schema: invalid spec
+    # empty schema
+    #schema: {}
+
+responses:
+  resp1:
+    description: "OK"
+    schema:
+      type: object
+      additionalProperties: true
+
+definitions: 
+  modelInterface:
+    type: object
+    additionalProperties: true
+paths: 
+  /getNull: 
+    get:
+      operationId: getNull
+      parameters:
+        - $ref: '#/parameters/ref1'
+      responses: 
+        200: 
+          $ref: '#/responses/resp1'
+        203: 
+          description: "OK"
+          # null schema
+  /getInterface: 
+    get: 
+      operationId: getInterface
+      parameters:
+        - name: interfaceBody
+          in: body
+          required: true
+          schema:
+            type: object
+            additionalProperties: true
+      responses: 
+        200: 
+          description: "OK"
+          schema:
+            type: object
+            additionalProperties: true
+  /getModelInterface: 
+    get: 
+      operationId: getModelInterface
+      parameters:
+        - name: interfaceBody
+          in: body
+          required: true
+          schema:
+            type: object
+            additionalProperties:
+              $ref: '#/definitions/modelInterface'
+      responses: 
+        200: 
+          description: "OK"
+          schema:
+            type: array
+            items:
+              $ref: '#/definitions/modelInterface'
+  /getPrimitive: 
+    get: 
+      operationId: getPrimitive
+      parameters:
+        - name: primitiveBody
+          in: body
+          required: true
+          schema:
+            type: integer
+            format: uint32
+            maximum: 100
+      responses: 
+        200: 
+          description: "OK"
+          schema:
+            type: number
+            format: float
+            maximum: 100
diff --git a/fixtures/enhancements/1572/fixture-deepMaps.yaml b/fixtures/enhancements/1572/fixture-deepMaps.yaml
new file mode 100644
index 00000000..6fb66779
--- /dev/null
+++ b/fixtures/enhancements/1572/fixture-deepMaps.yaml
@@ -0,0 +1,61 @@
+swagger: '2.0'
+info:
+  version: "1.0.0"
+  title: 'issue 1232'
+  description: verifies marshalling code on discriminated type
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /sanity:
+    get:
+      operationId: getSanity
+      description: no description
+      parameters:
+      - name: sanityParam
+        in: body
+        schema:
+          $ref: '#/definitions/ModelObjectVanilla'
+      responses:
+        default:
+          description: Generic Out
+          schema:
+            $ref: '#/definitions/ModelObjectVanilla'
+definitions:
+  ModelObjectVanilla:
+    type: object
+    required:
+      - prop1
+    properties:
+      prop0:
+        $ref: '#/definitions/ModelSanity'
+      prop1:
+        $ref: '#/definitions/ModelSanity'
+      prop2:
+        type: array
+        items:
+          $ref: '#/definitions/ModelSanity'
+      prop3:
+        $ref: '#/definitions/ModelSanity'
+      prop4:
+        type: object
+        additionalProperties:
+          $ref: '#/definitions/ModelSanity'
+      prop5:
+        type: integer
+    additionalProperties:
+      type: object
+      additionalProperties:
+        type: object
+        additionalProperties:
+          $ref: '#/definitions/ModelSanity'
+  ModelSanity:
+    type: object
+    required:
+    - propB
+    properties:
+      propA:
+        type: string
+      propB:
+        type: string
diff --git a/fixtures/enhancements/1572/gen-fixtures.sh b/fixtures/enhancements/1572/gen-fixtures.sh
new file mode 100755
index 00000000..42703456
--- /dev/null
+++ b/fixtures/enhancements/1572/gen-fixtures.sh
@@ -0,0 +1,70 @@
+#! /bin/bash 
+if [[ ${1} == "--clean" ]] ; then
+    clean=1
+fi
+continueOnError=
+# A small utility to build fixture servers
+testcases="${testcases} fixture-1572.yaml"
+testcases="${testcases} fixture-deepMaps.yaml"
+for opts in  "" "--with-flatten=full" "--with-expand" ; do
+for testcase in ${testcases} ; do
+    grep -q discriminator ${testcase}
+    discriminated=$?
+    if [[ ${discriminated} -eq 0 && ${opts} == "--with-expand" ]] ; then
+        echo "Skipped ${testcase} with ${opts}: discriminator not supported with ${opts}"
+        continue
+    fi
+    spec=${testcase}
+    testcase=`basename ${testcase}`
+    if [[ -z ${opts} ]]; then
+        target=./gen-${testcase%.*}-minimal
+    elif [[ ${opts} == "--with-flatten=full" ]] ; then
+        target=./gen-${testcase%.*}-flatten
+    else
+        target=./gen-${testcase%.*}-expand
+    fi
+    serverName="codegensrv"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Server generation for ${spec} with opts=${opts}"
+    serverName="nrcodegen"
+    swagger generate server --skip-validation ${opts} --spec ${spec} --target ${target} --name=${serverName} 1>${testcase%.*}.log 2>&1
+    #
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        if [[ ! -z ${continueOnError} ]] ; then
+            failures="${failures} codegen:${spec}"
+            continue
+        else
+            exit 1
+        fi
+    fi
+    echo "${spec}: Generation OK"
+    if [[ ! -d ${target}/models ]] ; then
+        echo "No model in this spec! Continue building server"
+    fi
+    if [[ -d ${target}/cmd/${serverName}"-server" ]] ; then
+        (cd ${target}/cmd/${serverName}"-server"; go build)
+        #(cd ${target}/models; go build)
+        if [[ $? != 0 ]] ; then
+            echo "Build failed for ${spec}"
+            if [[ ! -z ${continueOnError} ]] ; then
+                failures="${failures} build:${spec}"
+                continue
+            else
+                exit 1
+            fi
+        fi
+        echo "${spec}: Build OK"
+        if [[ -n ${clean} ]] ; then 
+             rm -rf ${target}
+        fi
+    fi
+done
+done
+if [[ ! -z ${failures} ]] ; then 
+    echo ${failures}|tr ' ' '\n'
+else
+    echo "No failures"
+fi
+exit
diff --git a/generator/build_test.go b/generator/build_test.go
index 61a13d22..1c1fde5b 100644
--- a/generator/build_test.go
+++ b/generator/build_test.go
@@ -27,6 +27,9 @@ func TestGenerateAndBuild(t *testing.T) {
 		"issue 844": {
 			"../fixtures/bugs/844/swagger.json",
 		},
+		"issue 844 (with params)": {
+			"../fixtures/bugs/844/swagger-bis.json",
+		},
 		"issue 1216": {
 			"../fixtures/bugs/1216/swagger.yml",
 		},
@@ -43,7 +46,7 @@ func TestGenerateAndBuild(t *testing.T) {
 			if err != nil {
 				t.Fatalf("TempDir()=%s", generated)
 			}
-			defer os.RemoveAll(generated)
+			defer func() { _ = os.RemoveAll(generated) }()
 
 			err = newTestClient(spec, generated).Execute(nil)
 			if err != nil {
diff --git a/generator/client_test.go b/generator/client_test.go
index 39cf49fa..eebc7b0b 100644
--- a/generator/client_test.go
+++ b/generator/client_test.go
@@ -24,6 +24,9 @@ import (
 )
 
 func TestClient_InvalidSpec(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/825/swagger.yml"
 	opts.ValidateSpec = true
@@ -37,7 +40,7 @@ func TestClient_BaseImportDisabled(t *testing.T) {
 	}
 	log.SetOutput(ioutil.Discard)
 	defer func() {
-		os.RemoveAll(targetdir)
+		_ = os.RemoveAll(targetdir)
 		log.SetOutput(os.Stdout)
 	}()
 	opts := testGenOpts()
diff --git a/generator/config.go b/generator/config.go
index 9b9b8edc..2d941321 100644
--- a/generator/config.go
+++ b/generator/config.go
@@ -38,7 +38,7 @@ func ReadConfig(fpath string) (*viper.Viper, error) {
 		if err != nil {
 			return nil, err
 		}
-		defer file.Close()
+		defer func() { _ = file.Close() }()
 		ext := filepath.Ext(fpath)
 		if len(ext) > 0 {
 			ext = ext[1:]
diff --git a/generator/formats.go b/generator/formats.go
index 297d1582..9454fff4 100644
--- a/generator/formats.go
+++ b/generator/formats.go
@@ -149,55 +149,55 @@ var typeMapping = map[string]string{
 
 // go primitive types
 var primitives = map[string]struct{}{
-	"bool":       struct{}{},
-	"byte":       struct{}{},
-	"[]byte":     struct{}{},
-	"complex64":  struct{}{},
-	"complex128": struct{}{},
-	"float32":    struct{}{},
-	"float64":    struct{}{},
-	"int":        struct{}{},
-	"int8":       struct{}{},
-	"int16":      struct{}{},
-	"int32":      struct{}{},
-	"int64":      struct{}{},
-	"rune":       struct{}{},
-	"string":     struct{}{},
-	"uint":       struct{}{},
-	"uint8":      struct{}{},
-	"uint16":     struct{}{},
-	"uint32":     struct{}{},
-	"uint64":     struct{}{},
+	"bool":       {},
+	"byte":       {},
+	"[]byte":     {},
+	"complex64":  {},
+	"complex128": {},
+	"float32":    {},
+	"float64":    {},
+	"int":        {},
+	"int8":       {},
+	"int16":      {},
+	"int32":      {},
+	"int64":      {},
+	"rune":       {},
+	"string":     {},
+	"uint":       {},
+	"uint8":      {},
+	"uint16":     {},
+	"uint32":     {},
+	"uint64":     {},
 }
 
 // Formats with a custom formatter.
 // Currently, 23 such formats are supported
 var customFormatters = map[string]struct{}{
-	"strfmt.Base64":     struct{}{},
-	"strfmt.CreditCard": struct{}{},
-	"strfmt.Date":       struct{}{},
-	"strfmt.DateTime":   struct{}{},
-	"strfmt.Duration":   struct{}{},
-	"strfmt.Email":      struct{}{},
-	"strfmt.HexColor":   struct{}{},
-	"strfmt.Hostname":   struct{}{},
-	"strfmt.IPv4":       struct{}{},
-	"strfmt.IPv6":       struct{}{},
-	"strfmt.ISBN":       struct{}{},
-	"strfmt.ISBN10":     struct{}{},
-	"strfmt.ISBN13":     struct{}{},
-	"strfmt.MAC":        struct{}{},
-	"strfmt.ObjectId":   struct{}{},
-	"strfmt.Password":   struct{}{},
-	"strfmt.RGBColor":   struct{}{},
-	"strfmt.SSN":        struct{}{},
-	"strfmt.URI":        struct{}{},
-	"strfmt.UUID":       struct{}{},
-	"strfmt.UUID3":      struct{}{},
-	"strfmt.UUID4":      struct{}{},
-	"strfmt.UUID5":      struct{}{},
+	"strfmt.Base64":     {},
+	"strfmt.CreditCard": {},
+	"strfmt.Date":       {},
+	"strfmt.DateTime":   {},
+	"strfmt.Duration":   {},
+	"strfmt.Email":      {},
+	"strfmt.HexColor":   {},
+	"strfmt.Hostname":   {},
+	"strfmt.IPv4":       {},
+	"strfmt.IPv6":       {},
+	"strfmt.ISBN":       {},
+	"strfmt.ISBN10":     {},
+	"strfmt.ISBN13":     {},
+	"strfmt.MAC":        {},
+	"strfmt.ObjectId":   {},
+	"strfmt.Password":   {},
+	"strfmt.RGBColor":   {},
+	"strfmt.SSN":        {},
+	"strfmt.URI":        {},
+	"strfmt.UUID":       {},
+	"strfmt.UUID3":      {},
+	"strfmt.UUID4":      {},
+	"strfmt.UUID5":      {},
 	// the following interfaces do not generate validations
-	"io.ReadCloser": struct{}{}, // for "format": "binary" (server side)
-	"io.Writer":     struct{}{}, // for "format": "binary" (client side)
+	"io.ReadCloser": {}, // for "format": "binary" (server side)
+	"io.Writer":     {}, // for "format": "binary" (client side)
 	// NOTE: runtime.File is not a customFormatter
 }
diff --git a/generator/model.go b/generator/model.go
index bde91610..349fd212 100644
--- a/generator/model.go
+++ b/generator/model.go
@@ -1163,6 +1163,7 @@ func (mt *mapStack) HasMore() bool {
 	return mt.Type.AdditionalProperties != nil && (mt.Type.AdditionalProperties.Schema != nil || mt.Type.AdditionalProperties.Allows)
 }
 
+/* currently unused:
 func (mt *mapStack) Dict() map[string]interface{} {
 	res := make(map[string]interface{})
 	res["context"] = mt.Context.Schema
@@ -1177,6 +1178,7 @@ func (mt *mapStack) Dict() map[string]interface{} {
 	}
 	return res
 }
+*/
 
 func (sg *schemaGenContext) buildAdditionalProperties() error {
 	if sg.Schema.AdditionalProperties == nil {
@@ -1868,6 +1870,13 @@ func (sg *schemaGenContext) makeGenSchema() error {
 		return e
 	}
 
+	// rewrite value expression from top-down
+	cur := &sg.GenSchema
+	for cur.AdditionalProperties != nil {
+		cur.AdditionalProperties.ValueExpression = cur.ValueExpression + "[" + cur.AdditionalProperties.KeyVar + "]"
+		cur = cur.AdditionalProperties
+	}
+
 	prev := sg.GenSchema
 	if sg.Untyped {
 		if Debug {
diff --git a/generator/model_test.go b/generator/model_test.go
index d239ce11..cac7f95d 100644
--- a/generator/model_test.go
+++ b/generator/model_test.go
@@ -293,6 +293,7 @@ func TestGenerateModel_Zeroes(t *testing.T) {
 			k.AliasedType = k.GoType
 			k.GoType = "myAliasedType"
 			rex = regexp.MustCompile(regexp.QuoteMeta(k.GoType+"("+k.AliasedType) + `\(\d*\)` + `\)`)
+			assert.True(t, rex.MatchString(k.Zero()))
 			//t.Logf("Zero for %s: %s", k.GoType, k.Zero())
 		case "strfmt.Base64": // akin to []byte
 			rex := regexp.MustCompile(regexp.QuoteMeta(v.Value.GoType) + `\(\[\]byte.*\)`)
@@ -302,6 +303,7 @@ func TestGenerateModel_Zeroes(t *testing.T) {
 			k.AliasedType = k.GoType
 			k.GoType = "myAliasedType"
 			rex = regexp.MustCompile(regexp.QuoteMeta(k.GoType+"("+k.AliasedType) + `\(\[\]byte.*\)` + `\)`)
+			assert.True(t, rex.MatchString(k.Zero()))
 			// t.Logf("Zero for %s: %s", k.GoType, k.Zero())
 		case "interface{}":
 			assert.Equal(t, `nil`, v.Value.Zero())
@@ -322,6 +324,7 @@ func TestGenerateModel_Zeroes(t *testing.T) {
 				k.AliasedType = k.GoType
 				k.GoType = "myAliasedType"
 				rex = regexp.MustCompile(regexp.QuoteMeta(k.GoType+"("+k.AliasedType) + `\(".*"\)` + `\)`)
+				assert.True(t, rex.MatchString(k.Zero()))
 				//t.Logf("Zero for %s: %s", k.GoType, k.Zero())
 			}
 		}
@@ -2393,6 +2396,9 @@ func TestGenModel_Issue1409(t *testing.T) {
 
 // This tests makes sure model definitions from inline schema in response are properly flattened and get validation
 func TestGenModel_Issue866(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
 	specDoc, err := loads.Spec("../fixtures/bugs/866/fixture-866.yaml")
 	if assert.NoError(t, err) {
 		p, ok := specDoc.Spec().Paths.Paths["/"]
diff --git a/generator/moreschemavalidation_fixtures_test.go b/generator/moreschemavalidation_fixtures_test.go
index 36671bfd..387c1b7c 100644
--- a/generator/moreschemavalidation_fixtures_test.go
+++ b/generator/moreschemavalidation_fixtures_test.go
@@ -9333,5 +9333,90 @@ func initFixture1548() {
 		// output in log
 		noLines,
 		noLines)
+}
+
+func initFixtureDeepMaps() {
+	// testing fixture-deepMaps.yaml with minimal flatten
+
+	f := newModelFixture("../fixtures/enhancements/1572/fixture-deepMaps.yaml", "issue 1572 - deep maps")
+	thisRun := f.AddRun(false).WithMinimalFlatten(true)
+
+	// load expectations for model: model_object_vanilla.go
+	thisRun.AddExpectations("model_object_vanilla.go", []string{
+		`type ModelObjectVanilla struct {`,
+		"	Prop0 *ModelSanity `json:\"prop0,omitempty\"`",
+		"	Prop1 *ModelSanity `json:\"prop1\"`",
+		"	Prop2 []*ModelSanity `json:\"prop2\"`",
+		"	Prop3 *ModelSanity `json:\"prop3,omitempty\"`",
+		"	Prop4 map[string]ModelSanity `json:\"prop4,omitempty\"`",
+		"	Prop5 int64 `json:\"prop5,omitempty\"`",
+		"	ModelObjectVanilla map[string]map[string]map[string]ModelSanity `json:\"-\"`",
+		`func (m *ModelObjectVanilla) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp0(formats); err != nil {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`	if err := m.validateProp3(formats); err != nil {`,
+		`	if err := m.validateProp4(formats); err != nil {`,
+		`	for k := range m.ModelObjectVanilla {`,
+		`		for kk := range m.ModelObjectVanilla[k] {`,
+		`			for kkk := range m.ModelObjectVanilla[k][kk] {`,
+		`				if err := validate.Required(k+"."+kk+"."+kkk, "body", m.ModelObjectVanilla[k][kk][kkk]); err != nil {`,
+		`				if val, ok := m.ModelObjectVanilla[k][kk][kkk]; ok {`,
+		`					if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ModelObjectVanilla) validateProp0(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop0) {`,
+		`	if m.Prop0 != nil {`,
+		`		if err := m.Prop0.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("prop0"`,
+		`func (m *ModelObjectVanilla) validateProp1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("prop1", "body", m.Prop1); err != nil {`,
+		`	if m.Prop1 != nil {`,
+		`		if err := m.Prop1.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("prop1"`,
+		`func (m *ModelObjectVanilla) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	for i := 0; i < len(m.Prop2); i++ {`,
+		`		if swag.IsZero(m.Prop2[i]) {`,
+		`		if m.Prop2[i] != nil {`,
+		`			if err := m.Prop2[i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName("prop2" + "." + strconv.Itoa(i)`,
+		`func (m *ModelObjectVanilla) validateProp3(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop3) {`,
+		`	if m.Prop3 != nil {`,
+		`		if err := m.Prop3.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("prop3"`,
+		`func (m *ModelObjectVanilla) validateProp4(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop4) {`,
+		`	for k := range m.Prop4 {`,
+		`		if err := validate.Required("prop4"+"."+k, "body", m.Prop4[k]); err != nil {`,
+		`		if val, ok := m.Prop4[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
 
+	// load expectations for model: model_sanity.go
+	thisRun.AddExpectations("model_sanity.go", []string{
+		`type ModelSanity struct {`,
+		"	PropA string `json:\"propA,omitempty\"`",
+		"	PropB *string `json:\"propB\"`",
+		`func (m *ModelSanity) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validatePropB(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ModelSanity) validatePropB(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("propB", "body", m.PropB); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
 }
diff --git a/generator/moreschemavalidation_test.go b/generator/moreschemavalidation_test.go
index 61738786..7dd8dfde 100644
--- a/generator/moreschemavalidation_test.go
+++ b/generator/moreschemavalidation_test.go
@@ -19,7 +19,9 @@ import (
 	"io/ioutil"
 	"log"
 	"os"
+	"path"
 	"strings"
+	"sync"
 	"testing"
 
 	"github.com/go-openapi/loads"
@@ -71,6 +73,11 @@ func (r *modelTestRun) ExpectedFor(definition string) *modelExpectations {
 	return nil
 }
 
+func (r *modelTestRun) WithMinimalFlatten(minimal bool) *modelTestRun {
+	r.FixtureOpts.FlattenOpts.Minimal = minimal
+	return r
+}
+
 // modelFixture is a test structure to launch configurable test runs on a given spec
 type modelFixture struct {
 	SpecFile    string
@@ -79,17 +86,20 @@ type modelFixture struct {
 }
 
 // Add adds a new run to the provided model fixture
-func (f *modelFixture) AddRun(skipFlattenSpec bool) *modelTestRun {
+func (f *modelFixture) AddRun(expandSpec bool) *modelTestRun {
 	opts := &GenOpts{}
 	opts.IncludeValidator = true
 	opts.IncludeModel = true
-	// sets gen options (e.g. flatten vs expand) - flatten is the default setting
 	opts.ValidateSpec = false
-	opts.FlattenSpec = !skipFlattenSpec
 	opts.Spec = f.SpecFile
 	if err := opts.EnsureDefaults(); err != nil {
 		panic(err)
 	}
+
+	// sets gen options (e.g. flatten vs expand) - full flatten is the default setting for this test (NOT the default CLI option!)
+	opts.FlattenOpts.Expand = expandSpec
+	opts.FlattenOpts.Minimal = false
+
 	defs := make(map[string]*modelExpectations, 150)
 	run := &modelTestRun{
 		FixtureOpts: opts,
@@ -132,7 +142,8 @@ func newModelFixture(specFile string, description string) *modelFixture {
 // all tested specs: init at the end of this source file
 // you may append to those with different initXXX() funcs below.
 var (
-	testedModels []*modelFixture
+	modelTestMutex = &sync.Mutex{}
+	testedModels   []*modelFixture
 
 	// convenient vars for (not) matching some lines
 	noLines     []string
@@ -142,7 +153,7 @@ var (
 )
 
 func init() {
-	testedModels = make([]*modelFixture, 0, 20)
+	testedModels = make([]*modelFixture, 0, 50)
 	noLines = []string{}
 	todo = []string{`TODO`}
 	validatable = append(todo, `Validate(`)
@@ -179,15 +190,17 @@ func initModelFixtures() {
 
 	// format "byte" validation
 	initFixture1548()
+
+	initFixtureDeepMaps()
 }
 
 /* Template initTxxx() to prepare and load a fixture:
 
 func initTxxx() {
-	// testing xxx.yaml with expand (--skip-flatten)
+	// testing xxx.yaml with expand (--with-expand)
 	f := newModelFixture("xxx.yaml", "A test blg")
 
-	// makes a run with skipFlattenSpec=false
+	// makes a run with expandSpec=false (full flattening)
 	thisRun := f.AddRun(false)
 
 	// loads expectations for model abc
@@ -218,21 +231,21 @@ func TestModelGenerateDefinition(t *testing.T) {
 	assert := assert.New(t)
 	gendir, erd := ioutil.TempDir(".", "model-test")
 	defer func() {
-		os.RemoveAll(gendir)
+		_ = os.RemoveAll(gendir)
 	}()
 	if assert.NoError(erd) {
 		opts := &GenOpts{}
 		opts.IncludeValidator = true
 		opts.IncludeModel = true
-		// sets gen options (e.g. flatten vs expand) - flatten is the default setting
 		opts.ValidateSpec = false
-		opts.FlattenSpec = true
 		opts.Spec = fixtureSpec
 		opts.ModelPackage = "models"
 		opts.Target = gendir
 		if err := opts.EnsureDefaults(); err != nil {
 			panic(err)
 		}
+		// sets gen options (e.g. flatten vs expand) - flatten is the default setting
+		opts.FlattenOpts.Minimal = false
 
 		err := GenerateDefinition([]string{"thingWithNullableDates"}, opts)
 		assert.NoErrorf(err, "Expected GenerateDefinition() to run without error")
@@ -269,147 +282,148 @@ func TestMoreModelValidations(t *testing.T) {
 	continueOnErrors := false
 	initModelFixtures()
 
-	assert := assert.New(t)
+	dassert := assert.New(t)
 
+	t.Logf("INFO: model specs tested: %d", len(testedModels))
 	for _, fixture := range testedModels {
 		if fixture.SpecFile == "" {
 			continue
 		}
 		fixtureSpec := fixture.SpecFile
-		specDoc, err := loads.Spec(fixtureSpec)
-		if !assert.NoErrorf(err, "unexpected failure loading spec %s: %v", fixtureSpec, err) {
-			t.FailNow()
-			return
-		}
-		for _, fixtureRun := range fixture.Runs {
-			// NOTE: could run in parallel, if no package level common structures, such as a cache etc..
-			opts := fixtureRun.FixtureOpts
-			t.Logf("codegen for  %s (%s) - run with FlattenSpec=%t", fixtureSpec, fixture.Description, opts.FlattenSpec)
-
-			// this is the expanded or flattened spec
-			newSpecDoc, er0 := validateAndFlattenSpec(opts, specDoc)
-			if !assert.NoErrorf(er0, "could not expand/flatten fixture %s: %v", fixtureSpec, er0) {
+		runTitle := strings.Join([]string{"codegen", strings.TrimSuffix(path.Base(fixtureSpec), path.Ext(fixtureSpec))}, "-")
+		t.Run(runTitle, func(t *testing.T) {
+			t.Parallel()
+			specDoc, err := loads.Spec(fixtureSpec)
+			if !dassert.NoErrorf(err, "unexpected failure loading spec %s: %v", fixtureSpec, err) {
 				t.FailNow()
 				return
 			}
-			definitions := newSpecDoc.Spec().Definitions
-			for k, fixtureExpectations := range fixtureRun.Definitions {
-				// pick definition to test
-				var schema *spec.Schema
-				var definitionName string
-				for def, s := range definitions {
-					// please do not inject in fixtures with case conflicts on defs...
-					// this one is just easier to retrieve model back from file names when capturing
-					// the generated code.
-					if strings.EqualFold(def, k) {
-						schema = &s
-						definitionName = def
-						break
-					}
-				}
-				if !assert.NotNil(schema, "expected to find definition %q in model fixture %s", k, fixtureSpec) {
+			for _, fixtureRun := range fixture.Runs {
+				opts := fixtureRun.FixtureOpts
+				//t.Logf("codegen for  %s (%s) - run with Expand=%t, MinimalFlatten=%t", fixtureSpec, fixture.Description, opts.FlattenOpts.Expand, opts.FlattenOpts.Minimal)
+
+				// workaround race condition with underlying pkg
+				modelTestMutex.Lock()
+				// this is the expanded or flattened spec
+				log.SetOutput(ioutil.Discard)
+				newSpecDoc, er0 := validateAndFlattenSpec(opts, specDoc)
+				if !dassert.NoErrorf(er0, "could not expand/flatten fixture %s: %v", fixtureSpec, er0) {
+					modelTestMutex.Unlock()
 					t.FailNow()
 					return
 				}
-
-				// prepare assertions on log output (e.g. generation warnings)
-				var logCapture bytes.Buffer
-				if len(fixtureExpectations.ExpectedLogs) > 0 || len(fixtureExpectations.NotExpectedLogs) > 0 {
-					log.SetOutput(&logCapture)
-				} else {
-					log.SetOutput(ioutil.Discard)
-				}
-
-				// generate the schema for this definition
-				genModel, er1 := makeGenDefinition(definitionName, "models", *schema, newSpecDoc, opts)
-
-				if fixtureExpectations.ExpectFailure && !assert.Errorf(er1, "Expected an error during generation of definition %q from spec fixture %s", k, fixtureSpec) {
-					// expected an error here, and it has not happened
-					if continueOnErrors {
-						t.Fail()
-						continue
-					} else {
-						t.FailNow()
-						return
-					}
-				}
-				if !assert.NoErrorf(er1, "could not generate model definition %q from spec fixture %s: %v", k, fixtureSpec, er1) {
-					// expected smooth generation
-					if continueOnErrors {
-						t.Fail()
-						continue
-					} else {
-						t.FailNow()
-						return
-					}
-				}
-				if len(fixtureExpectations.ExpectedLogs) > 0 || len(fixtureExpectations.NotExpectedLogs) > 0 {
-					// assert logged output
-					res := logCapture.String()
-					for line, logLine := range fixtureExpectations.ExpectedLogs {
-						if !assertInCode(t, strings.TrimSpace(logLine), res) {
-							t.Logf("Log expected did not match for definition %q in fixture %s at (fixture) log line %d", k, fixtureSpec, line)
-						}
-					}
-					for line, logLine := range fixtureExpectations.NotExpectedLogs {
-						if !assertNotInCode(t, strings.TrimSpace(logLine), res) {
-							t.Logf("Log unexpectedly matched for definition %q in fixture %s at (fixture) log line %d", k, fixtureSpec, line)
+				log.SetOutput(os.Stdout)
+				modelTestMutex.Unlock()
+				definitions := newSpecDoc.Spec().Definitions
+				for k, fixtureExpectations := range fixtureRun.Definitions {
+					// pick definition to test
+					var schema *spec.Schema
+					var definitionName string
+					for def, s := range definitions {
+						// please do not inject fixtures with case conflicts on defs...
+						// this one is just easier to retrieve model back from file names when capturing
+						// the generated code.
+						if strings.EqualFold(def, k) {
+							schema = &s
+							definitionName = def
+							break
 						}
 					}
-					if t.Failed() && !continueOnErrors {
+					if !dassert.NotNil(schema, "expected to find definition %q in model fixture %s", k, fixtureSpec) {
 						t.FailNow()
 						return
 					}
-					log.SetOutput(ioutil.Discard)
+					checkDefinitionCodegen(t, definitionName, fixtureSpec, schema, newSpecDoc, opts, fixtureExpectations, continueOnErrors)
 				}
+			}
+		})
+	}
+}
 
-				// execute the model template with this schema
-				buf := bytes.NewBuffer(nil)
-				er2 := templates.MustGet("model").Execute(buf, genModel)
-				if !assert.NoErrorf(er2, "could not render model template for definition %q in spec fixture %s: %v", k, fixtureSpec, er2) {
-					if continueOnErrors {
-						t.Fail()
-						continue
-					} else {
-						t.FailNow()
-						return
-					}
-				}
-				outputName := fixtureExpectations.GeneratedFile
-				if outputName == "" {
-					outputName = swag.ToFileName(k) + ".go"
-				}
+func checkContinue(t *testing.T, continueOnErrors bool) {
+	if continueOnErrors {
+		t.Fail()
+	} else {
+		t.FailNow()
+	}
+}
 
-				// run goimport, gofmt on the generated code
-				formatted, er3 := opts.LanguageOpts.FormatContent(outputName, buf.Bytes())
-				if !assert.NoErrorf(er3, "could not render model template for definition %q in spec fixture %s: %v", k, fixtureSpec, er2) {
-					t.Fail()
-					if continueOnErrors {
-						t.Fail()
-						continue
-					} else {
-						t.FailNow()
-						return
-					}
-				}
+func checkDefinitionCodegen(t *testing.T, definitionName, fixtureSpec string, schema *spec.Schema, specDoc *loads.Document, opts *GenOpts, fixtureExpectations *modelExpectations, continueOnErrors bool) {
+	// prepare assertions on log output (e.g. generation warnings)
+	var logCapture bytes.Buffer
+	dassert := assert.New(t)
+	if len(fixtureExpectations.ExpectedLogs) > 0 || len(fixtureExpectations.NotExpectedLogs) > 0 {
+		log.SetOutput(&logCapture)
+	} else {
+		log.SetOutput(ioutil.Discard)
+	}
 
-				// asserts generated code (see fixture file)
-				res := string(formatted)
-				for line, codeLine := range fixtureExpectations.ExpectedLines {
-					if !assertInCode(t, strings.TrimSpace(codeLine), res) {
-						t.Logf("Code expected did not match for definition %q in fixture %s at (fixture) line %d", k, fixtureSpec, line)
-					}
-				}
-				for line, codeLine := range fixtureExpectations.NotExpectedLines {
-					if !assertNotInCode(t, strings.TrimSpace(codeLine), res) {
-						t.Logf("code unexpectedly matched for definition %q in fixture %s at (fixture) line %d", k, fixtureSpec, line)
-					}
-				}
-				if t.Failed() && !continueOnErrors {
-					t.FailNow()
-					return
-				}
+	// generate the schema for this definition
+	genModel, er1 := makeGenDefinition(definitionName, "models", *schema, specDoc, opts)
+
+	if fixtureExpectations.ExpectFailure && !dassert.Errorf(er1, "Expected an error during generation of definition %q from spec fixture %s", definitionName, fixtureSpec) {
+		// expected an error here, and it has not happened
+		checkContinue(t, continueOnErrors)
+		return
+	}
+	if !dassert.NoErrorf(er1, "could not generate model definition %q from spec fixture %s: %v", definitionName, fixtureSpec, er1) {
+		// expected smooth generation
+		checkContinue(t, continueOnErrors)
+		return
+	}
+	if len(fixtureExpectations.ExpectedLogs) > 0 || len(fixtureExpectations.NotExpectedLogs) > 0 {
+		// assert logged output
+		res := logCapture.String()
+		for line, logLine := range fixtureExpectations.ExpectedLogs {
+			if !assertInCode(t, strings.TrimSpace(logLine), res) {
+				t.Logf("log expected did not match for definition %q in fixture %s at (fixture) log line %d", definitionName, fixtureSpec, line)
+			}
+		}
+		for line, logLine := range fixtureExpectations.NotExpectedLogs {
+			if !assertNotInCode(t, strings.TrimSpace(logLine), res) {
+				t.Logf("log unexpectedly matched for definition %q in fixture %s at (fixture) log line %d", definitionName, fixtureSpec, line)
 			}
 		}
+		if t.Failed() && !continueOnErrors {
+			t.FailNow()
+			return
+		}
+		log.SetOutput(ioutil.Discard)
+	}
+
+	// execute the model template with this schema
+	buf := bytes.NewBuffer(nil)
+	er2 := templates.MustGet("model").Execute(buf, genModel)
+	if !dassert.NoErrorf(er2, "could not render model template for definition %q in spec fixture %s: %v", definitionName, fixtureSpec, er2) {
+		checkContinue(t, continueOnErrors)
+		return
+	}
+	outputName := fixtureExpectations.GeneratedFile
+	if outputName == "" {
+		outputName = swag.ToFileName(definitionName) + ".go"
+	}
+
+	// run goimport, gofmt on the generated code
+	formatted, er3 := opts.LanguageOpts.FormatContent(outputName, buf.Bytes())
+	if !dassert.NoErrorf(er3, "could not render model template for definition %q in spec fixture %s: %v", definitionName, fixtureSpec, er2) {
+		checkContinue(t, continueOnErrors)
+		return
+	}
+
+	// asserts generated code (see fixture file)
+	res := string(formatted)
+	for line, codeLine := range fixtureExpectations.ExpectedLines {
+		if !assertInCode(t, strings.TrimSpace(codeLine), res) {
+			t.Logf("code expected did not match for definition %q in fixture %s at (fixture) line %d", definitionName, fixtureSpec, line)
+		}
+	}
+	for line, codeLine := range fixtureExpectations.NotExpectedLines {
+		if !assertNotInCode(t, strings.TrimSpace(codeLine), res) {
+			t.Logf("code unexpectedly matched for definition %q in fixture %s at (fixture) line %d", definitionName, fixtureSpec, line)
+		}
+	}
+	if t.Failed() && !continueOnErrors {
+		t.FailNow()
+		return
 	}
 }
diff --git a/generator/operation.go b/generator/operation.go
index 967d9a64..879b4e4e 100644
--- a/generator/operation.go
+++ b/generator/operation.go
@@ -42,6 +42,8 @@ func (s responses) Len() int           { return len(s) }
 func (s responses) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
 func (s responses) Less(i, j int) bool { return s[i].Code < s[j].Code }
 
+// sortedResponses produces a sorted list of responses.
+// TODO: this is redundant with the definition given in struct.go
 func sortedResponses(input map[int]spec.Response) responses {
 	var res responses
 	for k, v := range input {
@@ -277,6 +279,8 @@ type codeGenOpBuilder struct {
 	GenOpts             *GenOpts
 }
 
+// renameTimeout renames the variable in use by client template to avoid conflicting
+// with param names.
 func renameTimeout(seenIds map[string][]string, current string) string {
 	var next string
 	switch strings.ToLower(current) {
@@ -305,9 +309,11 @@ func (b *codeGenOpBuilder) MakeOperation() (GenOperation, error) {
 	}
 	// NOTE: we assume flatten is enabled by default (i.e. complex constructs are resolved from the models package),
 	// but do not assume the spec is necessarily fully flattened (i.e. all schemas moved to definitions).
-	// Flattened means that all complex constructs are present as
-	// definitions and models produced accordingly in ModelsPackage.
-	// When this is not the case, extra schemas are produced in the operations package.
+	// Fully flattened means that all complex constructs are present as
+	// definitions and models produced accordingly in ModelsPackage,
+	// wherease minimal flatten simply ensures that there are no weird $ref's in the spec.
+	//
+	// When some complex anonymous constructs are specified, extra schemas are produced in the operations package.
 	//
 	// In all cases, resetting definitions to the _original_ (untransformed) spec is not an option:
 	// we take it from here the spec possibly already transformed by the GenDefinitions stage.
@@ -556,16 +562,7 @@ func (b *codeGenOpBuilder) MakeResponse(receiver, name string, isSuccess bool, r
 		log.Printf("[%s %s] making id %q", b.Method, b.Path, b.Operation.ID)
 	}
 
-	if resp.Ref.String() != "" {
-		resp2, err := spec.ResolveResponse(b.Doc.Spec(), resp.Ref)
-		if err != nil {
-			return GenResponse{}, err
-		}
-		if resp2 == nil {
-			return GenResponse{}, fmt.Errorf("could not resolve response ref: %s", resp.Ref.String())
-		}
-		resp = *resp2
-	}
+	// assume minimal flattening has been carried on, so there is not $ref in response (but some may remain in response schema)
 
 	res := GenResponse{
 		Package:        b.APIPackage,
@@ -582,6 +579,7 @@ func (b *codeGenOpBuilder) MakeResponse(receiver, name string, isSuccess bool, r
 		Extensions:     resp.Extensions,
 	}
 
+	// prepare response headers
 	for hName, header := range resp.Headers {
 		hdr, err := b.MakeHeader(receiver, hName, header)
 		if err != nil {
@@ -592,105 +590,11 @@ func (b *codeGenOpBuilder) MakeResponse(receiver, name string, isSuccess bool, r
 	sort.Sort(res.Headers)
 
 	if resp.Schema != nil {
-		var schema GenSchema
-		var named bool
-		rslv := resolver
-		sch := resp.Schema
-		if resp.Schema.Ref.String() != "" && !resp.Schema.Ref.HasFragmentOnly {
-			// This section attempts to resolve external $ref (e.g. which are not only a fragment)
-			// TODO: this is currently unused as always resolved beforehand by flattening/expanding the spec.
-			// We should guard the generator against complex $ref, such as external, or pointing to anonymous places.
-			ss, err := spec.ResolveRefWithBase(b.Doc.Spec(), &resp.Schema.Ref, nil)
-			if err != nil {
-				return GenResponse{}, err
-			}
-			sch = ss
-			named = true
-			rslv = resolver.NewWithModelName(name + "Body")
+		// resolve schema model
+		schema, ers := b.buildOperationSchema(fmt.Sprintf("%q", name), name+"Body", swag.ToGoName(name+"Body"), receiver, "i", resp.Schema, resolver)
+		if ers != nil {
+			return GenResponse{}, ers
 		}
-
-		sc := schemaGenContext{
-			Path:             fmt.Sprintf("%q", name),
-			Name:             name + "Body",
-			Receiver:         receiver,
-			ValueExpr:        receiver,
-			IndexVar:         "i",
-			Schema:           *sch,
-			Required:         !named,
-			TypeResolver:     rslv,
-			Named:            named,
-			ExtraSchemas:     make(map[string]GenSchema),
-			IncludeModel:     true,
-			IncludeValidator: true,
-		}
-		br, bs := b.saveResolveContext(rslv, sch)
-		if err := sc.makeGenSchema(); err != nil {
-			return GenResponse{}, err
-		}
-
-		if !strings.HasPrefix(sch.Ref.String(), "#/definitions") && len(sc.ExtraSchemas) > 0 {
-			// when some ExtraSchemas are produced from something else than a definition,
-			// this indicates we are not running in fully flatten mode and we need to render
-			// ExtraSchemas in the operation's package.
-			// We need to rebuild the schema with a new type resolver to reflect this change in the
-			// models package.
-			//
-			// In the following, we want to produce extra schemas in the current package (operations),
-			// while being able to reuse already resolved definitions in the models package.
-
-			// restore resolving state before previous call to makeGenSchema()
-			rslv = br
-			sc.Schema = *bs
-
-			pg := sc.shallowClone()
-			pg.TypeResolver = newTypeResolver("", rslv.Doc).withKeepDefinitionsPackage(resolver.ModelsPackage)
-			pg.ExtraSchemas = make(map[string]GenSchema, len(sc.ExtraSchemas))
-			rslv = pg.TypeResolver
-
-			if err := pg.makeGenSchema(); err != nil {
-				return GenResponse{}, err
-			}
-			// lift nested extra schemas (inlined types)
-			if b.ExtraSchemas == nil {
-				b.ExtraSchemas = make(map[string]GenSchema, len(pg.ExtraSchemas))
-			}
-			for _, v := range pg.ExtraSchemas {
-				vv := v
-				vv.GoType = vv.Name
-				vv.IsAnonymous = false
-				if !v.IsStream {
-					b.ExtraSchemas[vv.Name] = vv
-				}
-			}
-			schema = pg.GenSchema
-		} else {
-			schema = sc.GenSchema
-		}
-
-		if named {
-			// TODO: this is currently unused as always resolved beforehand by flattening/expanding the spec.
-			if b.ExtraSchemas == nil {
-				b.ExtraSchemas = make(map[string]GenSchema)
-			}
-			if !schema.IsStream {
-				b.ExtraSchemas[schema.Name] = schema
-			}
-		}
-		if schema.IsAnonymous {
-			schema.Name = swag.ToGoName(sc.Name)
-			nm := schema.Name
-			if b.ExtraSchemas == nil {
-				b.ExtraSchemas = make(map[string]GenSchema)
-			}
-			if !schema.IsStream {
-				b.ExtraSchemas[schema.Name] = schema
-			}
-			schema = GenSchema{}
-			schema.IsAnonymous = false
-			schema.GoType = rslv.goTypeName(nm)
-			schema.SwaggerType = nm
-		}
-
 		res.Schema = &schema
 	}
 	return res, nil
@@ -814,17 +718,7 @@ func (b *codeGenOpBuilder) MakeParameter(receiver string, resolver *typeResolver
 		log.Printf("[%s %s] making parameter %q", b.Method, b.Path, param.Name)
 	}
 
-	if param.Ref.String() != "" {
-		// Resolve $ref before all
-		param2, err := spec.ResolveParameter(b.Doc.Spec(), param.Ref)
-		if err != nil {
-			return GenParameter{}, err
-		}
-		if param2 == nil {
-			return GenParameter{}, fmt.Errorf("could not resolve parameter ref: %s", param.Ref.String())
-		}
-		param = *param2
-	}
+	// assume minimal flattening has been carried on, so there is not $ref in response (but some may remain in response schema)
 
 	var child *GenItems
 	id := swag.ToGoName(param.Name)
@@ -889,124 +783,13 @@ func (b *codeGenOpBuilder) MakeParameter(receiver string, resolver *typeResolver
 
 // MakeBodyParameter constructs a body parameter schema
 func (b *codeGenOpBuilder) MakeBodyParameter(res *GenParameter, resolver *typeResolver, sch *spec.Schema) error {
-	var schema GenSchema
-	var named bool
-	rslv := resolver
-
-	if sch.Ref.String() != "" && !sch.Ref.HasFragmentOnly {
-		// This section attempts to resolve external $ref (e.g. which are not only a fragment)
-		// TODO: this is currently unused as always resolved beforehand by flattening/expanding the spec.
-		// We should guard the generator against complex $ref, such as external, or pointing to anonymous places.
-		ss, err := spec.ResolveRefWithBase(b.Doc.Spec(), &sch.Ref, nil)
-		if err != nil {
-			return err
-		}
-		sch = ss
-		// this is a named schema (i.e. with an external $ref)
-		named = true
-		rslv = resolver.NewWithModelName(b.Operation.ID + "ParamsBody")
-	}
-
 	// resolve schema model
-	sc := schemaGenContext{
-		Path:             res.Path,
-		Name:             b.Operation.ID + "ParamsBody",
-		Receiver:         res.ReceiverName,
-		ValueExpr:        res.ReceiverName,
-		IndexVar:         res.IndexVar,
-		Schema:           *sch,
-		Required:         false, // Required in body is managed independently from validations
-		TypeResolver:     rslv,
-		Named:            named,
-		IncludeModel:     true,
-		IncludeValidator: true,
-		ExtraSchemas:     make(map[string]GenSchema),
-	}
-	br, bs := b.saveResolveContext(rslv, sch)
-	if err := sc.makeGenSchema(); err != nil {
-		return err
-	}
-
-	if !strings.HasPrefix(sch.Ref.String(), "#/definitions") && len(sc.ExtraSchemas) > 0 {
-		// when some ExtraSchemas are produced from something else than a definition,
-		// this indicates we are not running in fully flattened mode and we need to render
-		// some ExtraSchemas in the operation's package.
-		// We need to rebuild the schema with a new type resolver to reflect this change in the
-		// models package.
-
-		// restore resolving state before previous call to makeGenSchema()
-		rslv = br
-		sc.Schema = *bs
-
-		pg := sc.shallowClone()
-		pg.TypeResolver = newTypeResolver("", rslv.Doc).withKeepDefinitionsPackage(resolver.ModelsPackage)
-		pg.ExtraSchemas = make(map[string]GenSchema, len(sc.ExtraSchemas))
-
-		if err := pg.makeGenSchema(); err != nil {
-			return err
-		}
-		// lift nested extra schemas (inlined types)
-		if b.ExtraSchemas == nil {
-			b.ExtraSchemas = make(map[string]GenSchema, len(pg.ExtraSchemas))
-		}
-		for _, v := range pg.ExtraSchemas {
-			vv := v
-			vv.GoType = vv.Name
-			vv.IsAnonymous = false
-			if !v.IsStream {
-				b.ExtraSchemas[vv.Name] = vv
-			}
-		}
-		schema = pg.GenSchema
-	} else {
-		schema = sc.GenSchema
-	}
-
-	if named {
-		// TODO: this is currently unused as always resolved beforehand by flattening/expanding the spec.
-		if b.ExtraSchemas == nil {
-			b.ExtraSchemas = make(map[string]GenSchema)
-		}
-		b.ExtraSchemas[b.Operation.ID+"ParamsBody"] = schema
+	schema, ers := b.buildOperationSchema(res.Path, b.Operation.ID+"ParamsBody", swag.ToGoName(b.Operation.ID+" Body"), res.ReceiverName, res.IndexVar, sch, resolver)
+	if ers != nil {
+		return ers
 	}
-
-	if schema.IsAnonymous {
-		// a generated name for anonymous parameter in body
-		nm := swag.ToGoName(b.Operation.ID + " Body")
-
-		hasProperties := len(schema.Properties) > 0
-		isInterface := schema.IsInterface
-		hasValidations := schema.HasValidations
-
-		// for complex anonymous objects, produce an extra schema
-		if hasProperties {
-			if b.ExtraSchemas == nil {
-				b.ExtraSchemas = make(map[string]GenSchema)
-			}
-			schema.Name = nm
-			schema.GoType = nm
-			schema.IsAnonymous = false
-			b.ExtraSchemas[nm] = schema
-
-			// constructs new schema to refer to the newly created type
-			schema = GenSchema{}
-			schema.IsAnonymous = false
-			schema.IsComplexObject = true
-			schema.SwaggerType = nm
-			schema.HasValidations = hasValidations
-			schema.GoType = nm
-		} else if isInterface {
-			schema = GenSchema{}
-			schema.IsAnonymous = false
-			schema.IsComplexObject = false
-			schema.IsInterface = true
-			schema.HasValidations = false
-			schema.GoType = iface
-		}
-	}
-
 	res.Schema = &schema
-	res.Schema.Required = res.Required
+	res.Schema.Required = res.Required // Required in body is managed independently from validations
 
 	// build Child items for nested slices and maps
 	var items *GenItems
@@ -1229,3 +1012,121 @@ func (b *codeGenOpBuilder) saveResolveContext(resolver *typeResolver, schema *sp
 
 	return rslv, b.cloneSchema(schema)
 }
+
+// liftExtraSchemas constructs the schema for an anonymous construct with some ExtraSchemas.
+//
+// When some ExtraSchemas are produced from something else than a definition,
+// this indicates we are not running in fully flattened mode and we need to render
+// these ExtraSchemas in the operation's package.
+// We need to rebuild the schema with a new type resolver to reflect this change in the
+// models package.
+func (b *codeGenOpBuilder) liftExtraSchemas(resolver, br *typeResolver, bs *spec.Schema, sc *schemaGenContext) (schema *GenSchema, err error) {
+
+	// restore resolving state before previous call to makeGenSchema()
+	rslv := br
+	sc.Schema = *bs
+
+	pg := sc.shallowClone()
+	pg.TypeResolver = newTypeResolver("", rslv.Doc).withKeepDefinitionsPackage(resolver.ModelsPackage)
+	pg.ExtraSchemas = make(map[string]GenSchema, len(sc.ExtraSchemas))
+
+	if err = pg.makeGenSchema(); err != nil {
+		return
+	}
+	// lift nested extra schemas (inlined types)
+	if b.ExtraSchemas == nil {
+		b.ExtraSchemas = make(map[string]GenSchema, len(pg.ExtraSchemas))
+	}
+	for _, v := range pg.ExtraSchemas {
+		vv := v
+		if !v.IsStream {
+			b.ExtraSchemas[vv.Name] = vv
+		}
+	}
+	schema = &pg.GenSchema
+	return
+}
+
+// buildOperationSchema constructs a schema for an operation (for body params or responses).
+// It determines if the schema is readily available from the models package,
+// or if a schema has to be generated in the operations package (i.e. is anonymous).
+// Whenever an anonymous schema needs somes extra schemas, we also determine if these extras are
+// available from models or must be generated alongside the schema in the operations package.
+//
+// Duplicate extra schemas are pruned later on, when operations grouping in packages (e.g. from tags) takes place.
+func (b *codeGenOpBuilder) buildOperationSchema(schemaPath, containerName, schemaName, receiverName, indexVar string, sch *spec.Schema, resolver *typeResolver) (GenSchema, error) {
+	var schema GenSchema
+
+	if sch == nil {
+		sch = &spec.Schema{}
+	}
+	rslv := resolver
+	sc := schemaGenContext{
+		Path:             schemaPath,
+		Name:             containerName,
+		Receiver:         receiverName,
+		ValueExpr:        receiverName,
+		IndexVar:         indexVar,
+		Schema:           *sch,
+		Required:         false,
+		TypeResolver:     rslv,
+		Named:            false,
+		IncludeModel:     true,
+		IncludeValidator: true,
+		ExtraSchemas:     make(map[string]GenSchema),
+	}
+
+	br, bs := b.saveResolveContext(rslv, sch)
+
+	if err := sc.makeGenSchema(); err != nil {
+		return GenSchema{}, err
+	}
+
+	if sch.Ref.String() == "" && len(sc.ExtraSchemas) > 0 {
+		newSchema, err := b.liftExtraSchemas(resolver, br, bs, &sc)
+		if err != nil {
+			return GenSchema{}, err
+		}
+		if newSchema != nil {
+			schema = *newSchema
+		}
+	} else {
+		schema = sc.GenSchema
+	}
+
+	if schema.IsAnonymous {
+		// a generated name for anonymous schema
+		// TODO: support x-go-name
+		hasProperties := len(schema.Properties) > 0
+		isAllOf := len(schema.AllOf) > 0
+		isInterface := schema.IsInterface
+		hasValidations := schema.HasValidations
+
+		// for complex anonymous objects, produce an extra schema
+		if hasProperties || isAllOf {
+			if b.ExtraSchemas == nil {
+				b.ExtraSchemas = make(map[string]GenSchema)
+			}
+			schema.Name = schemaName
+			schema.GoType = schemaName
+			schema.IsAnonymous = false
+			b.ExtraSchemas[schemaName] = schema
+
+			// constructs new schema to refer to the newly created type
+			schema = GenSchema{}
+			schema.IsAnonymous = false
+			schema.IsComplexObject = true
+			schema.SwaggerType = schemaName
+			schema.HasValidations = hasValidations
+			schema.GoType = schemaName
+		} else if isInterface {
+			schema = GenSchema{}
+			schema.IsAnonymous = false
+			schema.IsComplexObject = false
+			schema.IsInterface = true
+			schema.HasValidations = false
+			schema.GoType = iface
+		}
+	}
+	return schema, nil
+}
diff --git a/generator/operation_test.go b/generator/operation_test.go
index 30ce252f..2e1140e4 100644
--- a/generator/operation_test.go
+++ b/generator/operation_test.go
@@ -193,7 +193,6 @@ func TestMakeOperation(t *testing.T) {
 	if assert.NoError(t, err) {
 		gO, err := b.MakeOperation()
 		if assert.NoError(t, err) {
-			//pretty.Println(gO)
 			assert.Equal(t, "getTasks", gO.Name)
 			assert.Equal(t, "GET", gO.Method)
 			assert.Equal(t, "/tasks", gO.Path)
@@ -202,12 +201,13 @@ func TestMakeOperation(t *testing.T) {
 			assert.NotNil(t, gO.DefaultResponse)
 			assert.NotNil(t, gO.SuccessResponse)
 		}
-
-		// TODO: validate rendering of a complex operation
 	}
 }
 
 func TestRenderOperation_InstagramSearch(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
 	b, err := methodPathOpBuilder("get", "/media/search", "../fixtures/codegen/instagram.yml")
 	if assert.NoError(t, err) {
 		gO, ero := b.MakeOperation()
@@ -320,6 +320,7 @@ func methodPathOpBuilder(method, path, fname string) (codeGenOpBuilder, error) {
 	}, nil
 }
 
+// methodPathOpBuilderWithFlatten prepares an operation build based on method and path, with spec full flattening
 func methodPathOpBuilderWithFlatten(method, path, fname string) (codeGenOpBuilder, error) {
 	if fname == "" {
 		fname = "../fixtures/codegen/todolist.simple.yml"
@@ -330,11 +331,7 @@ func methodPathOpBuilderWithFlatten(method, path, fname string) (codeGenOpBuilde
 		return codeGenOpBuilder{}, err
 	}
 
-	o := &GenOpts{
-		FlattenSpec:  true,
-		ValidateSpec: false,
-		Spec:         fname,
-	}
+	o := opBuildGetOpts(fname, true, false) // flatten: true, minimal: false
 
 	specDoc, err = validateAndFlattenSpec(o, specDoc)
 	if err != nil {
@@ -367,6 +364,7 @@ func methodPathOpBuilderWithFlatten(method, path, fname string) (codeGenOpBuilde
 // opBuilderWithOpts prepares the making of an operation with spec flattening options
 func opBuilderWithOpts(name, fname string, o *GenOpts) (codeGenOpBuilder, error) {
 	if fname == "" {
+		// default fixture
 		fname = "../fixtures/codegen/todolist.simple.yml"
 	}
 
@@ -379,11 +377,15 @@ func opBuilderWithOpts(name, fname string, o *GenOpts) (codeGenOpBuilder, error)
 	if err != nil {
 		return codeGenOpBuilder{}, err
 	}
+	o.Spec = fname
 
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
 	specDoc, err = validateAndFlattenSpec(o, specDoc)
 	if err != nil {
 		return codeGenOpBuilder{}, err
 	}
+	log.SetOutput(os.Stdout)
 
 	analyzed := analysis.New(specDoc.Spec())
 
@@ -406,72 +408,82 @@ func opBuilderWithOpts(name, fname string, o *GenOpts) (codeGenOpBuilder, error)
 		Analyzed:      analyzed,
 		Authed:        false,
 		ExtraSchemas:  make(map[string]GenSchema),
-		GenOpts:       opts(),
+		GenOpts:       o, // opts()??
 	}, nil
 }
 
-// opBuilderWithFlatten prepares the making of an operation with spec flattening prior to rendering
-func opBuilderWithFlatten(name, fname string) (codeGenOpBuilder, error) {
-	o := &GenOpts{
-		FlattenSpec:  true,
-		ValidateSpec: false,
-		Spec:         fname,
+func opBuildGetOpts(specName string, withFlatten bool, withMinimalFlatten bool) (opts *GenOpts) {
+	opts = &GenOpts{}
+	if erd := opts.EnsureDefaults(); erd != nil {
+		panic("Cannot initialize GenOpts")
 	}
+	opts.ValidateSpec = true
+	opts.FlattenOpts.Expand = !withFlatten
+	opts.FlattenOpts.Minimal = withMinimalFlatten
+	opts.Spec = specName
+	return
+}
+
+// opBuilderWithFlatten prepares the making of an operation with spec full flattening prior to rendering
+func opBuilderWithFlatten(name, fname string) (codeGenOpBuilder, error) {
+	o := opBuildGetOpts(fname, true, false) // flatten: true, minimal: false
 	return opBuilderWithOpts(name, fname, o)
 }
 
 // opBuilderWithExpand prepares the making of an operation with spec expansion prior to rendering
 func opBuilderWithExpand(name, fname string) (codeGenOpBuilder, error) {
-	o := &GenOpts{
-		FlattenSpec:  false,
-		ValidateSpec: false,
-		Spec:         fname,
-	}
+	o := opBuildGetOpts(fname, false, false) // flatten: false => expand
 	return opBuilderWithOpts(name, fname, o)
 }
 
-// opBuilder prepares the making of an operation without spec alteration
+// opBuilder prepares the making of an operation with spec minimal flattening (default for CLI)
 func opBuilder(name, fname string) (codeGenOpBuilder, error) {
-	if fname == "" {
-		fname = "../fixtures/codegen/todolist.simple.yml"
-	}
+	o := opBuildGetOpts(fname, true, true) // flatten:true, minimal: true
+	// some fixtures do not fully validate - skip this
+	o.ValidateSpec = false
+	return opBuilderWithOpts(name, fname, o)
+	/*
+		if fname == "" {
+			fname = "../fixtures/codegen/todolist.simple.yml"
+		}
 
-	if !filepath.IsAbs(fname) {
-		cwd, _ := os.Getwd()
-		fname = filepath.Join(cwd, fname)
-	}
+		if !filepath.IsAbs(fname) {
+			cwd, _ := os.Getwd()
+			fname = filepath.Join(cwd, fname)
+		}
 
-	specDoc, err := loads.Spec(fname)
-	if err != nil {
-		return codeGenOpBuilder{}, err
-	}
-	if err != nil {
-		return codeGenOpBuilder{}, err
-	}
+		specDoc, err := loads.Spec(fname)
+		if err != nil {
+			return codeGenOpBuilder{}, err
+		}
+		if err != nil {
+			return codeGenOpBuilder{}, err
+		}
 
-	analyzed := analysis.New(specDoc.Spec())
+		analyzed := analysis.New(specDoc.Spec())
 
-	method, path, op, ok := analyzed.OperationForName(name)
-	if !ok {
-		return codeGenOpBuilder{}, errors.New("No operation could be found for " + name)
-	}
+		method, path, op, ok := analyzed.OperationForName(name)
+		if !ok {
+			return codeGenOpBuilder{}, errors.New("No operation could be found for " + name)
+		}
 
-	return codeGenOpBuilder{
-		Name:          name,
-		Method:        method,
-		Path:          path,
-		BasePath:      specDoc.BasePath(),
-		APIPackage:    "restapi",
-		ModelsPackage: "models",
-		Principal:     "models.User",
-		Target:        ".",
-		Operation:     *op,
-		Doc:           specDoc,
-		Analyzed:      analyzed,
-		Authed:        false,
-		ExtraSchemas:  make(map[string]GenSchema),
-		GenOpts:       opts(),
-	}, nil
+		return codeGenOpBuilder{
+			Name:          name,
+			Method:        method,
+			Path:          path,
+			BasePath:      specDoc.BasePath(),
+			APIPackage:    "restapi",
+			ModelsPackage: "models",
+			Principal:     "models.User",
+			Target:        ".",
+			Operation:     *op,
+			Doc:           specDoc,
+			Analyzed:      analyzed,
+			Authed:        false,
+			ExtraSchemas:  make(map[string]GenSchema),
+			GenOpts:       opts(),
+		}, nil
+	*/
 }
 
 func findResponseHeader(op *spec.Operation, code int, name string) *spec.Header {
@@ -733,7 +745,6 @@ func TestGenServerIssue890_ValidationTrueFlatteningTrue(t *testing.T) {
 		IncludeResponses:  true,
 		IncludeMain:       true,
 		ValidateSpec:      true,
-		FlattenSpec:       true,
 		APIPackage:        "restapi",
 		ModelPackage:      "model",
 		ServerPackage:     "server",
@@ -744,6 +755,9 @@ func TestGenServerIssue890_ValidationTrueFlatteningTrue(t *testing.T) {
 
 	//Testing Server Generation
 	err := opts.EnsureDefaults()
+	// Full flattening
+	opts.FlattenOpts.Expand = false
+	opts.FlattenOpts.Minimal = false
 	assert.NoError(t, err)
 	appGen, err := newAppGenerator("JsonRefOperation", nil, nil, opts)
 	if assert.NoError(t, err) {
@@ -769,12 +783,12 @@ func TestGenClientIssue890_ValidationTrueFlatteningTrue(t *testing.T) {
 	defer func() {
 		log.SetOutput(os.Stdout)
 		dr, _ := os.Getwd()
-		os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
+		_ = os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
 	}()
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/890/swagger.yaml"
 	opts.ValidateSpec = true
-	opts.FlattenSpec = true
+	opts.FlattenOpts.Minimal = false
 	// Testing this is enough as there is only one operation which is specified as $ref.
 	// If this doesn't get resolved then there will be an error definitely.
 	assert.NoError(t, GenerateClient("foo", nil, nil, &opts))
@@ -792,7 +806,6 @@ func TestGenServerIssue890_ValidationFalseFlattenTrue(t *testing.T) {
 		IncludeParameters: true,
 		IncludeResponses:  true,
 		IncludeMain:       true,
-		FlattenSpec:       true,
 		APIPackage:        "restapi",
 		ModelPackage:      "model",
 		ServerPackage:     "server",
@@ -803,6 +816,8 @@ func TestGenServerIssue890_ValidationFalseFlattenTrue(t *testing.T) {
 
 	//Testing Server Generation
 	err := opts.EnsureDefaults()
+	// full flattening
+	opts.FlattenOpts.Minimal = false
 	assert.NoError(t, err)
 	appGen, err := newAppGenerator("JsonRefOperation", nil, nil, opts)
 	if assert.NoError(t, err) {
@@ -828,12 +843,13 @@ func TestGenClientIssue890_ValidationFalseFlatteningTrue(t *testing.T) {
 	defer func() {
 		log.SetOutput(os.Stdout)
 		dr, _ := os.Getwd()
-		os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
+		_ = os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
 	}()
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/890/swagger.yaml"
 	opts.ValidateSpec = false
-	opts.FlattenSpec = true
+	// full flattening
+	opts.FlattenOpts.Minimal = false
 	// Testing this is enough as there is only one operation which is specified as $ref.
 	// If this doesn't get resolved then there will be an error definitely.
 	assert.NoError(t, GenerateClient("foo", nil, nil, &opts))
@@ -852,7 +868,6 @@ func TestGenServerIssue890_ValidationFalseFlattenFalse(t *testing.T) {
 		IncludeResponses:  true,
 		IncludeMain:       true,
 		ValidateSpec:      false,
-		FlattenSpec:       false,
 		APIPackage:        "restapi",
 		ModelPackage:      "model",
 		ServerPackage:     "server",
@@ -863,6 +878,8 @@ func TestGenServerIssue890_ValidationFalseFlattenFalse(t *testing.T) {
 
 	//Testing Server Generation
 	err := opts.EnsureDefaults()
+	// minimal flattening
+	opts.FlattenOpts.Minimal = true
 	assert.NoError(t, err)
 	_, err = newAppGenerator("JsonRefOperation", nil, nil, opts)
 	// if flatten is not set, expand takes over so this would resume normally
@@ -873,13 +890,14 @@ func TestGenClientIssue890_ValidationFalseFlattenFalse(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
 	defer func() {
 		dr, _ := os.Getwd()
-		os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
+		_ = os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
 		log.SetOutput(os.Stdout)
 	}()
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/890/swagger.yaml"
 	opts.ValidateSpec = false
-	opts.FlattenSpec = false
+	// minimal flattening
+	opts.FlattenOpts.Minimal = true
 	// Testing this is enough as there is only one operation which is specified as $ref.
 	// If this doesn't get resolved then there will be an error definitely.
 	// New: Now if flatten is false, expand takes over so server generation should resume normally
@@ -899,7 +917,6 @@ func TestGenServerIssue890_ValidationTrueFlattenFalse(t *testing.T) {
 		IncludeResponses:  true,
 		IncludeMain:       true,
 		ValidateSpec:      true,
-		FlattenSpec:       false,
 		APIPackage:        "restapi",
 		ModelPackage:      "model",
 		ServerPackage:     "server",
@@ -910,6 +927,8 @@ func TestGenServerIssue890_ValidationTrueFlattenFalse(t *testing.T) {
 
 	//Testing Server Generation
 	err := opts.EnsureDefaults()
+	// minimal flattening
+	opts.FlattenOpts.Minimal = true
 	assert.NoError(t, err)
 	_, err = newAppGenerator("JsonRefOperation", nil, nil, opts)
 	// now if flatten is false, expand takes over so server generation should resume normally
@@ -921,12 +940,11 @@ func TestGenClientIssue890_ValidationTrueFlattenFalse(t *testing.T) {
 	defer func() {
 		log.SetOutput(os.Stdout)
 		dr, _ := os.Getwd()
-		os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
+		_ = os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
 	}()
 	opts := testGenOpts()
 	opts.Spec = filepath.FromSlash("../fixtures/bugs/890/swagger.yaml")
 	opts.ValidateSpec = true
-	opts.FlattenSpec = false
 	// Testing this is enough as there is only one operation which is specified as $ref.
 	// If this doesn't get resolved then there will be an error definitely.
 	// same here: now if flatten doesn't resume, expand takes over
@@ -1039,7 +1057,7 @@ func TestGenSecurityRequirements(t *testing.T) {
 		genRequirements := b.makeSecurityRequirements("o")
 		assert.Len(t, genRequirements, 2)
 		assert.Equal(t, []GenSecurityRequirements{
-			GenSecurityRequirements{
+			{
 				GenSecurityRequirement{
 					Name:   "A",
 					Scopes: []string{},
@@ -1053,7 +1071,7 @@ func TestGenSecurityRequirements(t *testing.T) {
 					Scopes: []string{"s0", "s1", "s2", "s3", "s4"},
 				},
 			},
-			GenSecurityRequirements{
+			{
 				GenSecurityRequirement{
 					Name:   "C",
 					Scopes: []string{},
@@ -1079,7 +1097,7 @@ func TestGenSecurityRequirements(t *testing.T) {
 		genRequirements = b.makeSecurityRequirements("o")
 		assert.Len(t, genRequirements, 2)
 		assert.Equal(t, []GenSecurityRequirements{
-			GenSecurityRequirements{
+			{
 				GenSecurityRequirement{
 					Name:   "A",
 					Scopes: []string{},
@@ -1089,7 +1107,7 @@ func TestGenSecurityRequirements(t *testing.T) {
 					Scopes: []string{"s0", "s1", "s2", "s3", "s4"},
 				},
 			},
-			GenSecurityRequirements{
+			{
 				GenSecurityRequirement{
 					Name:   "D",
 					Scopes: []string{},
@@ -1130,10 +1148,11 @@ func TestGenerateServerOperation(t *testing.T) {
 	fname := "../fixtures/codegen/todolist.simple.yml"
 
 	tgt, _ := ioutil.TempDir(filepath.Dir(fname), "generated")
-	defer os.RemoveAll(tgt)
+	defer func() {
+		_ = os.RemoveAll(tgt)
+	}()
 	o := &GenOpts{
 		IncludeValidator:  true,
-		FlattenSpec:       true,
 		ValidateSpec:      false,
 		IncludeModel:      true,
 		IncludeHandler:    true,
diff --git a/generator/parameter_test.go b/generator/parameter_test.go
index 01285dbf..ad27e898 100644
--- a/generator/parameter_test.go
+++ b/generator/parameter_test.go
@@ -454,6 +454,11 @@ var bug163Properties = []paramTestContext{
 }
 
 func TestGenParameters_Simple(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer func() {
+		log.SetOutput(os.Stdout)
+	}()
+
 	b, err := opBuilder("getSearch", "../fixtures/bugs/163/swagger.yml")
 	if !assert.NoError(t, err) {
 		t.FailNow()
@@ -467,6 +472,11 @@ func TestGenParameters_Simple(t *testing.T) {
 }
 
 func TestGenParameter_Issue163(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer func() {
+		log.SetOutput(os.Stdout)
+	}()
+
 	b, err := opBuilder("getSearch", "../fixtures/bugs/163/swagger.yml")
 	if assert.NoError(t, err) {
 		op, err := b.MakeOperation()
@@ -490,6 +500,11 @@ func TestGenParameter_Issue163(t *testing.T) {
 }
 
 func TestGenParameter_Issue195(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer func() {
+		log.SetOutput(os.Stdout)
+	}()
+
 	b, err := opBuilder("getTesting", "../fixtures/bugs/195/swagger.json")
 	if assert.NoError(t, err) {
 		op, err := b.MakeOperation()
@@ -511,6 +526,11 @@ func TestGenParameter_Issue195(t *testing.T) {
 }
 
 func TestGenParameter_Issue196(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer func() {
+		log.SetOutput(os.Stdout)
+	}()
+
 	b, err := opBuilder("postEvents", "../fixtures/bugs/196/swagger.yml")
 	if assert.NoError(t, err) {
 		op, err := b.MakeOperation()
@@ -1185,24 +1205,26 @@ func TestGenParameter_ArrayQueryParameters(t *testing.T) {
 	}
 }
 
-func assertParams(t *testing.T, fixtureConfig map[string]map[string][]string, fixture string, skipFlatten bool, withExpand bool) {
+func assertParams(t *testing.T, fixtureConfig map[string]map[string][]string, fixture string, minimalFlatten bool, withExpand bool) {
 	fixtureSpec := path.Base(fixture)
 	tassert := assert.New(t)
 	for fixtureIndex, fixtureContents := range fixtureConfig {
 		var gen codeGenOpBuilder
 		var err error
-		if skipFlatten && !withExpand {
+		if minimalFlatten && !withExpand {
+			// proceed with minimal spec flattening
 			gen, err = opBuilder(fixtureIndex, fixture)
-		} else if !skipFlatten {
+		} else if !minimalFlatten {
+			// proceed with full flattening
 			gen, err = opBuilderWithFlatten(fixtureIndex, fixture)
 		} else {
+			// proceed with spec expansion
 			gen, err = opBuilderWithExpand(fixtureIndex, fixture)
 		}
 		if tassert.NoError(err) {
 			op, err := gen.MakeOperation()
 			if tassert.NoError(err) {
 				opts := opts()
-				//opts.FlattenSpec = true
 				for fixtureTemplate, expectedCode := range fixtureContents {
 					buf := bytes.NewBuffer(nil)
 					err := templates.MustGet(fixtureTemplate).Execute(buf, op)
@@ -1751,6 +1773,9 @@ func TestGenParameter_Issue1392(t *testing.T) {
 }
 
 func TestGenParameter_Issue1513(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
 	assert := assert.New(t)
 	var assertion = `r.SetBodyParam(o.Something)`
 	gen, err := opBuilderWithFlatten("put-enum", "../fixtures/bugs/1513/enums.yaml")
@@ -3949,7 +3974,7 @@ func TestGenParameter_Issue1536_MoreMaps(t *testing.T) {
 	assertParams(t, fixtureConfig, filepath.Join("..", "fixtures", "bugs", "1536", "fixture-1536-4.yaml"), false, false)
 }
 
-func TestGenParameter_Issue15362_SkipFlatten(t *testing.T) {
+func TestGenParameter_Issue15362_WithExpand(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
 	defer func() {
 		log.SetOutput(os.Stdout)
@@ -4092,3 +4117,137 @@ func TestGenParameter_Issue1548_base64(t *testing.T) {
 
 	assertParams(t, fixtureConfig, filepath.Join("..", "fixtures", "bugs", "1548", "fixture-1548.yaml"), true, false)
 }
+
+func TestGenParameter_1572(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer func() {
+		log.SetOutput(os.Stdout)
+	}()
+	// testing fixture-1572.yaml with minimal flatten
+	// edge cases for operations schemas
+
+	/*
+	        Run the following test caes and exercise the minimal flatten mode:
+	   - [x] nil schema in body param / response
+	   - [x] interface{} in body param /response
+	   - [x] additional schema reused from model (body param and response) (with maps or arrays)
+	   - [x] primitive body / response
+	   - [x] $ref'ed response and param (check that minimal flatten expands it)
+
+	*/
+
+	fixtureConfig := map[string]map[string][]string{
+
+		// load expectations for parameters in operation get_interface_parameters.go
+		"getInterface": { // fixture index
+			"serverParameter": { // executed template
+				// expected code lines
+				`func NewGetInterfaceParams() GetInterfaceParams {`,
+				`	return GetInterfaceParams{`,
+				`type GetInterfaceParams struct {`,
+				"	HTTPRequest *http.Request `json:\"-\"`",
+				`	InterfaceBody interface{`,
+				`func (o *GetInterfaceParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {`,
+				`	o.HTTPRequest = r`,
+				`	if runtime.HasBody(r) {`,
+				`		defer r.Body.Close(`,
+				`		var body interface{`,
+				`		if err := route.Consumer.Consume(r.Body, &body); err != nil {`,
+				`			if err == io.EOF {`,
+				`				res = append(res, errors.Required("interfaceBody", "body")`,
+				`			} else {`,
+				`				res = append(res, errors.NewParseError("interfaceBody", "body", "", err)`,
+				`		} else {`,
+				`			o.InterfaceBody = body`,
+				`	} else {`,
+				`		res = append(res, errors.Required("interfaceBody", "body")`,
+				`		return errors.CompositeValidationError(res...`,
+			},
+		},
+
+		// load expectations for parameters in operation get_null_parameters.go
+		"getNull": { // fixture index
+			"serverParameter": { // executed template
+				// expected code lines
+				`func NewGetNullParams() GetNullParams {`,
+				`	return GetNullParams{`,
+				`type GetNullParams struct {`,
+				"	HTTPRequest *http.Request `json:\"-\"`",
+				`	NullBody interface{`,
+				`func (o *GetNullParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {`,
+				`	o.HTTPRequest = r`,
+				`	if runtime.HasBody(r) {`,
+				`		defer r.Body.Close(`,
+				`		var body interface{`,
+				`		if err := route.Consumer.Consume(r.Body, &body); err != nil {`,
+				`			if err == io.EOF {`,
+				`				res = append(res, errors.Required("nullBody", "body")`,
+				`			} else {`,
+				`				res = append(res, errors.NewParseError("nullBody", "body", "", err)`,
+				`		} else {`,
+				`			o.NullBody = body`,
+				`	} else {`,
+				`		res = append(res, errors.Required("nullBody", "body")`,
+				`		return errors.CompositeValidationError(res...`,
+			},
+		},
+
+		// load expectations for parameters in operation get_primitive_parameters.go
+		"getPrimitive": { // fixture index
+			"serverParameter": { // executed template
+				// expected code lines
+				`func NewGetPrimitiveParams() GetPrimitiveParams {`,
+				`	return GetPrimitiveParams{`,
+				`type GetPrimitiveParams struct {`,
+				"	HTTPRequest *http.Request `json:\"-\"`",
+				`	PrimitiveBody uint32`,
+				`func (o *GetPrimitiveParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {`,
+				`	o.HTTPRequest = r`,
+				`	if runtime.HasBody(r) {`,
+				`		defer r.Body.Close(`,
+				`		var body uint32`,
+				`		if err := route.Consumer.Consume(r.Body, &body); err != nil {`,
+				`			if err == io.EOF {`,
+				`				res = append(res, errors.Required("primitiveBody", "body")`,
+				`			} else {`,
+				`				res = append(res, errors.NewParseError("primitiveBody", "body", "", err)`,
+				`		} else {`,
+				`			o.PrimitiveBody = body`,
+				`			if err := o.validatePrimitiveBodyBody(route.Formats); err != nil {`,
+				`	} else {`,
+				`		res = append(res, errors.Required("primitiveBody", "body")`,
+				`		return errors.CompositeValidationError(res...`,
+				`func (o *GetPrimitiveParams) validatePrimitiveBodyBody(formats strfmt.Registry) error {`,
+				`	if err := validate.MaximumInt("primitiveBody", "body", int64(o.PrimitiveBody), 100, false); err != nil {`,
+			},
+		},
+
+		// load expectations for parameters in operation get_model_interface_parameters.go
+		"getModelInterface": { // fixture index
+			"serverParameter": { // executed template
+				// expected code lines
+				`func NewGetModelInterfaceParams() GetModelInterfaceParams {`,
+				`	return GetModelInterfaceParams{`,
+				`type GetModelInterfaceParams struct {`,
+				"	HTTPRequest *http.Request `json:\"-\"`",
+				`	InterfaceBody map[string]models.ModelInterface`,
+				`func (o *GetModelInterfaceParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {`,
+				`	o.HTTPRequest = r`,
+				`	if runtime.HasBody(r) {`,
+				`		defer r.Body.Close(`,
+				`		var body map[string]models.ModelInterface`,
+				`		if err := route.Consumer.Consume(r.Body, &body); err != nil {`,
+				`			if err == io.EOF {`,
+				`				res = append(res, errors.Required("interfaceBody", "body")`,
+				`			} else {`,
+				`				res = append(res, errors.NewParseError("interfaceBody", "body", "", err)`,
+				`		} else {`,
+				`			o.InterfaceBody = body`,
+				`	} else {`,
+				`		res = append(res, errors.Required("interfaceBody", "body")`,
+				`		return errors.CompositeValidationError(res...`,
+			},
+		},
+	}
+	assertParams(t, fixtureConfig, filepath.Join("..", "fixtures", "enhancements", "1572", "fixture-1572.yaml"), true, false)
+}
diff --git a/generator/pointer_test.go b/generator/pointer_test.go
index 77c6f726..f900f39b 100644
--- a/generator/pointer_test.go
+++ b/generator/pointer_test.go
@@ -81,31 +81,31 @@ func isNotNullableExt() spec.Extensions {
 }
 
 var boolPointerVals = []builtinVal{
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: false, ReadOnly: false},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: false},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: false, ReadOnly: false},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: true},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: true, ReadOnly: true},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: false, ReadOnly: false, Extensions: nullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: false, Extensions: nullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: false, ReadOnly: false, Extensions: nullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: true, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: false, ReadOnly: false, Extensions: isNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: false, Extensions: isNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: false, ReadOnly: false, Extensions: isNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: true, ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: false, ReadOnly: false, Extensions: notNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: false, Extensions: notNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: false, ReadOnly: false, Extensions: notNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: true, Extensions: notNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: true, ReadOnly: true, Extensions: notNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: false, ReadOnly: false, Extensions: isNotNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: false, Extensions: isNotNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: false, ReadOnly: false, Extensions: isNotNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: true, Extensions: isNotNullableExt()},
-	builtinVal{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: true, ReadOnly: true, Extensions: isNotNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: false, ReadOnly: false},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: false},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: false, ReadOnly: false},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: true},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: true, ReadOnly: true},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: false, ReadOnly: false, Extensions: nullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: false, Extensions: nullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: false, ReadOnly: false, Extensions: nullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: true, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: false, ReadOnly: false, Extensions: isNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: false, Extensions: isNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: false, ReadOnly: false, Extensions: isNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: nil, Required: true, ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: true, Default: true, Required: true, ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: false, ReadOnly: false, Extensions: notNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: false, Extensions: notNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: false, ReadOnly: false, Extensions: notNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: true, Extensions: notNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: true, ReadOnly: true, Extensions: notNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: false, ReadOnly: false, Extensions: isNotNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: false, Extensions: isNotNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: false, ReadOnly: false, Extensions: isNotNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: nil, Required: true, ReadOnly: true, Extensions: isNotNullableExt()},
+	{Type: "boolean", Format: "", Expected: "bool", Nullable: false, Default: true, Required: true, ReadOnly: true, Extensions: isNotNullableExt()},
 }
 
 func generateNumberPointerVals(t, v string) (result []builtinVal) {
@@ -130,253 +130,253 @@ func generateNumberPointerVals(t, v string) (result []builtinVal) {
 	}
 	return []builtinVal{
 		// plain vanilla
-		builtinVal{Type: t, Format: v, Expected: vv},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Extensions: isNullableExt()}, // 2
+		{Type: t, Format: v, Expected: vv},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Extensions: isNullableExt()}, // 2
 
 		// plain vanilla readonly and defaults
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Extensions: isNullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, ReadOnly: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 9
+		{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Extensions: isNullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, ReadOnly: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 9
 
 		// required
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Extensions: isNullableExt()}, // 12
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Extensions: isNullableExt()}, // 12
 
 		// required, readonly and defaults
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, ReadOnly: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, ReadOnly: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, ReadOnly: true, Extensions: isNullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Default: 3, ReadOnly: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 19
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, ReadOnly: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, ReadOnly: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, ReadOnly: true, Extensions: isNullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Default: 3, ReadOnly: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 19
 
 		// minimum validation
-		builtinVal{Type: t, Format: v, Expected: vv, Minimum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(2), Extensions: isNullableExt()}, // 23
+		{Type: t, Format: v, Expected: vv, Minimum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(2), Extensions: isNullableExt()}, // 23
 
 		// minimum validation, readonly and defaults
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Minimum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Minimum: swag.Float64(2), Extensions: isNullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Minimum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, ReadOnly: true, Minimum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(2), Extensions: isNullableExt()}, // 31
+		{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Minimum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Minimum: swag.Float64(2), Extensions: isNullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Minimum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, ReadOnly: true, Minimum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(2), Extensions: isNullableExt()}, // 31
 
 		// required, minimum validation
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Extensions: isNullableExt()}, // 35
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Extensions: isNullableExt()}, // 35
 
 		// required, minimum validation, readonly and defaults
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Minimum: swag.Float64(2), ReadOnly: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), ReadOnly: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), ReadOnly: true, Extensions: isNullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Default: 3},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Minimum: swag.Float64(2), Default: 3, ReadOnly: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Default: 3, ReadOnly: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 42
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Minimum: swag.Float64(2), ReadOnly: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), ReadOnly: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), ReadOnly: true, Extensions: isNullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Default: 3},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Minimum: swag.Float64(2), Default: 3, ReadOnly: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Default: 3, ReadOnly: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 42
 
 		// maximum validation
-		builtinVal{Type: t, Format: v, Expected: vv, Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Maximum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 46
+		{Type: t, Format: v, Expected: vv, Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Maximum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 46
 
 		// maximum validation, readonly and defaults
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Maximum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: isNullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, ReadOnly: true, Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 54
+		{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Maximum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: isNullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, ReadOnly: true, Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 54
 
 		// required, maximum validation
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 58
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 58
 
 		// required, maximum validation, readonly and defaults
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Maximum: swag.Float64(2), ReadOnly: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), ReadOnly: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), ReadOnly: true, Extensions: isNullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Default: 3},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Maximum: swag.Float64(2), Default: 3, ReadOnly: true},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Default: 3, ReadOnly: true, Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 65
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Maximum: swag.Float64(2), ReadOnly: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), ReadOnly: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), ReadOnly: true, Extensions: isNullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Default: 3},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Maximum: swag.Float64(2), Default: 3, ReadOnly: true},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Default: 3, ReadOnly: true, Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Maximum: swag.Float64(2), Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 65
 
 		// minimum and maximum validation
-		builtinVal{Type: t, Format: v, Expected: vv, Minimum: swag.Float64(2), Maximum: swag.Float64(5)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(1)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(0), Maximum: swag.Float64(1)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(2), Maximum: swag.Float64(6), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(2), Maximum: swag.Float64(6), Extensions: isNullableExt()}, // 72
+		{Type: t, Format: v, Expected: vv, Minimum: swag.Float64(2), Maximum: swag.Float64(5)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(1)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(0), Maximum: swag.Float64(1)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(2), Maximum: swag.Float64(6), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Minimum: swag.Float64(2), Maximum: swag.Float64(6), Extensions: isNullableExt()}, // 72
 
 		// minimum and maximum validation, readonly and defaults
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(0), Maximum: swag.Float64(3)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Minimum: swag.Float64(-1), ReadOnly: true, Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: isNullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, Minimum: swag.Float64(-1), Maximum: swag.Float64(6)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Minimum: swag.Float64(1), Maximum: swag.Float64(6)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Minimum: swag.Float64(-6), Maximum: swag.Float64(-1)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 83
+		{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(0), Maximum: swag.Float64(3)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Minimum: swag.Float64(-1), ReadOnly: true, Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: isNullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, Minimum: swag.Float64(-1), Maximum: swag.Float64(6)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Minimum: swag.Float64(1), Maximum: swag.Float64(6)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Default: 3, Minimum: swag.Float64(-6), Maximum: swag.Float64(-1)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 83
 
 		// required, minimum and maximum validation
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Maximum: swag.Float64(5)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(1)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(0), Maximum: swag.Float64(1)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Maximum: swag.Float64(6), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Maximum: swag.Float64(6), Extensions: isNullableExt()}, // 89
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Maximum: swag.Float64(5)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(1)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(0), Maximum: swag.Float64(1)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Maximum: swag.Float64(6), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Minimum: swag.Float64(2), Maximum: swag.Float64(6), Extensions: isNullableExt()}, // 89
 
 		// required, minimum and maximum validation, readonly and defaults
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, ReadOnly: true, Minimum: swag.Float64(0), Maximum: swag.Float64(3)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(0)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Default: 3, Minimum: swag.Float64(-1), ReadOnly: true, Maximum: swag.Float64(2)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: isNullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, Minimum: swag.Float64(-1), Maximum: swag.Float64(6)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, Minimum: swag.Float64(1), Maximum: swag.Float64(6)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, Minimum: swag.Float64(-6), Maximum: swag.Float64(-1)},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2), Extensions: nullableExt()},
-		builtinVal{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 99
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, ReadOnly: true, Minimum: swag.Float64(0), Maximum: swag.Float64(3)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(0)},
+		{Type: t, Format: v, Expected: vv, Nullable: false, Required: true, Default: 3, Minimum: swag.Float64(-1), ReadOnly: true, Maximum: swag.Float64(2)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, ReadOnly: true, Maximum: swag.Float64(2), Extensions: isNullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, Minimum: swag.Float64(-1), Maximum: swag.Float64(6)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, Minimum: swag.Float64(1), Maximum: swag.Float64(6)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, Minimum: swag.Float64(-6), Maximum: swag.Float64(-1)},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2), Extensions: nullableExt()},
+		{Type: t, Format: v, Expected: vv, Nullable: true, Required: true, Default: 3, ReadOnly: true, Minimum: swag.Float64(-1), Maximum: swag.Float64(2), Extensions: isNullableExt()}, // 99
 	}
 }
 
 var stringPointerVals = []builtinVal{
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Extensions: isNullableExt()}, // 2
+	{Type: "string", Format: "", Expected: "string", Nullable: false},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Extensions: isNullableExt()}, // 2
 
 	// plain vanilla readonly and defaults
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, ReadOnly: true},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, Default: 3, ReadOnly: true},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 9
+	{Type: "string", Format: "", Expected: "string", Nullable: false, ReadOnly: true},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3},
+	{Type: "string", Format: "", Expected: "string", Nullable: false, Default: 3, ReadOnly: true},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 9
 
 	// required
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Extensions: isNullableExt()}, // 12
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Extensions: isNullableExt()}, // 12
 
 	// required, readonly and defaults
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, Required: true, ReadOnly: true},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Default: 3},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, Required: true, Default: 3, ReadOnly: true},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 19
+	{Type: "string", Format: "", Expected: "string", Nullable: false, Required: true, ReadOnly: true},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Default: 3},
+	{Type: "string", Format: "", Expected: "string", Nullable: false, Required: true, Default: 3, ReadOnly: true},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 19
 
 	// minLength validation
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, MinLength: swag.Int64(2)},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, MinLength: swag.Int64(0)},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, MinLength: swag.Int64(2), Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, MinLength: swag.Int64(2), Extensions: isNullableExt()}, // 23
+	{Type: "string", Format: "", Expected: "string", Nullable: false, MinLength: swag.Int64(2)},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, MinLength: swag.Int64(0)},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, MinLength: swag.Int64(2), Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, MinLength: swag.Int64(2), Extensions: isNullableExt()}, // 23
 
 	// minLength validation, readonly and defaults
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, ReadOnly: true, MinLength: swag.Int64(2)},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, ReadOnly: true, MinLength: swag.Int64(0)},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, ReadOnly: true, MinLength: swag.Int64(2), Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, ReadOnly: true, MinLength: swag.Int64(2), Extensions: isNullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, Default: 3, MinLength: swag.Int64(2)},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, Default: 3, ReadOnly: true, MinLength: swag.Int64(2)},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3, ReadOnly: true, MinLength: swag.Int64(2), Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3, ReadOnly: true, MinLength: swag.Int64(2), Extensions: isNullableExt()}, // 31
+	{Type: "string", Format: "", Expected: "string", Nullable: false, ReadOnly: true, MinLength: swag.Int64(2)},
+	{Type: "string", Format: "", Expected: "string", Nullable: false, ReadOnly: true, MinLength: swag.Int64(0)},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, ReadOnly: true, MinLength: swag.Int64(2), Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, ReadOnly: true, MinLength: swag.Int64(2), Extensions: isNullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: false, Default: 3, MinLength: swag.Int64(2)},
+	{Type: "string", Format: "", Expected: "string", Nullable: false, Default: 3, ReadOnly: true, MinLength: swag.Int64(2)},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3, ReadOnly: true, MinLength: swag.Int64(2), Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Default: 3, ReadOnly: true, MinLength: swag.Int64(2), Extensions: isNullableExt()}, // 31
 
 	// required, minLength validation
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2)},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(0)},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Extensions: isNullableExt()}, // 35
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2)},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(0)},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Extensions: isNullableExt()}, // 35
 
 	// required, minLength validation, readonly and defaults
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, Required: true, MinLength: swag.Int64(2), ReadOnly: true},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Default: 3},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: false, Required: true, MinLength: swag.Int64(2), Default: 3, ReadOnly: true},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Default: 3, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 42
+	{Type: "string", Format: "", Expected: "string", Nullable: false, Required: true, MinLength: swag.Int64(2), ReadOnly: true},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Default: 3},
+	{Type: "string", Format: "", Expected: "string", Nullable: false, Required: true, MinLength: swag.Int64(2), Default: 3, ReadOnly: true},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Default: 3, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "", Expected: "string", Nullable: true, Required: true, MinLength: swag.Int64(2), Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 42
 }
 
 var strfmtValues = []builtinVal{
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Extensions: isNullableExt()}, // 2
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Extensions: nullableExt()},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Extensions: isNullableExt()}, // 2
 
 	// plain vanilla readonly and defaults
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false, ReadOnly: true},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Default: 3},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false, Default: 3, ReadOnly: true},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 9
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false, ReadOnly: true},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Default: 3},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false, Default: 3, ReadOnly: true},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 9
 
 	// required
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Extensions: isNullableExt()}, // 12
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Extensions: nullableExt()},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Extensions: isNullableExt()}, // 12
 
 	// required, readonly and defaults
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false, Required: true, ReadOnly: true},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Default: 3},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false, Required: true, Default: 3, ReadOnly: true},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 19
-
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Extensions: isNullableExt()}, // 22
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false, Required: true, ReadOnly: true},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Default: 3},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: false, Required: true, Default: 3, ReadOnly: true},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "password", Expected: "strfmt.Password", Nullable: true, Required: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 19
+
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Extensions: nullableExt()},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Extensions: isNullableExt()}, // 22
 
 	// plain vanilla readonly and defaults
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, ReadOnly: true},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Default: 3},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Default: 3, ReadOnly: true},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Default: 3, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 29
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, ReadOnly: true},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Default: 3},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Default: 3, ReadOnly: true},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Default: 3, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 29
 
 	// required
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Extensions: isNullableExt()}, // 32
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Extensions: nullableExt()},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Extensions: isNullableExt()}, // 32
 
 	// required, readonly and defaults
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, ReadOnly: true},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, ReadOnly: true, Extensions: isNullableExt()},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Default: 3},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Default: 3, ReadOnly: true},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
-	builtinVal{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 39
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, ReadOnly: true},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, ReadOnly: true, Extensions: isNullableExt()},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Default: 3},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Default: 3, ReadOnly: true},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Default: 3, ReadOnly: true, Extensions: nullableExt()},
+	{Type: "string", Format: "binary", Expected: "io.ReadCloser", Nullable: false, Required: true, Default: 3, ReadOnly: true, Extensions: isNullableExt()}, // 39
 }
 
 func testPointToAdditionalPropertiesElements(t testing.TB, tr typeResolver, aliased bool) bool {
diff --git a/generator/response_test.go b/generator/response_test.go
index b72d6b96..756d7586 100644
--- a/generator/response_test.go
+++ b/generator/response_test.go
@@ -484,10 +484,10 @@ func TestGenResponses_Issue892(t *testing.T) {
 }
 
 func TestGenResponses_Issue1013(t *testing.T) {
-	b, err := methodPathOpBuilder("get", "/test", "../fixtures/bugs/1013/fixture-1013.yaml")
-	if assert.NoError(t, err) {
-		op, err := b.MakeOperation()
-		if assert.NoError(t, err) {
+	b, erp := methodPathOpBuilder("get", "/test", "../fixtures/bugs/1013/fixture-1013.yaml")
+	if assert.NoError(t, erp) {
+		op, erm := b.MakeOperation()
+		if assert.NoError(t, erm) {
 			var buf bytes.Buffer
 			opts := opts()
 			if assert.NoError(t, templates.MustGet("serverResponses").Execute(&buf, op)) {
@@ -500,10 +500,10 @@ func TestGenResponses_Issue1013(t *testing.T) {
 			}
 		}
 	}
-	b, err = methodPathOpBuilder("get", "/test2", "../fixtures/bugs/1013/fixture-1013.yaml")
-	if assert.NoError(t, err) {
-		op, err := b.MakeOperation()
-		if assert.NoError(t, err) {
+	b, erp = methodPathOpBuilder("get", "/test2", "../fixtures/bugs/1013/fixture-1013.yaml")
+	if assert.NoError(t, erp) {
+		op, erm := b.MakeOperation()
+		if assert.NoError(t, erm) {
 			var buf bytes.Buffer
 			opts := opts()
 			if assert.NoError(t, templates.MustGet("serverResponses").Execute(&buf, op)) {
@@ -518,7 +518,7 @@ func TestGenResponses_Issue1013(t *testing.T) {
 	}
 }
 
-func TestGenResponse_15362_SkipFlatten(t *testing.T) {
+func TestGenResponse_15362_WithExpand(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
 	defer func() {
 		log.SetOutput(os.Stdout)
@@ -554,3 +554,125 @@ func TestGenResponse_15362_SkipFlatten(t *testing.T) {
 	// assertParams also works for responses
 	assertParams(t, fixtureConfig, filepath.Join("..", "fixtures", "bugs", "1536", "fixture-1536-2-responses.yaml"), true, false)
 }
+
+func TestGenResponse_1572(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer func() {
+		log.SetOutput(os.Stdout)
+	}()
+
+	// testing fixture-1572.yaml with minimal flatten
+	// edge cases for operations schemas
+
+	/*
+	        Run the following test caes and exercise the minimal flatten mode:
+	   - [x] nil schema in body param / response
+	   - [x] interface{} in body param /response
+	   - [x] additional schema reused from model (body param and response) (with maps or arrays)
+	   - [x] primitive body / response
+	   - [x] $ref'ed response and param (check that minimal flatten expands it)
+
+	*/
+
+	fixtureConfig := map[string]map[string][]string{
+
+		// load expectations for responses in operation get_interface_responses.go
+		"getInterface": { // fixture index
+			"serverResponses": { // executed template
+				// expected code lines
+				`const GetInterfaceOKCode int = 200`,
+				`type GetInterfaceOK struct {`,
+				"	Payload interface{} `json:\"body,omitempty\"`",
+				`func NewGetInterfaceOK() *GetInterfaceOK {`,
+				`	return &GetInterfaceOK{`,
+				`func (o *GetInterfaceOK) WithPayload(payload interface{}) *GetInterfaceOK {`,
+				`	o.Payload = payload`,
+				`	return o`,
+				`func (o *GetInterfaceOK) SetPayload(payload interface{}) {`,
+				`	o.Payload = payload`,
+				`func (o *GetInterfaceOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {`,
+				`	rw.WriteHeader(200`,
+				`	payload := o.Payload`,
+				`	if err := producer.Produce(rw, payload); err != nil {`,
+			},
+		},
+
+		// load expectations for responses in operation get_primitive_responses.go
+		"getPrimitive": { // fixture index
+			"serverResponses": { // executed template
+				// expected code lines
+				`const GetPrimitiveOKCode int = 200`,
+				`type GetPrimitiveOK struct {`,
+				"	Payload float32 `json:\"body,omitempty\"`",
+				`func NewGetPrimitiveOK() *GetPrimitiveOK {`,
+				`	return &GetPrimitiveOK{`,
+				`func (o *GetPrimitiveOK) WithPayload(payload float32) *GetPrimitiveOK {`,
+				`	o.Payload = payload`,
+				`	return o`,
+				`func (o *GetPrimitiveOK) SetPayload(payload float32) {`,
+				`	o.Payload = payload`,
+				`func (o *GetPrimitiveOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {`,
+				`	rw.WriteHeader(200`,
+				`	payload := o.Payload`,
+				`	if err := producer.Produce(rw, payload); err != nil {`,
+			},
+		},
+
+		// load expectations for responses in operation get_null_responses.go
+		"getNull": { // fixture index
+			"serverResponses": { // executed template
+				// expected code lines
+				`const GetNullOKCode int = 200`,
+				`type GetNullOK struct {`,
+				"	Payload interface{} `json:\"body,omitempty\"`",
+				`func NewGetNullOK() *GetNullOK {`,
+				`	return &GetNullOK{`,
+				`func (o *GetNullOK) WithPayload(payload interface{}) *GetNullOK {`,
+				`	o.Payload = payload`,
+				`	return o`,
+				`func (o *GetNullOK) SetPayload(payload interface{}) {`,
+				`	o.Payload = payload`,
+				`func (o *GetNullOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {`,
+				`	rw.WriteHeader(200`,
+				`	payload := o.Payload`,
+				`	if err := producer.Produce(rw, payload); err != nil {`,
+				`const GetNullRequestProcessedCode int = 203`,
+				`/*GetNullRequestProcessed OK`,
+				`swagger:response getNullRequestProcessed`,
+				`*/`,
+				`type GetNullRequestProcessed struct {`,
+				`func NewGetNullRequestProcessed() *GetNullRequestProcessed {`,
+				`	return &GetNullRequestProcessed{`,
+				`func (o *GetNullRequestProcessed) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {`,
+				`	rw.Header().Del(runtime.HeaderContentType`,
+				`	rw.WriteHeader(203`,
+			},
+		},
+
+		// load expectations for responses in operation get_model_interface_responses.go
+		"getModelInterface": { // fixture index
+			"serverResponses": { // executed template
+				// expected code lines
+				`const GetModelInterfaceOKCode int = 200`,
+				`type GetModelInterfaceOK struct {`,
+				"	Payload []models.ModelInterface `json:\"body,omitempty\"`",
+				`func NewGetModelInterfaceOK() *GetModelInterfaceOK {`,
+				`	return &GetModelInterfaceOK{`,
+				`func (o *GetModelInterfaceOK) WithPayload(payload []models.ModelInterface) *GetModelInterfaceOK {`,
+				`	o.Payload = payload`,
+				`	return o`,
+				`func (o *GetModelInterfaceOK) SetPayload(payload []models.ModelInterface) {`,
+				`	o.Payload = payload`,
+				`func (o *GetModelInterfaceOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {`,
+				`	rw.WriteHeader(200`,
+				`	payload := o.Payload`,
+				`	if payload == nil {`,
+				`		payload = make([]models.ModelInterface, 0, 50`,
+				`	if err := producer.Produce(rw, payload); err != nil {`,
+			},
+		},
+	}
+
+	// assertParams also works for responses
+	assertParams(t, fixtureConfig, filepath.Join("..", "fixtures", "enhancements", "1572", "fixture-1572.yaml"), true, false)
+}
diff --git a/generator/server_test.go b/generator/server_test.go
index e166ea1d..4c921006 100644
--- a/generator/server_test.go
+++ b/generator/server_test.go
@@ -154,6 +154,8 @@ func TestServer_MultipartForm(t *testing.T) {
 }
 
 func TestServer_InvalidSpec(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/825/swagger.yml"
 	opts.ValidateSpec = true
@@ -265,7 +267,7 @@ func badParseCall() {
 
 	var badParse = `{{{ define "T1" }}T1{{end}}{{ define "T2" }}T2{{end}}`
 
-	templates.AddFile("badparse", badParse)
+	_ = templates.AddFile("badparse", badParse)
 	gen, _ := testAppGenerator(nil, "../fixtures/bugs/899/swagger.yml", "trailing slash")
 	app, _ := gen.makeCodegenApp()
 	log.SetOutput(ioutil.Discard)
@@ -289,9 +291,9 @@ func TestServer_OperationGroups(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
 	defer func() {
 		log.SetOutput(os.Stdout)
-		os.RemoveAll(filepath.Join(".", "restapi"))
-		os.RemoveAll(filepath.Join(".", "search"))
-		os.RemoveAll(filepath.Join(".", "tasks"))
+		_ = os.RemoveAll(filepath.Join(".", "restapi"))
+		_ = os.RemoveAll(filepath.Join(".", "search"))
+		_ = os.RemoveAll(filepath.Join(".", "tasks"))
 	}()
 
 	gen, err := testAppGenerator(t, "../fixtures/codegen/simplesearch.yml", "search")
@@ -319,7 +321,7 @@ func TestServer_OperationGroups(t *testing.T) {
 {{ range .Operations }}
 	// OperationName={{.Name}}
 {{end}}`
-		templates.AddFile("opGroupTest", opGroupTpl)
+		_ = templates.AddFile("opGroupTest", opGroupTpl)
 		err = gen.Generate()
 		assert.NoError(t, err)
 		//buf := bytes.NewBuffer(nil)
diff --git a/generator/shared.go b/generator/shared.go
index 9309e10b..70b3cf7d 100644
--- a/generator/shared.go
+++ b/generator/shared.go
@@ -378,22 +378,21 @@ type SectionOpts struct {
 
 // GenOpts the options for the generator
 type GenOpts struct {
-	IncludeModel       bool
-	IncludeValidator   bool
-	IncludeHandler     bool
-	IncludeParameters  bool
-	IncludeResponses   bool
-	IncludeURLBuilder  bool
-	IncludeMain        bool
-	IncludeSupport     bool
-	ExcludeSpec        bool
-	DumpData           bool
-	WithContext        bool
-	ValidateSpec       bool
-	FlattenSpec        bool
-	FlattenDefinitions bool
-	IsClient           bool
-	defaultsEnsured    bool
+	IncludeModel      bool
+	IncludeValidator  bool
+	IncludeHandler    bool
+	IncludeParameters bool
+	IncludeResponses  bool
+	IncludeURLBuilder bool
+	IncludeMain       bool
+	IncludeSupport    bool
+	ExcludeSpec       bool
+	DumpData          bool
+	WithContext       bool
+	ValidateSpec      bool
+	FlattenOpts       *analysis.FlattenOpts
+	IsClient          bool
+	defaultsEnsured   bool
 
 	Spec              string
 	APIPackage        string
@@ -483,6 +482,13 @@ func (g *GenOpts) EnsureDefaults() error {
 	if g.LanguageOpts == nil {
 		g.LanguageOpts = GoLangOpts()
 	}
+	// set defaults for flattening options
+	g.FlattenOpts = &analysis.FlattenOpts{
+		Minimal:      true,
+		Verbose:      true,
+		RemoveUnused: false,
+		Expand:       false,
+	}
 	g.defaultsEnsured = true
 	return nil
 }
@@ -916,6 +922,7 @@ func validateAndFlattenSpec(opts *GenOpts, specDoc *loads.Document) (*loads.Docu
 
 	// Validate if needed
 	if opts.ValidateSpec {
+		log.Printf("validating spec %v", opts.Spec)
 		if erv := validateSpec(opts.Spec, specDoc); erv != nil {
 			return specDoc, erv
 		}
@@ -933,27 +940,44 @@ func validateAndFlattenSpec(opts *GenOpts, specDoc *loads.Document) (*loads.Docu
 		absBasePath = filepath.Join(cwd, absBasePath)
 	}
 
-	/********************************************************************************************/
-	/* Either flatten or expand should be called here before moving on the code generation part */
-	/********************************************************************************************/
-	if opts.FlattenSpec {
-		flattenOpts := analysis.FlattenOpts{
-			Expand: false,
-			// BasePath must be absolute. This is guaranteed because opts.Spec is absolute
-			BasePath: absBasePath,
-			Spec:     analysis.New(specDoc.Spec()),
-		}
-		err = analysis.Flatten(flattenOpts)
+	// Some preprocessing is required before codegen
+	//
+	// This ensures at least that $ref's in the spec document are canonical,
+	// i.e all $ref are local to this file and point to some uniquely named definition.
+	//
+	// Default option is to ensure minimal flattening of $ref, bundling remote $refs and relocating arbitrary JSON
+	// pointers as definitions.
+	// This preprocessing may introduce duplicate names (e.g. remote $ref with same name). In this case, a definition
+	// suffixed with "OAIGen" is produced.
+	//
+	// Full flattening option farther transforms the spec by moving every complex object (e.g. with some properties)
+	// as a standalone definition.
+	//
+	// Eventually, an "expand spec" option is available. It is essentially useful for testing purposes.
+	//
+	// NOTE(fredbi): spec expansion may produce some unsupported constructs and is not yet protected against the following cases:
+	//  - polymorphic types generation may fail with expansion (expand destructs the reuse intent of the $ref in allOf)
+	//  - name duplicates may occur and result in compilation failures
+	// The right place to fix these shortcomings is go-openapi/analysis.
+
+	opts.FlattenOpts.BasePath = absBasePath // BasePath must be absolute. This is guaranteed because opts.Spec is absolute
+	opts.FlattenOpts.Spec = analysis.New(specDoc.Spec())
+
+	var preprocessingOption string
+	if opts.FlattenOpts.Expand {
+		preprocessingOption = "expand"
+	} else if opts.FlattenOpts.Minimal {
+		preprocessingOption = "minimal flattening"
 	} else {
-		err = spec.ExpandSpec(specDoc.Spec(), &spec.ExpandOptions{
-			RelativeBase: absBasePath,
-			SkipSchemas:  false,
-		})
+		preprocessingOption = "full flattening"
 	}
-	if err != nil {
+	log.Printf("preprocessing spec with option:  %s", preprocessingOption)
+
+	if err = analysis.Flatten(*opts.FlattenOpts); err != nil {
 		return nil, err
 	}
 
+	// yields the preprocessed spec document
 	return specDoc, nil
 }
 
diff --git a/generator/shared_test.go b/generator/shared_test.go
index 26b50618..ad0de6d1 100644
--- a/generator/shared_test.go
+++ b/generator/shared_test.go
@@ -198,7 +198,7 @@ func TestShared_GarbledTemplate(t *testing.T) {
 
 	garbled := "func x {{;;; garbled"
 
-	templates.AddFile("garbled", garbled)
+	_ = templates.AddFile("garbled", garbled)
 	opts := GenOpts{}
 	tplOpts := TemplateOpts{
 		Name:       "Garbled",
@@ -229,7 +229,7 @@ func TestShared_ExecTemplate(t *testing.T) {
 	// Not a failure: no value data
 	execfailure1 := "func x {{ .NotInData }}"
 
-	templates.AddFile("execfailure1", execfailure1)
+	_ = templates.AddFile("execfailure1", execfailure1)
 	opts := new(GenOpts)
 	tplOpts := TemplateOpts{
 		Name:       "execFailure1",
@@ -246,7 +246,7 @@ func TestShared_ExecTemplate(t *testing.T) {
 
 	execfailure2 := "func {{ .MyFaultyMethod }}"
 
-	templates.AddFile("execfailure2", execfailure2)
+	_ = templates.AddFile("execfailure2", execfailure2)
 	opts = new(GenOpts)
 	tplOpts2 := TemplateOpts{
 		Name:       "execFailure2",
@@ -269,8 +269,8 @@ func TestShared_BadFormatTemplate(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
 
 	defer func() {
-		os.Remove("test_badformat.gol")
-		os.Remove("test_badformat2.gol")
+		_ = os.Remove("test_badformat.gol")
+		_ = os.Remove("test_badformat2.gol")
 		log.SetOutput(os.Stdout)
 		Debug = false
 	}()
@@ -279,7 +279,7 @@ func TestShared_BadFormatTemplate(t *testing.T) {
 	badFormat := "func x {;;; garbled"
 
 	Debug = true
-	templates.AddFile("badformat", badFormat)
+	_ = templates.AddFile("badformat", badFormat)
 
 	opts := GenOpts{}
 	opts.LanguageOpts = GoLangOpts()
@@ -303,7 +303,7 @@ func TestShared_BadFormatTemplate(t *testing.T) {
 	// The badly formatted file has been dumped for debugging purposes
 	_, exists := os.Stat(tplOpts.FileName)
 	assert.True(t, !os.IsNotExist(exists), "The template file has not been generated as expected")
-	os.Remove(tplOpts.FileName)
+	_ = os.Remove(tplOpts.FileName)
 
 	assert.NotNil(t, err)
 	assert.Contains(t, err.Error(), "source formatting on generated source")
@@ -325,7 +325,7 @@ func TestShared_BadFormatTemplate(t *testing.T) {
 	// The unformatted file has been dumped without format checks
 	_, exists2 := os.Stat(tplOpts2.FileName)
 	assert.True(t, !os.IsNotExist(exists2), "The template file has not been generated as expected")
-	os.Remove(tplOpts2.FileName)
+	_ = os.Remove(tplOpts2.FileName)
 
 	assert.Nil(t, err2)
 
@@ -337,7 +337,7 @@ func TestShared_DirectoryTemplate(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
 
 	defer func() {
-		os.RemoveAll("TestGenDir")
+		_ = os.RemoveAll("TestGenDir")
 		log.SetOutput(os.Stdout)
 		Debug = false
 	}()
@@ -346,7 +346,7 @@ func TestShared_DirectoryTemplate(t *testing.T) {
 	content := "func x {}"
 
 	Debug = true
-	templates.AddFile("gendir", content)
+	_ = templates.AddFile("gendir", content)
 
 	opts := GenOpts{}
 	opts.LanguageOpts = GoLangOpts()
@@ -370,7 +370,7 @@ func TestShared_DirectoryTemplate(t *testing.T) {
 	// The badly formatted file has been dumped for debugging purposes
 	_, exists := os.Stat(filepath.Join(tplOpts.Target, tplOpts.FileName))
 	assert.True(t, !os.IsNotExist(exists), "The template file has not been generated as expected")
-	os.RemoveAll(tplOpts.Target)
+	_ = os.RemoveAll(tplOpts.Target)
 
 	assert.Nil(t, err)
 }
diff --git a/generator/support.go b/generator/support.go
index 20869502..7f7cb4a0 100644
--- a/generator/support.go
+++ b/generator/support.go
@@ -394,7 +394,7 @@ func (a *appGenerator) makeConsumes() (consumes GenSerGroups, consumesJSON bool)
 			ReceiverName: a.Receiver,
 			Name:         "json",
 			MediaType:    runtime.JSONMime,
-			AllSerializers: []GenSerializer{GenSerializer{
+			AllSerializers: []GenSerializer{{
 				AppName:        a.Name,
 				ReceiverName:   a.Receiver,
 				Name:           "json",
@@ -470,7 +470,7 @@ func (a *appGenerator) makeProduces() (produces GenSerGroups, producesJSON bool)
 			ReceiverName: a.Receiver,
 			Name:         "json",
 			MediaType:    runtime.JSONMime,
-			AllSerializers: []GenSerializer{GenSerializer{
+			AllSerializers: []GenSerializer{{
 				AppName:        a.Name,
 				ReceiverName:   a.Receiver,
 				Name:           "json",
diff --git a/generator/support_test.go b/generator/support_test.go
index ce58014a..998f7362 100644
--- a/generator/support_test.go
+++ b/generator/support_test.go
@@ -1,7 +1,6 @@
 package generator
 
 import (
-	"log"
 	"os"
 	"path/filepath"
 	goruntime "runtime"
@@ -77,8 +76,10 @@ func TestBaseImport(t *testing.T) {
 	// 3. Check results.
 
 	oldgopath := os.Getenv("GOPATH")
-	defer os.Setenv("GOPATH", oldgopath)
-	defer os.RemoveAll(filepath.Join(tempdir, "root"))
+	defer func() {
+		_ = os.Setenv("GOPATH", oldgopath)
+		_ = os.RemoveAll(filepath.Join(tempdir, "root"))
+	}()
 
 	for _, item := range checkbaseimporttest {
 
@@ -105,11 +106,11 @@ func TestBaseImport(t *testing.T) {
 					t.Errorf("baseImport(%s): expected %s, actual %s", item.targetpath, item.expectedpath, actualpath)
 				}
 
-				os.RemoveAll(filepath.Join(tempdir, "root"))
+				_ = os.RemoveAll(filepath.Join(tempdir, "root"))
 
 			} else {
-				log.Printf("WARNING:TestBaseImport with symlink could not be carried on. Symlink creation failed for %s -> %s: %v", item.symlinksrc, item.symlinkdest, err)
-				log.Printf("WARNING:TestBaseImport with symlink on Windows requires extended privileges (admin or a user with SeCreateSymbolicLinkPrivilege)")
+				t.Logf("WARNING:TestBaseImport with symlink could not be carried on. Symlink creation failed for %s -> %s: %v", item.symlinksrc, item.symlinkdest, err)
+				t.Logf("WARNING:TestBaseImport with symlink on Windows requires extended privileges (admin or a user with SeCreateSymbolicLinkPrivilege)")
 			}
 		}
 	}
diff --git a/generator/template_repo_test.go b/generator/template_repo_test.go
index 442b6856..6cc77269 100644
--- a/generator/template_repo_test.go
+++ b/generator/template_repo_test.go
@@ -415,8 +415,8 @@ func TestTemplates_AddFile(t *testing.T) {
 	// unprotected
 	err := AddFile("functpl", funcTpl)
 	if assert.NoError(t, err) {
-		_, err := templates.Get("functpl")
-		assert.Nil(t, err)
+		_, erg := templates.Get("functpl")
+		assert.Nil(t, erg)
 	}
 	// protected
 	err = AddFile("schemabody", funcTpl)
diff --git a/hack/.gitignore b/hack/.gitignore
new file mode 100644
index 00000000..06ae71f4
--- /dev/null
+++ b/hack/.gitignore
@@ -0,0 +1 @@
+tmp-gen
diff --git a/hack/codegen-nonreg.sh b/hack/codegen-nonreg.sh
index 76f7a31b..f8ad901a 100755
--- a/hack/codegen-nonreg.sh
+++ b/hack/codegen-nonreg.sh
@@ -59,22 +59,26 @@ fi
 
 # NOTE(fredbi): 
 # The following ones fail generation: 
-# - todo existing_model requires pregeneration
+# - existing-model.yml requires pregeneration (not supported yet by this script)
 # - issue72: model works with --skip-validation. Invalid spec (duplicate operationID)
 # - todolist.simple.yml: invalid default values put on purpose for UT (provided fixed version for testing)
+# - fixture-basetypes.yaml: exhibits some edge case failures with discriminator (e.g. using a base type in tuple...)
+# - fixture-polymorphism.yaml: idem
 #
 # The following ones requires some checks to be skipped:
 # - azure-text-analyis.json: works with --skip-validation. Invalid specification with duplicate property in allOf construct (provided fixed version for testing)
-# - azure-text-analyis.json: should work with -skip-validation
+# - swagger-gsma.json: idem
 #
 # The following ones used to fail and are ok:
-# - todolist.discriminators.yml: works
-# - bitbucket.json: works nows
+# - todolist.discriminators.yml: works (not with expand)
+# - bitbucket.json: works nows (not with expand: too many files for ordinary ulimit)
 # - cloudbreak.json : now works
 known_failed="@(\
 existing-model.yml|\
 issue72.json|\
-todolist.simple.yml\
+todolist.simple.yml|\
+fixture-basetypes.yaml|\
+fixture-polymorphism.yaml|\
 )"
 # The following ones should fail validation, but produce correct generated code (at least it builds)
 known_skip_validation="@(\
@@ -83,7 +87,12 @@ todolist.enums.flattened.json|\
 todolist.models.yml|\
 todolist.schemavalidation.yml|\
 azure-text-analyis.json|\
-swagger-gsma.json\
+swagger-gsma.json|\
+fixture-844-variations.yaml|\
+fixture-allOf.yaml|\
+fixture-errors.yaml|\
+fixture-itching.yaml|\
+fixture-tuple.yaml|\
 )"
 
 # A list of known client build failures
@@ -106,14 +115,28 @@ fixture-1392-2.yaml|\
 fixture-1392-3.yaml|\
 )"
 
-if [[ "$1" = "--circleci" ]] ; then
+# A list of known fixtures not supporting expand mode (not including the discriminator case).
+# Normally, this is because of duplicate names constructed during codegen of anonmyous structures.
+# This should be solved with proper analysis of names before codegen.
+known_expand_failure="@(\
+todolist.enums.flattened.json|\
+fixture-1479.yaml\
+bitbucket.json|\
+)"
+
+if [[ "$1" == "--circleci" ]] ; then
     # Coloured output not supported by default on CircleCI.
     # Forcing term to xterm is not enough: tput not available with minimalist env.
     MONO=1
+    # In CI run, test builds with default option (minimal flatten)
+    OPTS="--with-flatten=minimal"
     #export TERM=xterm
     #MONO=""
 else
+    # In manual run, enable coloured output
     MONO=""
+    # In manual run, test the full range of available options for spec preprocessing
+    OPTS="--with-flatten=full --with-flatten=minimal --with-flatten=expand"
 fi
 
 # A little chrome does not hurt...
@@ -125,103 +148,140 @@ specdir="../fixtures/codegen ../fixtures/bugs/909 ../fixtures/bugs/1437 ../fixtu
 specdir=${specdir}" ../fixtures/bugs/1392"
 specdir=${specdir}" ../fixtures/bugs/1277"
 specdir=${specdir}" ../fixtures/bugs/1536"
+specdir=${specdir}" ../fixtures/bugs/1487"
 gendir=./tmp-gen
 rm -rf ${gendir}
 
 check_list=`for d in ${specdir}; do ls $d/*.yml;ls $d/*.json;ls $d/*.yaml;done 2>/dev/null`
+list=( $check_list )
+fixtures_count=${#list[@]}
+okcr "Running codegen for ${fixtures_count} specs"
+
 for spec in ${check_list}; do 
     testcase=${spec##*/}
-
     case ${testcase} in 
     ${known_failed})
         warncr "[`date +%T`]${spec}: not tested against full build because of known issues."
         run="false"
         opts=""
         buildClient="false"
+        noexpand="false"
         ;;
     ${known_skip_validation})
-        info "[`date +%T`]${spec}: assumed invalid but tested against full build..."
+        infocr "[`date +%T`]${spec}: assumed spec is invalid but tested against build nonetheless..."
         run="true"
         opts="--skip-validation"
         buildClient="true"
+        noexpand="false"
         ;;
     ${known_client_failure})
         warncr "[`date +%T`]${spec}: will not attempt to build the client because of known issues..."
         run="true"
         opts=""
         buildClient="false"
+        noexpand="false"
+        ;;
+    ${known_expand_failure})
+        warncr "[`date +%T`]${spec}: will not attempt to build with expand mode because of known issues..."
+        run="true"
+        opts=""
+        buildClient="false"
+        noexpand="true"
         ;;
     *)
-        printf "[`date +%T`]%s: %s..." ${spec} "assumed valid and tested against build"
+        infocr "[`date +%T`]${spec}: assumed valid and tested against build."
         run="true"
         opts=""
         buildClient="true"
+        noexpand="false"
         ;;
     esac
 
-    if [[ ${run} == "true" ]]; then
-        target=${gendir}/gen-${testcase%.*}
-        target_client=${gendir}/gen-${testcase%.*}"-client"
-        server_name="nrcodegen"
-        client_name="nrcodegen"
-        errlog=${gendir}/stderr.log
+	if [[ ${run} == "true" ]]; then
+        declare -i index=0
+        for preprocessingOpts in ${OPTS} ; do
+            index+=1
+            infocr "Generation with options: ${preprocessingOpts} ${opts}"
+	
+            # Do not attempt to generate on expanded specs when there is a discriminator specified
+	        grep -q discriminator ${spec}
+	        discriminated=$?
+	        if [[ ${discriminated} -eq 0 && ${preprocessingOpts} == "--with-flatten=expand" ]] ; then
+	            warncr "Skipped ${testcase} with ${preprocessingOpts}: discriminator not supported in this mode"
+	            continue
+	        fi
+            if [[ ${noexpand} != "true" && ${preprocessingOpts} == "--with-flatten=expand" ]] ; then
+                continue
+            fi
+	
+	        target=${gendir}/gen-${testcase%.*}${index}
+	        target_client=${gendir}/gen-${testcase%.*}${index}"-client"
+
+	        server_name="nrcodegen"
+	        client_name="nrcodegen"
+	        errlog=${gendir}/stderr.log
+	
+	        rm -rf ${target} ${target_client}
+	        mkdir -p ${target} ${target_client}
+	        rm -f ${errlog}
+	
+	        # Gen server
+	        swagger generate server --spec ${spec} --target ${target} --name=${server_name} --quiet ${opts} ${preprocessingOpts} 2>${errlog}
+	        if [[ $? != 0 ]] ; then
+	            errcr "Generation Failed"
+	            if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
+	            exit 1
+	        fi
+	        ok `printf " %s..."  "Generation server OK"`
+	        rm -f ${errlog}
+	        # Gen client
+	        swagger generate client --spec ${spec} --target ${target_client} --name=${client_name} --quiet ${opts} ${preprocessingOpts} 2>${errlog}
+	        if [[ $? != 0 ]] ; then
+	            errcr "Generation Failed"
+	            if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
+	            exit 1
+	        fi
+	        ok `printf " %s..."  "Generation client OK"`
 
-        rm -rf ${target} ${target_client}
-        mkdir -p ${target} ${target_client}
-        rm -f ${errlog}
+            #
+            # Check build on generated artifacts
+            #
 
-        # Gen server
-        swagger generate server --spec ${spec} --target ${target} --name=${server_name} --quiet ${opts} 2>${errlog}
-        if [[ $? != 0 ]] ; then
-            errcr "Generation Failed"
-            if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
-            exit 1
-        fi
-        ok `printf " %s..."  "Generation server OK"`
-        rm -f ${errlog}
-        # Gen client
-        swagger generate client --spec ${spec} --target ${target_client} --name=${client_name} --quiet ${opts} 2>${errlog}
-        if [[ $? != 0 ]] ; then
-            errcr "Generation Failed"
-            if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
-            exit 1
-        fi
-        ok `printf " %s..."  "Generation client OK"`
-        # Build server
-        (cd ${target}/cmd/${server_name}"-server"; go build) 2>${errlog}
-        if [[ $? != 0 ]] ; then
-            errcr "Server build Failed"
-            if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
-            exit 1
-        fi
-        ok `printf " %s..."  "Server build OK"`
-        # Build models if any produced 
-        if [[ -d ${target}/models ]] ; then 
-            (cd ${target}/models ; go build) 2>${errlog}
-            if [[ $? != 0 ]] ; then
-                errcr "Model build Failed"
-                if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
-                exit 1
-            fi
-        fi
-        ok `printf " %s..."  "Models build OK"`
-        # Build client
-        if [[ ${buildClient} == "false" ]] ; then
-            warn "(no client built)"
-            # continue
-        else
-            (cd ${target_client}/client ; go build) 2>${errlog}
-            if [[ $? != 0 ]] ; then
-                errcr "Client build Failed"
-                if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
-                exit 1
-            fi
-            ok `printf " %s..."  "Client build OK"`
-        fi
-        successcr "[All builds: OK]"
-        rm -f ${errlog}
-        rm -rf ${target}
-    fi
+	        # Build server
+	        (cd ${target}/cmd/${server_name}"-server"; go build) 2>${errlog}
+	        if [[ $? != 0 ]] ; then
+	            errcr "Server build Failed"
+	            if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
+	            exit 1
+	        fi
+	        ok `printf " %s..."  "Server build OK"`
+	        # Build models if any produced 
+	        if [[ -d ${target}/models ]] ; then 
+	            (cd ${target}/models ; go build) 2>${errlog}
+	            if [[ $? != 0 ]] ; then
+	                errcr "Model build Failed"
+	                if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
+	                exit 1
+	            fi
+	        fi
+	        ok `printf " %s..."  "Models build OK"`
+	        # Build client
+	        if [[ ${buildClient} == "false" ]] ; then
+	            warn "(no client built)"
+	        else
+	            (cd ${target_client}/client ; go build) 2>${errlog}
+	            if [[ $? != 0 ]] ; then
+	                errcr "Client build Failed"
+	                if [[ -f ${errlog} ]] ; then errcr `cat ${errlog}` ; rm ${errlog};fi
+	                exit 1
+	            fi
+	            ok `printf " %s..."  "Client build OK"`
+	        fi
+	        successcr " [All builds for ${spec}:  OK]"
+	        rm -f ${errlog}
+	        rm -rf ${target} ${target_client}
+	    done
+	fi
 done
 rm -rf ${gendir}
 exit 0
