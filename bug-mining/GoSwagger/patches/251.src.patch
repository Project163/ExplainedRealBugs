diff --git a/.gitignore b/.gitignore
index 306ec130..f678851b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -59,3 +59,6 @@ tmp/
 cover/
 bin/
 enter-deploy-env.sh
+
+coverage.txt
+
diff --git a/.golangci.yml b/.golangci.yml
index c2c50713..aa0d6625 100644
--- a/.golangci.yml
+++ b/.golangci.yml
@@ -17,4 +17,8 @@ linters:
   enable-all: true
   disable:
     - maligned
+    - unparam
     - lll
+    - gochecknoinits
+    - gochecknoglobals
+    - dupl
\ No newline at end of file
diff --git a/README.md b/README.md
index 3ccadf09..ad100634 100644
--- a/README.md
+++ b/README.md
@@ -84,6 +84,7 @@ Here is an outline of available features (see the full list [here](https://goswa
   - Validation
   - Authorization
   - Swagger docs UI
+  - A Diff tool which will cause a build to fail if a change in the spec breaks backwards compatibility
 
 There is more to that...
 
@@ -166,6 +167,15 @@ Merge specifications (composition):
 swagger mixin {spec1} {spec2}
 ```
 
+### Compare specs
+
+The  diff command allows you to check backwards compatibility.
+Type ```swagger diff --help``` for info.
+
+```
+swagger diff {spec1} {spec2}
+```
+
 ## Try it
 
 Try `go-swagger` in a free online workspace using Gitpod:
diff --git a/appveyor.yml b/appveyor.yml
index a0b9ce8c..bda81c21 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -43,6 +43,7 @@ install:
   - go get -u github.com/axw/gocov/gocov
   - go get -u gopkg.in/matm/v1/gocov-html
   - go get -u github.com/cee-dub/go-junit-report
+  - go get -u github.com/corbym/gocrest
 
 build_script:
   - cd %APPVEYOR_BUILD_FOLDER%
diff --git a/cmd/swagger/commands/diff.go b/cmd/swagger/commands/diff.go
new file mode 100644
index 00000000..9836b8b9
--- /dev/null
+++ b/cmd/swagger/commands/diff.go
@@ -0,0 +1,115 @@
+package commands
+
+import (
+	"encoding/json"
+	"errors"
+	"io/ioutil"
+	"log"
+	"os"
+
+	"github.com/go-openapi/loads"
+	"github.com/go-swagger/go-swagger/cmd/swagger/commands/diff"
+)
+
+// JSONFormat for json
+const JSONFormat = "json"
+
+// DiffCommand is a command that generates the diff of two swagger specs.
+//
+// There are no specific options for this expansion.
+type DiffCommand struct {
+	OnlyBreakingChanges bool   `long:"break" short:"b" description:"When present, only shows incompatible changes"`
+	Format              string `long:"format" short:"f" description:"When present, writes output as json" default:"txt" choice:"txt" choice:"json"`
+	IgnoreFile          string `long:"ignore" short:"i" description:"Exception file of diffs to ignore (copy output from json diff format)"  default:"none specified"`
+	Destination         string `long:"dest" short:"d" description:"Output destination file or stdout" default:"stdout"`
+}
+
+// Execute diffs the two specs provided
+func (c *DiffCommand) Execute(args []string) error {
+	if len(args) != 2 {
+		msg := `missing arguments for diff command (use --help for more info)`
+		return errors.New(msg)
+	}
+
+	log.Println("Run Config:")
+	log.Printf("Spec1: %s", args[0])
+	log.Printf("Spec2: %s", args[1])
+	log.Printf("ReportOnlyBreakingChanges (-c) :%v", c.OnlyBreakingChanges)
+	log.Printf("OutputFormat (-f) :%s", c.Format)
+	log.Printf("IgnoreFile (-i) :%s", c.IgnoreFile)
+	log.Printf("Diff Report Destination (-d) :%s", c.Destination)
+
+	diffs, err := getDiffs(args[0], args[1])
+	if err != nil {
+		return err
+	}
+
+	ignores, err := readIgnores(c.IgnoreFile)
+	if err != nil {
+		return err
+	}
+	diffs = diffs.FilterIgnores(ignores)
+	if len(ignores) > 0 {
+		log.Printf("Diff Report Ignored Items from IgnoreFile")
+		for _, eachItem := range ignores {
+			log.Printf("%s", eachItem.String())
+		}
+	}
+
+	if c.Format == JSONFormat {
+		err = diffs.ReportAllDiffs(true)
+		if err != nil {
+			return err
+		}
+	} else {
+		if c.OnlyBreakingChanges {
+			err = diffs.ReportCompatibility()
+		} else {
+			err = diffs.ReportAllDiffs(false)
+		}
+	}
+	return err
+}
+
+func readIgnores(ignoreFile string) (diff.SpecDifferences, error) {
+	ignoreDiffs := diff.SpecDifferences{}
+
+	if ignoreFile == "none specified" {
+		return ignoreDiffs, nil
+	}
+	// Open our jsonFile
+	jsonFile, err := os.Open(ignoreFile)
+	// if we os.Open returns an error then handle it
+	if err != nil {
+		return nil, err
+	}
+	// defer the closing of our jsonFile so that we can parse it later on
+	defer jsonFile.Close()
+	byteValue, err := ioutil.ReadAll(jsonFile)
+	if err != nil {
+		return nil, err
+	}
+	// def
+	err = json.Unmarshal(byteValue, &ignoreDiffs)
+	if err != nil {
+		return nil, err
+	}
+	return ignoreDiffs, nil
+}
+
+func getDiffs(oldSpecPath, newSpecPath string) (diff.SpecDifferences, error) {
+	swaggerDoc1 := oldSpecPath
+	specDoc1, err := loads.Spec(swaggerDoc1)
+
+	if err != nil {
+		return nil, err
+	}
+
+	swaggerDoc2 := newSpecPath
+	specDoc2, err := loads.Spec(swaggerDoc2)
+	if err != nil {
+		return nil, err
+	}
+
+	return diff.Compare(specDoc1.Spec(), specDoc2.Spec())
+}
diff --git a/cmd/swagger/commands/diff/array_diff.go b/cmd/swagger/commands/diff/array_diff.go
new file mode 100644
index 00000000..a979cca7
--- /dev/null
+++ b/cmd/swagger/commands/diff/array_diff.go
@@ -0,0 +1,99 @@
+package diff
+
+// This is a simple DSL for diffing arrays
+
+// FromArrayStruct utility struct to encompass diffing of string arrays
+type FromArrayStruct struct {
+	from []string
+}
+
+// FromStringArray starts a fluent diff expression
+func FromStringArray(from []string) FromArrayStruct {
+	return FromArrayStruct{from}
+}
+
+// DiffsTo completes a fluent dff expression
+func (f FromArrayStruct) DiffsTo(toArray []string) (added, deleted, common []string) {
+	inFrom := 1
+	inTo := 2
+
+	m := make(map[string]int)
+
+	for _, item := range f.from {
+		m[item] = inFrom
+	}
+
+	for _, item := range toArray {
+		if _, ok := m[item]; ok {
+			m[item] |= inTo
+		} else {
+			m[item] = inTo
+		}
+	}
+	for key, val := range m {
+		switch val {
+		case inFrom:
+			deleted = append(deleted, key)
+		case inTo:
+			added = append(added, key)
+		default:
+			common = append(common, key)
+		}
+	}
+	return
+}
+
+// FromMapStruct utility struct to encompass diffing of string arrays
+type FromMapStruct struct {
+	srcMap map[string]interface{}
+}
+
+// FromStringMap starts a comparison by declaring a source map
+func FromStringMap(srcMap map[string]interface{}) FromMapStruct {
+	return FromMapStruct{srcMap}
+}
+
+// Pair stores a pair of items which share a key in two maps
+type Pair struct {
+	First  interface{}
+	Second interface{}
+}
+
+// DiffsTo - generates diffs for a comparison
+func (f FromMapStruct) DiffsTo(destMap map[string]interface{}) (added, deleted, common map[string]interface{}) {
+	added = make(map[string]interface{})
+	deleted = make(map[string]interface{})
+	common = make(map[string]interface{})
+
+	inSrc := 1
+	inDest := 2
+
+	m := make(map[string]int)
+
+	// enter values for all items in the source array
+	for key := range f.srcMap {
+		m[key] = inSrc
+	}
+
+	// now either set or 'boolean or' a new flag if in the second collection
+	for key := range destMap {
+		if _, ok := m[key]; ok {
+			m[key] |= inDest
+		} else {
+			m[key] = inDest
+		}
+	}
+	// finally inspect the values and generate the left,right and shared collections
+	// for the shared items, store both values in case there's a diff
+	for key, val := range m {
+		switch val {
+		case inSrc:
+			deleted[key] = f.srcMap[key]
+		case inDest:
+			added[key] = destMap[key]
+		default:
+			common[key] = Pair{f.srcMap[key], destMap[key]}
+		}
+	}
+	return added, deleted, common
+}
diff --git a/cmd/swagger/commands/diff/array_diff_test.go b/cmd/swagger/commands/diff/array_diff_test.go
new file mode 100644
index 00000000..1ce2f4ac
--- /dev/null
+++ b/cmd/swagger/commands/diff/array_diff_test.go
@@ -0,0 +1,101 @@
+package diff
+
+import (
+	"fmt"
+	"testing"
+
+	"github.com/corbym/gocrest"
+	"github.com/corbym/gocrest/then"
+)
+
+var assertThat = then.AssertThat
+
+func TestArrayDiff(t *testing.T) {
+	listA := []string{"abc", "def", "ghi", "jkl"}
+	added, deleted, common := FromStringArray(listA).
+		DiffsTo(listA)
+	assertThat(t, added, isListWithItems([]string{}))
+	assertThat(t, deleted, isListWithItems([]string{}))
+	assertThat(t, common, isListWithItems(listA))
+
+	listB := []string{"abc", "ghi", "jkl", "xyz", "fgh"}
+	added, deleted, common = FromStringArray(listA).
+		DiffsTo(listB)
+	assertThat(t, added, isListWithItems([]string{"xyz", "fgh"}))
+	assertThat(t, deleted, isListWithItems([]string{"def"}))
+	assertThat(t, common, isListWithItems([]string{"abc", "ghi", "jkl"}))
+
+}
+func TestMapDiff(t *testing.T) {
+	mapA := map[string]interface{}{"abc": 1, "def": 2, "ghi": 3, "jkl": 4}
+	added, deleted, common := FromStringMap(mapA).
+		DiffsTo(mapA)
+	assertThat(t, added, isMapWithItems(map[string]interface{}{}))
+	assertThat(t, deleted, isMapWithItems(map[string]interface{}{}))
+	commonDiffs := map[string]interface{}{"abc": Pair{1, 1}, "def": Pair{2, 2}, "ghi": Pair{3, 3}, "jkl": Pair{4, 4}}
+
+	assertThat(t, common, isMapWithItems(commonDiffs))
+
+	mapB := map[string]interface{}{"abc": 2, "ghi": 3, "jkl": 4, "xyz": 5, "fgh": 6}
+	added, deleted, common = FromStringMap(mapA).
+		DiffsTo(mapB)
+	assertThat(t, added, isMapWithItems(map[string]interface{}{"xyz": 5, "fgh": 6}))
+	assertThat(t, deleted, isMapWithItems(map[string]interface{}{"def": 2}))
+	commonDiffs = map[string]interface{}{"abc": Pair{1, 2}, "ghi": Pair{3, 3}, "jkl": Pair{4, 4}}
+	assertThat(t, common, isMapWithItems(commonDiffs))
+
+}
+
+func isListWithItems(other []string) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Describe = fmt.Sprintf("list with items:%v", other)
+	matcher.Matches = func(actual interface{}) bool {
+		if actual == nil {
+			return other == nil
+		}
+		if actualValue, ok := actual.([]string); ok {
+			if len(actualValue) == 0 {
+				return len(other) == 0
+			}
+			leftToMatch := len(actualValue)
+			for _, actualItem := range actualValue {
+				for _, otherItem := range other {
+					if actualItem == otherItem {
+						leftToMatch--
+						break
+					}
+				}
+			}
+			return leftToMatch == 0
+		}
+		return false
+	}
+	return matcher
+}
+
+func isMapWithItems(other map[string]interface{}) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Describe = fmt.Sprintf("map with items:%v", other)
+	matcher.Matches = func(actual interface{}) bool {
+		if actual == nil {
+			return other == nil
+		}
+		if actualValue, ok := actual.(map[string]interface{}); ok {
+			if len(actualValue) == 0 {
+				return len(other) == 0
+			}
+			leftToMatch := len(actualValue)
+			for keyActual, actualItem := range actualValue {
+				for keyOther, otherItem := range other {
+					if actualItem == otherItem && keyActual == keyOther {
+						leftToMatch--
+						break
+					}
+				}
+			}
+			return leftToMatch == 0
+		}
+		return false
+	}
+	return matcher
+}
diff --git a/cmd/swagger/commands/diff/compatibility.go b/cmd/swagger/commands/diff/compatibility.go
new file mode 100644
index 00000000..94694154
--- /dev/null
+++ b/cmd/swagger/commands/diff/compatibility.go
@@ -0,0 +1,90 @@
+package diff
+
+// CompatibilityPolicy decides which changes are breaking and which are not
+type CompatibilityPolicy struct {
+	ForResponse map[SpecChangeCode]Compatibility
+	ForRequest  map[SpecChangeCode]Compatibility
+	ForChange   map[SpecChangeCode]Compatibility
+}
+
+var compatibility CompatibilityPolicy
+
+func init() {
+	compatibility = CompatibilityPolicy{
+		ForResponse: map[SpecChangeCode]Compatibility{
+			AddedRequiredProperty:   Breaking,
+			DeletedProperty:         Breaking,
+			AddedProperty:           NonBreaking,
+			DeletedResponse:         Breaking,
+			AddedResponse:           NonBreaking,
+			WidenedType:             NonBreaking,
+			NarrowedType:            NonBreaking,
+			ChangedType:             Breaking,
+			ChangedToCompatibleType: NonBreaking,
+			AddedEnumValue:          Breaking,
+			DeletedEnumValue:        NonBreaking,
+			AddedResponseHeader:     NonBreaking,
+			ChangedResponseHeader:   Breaking,
+			DeletedResponseHeader:   Breaking,
+			ChangedDescripton:       NonBreaking,
+			AddedDescripton:         NonBreaking,
+			DeletedDescripton:       NonBreaking,
+			ChangedTag:              NonBreaking,
+			AddedTag:                NonBreaking,
+			DeletedTag:              NonBreaking,
+		},
+		ForRequest: map[SpecChangeCode]Compatibility{
+			AddedRequiredProperty:          Breaking,
+			DeletedProperty:                Breaking,
+			AddedProperty:                  Breaking,
+			AddedOptionalParam:             NonBreaking,
+			AddedRequiredParam:             Breaking,
+			DeletedOptionalParam:           NonBreaking,
+			DeletedRequiredParam:           NonBreaking,
+			WidenedType:                    NonBreaking,
+			NarrowedType:                   Breaking,
+			ChangedType:                    Breaking,
+			ChangedToCompatibleType:        NonBreaking,
+			ChangedOptionalToRequiredParam: Breaking,
+			ChangedRequiredToOptionalParam: NonBreaking,
+			AddedEnumValue:                 NonBreaking,
+			DeletedEnumValue:               Breaking,
+			ChangedDescripton:              NonBreaking,
+			AddedDescripton:                NonBreaking,
+			DeletedDescripton:              NonBreaking,
+			ChangedTag:                     NonBreaking,
+			AddedTag:                       NonBreaking,
+			DeletedTag:                     NonBreaking,
+		},
+		ForChange: map[SpecChangeCode]Compatibility{
+			NoChangeDetected:          NonBreaking,
+			AddedEndpoint:             NonBreaking,
+			DeletedEndpoint:           Breaking,
+			DeletedDeprecatedEndpoint: NonBreaking,
+			AddedConsumesFormat:       NonBreaking,
+			DeletedConsumesFormat:     Breaking,
+			AddedProducesFormat:       Breaking,
+			DeletedProducesFormat:     NonBreaking,
+			AddedSchemes:              NonBreaking,
+			DeletedSchemes:            Breaking,
+			ChangedHostURL:            Breaking,
+			ChangedBasePath:           Breaking,
+			ChangedDescripton:         NonBreaking,
+			AddedDescripton:           NonBreaking,
+			DeletedDescripton:         NonBreaking,
+			ChangedTag:                NonBreaking,
+			AddedTag:                  NonBreaking,
+			DeletedTag:                NonBreaking,
+		},
+	}
+}
+
+func getCompatibilityForChange(diffCode SpecChangeCode, where DataDirection) Compatibility {
+	if compat, commonChange := compatibility.ForChange[diffCode]; commonChange {
+		return compat
+	}
+	if where == Request {
+		return compatibility.ForRequest[diffCode]
+	}
+	return compatibility.ForResponse[diffCode]
+}
diff --git a/cmd/swagger/commands/diff/difference_location.go b/cmd/swagger/commands/diff/difference_location.go
new file mode 100644
index 00000000..3bd700b5
--- /dev/null
+++ b/cmd/swagger/commands/diff/difference_location.go
@@ -0,0 +1,22 @@
+package diff
+
+// DifferenceLocation indicates where the difference occurs
+type DifferenceLocation struct {
+	URL      string `json:"url"`
+	Method   string `json:"method,omitempty"`
+	Response int    `json:"response,omitempty"`
+	Node     *Node  `json:"node,omitempty"`
+}
+
+// AddNode returns a copy of this location with the leaf node added
+func (dl DifferenceLocation) AddNode(node *Node) DifferenceLocation {
+	newLoc := dl
+
+	if newLoc.Node != nil {
+		newLoc.Node = newLoc.Node.Copy()
+		newLoc.Node.AddLeafNode(node)
+	} else {
+		newLoc.Node = node
+	}
+	return newLoc
+}
diff --git a/cmd/swagger/commands/diff/difftypes.go b/cmd/swagger/commands/diff/difftypes.go
new file mode 100644
index 00000000..34f7a31b
--- /dev/null
+++ b/cmd/swagger/commands/diff/difftypes.go
@@ -0,0 +1,276 @@
+package diff
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+)
+
+// SpecChangeCode enumerates the various types of diffs from one spec to another
+type SpecChangeCode int
+
+const (
+	// NoChangeDetected - the specs have no changes
+	NoChangeDetected SpecChangeCode = iota
+	// DeletedProperty - A message property has been deleted in the new spec
+	DeletedProperty
+	// AddedProperty - A message property has been added in the new spec
+	AddedProperty
+	// AddedRequiredProperty - A required message property has been added in the new spec
+	AddedRequiredProperty
+	// DeletedOptionalParam - An endpoint parameter has been deleted in the new spec
+	DeletedOptionalParam
+	// ChangedDescripton - Changed a description
+	ChangedDescripton
+	// AddedDescripton - Added a description
+	AddedDescripton
+	// DeletedDescripton - Deleted a description
+	DeletedDescripton
+	// ChangedTag - Changed a tag
+	ChangedTag
+	// AddedTag - Added a tag
+	AddedTag
+	// DeletedTag - Deleted a tag
+	DeletedTag
+	// DeletedResponse - An endpoint response has been deleted in the new spec
+	DeletedResponse
+	// DeletedEndpoint - An endpoint has been deleted in the new spec
+	DeletedEndpoint
+	// DeletedDeprecatedEndpoint - A deprecated endpoint has been deleted in the new spec
+	DeletedDeprecatedEndpoint
+	// AddedRequiredParam - A required parameter has been added in the new spec
+	AddedRequiredParam
+	// DeletedRequiredParam - A required parameter has been deleted in the new spec
+	DeletedRequiredParam
+	// ChangedRequiredToOptional - A required parameter has been made optional in the new spec
+	ChangedRequiredToOptional
+	// AddedEndpoint - An endpoint has been added in the new spec
+	AddedEndpoint
+	// WidenedType - An type has been changed to a more permissive type eg int->string
+	WidenedType
+	// NarrowedType - An type has been changed to a less permissive type eg string->int
+	NarrowedType
+	// ChangedToCompatibleType - An type has been changed to a compatible type eg password->string
+	ChangedToCompatibleType
+	// ChangedType - An type has been changed to a type whose relative compatibility cannot be determined
+	ChangedType
+	// AddedEnumValue - An enum type has had a new potential value added to it
+	AddedEnumValue
+	// DeletedEnumValue - An enum type has had a existing value removed from it
+	DeletedEnumValue
+	// AddedOptionalParam - A new optional parameter has been added to the new spec
+	AddedOptionalParam
+	// ChangedOptionalToRequiredParam - An optional parameter is now required in the new spec
+	ChangedOptionalToRequiredParam
+	// ChangedRequiredToOptionalParam - An required parameter is now optional in the new spec
+	ChangedRequiredToOptionalParam
+	// AddedResponse An endpoint has new response code in the new spec
+	AddedResponse
+	// AddedConsumesFormat - a new consumes format (json/xml/yaml etc) has been added in the new spec
+	AddedConsumesFormat
+	// DeletedConsumesFormat - an existing format has been removed in the new spec
+	DeletedConsumesFormat
+	// AddedProducesFormat - a new produces format (json/xml/yaml etc) has been added in the new spec
+	AddedProducesFormat
+	// DeletedProducesFormat - an existing produces format has been removed in the new spec
+	DeletedProducesFormat
+	// AddedSchemes - a new scheme has been added to the new spec
+	AddedSchemes
+	// DeletedSchemes - a scheme has been removed from the new spec
+	DeletedSchemes
+	// ChangedHostURL - the host url has been changed. If this is used in the client generation, then clients will break.
+	ChangedHostURL
+	// ChangedBasePath - the host base path has been changed. If this is used in the client generation, then clients will break.
+	ChangedBasePath
+	// AddedResponseHeader Added a header Item
+	AddedResponseHeader
+	// ChangedResponseHeader Added a header Item
+	ChangedResponseHeader
+	// DeletedResponseHeader Added a header Item
+	DeletedResponseHeader
+)
+
+var toLongStringSpecChangeCode = map[SpecChangeCode]string{
+	NoChangeDetected:               "No Change detected",
+	AddedEndpoint:                  "Added endpoint",
+	DeletedEndpoint:                "Deleted endpoint",
+	DeletedDeprecatedEndpoint:      "Deleted a deprecated endpoint",
+	AddedRequiredProperty:          "Added required property",
+	DeletedProperty:                "Deleted property",
+	ChangedDescripton:              "Changed a description",
+	AddedDescripton:                "Added a description",
+	DeletedDescripton:              "Deleted a description",
+	ChangedTag:                     "Changed a tag",
+	AddedTag:                       "Added a tag",
+	DeletedTag:                     "Deleted a tag",
+	AddedProperty:                  "Added property",
+	AddedOptionalParam:             "Added optional param",
+	AddedRequiredParam:             "Added required param",
+	DeletedOptionalParam:           "Deleted optional param",
+	DeletedRequiredParam:           "Deleted required param",
+	DeletedResponse:                "Deleted response",
+	AddedResponse:                  "Added response",
+	WidenedType:                    "Widened type",
+	NarrowedType:                   "Narrowed type",
+	ChangedType:                    "Changed type",
+	ChangedToCompatibleType:        "Changed type to equivalent type",
+	ChangedOptionalToRequiredParam: "Changed optional param to required",
+	ChangedRequiredToOptionalParam: "Changed required param to optional",
+	AddedEnumValue:                 "Added possible enumeration(s)",
+	DeletedEnumValue:               "Deleted possible enumeration(s)",
+	AddedConsumesFormat:            "Added a consumes format",
+	DeletedConsumesFormat:          "Deleted a consumes format",
+	AddedProducesFormat:            "Added produces format",
+	DeletedProducesFormat:          "Deleted produces format",
+	AddedSchemes:                   "Added schemes",
+	DeletedSchemes:                 "Deleted schemes",
+	ChangedHostURL:                 "Changed host URL",
+	ChangedBasePath:                "Changed base path",
+	AddedResponseHeader:            "Added response header",
+	ChangedResponseHeader:          "Changed response header",
+	DeletedResponseHeader:          "Deleted response header",
+}
+
+var toStringSpecChangeCode = map[SpecChangeCode]string{
+	AddedEndpoint:                  "AddedEndpoint",
+	NoChangeDetected:               "NoChangeDetected",
+	DeletedEndpoint:                "DeletedEndpoint",
+	DeletedDeprecatedEndpoint:      "DeletedDeprecatedEndpoint",
+	AddedRequiredProperty:          "AddedRequiredProperty",
+	DeletedProperty:                "DeletedProperty",
+	AddedProperty:                  "AddedProperty",
+	ChangedDescripton:              "ChangedDescription",
+	AddedDescripton:                "AddedDescription",
+	DeletedDescripton:              "DeletedDescription",
+	ChangedTag:                     "ChangedTag",
+	AddedTag:                       "AddedTag",
+	DeletedTag:                     "DeletedTag",
+	AddedOptionalParam:             "AddedOptionalParam",
+	AddedRequiredParam:             "AddedRequiredParam",
+	DeletedOptionalParam:           "DeletedRequiredParam",
+	DeletedRequiredParam:           "Deleted required param",
+	DeletedResponse:                "DeletedResponse",
+	AddedResponse:                  "AddedResponse",
+	WidenedType:                    "WidenedType",
+	NarrowedType:                   "NarrowedType",
+	ChangedType:                    "ChangedType",
+	ChangedToCompatibleType:        "ChangedToCompatibleType",
+	ChangedOptionalToRequiredParam: "ChangedOptionalToRequiredParam",
+	ChangedRequiredToOptionalParam: "ChangedRequiredToOptionalParam",
+	AddedEnumValue:                 "AddedEnumValue",
+	DeletedEnumValue:               "DeletedEnumValue",
+	AddedConsumesFormat:            "AddedConsumesFormat",
+	DeletedConsumesFormat:          "DeletedConsumesFormat",
+	AddedProducesFormat:            "AddedProducesFormat",
+	DeletedProducesFormat:          "DeletedProducesFormat",
+	AddedSchemes:                   "AddedSchemes",
+	DeletedSchemes:                 "DeletedSchemes",
+	ChangedHostURL:                 "ChangedHostURL",
+	ChangedBasePath:                "ChangedBasePath",
+	AddedResponseHeader:            "AddedResponseHeader",
+	ChangedResponseHeader:          "ChangedResponseHeader",
+	DeletedResponseHeader:          "DeletedResponseHeader",
+}
+
+var toIDSpecChangeCode = map[string]SpecChangeCode{}
+
+// Description returns an english version of this error
+func (s *SpecChangeCode) Description() (result string) {
+	result, ok := toLongStringSpecChangeCode[*s]
+	if !ok {
+		fmt.Printf("WARNING: No description for %v", *s)
+		result = "UNDEFINED"
+	}
+	return
+}
+
+// MarshalJSON marshals the enum as a quoted json string
+func (s *SpecChangeCode) MarshalJSON() ([]byte, error) {
+	return stringAsQuotedBytes(toStringSpecChangeCode[*s])
+}
+
+// UnmarshalJSON unmashalls a quoted json string to the enum value
+func (s *SpecChangeCode) UnmarshalJSON(b []byte) error {
+	str, err := readStringFromByteStream(b)
+	if err != nil {
+		return err
+	}
+	// Note that if the string cannot be found then it will return an error to the caller.
+	val, ok := toIDSpecChangeCode[str]
+
+	if ok {
+		*s = val
+	} else {
+		return fmt.Errorf("unknown enum value. cannot unmarshal '%s'", str)
+	}
+	return nil
+}
+
+// Compatibility - whether this is a breaking or non-breaking change
+type Compatibility int
+
+const (
+	// Breaking this change could break existing clients
+	Breaking Compatibility = iota
+	// NonBreaking This is a backwards-compatible API change
+	NonBreaking
+)
+
+func (s Compatibility) String() string {
+	return toStringCompatibility[s]
+}
+
+var toStringCompatibility = map[Compatibility]string{
+	Breaking:    "Breaking",
+	NonBreaking: "NonBreaking",
+}
+
+var toIDCompatibility = map[string]Compatibility{}
+
+// MarshalJSON marshals the enum as a quoted json string
+func (s *Compatibility) MarshalJSON() ([]byte, error) {
+	return stringAsQuotedBytes(toStringCompatibility[*s])
+}
+
+// UnmarshalJSON unmashals a quoted json string to the enum value
+func (s *Compatibility) UnmarshalJSON(b []byte) error {
+	str, err := readStringFromByteStream(b)
+	if err != nil {
+		return err
+	}
+	// Note that if the string cannot be found then it will return an error to the caller.
+	val, ok := toIDCompatibility[str]
+
+	if ok {
+		*s = val
+	} else {
+		return fmt.Errorf("unknown enum value. cannot unmarshal '%s'", str)
+	}
+	return nil
+}
+
+func stringAsQuotedBytes(str string) ([]byte, error) {
+	buffer := bytes.NewBufferString(`"`)
+	buffer.WriteString(str)
+	buffer.WriteString(`"`)
+	return buffer.Bytes(), nil
+}
+
+func readStringFromByteStream(b []byte) (string, error) {
+	var j string
+	err := json.Unmarshal(b, &j)
+	if err != nil {
+		return "", err
+	}
+	return j, nil
+}
+
+func init() {
+	for key, val := range toStringSpecChangeCode {
+		toIDSpecChangeCode[val] = key
+	}
+	for key, val := range toStringCompatibility {
+		toIDCompatibility[val] = key
+	}
+
+}
diff --git a/cmd/swagger/commands/diff/node.go b/cmd/swagger/commands/diff/node.go
new file mode 100644
index 00000000..a4a9cf79
--- /dev/null
+++ b/cmd/swagger/commands/diff/node.go
@@ -0,0 +1,47 @@
+package diff
+
+// Node is the position od a diff in a spec
+type Node struct {
+	Field     string `json:"name,omitempty"`
+	TypeName  string `json:"type,omitempty"`
+	IsArray   bool   `json:"is_array,omitempty"`
+	ChildNode *Node  `json:"child,omitempty"`
+}
+
+// String std string render
+func (n *Node) String() string {
+	name := n.Field
+	if n.IsArray {
+		name = "array[" + n.TypeName + "]"
+	}
+
+	if n.ChildNode != nil {
+		return name + "." + n.ChildNode.String()
+	}
+	if len(n.TypeName) > 0 {
+		return name + " : " + n.TypeName
+	}
+	return name
+}
+
+// AddLeafNode Adds (recursive) a Child to the first non-nil child found
+func (n *Node) AddLeafNode(toAdd *Node) *Node {
+
+	if n.ChildNode == nil {
+		n.ChildNode = toAdd
+	} else {
+		n.ChildNode.AddLeafNode(toAdd)
+	}
+
+	return n
+}
+
+//Copy deep copy of this node and children
+func (n Node) Copy() *Node {
+	newNode := n
+
+	if newNode.ChildNode != nil {
+		n.ChildNode = newNode.ChildNode.Copy()
+	}
+	return &newNode
+}
diff --git a/cmd/swagger/commands/diff/reporting.go b/cmd/swagger/commands/diff/reporting.go
new file mode 100644
index 00000000..cf7687bb
--- /dev/null
+++ b/cmd/swagger/commands/diff/reporting.go
@@ -0,0 +1,169 @@
+package diff
+
+import (
+	"bytes"
+	"encoding/json"
+	"fmt"
+	"net/url"
+	"strings"
+
+	"github.com/go-openapi/spec"
+)
+
+// ArrayType const for array
+var ArrayType = "array"
+
+// Compare returns the result of analysing breaking and non breaking changes
+// between to Swagger specs
+func Compare(spec1, spec2 *spec.Swagger) (diffs SpecDifferences, err error) {
+	analyser := NewSpecAnalyser()
+	err = analyser.Analyse(spec1, spec2)
+	if err != nil {
+		return nil, err
+	}
+	diffs = analyser.Diffs
+	return
+}
+
+// PathItemOp - combines path and operation into a single keyed entity
+type PathItemOp struct {
+	ParentPathItem *spec.PathItem  `json:"pathitem"`
+	Operation      *spec.Operation `json:"operation"`
+}
+
+// URLMethod - combines url and method into a single keyed entity
+type URLMethod struct {
+	Path   string `json:"path"`
+	Method string `json:"method"`
+}
+
+// DataDirection indicates the direction of change Request vs Response
+type DataDirection int
+
+const (
+	// Request Used for messages/param diffs in a request
+	Request DataDirection = iota
+	// Response Used for messages/param diffs in a response
+	Response
+)
+
+func getParams(pathParams, opParams []spec.Parameter, location string) map[string]spec.Parameter {
+	params := map[string]spec.Parameter{}
+	// add shared path params
+	for _, eachParam := range pathParams {
+		if eachParam.In == location {
+			params[eachParam.Name] = eachParam
+		}
+	}
+	// add any overridden params
+	for _, eachParam := range opParams {
+		if eachParam.In == location {
+			params[eachParam.Name] = eachParam
+		}
+	}
+	return params
+}
+
+func getNameOnlyDiffNode(forLocation string) *Node {
+	node := Node{
+		Field: forLocation,
+	}
+	return &node
+}
+
+func getSimpleSchemaDiffNode(name string, schema *spec.SimpleSchema) *Node {
+	node := Node{
+		Field: name,
+	}
+	if schema != nil {
+		node.TypeName, node.IsArray = getSimpleSchemaType(schema)
+	}
+	return &node
+}
+
+func getSchemaDiffNode(name string, schema *spec.Schema) *Node {
+	node := Node{
+		Field: name,
+	}
+	if schema != nil {
+		node.TypeName, node.IsArray = getSchemaType(&schema.SchemaProps)
+	}
+	return &node
+}
+
+func definitonFromURL(url *url.URL) string {
+	if url == nil {
+		return ""
+	}
+	fragmentParts := strings.Split(url.Fragment, "/")
+	numParts := len(fragmentParts)
+	if numParts == 0 {
+		return ""
+	}
+	return fragmentParts[numParts-1]
+}
+
+func getSimpleSchemaType(schema *spec.SimpleSchema) (typeName string, isArray bool) {
+	typeName = schema.Type
+	if typeName == ArrayType {
+		typeName, _ = getSimpleSchemaType(&schema.Items.SimpleSchema)
+		return typeName, true
+	}
+	return typeName, false
+}
+
+func getSchemaType(schema *spec.SchemaProps) (typeName string, isArray bool) {
+	refStr := definitonFromURL(schema.Ref.GetURL())
+	if len(refStr) > 0 {
+		return refStr, false
+	}
+	typeName = schema.Type[0]
+	if typeName == ArrayType {
+		typeName, _ = getSchemaType(&schema.Items.Schema.SchemaProps)
+		return typeName, true
+	}
+	return typeName, false
+}
+
+func primitiveTypeString(typeName, typeFormat string) string {
+	if typeFormat != "" {
+		return fmt.Sprintf("%s.%s", typeName, typeFormat)
+	}
+	return typeName
+}
+
+// TypeDiff - describes a primitive type change
+type TypeDiff struct {
+	Change      SpecChangeCode `json:"change-type,omitempty"`
+	Description string         `json:"description,omitempty"`
+	FromType    string         `json:"from-type,omitempty"`
+	ToType      string         `json:"to-type,omitempty"`
+}
+
+// didn't use 'width' so as not to confuse with bit width
+var numberWideness = map[string]int{
+	"number":        3,
+	"number.double": 3,
+	"double":        3,
+	"number.float":  2,
+	"float":         2,
+	"long":          1,
+	"integer.int64": 1,
+	"integer":       0,
+	"integer.int32": 0,
+}
+
+func prettyprint(b []byte) ([]byte, error) {
+	var out bytes.Buffer
+	err := json.Indent(&out, b, "", "  ")
+	return out.Bytes(), err
+}
+
+// JSONMarshal allows the item to be correctly rendered to json
+func JSONMarshal(t interface{}) ([]byte, error) {
+	buffer := &bytes.Buffer{}
+	encoder := json.NewEncoder(buffer)
+	encoder.SetEscapeHTML(false)
+	err := encoder.Encode(t)
+	return buffer.Bytes(), err
+}
diff --git a/cmd/swagger/commands/diff/spec_analyser.go b/cmd/swagger/commands/diff/spec_analyser.go
new file mode 100644
index 00000000..f35c9e37
--- /dev/null
+++ b/cmd/swagger/commands/diff/spec_analyser.go
@@ -0,0 +1,654 @@
+package diff
+
+import (
+	"fmt"
+	"strings"
+
+	"github.com/go-openapi/spec"
+)
+
+const StringType = "string"
+
+// URLMethodResponse encapsulates these three elements to act as a map key
+type URLMethodResponse struct {
+	Path     string `json:"path"`
+	Method   string `json:"method"`
+	Response string `json:"response"`
+}
+
+// MarshalText - for serializing as a map key
+func (p URLMethod) MarshalText() (text []byte, err error) {
+	return []byte(fmt.Sprintf("%s %s", p.Path, p.Method)), nil
+}
+
+// URLMethods allows iteration of endpoints based on url and method
+type URLMethods map[URLMethod]*PathItemOp
+
+// SpecAnalyser contains all the differences for a Spec
+type SpecAnalyser struct {
+	Diffs                      SpecDifferences
+	urlMethods1                URLMethods
+	urlMethods2                URLMethods
+	Definitions1               spec.Definitions
+	Definitions2               spec.Definitions
+	AlreadyComparedDefinitions map[string]bool
+}
+
+// NewSpecAnalyser returns an empty SpecDiffs
+func NewSpecAnalyser() *SpecAnalyser {
+	return &SpecAnalyser{
+		Diffs: SpecDifferences{},
+	}
+}
+
+// Analyse the differences in two specs
+func (sd *SpecAnalyser) Analyse(spec1, spec2 *spec.Swagger) error {
+	sd.Definitions1 = spec1.Definitions
+	sd.Definitions2 = spec2.Definitions
+	sd.urlMethods1 = getURLMethodsFor(spec1)
+	sd.urlMethods2 = getURLMethodsFor(spec2)
+
+	sd.analyseSpecMetadata(spec1, spec2)
+	sd.analyseEndpoints()
+	sd.analyseParams()
+	sd.analyseEndpointData()
+	sd.analyseResponseParams()
+
+	return nil
+}
+
+func (sd *SpecAnalyser) analyseSpecMetadata(spec1, spec2 *spec.Swagger) {
+	// breaking if it no longer consumes any formats
+	added, deleted, _ := FromStringArray(spec1.Consumes).DiffsTo(spec2.Consumes)
+
+	node := getNameOnlyDiffNode("Spec")
+	location := DifferenceLocation{Node: node}
+	consumesLoation := location.AddNode(getNameOnlyDiffNode("consumes"))
+
+	for _, eachAdded := range added {
+		sd.Diffs = sd.Diffs.addDiff(
+			SpecDifference{DifferenceLocation: consumesLoation, Code: AddedConsumesFormat, Compatibility: NonBreaking, DiffInfo: eachAdded})
+	}
+	for _, eachDeleted := range deleted {
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: consumesLoation, Code: DeletedConsumesFormat, Compatibility: Breaking, DiffInfo: eachDeleted})
+	}
+
+	// // breaking if it no longer produces any formats
+	added, deleted, _ = FromStringArray(spec1.Produces).DiffsTo(spec2.Produces)
+	producesLocation := location.AddNode(getNameOnlyDiffNode("produces"))
+	for _, eachAdded := range added {
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: producesLocation, Code: AddedProducesFormat, Compatibility: NonBreaking, DiffInfo: eachAdded})
+	}
+	for _, eachDeleted := range deleted {
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: producesLocation, Code: DeletedProducesFormat, Compatibility: Breaking, DiffInfo: eachDeleted})
+	}
+
+	// // breaking if it no longer supports a scheme
+	added, deleted, _ = FromStringArray(spec1.Schemes).DiffsTo(spec2.Schemes)
+	schemesLocation := location.AddNode(getNameOnlyDiffNode("schemes"))
+
+	for _, eachAdded := range added {
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: schemesLocation, Code: AddedSchemes, Compatibility: NonBreaking, DiffInfo: eachAdded})
+	}
+	for _, eachDeleted := range deleted {
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: schemesLocation, Code: DeletedSchemes, Compatibility: Breaking, DiffInfo: eachDeleted})
+	}
+
+	// // host should be able to change without any issues?
+	sd.analyseMetaDataProperty(spec1.Info.Description, spec2.Info.Description, ChangedDescripton, NonBreaking)
+
+	// // host should be able to change without any issues?
+	sd.analyseMetaDataProperty(spec1.Host, spec2.Host, ChangedHostURL, Breaking)
+	// sd.Host = compareStrings(spec1.Host, spec2.Host)
+
+	// // Base Path change will break non generated clients
+	sd.analyseMetaDataProperty(spec1.BasePath, spec2.BasePath, ChangedBasePath, Breaking)
+
+	// TODO: what to do about security?
+	// Missing security scheme will break a client
+	// Security            []map[string][]string  `json:"security,omitempty"`
+	// Tags                []Tag                  `json:"tags,omitempty"`
+	// ExternalDocs        *ExternalDocumentation `json:"externalDocs,omitempty"`
+}
+
+func (sd *SpecAnalyser) analyseEndpoints() {
+	sd.findDeletedEndpoints()
+	sd.findAddedEndpoints()
+}
+
+func (sd *SpecAnalyser) analyseEndpointData() {
+
+	for URLMethod, op2 := range sd.urlMethods2 {
+		if op1, ok := sd.urlMethods1[URLMethod]; ok {
+			addedTags, deletedTags, _ := FromStringArray(op1.Operation.Tags).DiffsTo(op2.Operation.Tags)
+			location := DifferenceLocation{URL: URLMethod.Path, Method: URLMethod.Method}
+
+			for _, eachAddedTag := range addedTags {
+				sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: location, Code: AddedTag, DiffInfo: eachAddedTag})
+			}
+			for _, eachDeletedTag := range deletedTags {
+				sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: location, Code: DeletedTag, DiffInfo: eachDeletedTag})
+			}
+
+			sd.compareDescripton(location, op1.Operation.Description, op2.Operation.Description)
+
+		}
+	}
+
+}
+
+func (sd *SpecAnalyser) analyseParams() {
+	locations := []string{"query", "path", "body", "header"}
+
+	for _, paramLocation := range locations {
+		rootNode := getNameOnlyDiffNode(strings.Title(paramLocation))
+		for URLMethod, op2 := range sd.urlMethods2 {
+			if op1, ok := sd.urlMethods1[URLMethod]; ok {
+
+				params1 := getParams(op1.ParentPathItem.Parameters, op1.Operation.Parameters, paramLocation)
+				params2 := getParams(op2.ParentPathItem.Parameters, op2.Operation.Parameters, paramLocation)
+
+				location := DifferenceLocation{URL: URLMethod.Path, Method: URLMethod.Method, Node: rootNode}
+
+				// detect deleted params
+				for paramName1, param1 := range params1 {
+					if _, ok := params2[paramName1]; !ok {
+						childLocation := location.AddNode(getSchemaDiffNode(paramName1, param1.Schema))
+						code := DeletedOptionalParam
+						if param1.Required {
+							code = DeletedRequiredParam
+						}
+						sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: childLocation, Code: code})
+					}
+				}
+				// detect added changed params
+				for paramName2, param2 := range params2 {
+					//changed?
+					if param1, ok := params1[paramName2]; ok {
+						sd.compareParams(URLMethod, paramLocation, paramName2, param1, param2)
+					} else {
+						// Added
+						childLocation := location.AddNode(getSchemaDiffNode(paramName2, param2.Schema))
+						code := AddedOptionalParam
+						if param2.Required {
+							code = AddedRequiredParam
+						}
+						sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: childLocation, Code: code})
+					}
+				}
+			}
+		}
+	}
+}
+
+func (sd *SpecAnalyser) analyseResponseParams() {
+	// Loop through url+methods in spec 2 - check deleted and changed
+	for URLMethod2, op2 := range sd.urlMethods2 {
+		if op1, ok := sd.urlMethods1[URLMethod2]; ok {
+			// compare responses for url and method
+			op1Responses := op1.Operation.Responses.StatusCodeResponses
+			op2Responses := op2.Operation.Responses.StatusCodeResponses
+
+			// deleted responses
+			for code1 := range op1Responses {
+				if _, ok := op2Responses[code1]; !ok {
+					location := DifferenceLocation{URL: URLMethod2.Path, Method: URLMethod2.Method, Response: code1}
+					sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: location, Code: DeletedResponse})
+				}
+			}
+			// Added updated Response Codes
+			for code2, op2Response := range op2Responses {
+
+				if op1Response, ok := op1Responses[code2]; ok {
+					op1Headers := op1Response.ResponseProps.Headers
+					headerRootNode := getNameOnlyDiffNode("Headers")
+					location := DifferenceLocation{URL: URLMethod2.Path, Method: URLMethod2.Method, Response: code2, Node: headerRootNode}
+
+					// Iterate Spec2 Headers looking for added and updated
+					for op2HeaderName, op2Header := range op2Response.ResponseProps.Headers {
+						if op1Header, ok := op1Headers[op2HeaderName]; ok {
+							sd.compareSimpleSchema(location.AddNode(getNameOnlyDiffNode(op2HeaderName)),
+								&op1Header.SimpleSchema,
+								&op2Header.SimpleSchema, false, false)
+						} else {
+							sd.Diffs = sd.Diffs.addDiff(SpecDifference{
+								DifferenceLocation: location.AddNode(getNameOnlyDiffNode(op2HeaderName)),
+								Code:               AddedResponseHeader})
+						}
+					}
+					for op1HeaderName := range op1Response.ResponseProps.Headers {
+						if _, ok := op2Response.ResponseProps.Headers[op1HeaderName]; !ok {
+							sd.Diffs = sd.Diffs.addDiff(SpecDifference{
+								DifferenceLocation: location.AddNode(getNameOnlyDiffNode(op1HeaderName)),
+								Code:               DeletedResponseHeader})
+						}
+					}
+					responseLocation := DifferenceLocation{URL: URLMethod2.Path, Method: URLMethod2.Method, Response: code2}
+					sd.compareDescripton(responseLocation, op1Response.Description, op2Response.Description)
+
+					if op1Response.Schema != nil {
+						sd.compareSchema(
+							DifferenceLocation{URL: URLMethod2.Path, Method: URLMethod2.Method, Response: code2},
+							op1Response.Schema,
+							op2Response.Schema, true, true)
+					}
+				} else {
+					sd.Diffs = sd.Diffs.addDiff(SpecDifference{
+						DifferenceLocation: DifferenceLocation{URL: URLMethod2.Path, Method: URLMethod2.Method, Response: code2},
+						Code:               AddedResponse})
+				}
+			}
+		}
+	}
+}
+
+func addTypeDiff(diffs []TypeDiff, diff TypeDiff) []TypeDiff {
+	if diff.Change != NoChangeDetected {
+		diffs = append(diffs, diff)
+	}
+	return diffs
+}
+
+// CheckToFromPrimitiveType check for diff to or from a primitive
+func (sd *SpecAnalyser) CheckToFromPrimitiveType(diffs []TypeDiff, type1, type2 spec.SchemaProps) []TypeDiff {
+
+	type1IsPrimitive := len(type1.Type) > 0
+	type2IsPrimitive := len(type2.Type) > 0
+
+	// Primitive to Obj or Obj to Primitive
+	if type1IsPrimitive && !type2IsPrimitive {
+		return addTypeDiff(diffs, TypeDiff{Change: ChangedType, FromType: type1.Type[0], ToType: "obj"})
+	}
+
+	if !type1IsPrimitive && type2IsPrimitive {
+		return addTypeDiff(diffs, TypeDiff{Change: ChangedType, FromType: type2.Type[0], ToType: "obj"})
+	}
+
+	return diffs
+}
+
+// CheckToFromArrayType check for changes to or from an Array type
+func (sd *SpecAnalyser) CheckToFromArrayType(diffs []TypeDiff, type1, type2 spec.SchemaProps) []TypeDiff {
+	// Single to Array or Array to Single
+	type1Array := type1.Type[0] == ArrayType
+	type2Array := type2.Type[0] == ArrayType
+
+	if type1Array && !type2Array {
+		return addTypeDiff(diffs, TypeDiff{Change: ChangedType, FromType: "obj", ToType: type2.Type[0]})
+	}
+
+	if !type1Array && type2Array {
+		return addTypeDiff(diffs, TypeDiff{Change: ChangedType, FromType: type1.Type[0], ToType: ArrayType})
+	}
+
+	if type1Array && type2Array {
+		// array
+		// TODO: Items??
+		diffs = addTypeDiff(diffs, compareIntValues("MaxItems", type1.MaxItems, type2.MaxItems, WidenedType, NarrowedType))
+		diffs = addTypeDiff(diffs, compareIntValues("MinItems", type1.MinItems, type2.MinItems, NarrowedType, WidenedType))
+
+	}
+	return diffs
+}
+
+// CheckStringTypeChanges checks for changes to or from a string type
+func (sd *SpecAnalyser) CheckStringTypeChanges(diffs []TypeDiff, type1, type2 spec.SchemaProps) []TypeDiff {
+	// string changes
+	if type1.Type[0] == StringType &&
+		type2.Type[0] == StringType {
+		diffs = addTypeDiff(diffs, compareIntValues("MinLength", type1.MinLength, type2.MinLength, NarrowedType, WidenedType))
+		diffs = addTypeDiff(diffs, compareIntValues("MaxLength", type1.MinLength, type2.MinLength, WidenedType, NarrowedType))
+		if type1.Pattern != type2.Pattern {
+			diffs = addTypeDiff(diffs, TypeDiff{Change: ChangedType, Description: fmt.Sprintf("Pattern Changed:%s->%s", type1.Pattern, type2.Pattern)})
+		}
+		if type1.Type[0] == StringType {
+			if len(type1.Enum) > 0 {
+				enumDiffs := sd.compareEnums(type1.Enum, type2.Enum)
+				diffs = append(diffs, enumDiffs...)
+			}
+		}
+	}
+	return diffs
+}
+
+// CheckNumericTypeChanges checks for changes to or from a numeric type
+func (sd *SpecAnalyser) CheckNumericTypeChanges(diffs []TypeDiff, type1, type2 spec.SchemaProps) []TypeDiff {
+	// Number
+	_, type1IsNumeric := numberWideness[type1.Type[0]]
+	_, type2IsNumeric := numberWideness[type2.Type[0]]
+
+	if type1IsNumeric && type2IsNumeric {
+		diffs = addTypeDiff(diffs, compareFloatValues("Maximum", type1.Maximum, type2.Maximum, WidenedType, NarrowedType))
+		diffs = addTypeDiff(diffs, compareFloatValues("Minimum", type1.Minimum, type2.Minimum, NarrowedType, WidenedType))
+		if type1.ExclusiveMaximum && !type2.ExclusiveMaximum {
+			diffs = addTypeDiff(diffs, TypeDiff{Change: WidenedType, Description: fmt.Sprintf("Exclusive Maximum Removed:%v->%v", type1.ExclusiveMaximum, type2.ExclusiveMaximum)})
+		}
+		if !type1.ExclusiveMaximum && type2.ExclusiveMaximum {
+			diffs = addTypeDiff(diffs, TypeDiff{Change: NarrowedType, Description: fmt.Sprintf("Exclusive Maximum Added:%v->%v", type1.ExclusiveMaximum, type2.ExclusiveMaximum)})
+		}
+		if type1.ExclusiveMinimum && !type2.ExclusiveMinimum {
+			diffs = addTypeDiff(diffs, TypeDiff{Change: WidenedType, Description: fmt.Sprintf("Exclusive Minimum Removed:%v->%v", type1.ExclusiveMaximum, type2.ExclusiveMaximum)})
+		}
+		if !type1.ExclusiveMinimum && type2.ExclusiveMinimum {
+			diffs = addTypeDiff(diffs, TypeDiff{Change: NarrowedType, Description: fmt.Sprintf("Exclusive Minimum Added:%v->%v", type1.ExclusiveMinimum, type2.ExclusiveMinimum)})
+		}
+	}
+	return diffs
+}
+
+// CompareTypes computes type specific property diffs
+func (sd *SpecAnalyser) CompareTypes(type1, type2 spec.SchemaProps) []TypeDiff {
+
+	diffs := []TypeDiff{}
+
+	diffs = sd.CheckToFromPrimitiveType(diffs, type1, type2)
+
+	if len(diffs) > 0 {
+		return diffs
+	}
+
+	diffs = sd.CheckToFromArrayType(diffs, type1, type2)
+
+	if len(diffs) > 0 {
+		return diffs
+	}
+
+	// check type hierarchy change eg string -> integer = NarrowedChange
+	//Type
+	//Format
+	if type1.Type[0] != type2.Type[0] ||
+		type1.Format != type2.Format {
+		diff := getTypeHierarchyChange(primitiveTypeString(type1.Type[0], type1.Format), primitiveTypeString(type2.Type[0], type2.Format))
+		diffs = addTypeDiff(diffs, diff)
+	}
+
+	diffs = sd.CheckStringTypeChanges(diffs, type1, type2)
+
+	if len(diffs) > 0 {
+		return diffs
+	}
+
+	diffs = sd.CheckNumericTypeChanges(diffs, type1, type2)
+
+	if len(diffs) > 0 {
+		return diffs
+	}
+
+	return diffs
+}
+
+func (sd *SpecAnalyser) compareParams(urlMethod URLMethod, location string, name string, param1, param2 spec.Parameter) {
+	diffLocation := DifferenceLocation{URL: urlMethod.Path, Method: urlMethod.Method}
+
+	childLocation := diffLocation.AddNode(getNameOnlyDiffNode(strings.Title(location)))
+	paramLocation := diffLocation.AddNode(getNameOnlyDiffNode(name))
+	sd.compareDescripton(paramLocation, param1.Description, param2.Description)
+
+	if param1.Schema != nil && param2.Schema != nil {
+		childLocation = childLocation.AddNode(getSchemaDiffNode(name, param2.Schema))
+		sd.compareSchema(childLocation, param1.Schema, param2.Schema, param1.Required, param2.Required)
+	}
+	diffs := sd.CompareTypes(forParam(param1), forParam(param2))
+
+	childLocation = childLocation.AddNode(getSchemaDiffNode(name, param2.Schema))
+	for _, eachDiff := range diffs {
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{
+			DifferenceLocation: childLocation,
+			Code:               eachDiff.Change,
+			DiffInfo:           eachDiff.Description})
+	}
+	if param1.Required != param2.Required {
+		code := ChangedRequiredToOptionalParam
+		if param2.Required {
+			code = ChangedOptionalToRequiredParam
+		}
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: childLocation, Code: code})
+	}
+}
+
+func (sd *SpecAnalyser) compareSimpleSchema(location DifferenceLocation, schema1, schema2 *spec.SimpleSchema, required1, required2 bool) {
+	if schema1 == nil || schema2 == nil {
+		return
+	}
+
+	if schema1.Type == ArrayType {
+		refSchema1 := schema1.Items.SimpleSchema
+		refSchema2 := schema2.Items.SimpleSchema
+
+		childLocation := location.AddNode(getSimpleSchemaDiffNode("", schema1))
+		sd.compareSimpleSchema(childLocation, &refSchema1, &refSchema2, required1, required2)
+		return
+	}
+	if required1 != required2 {
+		code := AddedRequiredProperty
+		if required1 {
+			code = ChangedRequiredToOptional
+
+		}
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: location, Code: code})
+	}
+
+}
+
+func (sd *SpecAnalyser) compareDescripton(location DifferenceLocation, desc1, desc2 string) {
+	if desc1 != desc2 {
+		code := ChangedDescripton
+		if len(desc1) > 0 {
+			code = DeletedDescripton
+		} else if len(desc2) > 0 {
+			code = AddedDescripton
+		}
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: location, Code: code})
+	}
+
+}
+
+func (sd *SpecAnalyser) compareSchema(location DifferenceLocation, schema1, schema2 *spec.Schema, required1, required2 bool) {
+
+	if schema1 == nil || schema2 == nil {
+		return
+	}
+
+	sd.compareDescripton(location, schema1.Description, schema2.Description)
+
+	if len(schema1.Type) == 0 {
+		refSchema1, definition1 := sd.schemaFromRef(schema1, &sd.Definitions1)
+		refSchema2, definition2 := sd.schemaFromRef(schema2, &sd.Definitions2)
+
+		if len(definition1) > 0 {
+			info := fmt.Sprintf("[%s -> %s]", definition1, definition2)
+
+			if definition1 != definition2 {
+				sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: location,
+					Code:     ChangedType,
+					DiffInfo: info,
+				})
+			}
+			sd.compareSchema(location, refSchema1, refSchema2, required1, required2)
+			return
+		}
+	} else {
+		if schema1.Type[0] == ArrayType {
+			refSchema1, definition1 := sd.schemaFromRef(schema1.Items.Schema, &sd.Definitions1)
+			refSchema2, _ := sd.schemaFromRef(schema2.Items.Schema, &sd.Definitions2)
+
+			if len(definition1) > 0 {
+				childLocation := location.AddNode(getSchemaDiffNode("", schema1))
+				sd.compareSchema(childLocation, refSchema1, refSchema2, required1, required2)
+				return
+			}
+
+		}
+		diffs := sd.CompareTypes(schema1.SchemaProps, schema2.SchemaProps)
+
+		for _, eachTypeDiff := range diffs {
+			if eachTypeDiff.Change != NoChangeDetected {
+				sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: location, Code: eachTypeDiff.Change, DiffInfo: eachTypeDiff.Description})
+			}
+		}
+	}
+
+	if required1 != required2 {
+		code := AddedRequiredProperty
+		if required1 {
+			code = ChangedRequiredToOptional
+
+		}
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: location, Code: code})
+	}
+	requiredProps2 := sliceToStrMap(schema2.Required)
+	requiredProps1 := sliceToStrMap(schema1.Required)
+	schema1Props := sd.propertiesFor(schema1, &sd.Definitions1)
+	schema2Props := sd.propertiesFor(schema2, &sd.Definitions2)
+	// find deleted and changed properties
+	for eachProp1Name, eachProp1 := range schema1Props {
+		eachProp1 := eachProp1
+		_, required1 := requiredProps1[eachProp1Name]
+		_, required2 := requiredProps2[eachProp1Name]
+		childLoc := sd.addChildDiffNode(location, eachProp1Name, &eachProp1)
+
+		if eachProp2, ok := schema2Props[eachProp1Name]; ok {
+			sd.compareSchema(childLoc, &eachProp1, &eachProp2, required1, required2)
+			sd.compareDescripton(childLoc, eachProp1.Description, eachProp2.Description)
+		} else {
+			sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: childLoc, Code: DeletedProperty})
+		}
+	}
+
+	// find added properties
+	for eachProp2Name, eachProp2 := range schema2.Properties {
+		eachProp2 := eachProp2
+		if _, ok := schema1.Properties[eachProp2Name]; !ok {
+			childLoc := sd.addChildDiffNode(location, eachProp2Name, &eachProp2)
+			_, required2 := requiredProps2[eachProp2Name]
+			code := AddedProperty
+			if required2 {
+				code = AddedRequiredProperty
+			}
+			sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: childLoc, Code: code})
+		}
+	}
+}
+
+func (sd *SpecAnalyser) addChildDiffNode(location DifferenceLocation, propName string, propSchema *spec.Schema) DifferenceLocation {
+	newLoc := location
+	if newLoc.Node != nil {
+		newLoc.Node = newLoc.Node.Copy()
+	}
+
+	childNode := sd.fromSchemaProps(propName, &propSchema.SchemaProps)
+	if newLoc.Node != nil {
+		newLoc.Node.AddLeafNode(&childNode)
+	} else {
+		newLoc.Node = &childNode
+	}
+	return newLoc
+}
+
+func (sd *SpecAnalyser) fromSchemaProps(fieldName string, props *spec.SchemaProps) Node {
+	node := Node{}
+	node.IsArray = props.Type[0] == ArrayType
+	if !node.IsArray {
+		node.TypeName = props.Type[0]
+	}
+	node.Field = fieldName
+	return node
+}
+
+func (sd *SpecAnalyser) compareEnums(left, right []interface{}) []TypeDiff {
+	diffs := []TypeDiff{}
+
+	leftStrs := []string{}
+	rightStrs := []string{}
+	for _, eachLeft := range left {
+		leftStrs = append(leftStrs, fmt.Sprintf("%v", eachLeft))
+	}
+	for _, eachRight := range right {
+		rightStrs = append(rightStrs, fmt.Sprintf("%v", eachRight))
+	}
+	added, deleted, _ := FromStringArray(leftStrs).DiffsTo(rightStrs)
+	if len(added) > 0 {
+		typeChange := strings.Join(added, ",")
+		diffs = append(diffs, TypeDiff{Change: AddedEnumValue, Description: typeChange})
+	}
+	if len(deleted) > 0 {
+		typeChange := strings.Join(deleted, ",")
+		diffs = append(diffs, TypeDiff{Change: DeletedEnumValue, Description: typeChange})
+	}
+
+	return diffs
+}
+
+func (sd *SpecAnalyser) findAddedEndpoints() {
+	for URLMethod := range sd.urlMethods2 {
+		if _, ok := sd.urlMethods1[URLMethod]; !ok {
+			sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: DifferenceLocation{URL: URLMethod.Path, Method: URLMethod.Method}, Code: AddedEndpoint})
+		}
+	}
+}
+
+func (sd *SpecAnalyser) findDeletedEndpoints() {
+	for eachURLMethod, operation1 := range sd.urlMethods1 {
+		code := DeletedEndpoint
+		if (operation1.ParentPathItem.Options != nil && operation1.ParentPathItem.Options.Deprecated) ||
+			(operation1.Operation.Deprecated) {
+			code = DeletedDeprecatedEndpoint
+		}
+		if _, ok := sd.urlMethods2[eachURLMethod]; !ok {
+			sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: DifferenceLocation{URL: eachURLMethod.Path, Method: eachURLMethod.Method}, Code: code})
+		}
+	}
+}
+
+func (sd *SpecAnalyser) analyseMetaDataProperty(item1, item2 string, codeIfDiff SpecChangeCode, compatIfDiff Compatibility) {
+	if item1 != item2 {
+		diffSpec := fmt.Sprintf("%s -> %s", item1, item2)
+		sd.Diffs = sd.Diffs.addDiff(SpecDifference{DifferenceLocation: DifferenceLocation{Node: &Node{Field: "Spec Metadata"}}, Code: codeIfDiff, Compatibility: compatIfDiff, DiffInfo: diffSpec})
+	}
+}
+
+func (sd *SpecAnalyser) schemaFromRef(schema *spec.Schema, defns *spec.Definitions) (actualSchema *spec.Schema, definitionName string) {
+	ref := schema.Ref
+	url := ref.GetURL()
+	if url == nil {
+		return schema, ""
+	}
+	fragmentParts := strings.Split(url.Fragment, "/")
+	numParts := len(fragmentParts)
+	if numParts == 0 {
+		return schema, ""
+	}
+
+	definitionName = fragmentParts[numParts-1]
+	foundSchema, ok := (*defns)[definitionName]
+	if !ok {
+		return nil, definitionName
+	}
+	actualSchema = &foundSchema
+	return
+
+}
+
+func (sd *SpecAnalyser) propertiesFor(schema *spec.Schema, defns *spec.Definitions) map[string]spec.Schema {
+	schemaFromRef, _ := sd.schemaFromRef(schema, defns)
+	schema = schemaFromRef
+	props := map[string]spec.Schema{}
+
+	if schema.Properties != nil {
+		for name, prop := range schema.Properties {
+			prop := prop
+			eachProp, _ := sd.schemaFromRef(&prop, defns)
+			props[name] = *eachProp
+		}
+	}
+	for _, eachAllOf := range schema.AllOf {
+		eachAllOf := eachAllOf
+		eachAllOfActual, _ := sd.schemaFromRef(&eachAllOf, defns)
+		for name, prop := range eachAllOfActual.Properties {
+			prop := prop
+			eachProp, _ := sd.schemaFromRef(&prop, defns)
+			props[name] = *eachProp
+		}
+	}
+	return props
+}
diff --git a/cmd/swagger/commands/diff/spec_analyser_test.go b/cmd/swagger/commands/diff/spec_analyser_test.go
new file mode 100644
index 00000000..9e80f4f0
--- /dev/null
+++ b/cmd/swagger/commands/diff/spec_analyser_test.go
@@ -0,0 +1,126 @@
+package diff
+
+import (
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strings"
+	"testing"
+
+	"github.com/corbym/gocrest/is"
+	"github.com/go-openapi/loads"
+)
+
+const (
+	basePath = "../../../../fixtures/diff"
+)
+
+type testCaseData struct {
+	name          string
+	oldSpec       string
+	newSpec       string
+	expectedLines string
+}
+
+// TestDiffForVariousCombinations - computes the diffs for a number
+// of scenarios and compares the computed diff with expected diffs
+func TestDiffForVariousCombinations(t *testing.T) {
+
+	diffRootPath := basePath + "/"
+	pattern := diffRootPath + "*.diff.txt"
+
+	// To filter cases for debugging poke an individual case here eg "path", "enum" etc
+	// see the test cases in fixtures/diff
+	// Don't forget to remove it once you're done.
+	// (There's a test at the end to check all cases were run)
+	matches := []string{}
+
+	allTests, err := filepath.Glob(pattern)
+
+	if err != nil || len(allTests) == 0 {
+		t.Fatalf("Couldn't find files")
+	}
+
+	if len(matches) == 0 {
+		matches = allTests
+	}
+
+	testCases := []testCaseData{}
+
+	for _, eachFile := range matches {
+		base := filepath.Base(eachFile)
+		parts := strings.Split(base, ".diff.txt")
+		namePart := parts[0]
+		testCases = append(
+			testCases, testCaseData{
+				name:          namePart,
+				oldSpec:       diffRootPath + namePart + ".v1.json",
+				newSpec:       diffRootPath + namePart + ".v2.json",
+				expectedLines: LinesInFile(diffRootPath + namePart + ".diff.txt"),
+			})
+
+	}
+	for _, tc := range testCases {
+		tc := tc
+		t.Run(tc.name, func(t *testing.T) {
+			diffs, err := getDiffs(tc.oldSpec, tc.newSpec)
+			assertThat(t, err, is.Nil())
+
+			if err == nil {
+				diffsStr := catchStdOut(t, func() {
+					err = diffs.ReportAllDiffs(false)
+					if diffs.BreakingChangeCount() > 0 {
+						assertThat(t, err, is.Not(is.Nil()))
+					}
+				})
+				assertThat(t, diffsStr, is.EqualToIgnoringWhitespace(tc.expectedLines))
+			}
+		})
+	}
+
+	assertThat(t, len(matches), is.EqualTo(len(allTests)).Reason("All test cases were not run. Remove filter."))
+}
+
+func LinesInFile(fileName string) string {
+	bytes, _ := ioutil.ReadFile(fileName)
+	return string(bytes)
+}
+
+func catchStdOut(t *testing.T, runnable func()) string {
+
+	realStdout := os.Stdout
+	defer func() { os.Stdout = realStdout }()
+	r, fakeStdout, err := os.Pipe()
+	dieOn(err, t)
+	os.Stdout = fakeStdout
+	runnable()
+	// need to close here, otherwise ReadAll never gets "EOF".
+	dieOn(fakeStdout.Close(), t)
+	newOutBytes, err := ioutil.ReadAll(r)
+	dieOn(err, t)
+	dieOn(r.Close(), t)
+	return string(newOutBytes)
+}
+
+func dieOn(err error, t *testing.T) {
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
+func getDiffs(oldSpecPath, newSpecPath string) (SpecDifferences, error) {
+	swaggerDoc1 := oldSpecPath
+	specDoc1, err := loads.Spec(swaggerDoc1)
+
+	if err != nil {
+		return nil, err
+	}
+
+	swaggerDoc2 := newSpecPath
+	specDoc2, err := loads.Spec(swaggerDoc2)
+	if err != nil {
+		return nil, err
+	}
+
+	return Compare(specDoc1.Spec(), specDoc2.Spec())
+}
diff --git a/cmd/swagger/commands/diff/spec_difference.go b/cmd/swagger/commands/diff/spec_difference.go
new file mode 100644
index 00000000..ead620b3
--- /dev/null
+++ b/cmd/swagger/commands/diff/spec_difference.go
@@ -0,0 +1,190 @@
+package diff
+
+import (
+	"fmt"
+	"log"
+	"sort"
+)
+
+// SpecDifference encapsulates the details of an individual diff in part of a spec
+type SpecDifference struct {
+	DifferenceLocation DifferenceLocation `json:"location"`
+	Code               SpecChangeCode     `json:"code"`
+	Compatibility      Compatibility      `json:"compatibility"`
+	DiffInfo           string             `json:"info,omitempty"`
+}
+
+// SpecDifferences list of differences
+type SpecDifferences []SpecDifference
+
+// Matches returns true if the diff matches another
+func (sd SpecDifference) Matches(other SpecDifference) bool {
+	return sd.Code == other.Code &&
+		sd.Compatibility == other.Compatibility &&
+		sd.DiffInfo == other.DiffInfo &&
+		equalLocations(sd.DifferenceLocation, other.DifferenceLocation)
+}
+
+func equalLocations(a, b DifferenceLocation) bool {
+	return a.Method == b.Method &&
+		a.Response == b.Response &&
+		a.URL == b.URL &&
+		equalNodes(a.Node, b.Node)
+}
+
+func equalNodes(a, b *Node) bool {
+	if a == nil && b == nil {
+		return true
+	}
+	if a == nil || b == nil {
+		return false
+	}
+	return a.Field == b.Field &&
+		a.IsArray == b.IsArray &&
+		a.TypeName == b.TypeName &&
+		equalNodes(a.ChildNode, b.ChildNode)
+
+}
+
+// BreakingChangeCount Calculates the breaking change count
+func (sd SpecDifferences) BreakingChangeCount() int {
+	count := 0
+	for _, eachDiff := range sd {
+		if eachDiff.Compatibility == Breaking {
+			count++
+		}
+	}
+	return count
+}
+
+// FilterIgnores returns a copy of the list without the items in the specified ignore list
+func (sd SpecDifferences) FilterIgnores(ignores SpecDifferences) SpecDifferences {
+	newDiffs := SpecDifferences{}
+	for _, eachDiff := range sd {
+		if !ignores.Contains(eachDiff) {
+			newDiffs = newDiffs.addDiff(eachDiff)
+		}
+	}
+	return newDiffs
+}
+
+// Contains Returns true if the item contains the specified item
+func (sd SpecDifferences) Contains(diff SpecDifference) bool {
+	for _, eachDiff := range sd {
+		if eachDiff.Matches(diff) {
+			return true
+		}
+	}
+	return false
+}
+
+// String std string renderer
+func (sd SpecDifference) String() string {
+	isResponse := sd.DifferenceLocation.Response > 0
+	hasMethod := len(sd.DifferenceLocation.Method) > 0
+	hasURL := len(sd.DifferenceLocation.URL) > 0
+
+	prefix := ""
+	direction := ""
+
+	if isResponse {
+		direction = " Response"
+		if hasURL {
+			if hasMethod {
+				prefix = fmt.Sprintf("%s:%s -> %d", sd.DifferenceLocation.URL, sd.DifferenceLocation.Method, sd.DifferenceLocation.Response)
+			} else {
+				prefix = fmt.Sprintf("%s ", sd.DifferenceLocation.URL)
+			}
+		}
+	} else {
+		if hasURL {
+			if hasMethod {
+				direction = " Request"
+				prefix = fmt.Sprintf("%s:%s", sd.DifferenceLocation.URL, sd.DifferenceLocation.Method)
+			} else {
+				prefix = fmt.Sprintf("%s ", sd.DifferenceLocation.URL)
+			}
+		} else {
+			prefix = " Metadata"
+		}
+	}
+
+	paramOrPropertyLocation := ""
+	if sd.DifferenceLocation.Node != nil {
+		paramOrPropertyLocation = " - " + sd.DifferenceLocation.Node.String() + " "
+	}
+	optionalInfo := ""
+	if sd.DiffInfo != "" {
+		optionalInfo = fmt.Sprintf(" <%s>", sd.DiffInfo)
+	}
+	return fmt.Sprintf("%s%s%s- %s%s", prefix, direction, paramOrPropertyLocation, sd.Code.Description(), optionalInfo)
+}
+
+func (sd SpecDifferences) addDiff(diff SpecDifference) SpecDifferences {
+	context := Request
+	if diff.DifferenceLocation.Response > 0 {
+		context = Response
+	}
+	diff.Compatibility = getCompatibilityForChange(diff.Code, context)
+
+	return append(sd, diff)
+}
+
+// ReportCompatibility lists and spec
+func (sd *SpecDifferences) ReportCompatibility() error {
+	breakingCount := sd.BreakingChangeCount()
+	if breakingCount > 0 {
+		fmt.Printf("\nBREAKING CHANGES:\n=================\n")
+		sd.reportChanges(Breaking)
+		return fmt.Errorf("compatibility Test FAILED: %d Breaking changes detected", breakingCount)
+	}
+	log.Printf("Compatibility test OK. No breaking changes identified.")
+	return nil
+}
+
+func (sd SpecDifferences) reportChanges(compat Compatibility) {
+	toReportList := []string{}
+
+	for _, diff := range sd {
+		if diff.Compatibility == compat {
+			toReportList = append(toReportList, diff.String())
+		}
+	}
+
+	sort.Slice(toReportList, func(i, j int) bool {
+		return toReportList[i] < toReportList[j]
+	})
+
+	for _, eachDiff := range toReportList {
+		fmt.Println(eachDiff)
+	}
+}
+
+// ReportAllDiffs lists all the diffs between two specs
+func (sd SpecDifferences) ReportAllDiffs(fmtJSON bool) error {
+	if fmtJSON {
+
+		b, err := JSONMarshal(sd)
+		if err != nil {
+			log.Fatalf("Couldn't print results: %v", err)
+		}
+		pretty, err := prettyprint(b)
+		if err != nil {
+			log.Fatalf("Couldn't print results: %v", err)
+		}
+		fmt.Println(string(pretty))
+		return nil
+	}
+	numDiffs := len(sd)
+	if numDiffs == 0 {
+		fmt.Println("No changes identified")
+		return nil
+	}
+
+	if numDiffs != sd.BreakingChangeCount() {
+		fmt.Println("NON-BREAKING CHANGES:\n=====================")
+		sd.reportChanges(NonBreaking)
+	}
+
+	return sd.ReportCompatibility()
+}
diff --git a/cmd/swagger/commands/diff/spec_difference_test.go b/cmd/swagger/commands/diff/spec_difference_test.go
new file mode 100644
index 00000000..2898bd6f
--- /dev/null
+++ b/cmd/swagger/commands/diff/spec_difference_test.go
@@ -0,0 +1,66 @@
+package diff_test
+
+import (
+	"testing"
+
+	"github.com/corbym/gocrest/is"
+	"github.com/corbym/gocrest/then"
+	"github.com/go-swagger/go-swagger/cmd/swagger/commands/diff"
+)
+
+var assertThat = then.AssertThat
+var equals = is.EqualTo
+
+func TestMatches(t *testing.T) {
+	urlOnly := diff.SpecDifference{DifferenceLocation: diff.DifferenceLocation{URL: "bob"}}
+	urlOnlyDiff := diff.SpecDifference{DifferenceLocation: diff.DifferenceLocation{URL: "notbob"}}
+	urlOnlySame := diff.SpecDifference{DifferenceLocation: diff.DifferenceLocation{URL: "bob"}}
+
+	assertThat(t, urlOnly.Matches(urlOnlySame), equals(true))
+	assertThat(t, urlOnly.Matches(urlOnlyDiff), equals(false))
+
+	withMethod := urlOnly
+	withMethod.DifferenceLocation.Method = "PUT"
+	withMethodSame := withMethod
+	withMethodDiff := withMethod
+	withMethodDiff.DifferenceLocation.Method = "GET"
+
+	assertThat(t, withMethod.Matches(withMethodSame), equals(true))
+	assertThat(t, withMethod.Matches(withMethodDiff), equals(false))
+
+	withResponse := urlOnly
+	withResponse.DifferenceLocation.Response = 0
+	withResponseSame := withResponse
+	withResponseDiff := withResponse
+	withResponseDiff.DifferenceLocation.Response = 2
+
+	assertThat(t, withResponse.Matches(withResponseSame), equals(true))
+	assertThat(t, withResponse.Matches(withResponseDiff), equals(false))
+
+	withNode := urlOnly
+	withNode.DifferenceLocation.Node = &diff.Node{Field: "FieldA", TypeName: "TypeA"}
+	withNodeSame := withNode
+	withNodeSame.DifferenceLocation.Node = &diff.Node{Field: "FieldA", TypeName: "TypeA"}
+
+	withNodeDiff := withNode
+	withNodeDiff.DifferenceLocation.Node = &diff.Node{Field: "FieldA", TypeName: "TypeB"}
+
+	assertThat(t, withNode.Matches(withNodeSame), equals(true))
+	assertThat(t, withNode.Matches(withNodeDiff), equals(false))
+
+	withNodeDiff.DifferenceLocation.Node = &diff.Node{Field: "FieldB", TypeName: "TypeA"}
+
+	assertThat(t, withNode.Matches(withNodeSame), equals(true))
+	assertThat(t, withNode.Matches(withNodeDiff), equals(false))
+
+	withNestedNode := withNode
+	withNestedNode.DifferenceLocation = withNestedNode.DifferenceLocation.AddNode(&diff.Node{Field: "ChildA", TypeName: "ChildA"})
+	withNestedNodeSame := withNode
+	withNestedNodeSame.DifferenceLocation = withNestedNodeSame.DifferenceLocation.AddNode(&diff.Node{Field: "ChildA", TypeName: "ChildA"})
+	withNestedNodeDiff := withNode
+	withNestedNodeDiff.DifferenceLocation = withNestedNodeDiff.DifferenceLocation.AddNode(&diff.Node{Field: "ChildB", TypeName: "ChildA"})
+
+	assertThat(t, withNestedNode.Matches(withNestedNodeSame), equals(true))
+	assertThat(t, withNestedNode.Matches(withNestedNodeDiff), equals(false))
+
+}
diff --git a/cmd/swagger/commands/diff/type_adapters.go b/cmd/swagger/commands/diff/type_adapters.go
new file mode 100644
index 00000000..5e271b21
--- /dev/null
+++ b/cmd/swagger/commands/diff/type_adapters.go
@@ -0,0 +1,170 @@
+package diff
+
+import (
+	"fmt"
+
+	"github.com/go-openapi/spec"
+)
+
+func forItems(items *spec.Items) *spec.Schema {
+	if items == nil {
+		return nil
+	}
+	valids := items.CommonValidations
+	schema := spec.Schema{
+		SchemaProps: spec.SchemaProps{
+			Type:             []string{items.SimpleSchema.Type},
+			Format:           items.SimpleSchema.Format,
+			Maximum:          valids.Maximum,
+			ExclusiveMaximum: valids.ExclusiveMaximum,
+			Minimum:          valids.Minimum,
+			ExclusiveMinimum: valids.ExclusiveMinimum,
+			MaxLength:        valids.MaxLength,
+			MinLength:        valids.MinLength,
+			Pattern:          valids.Pattern,
+			MaxItems:         valids.MaxItems,
+			MinItems:         valids.MinItems,
+			UniqueItems:      valids.UniqueItems,
+			MultipleOf:       valids.MultipleOf,
+			Enum:             valids.Enum,
+		},
+	}
+	return &schema
+}
+
+func forParam(param spec.Parameter) spec.SchemaProps {
+	return spec.SchemaProps{
+		Type:             []string{param.Type},
+		Format:           param.Format,
+		Items:            &spec.SchemaOrArray{Schema: forItems(param.Items)},
+		Maximum:          param.Maximum,
+		ExclusiveMaximum: param.ExclusiveMaximum,
+		Minimum:          param.Minimum,
+		ExclusiveMinimum: param.ExclusiveMinimum,
+		MaxLength:        param.MaxLength,
+		MinLength:        param.MinLength,
+		Pattern:          param.Pattern,
+		MaxItems:         param.MaxItems,
+		MinItems:         param.MinItems,
+		UniqueItems:      param.UniqueItems,
+		MultipleOf:       param.MultipleOf,
+		Enum:             param.Enum,
+	}
+}
+
+// OperationMap saves indexing operations in PathItems individually
+type OperationMap map[string]*spec.Operation
+
+func toMap(item *spec.PathItem) OperationMap {
+	m := make(OperationMap)
+
+	if item.Post != nil {
+		m["post"] = item.Post
+	}
+	if item.Get != nil {
+		m["get"] = item.Get
+	}
+	if item.Put != nil {
+		m["put"] = item.Put
+	}
+	if item.Patch != nil {
+		m["patch"] = item.Patch
+	}
+	if item.Head != nil {
+		m["head"] = item.Head
+	}
+	if item.Options != nil {
+		m["options"] = item.Options
+	}
+	if item.Delete != nil {
+		m["delete"] = item.Delete
+	}
+	return m
+}
+
+func getURLMethodsFor(spec *spec.Swagger) URLMethods {
+	returnURLMethods := URLMethods{}
+
+	for url, eachPath := range spec.Paths.Paths {
+		eachPath := eachPath
+		opsMap := toMap(&eachPath)
+		for method, op := range opsMap {
+			returnURLMethods[URLMethod{url, method}] = &PathItemOp{&eachPath, op}
+		}
+	}
+	return returnURLMethods
+}
+
+func sliceToStrMap(elements []string) map[string]bool {
+	elementMap := make(map[string]bool)
+	for _, s := range elements {
+		elementMap[s] = true
+	}
+	return elementMap
+}
+
+func isStringType(typeName string) bool {
+	return typeName == "string" || typeName == "password"
+}
+
+const objType = "obj"
+
+func getTypeHierarchyChange(type1, type2 string) TypeDiff {
+	if type1 == type2 {
+		return TypeDiff{Change: NoChangeDetected, Description: ""}
+	}
+	fromType := type1
+	if fromType == "" {
+		fromType = objType
+	}
+	toType := type2
+	if toType == "" {
+		toType = objType
+	}
+	diffDescription := fmt.Sprintf("%s -> %s", fromType, toType)
+	if isStringType(type1) && !isStringType(type2) {
+		return TypeDiff{Change: NarrowedType, Description: diffDescription}
+	}
+	if !isStringType(type1) && isStringType(type2) {
+		return TypeDiff{Change: WidenedType, Description: diffDescription}
+	}
+	type1Wideness, type1IsNumeric := numberWideness[type1]
+	type2Wideness, type2IsNumeric := numberWideness[type2]
+	if type1IsNumeric && type2IsNumeric {
+		if type1Wideness == type2Wideness {
+			return TypeDiff{Change: ChangedToCompatibleType, Description: diffDescription}
+		}
+		if type1Wideness > type2Wideness {
+			return TypeDiff{Change: NarrowedType, Description: diffDescription}
+		}
+		if type1Wideness < type2Wideness {
+			return TypeDiff{Change: WidenedType, Description: diffDescription}
+		}
+	}
+	return TypeDiff{Change: ChangedType, Description: diffDescription}
+}
+
+func compareFloatValues(fieldName string, val1 *float64, val2 *float64, ifGreaterCode SpecChangeCode, ifLessCode SpecChangeCode) TypeDiff {
+	if val1 != nil && val2 != nil {
+		if *val2 > *val1 {
+			return TypeDiff{Change: ifGreaterCode, Description: fmt.Sprintf("%s %f->%f", fieldName, *val1, *val2)}
+		}
+		if *val2 < *val1 {
+			return TypeDiff{Change: ifLessCode, Description: fmt.Sprintf("%s %f->%f", fieldName, *val1, *val2)}
+		}
+	}
+	return TypeDiff{Change: NoChangeDetected, Description: ""}
+}
+
+func compareIntValues(fieldName string, val1 *int64, val2 *int64, ifGreaterCode SpecChangeCode, ifLessCode SpecChangeCode) TypeDiff {
+	if val1 != nil && val2 != nil {
+		if *val2 > *val1 {
+			return TypeDiff{Change: ifGreaterCode, Description: fmt.Sprintf("%s %d->%d", fieldName, *val1, *val2)}
+		}
+		if *val2 < *val1 {
+			return TypeDiff{Change: ifLessCode, Description: fmt.Sprintf("%s %d->%d", fieldName, *val1, *val2)}
+		}
+
+	}
+	return TypeDiff{Change: NoChangeDetected, Description: ""}
+}
diff --git a/cmd/swagger/commands/diff_test.go b/cmd/swagger/commands/diff_test.go
new file mode 100644
index 00000000..1ad42976
--- /dev/null
+++ b/cmd/swagger/commands/diff_test.go
@@ -0,0 +1,170 @@
+package commands
+
+import (
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strings"
+
+	"testing"
+
+	"github.com/go-swagger/go-swagger/cmd/swagger/commands/diff"
+
+	"github.com/corbym/gocrest/is"
+	"github.com/corbym/gocrest/then"
+)
+
+var assertThat = then.AssertThat
+var equals = is.EqualTo
+
+const (
+	basePath = "../../../fixtures/diff"
+)
+
+type testCaseData struct {
+	name          string
+	oldSpec       string
+	newSpec       string
+	expectedLines string
+}
+
+// TestDiffForVariousCombinations - computes the diffs for a number
+// of scenarios and compares the computed diff with expected diffs
+func TestDiffForVariousCombinations(t *testing.T) {
+
+	diffRootPath := basePath + "/"
+	pattern := diffRootPath + "*.diff.txt"
+
+	// To filter cases for debugging poke an individual case here eg "path", "enum" etc
+	// see the test cases in fixtures/diff
+	// Don't forget to remove it once you're done.
+	// (There's a test at the end to check all cases were run)
+	matches := []string{"path"}
+
+	allTests, err := filepath.Glob(pattern)
+
+	if err != nil || len(allTests) == 0 {
+		t.Fatalf("Couldn't find files")
+	}
+
+	if len(matches) == 0 {
+		matches = allTests
+	}
+
+	testCases := []testCaseData{}
+
+	for _, eachFile := range matches {
+		base := filepath.Base(eachFile)
+		parts := strings.Split(base, ".diff.txt")
+		namePart := parts[0]
+		testCases = append(
+			testCases, testCaseData{
+				name:          namePart,
+				oldSpec:       diffRootPath + namePart + ".v1.json",
+				newSpec:       diffRootPath + namePart + ".v2.json",
+				expectedLines: LinesInFile(diffRootPath + namePart + ".diff.txt"),
+			})
+
+	}
+	for _, tc := range testCases {
+		tc := tc
+		t.Run(tc.name, func(t *testing.T) {
+
+			diffs, err := getDiffs(tc.oldSpec, tc.newSpec)
+
+			assertThat(t, err, is.Nil())
+
+			if err == nil {
+
+				diffsStr := catchStdOut(t, func() {
+					err = diffs.ReportAllDiffs(false)
+					assertThat(t, err, is.Not(is.Nil()))
+				})
+				assertThat(t, diffsStr, is.EqualToIgnoringWhitespace(tc.expectedLines))
+			}
+		})
+	}
+}
+
+func TestReadIgnores(t *testing.T) {
+
+	diffRootPath := basePath + "/"
+	ignorePath := diffRootPath + "ignoreFile.json"
+	ignores, err := readIgnores(ignorePath)
+
+	assertThat(t, err, is.Nil())
+	assertThat(t, len(ignores), is.Not(equals(0)))
+
+	isIn := diff.SpecDifference{DifferenceLocation: diff.DifferenceLocation{
+		Method:   "get",
+		Response: 0,
+		URL:      "/a/",
+		Node:     &diff.Node{Field: "Query", ChildNode: &diff.Node{Field: "personality"}},
+	},
+		Code:          diff.AddedEnumValue,
+		Compatibility: diff.NonBreaking,
+		DiffInfo:      "extrovert",
+	}
+	assertThat(t, ignores.Contains(isIn), equals(true))
+
+}
+
+func dieOn(err error, t *testing.T) {
+	if err != nil {
+		t.Fatal(err)
+	}
+}
+
+func TestProcessIgnores(t *testing.T) {
+	diffRootPath := basePath + "/"
+	namePart := "enum"
+	tc := testCaseData{
+		name:          namePart,
+		oldSpec:       diffRootPath + namePart + ".v1.json",
+		newSpec:       diffRootPath + namePart + ".v2.json",
+		expectedLines: LinesInFile(diffRootPath + "ignoreDiffs.json"),
+	}
+
+	cmd := DiffCommand{
+		Format:     "json",
+		IgnoreFile: diffRootPath + "ignoreFile.json",
+	}
+
+	diffsStr := catchStdOut(t, func() {
+		err := cmd.Execute([]string{tc.oldSpec, tc.newSpec})
+		assertThat(t, err, is.Nil())
+	})
+	assertThat(t, diffsStr, is.EqualToIgnoringWhitespace(tc.expectedLines))
+}
+
+func TestNoArgs(t *testing.T) {
+
+	cmd := DiffCommand{
+		Format:     "json",
+		IgnoreFile: "",
+	}
+
+	err := cmd.Execute([]string{})
+	assertThat(t, err, is.Not(is.Nil()))
+}
+
+func LinesInFile(fileName string) string {
+	bytes, _ := ioutil.ReadFile(fileName)
+	return string(bytes)
+}
+
+func catchStdOut(t *testing.T, runnable func()) string {
+
+	realStdout := os.Stdout
+	defer func() { os.Stdout = realStdout }()
+	r, fakeStdout, err := os.Pipe()
+	dieOn(err, t)
+	os.Stdout = fakeStdout
+	runnable()
+	// need to close here, otherwise ReadAll never gets "EOF".
+	dieOn(fakeStdout.Close(), t)
+	newOutBytes, err := ioutil.ReadAll(r)
+	dieOn(err, t)
+	dieOn(r.Close(), t)
+	return string(newOutBytes)
+}
diff --git a/cmd/swagger/swagger.go b/cmd/swagger/swagger.go
index 7e72fe1d..79a299a6 100644
--- a/cmd/swagger/swagger.go
+++ b/cmd/swagger/swagger.go
@@ -99,6 +99,11 @@ It aims to represent the contract of your API with a language agnostic descripti
 		log.Fatal(err)
 	}
 
+	_, err = parser.AddCommand("diff", "diff swagger documents", "diff specs showing which changes will break existing clients", &commands.DiffCommand{})
+	if err != nil {
+		log.Fatal(err)
+	}
+
 	genpar, err := parser.AddCommand("generate", "generate go code", "generate go code for the swagger spec file", &commands.Generate{})
 	if err != nil {
 		log.Fatalln(err)
diff --git a/docs/README.md b/docs/README.md
index 0e91e92d..9e216595 100644
--- a/docs/README.md
+++ b/docs/README.md
@@ -84,6 +84,7 @@ Here is an outline of available features (see the full list [here](https://goswa
   - Validation
   - Authorization
   - Swagger docs UI
+  - A Diff tool which will cause a build to fail if a change in the spec breaks backwards compatibility
 
 There is more to that...
 
@@ -156,7 +157,7 @@ Resolve and expand $ref's in your spec as inline definitions:
 swagger expand {spec}
 ```
 
-Flatten you spec: all external $ref's are imported into the main document and inline schemas reorganized as definitions.
+Flatten your spec: all external $ref's are imported into the main document and inline schemas reorganized as definitions.
 ```
 swagger flatten {spec}
 ```
@@ -166,6 +167,22 @@ Merge specifications (composition):
 swagger mixin {spec1} {spec2}
 ```
 
+
+### Compare specs
+
+The  diff command allows you to check backwards compatibility.
+Type ```swagger diff --help``` for info.
+
+```
+swagger diff {spec1} {spec2}
+```
+
+## Try it
+
+Try `go-swagger` in a free online workspace using Gitpod:
+
+[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io#https://github.com/go-swagger/go-swagger)
+
 ## Licensing
 
 The toolkit itself is licensed as Apache Software License 2.0. Just like swagger, this does not cover code generated by the toolkit. That code is entirely yours to license however you see fit.
diff --git a/docs/diff/README.md b/docs/diff/README.md
new file mode 100644
index 00000000..24b284b2
--- /dev/null
+++ b/docs/diff/README.md
@@ -0,0 +1,3 @@
+<!--
+    Put in this directory CLI diff subcommands reference usage
+-->
diff --git a/docs/diff/diff.md b/docs/diff/diff.md
new file mode 100644
index 00000000..7dc01baa
--- /dev/null
+++ b/docs/diff/diff.md
@@ -0,0 +1,160 @@
+# Generate an Difference Report between two versions of a spec
+
+The toolkit has a command that will let you find the changes in a spec.
+
+### Command usage
+
+```
+Usage:
+  swagger [OPTIONS] diff [diff-OPTIONS] spec1 spec2
+
+diff two swagger spec files
+
+Application Options:
+  -q, --quiet                    silence logs
+  -o, --output=LOG-FILE          redirect logs to file
+
+Help Options:
+  -h, --help                     Show this help message
+
+[diff command options]
+      -b, --break                When present, only shows incompatible changes
+      -f, --format=[txt|json]    When present, writes output as json (default: txt)
+      -i, --ignore=              Exception file of diffs to ignore (copy output from json diff format) (default: none
+                                 specified)
+      -d, --dest=                Output destination file or stdout (default: stdout)
+
+```
+
+### Diff output
+
+The output is either a json array of diffs or a human-readable text change report split into breaking and non-breaking changes detected:
+
+```
+NON-BREAKING CHANGES:
+=====================
+/a/:put -  Added endpoint  
+/a/{id}:post -  Deleted a deprecated endpoint  
+/newpath/:post -  Added endpoint  
+
+BREAKING CHANGES:
+=================
+/a/:post -  Deleted endpoint  
+/b/:post -  Deleted endpoint  
+```
+
+### What does calculating Diffs enable me to do?
+
+The challenge of managing changes to API's is one which the industry has wrestled
+with for as long as we've had them.
+The popularity of microservice architectures talking to each other via REST has multiplied the
+complexity, particularly in a Continuous Integration Continuous Delivery (CI/CD) environment.
+
+One popular solution is to use testing to ensure confidence in API compatibility as they change.
+There are a few flavours of this but they are all variations on a theme.
+
+  i) Humans imagine an API.
+  ii) Humans code the server and one or more clients.
+  iii) Humans write tests to ensure that all the humans are doing the right thing.
+
+This is okay, but has challenges of its own.
+
+ i) There's a lot of repetitive boilerplate that humans are forced to write
+ ii) The tests can provide feedback which is late or inaccurate. Depending on the actual test
+     they may or may not detect backwards incompatible changes. When they do detect it they could flag a failure at a point which is removed from the bug injection. ie I break the server API but
+     only find out later when one of the client API tests fails (maybe)
+
+### The Alternative - Spec Driven Development (SDD)
+
+Instead of getting the primates to do all the repetitive typing and testing - we get computers to do it for us.
+That's where the go-swagger generate (or swagger-codegen) come into play.
+So now the workflow becomes:
+
+  1) Humans imagine an API and express it in a swagger spec
+  2) The code for the server endpoints is generated from that spec and wired in to the server app.
+  3) The code for the client to access the API (eg RestTemplates/OkHttp etc) is also generated from the same spec and wired in.
+  4) No tests need to be written to ensure that the client code matches the server code because they've both been auto-generated from the same spec.
+
+### What About when something changes?
+
+Great question! Glad you're still with us. Yes. The testing outlined in the human generated client/server workflow ensures that the API code matches not just when it's created, but also when it's updated. The most
+popular incarnation of this type of testing is known as PACT testing.
+
+#### Aren't all the cool kids using PACT for this?
+
+Methodologies like Consumer-Driven Contract Testing(https://docs.pact.io/how_pact_works)[PACT] testing can give confidence that the API has not been broken... but it suffers from some challenges:
+
+ 1) Complexity in setting up PACT brokers and code to capture reproduce server states for interactions where state impacts what gets returned from a server.
+ 2) Depending on the sequence of execution a client change could cause the server CI/CD pipeline to asyncronously fail as a result of a breaking client change.
+
+#### Using the spec and version control system to ensure backwards compatibility
+
+ Instead of pinning our hopes on after-the-event tests to tell us we did something bad somewhere else,
+ why not identify the problem at it's source: the spec itself. If the only thing that can influence the interaction is the API, and the spec defines the API - let's focus on that.
+
+ Given that the spec is well defined, it should be possible to identify changes in a spec that will break. A simple example is deleting an endpoint in use by clients. In general, when both server and client are auto-generated from versions of the same specification, a change will break if:
+
+  i) The server expects something new from the client which it doesn't provide
+  ii) The server stops accepting data formats that the client provides.
+  iii) The server stops accepting requests on a given endpoint that the client expects to call.
+  iii) The server changes the format of returned data.
+  iv) The server returns a different return code or different data.
+
+In order to ferret these changes out at the source we add the spec to the server source code repository and then use go-swagger diff to compare any changes against the currently deployed version as a part of the server build.
+
+If any breaking changes in the server are detected, the build fails immediately and the change is never built or deployed. This doesn't suffer from the "random failure" or delayed feedback which is present in relying on downstream testing to ensure backwards compatibility. Making changes to the spec can be done with confidence, because breaking changes are flagged immediately and never propagated to ANY client.
+
+The question is which version do I compare against? The simplest approach would be to compare against the previously committed version but this is subject to flux. The next approach is to compare against the previously pushed version. This is closer to what's in production but may not be exactly what's in prod. The closest fit is for the CI/CD pipeline to tag the server repository with the currently deployed version.
+
+If we ensure that each version of the spec is backwards compatible with it's predecessor then we can use semantic versioning  to ensure that clients on a given version of a spec in production will never be broken by an API change in production.
+
+#### But I want to break stuff
+
+Sometimes to make an omelette you have to break some eggs.
+
+Sometimes you need to make a breaking change to evolve an API.
+
+eg an endpoint needs a new required parameter, or an enum in a response needs a new value.
+
+These cases need to be handled VERY CAREFULLY. Lets take adding the enum value.
+
+ i) You add a new option to cooked_egg by adding "FRIED" to the existing enum ["POACHED","SCRAMBLED"]
+ ii) You run swagger diff on your new spec and it says
+
+ ```
+  BREAKING CHANGES:
+  =================
+  /a/:get->200 - Response Body: Added possible enumeration(s) <FRIED>  - array[BreakfastOrder].cooked_egg : string
+```
+ iii) You now have some choices:
+    a) revert, revert, revert - back off and not break the spec
+    b) create a new version of the spec in the server and start to migrate clients to that
+    c) do a managed migration
+ iv)  Let's assume you've decided VEWWWY VEWWWY CAREFUWWY migrate your change. Here's how that would work...
+
+ #### Migrating a breaking change
+
+ As before, same scenario.
+i) You add a new option to cooked_egg by adding "FRIED" to the existing enum ["POACHED","SCRAMBLED"]
+ii) You run swagger diff on your new spec and it complains as above.
+iii) You now generate a diff list using swagger diff -f json to produce a json formatted diff list.
+iv) You copy the breaking change you wish to ignore into a swagger_diff_ignore_file.json
+v) You ensure your build is configured to read this ignore file so now your build will no longer break.
+vi) VERY IMPORTANT: Now you must specifically put a temporary conditional check plus tests in the server to ensure you don't return this new enum value... YET. This gives you a chance to migrate clients to the version with the new enum value.
+vii) Deploy the change and then update the clients to use the new version (unless your clever build pipeline does that automatically because you use semantic versioning on your spec)
+viii) Once all clients have been updated (**and deployed**) you can remove the item from your ignore file and the code that blocks the server returning the new value.
+
+This type of change would be a nightmare if relying on after-the-event tests...
+
+ #### This may... or may not break a client
+
+What about a change that MAY break a client.
+
+eg returning a new success or error code response
+
+Will that break the client? It... depends. If the client has a firm set of responses it expects then perhaps, yes. New error repsonses are less likely to break the client as there are usually "Something unknown has gone sour" error handling to cope with that.
+
+However, new success messages, say a 201-CREATED instead of a plain 200-SUCCESS might get missed by a client expecting a 200 and only a 200 to indicate a successful call. In this case, use of the ```deprecated``` tag in the swagger spec can indicate that the server has an implendign change and a similar API migration strategy to the enum migration outlined above can be used.
+
+swagger diff is conservative in this regard, preferring to say something is breaking if it MAY block a client. You then have the option to use deprecated or the ignore file to temporarily manage the migration.
+
diff --git a/fixtures/diff/enum.diff.txt b/fixtures/diff/enum.diff.txt
new file mode 100644
index 00000000..7773896b
--- /dev/null
+++ b/fixtures/diff/enum.diff.txt
@@ -0,0 +1,14 @@
+NON-BREAKING CHANGES:
+            =====================
+            /a/:get -> 200 Response - array[A1].personality : string - Deleted possible enumeration(s) <crazy>
+            /a/:get Request - Query.personality - Added possible enumeration(s) <extrovert>
+            /a/{id}:get -> 200 Response - array[A1].personality : string - Deleted possible enumeration(s) <crazy>
+            /b/:get -> 200 Response - array[A1].personality : string - Deleted possible enumeration(s) <crazy>
+            
+            BREAKING CHANGES:
+            =================
+            /a/:get -> 200 Response - array[A1].personality : string - Added possible enumeration(s) <sane>
+            /a/:get Request - Query.personality - Deleted possible enumeration(s) <saucy>
+            /a/{id}:get -> 200 Response - array[A1].personality : string - Added possible enumeration(s) <sane>
+            /b/:get -> 200 Response - array[A1].personality : string - Added possible enumeration(s) <sane>
+            
\ No newline at end of file
diff --git a/fixtures/diff/enum.v1.json b/fixtures/diff/enum.v1.json
new file mode 100644
index 00000000..4f6bf3f8
--- /dev/null
+++ b/fixtures/diff/enum.v1.json
@@ -0,0 +1,166 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          },
+          {
+            "name": "personality",
+            "in": "query",
+            "required": false,
+            "type": "string",
+            "enum":["crazy","empathic","saucy"]
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "flavour",
+            "required": false,
+            "in": "query",
+            "type": "string"
+          },
+          {
+            "name": "id",
+            "in": "path",
+            "type": "string"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/b/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "personality":{ 
+            "type": "string",
+            "enum":["crazy","empathic","saucy"]
+          }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [ "name", "description" ],
+      "properties": {
+        "name": { "type": "string" },
+        "description": { "type": "string" }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "description": { "type": "string" },
+        "letters": {
+          "type": "array",
+          "items": { "type": "string" }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": { "type": "string" }
+        }
+      }
+    }
+  }
+}
diff --git a/fixtures/diff/enum.v2.json b/fixtures/diff/enum.v2.json
new file mode 100644
index 00000000..bd5e7e7d
--- /dev/null
+++ b/fixtures/diff/enum.v2.json
@@ -0,0 +1,167 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          },
+          {
+            "name": "personality",
+            "in": "query",
+            "required": false,
+            "type": "string",
+            "enum":["crazy","empathic","extrovert"]
+          }
+
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "flavour",
+            "required": false,
+            "in": "query",
+            "type": "string"
+          },
+          {
+            "name": "id",
+            "in": "path",
+            "type": "string"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/b/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "personality":{ 
+          "type": "string",
+          "enum":["empathic","saucy","sane"]
+        }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [ "name", "description" ],
+      "properties": {
+        "name": { "type": "string" },
+        "description": { "type": "string" }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "description": { "type": "string" },
+        "letters": {
+          "type": "array",
+          "items": { "type": "string" }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": { "type": "string" }
+        }
+      }
+    }
+  }
+}
diff --git a/fixtures/diff/ignoreDiffs.json b/fixtures/diff/ignoreDiffs.json
new file mode 100644
index 00000000..8c34b08f
--- /dev/null
+++ b/fixtures/diff/ignoreDiffs.json
@@ -0,0 +1,39 @@
+[
+  {
+    "location": {
+      "url": "/b/",
+      "method": "get",
+      "response": 200,
+      "node": {
+        "type": "A1",
+        "is_array": true,
+        "child": {
+          "name": "personality",
+          "type": "string"
+        }
+      }
+    },
+    "code": "AddedEnumValue",
+    "compatibility": "Breaking",
+    "info": "sane"
+  },
+  {
+    "location": {
+      "url": "/b/",
+      "method": "get",
+      "response": 200,
+      "node": {
+        "type": "A1",
+        "is_array": true,
+        "child": {
+          "name": "personality",
+          "type": "string"
+        }
+      }
+    },
+    "code": "DeletedEnumValue",
+    "compatibility": "NonBreaking",
+    "info": "crazy"
+  }
+]
+
diff --git a/fixtures/diff/ignoreFile.json b/fixtures/diff/ignoreFile.json
new file mode 100644
index 00000000..0842f65a
--- /dev/null
+++ b/fixtures/diff/ignoreFile.json
@@ -0,0 +1,104 @@
+[
+  {
+    "location": {
+      "url": "/a/",
+      "method": "get",
+      "node": {
+        "name": "Query",
+        "child": {
+          "name": "personality"
+        }
+      }
+    },
+    "code": "AddedEnumValue",
+    "compatibility": "NonBreaking",
+    "info": "extrovert"
+  },
+  {
+    "location": {
+      "url": "/a/",
+      "method": "get",
+      "node": {
+        "name": "Query",
+        "child": {
+          "name": "personality"
+        }
+      }
+    },
+    "code": "DeletedEnumValue",
+    "compatibility": "Breaking",
+    "info": "saucy"
+  },
+  {
+    "location": {
+      "url": "/a/",
+      "method": "get",
+      "response": 200,
+      "node": {
+        "type": "A1",
+        "is_array": true,
+        "child": {
+          "name": "personality",
+          "type": "string"
+        }
+      }
+    },
+    "code": "AddedEnumValue",
+    "compatibility": "Breaking",
+    "info": "sane"
+  },
+  {
+    "location": {
+      "url": "/a/",
+      "method": "get",
+      "response": 200,
+      "node": {
+        "type": "A1",
+        "is_array": true,
+        "child": {
+          "name": "personality",
+          "type": "string"
+        }
+      }
+    },
+    "code": "DeletedEnumValue",
+    "compatibility": "NonBreaking",
+    "info": "crazy"
+  },
+  {
+    "location": {
+      "url": "/a/{id}",
+      "method": "get",
+      "response": 200,
+      "node": {
+        "type": "A1",
+        "is_array": true,
+        "child": {
+          "name": "personality",
+          "type": "string"
+        }
+      }
+    },
+    "code": "AddedEnumValue",
+    "compatibility": "Breaking",
+    "info": "sane"
+  },
+  {
+    "location": {
+      "url": "/a/{id}",
+      "method": "get",
+      "response": 200,
+      "node": {
+        "type": "A1",
+        "is_array": true,
+        "child": {
+          "name": "personality",
+          "type": "string"
+        }
+      }
+    },
+    "code": "DeletedEnumValue",
+    "compatibility": "NonBreaking",
+    "info": "crazy"
+  }
+]
\ No newline at end of file
diff --git a/fixtures/diff/kitchensink.diff.txt b/fixtures/diff/kitchensink.diff.txt
new file mode 100644
index 00000000..44d035c8
--- /dev/null
+++ b/fixtures/diff/kitchensink.diff.txt
@@ -0,0 +1,27 @@
+NON-BREAKING CHANGES:
+            =====================
+             Metadata - Spec.consumes - Added a consumes format <bob>
+             Metadata - Spec.produces - Deleted produces format <bill>
+             Metadata - Spec.schemes - Added schemes <https>
+            /a/:get -> 200 Response- Added response
+            /a/:get Request - Header.addedHeaderParam : string - Added optional param
+            /a/:get Request - Header.deletedHeaderParam : string - Deleted optional param
+            /a/:get Request - Header.headerParam.headerParam : string - Widened type <string.password -> string>
+            /a/:get Request - Query.changeMaxInt - Widened type <Maximum 200.000000->300.000000>
+            /a/:get Request - Query.removeMaxInt - Widened type <Exclusive Maximum Removed:true->false>
+            /a/:get Request - Query.wideryString - Widened type <integer -> string>
+            
+            BREAKING CHANGES:
+            =================
+             Metadata - Spec Metadata - Changed base path </api -> /apibaby>
+             Metadata - Spec Metadata - Changed host URL <petstore.swagger.wordnik.com -> petstore.swaggery.wordnik.com>
+             Metadata - Spec.consumes - Deleted a consumes format <bill>
+             Metadata - Spec.produces - Added produces format <bob>
+             Metadata - Spec.schemes - Deleted schemes <http>
+            /a/:get Request - Query.ObjToPrim - Changed type <obj -> integer>
+            /a/:get Request - Query.changeMaxInt - Narrowed type <Exclusive Maximum Added:false->true>
+            /a/:get Request - Query.changeMinInt - Narrowed type <Exclusive Minimum Added:false->true>
+            /a/:get Request - Query.changeMinInt - Narrowed type <Minimum 200.000000->300.000000>
+            /a/:get Request - Query.changeyPattern - Changed type <Pattern Changed:*->anewpattern>
+            /a/:get Request - Query.primToObj : A2 - Changed type <integer -> obj>
+            
\ No newline at end of file
diff --git a/fixtures/diff/kitchensink.v1.json b/fixtures/diff/kitchensink.v1.json
new file mode 100644
index 00000000..6df1fc13
--- /dev/null
+++ b/fixtures/diff/kitchensink.v1.json
@@ -0,0 +1,297 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "host": "petstore.swagger.wordnik.com",
+  "basePath": "/api",
+  "schemes": [
+    "http"
+  ],
+  "consumes": [
+    "bill"
+  ],
+  "produces": [
+    "bill"
+  ],
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          },
+          {
+            "name": "headerParam",
+            "in": "header",
+            "schema":{
+              "type":"string",
+              "format":"password"
+            }
+          },
+          {
+            "name": "deletedHeaderParam",
+            "in": "header",
+            "schema":{
+              "type":"string",
+              "format":"password"
+            }
+          },
+          {
+            "name": "changeMaxInt",
+            "in": "query",
+            "required": false,
+            "type": "integer",
+            "maximum": 200,
+            "exclusiveMaximum": false
+          },
+          {
+            "name": "removeMaxInt",
+            "in": "query",
+            "required": false,
+            "type": "integer",
+            "maximum": 200,
+            "exclusiveMaximum": true
+          },
+          {
+            "name": "changeMinInt",
+            "in": "query",
+            "required": false,
+            "type": "integer",
+            "minimum": 200,
+            "exclusiveMinimum": false
+          },
+          {
+            "name": "wideryString",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          },
+          {
+            "name": "personality",
+            "in": "query",
+            "required": false,
+            "type": "string",
+            "enum": [
+              "crazy",
+              "empathic",
+              "saucy"
+            ]
+          },
+          {
+            "name": "changeyPattern",
+            "in": "query",
+            "required": false,
+            "type": "string",
+            "pattern": "*"
+          },
+          {
+            "name": "primToObj",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          },
+          {
+            "name": "ObjToPrim",
+            "in": "query",
+            "required": false,
+            "schema": {
+              "$ref": "#/definitions/A2"
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "headers":[
+              {"header1":{
+                "type":"integer"
+              }
+            }
+            ],
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/A1"
+              }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": {
+              "$ref": "#/definitions/A2"
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "$ref": "#/definitions/A3"
+            }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "flavour",
+            "required": false,
+            "in": "query",
+            "type": "string"
+          },
+          {
+            "name": "id",
+            "in": "path",
+            "type": "string"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/A1"
+              }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": {
+              "$ref": "#/definitions/A2"
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "$ref": "#/definitions/A3"
+            }
+          }
+        }
+      }
+    },
+    "/b/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/A1"
+              }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": {
+              "$ref": "#/definitions/A2"
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "$ref": "#/definitions/A3"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": {
+          "type": "integer"
+        },
+        "name": {
+          "type": "string"
+        },
+        "personality": {
+          "type": "string",
+          "enum": [
+            "crazy",
+            "empathic",
+            "saucy"
+          ]
+        }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [
+        "name",
+        "description"
+      ],
+      "properties": {
+        "name": {
+          "type": "string"
+        },
+        "description": {
+          "type": "string"
+        }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": {
+          "type": "integer"
+        },
+        "name": {
+          "type": "string"
+        },
+        "description": {
+          "type": "string"
+        },
+        "letters": {
+          "type": "array",
+          "items": {
+            "type": "string"
+          }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": {
+            "type": "string"
+          }
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/fixtures/diff/kitchensink.v2.json b/fixtures/diff/kitchensink.v2.json
new file mode 100644
index 00000000..8bf1c791
--- /dev/null
+++ b/fixtures/diff/kitchensink.v2.json
@@ -0,0 +1,290 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "host": "petstore.swaggery.wordnik.com",
+  "basePath": "/apibaby",
+  "schemes": [
+    "https"
+  ],
+  "consumes": [
+    "bob"
+  ],
+  "produces": [
+    "bob"
+  ],
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          },
+          {
+            "name": "headerParam",
+            "in": "header",
+            "schema": {
+              "type": "string"
+            }
+          },
+          {
+            "name": "addedHeaderParam",
+            "in": "header",
+            "schema": {
+              "type": "string",
+              "format": "password"
+            }
+          },
+          {
+            "name": "changeMaxInt",
+            "in": "query",
+            "required": false,
+            "type": "integer",
+            "maximum": 300,
+            "exclusiveMaximum": true
+          },
+          {
+            "name": "removeMaxInt",
+            "in": "query",
+            "required": false,
+            "type": "integer",
+            "maximum": 200,
+            "exclusiveMaximum": false
+          },
+          {
+            "name": "changeMinInt",
+            "in": "query",
+            "required": false,
+            "type": "integer",
+            "minimum": 300,
+            "exclusiveMinimum": true
+          },
+          {
+            "name": "wideryString",
+            "in": "query",
+            "required": false,
+            "type": "string"
+          },
+          {
+            "name": "personality",
+            "in": "query",
+            "required": false,
+            "type": "string",
+            "enum": [
+              "crazy",
+              "empathic",
+              "saucy"
+            ]
+          },
+          {
+            "name": "changeyPattern",
+            "in": "query",
+            "required": false,
+            "type": "string",
+            "pattern": "anewpattern"
+          },
+          {
+            "name": "primToObj",
+            "in": "query",
+            "required": false,
+            "schema": {
+              "$ref": "#/definitions/A2"
+            }
+          },
+          {
+            "name": "ObjToPrim",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/A1"
+              }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": {
+              "$ref": "#/definitions/A2"
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "$ref": "#/definitions/A3"
+            }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "flavour",
+            "required": false,
+            "in": "query",
+            "type": "string"
+          },
+          {
+            "name": "id",
+            "in": "path",
+            "type": "string"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/A1"
+              }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": {
+              "$ref": "#/definitions/A2"
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "$ref": "#/definitions/A3"
+            }
+          }
+        }
+      }
+    },
+    "/b/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/A1"
+              }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": {
+              "$ref": "#/definitions/A2"
+            }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "$ref": "#/definitions/A3"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": {
+          "type": "integer"
+        },
+        "name": {
+          "type": "string"
+        },
+        "personality": {
+          "type": "string",
+          "enum": [
+            "crazy",
+            "empathic",
+            "saucy"
+          ]
+        }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [
+        "name",
+        "description"
+      ],
+      "properties": {
+        "name": {
+          "type": "string"
+        },
+        "description": {
+          "type": "string"
+        }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": {
+          "type": "integer"
+        },
+        "name": {
+          "type": "string"
+        },
+        "description": {
+          "type": "string"
+        },
+        "letters": {
+          "type": "array",
+          "items": {
+            "type": "string"
+          }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": {
+            "type": "string"
+          }
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/fixtures/diff/param.diff.txt b/fixtures/diff/param.diff.txt
new file mode 100644
index 00000000..3d1a2b3a
--- /dev/null
+++ b/fixtures/diff/param.diff.txt
@@ -0,0 +1,21 @@
+NON-BREAKING CHANGES:
+            =====================
+            /a/:get Request - Query.limit - Deleted optional param
+            /a/{id}:get -> 200 Response - Headers.newResponseHeader - Added response header
+            /a/{id}:get Request - Query.newOptParam - Added optional param
+            /a/{id}:get Request - Query.widenedParam - Widened type <integer.int32 -> integer.int64>
+            /a/{id}:post Request - Header.newboris - Added optional param
+            /a/{id}:post Request - Header.optboris - Deleted optional param
+            /a/{id}:post Request - Header.reqdboris - Deleted required param
+            
+            BREAKING CHANGES:
+            =================
+            /a/:post -> 200 Response - otherDeletedName : string - Deleted property
+            /a/{id}:get -> 200 Response - Headers.optResponseHeader - Deleted response header
+            /a/{id}:get Request - Path.id - Narrowed type <string -> integer>
+            /a/{id}:get Request - Query.flavour - Changed optional param to required
+            /a/{id}:get Request - Query.newReqParam - Added required param
+            /a/{id}:post -> 200 Response - otherDeletedName : string - Deleted property
+            /a/{id}:post Request - Header.changedboris - Narrowed type <string -> integer>
+            /b/:post -> 200 Response - otherDeletedName : string - Deleted property
+            
\ No newline at end of file
diff --git a/fixtures/diff/param.v1.json b/fixtures/diff/param.v1.json
new file mode 100644
index 00000000..dcbcc063
--- /dev/null
+++ b/fixtures/diff/param.v1.json
@@ -0,0 +1,186 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "flavour",
+            "required": false,
+            "in": "query",
+            "type": "string"
+          },
+          {
+            "name": "widenedParam",
+            "in": "query",
+            "type": "integer",
+            "format":"int32"
+          },
+          {
+            "name": "id",
+            "in": "path",
+            "type": "string"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            },
+            "headers":{
+              "optResponseHeader":{
+                "schema":{ "type":"integer"}
+              }
+            }
+
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "reqdboris",
+            "in": "header",
+            "type":"string",
+            "required":true
+          },
+          {
+            "name": "optboris",
+            "in": "header",
+            "type":"string",
+            "required":false
+          },
+          {
+            "name": "changedboris",
+            "in": "header",
+            "type":"string",
+            "required":true
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/b/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [ "name", "description" ],
+      "properties": {
+        "name": { "type": "string" },
+        "description": { "type": "string" }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "otherDeletedName":{"type":"string","deprecated":true},
+        "description": { "type": "string" },
+        "letters": {
+          "type": "array",
+          "items": { "type": "string" }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": { "type": "string" }
+        }
+      }
+    }
+  }
+}
diff --git a/fixtures/diff/param.v2.json b/fixtures/diff/param.v2.json
new file mode 100644
index 00000000..7b75bf1a
--- /dev/null
+++ b/fixtures/diff/param.v2.json
@@ -0,0 +1,182 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "paths": {
+    "/a/": {
+      "get": {
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "flavour",
+            "required": true,
+            "in": "query",
+            "type": "string"
+          },
+          {
+            "name": "newReqParam",
+            "required": true,
+            "in": "query",
+            "type": "string"
+          },
+          {
+            "name": "newOptParam",
+            "in": "query",
+            "type": "string"
+          },
+          {
+            "name": "widenedParam",
+            "in": "query",
+            "type": "integer",
+            "format":"int64"
+          },
+          {
+            "name": "id",
+            "in": "path",
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            },
+            "headers":{
+              "newResponseHeader":{
+                "schema":{ "type":"integer"}
+              }
+            }
+
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "newboris",
+            "in": "header",
+            "type":"string",
+            "required":false
+          },
+          {
+            "name": "changedboris",
+            "in": "header",
+            "type":"integer",
+            "required":true
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/b/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [ "name", "description" ],
+      "properties": {
+        "name": { "type": "string" },
+        "description": { "type": "string" }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "description": { "type": "string" },
+        "letters": {
+          "type": "array",
+          "items": { "type": "string" }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": { "type": "string" }
+        }
+      }
+    }
+  }
+}
diff --git a/fixtures/diff/path.diff.txt b/fixtures/diff/path.diff.txt
new file mode 100644
index 00000000..b3ef7e0d
--- /dev/null
+++ b/fixtures/diff/path.diff.txt
@@ -0,0 +1,11 @@
+NON-BREAKING CHANGES:
+            =====================
+            /a/:put Request- Added endpoint
+            /a/{id}:post Request- Deleted a deprecated endpoint
+            /newpath/:post Request- Added endpoint
+            
+            BREAKING CHANGES:
+            =================
+            /a/:post Request- Deleted endpoint
+            /b/:post Request- Deleted endpoint
+            
\ No newline at end of file
diff --git a/fixtures/diff/path.v1.json b/fixtures/diff/path.v1.json
new file mode 100644
index 00000000..586f90cb
--- /dev/null
+++ b/fixtures/diff/path.v1.json
@@ -0,0 +1,317 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      },
+      "post": {
+        "deprecated": true,
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      },
+      "patch" : {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A4" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A6" }
+          }
+        }
+      },
+      "put" : {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/b/": {
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/B3" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A1" }
+          }
+        }
+      }
+    },
+    "/b/{id}": {
+      "put": {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/B1" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/B2" }
+          }
+        }
+      }
+    },
+    "/c/": {
+      "get": {
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/C1" }
+            }
+          },
+          "201": {
+            "description": "201 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/C1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/C2" }
+          }
+        ],
+        "responses": {
+          "204": {
+            "description": "204 response"
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [ "name", "description" ],
+      "properties": {
+        "name": { "type": "string" },
+        "description": { "type": "string" }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "description": { "type": "string" },
+        "letters": {
+          "type": "array",
+          "items": { "type": "string" }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": { "type": "string" }
+        }
+      }
+    },
+    "A4": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": ["string", "null"] },
+        "obj": { "$ref": "#/definitions/A5" },
+        "str": { "type": "string" }
+      }
+    },
+    "A5": {
+      "type": "object",
+      "properties": {
+        "thing": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A6": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "obj": { "$ref": "#/definitions/A5" },
+        "objs": { "type": "array",
+                  "items": { "$ref": "#/definitions/A5" }
+        },
+        "str": { "type": "string" }
+      }
+    },
+    "B1": {
+      "type": "object",
+      "allOf": [
+        { "$ref": "#/definitions/A2" },
+        {
+          "required": ["req"],
+          "properties": {
+            "req": { "type": "string" },
+            "opt": { "type": "string" }
+          }
+        }
+      ]
+    },
+    "B2": {
+      "type": "object",
+      "allOf": [
+        { "$ref": "#/definitions/A3" },
+        {
+          "properties": {
+            "key1": { "type": "integer" },
+            "key2": { "type": "string" }
+          }
+        }
+      ]
+    },
+    "B3": {
+      "type": "object",
+      "properties": {
+        "name": { "type": "string" }
+      }
+    },
+    "C1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "C2": {
+      "type": "object",
+      "properties": {
+        "existing": { "$ref": "#/definitions/C3" }
+      }
+    },
+    "C3": {
+      "type": "object",
+      "required": [ "a" ],
+      "properties": {
+        "a": { "type": "string" },
+        "b": { "type": "string" }
+      }
+    },
+    "C4": {
+      "type": "object",
+      "required": [ "a", "b" ],
+      "properties": {
+        "a": { "type": "string" },
+        "b": { "type": "string" }
+      }
+    }
+  }
+}
diff --git a/fixtures/diff/path.v2.json b/fixtures/diff/path.v2.json
new file mode 100644
index 00000000..6bf4dd21
--- /dev/null
+++ b/fixtures/diff/path.v2.json
@@ -0,0 +1,300 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "put": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      },
+      "patch" : {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A4" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A6" }
+          }
+        }
+      },
+      "put" : {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/newpath/": {
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/B3" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A1" }
+          }
+        }
+      }
+    },
+    "/b/{id}": {
+      "put": {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/B1" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/B2" }
+          }
+        }
+      }
+    },
+    "/c/": {
+      "get": {
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/C1" }
+            }
+          },
+          "201": {
+            "description": "201 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/C1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/C2" }
+          }
+        ],
+        "responses": {
+          "204": {
+            "description": "204 response"
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [ "name", "description" ],
+      "properties": {
+        "name": { "type": "string" },
+        "description": { "type": "string" }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "description": { "type": "string" },
+        "letters": {
+          "type": "array",
+          "items": { "type": "string" }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": { "type": "string" }
+        }
+      }
+    },
+    "A4": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": ["string", "null"] },
+        "obj": { "$ref": "#/definitions/A5" },
+        "str": { "type": "string" }
+      }
+    },
+    "A5": {
+      "type": "object",
+      "properties": {
+        "thing": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A6": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "obj": { "$ref": "#/definitions/A5" },
+        "objs": { "type": "array",
+                  "items": { "$ref": "#/definitions/A5" }
+        },
+        "str": { "type": "string" }
+      }
+    },
+    "B1": {
+      "type": "object",
+      "allOf": [
+        { "$ref": "#/definitions/A2" },
+        {
+          "required": ["req"],
+          "properties": {
+            "req": { "type": "string" },
+            "opt": { "type": "string" }
+          }
+        }
+      ]
+    },
+    "B2": {
+      "type": "object",
+      "allOf": [
+        { "$ref": "#/definitions/A3" },
+        {
+          "properties": {
+            "key1": { "type": "integer" },
+            "key2": { "type": "string" }
+          }
+        }
+      ]
+    },
+    "B3": {
+      "type": "object",
+      "properties": {
+        "name": { "type": "string" }
+      }
+    },
+    "C1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "C2": {
+      "type": "object",
+      "properties": {
+        "existing": { "$ref": "#/definitions/C3" }
+      }
+    },
+    "C3": {
+      "type": "object",
+      "required": [ "a" ],
+      "properties": {
+        "a": { "type": "string" },
+        "b": { "type": "string" }
+      }
+    },
+    "C4": {
+      "type": "object",
+      "required": [ "a", "b" ],
+      "properties": {
+        "a": { "type": "string" },
+        "b": { "type": "string" }
+      }
+    }
+  }
+}
diff --git a/fixtures/diff/response.diff.txt b/fixtures/diff/response.diff.txt
new file mode 100644
index 00000000..e956f99a
--- /dev/null
+++ b/fixtures/diff/response.diff.txt
@@ -0,0 +1,12 @@
+NON-BREAKING CHANGES:
+            =====================
+            /a/:get -> 201 Response- Added response
+            /a/:put -> 200 Response - colour : string - Added property
+            /a/:put -> 200 Response - description : string - Narrowed type <string -> integer.int32>
+            /a/{id}:get -> 200 Response - colour : string - Added property
+            /a/{id}:get -> 200 Response - description : string - Narrowed type <string -> integer.int32>
+            
+            BREAKING CHANGES:
+            =================
+            /a/:get -> 200 Response- Deleted response
+            
\ No newline at end of file
diff --git a/fixtures/diff/response.v1.json b/fixtures/diff/response.v1.json
new file mode 100644
index 00000000..8d10b4e2
--- /dev/null
+++ b/fixtures/diff/response.v1.json
@@ -0,0 +1,256 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "put": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      },
+      "patch" : {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A4" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A6" }
+          }
+        }
+      }
+    },
+    "/newpath/": {
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/B3" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A1" }
+          }
+        }
+      }
+    },
+    "/c/": {
+      "get": {
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/C1" }
+            }
+          },
+          "201": {
+            "description": "201 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/C1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/C2" }
+          }
+        ],
+        "responses": {
+          "204": {
+            "description": "204 response"
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [ "name", "description" ],
+      "properties": {
+        "name": { "type": "string" },
+        "description": { "type": "string" }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "description": { "type": "string" },
+        "letters": {
+          "type": "array",
+          "items": { "type": "string" }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": { "type": "string" }
+        }
+      }
+    },
+    "A4": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": ["string", "null"] },
+        "obj": { "$ref": "#/definitions/A5" },
+        "str": { "type": "string" }
+      }
+    },
+    "A5": {
+      "type": "object",
+      "properties": {
+        "thing": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A6": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "obj": { "$ref": "#/definitions/A5" },
+        "objs": { "type": "array",
+                  "items": { "$ref": "#/definitions/A5" }
+        },
+        "str": { "type": "string" }
+      }
+    },
+    "B1": {
+      "type": "object",
+      "allOf": [
+        { "$ref": "#/definitions/A2" },
+        {
+          "required": ["req"],
+          "properties": {
+            "req": { "type": "string" },
+            "opt": { "type": "string" }
+          }
+        }
+      ]
+    },
+    "B2": {
+      "type": "object",
+      "allOf": [
+        { "$ref": "#/definitions/A3" },
+        {
+          "properties": {
+            "key1": { "type": "integer" },
+            "key2": { "type": "string" }
+          }
+        }
+      ]
+    },
+    "B3": {
+      "type": "object",
+      "properties": {
+        "name": { "type": "string" }
+      }
+    },
+    "C1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "C2": {
+      "type": "object",
+      "properties": {
+        "existing": { "$ref": "#/definitions/C3" }
+      }
+    },
+    "C3": {
+      "type": "object",
+      "required": [ "a" ],
+      "properties": {
+        "a": { "type": "string" },
+        "b": { "type": "string" }
+      }
+    },
+    "C4": {
+      "type": "object",
+      "required": [ "a", "b" ],
+      "properties": {
+        "a": { "type": "string" },
+        "b": { "type": "string" }
+      }
+    }
+  }
+}
diff --git a/fixtures/diff/response.v2.json b/fixtures/diff/response.v2.json
new file mode 100644
index 00000000..0a1ed797
--- /dev/null
+++ b/fixtures/diff/response.v2.json
@@ -0,0 +1,257 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Swagger Fixture",
+    "version": "1.0"
+  },
+  "paths": {
+    "/a/": {
+      "get": {
+        "parameters": [
+          {
+            "name": "limit",
+            "in": "query",
+            "required": false,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "201": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/A1" }
+            }
+          }
+        }
+      },
+      "put": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A2" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      }
+    },
+    "/a/{id}": {
+      "get": {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A3" }
+          }
+        }
+      },
+      "patch" : {
+        "parameters": [
+          {
+            "name": "id",
+            "in": "path",
+            "required": true,
+            "type": "integer"
+          },
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/A4" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A6" }
+          }
+        }
+      }
+    },
+    "/newpath/": {
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/B3" }
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": { "$ref": "#/definitions/A1" }
+          }
+        }
+      }
+    },
+    "/c/": {
+      "get": {
+        "responses": {
+          "200": {
+            "description": "200 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/C1" }
+            }
+          },
+          "201": {
+            "description": "201 response",
+            "schema": {
+              "type": "array",
+              "items": { "$ref": "#/definitions/C1" }
+            }
+          }
+        }
+      },
+      "post": {
+        "parameters": [
+          {
+            "name": "",
+            "in": "body",
+            "schema": { "$ref": "#/definitions/C2" }
+          }
+        ],
+        "responses": {
+          "204": {
+            "description": "204 response"
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A2": {
+      "type": "object",
+      "required": [ "name", "description" ],
+      "properties": {
+        "name": { "type": "string" },
+        "description": { "type": "string" }
+      }
+    },
+    "A3": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "description": { "type": "integer", "format": "int32" },
+        "colour":{"type": "string"},
+        "letters": {
+          "type": "array",
+          "items": { "type": "string" }
+        },
+        "attributes": {
+          "type": "object",
+          "additionalProperties": { "type": "string" }
+        }
+      }
+    },
+    "A4": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": ["string", "null"] },
+        "obj": { "$ref": "#/definitions/A5" },
+        "str": { "type": "string" }
+      }
+    },
+    "A5": {
+      "type": "object",
+      "properties": {
+        "thing": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "A6": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" },
+        "obj": { "$ref": "#/definitions/A5" },
+        "objs": { "type": "array",
+                  "items": { "$ref": "#/definitions/A5" }
+        },
+        "str": { "type": "string" }
+      }
+    },
+    "B1": {
+      "type": "object",
+      "allOf": [
+        { "$ref": "#/definitions/A2" },
+        {
+          "required": ["req"],
+          "properties": {
+            "req": { "type": "string" },
+            "opt": { "type": "string" }
+          }
+        }
+      ]
+    },
+    "B2": {
+      "type": "object",
+      "allOf": [
+        { "$ref": "#/definitions/A4" },
+        {
+          "properties": {
+            "key1": { "type": "integer" },
+            "key2": { "type": "string" }
+          }
+        }
+      ]
+    },
+    "B3": {
+      "type": "object",
+      "properties": {
+        "name": { "type": "string" }
+      }
+    },
+    "C1": {
+      "type": "object",
+      "properties": {
+        "id": { "type": "integer" },
+        "name": { "type": "string" }
+      }
+    },
+    "C2": {
+      "type": "object",
+      "properties": {
+        "existing": { "$ref": "#/definitions/C3" }
+      }
+    },
+    "C3": {
+      "type": "object",
+      "required": [ "a" ],
+      "properties": {
+        "a": { "type": "string" },
+        "b": { "type": "string" }
+      }
+    },
+    "C4": {
+      "type": "object",
+      "required": [ "a", "b" ],
+      "properties": {
+        "a": { "type": "string" },
+        "b": { "type": "string" }
+      }
+    }
+  }
+}
diff --git a/fixtures/diff/uber.diff.txt b/fixtures/diff/uber.diff.txt
new file mode 100644
index 00000000..9b89651f
--- /dev/null
+++ b/fixtures/diff/uber.diff.txt
@@ -0,0 +1,8 @@
+NON-BREAKING CHANGES:
+            =====================
+             Metadata - Spec Metadata - Changed a description <Move your app forward with the Uber API -> Move your app forward with the Uber API with description change>
+            /estimates/price:get Request- Added a tag <A new tag>
+            /estimates/price:get Request- Deleted a tag <DeadTagWalking>
+            /products:get Request - latitude - Deleted a description
+            /products:get Request- Deleted a description
+           
\ No newline at end of file
diff --git a/fixtures/diff/uber.v1.json b/fixtures/diff/uber.v1.json
new file mode 100644
index 00000000..7d17be12
--- /dev/null
+++ b/fixtures/diff/uber.v1.json
@@ -0,0 +1,370 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Uber API",
+    "description": "Move your app forward with the Uber API",
+    "version": "1.0.0"
+  },
+  "host": "api.uber.com",
+  "schemes": [
+    "https"
+  ],
+  "basePath": "/v1",
+  "produces": [
+    "application/json"
+  ],
+  "paths": {
+    "/products": {
+      "get": {
+        "summary": "Product Types",
+        "description": "The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product, and lists the products in the proper display order.",
+        "parameters": [
+          {
+            "name": "latitude",
+            "in": "query",
+            "description": "Latitude component of location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "longitude",
+            "in": "query",
+            "description": "Longitude component of location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          }
+        ],
+        "tags": [
+          "Products"
+        ],
+        "responses": {
+          "200": {
+            "description": "An array of products",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/Product"
+              }
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    },
+    "/estimates/price": {
+      "get": {
+        "summary": "Price Estimates",
+        "description": "The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.<br><br>The response also includes low and high estimates, and the [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code for situations requiring currency conversion. When surge is active for a particular product, its surge_multiplier will be greater than 1, but the price estimate already factors in this multiplier.",
+        "parameters": [
+          {
+            "name": "start_latitude",
+            "in": "query",
+            "description": "Latitude component of start location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "start_longitude",
+            "in": "query",
+            "description": "Longitude component of start location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "end_latitude",
+            "in": "query",
+            "description": "Latitude component of end location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "end_longitude",
+            "in": "query",
+            "description": "Longitude component of end location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          }
+        ],
+        "tags": [
+          "Estimates", "DeadTagWalking"
+        ],
+        "responses": {
+          "200": {
+            "description": "An array of price estimates by product",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/PriceEstimate"
+              }
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    },
+    "/estimates/time": {
+      "get": {
+        "summary": "Time Estimates",
+        "description": "The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.",
+        "parameters": [
+          {
+            "name": "start_latitude",
+            "in": "query",
+            "description": "Latitude component of start location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "start_longitude",
+            "in": "query",
+            "description": "Longitude component of start location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "customer_uuid",
+            "in": "query",
+            "type": "string",
+            "format": "uuid",
+            "description": "Unique customer identifier to be used for experience customization."
+          },
+          {
+            "name": "product_id",
+            "in": "query",
+            "type": "string",
+            "description": "Unique identifier representing a specific product for a given latitude & longitude."
+          }
+        ],
+        "tags": [
+          "Estimates"
+        ],
+        "responses": {
+          "200": {
+            "description": "An array of products",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/Product"
+              }
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    },
+    "/me": {
+      "get": {
+        "summary": "User Profile",
+        "description": "The User Profile endpoint returns information about the Uber user that has authorized with the application.",
+        "tags": [
+          "User"
+        ],
+        "responses": {
+          "200": {
+            "description": "Profile information for a user",
+            "schema": {
+              "$ref": "#/definitions/Profile"
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    },
+    "/history": {
+      "get": {
+        "summary": "User Activity",
+        "description": "The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.<br><br>The history array in the response will have a maximum length based on the limit parameter. The response value count may exceed limit, therefore subsequent API requests may be necessary.",
+        "parameters": [
+          {
+            "name": "offset",
+            "in": "query",
+            "type": "integer",
+            "format": "int32",
+            "description": "Offset the list of returned results by this amount. Default is zero."
+          },
+          {
+            "name": "limit",
+            "in": "query",
+            "type": "integer",
+            "format": "int32",
+            "description": "Number of items to retrieve. Default is 5, maximum is 100."
+          }
+        ],
+        "tags": [
+          "User"
+        ],
+        "responses": {
+          "200": {
+            "description": "History information for the given user",
+            "schema": {
+              "$ref": "#/definitions/Activities"
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "Product": {
+      "properties": {
+        "product_id": {
+          "type": "string",
+          "description": "Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles."
+        },
+        "description": {
+          "type": "string",
+          "description": "Description of product."
+        },
+        "display_name": {
+          "type": "string",
+          "description": "Display name of product."
+        },
+        "capacity": {
+          "type": "string",
+          "description": "Capacity of product. For example, 4 people."
+        },
+        "image": {
+          "type": "string",
+          "description": "Image URL representing the product."
+        }
+      }
+    },
+    "PriceEstimate": {
+      "properties": {
+        "product_id": {
+          "type": "string",
+          "description": "Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles"
+        },
+        "currency_code": {
+          "type": "string",
+          "description": "[ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code."
+        },
+        "display_name": {
+          "type": "string",
+          "description": "Display name of product."
+        },
+        "estimate": {
+          "type": "string",
+          "description": "Formatted string of estimate in local currency of the start location. Estimate could be a range, a single number (flat rate) or \"Metered\" for TAXI."
+        },
+        "low_estimate": {
+          "type": "number",
+          "description": "Lower bound of the estimated price."
+        },
+        "high_estimate": {
+          "type": "number",
+          "description": "Upper bound of the estimated price."
+        },
+        "surge_multiplier": {
+          "type": "number",
+          "description": "Expected surge multiplier. Surge is active if surge_multiplier is greater than 1. Price estimate already factors in the surge multiplier."
+        }
+      }
+    },
+    "Profile": {
+      "properties": {
+        "first_name": {
+          "type": "string",
+          "description": "First name of the Uber user."
+        },
+        "last_name": {
+          "type": "string",
+          "description": "Last name of the Uber user."
+        },
+        "email": {
+          "type": "string",
+          "description": "Email address of the Uber user"
+        },
+        "picture": {
+          "type": "string",
+          "description": "Image URL of the Uber user."
+        },
+        "promo_code": {
+          "type": "string",
+          "description": "Promo code of the Uber user."
+        }
+      }
+    },
+    "Activity": {
+      "properties": {
+        "uuid": {
+          "type": "string",
+          "description": "Unique identifier for the activity"
+        }
+      }
+    },
+    "Activities": {
+      "properties": {
+        "offset": {
+          "type": "integer",
+          "format": "int32",
+          "description": "Position in pagination."
+        },
+        "limit": {
+          "type": "integer",
+          "format": "int32",
+          "description": "Number of items to retrieve (100 max)."
+        },
+        "count": {
+          "type": "integer",
+          "format": "int32",
+          "description": "Total number of items available."
+        },
+        "history": {
+          "type": "array",
+          "items": {
+              "$ref": "#/definitions/Activity"
+           }
+        }
+      }
+    },
+    "Error": {
+      "properties": {
+        "code": {
+          "type": "integer",
+          "format": "int32"
+        },
+        "message": {
+          "type": "string"
+        },
+        "fields": {
+          "type": "string"
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/fixtures/diff/uber.v2.json b/fixtures/diff/uber.v2.json
new file mode 100644
index 00000000..e3a1778a
--- /dev/null
+++ b/fixtures/diff/uber.v2.json
@@ -0,0 +1,370 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "Uber API",
+    "description": "Move your app forward with the Uber API with description change",
+    "version": "1.0.0"
+  },
+  "host": "api.uber.com",
+  "schemes": [
+    "https"
+  ],
+  "basePath": "/v1",
+  "produces": [
+    "application/json"
+  ],
+  "paths": {
+    "/products": {
+      "get": {
+        "summary": "Product Types",
+        "description": "The Products endpoint returns information about the Uber products offered at a given location. The response includes the display name and other details about each product.",
+        "parameters": [
+          {
+            "name": "latitude",
+            "in": "query",
+            "description": "Latitude component of location with addition.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "longitude",
+            "in": "query",
+            "description": "Longitude component of location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          }
+        ],
+        "tags": [
+          "Products"
+        ],
+        "responses": {
+          "200": {
+            "description": "An array of products",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/Product"
+              }
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    },
+    "/estimates/price": {
+      "get": {
+        "summary": "Price Estimates",
+        "description": "The Price Estimates endpoint returns an estimated price range for each product offered at a given location. The price estimate is provided as a formatted string with the full price range and the localized currency symbol.<br><br>The response also includes low and high estimates, and the [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code for situations requiring currency conversion. When surge is active for a particular product, its surge_multiplier will be greater than 1, but the price estimate already factors in this multiplier.",
+        "parameters": [
+          {
+            "name": "start_latitude",
+            "in": "query",
+            "description": "Latitude component of start location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "start_longitude",
+            "in": "query",
+            "description": "Longitude component of start location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "end_latitude",
+            "in": "query",
+            "description": "Latitude component of end location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "end_longitude",
+            "in": "query",
+            "description": "Longitude component of end location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          }
+        ],
+        "tags": [
+          "Estimates","A new tag"
+        ],
+        "responses": {
+          "200": {
+            "description": "An array of price estimates by product",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/PriceEstimate"
+              }
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    },
+    "/estimates/time": {
+      "get": {
+        "summary": "Time Estimates",
+        "description": "The Time Estimates endpoint returns ETAs for all products offered at a given location, with the responses expressed as integers in seconds. We recommend that this endpoint be called every minute to provide the most accurate, up-to-date ETAs.",
+        "parameters": [
+          {
+            "name": "start_latitude",
+            "in": "query",
+            "description": "Latitude component of start location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "start_longitude",
+            "in": "query",
+            "description": "Longitude component of start location.",
+            "required": true,
+            "type": "number",
+            "format": "double"
+          },
+          {
+            "name": "customer_uuid",
+            "in": "query",
+            "type": "string",
+            "format": "uuid",
+            "description": "Unique customer identifier to be used for experience customization."
+          },
+          {
+            "name": "product_id",
+            "in": "query",
+            "type": "string",
+            "description": "Unique identifier representing a specific product for a given latitude & longitude."
+          }
+        ],
+        "tags": [
+          "Estimates"
+        ],
+        "responses": {
+          "200": {
+            "description": "An array of products",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "#/definitions/Product"
+              }
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    },
+    "/me": {
+      "get": {
+        "summary": "User Profile",
+        "description": "The User Profile endpoint returns information about the Uber user that has authorized with the application.",
+        "tags": [
+          "User"
+        ],
+        "responses": {
+          "200": {
+            "description": "Profile information for a user",
+            "schema": {
+              "$ref": "#/definitions/Profile"
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    },
+    "/history": {
+      "get": {
+        "summary": "User Activity",
+        "description": "The User Activity endpoint returns data about a user's lifetime activity with Uber. The response will include pickup locations and times, dropoff locations and times, the distance of past requests, and information about which products were requested.<br><br>The history array in the response will have a maximum length based on the limit parameter. The response value count may exceed limit, therefore subsequent API requests may be necessary.",
+        "parameters": [
+          {
+            "name": "offset",
+            "in": "query",
+            "type": "integer",
+            "format": "int32",
+            "description": "Offset the list of returned results by this amount. Default is zero."
+          },
+          {
+            "name": "limit",
+            "in": "query",
+            "type": "integer",
+            "format": "int32",
+            "description": "Number of items to retrieve. Default is 5, maximum is 100."
+          }
+        ],
+        "tags": [
+          "User"
+        ],
+        "responses": {
+          "200": {
+            "description": "History information for the given user",
+            "schema": {
+              "$ref": "#/definitions/Activities"
+            }
+          },
+          "default": {
+            "description": "Unexpected error",
+            "schema": {
+              "$ref": "#/definitions/Error"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "Product": {
+      "properties": {
+        "product_id": {
+          "type": "string",
+          "description": "Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles."
+        },
+        "description": {
+          "type": "string",
+          "description": "Description of product."
+        },
+        "display_name": {
+          "type": "string",
+          "description": "Display name of product."
+        },
+        "capacity": {
+          "type": "string",
+          "description": "Capacity of product. For example, 4 people."
+        },
+        "image": {
+          "type": "string",
+          "description": "Image URL representing the product."
+        }
+      }
+    },
+    "PriceEstimate": {
+      "properties": {
+        "product_id": {
+          "type": "string",
+          "description": "Unique identifier representing a specific product for a given latitude & longitude. For example, uberX in San Francisco will have a different product_id than uberX in Los Angeles"
+        },
+        "currency_code": {
+          "type": "string",
+          "description": "[ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code."
+        },
+        "display_name": {
+          "type": "string",
+          "description": "Display name of product."
+        },
+        "estimate": {
+          "type": "string",
+          "description": "Formatted string of estimate in local currency of the start location. Estimate could be a range, a single number (flat rate) or \"Metered\" for TAXI."
+        },
+        "low_estimate": {
+          "type": "number",
+          "description": "Lower bound of the estimated price."
+        },
+        "high_estimate": {
+          "type": "number",
+          "description": "Upper bound of the estimated price."
+        },
+        "surge_multiplier": {
+          "type": "number",
+          "description": "Expected surge multiplier. Surge is active if surge_multiplier is greater than 1. Price estimate already factors in the surge multiplier."
+        }
+      }
+    },
+    "Profile": {
+      "properties": {
+        "first_name": {
+          "type": "string",
+          "description": "First name of the Uber user."
+        },
+        "last_name": {
+          "type": "string",
+          "description": "Last name of the Uber user."
+        },
+        "email": {
+          "type": "string",
+          "description": "Email address of the Uber user"
+        },
+        "picture": {
+          "type": "string",
+          "description": "Image URL of the Uber user."
+        },
+        "promo_code": {
+          "type": "string",
+          "description": "Promo code of the Uber user."
+        }
+      }
+    },
+    "Activity": {
+      "properties": {
+        "uuid": {
+          "type": "string",
+          "description": "Unique identifier for the activity"
+        }
+      }
+    },
+    "Activities": {
+      "properties": {
+        "offset": {
+          "type": "integer",
+          "format": "int32",
+          "description": "Position in pagination."
+        },
+        "limit": {
+          "type": "integer",
+          "format": "int32",
+          "description": "Number of items to retrieve (100 max)."
+        },
+        "count": {
+          "type": "integer",
+          "format": "int32",
+          "description": "Total number of items available."
+        },
+        "history": {
+          "type": "array",
+          "items": {
+              "$ref": "#/definitions/Activity"
+           }
+        }
+      }
+    },
+    "Error": {
+      "properties": {
+        "code": {
+          "type": "integer",
+          "format": "int32"
+        },
+        "message": {
+          "type": "string"
+        },
+        "fields": {
+          "type": "string"
+        }
+      }
+    }
+  }
+}
\ No newline at end of file
diff --git a/go.mod b/go.mod
index 4d9e2ff1..53a781bd 100644
--- a/go.mod
+++ b/go.mod
@@ -5,15 +5,23 @@ go 1.12
 replace github.com/golang/lint => golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3
 
 require (
-	github.com/BurntSushi/toml v0.3.1 // indirect
+	cloud.google.com/go v0.39.0 // indirect
+	github.com/OneOfOne/xxhash v1.2.5 // indirect
+	github.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a // indirect
+	github.com/corbym/gocrest v1.0.3
+	github.com/coreos/etcd v3.3.13+incompatible // indirect
+	github.com/coreos/go-etcd v2.0.0+incompatible // indirect
 	github.com/coreos/go-oidc v2.0.0+incompatible
+	github.com/coreos/go-semver v0.3.0 // indirect
 	github.com/davecgh/go-spew v1.1.1
 	github.com/dgrijalva/jwt-go v3.2.0+incompatible
+	github.com/dgryski/go-sip13 v0.0.0-20190329191031-25c5027a8c7b // indirect
+	github.com/docker/go-units v0.4.0 // indirect
 	github.com/go-openapi/analysis v0.19.0
 	github.com/go-openapi/errors v0.19.0
 	github.com/go-openapi/inflect v0.19.0
-	github.com/go-openapi/jsonpointer v0.19.0 // indirect
-	github.com/go-openapi/jsonreference v0.19.0 // indirect
+	github.com/go-openapi/jsonpointer v0.19.0
+	github.com/go-openapi/jsonreference v0.19.0
 	github.com/go-openapi/loads v0.19.0
 	github.com/go-openapi/runtime v0.19.0
 	github.com/go-openapi/spec v0.19.0
@@ -21,23 +29,47 @@ require (
 	github.com/go-openapi/swag v0.19.0
 	github.com/go-openapi/validate v0.19.0
 	github.com/go-swagger/scan-repo-boundary v0.0.0-20180623220736-973b3573c013
-	github.com/golang/protobuf v1.3.1 // indirect
+	github.com/golang/mock v1.3.1 // indirect
+	github.com/google/pprof v0.0.0-20190515194954-54271f7e092f // indirect
 	github.com/gorilla/handlers v1.4.0
 	github.com/jessevdk/go-flags v1.4.0
+	github.com/kisielk/errcheck v1.2.0 // indirect
+	github.com/konsorten/go-windows-terminal-sequences v1.0.2 // indirect
 	github.com/kr/pretty v0.1.0
+	github.com/kr/pty v1.1.4 // indirect
+	github.com/magiconair/properties v1.8.1 // indirect
+	github.com/mailru/easyjson v0.0.0-20190403194419-1ea4449da983 // indirect
+	github.com/pelletier/go-toml v1.4.0 // indirect
+	github.com/pkg/errors v0.8.1 // indirect
 	github.com/pquerna/cachecontrol v0.0.0-20180517163645-1555304b9b35 // indirect
-	github.com/spf13/afero v1.2.1 // indirect
+	github.com/prometheus/common v0.4.1 // indirect
+	github.com/prometheus/procfs v0.0.1 // indirect
+	github.com/prometheus/tsdb v0.8.0 // indirect
+	github.com/rogpeppe/fastuuid v1.1.0 // indirect
+	github.com/sirupsen/logrus v1.4.2 // indirect
+	github.com/spaolacci/murmur3 v1.1.0 // indirect
+	github.com/spf13/afero v1.2.2 // indirect
 	github.com/spf13/jwalterweatherman v1.1.0 // indirect
 	github.com/spf13/pflag v1.0.3
-	github.com/spf13/viper v1.3.2
+	github.com/spf13/viper v1.4.0
+	github.com/stretchr/objx v0.2.0 // indirect
 	github.com/stretchr/testify v1.3.0
 	github.com/toqueteos/webbrowser v1.1.0
-	golang.org/x/net v0.0.0-20190322120337-addf6b3196f6
-	golang.org/x/oauth2 v0.0.0-20190319182350-c85d3e98c914
-	golang.org/x/sys v0.0.0-20190322080309-f49334f85ddc // indirect
-	golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2 // indirect
-	golang.org/x/tools v0.0.0-20190322203728-c1a832b0ad89
-	google.golang.org/appengine v1.5.0 // indirect
-	gopkg.in/square/go-jose.v2 v2.3.0 // indirect
+	github.com/ugorji/go v1.1.5-pre // indirect
+	go.opencensus.io v0.22.0 // indirect
+	golang.org/x/crypto v0.0.0-20190530122614-20be4c3c3ed5 // indirect
+	golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522 // indirect
+	golang.org/x/image v0.0.0-20190523035834-f03afa92d3ff // indirect
+	golang.org/x/lint v0.0.0-20190409202823-959b441ac422 // indirect
+	golang.org/x/mobile v0.0.0-20190509164839-32b2708ab171 // indirect
+	golang.org/x/mod v0.1.0 // indirect
+	golang.org/x/net v0.0.0-20190522155817-f3200d17e092
+	golang.org/x/oauth2 v0.0.0-20190523182746-aaccbc9213b0
+	golang.org/x/sys v0.0.0-20190602015325-4c4f7f33c9ed // indirect
+	golang.org/x/tools v0.0.0-20190602112858-2de7f9bf822c
+	google.golang.org/appengine v1.6.0 // indirect
+	google.golang.org/genproto v0.0.0-20190530194941-fb225487d101 // indirect
+	gopkg.in/square/go-jose.v2 v2.3.1 // indirect
 	gopkg.in/yaml.v2 v2.2.2
+	honnef.co/go/tools v0.0.0-20190602125119-5a4a2f4a438d // indirect
 )
diff --git a/go.sum b/go.sum
index b97325dd..59a4cf66 100644
--- a/go.sum
+++ b/go.sum
@@ -1,31 +1,59 @@
+cloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
 cloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=
+cloud.google.com/go v0.39.0/go.mod h1:rVLT6fkc8chs9sfPtFc1SBH6em7n+ZoXaG+87tDISts=
 github.com/BurntSushi/toml v0.3.1 h1:WXkYYl6Yr3qBf1K79EBnL4mak0OimBfB0XUf9Vl28OQ=
 github.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=
+github.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=
+github.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=
+github.com/OneOfOne/xxhash v1.2.5/go.mod h1:eZbhyaAYD41SGSSsnmcpxVoRiQ/MPUTjUdIIOT9Um7Q=
 github.com/PuerkitoBio/purell v1.1.0/go.mod h1:c11w/QuzBsJSee3cPx9rAFu61PvFxuPbtSwDGJws/X0=
 github.com/PuerkitoBio/purell v1.1.1 h1:WEQqlqaGbrPkxLJWfBwQmfEAE1Z7ONdDLqrN38tNFfI=
 github.com/PuerkitoBio/purell v1.1.1/go.mod h1:c11w/QuzBsJSee3cPx9rAFu61PvFxuPbtSwDGJws/X0=
 github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 h1:d+Bc7a5rLufV/sSk/8dngufqelfh6jnri85riMAaF/M=
 github.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578/go.mod h1:uGdkoq3SwY9Y+13GIhn11/XLaGBb4BfwItxLd5jeuXE=
+github.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=
+github.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=
 github.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=
 github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf h1:eg0MeVzsP1G42dRafH3vf+al2vQIJU0YHX+1Tw87oco=
 github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=
+github.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a h1:idn718Q4B6AGu/h5Sxe66HYVdqdGu2l9Iebqhi/AEoA=
+github.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=
+github.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=
+github.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=
+github.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=
+github.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=
+github.com/corbym/gocrest v1.0.3 h1:gwEdq6RkTmq+09CTuM29DfKOCtZ7G7bcyxs3IZ6EVdU=
+github.com/corbym/gocrest v1.0.3/go.mod h1:maVFL5lbdS2PgfOQgGRWDYTeunSWQeiEgoNdTABShCs=
+github.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=
 github.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
+github.com/coreos/etcd v3.3.13+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=
 github.com/coreos/go-etcd v2.0.0+incompatible/go.mod h1:Jez6KQU2B/sWsbdaef3ED8NzMklzPG4d5KIOhIy30Tk=
 github.com/coreos/go-oidc v2.0.0+incompatible h1:+RStIopZ8wooMx+Vs5Bt8zMXxV1ABl5LbakNExNmZIg=
 github.com/coreos/go-oidc v2.0.0+incompatible/go.mod h1:CgnwVTmzoESiwO9qyAFEMiHoZ1nMCKZlZ9V6mm3/LKc=
 github.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
+github.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=
+github.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=
+github.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=
 github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
 github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
 github.com/dgrijalva/jwt-go v3.2.0+incompatible h1:7qlOGliEKZXTDg6OTjfoBKDXWrumCAMpl/TFQ4/5kLM=
 github.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=
+github.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=
+github.com/dgryski/go-sip13 v0.0.0-20190329191031-25c5027a8c7b/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=
 github.com/docker/go-units v0.3.3 h1:Xk8S3Xj5sLGlG5g67hJmYMmUgXv5N4PhkjJHHqrwnTk=
 github.com/docker/go-units v0.3.3/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
+github.com/docker/go-units v0.4.0 h1:3uh0PgVws3nIA0Q+MwDC8yjEPf9zjRfZZWXZYDct3Tw=
+github.com/docker/go-units v0.4.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
 github.com/fsnotify/fsnotify v1.4.7 h1:IXs+QLmnXW2CcXuY+8Mzv/fWEsPGWxqefPtCP5CnV9I=
 github.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=
+github.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=
 github.com/globalsign/mgo v0.0.0-20180905125535-1ca0a4f7cbcb/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=
 github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8 h1:DujepqpGd1hyOd7aW59XpK7Qymp8iy83xq74fLr21is=
 github.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=
+github.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=
+github.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=
+github.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=
 github.com/go-openapi/analysis v0.0.0-20180825180245-b006789cd277/go.mod h1:k70tL6pCuVxPJOHXQ+wIac1FUrvNkHolPie/cLEU6hI=
 github.com/go-openapi/analysis v0.17.0/go.mod h1:IowGgpVeD0vNm45So8nr+IcQ3pxVtpRoBWb8PVZO0ik=
 github.com/go-openapi/analysis v0.18.0 h1:hRMEymXOgwo7KLPqqFmw6t3jLO2/zxUe/TXjAHPq9Gc=
@@ -73,42 +101,108 @@ github.com/go-openapi/swag v0.19.0/go.mod h1:AByQ+nYG6gQg71GINrmuDXCPWdL640yX49/
 github.com/go-openapi/validate v0.18.0/go.mod h1:Uh4HdOzKt19xGIGm1qHf/ofbX1YQ4Y+MYsct2VUrAJ4=
 github.com/go-openapi/validate v0.19.0 h1:SF5vyj6PBFM6D1cw2NJIFrlS8Su2YKk6ADPPjAH70Bw=
 github.com/go-openapi/validate v0.19.0/go.mod h1:Uh4HdOzKt19xGIGm1qHf/ofbX1YQ4Y+MYsct2VUrAJ4=
+github.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=
 github.com/go-swagger/scan-repo-boundary v0.0.0-20180623220736-973b3573c013 h1:l9rI6sNaZgNC0LnF3MiE+qTmyBA/tZAg1rtyrGbUMK0=
 github.com/go-swagger/scan-repo-boundary v0.0.0-20180623220736-973b3573c013/go.mod h1:b65mBPzqzZWxOZGxSWrqs4GInLIn+u99Q9q7p+GKni0=
+github.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=
+github.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=
+github.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=
+github.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=
+github.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
+github.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=
+github.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=
 github.com/golang/protobuf v1.2.0/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
 github.com/golang/protobuf v1.3.1 h1:YF8+flBXS5eO826T4nzqPrxfhQThhXl0YzfuUPu4SBg=
 github.com/golang/protobuf v1.3.1/go.mod h1:6lQm79b+lXiMfvg/cZm0SGofjICqVBUtrP5yJMmIC1U=
+github.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
+github.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=
+github.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=
+github.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=
+github.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=
+github.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
+github.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=
+github.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=
 github.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
 github.com/google/uuid v1.1.1 h1:Gkbcsh/GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF/3gY=
 github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
+github.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=
 github.com/gorilla/handlers v1.4.0 h1:XulKRWSQK5uChr4pEgSE4Tc/OcmnU9GJuSwdog/tZsA=
 github.com/gorilla/handlers v1.4.0/go.mod h1:Qkdc/uu4tH4g6mTK6auzZ766c4CA0Ng8+o/OAirnOIQ=
+github.com/gorilla/websocket v1.4.0/go.mod h1:E7qHFY5m1UJ88s3WnNqhKjPHQ0heANvMoAMk2YaljkQ=
+github.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=
+github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=
+github.com/grpc-ecosystem/grpc-gateway v1.9.0/go.mod h1:vNeuVxBJEsws4ogUvrchl83t/GYV9WGTSLVdBhOQFDY=
+github.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
+github.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=
 github.com/hashicorp/hcl v1.0.0 h1:0Anlzjpi4vEasTeNFn2mLJgTSwt0+6sfsiTG8qcWGx4=
 github.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=
 github.com/jessevdk/go-flags v1.4.0 h1:4IU2WS7AumrZ/40jfhf4QVDMsQwqA7VEHozFRrGARJA=
 github.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=
+github.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=
+github.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=
+github.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=
+github.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=
+github.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=
+github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
+github.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
+github.com/konsorten/go-windows-terminal-sequences v1.0.2/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=
+github.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=
 github.com/kr/pretty v0.1.0 h1:L/CwN0zerZDmRFUapSPitk6f+Q3+0za1rQkzVuMiMFI=
 github.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=
 github.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
+github.com/kr/pty v1.1.4/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=
 github.com/kr/text v0.1.0 h1:45sCR5RtlFHMR4UwH9sdQ5TC8v0qDQCHnXt+kaKSTVE=
 github.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=
 github.com/magiconair/properties v1.8.0 h1:LLgXmsheXeRoUOBOjtwPQCWIYqM/LU1ayDtDePerRcY=
 github.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
+github.com/magiconair/properties v1.8.1 h1:ZC2Vc7/ZFkGmsVC9KvOjumD+G5lXy2RtTKyzRKO2BQ4=
+github.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=
 github.com/mailru/easyjson v0.0.0-20180823135443-60711f1a8329/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
 github.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe h1:W/GaMY0y69G4cFlmsC6B9sbuo2fP8OFP1ABjt4kPz+w=
 github.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
+github.com/mailru/easyjson v0.0.0-20190403194419-1ea4449da983 h1:wL11wNW7dhKIcRCHSm4sHKPWz0tt4mwBsVodG7+Xyqg=
+github.com/mailru/easyjson v0.0.0-20190403194419-1ea4449da983/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=
+github.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=
 github.com/mitchellh/mapstructure v1.1.2 h1:fmNYVwqnSfB9mZU6OS2O6GsXM+wcskZDuKQzvN1EDeE=
 github.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=
+github.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=
+github.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=
 github.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=
 github.com/pelletier/go-toml v1.2.0 h1:T5zMGML61Wp+FlcbWjRDT7yAxhJNAiPPLOFECq181zc=
 github.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=
+github.com/pelletier/go-toml v1.4.0 h1:u3Z1r+oOXJIkxqw34zVhyPgjBsm6X2wn21NWs/HfSeg=
+github.com/pelletier/go-toml v1.4.0/go.mod h1:PN7xzY2wHTK0K9p34ErDQMlFxa51Fk0OUruD3k1mMwo=
+github.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
+github.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
 github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
 github.com/pquerna/cachecontrol v0.0.0-20180517163645-1555304b9b35 h1:J9b7z+QKAmPf4YLrFg6oQUotqHQeUNWwkvo7jZp1GLU=
 github.com/pquerna/cachecontrol v0.0.0-20180517163645-1555304b9b35/go.mod h1:prYjPmNq4d1NPVmpShWobRqXY3q7Vp+80DqgxxUrUIA=
+github.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=
+github.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=
+github.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=
+github.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=
+github.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=
+github.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=
+github.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=
+github.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=
+github.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=
+github.com/prometheus/procfs v0.0.1/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=
+github.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=
+github.com/prometheus/tsdb v0.8.0/go.mod h1:fSI0j+IUQrDd7+ZtR9WKIGtoYAYAJUKcKhYLG25tN4g=
+github.com/rogpeppe/fastuuid v0.0.0-20150106093220-6724a57986af/go.mod h1:XWv6SoW27p1b0cqNHllgS5HIMJraePCO15w5zCzIWYg=
+github.com/rogpeppe/fastuuid v1.1.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=
+github.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=
+github.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=
+github.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=
+github.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=
+github.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=
+github.com/spaolacci/murmur3 v1.1.0/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=
 github.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=
 github.com/spf13/afero v1.2.1 h1:qgMbHoJbPbw579P+1zVY+6n4nIFuIchaIjzZ/I/Yq8M=
 github.com/spf13/afero v1.2.1/go.mod h1:9ZxEEn6pIJ8Rxe320qSDBk6AsU0r9pR7Q4OcevTdifk=
+github.com/spf13/afero v1.2.2 h1:5jhuqJyZCZf2JRofRvN/nIFgIWNzPa3/Vz8mYylgbWc=
+github.com/spf13/afero v1.2.2/go.mod h1:9ZxEEn6pIJ8Rxe320qSDBk6AsU0r9pR7Q4OcevTdifk=
 github.com/spf13/cast v1.3.0 h1:oget//CVOEoFewqQxwr0Ej5yjygnqGkvggSE/gB35Q8=
 github.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
 github.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=
@@ -118,48 +212,142 @@ github.com/spf13/pflag v1.0.3 h1:zPAT6CGy6wXeQ7NtTnaTerfKOsV6V6F8agHXFiazDkg=
 github.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=
 github.com/spf13/viper v1.3.2 h1:VUFqw5KcqRf7i70GOzW7N+Q7+gxVBkSSqiXB12+JQ4M=
 github.com/spf13/viper v1.3.2/go.mod h1:ZiWeW+zYFKm7srdB9IoDzzZXaJaI5eL9QjNiN/DMA2s=
+github.com/spf13/viper v1.4.0 h1:yXHLWeravcrgGyFSyCgdYpXQ9dR9c/WED3pg1RhxqEU=
+github.com/spf13/viper v1.4.0/go.mod h1:PTJ7Z/lr49W6bUbkmS1V3by4uWynFiR9p7+dSq/yZzE=
 github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
 github.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
+github.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=
 github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
 github.com/stretchr/testify v1.3.0 h1:TivCn/peBQ7UY8ooIcPgZFpTNSz0Q2U6UrFlUfqbe0Q=
 github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
+github.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=
 github.com/toqueteos/webbrowser v1.1.0 h1:Prj1okiysRgHPoe3B1bOIVxcv+UuSt525BDQmR5W0x0=
 github.com/toqueteos/webbrowser v1.1.0/go.mod h1:Hqqqmzj8AHn+VlZyVjaRWY20i25hoOZGAABCcg2el4A=
+github.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=
+github.com/ugorji/go v1.1.5-pre/go.mod h1:FwP/aQVg39TXzItUBMwnWp9T9gPQnXw4Poh4/oBQZ/0=
 github.com/ugorji/go/codec v0.0.0-20181204163529-d75b2dcb6bc8/go.mod h1:VFNgLljTbGfSG7qAOspJ7OScBnGdDN/yBr0sguwnwf0=
+github.com/ugorji/go/codec v1.1.5-pre/go.mod h1:tULtS6Gy1AE1yCENaw4Vb//HLH5njI2tfCQDUqRd8fI=
+github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=
 github.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=
+go.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=
+go.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=
+go.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=
+go.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=
+go.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=
+go.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=
+golang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
 golang.org/x/crypto v0.0.0-20181203042331-505ab145d0a9/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=
 golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
 golang.org/x/crypto v0.0.0-20190320223903-b7391e95e576 h1:aUX/1G2gFSs4AsJJg2cL3HuoRhCSCz733FE5GUSuaT4=
 golang.org/x/crypto v0.0.0-20190320223903-b7391e95e576/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
+golang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
+golang.org/x/crypto v0.0.0-20190530122614-20be4c3c3ed5 h1:8dUaAV7K4uHsF56JQWkprecIQKdPHtR9jCHF5nB8uzc=
+golang.org/x/crypto v0.0.0-20190530122614-20be4c3c3ed5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
+golang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
+golang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=
+golang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=
+golang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=
+golang.org/x/image v0.0.0-20190523035834-f03afa92d3ff/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=
+golang.org/x/lint v0.0.0-20181026193005-c67002cb31c3/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
+golang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=
+golang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=
+golang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
+golang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=
+golang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=
+golang.org/x/mobile v0.0.0-20190509164839-32b2708ab171/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=
+golang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=
+golang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=
 golang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
+golang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20181005035420-146acd28ed58/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
+golang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
+golang.org/x/net v0.0.0-20181220203305-927f97764cc3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
+golang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=
 golang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
 golang.org/x/net v0.0.0-20190320064053-1272bf9dcd53/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
 golang.org/x/net v0.0.0-20190322120337-addf6b3196f6 h1:78jEq2G3J16aXneH23HSnTQQTCwMHoyO8VEiUH+bpPM=
 golang.org/x/net v0.0.0-20190322120337-addf6b3196f6/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
+golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
+golang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
+golang.org/x/net v0.0.0-20190522155817-f3200d17e092 h1:4QSRKanuywn15aTZvI/mIDEgPQpswuFndXpOj3rKEco=
+golang.org/x/net v0.0.0-20190522155817-f3200d17e092/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=
+golang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=
+golang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
 golang.org/x/oauth2 v0.0.0-20190319182350-c85d3e98c914 h1:jIOcLT9BZzyJ9ce+IwwZ+aF9yeCqzrR+NrD68a/SHKw=
 golang.org/x/oauth2 v0.0.0-20190319182350-c85d3e98c914/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
+golang.org/x/oauth2 v0.0.0-20190523182746-aaccbc9213b0 h1:xFEXbcD0oa/xhqQmMXztdZ0bWvexAWds+8c1gRN8nu0=
+golang.org/x/oauth2 v0.0.0-20190523182746-aaccbc9213b0/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=
+golang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
 golang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
+golang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
+golang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
+golang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
+golang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20181205085412-a5c9d58dba9a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
 golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
+golang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190321052220-f7bb7a8bee54/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/sys v0.0.0-20190322080309-f49334f85ddc h1:4gbWbmmPFp4ySWICouJl6emP0MyS31yy9SrTlAGFT+g=
 golang.org/x/sys v0.0.0-20190322080309-f49334f85ddc/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
+golang.org/x/sys v0.0.0-20190602015325-4c4f7f33c9ed h1:uPxWBzB3+mlnjy9W58qY1j/cjyFjutgw/Vhan2zLy/A=
+golang.org/x/sys v0.0.0-20190602015325-4c4f7f33c9ed/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
 golang.org/x/text v0.3.0 h1:g61tztE5qeGQ89tm6NTjjM9VPIm088od1l6aSorWRWg=
 golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
 golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2 h1:z99zHgr7hKfrUcX/KsoJk5FJfjTceCKIp96+biqP4To=
 golang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
+golang.org/x/text v0.3.2 h1:tW2bmiBqwgJj/UpqtC8EpXEZVYOwU0yG4iWbprSVAcs=
+golang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=
+golang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
+golang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
+golang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
+golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
+golang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
+golang.org/x/tools v0.0.0-20190114222345-bf090417da8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
+golang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=
+golang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
+golang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
+golang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
 golang.org/x/tools v0.0.0-20190322203728-c1a832b0ad89 h1:iWXXYN3edZ3Nd/7I6Rt1sXrWVmhF9bgVtlEJ7BbH124=
 golang.org/x/tools v0.0.0-20190322203728-c1a832b0ad89/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=
+golang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=
+golang.org/x/tools v0.0.0-20190530171427-2b03ca6e44eb/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
+golang.org/x/tools v0.0.0-20190602112858-2de7f9bf822c h1:8QARbM77BTyoVvSaGaoQPCYgZlVROYX1uKApKK98b+8=
+golang.org/x/tools v0.0.0-20190602112858-2de7f9bf822c/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=
+google.golang.org/api v0.5.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=
+google.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=
 google.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
 google.golang.org/appengine v1.5.0 h1:KxkO13IPW4Lslp2bz+KHP2E3gtFlrIGNThxkZQ3g+4c=
 google.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
+google.golang.org/appengine v1.6.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=
+google.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=
+google.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
+google.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
+google.golang.org/genproto v0.0.0-20190508193815-b515fa19cec8/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=
+google.golang.org/genproto v0.0.0-20190530194941-fb225487d101/go.mod h1:z3L6/3dTEVtUr6QSP8miRzeRqwQOioJ9I66odjN4I7s=
+google.golang.org/grpc v1.19.0/go.mod h1:mqu4LbDTu4XGKhr4mRzUsmM4RtVoemTSY81AxZiDr8c=
+google.golang.org/grpc v1.20.1/go.mod h1:10oTOabMzJvdu6/UiuZezV6QK5dSlG84ov/aaiqXj38=
+google.golang.org/grpc v1.21.0/go.mod h1:oYelfM1adQP15Ek0mdvEgi9Df8B9CZIaU1084ijfRaM=
+gopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=
 gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
 gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127 h1:qIbj1fsPNlZgppZ+VLlY7N33q108Sa+fhmuc+sWQYwY=
 gopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
+gopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=
+gopkg.in/resty.v1 v1.12.0/go.mod h1:mDo4pnntr5jdWRML875a/NmxYqAlA73dVijT2AXvQQo=
 gopkg.in/square/go-jose.v2 v2.3.0 h1:nLzhkFyl5bkblqYBoiWJUt5JkWOzmiaBtCxdJAqJd3U=
 gopkg.in/square/go-jose.v2 v2.3.0/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=
+gopkg.in/square/go-jose.v2 v2.3.1 h1:SK5KegNXmKmqE342YYN2qPHEnUYeoMiXXl1poUlI+o4=
+gopkg.in/square/go-jose.v2 v2.3.1/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=
+gopkg.in/yaml.v2 v2.0.0-20170812160011-eb3733d160e7/go.mod h1:JAlM8MvJe8wmxCU4Bli9HhUf9+ttbYbLASfIpnQbh74=
 gopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
 gopkg.in/yaml.v2 v2.2.2 h1:ZCJp+EgiOT7lHqUV2J862kp8Qj64Jo6az82+3Td9dZw=
 gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
+honnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
+honnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=
+honnef.co/go/tools v0.0.0-20190602125119-5a4a2f4a438d/go.mod h1:JlmFZigtG9vBVR3QGIQ9g/Usz4BzH+Xm6Z8iHQWRYUw=
diff --git a/vendor/github.com/corbym/gocrest/.gitignore b/vendor/github.com/corbym/gocrest/.gitignore
new file mode 100644
index 00000000..62c89355
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/.gitignore
@@ -0,0 +1 @@
+.idea/
\ No newline at end of file
diff --git a/vendor/github.com/corbym/gocrest/.travis.yml b/vendor/github.com/corbym/gocrest/.travis.yml
new file mode 100644
index 00000000..737aed6b
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/.travis.yml
@@ -0,0 +1,15 @@
+sudo: false
+language: go
+go:
+  - 1.9.x
+  - master
+before_install:
+  - go get github.com/mattn/goveralls
+script:
+  - $GOPATH/bin/goveralls -service=travis-ci
+matrix:
+  allow_failures:
+    - go: master
+  fast_finish: true
+notifications:
+  email: false
diff --git a/vendor/github.com/corbym/gocrest/LICENSE.md b/vendor/github.com/corbym/gocrest/LICENSE.md
new file mode 100644
index 00000000..4842a866
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/LICENSE.md
@@ -0,0 +1,29 @@
+BSD 3-Clause License
+
+Copyright (c) 2017, Binary Soup Ltd
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/vendor/github.com/corbym/gocrest/README.md b/vendor/github.com/corbym/gocrest/README.md
new file mode 100644
index 00000000..241e6723
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/README.md
@@ -0,0 +1,67 @@
+# gocrest
+
+A hamcrest-like assertion library for Go. GoCrest matchers are composable, self-describing and
+can be strung together in a more readable form to create flexible assertions. 
+
+Inspired by [Hamcrest](https://github.com/hamcrest). 
+
+[![Build status](https://travis-ci.org/corbym/gocrest.svg?branch=master)](https://github.com/corbym/gocrest)
+[![Go Report Card](https://goreportcard.com/badge/github.com/corbym/gocrest)](https://goreportcard.com/report/github.com/corbym/gocrest)
+[![GoDoc](https://godoc.org/github.com/corbym/gocrest?status.svg)](http://godoc.org/github.com/corbym/gocrest)
+[![BCH compliance](https://bettercodehub.com/edge/badge/corbym/gocrest?branch=master)](https://bettercodehub.com/)
+[![Coverage Status](https://coveralls.io/repos/github/corbym/gocrest/badge.svg?branch=master)](https://coveralls.io/github/corbym/gocrest?branch=master)
+## Package import
+
+```
+import (
+  "github.com/corbym/gocrest/then"
+  "github.com/corbym/gocrest/is"
+  "github.com/corbym/gocrest/has"
+)
+```
+
+## Example:
+```go
+then.AssertThat(testing, "hi", is.EqualTo("bye").Reason("we are going"))
+```
+
+output:
+
+```
+we are going
+Expected: value equal to <bye>
+     but: <hi>
+```
+
+Composed with AllOf:
+
+```go
+then.AssertThat(t, "abcdef", is.AllOf(is.ValueContaining("abc"), is.LessThan("ghi")))
+```
+
+# Matchers so far..
+
+- is.EqualTo(x)
+- is.EqualToIgnoringWhitespace(string) - compares two strings without comparing their whitespace characters.
+- is.Nil() - value must be nil
+- is.ValueContaining(expected) -- acts like containsAll
+- is.Not(m *Matcher) -- logical not of matcher's result
+- is.MatchForPattern(regex string) -- a string regex expression
+- has.FunctionNamed(string x) - checks if an interface has a function (method)
+- has.FieldNamed(string x) - checks if a struct has a field named x
+- is.AllOf(... *Matcher) - returns true if all matchers match
+- is.AnyOf(... *Matcher) - return true if any matcher matches
+- is.GreaterThan(expected) - checks if actual > expected
+- is.LessThan(expected)
+- is.Empty() - matches if the actual is "", nil or len(actual)==0
+- is.LessThan(x)
+- is.LessThanOrEqualTo(x)
+- is.GreaterThan(x)
+- is.GreaterThanOrEqualTo(x)
+- has.Length(x) - matcher if given value (int or matcher) matches the len of the given
+- has.Prefix(x) - string starts with x
+- has.Suffix(x) - string ends with x
+- has.Key(x) - map has key x
+- has.AllKeys(T x, T y) (or has.AllKeys([]T{x,y})) - finds key of type T in map
+
+For more comprehensive documentation see [godoc](http://godoc.org/github.com/corbym/gocrest).
diff --git a/vendor/github.com/corbym/gocrest/is/allof.go b/vendor/github.com/corbym/gocrest/is/allof.go
new file mode 100644
index 00000000..f7212825
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/allof.go
@@ -0,0 +1,29 @@
+package is
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+)
+
+//AllOf takes some matchers and checks if all the matchers return true.
+//Returns a matcher that performs the the test on the input matchers.
+func AllOf(allMatchers ...*gocrest.Matcher) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Describe = fmt.Sprintf("all of (%s)", describe(allMatchers, "and"))
+	matcher.Matches = matchAll(allMatchers, matcher)
+	return matcher
+}
+
+func matchAll(allMatchers []*gocrest.Matcher, allOf *gocrest.Matcher) func(actual interface{}) bool {
+	return func(actual interface{}) bool {
+		matches := true
+		allOf.AppendActual(fmt.Sprintf("actual <%v>", actual))
+		for x := 0; x < len(allMatchers); x++ {
+			if !allMatchers[x].Matches(actual) {
+				matches = false
+			}
+			allOf.AppendActual(allMatchers[x].Actual)
+		}
+		return matches
+	}
+}
diff --git a/vendor/github.com/corbym/gocrest/is/anyof.go b/vendor/github.com/corbym/gocrest/is/anyof.go
new file mode 100644
index 00000000..b2d84938
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/anyof.go
@@ -0,0 +1,29 @@
+package is
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+)
+
+//AnyOf takes some matchers and checks if at least one of the matchers return true.
+//Returns a matcher that performs the the test on the input matchers.
+func AnyOf(allMatchers ...*gocrest.Matcher) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Describe = fmt.Sprintf("any of (%s)", describe(allMatchers, "or"))
+	matcher.Matches = anyMatcherMatches(allMatchers, matcher)
+	return matcher
+}
+
+func anyMatcherMatches(allMatchers []*gocrest.Matcher, anyOf *gocrest.Matcher) func(actual interface{}) bool {
+	return func(actual interface{}) bool {
+		matches := false
+		anyOf.AppendActual(fmt.Sprintf("actual <%v>", actual))
+		for x := 0; x < len(allMatchers); x++ {
+			if allMatchers[x].Matches(actual) {
+				matches = true
+			}
+			anyOf.AppendActual(allMatchers[x].Actual)
+		}
+		return matches
+	}
+}
diff --git a/vendor/github.com/corbym/gocrest/is/contains.go b/vendor/github.com/corbym/gocrest/is/contains.go
new file mode 100644
index 00000000..404632a6
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/contains.go
@@ -0,0 +1,94 @@
+package is
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+	"reflect"
+	"strings"
+)
+
+//ValueContaining finds if x is contained in y.
+// Acts like "ContainsAll", all elements given must be present in actual.
+// If "expected" is an array or slice, we assume that actual is the same type.
+// assertThat([]T, has.ValueContaining(a,b,c)) is also valid if variadic a,b,c are all type T.
+// For maps, the expected must also be a map or a variadic and matches if both maps contain all key,values in expected
+// or all variadic values respectively.
+// For string, behaves like strings.Contains.
+// Will panic if types cannot be converted correctly.
+//Returns the Matcher that returns true if found.
+func ValueContaining(expected ...interface{}) *gocrest.Matcher {
+	match := new(gocrest.Matcher)
+	correctVariadicExpected := correctExpectedValue(expected...)
+	match.Describe = fmt.Sprintf("something that contains %v", correctVariadicExpected)
+	match.Matches = func(actual interface{}) bool {
+		expectedAsStr, expectedOk := expected[0].(string)
+		actualAsStr, actualOk := actual.(string)
+		if expectedOk && actualOk {
+			return strings.Contains(actualAsStr, expectedAsStr)
+		}
+		actualValue := reflect.ValueOf(actual)
+		expectedValue := reflect.ValueOf(correctVariadicExpected)
+		switch actualValue.Kind() {
+		case reflect.Array, reflect.Slice:
+			return listContains(expectedValue, actualValue)
+		case reflect.Map:
+			if expectedValue.Kind() == reflect.Array || expectedValue.Kind() == reflect.Slice {
+				return mapContainsList(expectedValue, actualValue)
+			}
+			return mapContains(expectedValue, actualValue)
+		default:
+			panic("cannot determine type of variadic actual, " + actualValue.String())
+		}
+	}
+	return match
+}
+
+func mapContainsList(expected reflect.Value, mapValue reflect.Value) bool {
+	contains := make(map[interface{}]bool)
+	for i := 0; i < expected.Len(); i++ {
+		for _, key := range mapValue.MapKeys() {
+			itemValue := expected.Index(i).Interface()
+			if mapValue.MapIndex(key).Interface() == itemValue {
+				contains[itemValue] = true
+			}
+		}
+	}
+	return len(contains) == expected.Len()
+}
+
+func mapContains(expected reflect.Value, actual reflect.Value) bool {
+	expectedKeys := expected.MapKeys()
+
+	contains := make(map[interface{}]bool)
+	for i := 0; i < len(expectedKeys); i++ {
+		val := actual.MapIndex(expectedKeys[i])
+		if val.IsValid() {
+			if val.Interface() == expected.MapIndex(expectedKeys[i]).Interface() {
+				contains[val] = true
+			}
+		}
+	}
+	return len(contains) == len(expected.MapKeys())
+}
+
+func listContains(expectedValue reflect.Value, actualValue reflect.Value) bool {
+	contains := make(map[interface{}]bool)
+	for i := 0; i < expectedValue.Len(); i++ {
+		for y := 0; y < actualValue.Len(); y++ {
+			exp := expectedValue.Index(i).Interface()
+			act := actualValue.Index(y).Interface()
+			if exp == act {
+				contains[act] = true
+			}
+		}
+	}
+	return len(contains) == expectedValue.Len()
+}
+
+func correctExpectedValue(expected ...interface{}) interface{} {
+	kind := reflect.ValueOf(expected[0]).Kind()
+	if kind == reflect.Slice || kind == reflect.Map {
+		return expected[0]
+	}
+	return expected
+}
diff --git a/vendor/github.com/corbym/gocrest/is/describe.go b/vendor/github.com/corbym/gocrest/is/describe.go
new file mode 100644
index 00000000..7a9eab52
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/describe.go
@@ -0,0 +1,17 @@
+package is
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+)
+
+func describe(matchers []*gocrest.Matcher, conjunction string) string {
+	var description string
+	for x := 0; x < len(matchers); x++ {
+		description += matchers[x].Describe
+		if x+1 < len(matchers) {
+			description += fmt.Sprintf(" %s ", conjunction)
+		}
+	}
+	return description
+}
diff --git a/vendor/github.com/corbym/gocrest/is/empty.go b/vendor/github.com/corbym/gocrest/is/empty.go
new file mode 100644
index 00000000..ccff97f6
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/empty.go
@@ -0,0 +1,29 @@
+package is
+
+import (
+	"github.com/corbym/gocrest"
+	"reflect"
+)
+
+//Empty matches if the actual is "empty".
+// 'string' values are empty if they are "", maps, arrays and slices are empty if len(actual) is 0.
+// Pointers and interfaces are empty when nil.
+// Other types (int, float, bool) will cause the function to panic.
+//Returns a matcher that evaluates true if actual is "empty".
+func Empty() *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Describe = "empty value"
+	matcher.Matches = func(actual interface{}) bool {
+		if actual == nil {
+			return true
+		}
+		if actualValue, ok := actual.(string); ok {
+			return actualValue == ""
+		}
+		if reflect.ValueOf(actual).Len() == 0 {
+			return true
+		}
+		return false
+	}
+	return matcher
+}
diff --git a/vendor/github.com/corbym/gocrest/is/equalto.go b/vendor/github.com/corbym/gocrest/is/equalto.go
new file mode 100644
index 00000000..b178b4fd
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/equalto.go
@@ -0,0 +1,19 @@
+package is
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+	"reflect"
+)
+
+//EqualTo checks if two values are equal. Uses DeepEqual (could be slow).
+//Returns a matcher that will return true if two values are equal.
+func EqualTo(expected interface{}) *gocrest.Matcher {
+	match := new(gocrest.Matcher)
+	match.Describe = fmt.Sprintf("value equal to <%v>", expected)
+	match.Matches = func(actual interface{}) bool {
+		return reflect.DeepEqual(expected, actual)
+	}
+
+	return match
+}
diff --git a/vendor/github.com/corbym/gocrest/is/equaltoignoringwhitespace.go b/vendor/github.com/corbym/gocrest/is/equaltoignoringwhitespace.go
new file mode 100644
index 00000000..70b1395f
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/equaltoignoringwhitespace.go
@@ -0,0 +1,28 @@
+package is
+
+import (
+	"github.com/corbym/gocrest"
+	"strings"
+)
+
+//EqualToIgnoringWhitespace tests whether two strings have identical content without any whitespace
+// comparison. For example:
+//
+// "a bc" is EqualToIgnoringWhitespace when compared with "a   b c"
+// "a b c" is EqualToIgnoringWhitespace when compared with "a \nb \tc"
+// "ab\tc" is EqualToIgnoringWhitespace when compared with "a \nb \tc"
+// .. and so on.
+func EqualToIgnoringWhitespace(expected string) (matcher *gocrest.Matcher) {
+	matcher = new(gocrest.Matcher)
+	matcher.Matches = func(actual interface{}) bool {
+		actualString := actual.(string)
+		expectedFields := strings.Join(strings.Fields(expected), "")
+		actualFields := strings.Join(strings.Fields(actualString), "")
+
+		equalToMatcher := EqualTo(expectedFields)
+		matcher.Describe = "ignoring whitespace value equal to <" + expected + ">"
+		isEqualTo := equalToMatcher.Matches(actualFields)
+		return isEqualTo
+	}
+	return
+}
diff --git a/vendor/github.com/corbym/gocrest/is/greaterthan.go b/vendor/github.com/corbym/gocrest/is/greaterthan.go
new file mode 100644
index 00000000..0845275a
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/greaterthan.go
@@ -0,0 +1,39 @@
+package is
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+	"reflect"
+)
+
+//GreaterThan matcher compares two values that are numeric or string values, and when
+// called returns true if actual > expected. Strings are compared lexicographically with '>'.
+// The matcher will always return false for unknown types.
+// Actual and expected types must be the same underlying type, or the function will panic.
+//Returns a matcher that checks if actual is greater than expected.
+func GreaterThan(expected interface{}) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Describe = fmt.Sprintf("value greater than <%v>", expected)
+	matcher.Matches = func(actual interface{}) bool {
+		actualValue := reflect.ValueOf(actual)
+		expectedValue := reflect.ValueOf(expected)
+		switch expected.(type) {
+		case float32, float64:
+			{
+				return actualValue.Float() > expectedValue.Float()
+			}
+		case int, int8, int16, int32, int64:
+			{
+				return actualValue.Int() > expectedValue.Int()
+			}
+		case uint, uint8, uint16, uint32, uint64:
+			{
+				return actualValue.Uint() > expectedValue.Uint()
+			}
+		case string:
+			return actualValue.String() > expectedValue.String()
+		}
+		return false
+	}
+	return matcher
+}
diff --git a/vendor/github.com/corbym/gocrest/is/greaterthanorequalto.go b/vendor/github.com/corbym/gocrest/is/greaterthanorequalto.go
new file mode 100644
index 00000000..68c73637
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/greaterthanorequalto.go
@@ -0,0 +1,16 @@
+package is
+
+import "github.com/corbym/gocrest"
+
+//GreaterThanOrEqualTo is a short hand matcher for anyOf(greaterThan(x), equalTo(x))
+//Returns a matcher matching if actual >= expected (using deepEquals).
+func GreaterThanOrEqualTo(expected interface{}) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Matches = func(actual interface{}) bool {
+		anyOf := AnyOf(GreaterThan(expected), EqualTo(expected))
+		anyOfMatches := anyOf.Matches(actual)
+		matcher.Describe = anyOf.Describe
+		return anyOfMatches
+	}
+	return matcher
+}
diff --git a/vendor/github.com/corbym/gocrest/is/isfalse.go b/vendor/github.com/corbym/gocrest/is/isfalse.go
new file mode 100644
index 00000000..4bfaae15
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/isfalse.go
@@ -0,0 +1,13 @@
+package is
+
+import "github.com/corbym/gocrest"
+
+//False returns true if the actual matches false. Confusing but true.
+func False() *gocrest.Matcher {
+	return &gocrest.Matcher{
+		Describe: "is false",
+		Matches: func(actual interface{}) bool {
+			return actual == false
+		},
+	}
+}
diff --git a/vendor/github.com/corbym/gocrest/is/istrue.go b/vendor/github.com/corbym/gocrest/is/istrue.go
new file mode 100644
index 00000000..30601e88
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/istrue.go
@@ -0,0 +1,13 @@
+package is
+
+import "github.com/corbym/gocrest"
+
+//True returns true if the actual matches true
+func True() *gocrest.Matcher {
+	return &gocrest.Matcher{
+		Describe: "is true",
+		Matches: func(actual interface{}) bool {
+			return actual == true
+		},
+	}
+}
diff --git a/vendor/github.com/corbym/gocrest/is/lessthan.go b/vendor/github.com/corbym/gocrest/is/lessthan.go
new file mode 100644
index 00000000..9d1548ae
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/lessthan.go
@@ -0,0 +1,33 @@
+package is
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+	"reflect"
+)
+
+//LessThan matcher compares two values that are numeric or string values, and when
+// called returns true if actual < expected. Strings are compared lexicographically with '<'.
+// The matcher will always return false for unknown types.
+// Actual and expected types must be the same underlying type, or the function will panic.
+//Returns a matcher that checks if actual is greater than expected.
+func LessThan(expected interface{}) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Describe = fmt.Sprintf("value less than <%v>", expected)
+	matcher.Matches = func(actual interface{}) bool {
+		actualValue := reflect.ValueOf(actual)
+		expectedValue := reflect.ValueOf(expected)
+		switch expected.(type) {
+		case float32, float64:
+			return actualValue.Float() < expectedValue.Float()
+		case int, int8, int16, int32, int64:
+			return actualValue.Int() < expectedValue.Int()
+		case uint, uint8, uint16, uint32, uint64:
+			return actualValue.Uint() < expectedValue.Uint()
+		case string:
+			return actualValue.String() < expectedValue.String()
+		}
+		return false
+	}
+	return matcher
+}
diff --git a/vendor/github.com/corbym/gocrest/is/lessthanorequalto.go b/vendor/github.com/corbym/gocrest/is/lessthanorequalto.go
new file mode 100644
index 00000000..66a06bc2
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/lessthanorequalto.go
@@ -0,0 +1,16 @@
+package is
+
+import "github.com/corbym/gocrest"
+
+//LessThanOrEqualTo is a short hand matcher for anyOf(lessThan(x), equalTo(x))
+//Returns a matcher matching if actual <= expected (using deepEquals).
+func LessThanOrEqualTo(expected interface{}) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Matches = func(actual interface{}) bool {
+		anyOf := AnyOf(LessThan(expected), EqualTo(expected))
+		anyOfMatches := anyOf.Matches(actual)
+		matcher.Describe = anyOf.Describe
+		return anyOfMatches
+	}
+	return matcher
+}
diff --git a/vendor/github.com/corbym/gocrest/is/matchespattern.go b/vendor/github.com/corbym/gocrest/is/matchespattern.go
new file mode 100644
index 00000000..d6bf95e3
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/matchespattern.go
@@ -0,0 +1,24 @@
+package is
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+	"regexp"
+)
+
+//MatchForPattern matches if actual string matches the expected regex
+//String provided must be a valid for compilation with regexp.Compile.
+//Returns a matcher that uses the expected for a regex to match the actual value.
+func MatchForPattern(expected string) *gocrest.Matcher {
+	matcher := new(gocrest.Matcher)
+	matcher.Describe = fmt.Sprintf("a value that matches pattern %s", expected)
+	matcher.Matches = func(actual interface{}) bool {
+		compiledExp, err := regexp.Compile(expected)
+		if err != nil {
+			matcher.Describe = err.Error()
+			return false
+		}
+		return compiledExp.MatchString(actual.(string))
+	}
+	return matcher
+}
diff --git a/vendor/github.com/corbym/gocrest/is/nil.go b/vendor/github.com/corbym/gocrest/is/nil.go
new file mode 100644
index 00000000..651ac0f5
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/nil.go
@@ -0,0 +1,8 @@
+package is
+
+import "github.com/corbym/gocrest"
+
+//Nil matches if the expected value is nil
+func Nil() *gocrest.Matcher {
+	return EqualTo(nil)
+}
diff --git a/vendor/github.com/corbym/gocrest/is/not.go b/vendor/github.com/corbym/gocrest/is/not.go
new file mode 100644
index 00000000..6d8c4303
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/is/not.go
@@ -0,0 +1,18 @@
+package is
+
+import (
+	"github.com/corbym/gocrest"
+)
+
+//Not negates the given matcher.
+//Returns a matcher that returns logical not of the matcher given.
+func Not(matcher *gocrest.Matcher) *gocrest.Matcher {
+	match := new(gocrest.Matcher)
+	match.Describe = "not(" + matcher.Describe + ")"
+	match.Matches = func(actual interface{}) bool {
+		matches := !matcher.Matches(actual)
+		match.Actual = matcher.Actual
+		return matches
+	}
+	return match
+}
diff --git a/vendor/github.com/corbym/gocrest/matcher.go b/vendor/github.com/corbym/gocrest/matcher.go
new file mode 100644
index 00000000..9abfa953
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/matcher.go
@@ -0,0 +1,39 @@
+package gocrest
+
+import (
+	"fmt"
+	"strings"
+)
+
+//Matcher provides the structure for matcher operations.
+type Matcher struct {
+	// Matches returns true if the function matches.
+	Matches func(actual interface{}) bool
+	// Describe describes the matcher (e.g. "a value EqualTo(foo)"
+	Describe string
+	// Actual is used by then.AssertThat if the matcher
+	// needs to resolve the string description of the actual.
+	// This is usually if the actual is a complex type.
+	Actual string
+	// ReasonString is a comment on why the matcher did not match, and set by the caller not the matcher.
+	// Usually, this is set by the helper function, e.g. FooMatcher("foo").Reason("foo didn't foobar")
+	ReasonString string
+}
+
+//Reason for the mismatch.
+func (matcher *Matcher) Reason(r string) *Matcher {
+	matcher.ReasonString = r
+	return matcher
+}
+
+//Reasonf allows a formatted reason for the mismatch.
+func (matcher *Matcher) Reasonf(format string, args ...interface{}) *Matcher {
+	return matcher.Reason(fmt.Sprintf(format, args...))
+}
+
+//AppendActual appends an actual string to the matcher's actual description. This is useful if you want
+// to preseve sub-matchers actual values. See is.AllOf() matcher for an example.
+func (matcher *Matcher) AppendActual(actualAsString string) {
+	matcher.Actual += " " + actualAsString
+	matcher.Actual = strings.TrimSpace(matcher.Actual)
+}
diff --git a/vendor/github.com/corbym/gocrest/testingt.go b/vendor/github.com/corbym/gocrest/testingt.go
new file mode 100644
index 00000000..fa429bc6
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/testingt.go
@@ -0,0 +1,9 @@
+package gocrest
+
+//TestingT supplies a convenience interface that matches the testing.T interface.
+type TestingT interface {
+	Logf(format string, args ...interface{})
+	Errorf(format string, args ...interface{})
+	FailNow()
+	Helper()
+}
diff --git a/vendor/github.com/corbym/gocrest/then/assertthat.go b/vendor/github.com/corbym/gocrest/then/assertthat.go
new file mode 100644
index 00000000..707e963e
--- /dev/null
+++ b/vendor/github.com/corbym/gocrest/then/assertthat.go
@@ -0,0 +1,27 @@
+package then
+
+import (
+	"fmt"
+	"github.com/corbym/gocrest"
+)
+
+//AssertThat calls a given matcher and fails the test with a message if the matcher doesn't match.
+func AssertThat(t gocrest.TestingT, actual interface{}, m *gocrest.Matcher) {
+	t.Helper()
+	matches := m.Matches(actual)
+	if !matches {
+		t.Errorf("%s\nExpected: %s"+
+			"\n     but: <%s>\n",
+			m.ReasonString,
+			m.Describe,
+			actualAsString(m, actual),
+		)
+	}
+}
+
+func actualAsString(matcher *gocrest.Matcher, actual interface{}) string {
+	if matcher.Actual != "" {
+		return matcher.Actual
+	}
+	return fmt.Sprintf("%v", actual)
+}
diff --git a/vendor/github.com/globalsign/mgo/bson/compatibility.go b/vendor/github.com/globalsign/mgo/bson/compatibility.go
index 66efd465..bcbb25b2 100644
--- a/vendor/github.com/globalsign/mgo/bson/compatibility.go
+++ b/vendor/github.com/globalsign/mgo/bson/compatibility.go
@@ -10,7 +10,7 @@ func SetJSONTagFallback(state bool) {
 	useJSONTagFallback = state
 }
 
-// JSONTagFallbackState returns the current status of the JSON tag fallback compatability option. See SetJSONTagFallback
+// JSONTagFallbackState returns the current status of the JSON tag fallback compatibility option. See SetJSONTagFallback
 // for more information.
 func JSONTagFallbackState() bool {
 	return useJSONTagFallback
diff --git a/vendor/modules.txt b/vendor/modules.txt
index a0af1d05..3f92e30e 100644
--- a/vendor/modules.txt
+++ b/vendor/modules.txt
@@ -4,6 +4,10 @@ github.com/PuerkitoBio/purell
 github.com/PuerkitoBio/urlesc
 # github.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf
 github.com/asaskevich/govalidator
+# github.com/corbym/gocrest v1.0.3
+github.com/corbym/gocrest
+github.com/corbym/gocrest/is
+github.com/corbym/gocrest/then
 # github.com/coreos/go-oidc v2.0.0+incompatible
 github.com/coreos/go-oidc
 # github.com/davecgh/go-spew v1.1.1
