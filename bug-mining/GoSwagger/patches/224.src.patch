diff --git a/generator/debug.go b/generator/debug.go
index f906533d..e2053a46 100644
--- a/generator/debug.go
+++ b/generator/debug.go
@@ -15,6 +15,7 @@
 package generator
 
 import (
+	"encoding/json"
 	"fmt"
 	"log"
 	"os"
@@ -22,21 +23,42 @@ import (
 	"runtime"
 )
 
-// Debug when the env var DEBUG or SWAGGER_DEBUG is not empty
-// the generators will be very noisy about what they are doing
-var Debug = os.Getenv("DEBUG") != "" || os.Getenv("SWAGGER_DEBUG") != ""
+var (
+	// Debug when the env var DEBUG or SWAGGER_DEBUG is not empty
+	// the generators will be very noisy about what they are doing
+	Debug = os.Getenv("DEBUG") != "" || os.Getenv("SWAGGER_DEBUG") != ""
+	// generatorLogger is a debug logger for this package
+	generatorLogger *log.Logger
+)
+
+func init() {
+	debugOptions()
+}
+
+func debugOptions() {
+	generatorLogger = log.New(os.Stdout, "generator:", log.LstdFlags)
+}
 
-func logDebug(frmt string, args ...interface{}) {
+// debugLog wraps log.Printf with a debug-specific logger
+func debugLog(frmt string, args ...interface{}) {
 	if Debug {
-		_, file, pos, _ := runtime.Caller(2)
-		log.Printf("%s:%d: %s", filepath.Base(file), pos, fmt.Sprintf(frmt, args...))
+		_, file, pos, _ := runtime.Caller(1)
+		generatorLogger.Printf("%s:%d: %s", filepath.Base(file), pos,
+			fmt.Sprintf(frmt, args...))
 	}
 }
 
-// debuglog is used to debug the typeResolver (types.go)
-func debugLog(format string, args ...interface{}) {
+// debugLogAsJSON unmarshals its last arg as pretty JSON
+func debugLogAsJSON(frmt string, args ...interface{}) {
 	if Debug {
-		_, file, pos, _ := runtime.Caller(2)
-		log.Printf("%s:%d: "+format, append([]interface{}{filepath.Base(file), pos}, args...)...)
+		_, file, pos, _ := runtime.Caller(1)
+		if len(args) > 0 {
+			bbb, _ := json.MarshalIndent(args[len(args)-1], "", " ")
+			generatorLogger.Printf("%s:%d: %s\n%s", filepath.Base(file), pos,
+				fmt.Sprintf(frmt, args[0:len(args)-1]...), string(bbb))
+		} else {
+			generatorLogger.Printf("%s:%d: %s", filepath.Base(file), pos,
+				fmt.Sprintf(frmt, args...))
+		}
 	}
 }
diff --git a/generator/debug_test.go b/generator/debug_test.go
new file mode 100644
index 00000000..2965a852
--- /dev/null
+++ b/generator/debug_test.go
@@ -0,0 +1,84 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package generator
+
+import (
+	"io/ioutil"
+	"os"
+	"sync"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+var (
+	logMutex = &sync.Mutex{}
+)
+
+func TestDebug(t *testing.T) {
+	// test debugLog()
+	tmpFile, _ := ioutil.TempFile("", "debug-test")
+	tmpName := tmpFile.Name()
+	defer func() {
+		Debug = false
+		// mutex for -race
+		logMutex.Unlock()
+		_ = os.Remove(tmpName)
+	}()
+
+	// mutex for -race
+	logMutex.Lock()
+	Debug = true
+	debugOptions()
+	defer func() {
+		generatorLogger.SetOutput(os.Stdout)
+	}()
+	generatorLogger.SetOutput(tmpFile)
+
+	debugLog("A debug")
+	_ = tmpFile.Close()
+
+	flushed, _ := os.Open(tmpName)
+	buf := make([]byte, 500)
+	_, _ = flushed.Read(buf)
+	assert.Contains(t, string(buf), "A debug")
+	_ = flushed.Close()
+
+	// test debugLogAsJSON()
+	tmpJSONFile, _ := ioutil.TempFile("", "debug-test")
+	tmpJSONName := tmpJSONFile.Name()
+	defer func() {
+		_ = os.Remove(tmpJSONName)
+	}()
+	generatorLogger.SetOutput(tmpJSONFile)
+	debugLogAsJSON("A short debug")
+
+	sch := struct {
+		FieldOne string `json:"fieldOne"`
+	}{
+		FieldOne: "content",
+	}
+	debugLogAsJSON("A long debug:%t", true, sch)
+	_ = tmpJSONFile.Close()
+
+	flushed, _ = os.Open(tmpJSONName)
+	buf2 := make([]byte, 500)
+	_, _ = flushed.Read(buf2)
+	_ = flushed.Close()
+	assert.Contains(t, string(buf2), "A short debug")
+	assert.Contains(t, string(buf2), "A long debug:true")
+	assert.Contains(t, string(buf2), `"fieldOne":`)
+	assert.Contains(t, string(buf2), `"content"`)
+}
diff --git a/generator/model.go b/generator/model.go
index 5dcc2e02..59c2ac52 100644
--- a/generator/model.go
+++ b/generator/model.go
@@ -127,9 +127,7 @@ func (m *definitionGenerator) Generate() error {
 }
 
 func (m *definitionGenerator) generateModel(g *GenDefinition) error {
-	if Debug {
-		log.Printf("rendering definitions for %+v", *g)
-	}
+	debugLog("rendering definitions for %+v", *g)
 	return m.opts.renderDefinition(g)
 }
 
@@ -429,9 +427,7 @@ type schemaGenContext struct {
 }
 
 func (sg *schemaGenContext) NewSliceBranch(schema *spec.Schema) *schemaGenContext {
-	if Debug {
-		log.Printf("new slice branch %s (model: %s)", sg.Name, sg.TypeResolver.ModelName)
-	}
+	debugLog("new slice branch %s (model: %s)", sg.Name, sg.TypeResolver.ModelName)
 	pg := sg.shallowClone()
 	indexVar := pg.IndexVar
 	if pg.Path == "" {
@@ -464,9 +460,7 @@ func (sg *schemaGenContext) NewSliceBranch(schema *spec.Schema) *schemaGenContex
 }
 
 func (sg *schemaGenContext) NewAdditionalItems(schema *spec.Schema) *schemaGenContext {
-	if Debug {
-		log.Printf("new additional items\n")
-	}
+	debugLog("new additional items\n")
 
 	pg := sg.shallowClone()
 	indexVar := pg.IndexVar
@@ -495,9 +489,7 @@ func (sg *schemaGenContext) NewAdditionalItems(schema *spec.Schema) *schemaGenCo
 }
 
 func (sg *schemaGenContext) NewTupleElement(schema *spec.Schema, index int) *schemaGenContext {
-	if Debug {
-		log.Printf("New tuple element\n")
-	}
+	debugLog("New tuple element\n")
 
 	pg := sg.shallowClone()
 	if pg.Path == "" {
@@ -515,9 +507,7 @@ func (sg *schemaGenContext) NewTupleElement(schema *spec.Schema, index int) *sch
 }
 
 func (sg *schemaGenContext) NewStructBranch(name string, schema spec.Schema) *schemaGenContext {
-	if Debug {
-		log.Printf("new struct branch %s (parent %s)", sg.Name, sg.Container)
-	}
+	debugLog("new struct branch %s (parent %s)", sg.Name, sg.Container)
 	pg := sg.shallowClone()
 	if sg.Path == "" {
 		pg.Path = fmt.Sprintf("%q", name)
@@ -533,16 +523,12 @@ func (sg *schemaGenContext) NewStructBranch(name string, schema spec.Schema) *sc
 			break
 		}
 	}
-	if Debug {
-		log.Printf("made new struct branch %s (parent %s)", pg.Name, pg.Container)
-	}
+	debugLog("made new struct branch %s (parent %s)", pg.Name, pg.Container)
 	return pg
 }
 
 func (sg *schemaGenContext) shallowClone() *schemaGenContext {
-	if Debug {
-		log.Printf("cloning context %s\n", sg.Name)
-	}
+	debugLog("cloning context %s\n", sg.Name)
 	pg := new(schemaGenContext)
 	*pg = *sg
 	if pg.Container == "" {
@@ -559,9 +545,7 @@ func (sg *schemaGenContext) shallowClone() *schemaGenContext {
 }
 
 func (sg *schemaGenContext) NewCompositionBranch(schema spec.Schema, index int) *schemaGenContext {
-	if Debug {
-		log.Printf("new composition branch %s (parent: %s, index: %d)", sg.Name, sg.Container, index)
-	}
+	debugLog("new composition branch %s (parent: %s, index: %d)", sg.Name, sg.Container, index)
 	pg := sg.shallowClone()
 	pg.Schema = schema
 	pg.Name = "AO" + strconv.Itoa(index)
@@ -569,16 +553,12 @@ func (sg *schemaGenContext) NewCompositionBranch(schema spec.Schema, index int)
 		pg.Name = sg.Name + pg.Name
 	}
 	pg.Index = index
-	if Debug {
-		log.Printf("made new composition branch %s (parent: %s)", pg.Name, pg.Container)
-	}
+	debugLog("made new composition branch %s (parent: %s)", pg.Name, pg.Container)
 	return pg
 }
 
 func (sg *schemaGenContext) NewAdditionalProperty(schema spec.Schema) *schemaGenContext {
-	if Debug {
-		log.Printf("new additional property %s (expr: %s)", sg.Name, sg.ValueExpr)
-	}
+	debugLog("new additional property %s (expr: %s)", sg.Name, sg.ValueExpr)
 	pg := sg.shallowClone()
 	pg.Schema = schema
 	if pg.KeyVar == "" {
@@ -698,17 +678,13 @@ func (sg *schemaGenContext) MergeResult(other *schemaGenContext, liftsRequired b
 }
 
 func (sg *schemaGenContext) buildProperties() error {
-
-	if Debug {
-		log.Printf("building properties %s (parent: %s)", sg.Name, sg.Container)
-	}
+	debugLog("building properties %s (parent: %s)", sg.Name, sg.Container)
 
 	for k, v := range sg.Schema.Properties {
-		if Debug {
-			bbb, _ := json.MarshalIndent(sg.Schema, "", "  ")
-			log.Printf("building property %s[%q] (tup: %t) (BaseType: %t) %s\n", sg.Name, k, sg.IsTuple, sg.GenSchema.IsBaseType, bbb)
-			log.Printf("property %s[%q] (tup: %t) HasValidations: %t)", sg.Name, k, sg.IsTuple, sg.GenSchema.HasValidations)
-		}
+		debugLogAsJSON("building property %s[%q] (tup: %t) (BaseType: %t) %s",
+			sg.Name, k, sg.IsTuple, sg.GenSchema.IsBaseType, sg.Schema)
+		debugLog("property %s[%q] (tup: %t) HasValidations: %t)",
+			sg.Name, k, sg.IsTuple, sg.GenSchema.HasValidations)
 
 		// check if this requires de-anonymizing, if so lift this as a new struct and extra schema
 		tpe, err := sg.TypeResolver.ResolveSchema(&v, true, sg.IsTuple || containsString(sg.Schema.Required, k))
@@ -883,11 +859,7 @@ func (sg *schemaGenContext) buildAllOf() error {
 	if sg.Container == "" {
 		sg.Container = sg.Name
 	}
-	if Debug {
-		log.Printf("building all of for %d entries", len(sg.Schema.AllOf))
-		b, _ := json.MarshalIndent(sg.Schema, "", "  ")
-		log.Println(string(b))
-	}
+	debugLogAsJSON("building all of for %d entries", len(sg.Schema.AllOf), sg.Schema)
 	for i, sch := range sg.Schema.AllOf {
 		tpe, ert := sg.TypeResolver.ResolveSchema(&sch, sch.Ref.String() == "", false)
 		if ert != nil {
@@ -903,19 +875,14 @@ func (sg *schemaGenContext) buildAllOf() error {
 		} else {
 			hasNonArray++
 		}
-		if Debug {
-			b, _ := json.MarshalIndent(sch, "", "  ")
-			log.Println("trying", string(b))
-		}
+		debugLogAsJSON("trying", sch)
 		if (tpe.IsAnonymous && len(sch.AllOf) > 0) || (sch.Ref.String() == "" && !tpe.IsComplexObject && (tpe.IsArray || tpe.IsInterface || tpe.IsPrimitive)) {
 			// cases where anonymous structures cause the creation of a new type:
 			// - nested allOf: this one is itself a AllOf: build a new type for it
 			// - anonymous simple types for edge cases: array, primitive, interface{}
 			// NOTE: when branches are aliased or anonymous, the nullable property in the branch type is lost.
 			name := swag.ToVarName(goName(&sch, sg.Name+"AllOf"+strconv.Itoa(i)))
-			if Debug {
-				log.Printf("building anonymous nested allOf in %s: %s", sg.Name, name)
-			}
+			debugLog("building anonymous nested allOf in %s: %s", sg.Name, name)
 			ng := sg.makeNewStruct(name, sch)
 			if err := ng.makeGenSchema(); err != nil {
 				return err
@@ -1083,9 +1050,7 @@ func (mt *mapStack) Build() error {
 			mt.Context.GenSchema.AdditionalProperties.HasValidations = true
 		}
 
-		if Debug {
-			log.Printf("early mapstack exit, nullable: %t for %s", cp.GenSchema.IsNullable, cp.GenSchema.Name)
-		}
+		debugLog("early mapstack exit, nullable: %t for %s", cp.GenSchema.IsNullable, cp.GenSchema.Name)
 		return nil
 	}
 	cur := mt
@@ -1219,9 +1184,7 @@ func (sg *schemaGenContext) buildAdditionalProperties() error {
 			}
 			sg.MergeResult(cp, false)
 			sg.GenSchema.AdditionalProperties = &cp.GenSchema
-			if Debug {
-				log.Println("added interface{} schema for additionalProperties[allows == true]", cp.GenSchema.IsInterface)
-			}
+			debugLog("added interface{} schema for additionalProperties[allows == true]", cp.GenSchema.IsInterface)
 		}
 		return nil
 	}
@@ -1351,9 +1314,7 @@ func (sg *schemaGenContext) buildAdditionalProperties() error {
 }
 
 func (sg *schemaGenContext) makeNewStruct(name string, schema spec.Schema) *schemaGenContext {
-	if Debug {
-		log.Println("making new struct", name, sg.Container)
-	}
+	debugLog("making new struct", name, sg.Container)
 	sp := sg.TypeResolver.Doc.Spec()
 	name = swag.ToGoName(name)
 	if sg.TypeResolver.ModelName != sg.Name {
@@ -1627,11 +1588,7 @@ func (sg *schemaGenContext) shortCircuitNamedRef() (bool, error) {
 	if sg.RefHandled || !sg.Named || sg.Schema.Ref.String() == "" {
 		return false, nil
 	}
-	if Debug {
-		log.Printf("short circuit named ref: %q", sg.Schema.Ref.String())
-		b, _ := json.MarshalIndent(sg.Schema, "", "  ")
-		log.Println(string(b))
-	}
+	debugLogAsJSON("short circuit named ref: %q", sg.Schema.Ref.String(), sg.Schema)
 
 	nullableOverride := sg.GenSchema.IsNullable
 	tpe := resolvedType{}
@@ -1694,9 +1651,7 @@ func (sg *schemaGenContext) liftSpecialAllOf() error {
 
 	if seenSchema == 1 {
 		// when there only a single schema to lift in allOf, replace the schema by its allOf definition
-		if Debug {
-			log.Printf("lifted schema in allOf for %s", sg.Name)
-		}
+		debugLog("lifted schema in allOf for %s", sg.Name)
 		sg.Schema = schemaToLift
 		sg.GenSchema.IsNullable = seenNullable
 	}
@@ -1778,7 +1733,8 @@ func (sg *schemaGenContext) buildMapOfNullable(sch *GenSchema) {
 			if elem.IsPrimitive && elem.IsNullable {
 				sg.checkNeedsPointer(outer, nil, elem)
 			} else if elem.IsArray {
-				// override nullability of array of primitive elements: render element of aliased or anonyous map as a pointer
+				// override nullability of array of primitive elements:
+				// render element of aliased or anonyous map as a pointer
 				it := elem.Items
 				for it != nil {
 					if it.IsPrimitive && it.IsNullable {
@@ -1795,11 +1751,8 @@ func (sg *schemaGenContext) buildMapOfNullable(sch *GenSchema) {
 }
 
 func (sg *schemaGenContext) makeGenSchema() error {
-	if Debug {
-		log.Printf("making gen schema (anon: %t, req: %t, tuple: %t) %s\n", !sg.Named, sg.Required, sg.IsTuple, sg.Name)
-		b, _ := json.MarshalIndent(sg.Schema, "", "  ")
-		log.Println(string(b))
-	}
+	debugLogAsJSON("making gen schema (anon: %t, req: %t, tuple: %t) %s\n",
+		!sg.Named, sg.Required, sg.IsTuple, sg.Name, sg.Schema)
 
 	ex := ""
 	if sg.Schema.Example != nil {
@@ -1831,21 +1784,13 @@ func (sg *schemaGenContext) makeGenSchema() error {
 	if returns {
 		return nil
 	}
-	if Debug {
-		log.Println("after short circuit named ref")
-		b, _ := json.MarshalIndent(sg.Schema, "", "  ")
-		log.Println(string(b))
-	}
+	debugLogAsJSON("after short circuit named ref", sg.Schema)
 
 	if e := sg.liftSpecialAllOf(); e != nil {
 		return e
 	}
 	nullableOverride := sg.GenSchema.IsNullable
-	if Debug {
-		log.Println("after lifting special all of")
-		b, _ := json.MarshalIndent(sg.Schema, "", "  ")
-		log.Println(string(b))
-	}
+	debugLogAsJSON("after lifting special all of", sg.Schema)
 
 	if sg.Container == "" {
 		sg.Container = sg.GenSchema.Name
@@ -1864,9 +1809,7 @@ func (sg *schemaGenContext) makeGenSchema() error {
 		return err
 	}
 
-	if Debug {
-		log.Println("gschema rrequired", sg.GenSchema.Required, "nullable", sg.GenSchema.IsNullable)
-	}
+	debugLog("gschema rrequired: %t, nullable: %t", sg.GenSchema.Required, sg.GenSchema.IsNullable)
 	tpe.IsNullable = tpe.IsNullable || nullableOverride
 	sg.GenSchema.resolvedType = tpe
 	sg.GenSchema.IsBaseType = tpe.IsBaseType
@@ -1881,9 +1824,7 @@ func (sg *schemaGenContext) makeGenSchema() error {
 		sg.GenSchema.ValueExpression += "()"
 	}
 
-	if Debug {
-		log.Println("gschema nullable", sg.GenSchema.IsNullable)
-	}
+	debugLog("gschema nullable: %t", sg.GenSchema.IsNullable)
 	if e := sg.buildAdditionalProperties(); e != nil {
 		return e
 	}
@@ -1897,24 +1838,18 @@ func (sg *schemaGenContext) makeGenSchema() error {
 
 	prev := sg.GenSchema
 	if sg.Untyped {
-		if Debug {
-			log.Println("untyped resolve", sg.Named || sg.IsTuple || sg.Required || sg.GenSchema.Required)
-			b, _ := json.MarshalIndent(sg.Schema, "", "  ")
-			log.Println(string(b))
-		}
+		debugLogAsJSON("untyped resolve:%t", sg.Named || sg.IsTuple || sg.Required || sg.GenSchema.Required, sg.Schema)
 		tpe, err = sg.TypeResolver.ResolveSchema(nil, !sg.Named, sg.Named || sg.IsTuple || sg.Required || sg.GenSchema.Required)
 	} else {
-		if Debug {
-			log.Printf("typed resolve, isAnonymous(%t), n: %t, t: %t, sgr: %t, sr: %t, isRequired(%t), BaseType(%t)", !sg.Named, sg.Named, sg.IsTuple, sg.Required, sg.GenSchema.Required, sg.Named || sg.IsTuple || sg.Required || sg.GenSchema.Required, sg.GenSchema.IsBaseType)
-			b, _ := json.MarshalIndent(sg.Schema, "", "  ")
-			log.Println(string(b))
-		}
+		debugLogAsJSON("typed resolve, isAnonymous(%t), n: %t, t: %t, sgr: %t, sr: %t, isRequired(%t), BaseType(%t)",
+			!sg.Named, sg.Named, sg.IsTuple, sg.Required, sg.GenSchema.Required,
+			sg.Named || sg.IsTuple || sg.Required || sg.GenSchema.Required, sg.GenSchema.IsBaseType, sg.Schema)
 		tpe, err = sg.TypeResolver.ResolveSchema(&sg.Schema, !sg.Named, sg.Named || sg.IsTuple || sg.Required || sg.GenSchema.Required)
 	}
 	if err != nil {
 		return err
 	}
-	otn := tpe.IsNullable
+	otn := tpe.IsNullable // for debug only
 	tpe.IsNullable = tpe.IsNullable || nullableOverride
 	sg.GenSchema.resolvedType = tpe
 	sg.GenSchema.IsComplexObject = prev.IsComplexObject
@@ -1922,11 +1857,8 @@ func (sg *schemaGenContext) makeGenSchema() error {
 	sg.GenSchema.IsAdditionalProperties = prev.IsAdditionalProperties
 	sg.GenSchema.IsBaseType = sg.GenSchema.HasDiscriminator
 
-	if Debug {
-		log.Println("gschema nnullable", sg.GenSchema.IsNullable, otn, nullableOverride)
-		b, _ := json.MarshalIndent(sg.Schema, "", "  ")
-		log.Println(string(b))
-	}
+	debugLogAsJSON("gschema nnullable:IsNullable:%t,resolver.IsNullable:%t,nullableOverride:%t",
+		sg.GenSchema.IsNullable, otn, nullableOverride, sg.Schema)
 	if err := sg.buildProperties(); err != nil {
 		return err
 	}
@@ -1949,8 +1881,6 @@ func (sg *schemaGenContext) makeGenSchema() error {
 
 	sg.buildMapOfNullable(nil)
 
-	if Debug {
-		log.Printf("finished gen schema for %q\n", sg.Name)
-	}
+	debugLog("finished gen schema for %q", sg.Name)
 	return nil
 }
diff --git a/generator/model_test.go b/generator/model_test.go
index c417305b..058160ca 100644
--- a/generator/model_test.go
+++ b/generator/model_test.go
@@ -2161,102 +2161,6 @@ func TestGenModel_Issue1341(t *testing.T) {
 	}
 }
 
-// Non-regression when Debug mode activated
-// Run everything again in Debug mode, just to make
-// sure no side effect has been added while debugging
-// TODO: remove it when no more "if Debug {}" branches are
-// present in source code.
-func TestDebugModelEntries(t *testing.T) {
-	Debug = true
-	log.SetOutput(ioutil.Discard)
-	// Verification only: temporarily mute stderr for possible debug logs to stderr
-	//origStdout := os.Stdout
-	//origStderr := os.Stderr
-	//f, err := os.OpenFile("stderr.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
-	//if err != nil {
-	//	panic("Test interrupted: cannot redirect stderr to log file")
-	//}
-	//os.Stdout = ioutil.Discard
-	//os.Stderr = f
-
-	defer func() {
-		log.SetOutput(os.Stdout)
-		//os.Stderr = origStderr
-		Debug = false
-	}()
-
-	TestGenerateModel_Sanity(t)
-	TestGenerateModel_DocString(t)
-	TestGenerateModel_PropertyValidation(t)
-	TestGenerateModel_SchemaField(t)
-	TestGenSchemaType(t)
-	TestGenerateModel_Primitives(t)
-	TestGenerateModel_Nota(t)
-	TestGenerateModel_NotaWithRef(t)
-	TestGenerateModel_NotaWithMeta(t)
-	TestGenerateModel_RunParameters(t)
-	TestGenerateModel_NotaWithName(t)
-	TestGenerateModel_NotaWithRefRegistry(t)
-	TestGenerateModel_WithCustomTag(t)
-	TestGenerateModel_NotaWithMetaRegistry(t)
-	TestGenerateModel_WithMap(t)
-	TestGenerateModel_WithMapInterface(t)
-	TestGenerateModel_WithMapRef(t)
-	TestGenerateModel_WithMapComplex(t)
-	TestGenerateModel_WithMapRegistry(t)
-	TestGenerateModel_WithMapRegistryRef(t)
-	TestGenerateModel_WithMapComplexRegistry(t)
-	TestGenerateModel_WithAdditional(t)
-	TestGenerateModel_JustRef(t)
-	TestGenerateModel_WithRef(t)
-	TestGenerateModel_WithNullableRef(t)
-	TestGenerateModel_Scores(t)
-	TestGenerateModel_JaggedScores(t)
-	TestGenerateModel_Notables(t)
-	TestGenerateModel_Notablix(t)
-	TestGenerateModel_Stats(t)
-	TestGenerateModel_Statix(t)
-	TestGenerateModel_WithItems(t)
-	TestGenerateModel_WithComplexItems(t)
-	TestGenerateModel_WithItemsAndAdditional(t)
-	TestGenerateModel_WithItemsAndAdditional2(t)
-	TestGenerateModel_WithComplexAdditional(t)
-	TestGenerateModel_SimpleTuple(t)
-	TestGenerateModel_TupleWithExtra(t)
-	TestGenerateModel_TupleWithComplex(t)
-	TestGenerateModel_WithTuple(t)
-	TestGenerateModel_WithTupleWithExtra(t)
-	TestGenerateModel_WithAllOfAndDiscriminator(t)
-	TestGenerateModel_WithAllOfAndDiscriminatorAndArrayOfPolymorphs(t)
-	TestGenerateModel_WithAllOf(t)
-	TestNumericKeys(t)
-	TestGenModel_Issue196(t)
-	TestGenModel_Issue222(t)
-	TestGenModel_Issue243(t)
-	TestGenModel_Issue252(t)
-	TestGenModel_Issue251(t)
-	TestGenModel_Issue257(t)
-	TestGenModel_Issue340(t)
-	TestGenModel_Issue381(t)
-	TestGenModel_Issue300(t)
-	TestGenModel_Issue398(t)
-	TestGenModel_Issue454(t)
-	TestGenModel_Issue423(t)
-	TestGenModel_Issue453(t)
-	TestGenModel_Issue455(t)
-	TestGenModel_Issue763(t)
-	TestGenModel_Issue811_NullType(t)
-	TestGenModel_Issue811_Emojis(t)
-	TestGenModel_Issue752_EOFErr(t)
-	TestImports_ExistingModel(t)
-	TestGenModel_Issue786(t)
-	TestGenModel_Issue822(t)
-	TestGenModel_Issue981(t)
-	TestGenModel_Issue774(t)
-	TestGenModel_Issue1341(t)
-	Debug = false
-}
-
 // This tests to check that format validation is performed on non required schema properties
 func TestGenModel_Issue1347(t *testing.T) {
 	specDoc, err := loads.Spec("../fixtures/bugs/1347/fixture-1347.yaml")
diff --git a/generator/operation.go b/generator/operation.go
index 40405d7f..6c89527c 100644
--- a/generator/operation.go
+++ b/generator/operation.go
@@ -18,7 +18,6 @@ import (
 	"encoding/json"
 	"errors"
 	"fmt"
-	"log"
 	"os"
 	"path/filepath"
 	"sort"
@@ -304,9 +303,7 @@ func renameTimeout(seenIds map[string][]string, current string) string {
 }
 
 func (b *codeGenOpBuilder) MakeOperation() (GenOperation, error) {
-	if Debug {
-		log.Printf("[%s %s] parsing operation (id: %q)", b.Method, b.Path, b.Operation.ID)
-	}
+	debugLog("[%s %s] parsing operation (id: %q)", b.Method, b.Path, b.Operation.ID)
 	// NOTE: we assume flatten is enabled by default (i.e. complex constructs are resolved from the models package),
 	// but do not assume the spec is necessarily fully flattened (i.e. all schemas moved to definitions).
 	//
@@ -559,9 +556,7 @@ func concatUnique(collections ...[]string) []string {
 }
 
 func (b *codeGenOpBuilder) MakeResponse(receiver, name string, isSuccess bool, resolver *typeResolver, code int, resp spec.Response) (GenResponse, error) {
-	if Debug {
-		log.Printf("[%s %s] making id %q", b.Method, b.Path, b.Operation.ID)
-	}
+	debugLog("[%s %s] making id %q", b.Method, b.Path, b.Operation.ID)
 
 	// assume minimal flattening has been carried on, so there is not $ref in response (but some may remain in response schema)
 
@@ -715,9 +710,7 @@ func (b *codeGenOpBuilder) MakeParameterItem(receiver, paramName, indexVar, path
 }
 
 func (b *codeGenOpBuilder) MakeParameter(receiver string, resolver *typeResolver, param spec.Parameter, idMapping map[string]map[string]string) (GenParameter, error) {
-	if Debug {
-		log.Printf("[%s %s] making parameter %q", b.Method, b.Path, param.Name)
-	}
+	debugLog("[%s %s] making parameter %q", b.Method, b.Path, param.Name)
 
 	// assume minimal flattening has been carried on, so there is not $ref in response (but some may remain in response schema)
 
diff --git a/generator/shared.go b/generator/shared.go
index 70b3cf7d..7a4b42fe 100644
--- a/generator/shared.go
+++ b/generator/shared.go
@@ -600,9 +600,7 @@ func (g *GenOpts) render(t *TemplateOpts, data interface{}) ([]byte, error) {
 	if err := templ.Execute(&tBuf, data); err != nil {
 		return nil, fmt.Errorf("template execution failed for template %s: %v", t.Name, err)
 	}
-	//if Debug {
 	log.Printf("executed template %s", t.Source)
-	//}
 
 	return tBuf.Bytes(), nil
 }
@@ -618,9 +616,8 @@ func (g *GenOpts) write(t *TemplateOpts, data interface{}) error {
 	}
 
 	if t.SkipExists && fileExists(dir, fname) {
-		if Debug {
-			log.Printf("skipping generation of %s because it already exists and skip_exist directive is set for %s", filepath.Join(dir, fname), t.Name)
-		}
+		debugLog("skipping generation of %s because it already exists and skip_exist directive is set for %s",
+			filepath.Join(dir, fname), t.Name)
 		return nil
 	}
 
@@ -633,9 +630,7 @@ func (g *GenOpts) write(t *TemplateOpts, data interface{}) error {
 	if dir != "" {
 		_, exists := os.Stat(dir)
 		if os.IsNotExist(exists) {
-			if Debug {
-				log.Printf("creating directory %q for \"%s\"", dir, t.Name)
-			}
+			debugLog("creating directory %q for \"%s\"", dir, t.Name)
 			// Directory settings consistent with file privileges.
 			// Environment's umask may alter this setup
 			if e := os.MkdirAll(dir, 0755); e != nil {
@@ -955,12 +950,13 @@ func validateAndFlattenSpec(opts *GenOpts, specDoc *loads.Document) (*loads.Docu
 	//
 	// Eventually, an "expand spec" option is available. It is essentially useful for testing purposes.
 	//
-	// NOTE(fredbi): spec expansion may produce some unsupported constructs and is not yet protected against the following cases:
+	// NOTE(fredbi): spec expansion may produce some unsupported constructs and is not yet protected against the
+	// following cases:
 	//  - polymorphic types generation may fail with expansion (expand destructs the reuse intent of the $ref in allOf)
 	//  - name duplicates may occur and result in compilation failures
 	// The right place to fix these shortcomings is go-openapi/analysis.
 
-	opts.FlattenOpts.BasePath = absBasePath // BasePath must be absolute. This is guaranteed because opts.Spec is absolute
+	opts.FlattenOpts.BasePath = absBasePath // BasePath must be absolute. This is guaranteed as opts.Spec is absolute
 	opts.FlattenOpts.Spec = analysis.New(specDoc.Spec())
 
 	var preprocessingOption string
diff --git a/generator/types.go b/generator/types.go
index 3df91d6b..738176ca 100644
--- a/generator/types.go
+++ b/generator/types.go
@@ -18,7 +18,6 @@ import (
 	"fmt"
 	"log"
 	"path/filepath"
-	"runtime"
 	"strings"
 
 	"github.com/go-openapi/loads"
@@ -210,19 +209,14 @@ func (t *typeResolver) IsNullable(schema *spec.Schema) bool {
 
 func (t *typeResolver) resolveSchemaRef(schema *spec.Schema, isRequired bool) (returns bool, result resolvedType, err error) {
 	if schema.Ref.String() != "" {
-		if Debug {
-			_, file, pos, _ := runtime.Caller(1)
-			log.Printf("%s:%d: resolving ref (anon: %t, req: %t) %s\n", filepath.Base(file), pos, false, isRequired, schema.Ref.String())
-		}
+		debugLog("resolving ref (anon: %t, req: %t) %s", false, isRequired, schema.Ref.String())
 		returns = true
 		var ref *spec.Schema
 		var er error
 
 		ref, er = spec.ResolveRef(t.Doc.Spec(), &schema.Ref)
 		if er != nil {
-			if Debug {
-				log.Printf("error resolving ref %s: %v", schema.Ref.String(), er)
-			}
+			debugLog("error resolving ref %s: %v", schema.Ref.String(), er)
 			err = er
 			return
 		}
@@ -235,9 +229,7 @@ func (t *typeResolver) resolveSchemaRef(schema *spec.Schema, isRequired bool) (r
 
 		tn := filepath.Base(schema.Ref.GetURL().Fragment)
 		tpe, pkg, alias := knownDefGoType(tn, *ref, t.goTypeName)
-		if Debug {
-			log.Printf("type name %s, package %s, alias %s", tpe, pkg, alias)
-		}
+		debugLog("type name %s, package %s, alias %s", tpe, pkg, alias)
 		if tpe != "" {
 			result.GoType = tpe
 			result.Pkg = pkg
@@ -264,10 +256,7 @@ func (t *typeResolver) inferAliasing(result *resolvedType, schema *spec.Schema,
 func (t *typeResolver) resolveFormat(schema *spec.Schema, isAnonymous bool, isRequired bool) (returns bool, result resolvedType, err error) {
 
 	if schema.Format != "" {
-		if Debug {
-			_, file, pos, _ := runtime.Caller(1)
-			log.Printf("%s:%d: resolving format (anon: %t, req: %t)\n", filepath.Base(file), pos, isAnonymous, isRequired) //, bbb)
-		}
+		debugLog("resolving format (anon: %t, req: %t)", isAnonymous, isRequired)
 		schFmt := strings.Replace(schema.Format, "-", "", -1)
 		if tpe, ok := typeMapping[schFmt]; ok {
 			returns = true
@@ -335,10 +324,7 @@ func (t *typeResolver) firstType(schema *spec.Schema) string {
 }
 
 func (t *typeResolver) resolveArray(schema *spec.Schema, isAnonymous, isRequired bool) (result resolvedType, err error) {
-	if Debug {
-		_, file, pos, _ := runtime.Caller(1)
-		log.Printf("%s:%d: resolving array (anon: %t, req: %t)\n", filepath.Base(file), pos, isAnonymous, isRequired) //, bbb)
-	}
+	debugLog("resolving array (anon: %t, req: %t)", isAnonymous, isRequired)
 
 	result.IsArray = true
 	result.IsNullable = false
@@ -409,10 +395,7 @@ func (t *typeResolver) goTypeName(nm string) string {
 }
 
 func (t *typeResolver) resolveObject(schema *spec.Schema, isAnonymous bool) (result resolvedType, err error) {
-	if Debug {
-		_, file, pos, _ := runtime.Caller(1)
-		log.Printf("%s:%d: resolving object %s (anon: %t, req: %t)\n", filepath.Base(file), pos, t.ModelName, isAnonymous, false) //, bbb)
-	}
+	debugLog("resolving object %s (anon: %t, req: %t)", t.ModelName, isAnonymous, false)
 
 	result.IsAnonymous = isAnonymous
 
@@ -617,7 +600,7 @@ func boolExtension(ext spec.Extensions, key string) *bool {
 }
 
 func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequired bool) (result resolvedType, err error) {
-	logDebug("resolving schema (anon: %t, req: %t) %s\n", isAnonymous, isRequired, t.ModelName)
+	debugLog("resolving schema (anon: %t, req: %t) %s", isAnonymous, isRequired, t.ModelName)
 	if schema == nil {
 		result.IsInterface = true
 		result.GoType = iface
@@ -630,9 +613,9 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 		if !isAnonymous {
 			result.IsMap = false
 			result.IsComplexObject = true
-			logDebug("not anonymous ref")
+			debugLog("not anonymous ref")
 		}
-		logDebug("returning after ref")
+		debugLog("returning after ref")
 		return
 	}
 
@@ -648,7 +631,7 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 
 	returns, result, err = t.resolveFormat(schema, isAnonymous, isRequired)
 	if returns {
-		logDebug("returning after resolve format: %s", pretty.Sprint(result))
+		debugLog("returning after resolve format: %s", pretty.Sprint(result))
 		return
 	}
 
