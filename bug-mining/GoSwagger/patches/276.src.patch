diff --git a/fixtures/bugs/2116/.gitignore b/fixtures/bugs/2116/.gitignore
new file mode 100644
index 00000000..1e16265b
--- /dev/null
+++ b/fixtures/bugs/2116/.gitignore
@@ -0,0 +1,3 @@
+gen-*
+!gen-fixtures.sh
+*.log
diff --git a/fixtures/bugs/2116/fixture-2116.yaml b/fixtures/bugs/2116/fixture-2116.yaml
new file mode 100644
index 00000000..ed451b19
--- /dev/null
+++ b/fixtures/bugs/2116/fixture-2116.yaml
@@ -0,0 +1,123 @@
+swagger: "2.0"
+info:
+  title: ""
+  version: ""
+paths:
+  /:
+    get:
+      description: ""
+      responses:
+        200:
+          description: ""
+definitions:
+  Case-1--Fail--omitempty-false-not-hoisted-by-ref:
+    type: object
+    properties:
+      Body:
+        $ref: '#/definitions/Object-with-omitempty-false'
+
+  Case-2--Fail--omitempty-false-not-overridden-by-ref-sibling:
+    type: object
+    properties:
+      Body:
+        $ref: '#/definitions/Object-with-omitempty-true'
+        x-omitempty: false
+
+  Case-3--Pass--object-nullable-false-hoisted-by-ref:
+    type: object
+    properties:
+      Body:
+        $ref: '#/definitions/Object-with-nullable-false'
+
+  Case-4--Pass--object-nullable-false-overriden-by-ref-sibling:
+    type: object
+    properties:
+      Body:
+        $ref: '#/definitions/Object-with-nullable-true'
+        x-nullable: false
+
+  Object-with-omitempty-true:
+    type: object
+    properties:
+      Data:
+        type: object
+
+  Object-with-omitempty-false:
+    type: object
+    properties:
+      Data:
+        type: object
+    x-omitempty: false
+
+  Object-with-nullable-true:
+    type: object
+    properties:
+      Data:
+        type: object
+    x-nullable: true
+
+  Object-with-nullable-false:
+    type: object
+    properties:
+      Data:
+        type: object
+    x-nullable: false
+
+  arrayWithNullable:
+    type: array
+    items:
+      type: string
+    x-nullable: true
+
+  arrayWithNullableItems:
+    type: array
+    items:
+      type: string
+      x-nullable: true
+
+  arrayWithDefault:
+    type: array
+    items:
+      type: string
+
+  arrayWithOmitEmpty:
+    type: array
+    items:
+      type: string
+    x-omitempty: true
+
+  arrayWithNoOmitEmpty:
+    type: array
+    items:
+      type: string
+    x-omitempty: false
+
+  arrayWithOmitEmptyItems:
+    type: array
+    items:
+      type: string
+      x-omitempty: false
+
+  objectWithArrays:
+    type: object
+    properties:
+      array0: # <- expect property to be omit empty
+        $ref: '#/definitions/arrayWithDefault'
+      array1: # <- expect property to be no omit empty
+        type: array
+        items:
+          type: string
+        x-omitempty: false
+      array11: # <- expect property to be omit empty
+        type: array
+        items:
+          type: string
+        x-omitempty: true
+      array12: # <- expect property to be no omit empty
+        type: array
+        items:
+          type: string
+      array2: # <- expect property to be omit empty
+        $ref: '#/definitions/arrayWithOmitEmpty'
+      array3: # <- expect property to be no omit empty
+        $ref: '#/definitions/arrayWithNoOmitEmpty'
diff --git a/fixtures/bugs/2116/gen-fixtures.sh b/fixtures/bugs/2116/gen-fixtures.sh
new file mode 100755
index 00000000..9d08c679
--- /dev/null
+++ b/fixtures/bugs/2116/gen-fixtures.sh
@@ -0,0 +1,74 @@
+#! /bin/bash
+if [[ ${1} == "--clean" ]] ; then
+    clean=1
+fi
+continueOnError=
+# A small utility to build fixture servers
+# Fixtures with models only
+testcases="${testcases} fixture-2116.yaml"
+for opts in  "" "--with-expand" ; do
+for testcase in ${testcases} ; do
+    grep -q discriminator ${testcase}
+    discriminated=$?
+    if [[ ${discriminated} -eq 0 && ${opts} == "--with-expand" ]] ; then
+        echo "Skipped ${testcase} with ${opts}: discriminator not supported with ${opts}"
+        continue
+    fi
+    if [[ ${testcase} == "../1479/fixture-1479-part.yaml" && ${opts} == "--with-expand" ]] ; then
+        echo "Skipped ${testcase} with ${opts}: known issue with enum in anonymous allOf not validated. See you next PR"
+        continue
+    fi
+
+    spec=${testcase}
+    testcase=`basename ${testcase}`
+    if [[ -z ${opts} ]]; then
+        target=./gen-${testcase%.*}-flatten
+    else
+        target=./gen-${testcase%.*}-expand
+    fi
+    serverName="codegensrv"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Model generation for ${spec} with opts=${opts}"
+    serverName="nrcodegen"
+    swagger generate server --skip-validation ${opts} --spec ${spec} --target ${target} --name=${serverName} 1>${testcase%.*}.log 2>&1
+    # 1>x.log 2>&1
+    #
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        if [[ ! -z ${continueOnError} ]] ; then
+            failures="${failures} codegen:${spec}"
+            continue
+        else
+            exit 1
+        fi
+    fi
+    echo "${spec}: Generation OK"
+    if [[ ! -d ${target}/models ]] ; then
+        echo "No model in this spec! Continue building server"
+    fi
+    if [[ -d ${target}/cmd/${serverName}"-server" ]] ; then
+        (cd ${target}/cmd/${serverName}"-server"; go build)
+        #(cd ${target}/models; go build)
+        if [[ $? != 0 ]] ; then
+            echo "Build failed for ${spec}"
+            if [[ ! -z ${continueOnError} ]] ; then
+                failures="${failures} build:${spec}"
+                continue
+            else
+                exit 1
+            fi
+        fi
+        echo "${spec}: Build OK"
+        if [[ -n ${clean} ]] ; then
+             rm -rf ${target}
+        fi
+    fi
+done
+done
+if [[ ! -z ${failures} ]] ; then
+    echo ${failures}|tr ' ' '\n'
+else
+    echo "No failures"
+fi
+exit
diff --git a/fixtures/enhancements/1623/swagger.yml b/fixtures/enhancements/1623/swagger.yml
index cb1da6f5..d7537415 100644
--- a/fixtures/enhancements/1623/swagger.yml
+++ b/fixtures/enhancements/1623/swagger.yml
@@ -49,10 +49,10 @@ definitions:
         x-omitempty: false
       generalNoOmitEmpty:
         type: string
-      refHasOmitEmptyTrue:
+      refHasOmitEmptyTrue: # <- discarded ($ref siblings are ignored, however, true is the default)
         x-omitempty: true
         $ref: "#/definitions/bar"
-      refHasOmitEmptyFalse:
+      refHasOmitEmptyFalse:  # <- discarded ($ref siblings are ignored)
         x-omitempty: false
         $ref: "#/definitions/bar"
       refNoOmitEmpty:
diff --git a/generator/model_test.go b/generator/model_test.go
index 9f442901..10233821 100644
--- a/generator/model_test.go
+++ b/generator/model_test.go
@@ -2487,7 +2487,7 @@ func TestGenModel_Issue1623(t *testing.T) {
 	assertInCode(t, "GeneralHasOmitEmptyFalse string `json:\"generalHasOmitEmptyFalse\"`", res)
 	assertInCode(t, "GeneralHasOmitEmptyTrue string `json:\"generalHasOmitEmptyTrue,omitempty\"`", res)
 	assertInCode(t, "GeneralNoOmitEmpty string `json:\"generalNoOmitEmpty,omitempty\"`", res)
-	assertInCode(t, "RefHasOmitEmptyFalse Bar `json:\"refHasOmitEmptyFalse\"`", res)
+	assertInCode(t, "RefHasOmitEmptyFalse Bar `json:\"refHasOmitEmptyFalse,omitempty\"`", res)
 	assertInCode(t, "RefHasOmitEmptyTrue Bar `json:\"refHasOmitEmptyTrue,omitempty\"`", res)
 	assertInCode(t, "RefNoOmitEmpty Bar `json:\"refNoOmitEmpty,omitempty\"`", res)
 	assertInCode(t, "IntHasJSONString int64 `json:\"intHasJsonString,omitempty,string\"`", res)
diff --git a/generator/moreschemavalidation_fixtures_test.go b/generator/moreschemavalidation_fixtures_test.go
index 2181dbbe..02529490 100644
--- a/generator/moreschemavalidation_fixtures_test.go
+++ b/generator/moreschemavalidation_fixtures_test.go
@@ -14,6 +14,76 @@
 
 package generator
 
+func initFixture2116() {
+	f := newModelFixture("../fixtures/bugs/2116/fixture-2116.yaml", "check x-omitempty and x-nullable with $ref")
+	flattenRun := f.AddRun(false).WithMinimalFlatten(true)
+
+	flattenRun.AddExpectations("case1_fail_omitempty_false_not_hoisted_by_ref.go", []string{
+		"Body *ObjectWithOmitemptyFalse `json:\"Body\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("case2_fail_omitempty_false_not_overridden_by_ref_sibling.go", []string{
+		"Body *ObjectWithOmitemptyTrue `json:\"Body,omitempty\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("case3_pass_object_nullable_false_hoisted_by_ref.go", []string{
+		"Body ObjectWithNullableFalse `json:\"Body,omitempty\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("case4_pass_object_nullable_false_overriden_by_ref_sibling.go", []string{
+		"Body *ObjectWithNullableTrue `json:\"Body,omitempty\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("array_with_default.go", []string{
+		"type ArrayWithDefault []string",
+	}, append(todo, "omitempty"), noLines, noLines)
+
+	flattenRun.AddExpectations("array_with_no_omit_empty.go", []string{
+		"type ArrayWithNoOmitEmpty []string",
+	}, append(todo, "omitempty"), noLines, noLines)
+
+	flattenRun.AddExpectations("array_with_nullable.go", []string{
+		"type ArrayWithNullable []string",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("array_with_nullable_items.go", []string{
+		"type ArrayWithNullableItems []*string",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("array_with_omit_empty.go", []string{
+		"type ArrayWithOmitEmpty []string",
+	}, append(todo, "omitempty"), noLines, noLines)
+
+	flattenRun.AddExpectations("object_with_arrays.go", []string{
+		"Array0 ArrayWithDefault `json:\"array0,omitempty\"`",
+		"Array1 []string `json:\"array1\"`",
+		"Array11 []string `json:\"array11,omitempty\"`",
+		"Array12 []string `json:\"array12\"`",
+		"Array2 ArrayWithOmitEmpty `json:\"array2,omitempty\"`",
+		"Array3 ArrayWithNoOmitEmpty `json:\"array3\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("object_with_nullable_false.go", []string{
+		"Data interface{} `json:\"Data,omitempty\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("object_with_nullable_true.go", []string{
+		"Data interface{} `json:\"Data,omitempty\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("object_with_omitempty_false.go", []string{
+		"Data interface{} `json:\"Data,omitempty\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("object_with_omitempty_true.go", []string{
+		"Data interface{} `json:\"Data,omitempty\"`",
+	}, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("array_with_omit_empty_items.go", []string{
+		"type ArrayWithOmitEmptyItems []string",
+	}, append(todo, "omitempty"), noLines, noLines)
+}
+
 func initFixture2071() {
 	f := newModelFixture("../fixtures/bugs/2071/fixture-2071.yaml", "check allOf serializer when x-go-name is present")
 	flattenRun := f.AddRun(false).WithMinimalFlatten(true)
diff --git a/generator/moreschemavalidation_test.go b/generator/moreschemavalidation_test.go
index 8ba4eead..0dd9d597 100644
--- a/generator/moreschemavalidation_test.go
+++ b/generator/moreschemavalidation_test.go
@@ -206,6 +206,9 @@ func initModelFixtures() {
 
 	// allOf marshallers
 	initFixture2071()
+
+	// x-omitempty
+	initFixture2116()
 }
 
 /* Template initTxxx() to prepare and load a fixture:
@@ -338,7 +341,8 @@ func TestMoreModelValidations(t *testing.T) {
 						// please do not inject fixtures with case conflicts on defs...
 						// this one is just easier to retrieve model back from file names when capturing
 						// the generated code.
-						if strings.EqualFold(def, k) {
+						mangled := swag.ToJSONName(def)
+						if strings.EqualFold(mangled, k) {
 							schema = &s
 							definitionName = def
 							break
diff --git a/generator/types.go b/generator/types.go
index a80d75bb..75deeca4 100644
--- a/generator/types.go
+++ b/generator/types.go
@@ -222,40 +222,38 @@ func (t *typeResolver) IsNullable(schema *spec.Schema) bool {
 }
 
 func (t *typeResolver) resolveSchemaRef(schema *spec.Schema, isRequired bool) (returns bool, result resolvedType, err error) {
-	if schema.Ref.String() != "" {
-		debugLog("resolving ref (anon: %t, req: %t) %s", false, isRequired, schema.Ref.String())
-		returns = true
-		var ref *spec.Schema
-		var er error
-
-		ref, er = spec.ResolveRef(t.Doc.Spec(), &schema.Ref)
-		if er != nil {
-			debugLog("error resolving ref %s: %v", schema.Ref.String(), er)
-			err = er
-			return
-		}
-		res, er := t.ResolveSchema(ref, false, isRequired)
-		if er != nil {
-			err = er
-			return
-		}
-		result = res
+	if schema.Ref.String() == "" {
+		return
+	}
+	debugLog("resolving ref (anon: %t, req: %t) %s", false, isRequired, schema.Ref.String())
+	returns = true
+	var ref *spec.Schema
+	var er error
 
-		tn := filepath.Base(schema.Ref.GetURL().Fragment)
-		tpe, pkg, alias := knownDefGoType(tn, *ref, t.goTypeName)
-		debugLog("type name %s, package %s, alias %s", tpe, pkg, alias)
-		if tpe != "" {
-			result.GoType = tpe
-			result.Pkg = pkg
-			result.PkgAlias = alias
-		}
-		result.HasDiscriminator = res.HasDiscriminator
-		result.IsBaseType = result.HasDiscriminator
-		result.IsNullable = t.IsNullable(ref)
-		//result.IsAliased = true
+	ref, er = spec.ResolveRef(t.Doc.Spec(), &schema.Ref)
+	if er != nil {
+		debugLog("error resolving ref %s: %v", schema.Ref.String(), er)
+		err = er
+		return
+	}
+	res, er := t.ResolveSchema(ref, false, isRequired)
+	if er != nil {
+		err = er
 		return
+	}
+	result = res
 
+	tn := filepath.Base(schema.Ref.GetURL().Fragment)
+	tpe, pkg, alias := knownDefGoType(tn, *ref, t.goTypeName)
+	debugLog("type name %s, package %s, alias %s", tpe, pkg, alias)
+	if tpe != "" {
+		result.GoType = tpe
+		result.Pkg = pkg
+		result.PkgAlias = alias
 	}
+	result.HasDiscriminator = res.HasDiscriminator
+	result.IsBaseType = result.HasDiscriminator
+	result.IsNullable = t.IsNullable(ref)
 	return
 }
 
@@ -329,32 +327,6 @@ func (t *typeResolver) isNullable(schema *spec.Schema) bool {
 	return len(schema.Properties) > 0
 }
 
-func setIsEmptyOmitted(result *resolvedType, schema *spec.Schema, tpe string) {
-	defaultValue := true
-	if tpe == array {
-		defaultValue = false
-	}
-	v, found := schema.Extensions[xOmitEmpty]
-	if !found {
-		result.IsEmptyOmitted = defaultValue
-		return
-	}
-
-	omitted, cast := v.(bool)
-	result.IsEmptyOmitted = omitted && cast
-}
-
-func setIsJSONString(result *resolvedType, schema *spec.Schema, tpe string) {
-
-	_, found := schema.Extensions[xGoJSONString]
-	if !found {
-		result.IsJSONString = false
-		return
-	}
-
-	result.IsJSONString = true
-}
-
 func (t *typeResolver) firstType(schema *spec.Schema) string {
 	if len(schema.Type) == 0 || schema.Type[0] == "" {
 		return object
@@ -652,9 +624,8 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 	}
 
 	tpe := t.firstType(schema)
-	defer setIsEmptyOmitted(&result, schema, tpe)
-
 	var returns bool
+
 	returns, result, err = t.resolveSchemaRef(schema, isRequired)
 	if returns {
 		if !isAnonymous {
@@ -665,7 +636,10 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 		debugLog("returning after ref")
 		return
 	}
-	defer setIsJSONString(&result, schema, tpe)
+	defer func() {
+		result.setIsEmptyOmitted(schema, tpe)
+		result.setIsJSONString(schema, tpe)
+	}()
 
 	// special case of swagger type "file", rendered as io.ReadCloser interface
 	if t.firstType(schema) == file {
@@ -818,3 +792,22 @@ func (rt *resolvedType) Zero() string {
 
 	return ""
 }
+
+func (rt *resolvedType) setIsEmptyOmitted(schema *spec.Schema, tpe string) {
+	if v, found := schema.Extensions[xOmitEmpty]; found {
+		omitted, cast := v.(bool)
+		rt.IsEmptyOmitted = omitted && cast
+		return
+	}
+	// array of primitives are by default not empty-omitted, but arrays of aliased type are
+	rt.IsEmptyOmitted = (tpe != array) || (tpe == array && rt.IsAliased)
+}
+
+func (rt *resolvedType) setIsJSONString(schema *spec.Schema, tpe string) {
+	_, found := schema.Extensions[xGoJSONString]
+	if !found {
+		rt.IsJSONString = false
+		return
+	}
+	rt.IsJSONString = true
+}
