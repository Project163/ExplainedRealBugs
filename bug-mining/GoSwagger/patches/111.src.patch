diff --git a/.drone.sec b/.drone.sec
index 9d73ed8b..4e35199d 100644
--- a/.drone.sec
+++ b/.drone.sec
@@ -1 +1 @@
-eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkExMjhHQ00ifQ.OWh8sYNxpnVAw3X76JtsWh7eMJdQD0wEkoaQh2aulfhNcRdFK074V6bPP5SPZJTpl4FOZyJaXnRZclmBzZBsCchieyceruB4IrhObWprpEZJHq7h9mJoIUwHXWfj5_Ui3XBjOEp4gCsK3Zda2KTTtdunfjRmMh7rIaYBit_H738mBGmm0kxcV2SUMm1c_X-S71DkBdjsZ9HtTP6vCX1MPWQlCNPmte_FJfMejW0TuzBJG3e2iQP1054vK7_eY2QvFjVDBh-vmeHJUk2zhCsLtUsat86pCPOP7vxcBH4v3t9UvOrwUSjYG3ITND2LLTUXQnnz-iBAJviRd53XOqNz2Q.cJ7XFjV7qThCP3D1.AmCBE7bSmv7X6KEC-z4fBVd7moJTcGCP4PPZu4YnVIOXORmPgT0s2Rxg9fl2-XbXO6wB-VO7nEqIIBiyZGgD8ElXrtQPtGz1AFRK_fT-Leqk_QzvUu1XfclV18iuKCic-M5UTwhBQxn2JT-3GAR7yc_eRdk8yMCKsdpyGgl8c5vMnyMwOsF2lliW1nTLyUfGRMG7PyxMxzxFr_ngJZLWtBYzt8wJbbMNgCwwy6yFqr5RcD3L05_7yZc5FqFQtG3EBE3hUjLLzNZef93vHNE9Qkaa9OY76EbeRvWBHTBwOCLDsw.9eS-9yHgcG29GB4-LMeNIw
\ No newline at end of file
+eyJhbGciOiJSU0EtT0FFUCIsImVuYyI6IkExMjhHQ00ifQ.i8WvqP8NrhmLA3oXi2LaXtEe_5xf1KUAb9EWSgo5cGmcZ8VZLFXqnNZH1xiapd_VK-gjrR3otg_BvIytSJKn1GigfmTHxPX2zGEIj1jXKKXcGGf_NVd_rmmewAGXulvbXlexWh18aPrLvI8gcwmY2AO9eJKQAk2FaoDhqoQfgnu6vLaqgK-qqlRw79T-cYiWx8T5w3uNV9PfYx077G8Fc8XSgCkUh7ZWCXPxbHeFTJIrti0ZRP0hv-vlvht7eXwj4UVKhBAeN0kewru5wBRPYy8NSqn4PXuNVDm3LUpK3PuId2eUBTBIRz9A86Tsq6p7R3hkIm1zbQtNlhFdPcOI_w.UMDpRaPo9qK30u1s.kTf49Y35eihCfFnOT_ADkwRx_h0UtWJS8aOMX-qDKgZkuXMnOm3q6qARbgweoiSCNTZa7oGRMFBr-uQfLetg8MNEfMctimAW5Dpwq4jViHD6OWyiuJP6sKHKxau0xxyjwlX6KkovX5Lj6Br27mKtC2ygHmVGL2GlnbKvouRe8fgcy1Yt1hC4ti2uq1xxGBmqxEJiqM7HRP065MqnXaycTB8Oo5IItn-1otJPdRb82bg7xs4cAi0l4xjCmDjjV7f9678Ma3kMpszkPO2kqiE5NwdkGy5B1-xNPG4XbYJHBo18ag.qNsqv-389tl5wOTd-_-Zvg
\ No newline at end of file
diff --git a/.drone.yml b/.drone.yml
index 9b67346f..0b2102a4 100644
--- a/.drone.yml
+++ b/.drone.yml
@@ -3,7 +3,7 @@ clone:
 
 matrix:
   GO_VERSION:
-    # - "1.5"
+    - "1.5"
     - "1.6"
 
 build:
@@ -45,7 +45,7 @@ publish:
   github_release:
     api_key: $$GITHUB_TOKEN
     files:
-      - dist/binaries/swagger_*
+      - /go/src/github.com/go-swagger/go-swagger/dist/binaries/swagger_*
     when:
       event: tag
       matrix:
diff --git a/cmd/swagger/commands/version_number.go b/cmd/swagger/commands/version_number.go
index 1193f062..a2937699 100644
--- a/cmd/swagger/commands/version_number.go
+++ b/cmd/swagger/commands/version_number.go
@@ -1,6 +1,6 @@
 package commands
 
 func init() {
-  Version = "0.2.6"
+  Version = "0.2.2"
 }
 
diff --git a/fixtures/bugs/264/swagger.yml b/fixtures/bugs/264/swagger.yml
new file mode 100644
index 00000000..e26cd855
--- /dev/null
+++ b/fixtures/bugs/264/swagger.yml
@@ -0,0 +1,21 @@
+swagger: '2.0'
+info:
+  version: 1.0.0
+  title: 'Test'
+schemes:
+  - http
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /key/{id}:
+    delete:
+      parameters:
+        - name: id
+          in: path
+          type: integer
+          required: true
+      responses:
+        '200':
+          description: OK
diff --git a/httpkit/headers.go b/httpkit/headers.go
index 7f85786d..8f083c2b 100644
--- a/httpkit/headers.go
+++ b/httpkit/headers.go
@@ -22,12 +22,15 @@ import (
 )
 
 // ContentType parses a content type header
-func ContentType(headers http.Header) (string, string, *errors.ParseError) {
+func ContentType(headers http.Header, optional bool) (string, string, *errors.ParseError) {
 	ct := headers.Get(HeaderContentType)
 	orig := ct
-	if ct == "" {
+	if ct == "" && !optional {
 		ct = DefaultMime
 	}
+	if ct == "" {
+		return "", "", nil
+	}
 
 	mt, opts, err := mime.ParseMediaType(ct)
 	if err != nil {
diff --git a/httpkit/headers_test.go b/httpkit/headers_test.go
index 13080415..cafb8782 100644
--- a/httpkit/headers_test.go
+++ b/httpkit/headers_test.go
@@ -46,7 +46,7 @@ func TestParseContentType(t *testing.T) {
 		} else {
 			headers.Del("content-type")
 		}
-		ct, cs, err := ContentType(headers)
+		ct, cs, err := ContentType(headers, false)
 		if v.err == nil {
 			assert.NoError(t, err, "input: %q", v.hdr)
 		} else {
diff --git a/httpkit/middleware/context.go b/httpkit/middleware/context.go
index 74fd25eb..30312124 100644
--- a/httpkit/middleware/context.go
+++ b/httpkit/middleware/context.go
@@ -209,7 +209,7 @@ func (c *Context) BindValidRequest(request *http.Request, route *MatchedRoute, b
 
 	// check and validate content type, select consumer
 	if httpkit.CanHaveBody(request.Method) {
-		ct, _, err := httpkit.ContentType(request.Header)
+		ct, _, err := httpkit.ContentType(request.Header, httpkit.IsDelete(request.Method))
 		if err != nil {
 			res = append(res, err)
 		} else {
@@ -221,7 +221,7 @@ func (c *Context) BindValidRequest(request *http.Request, route *MatchedRoute, b
 	}
 
 	// check and validate the response format
-	if len(res) == 0 {
+	if len(res) == 0 && httpkit.NeedsContentType(request.Method) {
 		if str := NegotiateContentType(request, route.Produces, ""); str == "" {
 			res = append(res, errors.InvalidResponseFormat(request.Header.Get(httpkit.HeaderAccept), route.Produces))
 		}
@@ -250,7 +250,7 @@ func (c *Context) ContentType(request *http.Request) (string, string, *errors.Pa
 		}
 	}
 
-	mt, cs, err := httpkit.ContentType(request.Header)
+	mt, cs, err := httpkit.ContentType(request.Header, httpkit.IsDelete(request.Method))
 	if err != nil {
 		return "", "", err
 	}
@@ -364,7 +364,12 @@ func (c *Context) Respond(rw http.ResponseWriter, r *http.Request, produces []st
 		producers := route.Producers
 		prod, ok := producers[format]
 		if !ok {
-			panic(errors.New(http.StatusInternalServerError, "can't find a producer for "+format))
+			prods := c.api.ProducersFor([]string{c.api.DefaultProduces()})
+			pr, ok := prods[c.api.DefaultProduces()]
+			if !ok {
+				panic(errors.New(http.StatusInternalServerError, "can't find a producer for "+format))
+			}
+			prod = pr
 		}
 		resp.WriteResponse(rw, prod)
 		return
@@ -407,7 +412,14 @@ func (c *Context) Respond(rw http.ResponseWriter, r *http.Request, produces []st
 		producers := route.Producers
 		prod, ok := producers[format]
 		if !ok {
-			panic(errors.New(http.StatusInternalServerError, "can't find a producer for "+format))
+			if !ok {
+				prods := c.api.ProducersFor([]string{c.api.DefaultProduces()})
+				pr, ok := prods[c.api.DefaultProduces()]
+				if !ok {
+					panic(errors.New(http.StatusInternalServerError, "can't find a producer for "+format))
+				}
+				prod = pr
+			}
 		}
 		if err := prod.Produce(rw, data); err != nil {
 			panic(err) // let the recovery middleware deal with this
diff --git a/httpkit/middleware/context_test.go b/httpkit/middleware/context_test.go
index b69c2b94..3a7c484b 100644
--- a/httpkit/middleware/context_test.go
+++ b/httpkit/middleware/context_test.go
@@ -21,11 +21,39 @@ import (
 	"testing"
 
 	"github.com/go-swagger/go-swagger/httpkit"
+	"github.com/go-swagger/go-swagger/httpkit/middleware/untyped"
 	"github.com/go-swagger/go-swagger/internal/testing/petstore"
+	"github.com/go-swagger/go-swagger/spec"
 	"github.com/gorilla/context"
 	"github.com/stretchr/testify/assert"
 )
 
+type stubOperationHandler struct {
+}
+
+func (s *stubOperationHandler) ParameterModel() interface{} {
+	return nil
+}
+
+func (s *stubOperationHandler) Handle(params interface{}) (interface{}, error) {
+	return nil, nil
+}
+func TestContentType_Issue264(t *testing.T) {
+	swspec, err := spec.Load("../../fixtures/bugs/264/swagger.yml")
+	if assert.NoError(t, err) {
+		api := untyped.NewAPI(swspec)
+		api.RegisterConsumer("application/json", httpkit.JSONConsumer())
+		api.RegisterProducer("application/json", httpkit.JSONProducer())
+		api.RegisterOperation("delete", "/key/{id}", new(stubOperationHandler))
+
+		handler := Serve(swspec, api)
+		request, _ := http.NewRequest("DELETE", "/key/1", nil)
+		recorder := httptest.NewRecorder()
+		handler.ServeHTTP(recorder, request)
+		assert.Equal(t, 200, recorder.Code)
+	}
+}
+
 func TestServe(t *testing.T) {
 	spec, api := petstore.NewAPI(t)
 	handler := Serve(spec, api)
@@ -163,9 +191,9 @@ func TestContextRender(t *testing.T) {
 	recorder = httptest.NewRecorder()
 	assert.Panics(t, func() { ctx.Respond(recorder, request, []string{ct}, ri, map[int]interface{}{1: "hello"}) })
 
-	recorder = httptest.NewRecorder()
-	request, _ = http.NewRequest("GET", "/pets", nil)
-	assert.Panics(t, func() { ctx.Respond(recorder, request, []string{}, ri, map[string]interface{}{"name": "hello"}) })
+	// recorder = httptest.NewRecorder()
+	// request, _ = http.NewRequest("GET", "/pets", nil)
+	// assert.Panics(t, func() { ctx.Respond(recorder, request, []string{}, ri, map[string]interface{}{"name": "hello"}) })
 
 	recorder = httptest.NewRecorder()
 	request, _ = http.NewRequest("DELETE", "/pets/1", nil)
diff --git a/httpkit/middleware/parameter.go b/httpkit/middleware/parameter.go
index 1c14eadc..a2faecc8 100644
--- a/httpkit/middleware/parameter.go
+++ b/httpkit/middleware/parameter.go
@@ -81,6 +81,8 @@ func (p *untypedParamBinder) typeForSchema(tpe, format string, items *spec.Items
 			return reflect.TypeOf(int32(0))
 		case "int64":
 			return reflect.TypeOf(int64(0))
+		default:
+			return reflect.TypeOf(int64(0))
 		}
 
 	case "number":
@@ -175,7 +177,7 @@ func (p *untypedParamBinder) Bind(request *http.Request, routeParams RouteParams
 		var err error
 		var mt string
 
-		mt, _, e := httpkit.ContentType(request.Header)
+		mt, _, e := httpkit.ContentType(request.Header, httpkit.IsDelete(request.Method))
 		if e != nil {
 			// because of the interface conversion go thinks the error is not nil
 			// so we first check for nil and then set the err var if it's not nil
diff --git a/httpkit/middleware/validation.go b/httpkit/middleware/validation.go
index 7dc489b3..42caf798 100644
--- a/httpkit/middleware/validation.go
+++ b/httpkit/middleware/validation.go
@@ -102,7 +102,7 @@ func (v *validation) contentType() {
 		ct, _, err := v.context.ContentType(v.request)
 		if err != nil {
 			v.result = append(v.result, err)
-		} else {
+		} else if httpkit.NeedsContentType(v.request.Method) {
 			if err := validateContentType(v.route.Consumes, ct); err != nil {
 				v.result = append(v.result, err)
 			}
@@ -112,7 +112,7 @@ func (v *validation) contentType() {
 }
 
 func (v *validation) responseFormat() {
-	if str := v.context.ResponseFormat(v.request, v.route.Produces); str == "" {
+	if str := v.context.ResponseFormat(v.request, v.route.Produces); str == "" && httpkit.NeedsContentType(v.request.Method) {
 		v.result = append(v.result, errors.InvalidResponseFormat(v.request.Header.Get(httpkit.HeaderAccept), v.route.Produces))
 	}
 }
diff --git a/httpkit/request.go b/httpkit/request.go
index 24579e14..91ef1703 100644
--- a/httpkit/request.go
+++ b/httpkit/request.go
@@ -28,6 +28,17 @@ func CanHaveBody(method string) bool {
 	return mn == "POST" || mn == "PUT" || mn == "PATCH" || mn == "DELETE"
 }
 
+// NeedsContentType returns true if this method needs a content-type
+func NeedsContentType(method string) bool {
+	mn := strings.ToUpper(method)
+	return mn == "POST" || mn == "PUT" || mn == "PATCH"
+}
+
+// IsDelete returns true if this method is DELETE
+func IsDelete(method string) bool {
+	return strings.ToUpper(method) == "DELETE"
+}
+
 // JSONRequest creates a new http request with json headers set
 func JSONRequest(method, urlStr string, body io.Reader) (*http.Request, error) {
 	req, err := http.NewRequest(method, urlStr, body)
diff --git a/internal/testing/petstore/api.go b/internal/testing/petstore/api.go
index 8ca0730d..21146b10 100644
--- a/internal/testing/petstore/api.go
+++ b/internal/testing/petstore/api.go
@@ -28,7 +28,7 @@ import (
 )
 
 // NewAPI registers a stub api for the pet store
-func NewAPI(t *gotest.T) (*spec.Document, *untyped.API) {
+func NewAPI(t gotest.TB) (*spec.Document, *untyped.API) {
 	spec, err := spec.New(testingutil.PetStoreJSONMessage, "")
 	assert.NoError(t, err)
 	api := untyped.NewAPI(spec)
@@ -67,7 +67,7 @@ func NewAPI(t *gotest.T) (*spec.Document, *untyped.API) {
 }
 
 // NewRootAPI registers a stub api for the pet store
-func NewRootAPI(t *gotest.T) (*spec.Document, *untyped.API) {
+func NewRootAPI(t gotest.TB) (*spec.Document, *untyped.API) {
 	spec, err := spec.New(testingutil.RootPetStoreJSONMessage, "")
 	assert.NoError(t, err)
 	api := untyped.NewAPI(spec)
