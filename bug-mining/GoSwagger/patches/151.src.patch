diff --git a/cmd/swagger/commands/version_number.go b/cmd/swagger/commands/version_number.go
index 47ba5eb8..460a4c39 100644
--- a/cmd/swagger/commands/version_number.go
+++ b/cmd/swagger/commands/version_number.go
@@ -1,6 +1,6 @@
 package commands
 
 func init() {
-  Version = "0.4.0-58-g088a481"
+  Version = "0.4.0-60-gd8d76b8"
 }
 
diff --git a/fixtures/analysis/references.yml b/fixtures/analysis/references.yml
index 2bffbc1e..64c3b832 100644
--- a/fixtures/analysis/references.yml
+++ b/fixtures/analysis/references.yml
@@ -26,6 +26,7 @@ paths:
   "/some/where/{id}":
     parameters:
       - $ref: "#/parameters/idParam"
+
       - name: bodyId
         in: body
         schema:
@@ -33,6 +34,11 @@ paths:
     get:
       parameters:
       - $ref: "#/parameters/limitParam"
+      - name: other
+        in: query
+        type: array
+        items:
+          $ref: "#/definitions/named"
       - name: body
         in: body
         schema:
@@ -47,6 +53,8 @@ paths:
           schema:
             $ref: "#/definitions/tag"
 definitions:
+  named:
+    type: string
   tag:
     type: object
     properties:
diff --git a/fixtures/expansion/invalid-refs.json b/fixtures/expansion/invalid-refs.json
new file mode 100644
index 00000000..d636d458
--- /dev/null
+++ b/fixtures/expansion/invalid-refs.json
@@ -0,0 +1,85 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "version": "1.0.0",
+    "title": "Swagger Petstore",
+    "contact": {
+      "name": "wordnik api team",
+      "url": "http://developer.wordnik.com"
+    },
+    "license": {
+      "name": "Creative Commons 4.0 International",
+      "url": "http://creativecommons.org/licenses/by/4.0/"
+    }
+  },
+  "host": "petstore.swagger.wordnik.com",
+  "basePath": "/api",
+  "schemes": [
+    "http"
+  ],
+  "paths": {
+    "/pets": {
+      "get": {
+        "tags": [ "Pet Operations" ],
+        "summary": "finds pets in the system",
+        "responses": {
+          "200": {
+            "description": "pet response",
+            "schema": {
+              "type": "array",
+              "items": {
+                "$ref": "NotCorrectRef"
+              }
+            },
+            "headers": {
+              "x-expires": {
+                "type": "string"
+              }
+            }
+          },
+          "default": {
+            "description": "unexpected error",
+            "schema": {
+              "$ref": "NotCorrectRef"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "Pet": {
+      "required": [
+        "id",
+        "name"
+      ],
+      "properties": {
+        "id": {
+          "type": "integer",
+          "format": "int64"
+        },
+        "name": {
+          "type": "string"
+        },
+        "tag": {
+          "type": "string"
+        }
+      }
+    },
+    "Error": {
+      "required": [
+        "code",
+        "message"
+      ],
+      "properties": {
+        "code": {
+          "type": "integer",
+          "format": "int32"
+        },
+        "message": {
+          "type": "string"
+        }
+      }
+    }
+  }
+}
diff --git a/generator/bindata.go b/generator/bindata.go
index e80ceb44..315bac72 100644
--- a/generator/bindata.go
+++ b/generator/bindata.go
@@ -130,7 +130,7 @@ func templatesClientClientGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/client/client.gotmpl", size: 2525, mode: os.FileMode(420), modTime: time.Unix(1457243576, 0)}
+	info := bindataFileInfo{name: "templates/client/client.gotmpl", size: 2525, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -170,7 +170,7 @@ func templatesClientParameterGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/client/parameter.gotmpl", size: 6841, mode: os.FileMode(420), modTime: time.Unix(1457240922, 0)}
+	info := bindataFileInfo{name: "templates/client/parameter.gotmpl", size: 6841, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -190,7 +190,7 @@ func templatesClientResponseGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/client/response.gotmpl", size: 5311, mode: os.FileMode(420), modTime: time.Unix(1457240922, 0)}
+	info := bindataFileInfo{name: "templates/client/response.gotmpl", size: 5311, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -210,7 +210,7 @@ func templatesDocstringGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/docstring.gotmpl", size: 190, mode: os.FileMode(420), modTime: time.Unix(1457280772, 0)}
+	info := bindataFileInfo{name: "templates/docstring.gotmpl", size: 190, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -250,7 +250,7 @@ func templatesModelGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/model.gotmpl", size: 639, mode: os.FileMode(420), modTime: time.Unix(1457280772, 0)}
+	info := bindataFileInfo{name: "templates/model.gotmpl", size: 639, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -290,7 +290,7 @@ func templatesSchemaGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/schema.gotmpl", size: 6016, mode: os.FileMode(420), modTime: time.Unix(1457237339, 0)}
+	info := bindataFileInfo{name: "templates/schema.gotmpl", size: 6016, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -350,7 +350,7 @@ func templatesSchemavalidatorGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/schemavalidator.gotmpl", size: 19494, mode: os.FileMode(420), modTime: time.Unix(1457278070, 0)}
+	info := bindataFileInfo{name: "templates/schemavalidator.gotmpl", size: 19494, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -430,7 +430,7 @@ func templatesServerMainGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/server/main.gotmpl", size: 1971, mode: os.FileMode(420), modTime: time.Unix(1457245072, 0)}
+	info := bindataFileInfo{name: "templates/server/main.gotmpl", size: 1971, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -470,7 +470,7 @@ func templatesServerParameterGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/server/parameter.gotmpl", size: 13960, mode: os.FileMode(420), modTime: time.Unix(1457294082, 0)}
+	info := bindataFileInfo{name: "templates/server/parameter.gotmpl", size: 13960, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -490,7 +490,7 @@ func templatesServerResponsesGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/server/responses.gotmpl", size: 4175, mode: os.FileMode(420), modTime: time.Unix(1457238197, 0)}
+	info := bindataFileInfo{name: "templates/server/responses.gotmpl", size: 4175, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -510,7 +510,7 @@ func templatesServerServerGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/server/server.gotmpl", size: 6235, mode: os.FileMode(420), modTime: time.Unix(1457202782, 0)}
+	info := bindataFileInfo{name: "templates/server/server.gotmpl", size: 6235, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -630,7 +630,7 @@ func templatesValidationPrimitiveGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/validation/primitive.gotmpl", size: 1924, mode: os.FileMode(420), modTime: time.Unix(1457211961, 0)}
+	info := bindataFileInfo{name: "templates/validation/primitive.gotmpl", size: 1924, mode: os.FileMode(420), modTime: time.Unix(1457296572, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
diff --git a/internal/validate/spec.go b/internal/validate/spec.go
index 4a0b6365..16dfb459 100644
--- a/internal/validate/spec.go
+++ b/internal/validate/spec.go
@@ -566,11 +566,18 @@ func parsePath(path string) (segments []string, params []int) {
 func (s *SpecValidator) validateReferencesValid() *Result {
 	// each reference must point to a valid object
 	res := new(Result)
-	exp, err := s.spec.Expanded()
-	if err != nil {
-		res.AddErrors(err)
+	for _, r := range s.spec.AllRefs() {
+		if !r.IsValidURI() {
+			res.AddErrors(errors.New(404, "invalid ref %q", r.String()))
+		}
+	}
+	if !res.HasErrors() {
+		exp, err := s.spec.Expanded()
+		if err != nil {
+			res.AddErrors(err)
+		}
+		s.expanded = exp
 	}
-	s.expanded = exp
 	return res
 }
 
diff --git a/spec/analyzer.go b/spec/analyzer.go
index 1fee2eff..efd56004 100644
--- a/spec/analyzer.go
+++ b/spec/analyzer.go
@@ -28,6 +28,8 @@ type referenceAnalysis struct {
 	schemas    map[string]Ref
 	responses  map[string]Ref
 	parameters map[string]Ref
+	items      map[string]Ref
+	allRefs    map[string]Ref
 	referenced struct {
 		schemas    map[string]SchemaRef
 		responses  map[string]*Response
@@ -35,11 +37,27 @@ type referenceAnalysis struct {
 	}
 }
 
+func (r *referenceAnalysis) addRef(key string, ref Ref) {
+	if r.allRefs == nil {
+		r.allRefs = make(map[string]Ref)
+	}
+	r.allRefs["#"+key] = ref
+}
+
+func (r *referenceAnalysis) addItemsRef(key string, items *Items) {
+	if r.items == nil {
+		r.items = make(map[string]Ref)
+	}
+	r.items["#"+key] = items.Ref
+	r.addRef(key, items.Ref)
+}
+
 func (r *referenceAnalysis) addSchemaRef(key string, ref SchemaRef) {
 	if r.schemas == nil {
 		r.schemas = make(map[string]Ref)
 	}
 	r.schemas["#"+key] = ref.Schema.Ref
+	r.addRef(key, ref.Schema.Ref)
 }
 
 func (r *referenceAnalysis) addResponseRef(key string, resp *Response) {
@@ -47,6 +65,7 @@ func (r *referenceAnalysis) addResponseRef(key string, resp *Response) {
 		r.responses = make(map[string]Ref)
 	}
 	r.responses["#"+key] = resp.Ref
+	r.addRef(key, resp.Ref)
 }
 
 func (r *referenceAnalysis) addParamRef(key string, param *Parameter) {
@@ -54,6 +73,7 @@ func (r *referenceAnalysis) addParamRef(key string, param *Parameter) {
 		r.parameters = make(map[string]Ref)
 	}
 	r.parameters["#"+key] = param.Ref
+	r.addRef(key, param.Ref)
 }
 
 // specAnalyzer takes a swagger spec object and turns it into a registry
@@ -86,14 +106,24 @@ func (s *specAnalyzer) initialize() {
 	}
 
 	for name, parameter := range s.spec.Parameters {
+		refPref := slashpath.Join("/parameters", jsonpointer.Escape(name))
+		if parameter.Items != nil {
+			s.analyzeItems("items", parameter.Items, refPref)
+		}
 		if parameter.In == "body" && parameter.Schema != nil {
-			s.analyzeSchema("schema", *parameter.Schema, slashpath.Join("/parameters", jsonpointer.Escape(name)))
+			s.analyzeSchema("schema", *parameter.Schema, refPref)
 		}
 	}
 
 	for name, response := range s.spec.Responses {
+		refPref := slashpath.Join("/responses", jsonpointer.Escape(name))
+		for _, v := range response.Headers {
+			if v.Items != nil {
+				s.analyzeItems("items", v.Items, refPref)
+			}
+		}
 		if response.Schema != nil {
-			s.analyzeSchema("schema", *response.Schema, slashpath.Join("/responses", jsonpointer.Escape(name)))
+			s.analyzeSchema("schema", *response.Schema, refPref)
 		}
 	}
 
@@ -120,12 +150,28 @@ func (s *specAnalyzer) analyzeOperations(path string, pi *PathItem) {
 		if param.Ref.String() != "" {
 			s.references.addParamRef(refPref, &param)
 		}
+		if param.Items != nil {
+			s.analyzeItems("items", param.Items, refPref)
+		}
 		if param.Schema != nil {
 			s.analyzeSchema("schema", *param.Schema, refPref)
 		}
 	}
 }
 
+func (s *specAnalyzer) analyzeItems(name string, items *Items, prefix string) {
+	if items == nil {
+		return
+	}
+	refPref := slashpath.Join(prefix, name)
+	if items.Items != nil {
+		s.analyzeItems(name, items.Items, refPref)
+	}
+	if items.Ref.String() != "" {
+		s.references.addItemsRef(refPref, items)
+	}
+}
+
 func (s *specAnalyzer) analyzeOperation(method, path string, op *Operation) {
 	if op == nil {
 		return
@@ -152,6 +198,9 @@ func (s *specAnalyzer) analyzeOperation(method, path string, op *Operation) {
 		if param.Ref.String() != "" {
 			s.references.addParamRef(refPref, &param)
 		}
+		if param.Items != nil {
+			s.analyzeItems("items", param.Items, refPref)
+		}
 		if param.In == "body" && param.Schema != nil {
 			s.analyzeSchema("schema", *param.Schema, refPref)
 		}
@@ -162,6 +211,11 @@ func (s *specAnalyzer) analyzeOperation(method, path string, op *Operation) {
 			if op.Responses.Default.Ref.String() != "" {
 				s.references.addResponseRef(refPref, op.Responses.Default)
 			}
+			for _, v := range op.Responses.Default.Headers {
+				if v.Items != nil {
+					s.analyzeItems("items", v.Items, refPref)
+				}
+			}
 			if op.Responses.Default.Schema != nil {
 				s.analyzeSchema("schema", *op.Responses.Default.Schema, refPref)
 			}
@@ -171,6 +225,11 @@ func (s *specAnalyzer) analyzeOperation(method, path string, op *Operation) {
 			if res.Ref.String() != "" {
 				s.references.addResponseRef(refPref, &res)
 			}
+			for _, v := range res.Headers {
+				if v.Items != nil {
+					s.analyzeItems("items", v.Items, refPref)
+				}
+			}
 			if res.Schema != nil {
 				s.analyzeSchema("schema", *res.Schema, refPref)
 			}
@@ -490,3 +549,35 @@ func (s *specAnalyzer) AllResponseReferences() (result []string) {
 	}
 	return
 }
+
+// AllItemsReferences returns the references for all the items
+func (s *specAnalyzer) AllItemsReferences() (result []string) {
+	for _, v := range s.references.items {
+		result = append(result, v.String())
+	}
+	return
+}
+
+// AllReferences returns all the references found in the document
+func (s *specAnalyzer) AllReferences() (result []string) {
+	for _, v := range s.references.allRefs {
+		result = append(result, v.String())
+	}
+	return
+}
+
+// AllRefs returns all the unique references found in the document
+func (s *specAnalyzer) AllRefs() (result []Ref) {
+	set := make(map[string]struct{})
+	for _, v := range s.references.allRefs {
+		a := v.String()
+		if a == "" {
+			continue
+		}
+		if _, ok := set[a]; !ok {
+			set[a] = struct{}{}
+			result = append(result, v)
+		}
+	}
+	return
+}
diff --git a/spec/analyzer_test.go b/spec/analyzer_test.go
index 70ba6c9a..3ecd983a 100644
--- a/spec/analyzer_test.go
+++ b/spec/analyzer_test.go
@@ -212,6 +212,9 @@ func TestReferenceAnalysis(t *testing.T) {
 		assertRefExists(t, definitions.schemas, "#/responses/notFound/schema")
 		assertRefExists(t, definitions.schemas, "#/paths/~1some~1where~1{id}/get/responses/200/schema")
 		assertRefExists(t, definitions.schemas, "#/definitions/tag/properties/audit")
+
+		// items
+		assertRefExists(t, definitions.allRefs, "#/paths/~1some~1where~1{id}/get/parameters/1/items")
 	}
 }
 
diff --git a/spec/expander.go b/spec/expander.go
index 1167a7fe..7aa5957b 100644
--- a/spec/expander.go
+++ b/spec/expander.go
@@ -46,16 +46,15 @@ func defaultResolutionCache() ResolutionCache {
 
 func (s *simpleCache) Get(uri string) (interface{}, bool) {
 	s.lock.RLock()
-	defer s.lock.RUnlock()
 	v, ok := s.store[uri]
+	s.lock.RUnlock()
 	return v, ok
 }
 
 func (s *simpleCache) Set(uri string, data interface{}) {
 	s.lock.Lock()
-	defer s.lock.Unlock()
-
 	s.store[uri] = data
+	s.lock.Unlock()
 }
 
 // ResolveRef resolves a reference against a context root
@@ -547,6 +546,17 @@ func expandOperation(op *Operation, resolver *schemaLoader) error {
 	return nil
 }
 
+func expandItems(items *Items, resolver *schemaLoader) error {
+	if items == nil {
+		return nil
+	}
+
+	if err := resolver.Resolve(&items.Ref, items); err != nil {
+		return err
+	}
+	return nil
+}
+
 func expandResponse(response *Response, resolver *schemaLoader) error {
 	if response == nil {
 		return nil
@@ -556,6 +566,14 @@ func expandResponse(response *Response, resolver *schemaLoader) error {
 		return err
 	}
 
+	for _, v := range response.Headers {
+		if v.Items != nil && v.Items.Ref.String() != "" {
+			if err := expandItems(v.Items, resolver); err != nil {
+				return err
+			}
+		}
+	}
+
 	if response.Schema != nil {
 		if err := expandSchema(response.Schema, resolver); err != nil {
 			return err
@@ -571,6 +589,13 @@ func expandParameter(parameter *Parameter, resolver *schemaLoader) error {
 	if err := resolver.Resolve(&parameter.Ref, parameter); err != nil {
 		return err
 	}
+
+	if parameter.Items != nil && parameter.Items.Ref.String() != "" {
+		if err := expandItems(parameter.Items, resolver); err != nil {
+			return err
+		}
+	}
+
 	if parameter.Schema != nil {
 		if err := expandSchema(parameter.Schema, resolver); err != nil {
 			return err
diff --git a/spec/ref.go b/spec/ref.go
index ed791b65..6c86fb93 100644
--- a/spec/ref.go
+++ b/spec/ref.go
@@ -16,18 +16,24 @@ package spec
 
 import (
 	"encoding/json"
+	"net/http"
+	"os"
+	"path/filepath"
 
 	"github.com/go-swagger/go-swagger/jsonreference"
 )
 
+// Refable is a struct for things that accept a $ref property
 type Refable struct {
 	Ref Ref
 }
 
+// MarshalJSON marshals the ref to json
 func (r Refable) MarshalJSON() ([]byte, error) {
 	return r.Ref.MarshalJSON()
 }
 
+// UnmarshalJSON unmarshalss the ref from json
 func (r *Refable) UnmarshalJSON(d []byte) error {
 	return json.Unmarshal(d, &r.Ref)
 }
@@ -37,6 +43,59 @@ type Ref struct {
 	jsonreference.Ref
 }
 
+// RemoteURI gets the remote uri part of the ref
+func (r *Ref) RemoteURI() string {
+	if r.String() == "" {
+		return r.String()
+	}
+
+	u := *r.GetURL()
+	u.Fragment = ""
+	return u.String()
+}
+
+// IsValidURI returns true when the url the ref points to can be found
+func (r *Ref) IsValidURI() bool {
+	if r.String() == "" {
+		return true
+	}
+
+	v := r.RemoteURI()
+	if v == "" {
+		return true
+	}
+
+	if r.HasFullURL {
+		rr, err := http.Get(v)
+		if err != nil {
+			return false
+		}
+
+		return rr.StatusCode/100 == 2
+	}
+
+	if !(r.HasFileScheme || r.HasFullFilePath || r.HasURLPathOnly) {
+		return false
+	}
+
+	// check for local file
+	pth := v
+	if r.HasURLPathOnly {
+		p, e := filepath.Abs(pth)
+		if e != nil {
+			return false
+		}
+		pth = p
+	}
+
+	fi, err := os.Stat(pth)
+	if err != nil {
+		return false
+	}
+
+	return !fi.IsDir()
+}
+
 // Inherits creates a new reference from a parent and a child
 // If the child cannot inherit from the parent, an error is returned
 func (r *Ref) Inherits(child Ref) (*Ref, error) {
