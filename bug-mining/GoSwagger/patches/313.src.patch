diff --git a/examples/file-server/README.md b/examples/file-server/README.md
new file mode 100644
index 00000000..c709d04f
--- /dev/null
+++ b/examples/file-server/README.md
@@ -0,0 +1,77 @@
+# File upload server
+
+This example demonstrates how to build a simple file upload endpoint
+with swagger and go-swagger.
+
+## Try it
+
+1. Build the server
+
+```
+cd restapi/cmd/file-upload-server
+go build
+
+./file-upload-server --port 8000
+2021/01/17 18:54:09 Serving file upload at http://127.0.0.1:8000
+```
+
+2. Run the client
+
+From another terminal:
+
+```
+go run upload_file.go swagger.yml
+```
+
+Logs on the server:
+```
+2021/01/17 18:54:15 received file name: swagger.yml
+2021/01/17 18:54:15 received file size: 512
+2021/01/17 18:54:15 copied bytes 512
+2021/01/17 18:54:15 file uploaded copied as upload427417421/uploaded_file_0.dat
+```
+
+The file has been copied in a temporary folder `cmd/file-upload-server/upload*/`
+
+
+## Specification
+
+We use the swagger type `file` in a multipart form, like so:
+
+```yaml
+paths:
+  /upload:
+    post:
+      consumes:
+      - multipart/form-data
+      parameters:
+      - name: file
+        in: formData
+        type: file
+```
+
+## Server side
+
+The handler receives a `io.ReadCloser` as the file to consume.
+
+Under the hood, the runtime builds this with a `*runtime.File`, which provides access to some header information, such as:
+
+```go
+		if namedFile, ok := params.File.(*runtime.File); ok {
+			log.Printf("received file name: %s", namedFile.Header.Filename)
+			log.Printf("received file size: %d", namedFile.Header.Size)
+		}
+```
+
+## Client side
+
+The local file is handled as a `runtime.NamedReadCloser` (that is, a `io.ReadCloser` plus the `Name() string` method).
+A regular `os.File` satisfies this.
+
+The file can be passed directly to the client method, like so:
+
+```go
+	params := uploads.NewUploadFileParams().WithFile(reader)
+
+	_, err := uploader.Uploads.UploadFile(params)
+```
diff --git a/examples/file-server/client/file_upload_client.go b/examples/file-server/client/file_upload_client.go
new file mode 100644
index 00000000..25feee3f
--- /dev/null
+++ b/examples/file-server/client/file_upload_client.go
@@ -0,0 +1,112 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package client
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the swagger generate command
+
+import (
+	"github.com/go-openapi/runtime"
+	httptransport "github.com/go-openapi/runtime/client"
+	"github.com/go-openapi/strfmt"
+
+	"github.com/go-swagger/go-swagger/examples/file-server/client/uploads"
+)
+
+// Default file upload HTTP client.
+var Default = NewHTTPClient(nil)
+
+const (
+	// DefaultHost is the default Host
+	// found in Meta (info) section of spec file
+	DefaultHost string = "localhost"
+	// DefaultBasePath is the default BasePath
+	// found in Meta (info) section of spec file
+	DefaultBasePath string = "/"
+)
+
+// DefaultSchemes are the default schemes found in Meta (info) section of spec file
+var DefaultSchemes = []string{"http"}
+
+// NewHTTPClient creates a new file upload HTTP client.
+func NewHTTPClient(formats strfmt.Registry) *FileUpload {
+	return NewHTTPClientWithConfig(formats, nil)
+}
+
+// NewHTTPClientWithConfig creates a new file upload HTTP client,
+// using a customizable transport config.
+func NewHTTPClientWithConfig(formats strfmt.Registry, cfg *TransportConfig) *FileUpload {
+	// ensure nullable parameters have default
+	if cfg == nil {
+		cfg = DefaultTransportConfig()
+	}
+
+	// create transport and client
+	transport := httptransport.New(cfg.Host, cfg.BasePath, cfg.Schemes)
+	return New(transport, formats)
+}
+
+// New creates a new file upload client
+func New(transport runtime.ClientTransport, formats strfmt.Registry) *FileUpload {
+	// ensure nullable parameters have default
+	if formats == nil {
+		formats = strfmt.Default
+	}
+
+	cli := new(FileUpload)
+	cli.Transport = transport
+	cli.Uploads = uploads.New(transport, formats)
+	return cli
+}
+
+// DefaultTransportConfig creates a TransportConfig with the
+// default settings taken from the meta section of the spec file.
+func DefaultTransportConfig() *TransportConfig {
+	return &TransportConfig{
+		Host:     DefaultHost,
+		BasePath: DefaultBasePath,
+		Schemes:  DefaultSchemes,
+	}
+}
+
+// TransportConfig contains the transport related info,
+// found in the meta section of the spec file.
+type TransportConfig struct {
+	Host     string
+	BasePath string
+	Schemes  []string
+}
+
+// WithHost overrides the default host,
+// provided by the meta section of the spec file.
+func (cfg *TransportConfig) WithHost(host string) *TransportConfig {
+	cfg.Host = host
+	return cfg
+}
+
+// WithBasePath overrides the default basePath,
+// provided by the meta section of the spec file.
+func (cfg *TransportConfig) WithBasePath(basePath string) *TransportConfig {
+	cfg.BasePath = basePath
+	return cfg
+}
+
+// WithSchemes overrides the default schemes,
+// provided by the meta section of the spec file.
+func (cfg *TransportConfig) WithSchemes(schemes []string) *TransportConfig {
+	cfg.Schemes = schemes
+	return cfg
+}
+
+// FileUpload is a client for file upload
+type FileUpload struct {
+	Uploads uploads.ClientService
+
+	Transport runtime.ClientTransport
+}
+
+// SetTransport changes the transport on the client and all its subresources
+func (c *FileUpload) SetTransport(transport runtime.ClientTransport) {
+	c.Transport = transport
+	c.Uploads.SetTransport(transport)
+}
diff --git a/examples/file-server/client/uploads/upload_file_parameters.go b/examples/file-server/client/uploads/upload_file_parameters.go
new file mode 100644
index 00000000..ff0409a1
--- /dev/null
+++ b/examples/file-server/client/uploads/upload_file_parameters.go
@@ -0,0 +1,145 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package uploads
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the swagger generate command
+
+import (
+	"context"
+	"net/http"
+	"time"
+
+	"github.com/go-openapi/errors"
+	"github.com/go-openapi/runtime"
+	cr "github.com/go-openapi/runtime/client"
+	"github.com/go-openapi/strfmt"
+)
+
+// NewUploadFileParams creates a new UploadFileParams object,
+// with the default timeout for this client.
+//
+// Default values are not hydrated, since defaults are normally applied by the API server side.
+//
+// To enforce default values in parameter, use SetDefaults or WithDefaults.
+func NewUploadFileParams() *UploadFileParams {
+	return &UploadFileParams{
+		timeout: cr.DefaultTimeout,
+	}
+}
+
+// NewUploadFileParamsWithTimeout creates a new UploadFileParams object
+// with the ability to set a timeout on a request.
+func NewUploadFileParamsWithTimeout(timeout time.Duration) *UploadFileParams {
+	return &UploadFileParams{
+		timeout: timeout,
+	}
+}
+
+// NewUploadFileParamsWithContext creates a new UploadFileParams object
+// with the ability to set a context for a request.
+func NewUploadFileParamsWithContext(ctx context.Context) *UploadFileParams {
+	return &UploadFileParams{
+		Context: ctx,
+	}
+}
+
+// NewUploadFileParamsWithHTTPClient creates a new UploadFileParams object
+// with the ability to set a custom HTTPClient for a request.
+func NewUploadFileParamsWithHTTPClient(client *http.Client) *UploadFileParams {
+	return &UploadFileParams{
+		HTTPClient: client,
+	}
+}
+
+/* UploadFileParams contains all the parameters to send to the API endpoint
+   for the upload file operation.
+
+   Typically these are written to a http.Request.
+*/
+type UploadFileParams struct {
+
+	// File.
+	File runtime.NamedReadCloser
+
+	timeout    time.Duration
+	Context    context.Context
+	HTTPClient *http.Client
+}
+
+// WithDefaults hydrates default values in the upload file params (not the query body).
+//
+// All values with no default are reset to their zero value.
+func (o *UploadFileParams) WithDefaults() *UploadFileParams {
+	o.SetDefaults()
+	return o
+}
+
+// SetDefaults hydrates default values in the upload file params (not the query body).
+//
+// All values with no default are reset to their zero value.
+func (o *UploadFileParams) SetDefaults() {
+	// no default values defined for this parameter
+}
+
+// WithTimeout adds the timeout to the upload file params
+func (o *UploadFileParams) WithTimeout(timeout time.Duration) *UploadFileParams {
+	o.SetTimeout(timeout)
+	return o
+}
+
+// SetTimeout adds the timeout to the upload file params
+func (o *UploadFileParams) SetTimeout(timeout time.Duration) {
+	o.timeout = timeout
+}
+
+// WithContext adds the context to the upload file params
+func (o *UploadFileParams) WithContext(ctx context.Context) *UploadFileParams {
+	o.SetContext(ctx)
+	return o
+}
+
+// SetContext adds the context to the upload file params
+func (o *UploadFileParams) SetContext(ctx context.Context) {
+	o.Context = ctx
+}
+
+// WithHTTPClient adds the HTTPClient to the upload file params
+func (o *UploadFileParams) WithHTTPClient(client *http.Client) *UploadFileParams {
+	o.SetHTTPClient(client)
+	return o
+}
+
+// SetHTTPClient adds the HTTPClient to the upload file params
+func (o *UploadFileParams) SetHTTPClient(client *http.Client) {
+	o.HTTPClient = client
+}
+
+// WithFile adds the file to the upload file params
+func (o *UploadFileParams) WithFile(file runtime.NamedReadCloser) *UploadFileParams {
+	o.SetFile(file)
+	return o
+}
+
+// SetFile adds the file to the upload file params
+func (o *UploadFileParams) SetFile(file runtime.NamedReadCloser) {
+	o.File = file
+}
+
+// WriteToRequest writes these params to a swagger request
+func (o *UploadFileParams) WriteToRequest(r runtime.ClientRequest, reg strfmt.Registry) error {
+
+	if err := r.SetTimeout(o.timeout); err != nil {
+		return err
+	}
+	var res []error
+	// form file param file
+	if err := r.SetFileParam("file", o.File); err != nil {
+		return err
+	}
+
+	if len(res) > 0 {
+		return errors.CompositeValidationError(res...)
+	}
+	return nil
+}
diff --git a/examples/file-server/client/uploads/upload_file_responses.go b/examples/file-server/client/uploads/upload_file_responses.go
new file mode 100644
index 00000000..481b19f4
--- /dev/null
+++ b/examples/file-server/client/uploads/upload_file_responses.go
@@ -0,0 +1,53 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package uploads
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the swagger generate command
+
+import (
+	"fmt"
+
+	"github.com/go-openapi/runtime"
+	"github.com/go-openapi/strfmt"
+)
+
+// UploadFileReader is a Reader for the UploadFile structure.
+type UploadFileReader struct {
+	formats strfmt.Registry
+}
+
+// ReadResponse reads a server response into the received o.
+func (o *UploadFileReader) ReadResponse(response runtime.ClientResponse, consumer runtime.Consumer) (interface{}, error) {
+	switch response.Code() {
+	case 200:
+		result := NewUploadFileOK()
+		if err := result.readResponse(response, consumer, o.formats); err != nil {
+			return nil, err
+		}
+		return result, nil
+	default:
+		return nil, runtime.NewAPIError("response status code does not match any response statuses defined for this endpoint in the swagger spec", response, response.Code())
+	}
+}
+
+// NewUploadFileOK creates a UploadFileOK with default headers values
+func NewUploadFileOK() *UploadFileOK {
+	return &UploadFileOK{}
+}
+
+/* UploadFileOK describes a response with status code 200, with default header values.
+
+OK
+*/
+type UploadFileOK struct {
+}
+
+func (o *UploadFileOK) Error() string {
+	return fmt.Sprintf("[POST /upload][%d] uploadFileOK ", 200)
+}
+
+func (o *UploadFileOK) readResponse(response runtime.ClientResponse, consumer runtime.Consumer, formats strfmt.Registry) error {
+
+	return nil
+}
diff --git a/examples/file-server/client/uploads/uploads_client.go b/examples/file-server/client/uploads/uploads_client.go
new file mode 100644
index 00000000..8619a176
--- /dev/null
+++ b/examples/file-server/client/uploads/uploads_client.go
@@ -0,0 +1,72 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package uploads
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the swagger generate command
+
+import (
+	"fmt"
+
+	"github.com/go-openapi/runtime"
+	"github.com/go-openapi/strfmt"
+)
+
+// New creates a new uploads API client.
+func New(transport runtime.ClientTransport, formats strfmt.Registry) ClientService {
+	return &Client{transport: transport, formats: formats}
+}
+
+/*
+Client for uploads API
+*/
+type Client struct {
+	transport runtime.ClientTransport
+	formats   strfmt.Registry
+}
+
+// ClientService is the interface for Client methods
+type ClientService interface {
+	UploadFile(params *UploadFileParams) (*UploadFileOK, error)
+
+	SetTransport(transport runtime.ClientTransport)
+}
+
+/*
+  UploadFile uploads
+*/
+func (a *Client) UploadFile(params *UploadFileParams) (*UploadFileOK, error) {
+	// TODO: Validate the params before sending
+	if params == nil {
+		params = NewUploadFileParams()
+	}
+
+	result, err := a.transport.Submit(&runtime.ClientOperation{
+		ID:                 "uploadFile",
+		Method:             "POST",
+		PathPattern:        "/upload",
+		ProducesMediaTypes: []string{"application/json"},
+		ConsumesMediaTypes: []string{"multipart/form-data"},
+		Schemes:            []string{"http"},
+		Params:             params,
+		Reader:             &UploadFileReader{formats: a.formats},
+		Context:            params.Context,
+		Client:             params.HTTPClient,
+	})
+	if err != nil {
+		return nil, err
+	}
+	success, ok := result.(*UploadFileOK)
+	if ok {
+		return success, nil
+	}
+	// unexpected success response
+	// safeguard: normally, absent a default response, unknown success responses return an error above: so this is a codegen issue
+	msg := fmt.Sprintf("unexpected success response for uploadFile: API contract not enforced by server. Client expected to get an error, but got: %T", result)
+	panic(msg)
+}
+
+// SetTransport changes the transport on the client
+func (a *Client) SetTransport(transport runtime.ClientTransport) {
+	a.transport = transport
+}
diff --git a/examples/file-server/cmd/file-upload-server/main.go b/examples/file-server/cmd/file-upload-server/main.go
new file mode 100644
index 00000000..a45a097f
--- /dev/null
+++ b/examples/file-server/cmd/file-upload-server/main.go
@@ -0,0 +1,57 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package main
+
+import (
+	"log"
+	"os"
+
+	"github.com/go-openapi/loads"
+	flags "github.com/jessevdk/go-flags"
+
+	"github.com/go-swagger/go-swagger/examples/file-server/restapi"
+	"github.com/go-swagger/go-swagger/examples/file-server/restapi/operations"
+)
+
+// This file was generated by the swagger tool.
+// Make sure not to overwrite this file after you generated it because all your edits would be lost!
+
+func main() {
+
+	swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)
+	if err != nil {
+		log.Fatalln(err)
+	}
+
+	api := operations.NewFileUploadAPI(swaggerSpec)
+	server := restapi.NewServer(api)
+	defer server.Shutdown()
+
+	parser := flags.NewParser(server, flags.Default)
+	parser.ShortDescription = "File Upload"
+	parser.LongDescription = "Example server uploading a file"
+	server.ConfigureFlags()
+	for _, optsGroup := range api.CommandLineOptionsGroups {
+		_, err := parser.AddGroup(optsGroup.ShortDescription, optsGroup.LongDescription, optsGroup.Options)
+		if err != nil {
+			log.Fatalln(err)
+		}
+	}
+
+	if _, err := parser.Parse(); err != nil {
+		code := 1
+		if fe, ok := err.(*flags.Error); ok {
+			if fe.Type == flags.ErrHelp {
+				code = 0
+			}
+		}
+		os.Exit(code)
+	}
+
+	server.ConfigureAPI()
+
+	if err := server.Serve(); err != nil {
+		log.Fatalln(err)
+	}
+
+}
diff --git a/examples/file-server/restapi/configure_file_upload.go b/examples/file-server/restapi/configure_file_upload.go
new file mode 100644
index 00000000..113a4101
--- /dev/null
+++ b/examples/file-server/restapi/configure_file_upload.go
@@ -0,0 +1,117 @@
+// This file is safe to edit. Once it exists it will not be overwritten
+
+package restapi
+
+import (
+	"crypto/tls"
+	"fmt"
+	"io"
+	"io/ioutil"
+	"log"
+	"net/http"
+	"os"
+	"path"
+
+	"github.com/go-openapi/errors"
+	"github.com/go-openapi/runtime"
+	"github.com/go-openapi/runtime/middleware"
+
+	"github.com/go-swagger/go-swagger/examples/file-server/restapi/operations"
+	"github.com/go-swagger/go-swagger/examples/file-server/restapi/operations/uploads"
+)
+
+//go:generate swagger generate server --target ../../file-server --name FileUpload --spec ../swagger.yml --principal interface{}
+
+func configureFlags(api *operations.FileUploadAPI) {
+	// api.CommandLineOptionsGroups = []swag.CommandLineOptionsGroup{ ... }
+}
+
+func configureAPI(api *operations.FileUploadAPI) http.Handler {
+	// configure the api here
+	api.ServeError = errors.ServeError
+
+	// Set your custom logger if needed. Default one is log.Printf
+	// Expected interface func(string, ...interface{})
+	//
+	// Example:
+	// api.Logger = log.Printf
+
+	api.UseSwaggerUI()
+	// To continue using redoc as your UI, uncomment the following line
+	// api.UseRedoc()
+
+	api.JSONConsumer = runtime.JSONConsumer()
+	api.MultipartformConsumer = runtime.DiscardConsumer
+
+	api.JSONProducer = runtime.JSONProducer()
+
+	uploadFolder, err := ioutil.TempDir(".", "upload")
+	if err != nil {
+		panic("could not create upload folder")
+	}
+	uploadCounter := 0
+
+	api.UploadsUploadFileHandler = uploads.UploadFileHandlerFunc(func(params uploads.UploadFileParams) middleware.Responder {
+
+		if params.File == nil {
+			return middleware.Error(404, fmt.Errorf("no file provided"))
+		}
+		defer func() {
+			_ = params.File.Close()
+		}()
+
+		if namedFile, ok := params.File.(*runtime.File); ok {
+			log.Printf("received file name: %s", namedFile.Header.Filename)
+			log.Printf("received file size: %d", namedFile.Header.Size)
+		}
+
+		// uploads file and save it locally
+		filename := path.Join(uploadFolder, fmt.Sprintf("uploaded_file_%d.dat", uploadCounter))
+		uploadCounter++
+		f, err := os.OpenFile(filename, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
+		if err != nil {
+			return middleware.Error(500, fmt.Errorf("could not create file on server"))
+		}
+
+		n, err := io.Copy(f, params.File)
+		if err != nil {
+			return middleware.Error(500, fmt.Errorf("could not upload file on server"))
+		}
+
+		log.Printf("copied bytes %d", n)
+
+		log.Printf("file uploaded copied as %s", filename)
+
+		return uploads.NewUploadFileOK()
+	})
+
+	api.PreServerShutdown = func() {}
+
+	api.ServerShutdown = func() {}
+
+	return setupGlobalMiddleware(api.Serve(setupMiddlewares))
+}
+
+// The TLS configuration before HTTPS server starts.
+func configureTLS(tlsConfig *tls.Config) {
+	// Make all necessary changes to the TLS configuration here.
+}
+
+// As soon as server is initialized but not run yet, this function will be called.
+// If you need to modify a config, store server instance to stop it individually later, this is the place.
+// This function can be called multiple times, depending on the number of serving schemes.
+// scheme value will be set accordingly: "http", "https" or "unix".
+func configureServer(s *http.Server, scheme, addr string) {
+}
+
+// The middleware configuration is for the handler executors. These do not apply to the swagger.json document.
+// The middleware executes after routing but before authentication, binding and validation.
+func setupMiddlewares(handler http.Handler) http.Handler {
+	return handler
+}
+
+// The middleware configuration happens before anything, this middleware also applies to serving the swagger.json document.
+// So this is a good place to plug in a panic handling middleware, logging and metrics.
+func setupGlobalMiddleware(handler http.Handler) http.Handler {
+	return handler
+}
diff --git a/examples/file-server/restapi/doc.go b/examples/file-server/restapi/doc.go
new file mode 100644
index 00000000..73f8032d
--- /dev/null
+++ b/examples/file-server/restapi/doc.go
@@ -0,0 +1,20 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+// Package restapi File Upload
+//
+//  Example server uploading a file
+//  Schemes:
+//    http
+//  Host: localhost
+//  BasePath: /
+//  Version: 1.0.0
+//
+//  Consumes:
+//    - application/json
+//    - multipart/form-data
+//
+//  Produces:
+//    - application/json
+//
+// swagger:meta
+package restapi
diff --git a/examples/file-server/restapi/embedded_spec.go b/examples/file-server/restapi/embedded_spec.go
new file mode 100644
index 00000000..d1ad315a
--- /dev/null
+++ b/examples/file-server/restapi/embedded_spec.go
@@ -0,0 +1,110 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package restapi
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the swagger generate command
+
+import (
+	"encoding/json"
+)
+
+var (
+	// SwaggerJSON embedded version of the swagger document used at generation time
+	SwaggerJSON json.RawMessage
+	// FlatSwaggerJSON embedded flattened version of the swagger document used at generation time
+	FlatSwaggerJSON json.RawMessage
+)
+
+func init() {
+	SwaggerJSON = json.RawMessage([]byte(`{
+  "consumes": [
+    "application/json"
+  ],
+  "produces": [
+    "application/json"
+  ],
+  "schemes": [
+    "http"
+  ],
+  "swagger": "2.0",
+  "info": {
+    "description": "Example server uploading a file",
+    "title": "File Upload",
+    "version": "1.0.0"
+  },
+  "basePath": "/",
+  "paths": {
+    "/upload": {
+      "post": {
+        "consumes": [
+          "multipart/form-data"
+        ],
+        "tags": [
+          "uploads"
+        ],
+        "summary": "uploads",
+        "operationId": "uploadFile",
+        "parameters": [
+          {
+            "type": "file",
+            "name": "file",
+            "in": "formData",
+            "required": true
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "OK"
+          }
+        }
+      }
+    }
+  }
+}`))
+	FlatSwaggerJSON = json.RawMessage([]byte(`{
+  "consumes": [
+    "application/json"
+  ],
+  "produces": [
+    "application/json"
+  ],
+  "schemes": [
+    "http"
+  ],
+  "swagger": "2.0",
+  "info": {
+    "description": "Example server uploading a file",
+    "title": "File Upload",
+    "version": "1.0.0"
+  },
+  "basePath": "/",
+  "paths": {
+    "/upload": {
+      "post": {
+        "consumes": [
+          "multipart/form-data"
+        ],
+        "tags": [
+          "uploads"
+        ],
+        "summary": "uploads",
+        "operationId": "uploadFile",
+        "parameters": [
+          {
+            "type": "file",
+            "name": "file",
+            "in": "formData",
+            "required": true
+          }
+        ],
+        "responses": {
+          "200": {
+            "description": "OK"
+          }
+        }
+      }
+    }
+  }
+}`))
+}
diff --git a/examples/file-server/restapi/operations/file_upload_api.go b/examples/file-server/restapi/operations/file_upload_api.go
new file mode 100644
index 00000000..0b1fb13f
--- /dev/null
+++ b/examples/file-server/restapi/operations/file_upload_api.go
@@ -0,0 +1,309 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package operations
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the swagger generate command
+
+import (
+	"fmt"
+	"net/http"
+	"strings"
+
+	"github.com/go-openapi/errors"
+	"github.com/go-openapi/loads"
+	"github.com/go-openapi/runtime"
+	"github.com/go-openapi/runtime/middleware"
+	"github.com/go-openapi/runtime/security"
+	"github.com/go-openapi/spec"
+	"github.com/go-openapi/strfmt"
+	"github.com/go-openapi/swag"
+
+	"github.com/go-swagger/go-swagger/examples/file-server/restapi/operations/uploads"
+)
+
+// NewFileUploadAPI creates a new FileUpload instance
+func NewFileUploadAPI(spec *loads.Document) *FileUploadAPI {
+	return &FileUploadAPI{
+		handlers:            make(map[string]map[string]http.Handler),
+		formats:             strfmt.Default,
+		defaultConsumes:     "application/json",
+		defaultProduces:     "application/json",
+		customConsumers:     make(map[string]runtime.Consumer),
+		customProducers:     make(map[string]runtime.Producer),
+		PreServerShutdown:   func() {},
+		ServerShutdown:      func() {},
+		spec:                spec,
+		useSwaggerUI:        false,
+		ServeError:          errors.ServeError,
+		BasicAuthenticator:  security.BasicAuth,
+		APIKeyAuthenticator: security.APIKeyAuth,
+		BearerAuthenticator: security.BearerAuth,
+
+		JSONConsumer:          runtime.JSONConsumer(),
+		MultipartformConsumer: runtime.DiscardConsumer,
+
+		JSONProducer: runtime.JSONProducer(),
+
+		UploadsUploadFileHandler: uploads.UploadFileHandlerFunc(func(params uploads.UploadFileParams) middleware.Responder {
+			return middleware.NotImplemented("operation uploads.UploadFile has not yet been implemented")
+		}),
+	}
+}
+
+/*FileUploadAPI Example server uploading a file */
+type FileUploadAPI struct {
+	spec            *loads.Document
+	context         *middleware.Context
+	handlers        map[string]map[string]http.Handler
+	formats         strfmt.Registry
+	customConsumers map[string]runtime.Consumer
+	customProducers map[string]runtime.Producer
+	defaultConsumes string
+	defaultProduces string
+	Middleware      func(middleware.Builder) http.Handler
+	useSwaggerUI    bool
+
+	// BasicAuthenticator generates a runtime.Authenticator from the supplied basic auth function.
+	// It has a default implementation in the security package, however you can replace it for your particular usage.
+	BasicAuthenticator func(security.UserPassAuthentication) runtime.Authenticator
+	// APIKeyAuthenticator generates a runtime.Authenticator from the supplied token auth function.
+	// It has a default implementation in the security package, however you can replace it for your particular usage.
+	APIKeyAuthenticator func(string, string, security.TokenAuthentication) runtime.Authenticator
+	// BearerAuthenticator generates a runtime.Authenticator from the supplied bearer token auth function.
+	// It has a default implementation in the security package, however you can replace it for your particular usage.
+	BearerAuthenticator func(string, security.ScopedTokenAuthentication) runtime.Authenticator
+
+	// JSONConsumer registers a consumer for the following mime types:
+	//   - application/json
+	JSONConsumer runtime.Consumer
+	// MultipartformConsumer registers a consumer for the following mime types:
+	//   - multipart/form-data
+	MultipartformConsumer runtime.Consumer
+
+	// JSONProducer registers a producer for the following mime types:
+	//   - application/json
+	JSONProducer runtime.Producer
+
+	// UploadsUploadFileHandler sets the operation handler for the upload file operation
+	UploadsUploadFileHandler uploads.UploadFileHandler
+	// ServeError is called when an error is received, there is a default handler
+	// but you can set your own with this
+	ServeError func(http.ResponseWriter, *http.Request, error)
+
+	// PreServerShutdown is called before the HTTP(S) server is shutdown
+	// This allows for custom functions to get executed before the HTTP(S) server stops accepting traffic
+	PreServerShutdown func()
+
+	// ServerShutdown is called when the HTTP(S) server is shut down and done
+	// handling all active connections and does not accept connections any more
+	ServerShutdown func()
+
+	// Custom command line argument groups with their descriptions
+	CommandLineOptionsGroups []swag.CommandLineOptionsGroup
+
+	// User defined logger function.
+	Logger func(string, ...interface{})
+}
+
+// UseRedoc for documentation at /docs
+func (o *FileUploadAPI) UseRedoc() {
+	o.useSwaggerUI = false
+}
+
+// UseSwaggerUI for documentation at /docs
+func (o *FileUploadAPI) UseSwaggerUI() {
+	o.useSwaggerUI = true
+}
+
+// SetDefaultProduces sets the default produces media type
+func (o *FileUploadAPI) SetDefaultProduces(mediaType string) {
+	o.defaultProduces = mediaType
+}
+
+// SetDefaultConsumes returns the default consumes media type
+func (o *FileUploadAPI) SetDefaultConsumes(mediaType string) {
+	o.defaultConsumes = mediaType
+}
+
+// SetSpec sets a spec that will be served for the clients.
+func (o *FileUploadAPI) SetSpec(spec *loads.Document) {
+	o.spec = spec
+}
+
+// DefaultProduces returns the default produces media type
+func (o *FileUploadAPI) DefaultProduces() string {
+	return o.defaultProduces
+}
+
+// DefaultConsumes returns the default consumes media type
+func (o *FileUploadAPI) DefaultConsumes() string {
+	return o.defaultConsumes
+}
+
+// Formats returns the registered string formats
+func (o *FileUploadAPI) Formats() strfmt.Registry {
+	return o.formats
+}
+
+// RegisterFormat registers a custom format validator
+func (o *FileUploadAPI) RegisterFormat(name string, format strfmt.Format, validator strfmt.Validator) {
+	o.formats.Add(name, format, validator)
+}
+
+// Validate validates the registrations in the FileUploadAPI
+func (o *FileUploadAPI) Validate() error {
+	var unregistered []string
+
+	if o.JSONConsumer == nil {
+		unregistered = append(unregistered, "JSONConsumer")
+	}
+	if o.MultipartformConsumer == nil {
+		unregistered = append(unregistered, "MultipartformConsumer")
+	}
+
+	if o.JSONProducer == nil {
+		unregistered = append(unregistered, "JSONProducer")
+	}
+
+	if o.UploadsUploadFileHandler == nil {
+		unregistered = append(unregistered, "uploads.UploadFileHandler")
+	}
+
+	if len(unregistered) > 0 {
+		return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
+	}
+
+	return nil
+}
+
+// ServeErrorFor gets a error handler for a given operation id
+func (o *FileUploadAPI) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
+	return o.ServeError
+}
+
+// AuthenticatorsFor gets the authenticators for the specified security schemes
+func (o *FileUploadAPI) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]runtime.Authenticator {
+	return nil
+}
+
+// Authorizer returns the registered authorizer
+func (o *FileUploadAPI) Authorizer() runtime.Authorizer {
+	return nil
+}
+
+// ConsumersFor gets the consumers for the specified media types.
+// MIME type parameters are ignored here.
+func (o *FileUploadAPI) ConsumersFor(mediaTypes []string) map[string]runtime.Consumer {
+	result := make(map[string]runtime.Consumer, len(mediaTypes))
+	for _, mt := range mediaTypes {
+		switch mt {
+		case "application/json":
+			result["application/json"] = o.JSONConsumer
+		case "multipart/form-data":
+			result["multipart/form-data"] = o.MultipartformConsumer
+		}
+
+		if c, ok := o.customConsumers[mt]; ok {
+			result[mt] = c
+		}
+	}
+	return result
+}
+
+// ProducersFor gets the producers for the specified media types.
+// MIME type parameters are ignored here.
+func (o *FileUploadAPI) ProducersFor(mediaTypes []string) map[string]runtime.Producer {
+	result := make(map[string]runtime.Producer, len(mediaTypes))
+	for _, mt := range mediaTypes {
+		switch mt {
+		case "application/json":
+			result["application/json"] = o.JSONProducer
+		}
+
+		if p, ok := o.customProducers[mt]; ok {
+			result[mt] = p
+		}
+	}
+	return result
+}
+
+// HandlerFor gets a http.Handler for the provided operation method and path
+func (o *FileUploadAPI) HandlerFor(method, path string) (http.Handler, bool) {
+	if o.handlers == nil {
+		return nil, false
+	}
+	um := strings.ToUpper(method)
+	if _, ok := o.handlers[um]; !ok {
+		return nil, false
+	}
+	if path == "/" {
+		path = ""
+	}
+	h, ok := o.handlers[um][path]
+	return h, ok
+}
+
+// Context returns the middleware context for the file upload API
+func (o *FileUploadAPI) Context() *middleware.Context {
+	if o.context == nil {
+		o.context = middleware.NewRoutableContext(o.spec, o, nil)
+	}
+
+	return o.context
+}
+
+func (o *FileUploadAPI) initHandlerCache() {
+	o.Context() // don't care about the result, just that the initialization happened
+	if o.handlers == nil {
+		o.handlers = make(map[string]map[string]http.Handler)
+	}
+
+	if o.handlers["POST"] == nil {
+		o.handlers["POST"] = make(map[string]http.Handler)
+	}
+	o.handlers["POST"]["/upload"] = uploads.NewUploadFile(o.context, o.UploadsUploadFileHandler)
+}
+
+// Serve creates a http handler to serve the API over HTTP
+// can be used directly in http.ListenAndServe(":8000", api.Serve(nil))
+func (o *FileUploadAPI) Serve(builder middleware.Builder) http.Handler {
+	o.Init()
+
+	if o.Middleware != nil {
+		return o.Middleware(builder)
+	}
+	if o.useSwaggerUI {
+		return o.context.APIHandlerSwaggerUI(builder)
+	}
+	return o.context.APIHandler(builder)
+}
+
+// Init allows you to just initialize the handler cache, you can then recompose the middleware as you see fit
+func (o *FileUploadAPI) Init() {
+	if len(o.handlers) == 0 {
+		o.initHandlerCache()
+	}
+}
+
+// RegisterConsumer allows you to add (or override) a consumer for a media type.
+func (o *FileUploadAPI) RegisterConsumer(mediaType string, consumer runtime.Consumer) {
+	o.customConsumers[mediaType] = consumer
+}
+
+// RegisterProducer allows you to add (or override) a producer for a media type.
+func (o *FileUploadAPI) RegisterProducer(mediaType string, producer runtime.Producer) {
+	o.customProducers[mediaType] = producer
+}
+
+// AddMiddlewareFor adds a http middleware to existing handler
+func (o *FileUploadAPI) AddMiddlewareFor(method, path string, builder middleware.Builder) {
+	um := strings.ToUpper(method)
+	if path == "/" {
+		path = ""
+	}
+	o.Init()
+	if h, ok := o.handlers[um][path]; ok {
+		o.handlers[method][path] = builder(h)
+	}
+}
diff --git a/examples/file-server/restapi/operations/uploads/upload_file.go b/examples/file-server/restapi/operations/uploads/upload_file.go
new file mode 100644
index 00000000..b105a8db
--- /dev/null
+++ b/examples/file-server/restapi/operations/uploads/upload_file.go
@@ -0,0 +1,56 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package uploads
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the generate command
+
+import (
+	"net/http"
+
+	"github.com/go-openapi/runtime/middleware"
+)
+
+// UploadFileHandlerFunc turns a function with the right signature into a upload file handler
+type UploadFileHandlerFunc func(UploadFileParams) middleware.Responder
+
+// Handle executing the request and returning a response
+func (fn UploadFileHandlerFunc) Handle(params UploadFileParams) middleware.Responder {
+	return fn(params)
+}
+
+// UploadFileHandler interface for that can handle valid upload file params
+type UploadFileHandler interface {
+	Handle(UploadFileParams) middleware.Responder
+}
+
+// NewUploadFile creates a new http.Handler for the upload file operation
+func NewUploadFile(ctx *middleware.Context, handler UploadFileHandler) *UploadFile {
+	return &UploadFile{Context: ctx, Handler: handler}
+}
+
+/*UploadFile swagger:route POST /upload uploads uploadFile
+
+uploads
+
+*/
+type UploadFile struct {
+	Context *middleware.Context
+	Handler UploadFileHandler
+}
+
+func (o *UploadFile) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
+	route, rCtx, _ := o.Context.RouteInfo(r)
+	if rCtx != nil {
+		r = rCtx
+	}
+	var Params = NewUploadFileParams()
+	if err := o.Context.BindValidRequest(r, route, &Params); err != nil { // bind params
+		o.Context.Respond(rw, r, route.Produces, route, err)
+		return
+	}
+
+	res := o.Handler.Handle(Params) // actually handle the request
+	o.Context.Respond(rw, r, route.Produces, route, res)
+
+}
diff --git a/examples/file-server/restapi/operations/uploads/upload_file_parameters.go b/examples/file-server/restapi/operations/uploads/upload_file_parameters.go
new file mode 100644
index 00000000..f27a7d1c
--- /dev/null
+++ b/examples/file-server/restapi/operations/uploads/upload_file_parameters.go
@@ -0,0 +1,79 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package uploads
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the swagger generate command
+
+import (
+	"io"
+	"mime/multipart"
+	"net/http"
+
+	"github.com/go-openapi/errors"
+	"github.com/go-openapi/runtime"
+	"github.com/go-openapi/runtime/middleware"
+)
+
+// NewUploadFileParams creates a new UploadFileParams object
+// no default values defined in spec.
+func NewUploadFileParams() UploadFileParams {
+
+	return UploadFileParams{}
+}
+
+// UploadFileParams contains all the bound params for the upload file operation
+// typically these are obtained from a http.Request
+//
+// swagger:parameters uploadFile
+type UploadFileParams struct {
+
+	// HTTP Request Object
+	HTTPRequest *http.Request `json:"-"`
+
+	/*
+	  Required: true
+	  In: formData
+	*/
+	File io.ReadCloser
+}
+
+// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable(strfmt.Registry) error interface
+// for simple values it will use straight method calls.
+//
+// To ensure default values, the struct must have been initialized with NewUploadFileParams() beforehand.
+func (o *UploadFileParams) BindRequest(r *http.Request, route *middleware.MatchedRoute) error {
+	var res []error
+
+	o.HTTPRequest = r
+
+	if err := r.ParseMultipartForm(32 << 20); err != nil {
+		if err != http.ErrNotMultipart {
+			return errors.New(400, "%v", err)
+		} else if err := r.ParseForm(); err != nil {
+			return errors.New(400, "%v", err)
+		}
+	}
+
+	file, fileHeader, err := r.FormFile("file")
+	if err != nil {
+		res = append(res, errors.New(400, "reading file %q failed: %v", "file", err))
+	} else if err := o.bindFile(file, fileHeader); err != nil {
+		// Required: true
+		res = append(res, err)
+	} else {
+		o.File = &runtime.File{Data: file, Header: fileHeader}
+	}
+
+	if len(res) > 0 {
+		return errors.CompositeValidationError(res...)
+	}
+	return nil
+}
+
+// bindFile binds file parameter File.
+//
+// The only supported validations on files are MinLength and MaxLength
+func (o *UploadFileParams) bindFile(file multipart.File, header *multipart.FileHeader) error {
+	return nil
+}
diff --git a/examples/file-server/restapi/operations/uploads/upload_file_responses.go b/examples/file-server/restapi/operations/uploads/upload_file_responses.go
new file mode 100644
index 00000000..b3e0382f
--- /dev/null
+++ b/examples/file-server/restapi/operations/uploads/upload_file_responses.go
@@ -0,0 +1,36 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package uploads
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the swagger generate command
+
+import (
+	"net/http"
+
+	"github.com/go-openapi/runtime"
+)
+
+// UploadFileOKCode is the HTTP code returned for type UploadFileOK
+const UploadFileOKCode int = 200
+
+/*UploadFileOK OK
+
+swagger:response uploadFileOK
+*/
+type UploadFileOK struct {
+}
+
+// NewUploadFileOK creates UploadFileOK with default headers values
+func NewUploadFileOK() *UploadFileOK {
+
+	return &UploadFileOK{}
+}
+
+// WriteResponse to the client
+func (o *UploadFileOK) WriteResponse(rw http.ResponseWriter, producer runtime.Producer) {
+
+	rw.Header().Del(runtime.HeaderContentType) //Remove Content-Type on empty responses
+
+	rw.WriteHeader(200)
+}
diff --git a/examples/file-server/restapi/operations/uploads/upload_file_urlbuilder.go b/examples/file-server/restapi/operations/uploads/upload_file_urlbuilder.go
new file mode 100644
index 00000000..9796572b
--- /dev/null
+++ b/examples/file-server/restapi/operations/uploads/upload_file_urlbuilder.go
@@ -0,0 +1,87 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package uploads
+
+// This file was generated by the swagger tool.
+// Editing this file might prove futile when you re-run the generate command
+
+import (
+	"errors"
+	"net/url"
+	golangswaggerpaths "path"
+)
+
+// UploadFileURL generates an URL for the upload file operation
+type UploadFileURL struct {
+	_basePath string
+}
+
+// WithBasePath sets the base path for this url builder, only required when it's different from the
+// base path specified in the swagger spec.
+// When the value of the base path is an empty string
+func (o *UploadFileURL) WithBasePath(bp string) *UploadFileURL {
+	o.SetBasePath(bp)
+	return o
+}
+
+// SetBasePath sets the base path for this url builder, only required when it's different from the
+// base path specified in the swagger spec.
+// When the value of the base path is an empty string
+func (o *UploadFileURL) SetBasePath(bp string) {
+	o._basePath = bp
+}
+
+// Build a url path and query string
+func (o *UploadFileURL) Build() (*url.URL, error) {
+	var _result url.URL
+
+	var _path = "/upload"
+
+	_basePath := o._basePath
+	if _basePath == "" {
+		_basePath = "/"
+	}
+	_result.Path = golangswaggerpaths.Join(_basePath, _path)
+
+	return &_result, nil
+}
+
+// Must is a helper function to panic when the url builder returns an error
+func (o *UploadFileURL) Must(u *url.URL, err error) *url.URL {
+	if err != nil {
+		panic(err)
+	}
+	if u == nil {
+		panic("url can't be nil")
+	}
+	return u
+}
+
+// String returns the string representation of the path with query string
+func (o *UploadFileURL) String() string {
+	return o.Must(o.Build()).String()
+}
+
+// BuildFull builds a full url with scheme, host, path and query string
+func (o *UploadFileURL) BuildFull(scheme, host string) (*url.URL, error) {
+	if scheme == "" {
+		return nil, errors.New("scheme is required for a full url on UploadFileURL")
+	}
+	if host == "" {
+		return nil, errors.New("host is required for a full url on UploadFileURL")
+	}
+
+	base, err := o.Build()
+	if err != nil {
+		return nil, err
+	}
+
+	base.Scheme = scheme
+	base.Host = host
+	return base, nil
+}
+
+// StringFull returns the string representation of a complete url
+func (o *UploadFileURL) StringFull(scheme, host string) string {
+	return o.Must(o.BuildFull(scheme, host)).String()
+}
diff --git a/examples/file-server/restapi/server.go b/examples/file-server/restapi/server.go
new file mode 100644
index 00000000..4671f60e
--- /dev/null
+++ b/examples/file-server/restapi/server.go
@@ -0,0 +1,511 @@
+// Code generated by go-swagger; DO NOT EDIT.
+
+package restapi
+
+import (
+	"context"
+	"crypto/tls"
+	"crypto/x509"
+	"errors"
+	"fmt"
+	"io/ioutil"
+	"log"
+	"net"
+	"net/http"
+	"os"
+	"os/signal"
+	"strconv"
+	"sync"
+	"sync/atomic"
+	"syscall"
+	"time"
+
+	"github.com/go-openapi/runtime/flagext"
+	"github.com/go-openapi/swag"
+	flags "github.com/jessevdk/go-flags"
+	"golang.org/x/net/netutil"
+
+	"github.com/go-swagger/go-swagger/examples/file-server/restapi/operations"
+)
+
+const (
+	schemeHTTP  = "http"
+	schemeHTTPS = "https"
+	schemeUnix  = "unix"
+)
+
+var defaultSchemes []string
+
+func init() {
+	defaultSchemes = []string{
+		schemeHTTP,
+	}
+}
+
+// NewServer creates a new api file upload server but does not configure it
+func NewServer(api *operations.FileUploadAPI) *Server {
+	s := new(Server)
+
+	s.shutdown = make(chan struct{})
+	s.api = api
+	s.interrupt = make(chan os.Signal, 1)
+	return s
+}
+
+// ConfigureAPI configures the API and handlers.
+func (s *Server) ConfigureAPI() {
+	if s.api != nil {
+		s.handler = configureAPI(s.api)
+	}
+}
+
+// ConfigureFlags configures the additional flags defined by the handlers. Needs to be called before the parser.Parse
+func (s *Server) ConfigureFlags() {
+	if s.api != nil {
+		configureFlags(s.api)
+	}
+}
+
+// Server for the file upload API
+type Server struct {
+	EnabledListeners []string         `long:"scheme" description:"the listeners to enable, this can be repeated and defaults to the schemes in the swagger spec"`
+	CleanupTimeout   time.Duration    `long:"cleanup-timeout" description:"grace period for which to wait before killing idle connections" default:"10s"`
+	GracefulTimeout  time.Duration    `long:"graceful-timeout" description:"grace period for which to wait before shutting down the server" default:"15s"`
+	MaxHeaderSize    flagext.ByteSize `long:"max-header-size" description:"controls the maximum number of bytes the server will read parsing the request header's keys and values, including the request line. It does not limit the size of the request body." default:"1MiB"`
+
+	SocketPath    flags.Filename `long:"socket-path" description:"the unix socket to listen on" default:"/var/run/file-upload.sock"`
+	domainSocketL net.Listener
+
+	Host         string        `long:"host" description:"the IP to listen on" default:"localhost" env:"HOST"`
+	Port         int           `long:"port" description:"the port to listen on for insecure connections, defaults to a random value" env:"PORT"`
+	ListenLimit  int           `long:"listen-limit" description:"limit the number of outstanding requests"`
+	KeepAlive    time.Duration `long:"keep-alive" description:"sets the TCP keep-alive timeouts on accepted connections. It prunes dead TCP connections ( e.g. closing laptop mid-download)" default:"3m"`
+	ReadTimeout  time.Duration `long:"read-timeout" description:"maximum duration before timing out read of the request" default:"30s"`
+	WriteTimeout time.Duration `long:"write-timeout" description:"maximum duration before timing out write of the response" default:"60s"`
+	httpServerL  net.Listener
+
+	TLSHost           string         `long:"tls-host" description:"the IP to listen on for tls, when not specified it's the same as --host" env:"TLS_HOST"`
+	TLSPort           int            `long:"tls-port" description:"the port to listen on for secure connections, defaults to a random value" env:"TLS_PORT"`
+	TLSCertificate    flags.Filename `long:"tls-certificate" description:"the certificate to use for secure connections" env:"TLS_CERTIFICATE"`
+	TLSCertificateKey flags.Filename `long:"tls-key" description:"the private key to use for secure connections" env:"TLS_PRIVATE_KEY"`
+	TLSCACertificate  flags.Filename `long:"tls-ca" description:"the certificate authority file to be used with mutual tls auth" env:"TLS_CA_CERTIFICATE"`
+	TLSListenLimit    int            `long:"tls-listen-limit" description:"limit the number of outstanding requests"`
+	TLSKeepAlive      time.Duration  `long:"tls-keep-alive" description:"sets the TCP keep-alive timeouts on accepted connections. It prunes dead TCP connections ( e.g. closing laptop mid-download)"`
+	TLSReadTimeout    time.Duration  `long:"tls-read-timeout" description:"maximum duration before timing out read of the request"`
+	TLSWriteTimeout   time.Duration  `long:"tls-write-timeout" description:"maximum duration before timing out write of the response"`
+	httpsServerL      net.Listener
+
+	api          *operations.FileUploadAPI
+	handler      http.Handler
+	hasListeners bool
+	shutdown     chan struct{}
+	shuttingDown int32
+	interrupted  bool
+	interrupt    chan os.Signal
+}
+
+// Logf logs message either via defined user logger or via system one if no user logger is defined.
+func (s *Server) Logf(f string, args ...interface{}) {
+	if s.api != nil && s.api.Logger != nil {
+		s.api.Logger(f, args...)
+	} else {
+		log.Printf(f, args...)
+	}
+}
+
+// Fatalf logs message either via defined user logger or via system one if no user logger is defined.
+// Exits with non-zero status after printing
+func (s *Server) Fatalf(f string, args ...interface{}) {
+	if s.api != nil && s.api.Logger != nil {
+		s.api.Logger(f, args...)
+		os.Exit(1)
+	} else {
+		log.Fatalf(f, args...)
+	}
+}
+
+// SetAPI configures the server with the specified API. Needs to be called before Serve
+func (s *Server) SetAPI(api *operations.FileUploadAPI) {
+	if api == nil {
+		s.api = nil
+		s.handler = nil
+		return
+	}
+
+	s.api = api
+	s.handler = configureAPI(api)
+}
+
+func (s *Server) hasScheme(scheme string) bool {
+	schemes := s.EnabledListeners
+	if len(schemes) == 0 {
+		schemes = defaultSchemes
+	}
+
+	for _, v := range schemes {
+		if v == scheme {
+			return true
+		}
+	}
+	return false
+}
+
+// Serve the api
+func (s *Server) Serve() (err error) {
+	if !s.hasListeners {
+		if err = s.Listen(); err != nil {
+			return err
+		}
+	}
+
+	// set default handler, if none is set
+	if s.handler == nil {
+		if s.api == nil {
+			return errors.New("can't create the default handler, as no api is set")
+		}
+
+		s.SetHandler(s.api.Serve(nil))
+	}
+
+	wg := new(sync.WaitGroup)
+	once := new(sync.Once)
+	signalNotify(s.interrupt)
+	go handleInterrupt(once, s)
+
+	servers := []*http.Server{}
+
+	if s.hasScheme(schemeUnix) {
+		domainSocket := new(http.Server)
+		domainSocket.MaxHeaderBytes = int(s.MaxHeaderSize)
+		domainSocket.Handler = s.handler
+		if int64(s.CleanupTimeout) > 0 {
+			domainSocket.IdleTimeout = s.CleanupTimeout
+		}
+
+		configureServer(domainSocket, "unix", string(s.SocketPath))
+
+		servers = append(servers, domainSocket)
+		wg.Add(1)
+		s.Logf("Serving file upload at unix://%s", s.SocketPath)
+		go func(l net.Listener) {
+			defer wg.Done()
+			if err := domainSocket.Serve(l); err != nil && err != http.ErrServerClosed {
+				s.Fatalf("%v", err)
+			}
+			s.Logf("Stopped serving file upload at unix://%s", s.SocketPath)
+		}(s.domainSocketL)
+	}
+
+	if s.hasScheme(schemeHTTP) {
+		httpServer := new(http.Server)
+		httpServer.MaxHeaderBytes = int(s.MaxHeaderSize)
+		httpServer.ReadTimeout = s.ReadTimeout
+		httpServer.WriteTimeout = s.WriteTimeout
+		httpServer.SetKeepAlivesEnabled(int64(s.KeepAlive) > 0)
+		if s.ListenLimit > 0 {
+			s.httpServerL = netutil.LimitListener(s.httpServerL, s.ListenLimit)
+		}
+
+		if int64(s.CleanupTimeout) > 0 {
+			httpServer.IdleTimeout = s.CleanupTimeout
+		}
+
+		httpServer.Handler = s.handler
+
+		configureServer(httpServer, "http", s.httpServerL.Addr().String())
+
+		servers = append(servers, httpServer)
+		wg.Add(1)
+		s.Logf("Serving file upload at http://%s", s.httpServerL.Addr())
+		go func(l net.Listener) {
+			defer wg.Done()
+			if err := httpServer.Serve(l); err != nil && err != http.ErrServerClosed {
+				s.Fatalf("%v", err)
+			}
+			s.Logf("Stopped serving file upload at http://%s", l.Addr())
+		}(s.httpServerL)
+	}
+
+	if s.hasScheme(schemeHTTPS) {
+		httpsServer := new(http.Server)
+		httpsServer.MaxHeaderBytes = int(s.MaxHeaderSize)
+		httpsServer.ReadTimeout = s.TLSReadTimeout
+		httpsServer.WriteTimeout = s.TLSWriteTimeout
+		httpsServer.SetKeepAlivesEnabled(int64(s.TLSKeepAlive) > 0)
+		if s.TLSListenLimit > 0 {
+			s.httpsServerL = netutil.LimitListener(s.httpsServerL, s.TLSListenLimit)
+		}
+		if int64(s.CleanupTimeout) > 0 {
+			httpsServer.IdleTimeout = s.CleanupTimeout
+		}
+		httpsServer.Handler = s.handler
+
+		// Inspired by https://blog.bracebin.com/achieving-perfect-ssl-labs-score-with-go
+		httpsServer.TLSConfig = &tls.Config{
+			// Causes servers to use Go's default ciphersuite preferences,
+			// which are tuned to avoid attacks. Does nothing on clients.
+			PreferServerCipherSuites: true,
+			// Only use curves which have assembly implementations
+			// https://github.com/golang/go/tree/master/src/crypto/elliptic
+			CurvePreferences: []tls.CurveID{tls.CurveP256},
+			// Use modern tls mode https://wiki.mozilla.org/Security/Server_Side_TLS#Modern_compatibility
+			NextProtos: []string{"h2", "http/1.1"},
+			// https://www.owasp.org/index.php/Transport_Layer_Protection_Cheat_Sheet#Rule_-_Only_Support_Strong_Protocols
+			MinVersion: tls.VersionTLS12,
+			// These ciphersuites support Forward Secrecy: https://en.wikipedia.org/wiki/Forward_secrecy
+			CipherSuites: []uint16{
+				tls.TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384,
+				tls.TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384,
+				tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256,
+				tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
+				tls.TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305,
+				tls.TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305,
+			},
+		}
+
+		// build standard config from server options
+		if s.TLSCertificate != "" && s.TLSCertificateKey != "" {
+			httpsServer.TLSConfig.Certificates = make([]tls.Certificate, 1)
+			httpsServer.TLSConfig.Certificates[0], err = tls.LoadX509KeyPair(string(s.TLSCertificate), string(s.TLSCertificateKey))
+			if err != nil {
+				return err
+			}
+		}
+
+		if s.TLSCACertificate != "" {
+			// include specified CA certificate
+			caCert, caCertErr := ioutil.ReadFile(string(s.TLSCACertificate))
+			if caCertErr != nil {
+				return caCertErr
+			}
+			caCertPool := x509.NewCertPool()
+			ok := caCertPool.AppendCertsFromPEM(caCert)
+			if !ok {
+				return fmt.Errorf("cannot parse CA certificate")
+			}
+			httpsServer.TLSConfig.ClientCAs = caCertPool
+			httpsServer.TLSConfig.ClientAuth = tls.RequireAndVerifyClientCert
+		}
+
+		// call custom TLS configurator
+		configureTLS(httpsServer.TLSConfig)
+
+		if len(httpsServer.TLSConfig.Certificates) == 0 && httpsServer.TLSConfig.GetCertificate == nil {
+			// after standard and custom config are passed, this ends up with no certificate
+			if s.TLSCertificate == "" {
+				if s.TLSCertificateKey == "" {
+					s.Fatalf("the required flags `--tls-certificate` and `--tls-key` were not specified")
+				}
+				s.Fatalf("the required flag `--tls-certificate` was not specified")
+			}
+			if s.TLSCertificateKey == "" {
+				s.Fatalf("the required flag `--tls-key` was not specified")
+			}
+			// this happens with a wrong custom TLS configurator
+			s.Fatalf("no certificate was configured for TLS")
+		}
+
+		// must have at least one certificate or panics
+		httpsServer.TLSConfig.BuildNameToCertificate()
+
+		configureServer(httpsServer, "https", s.httpsServerL.Addr().String())
+
+		servers = append(servers, httpsServer)
+		wg.Add(1)
+		s.Logf("Serving file upload at https://%s", s.httpsServerL.Addr())
+		go func(l net.Listener) {
+			defer wg.Done()
+			if err := httpsServer.Serve(l); err != nil && err != http.ErrServerClosed {
+				s.Fatalf("%v", err)
+			}
+			s.Logf("Stopped serving file upload at https://%s", l.Addr())
+		}(tls.NewListener(s.httpsServerL, httpsServer.TLSConfig))
+	}
+
+	wg.Add(1)
+	go s.handleShutdown(wg, &servers)
+
+	wg.Wait()
+	return nil
+}
+
+// Listen creates the listeners for the server
+func (s *Server) Listen() error {
+	if s.hasListeners { // already done this
+		return nil
+	}
+
+	if s.hasScheme(schemeHTTPS) {
+		// Use http host if https host wasn't defined
+		if s.TLSHost == "" {
+			s.TLSHost = s.Host
+		}
+		// Use http listen limit if https listen limit wasn't defined
+		if s.TLSListenLimit == 0 {
+			s.TLSListenLimit = s.ListenLimit
+		}
+		// Use http tcp keep alive if https tcp keep alive wasn't defined
+		if int64(s.TLSKeepAlive) == 0 {
+			s.TLSKeepAlive = s.KeepAlive
+		}
+		// Use http read timeout if https read timeout wasn't defined
+		if int64(s.TLSReadTimeout) == 0 {
+			s.TLSReadTimeout = s.ReadTimeout
+		}
+		// Use http write timeout if https write timeout wasn't defined
+		if int64(s.TLSWriteTimeout) == 0 {
+			s.TLSWriteTimeout = s.WriteTimeout
+		}
+	}
+
+	if s.hasScheme(schemeUnix) {
+		domSockListener, err := net.Listen("unix", string(s.SocketPath))
+		if err != nil {
+			return err
+		}
+		s.domainSocketL = domSockListener
+	}
+
+	if s.hasScheme(schemeHTTP) {
+		listener, err := net.Listen("tcp", net.JoinHostPort(s.Host, strconv.Itoa(s.Port)))
+		if err != nil {
+			return err
+		}
+
+		h, p, err := swag.SplitHostPort(listener.Addr().String())
+		if err != nil {
+			return err
+		}
+		s.Host = h
+		s.Port = p
+		s.httpServerL = listener
+	}
+
+	if s.hasScheme(schemeHTTPS) {
+		tlsListener, err := net.Listen("tcp", net.JoinHostPort(s.TLSHost, strconv.Itoa(s.TLSPort)))
+		if err != nil {
+			return err
+		}
+
+		sh, sp, err := swag.SplitHostPort(tlsListener.Addr().String())
+		if err != nil {
+			return err
+		}
+		s.TLSHost = sh
+		s.TLSPort = sp
+		s.httpsServerL = tlsListener
+	}
+
+	s.hasListeners = true
+	return nil
+}
+
+// Shutdown server and clean up resources
+func (s *Server) Shutdown() error {
+	if atomic.CompareAndSwapInt32(&s.shuttingDown, 0, 1) {
+		close(s.shutdown)
+	}
+	return nil
+}
+
+func (s *Server) handleShutdown(wg *sync.WaitGroup, serversPtr *[]*http.Server) {
+	// wg.Done must occur last, after s.api.ServerShutdown()
+	// (to preserve old behaviour)
+	defer wg.Done()
+
+	<-s.shutdown
+
+	servers := *serversPtr
+
+	ctx, cancel := context.WithTimeout(context.TODO(), s.GracefulTimeout)
+	defer cancel()
+
+	// first execute the pre-shutdown hook
+	s.api.PreServerShutdown()
+
+	shutdownChan := make(chan bool)
+	for i := range servers {
+		server := servers[i]
+		go func() {
+			var success bool
+			defer func() {
+				shutdownChan <- success
+			}()
+			if err := server.Shutdown(ctx); err != nil {
+				// Error from closing listeners, or context timeout:
+				s.Logf("HTTP server Shutdown: %v", err)
+			} else {
+				success = true
+			}
+		}()
+	}
+
+	// Wait until all listeners have successfully shut down before calling ServerShutdown
+	success := true
+	for range servers {
+		success = success && <-shutdownChan
+	}
+	if success {
+		s.api.ServerShutdown()
+	}
+}
+
+// GetHandler returns a handler useful for testing
+func (s *Server) GetHandler() http.Handler {
+	return s.handler
+}
+
+// SetHandler allows for setting a http handler on this server
+func (s *Server) SetHandler(handler http.Handler) {
+	s.handler = handler
+}
+
+// UnixListener returns the domain socket listener
+func (s *Server) UnixListener() (net.Listener, error) {
+	if !s.hasListeners {
+		if err := s.Listen(); err != nil {
+			return nil, err
+		}
+	}
+	return s.domainSocketL, nil
+}
+
+// HTTPListener returns the http listener
+func (s *Server) HTTPListener() (net.Listener, error) {
+	if !s.hasListeners {
+		if err := s.Listen(); err != nil {
+			return nil, err
+		}
+	}
+	return s.httpServerL, nil
+}
+
+// TLSListener returns the https listener
+func (s *Server) TLSListener() (net.Listener, error) {
+	if !s.hasListeners {
+		if err := s.Listen(); err != nil {
+			return nil, err
+		}
+	}
+	return s.httpsServerL, nil
+}
+
+func handleInterrupt(once *sync.Once, s *Server) {
+	once.Do(func() {
+		for range s.interrupt {
+			if s.interrupted {
+				s.Logf("Server already shutting down")
+				continue
+			}
+			s.interrupted = true
+			s.Logf("Shutting down... ")
+			if err := s.Shutdown(); err != nil {
+				s.Logf("HTTP server Shutdown: %v", err)
+			}
+		}
+	})
+}
+
+func signalNotify(interrupt chan<- os.Signal) {
+	signal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM)
+}
diff --git a/examples/file-server/swagger.yml b/examples/file-server/swagger.yml
new file mode 100644
index 00000000..ea6b491c
--- /dev/null
+++ b/examples/file-server/swagger.yml
@@ -0,0 +1,30 @@
+swagger: "2.0"
+info:
+  description: Example server uploading a file
+  version: "1.0.0"
+  title: File Upload
+basePath: /
+schemes:
+  - http
+consumes:
+  - application/json
+produces:
+  - application/json
+
+paths:
+  /upload:
+    post:
+      tags:
+      - uploads
+      summary: uploads
+      operationId: uploadFile
+      consumes:
+      - multipart/form-data
+      parameters:
+      - name: file
+        in: formData
+        type: file
+        required: true
+      responses:
+        "200":
+          description: OK
diff --git a/examples/file-server/upload_file.go b/examples/file-server/upload_file.go
new file mode 100644
index 00000000..1ca895e9
--- /dev/null
+++ b/examples/file-server/upload_file.go
@@ -0,0 +1,43 @@
+// +build ignore
+
+package main
+
+import (
+	"log"
+	"os"
+
+	"github.com/go-openapi/runtime"
+	"github.com/go-swagger/go-swagger/examples/file-server/client"
+	"github.com/go-swagger/go-swagger/examples/file-server/client/uploads"
+)
+
+func main() {
+	if len(os.Args) < 2 {
+		log.Fatalf("must provide a file name as argument")
+	}
+
+	filename := os.Args[1]
+
+	f, err := os.Open(filename)
+	if err != nil {
+		log.Fatal(err)
+	}
+
+	err = upload(f)
+	if err != nil {
+		log.Fatal(err)
+	}
+}
+
+func upload(reader runtime.NamedReadCloser) error {
+
+	config := client.DefaultTransportConfig().WithHost("localhost:8000")
+
+	uploader := client.NewHTTPClientWithConfig(nil, config)
+
+	params := uploads.NewUploadFileParams().WithFile(reader)
+
+	_, err := uploader.Uploads.UploadFile(params)
+
+	return err
+}
diff --git a/generator/bindata.go b/generator/bindata.go
index 7510f363..c0c83bda 100644
--- a/generator/bindata.go
+++ b/generator/bindata.go
@@ -1,6 +1,6 @@
 // Code generated by go-bindata. DO NOT EDIT.
 // sources:
-// templates/client/client.gotmpl (5.197kB)
+// templates/client/client.gotmpl (5.125kB)
 // templates/client/facade.gotmpl (3.83kB)
 // templates/client/parameter.gotmpl (15.048kB)
 // templates/client/response.gotmpl (10.424kB)
@@ -113,7 +113,7 @@ func (fi bindataFileInfo) Sys() interface{} {
 	return nil
 }
 
-var _templatesClientClientGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x58\x4d\x6f\xdb\x38\x13\x3e\x57\xbf\x62\x5e\xbf\x69\x61\x1b\x8e\xb4\x7b\xd5\x22\x87\x20\xe9\xa2\x39\x34\x09\x62\x63\x7b\x5c\xd0\xd2\x48\x22\x22\x91\x2a\x49\xd9\x75\x05\xfd\xf7\x05\x3f\xf4\x65\xd9\x49\x16\x58\x74\xf7\xd0\x4b\x2c\x69\x3e\x38\xf3\xcc\x3c\x43\x32\x41\x00\x37\x3c\x46\x48\x91\xa1\x20\x0a\x63\xd8\x1e\x20\xe5\x97\x72\x4f\xd2\x14\xc5\x6f\x70\xfb\x00\xf7\x0f\x1b\xf8\x78\x7b\xb7\xf1\x3d\xcf\xab\x6b\xa0\x09\xf8\x37\xbc\x3c\x08\x9a\x66\x0a\x2e\x9b\x26\x08\xa0\xae\x21\xe2\x45\x81\x4c\x1d\xc9\xea\x1a\x90\xc5\xd0\x34\x9e\xe7\x95\x24\x7a\x26\x29\x6a\x65\xff\x9e\x14\x68\xbe\x06\x01\x6c\x32\x2a\x21\xa1\x39\xc2\x9e\xc8\x71\x24\x2a\x43\x70\xa1\x80\xe2\x3c\xf7\xb5\xfe\xc7\x98\x2a\xca\x52\x50\x9d\x5d\x61\x96\x2b\x05\xdf\x21\x24\x95\x32\xae\x32\x64\x70\xe0\x15\x08\xbc\x14\x15\x1b\x79\x6a\x97\x30\x31\x13\x16\x7b\x1e\x2d\x4a\x2e\x14\xcc\x3d\x80\x59\x52\xa8\x99\xfe\xa5\xdc\xfc\x30\x54\x41\xa6\x54\x39\xf3\xf4\x5b\x4a\x55\x56\x6d\xfd\x88\x17\x41\xca\x2f\x79\x89\x8c\x94\x34\x40\x21\xb8\x90\xb3\xf3\x0a\xa2\x62\x8a\x16\xf8\x82\x86\x54\xa2\x5d\xf8\x8c\xc2\x9e\xa4\x2f\x88\x77\x24\xa7\x31\x51\x68\xc2\xd4\x55\x32\x19\x49\xf0\x6f\x31\x21\x55\xae\xee\xdc\x7b\xd3\x1c\xc9\x07\x82\x85\x29\xc7\x3d\xee\x21\x12\x48\x14\x4a\x20\xc0\x70\xaf\xd5\xb3\xaa\x20\x8c\x7e\xc7\xae\x72\x70\xfd\x78\x07\x51\x4e\x91\x29\xdf\x4b\x2a\x16\x69\xbb\xb9\x12\x84\x49\x03\xa5\xcb\xd8\xbf\x31\x2a\x9b\xf6\xfb\x0a\x12\x2e\x0a\xa2\x24\xd8\x84\xfd\x27\x4c\xa9\x54\xe2\xb0\x00\xab\xb9\x46\xb1\xa3\x11\x42\xed\x01\x08\x54\x95\x60\xf0\xc1\x4a\xea\xce\x79\x08\x6a\xe2\x2f\x6c\x1f\x1a\x4f\x77\xd5\xd2\xb3\x46\xe0\x1a\x76\x5d\x15\x05\x11\x07\x30\x1d\x39\x7e\xd3\xe2\x5b\x94\x91\xa0\xa5\xa2\x9c\x99\xae\xac\x6b\xd8\xe6\x3c\x7a\xee\x9a\x7a\xac\xd0\x75\xb5\x7e\xc8\x25\x1e\xfb\x30\x82\xd7\x1c\x68\xbb\xa6\x49\xb8\x38\x8b\x6f\x4f\x9e\x65\xe0\xa9\x43\x89\x0e\x23\x8d\x5d\x15\x29\x83\xd1\xab\x88\x7b\x70\x0e\x72\xcf\xd2\x6f\x8c\x3b\x95\x86\x2a\x94\x29\x14\x09\x89\x50\x1b\xb7\xcb\x16\xa8\x32\x1e\xcb\x61\x28\x9d\x59\xa7\x5f\x7b\xef\xea\x1a\x04\x61\x29\x82\xff\x50\x6a\xa2\x51\xce\x4c\x7f\x69\x41\x49\x64\x44\xf2\x61\xa6\xf3\x92\x08\x52\x48\x58\x9e\x94\x3e\x1a\xa1\x2b\xd3\x75\xa5\x32\x2e\xe8\x77\xd4\xa0\xac\x80\x54\x2a\xbb\x63\x09\x3f\x4a\xfd\xda\x7d\xfe\x22\xa8\x42\x51\xd7\xc8\xe2\xae\xd0\x9f\x88\x5c\x2b\x81\xa4\xa0\x2c\x7d\x42\x59\x72\x66\xaa\xb0\x82\xbd\x51\x06\xca\xfd\xd6\xcc\x61\xbf\xe8\x5b\x28\x8a\x50\xca\x81\xd5\xbc\x4f\xf4\x48\xa8\xd3\x3d\x9d\xcf\x0a\x46\xcd\x63\x1e\xcc\xf8\x38\xbb\xca\xa2\x6f\x83\x77\x83\x71\xfa\x6e\x8d\x7d\x91\x5f\x27\xde\xc2\xb3\x6d\x7d\xb2\x30\xc1\xd2\x0e\x85\x69\xb8\x27\xf9\x53\xe6\x95\x30\x6a\xbf\x53\x21\xd5\x17\x2e\x62\x98\xf7\x0d\xec\x54\x17\xe7\xd9\x65\xd6\xfa\x41\xfc\x7a\x13\xb7\xcc\xfc\x9a\x13\x58\x5a\xd0\x16\xa7\xb1\xf8\xd9\xa8\x6f\x6d\x54\x33\x99\xf4\xce\xfe\x70\xfb\x10\xc2\x1f\x6e\x6b\x32\x83\xc5\x61\xb8\xc5\x84\x0b\x04\x89\x2c\xa6\x2c\xf5\x40\xbb\x74\xa2\xab\x2b\x60\x34\x37\x2e\xa0\xfb\xa6\x77\x97\x17\x60\x9f\x2f\x3c\x00\xb7\xb3\x5d\xe4\xc8\x52\x95\x41\x78\x05\x39\xb2\x93\x19\xbb\x2d\xf0\x64\x16\x02\x65\x95\xab\xba\xd6\xfd\xd3\x34\x7f\x76\x39\xad\x00\x85\xd0\x4e\x89\xdf\x91\xcd\x5f\x57\xdb\x82\xaa\xf9\x87\x71\x5d\x3b\x72\xd9\x1c\xee\x6e\x43\xd3\x50\x82\x32\x95\xc0\xec\xfd\xd7\x59\x0f\xb2\x51\xf8\x6c\xe6\xea\x54\xc9\x7e\xef\xd4\x1e\x89\xca\x1e\x89\x52\x28\xd8\x54\x57\x0b\x7b\x4d\xc1\xe3\x2a\x42\xf9\x19\x63\x4a\x36\x87\x12\xe5\xd8\xe0\xff\x3b\x6d\x31\x51\xea\xec\x6f\x38\x93\x55\xf1\x8a\xfd\x54\xa9\xb3\x5f\x47\x19\x16\x27\x8d\x9c\x64\x90\x93\x2e\x5f\xe8\xea\x6c\xbf\x3d\x21\x89\x51\x84\xf0\xe1\x64\xc1\xad\xb4\xee\xb6\x7d\xe2\xbb\xc7\xb7\x11\x27\x74\xbf\x5d\x5d\x5d\x20\x75\x7d\x39\x65\xae\x91\xb4\x2c\x0d\x3b\x1a\xf7\x16\x86\xb1\x2d\x64\x0a\xbf\xa9\x36\x13\xdf\xbd\x3b\x3c\x4d\x5b\x74\xb2\x4f\x9b\xcd\xa3\xfd\xa4\xc5\xcd\xc2\xb6\xbf\x6e\xaf\xff\x0d\x7b\xdf\x1d\x7f\xce\x76\xaa\x81\x27\x5e\x57\x42\xf0\x8a\xc5\x30\x63\x34\x9f\xb9\xbf\xbf\x74\x2c\x18\x11\x19\x85\xe8\x78\x72\x79\xc6\xeb\x10\x0d\xfc\xda\xf9\xf9\xd5\x8a\xa4\xd5\x5f\x01\x7f\xd6\x5c\xb0\x64\xf1\xe7\x47\x23\xe4\xc8\x6b\x5b\x3a\x97\x28\x7f\x1e\x27\xd8\xfa\x64\x34\x77\xd1\x05\x01\x54\x0c\xbf\x95\x18\xe9\x7b\x80\x93\xeb\xc5\x8c\x3b\x63\xdb\xa7\xe0\x0e\xb8\x23\x60\x82\xa5\x16\x11\x88\xad\xac\x33\xd5\xc7\x1b\x7d\x4d\xa0\x31\xc6\x2b\x7d\x77\xc8\xed\x2d\x82\xb0\xb8\x8d\x86\x30\x30\x63\x0e\x96\x81\xc9\xb8\x0f\xc4\x65\xf5\x42\xde\x47\xa1\x0c\xf3\x76\xde\x19\xcd\x57\xdd\x2e\x70\x8f\xfb\xeb\xc7\xbb\x8f\x7a\xb5\xf9\xec\x85\x84\x43\x88\x74\x37\x31\x05\x64\x47\x68\x4e\xb6\x39\x02\x91\x27\x92\x73\xa1\xcf\x56\xd3\xa8\x4f\x7c\xf2\xf5\xcd\x6f\xbe\x58\x0c\xf0\x74\x9b\x66\x3f\xbd\xe7\x89\xc0\x78\x11\x82\xc0\x42\x5f\xae\x4a\xc2\x68\x64\xa5\x92\x24\x98\x56\x44\xc4\x21\x30\x4d\xc0\x3c\x3f\xac\x80\x6c\xa5\x09\x73\x12\x9b\x5e\xfe\x99\xf1\x3d\x9b\x24\x27\x27\xc0\x93\x2d\xdf\x61\x08\x92\xdb\xda\xe8\xf2\x40\xc4\x63\x4c\x91\x01\x95\xb2\xd2\x0d\x50\xc8\x54\xd7\x41\x1f\x67\xd7\x76\xc2\xbc\x88\x20\xb8\x63\x76\x5b\x91\xd0\x5e\x5f\x38\x53\x82\x44\x0a\x18\x57\x80\x2c\xe1\x22\xb2\xd7\x4e\x89\x62\x87\xc2\x6f\xcf\xbd\x9d\x5b\xc5\x21\x45\xd5\x45\xba\x82\x6d\xa5\x20\xe5\x2a\x84\xf7\x9b\xd9\xca\x75\x85\xc6\xd3\xe0\x34\x2f\x64\x3a\x02\x97\xc5\x43\x7e\x75\x07\x94\x60\x09\x12\x77\x28\x48\x0e\x25\x97\x92\xea\xf2\x4e\x51\x72\xed\x28\xf7\x54\x45\x19\xec\x48\x5e\xe1\xb0\x13\xf5\x99\x7c\xe1\x78\x65\xfd\xdb\x0d\xff\x82\xae\xe0\x62\xa7\x35\xcf\x6c\x84\x11\x91\x78\x74\xa4\xb9\xd8\x75\x38\x1d\x0d\xa2\xd1\xbc\x31\x31\xb4\x13\xe7\x82\x8e\x46\x8e\xe5\xf2\x24\xf3\xe6\xc7\x72\xf7\xd5\x39\xf2\xcf\x92\xfb\xcd\x03\xf9\xe7\x00\xf8\xb7\x06\xc0\xc5\x7f\x6a\x02\xb4\xaf\x63\xe4\xfb\xad\xc2\x1b\xe9\x35\xde\xe0\x45\xdf\xdc\x87\x37\x40\x88\x32\xcd\x77\x7b\x7b\xef\x6f\x83\xdc\xfe\xe7\xcb\xfe\xa3\x66\x7a\xcf\xf9\x9b\x77\x48\x33\x5f\x06\xe7\x5f\xb8\xea\x97\xf2\x1a\xef\xaf\x00\x00\x00\xff\xff\x37\xbc\xd1\x14\x4d\x14\x00\x00")
+var _templatesClientClientGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x58\x4d\x6f\xdb\x38\x13\x3e\x57\xbf\x62\x5e\xbf\x69\x61\x1b\x8a\xb4\x7b\xf5\x22\x87\x20\xe9\xa2\x39\x34\x09\x62\x63\x7b\x5c\xd0\xd2\x48\x22\x22\x91\x2a\x49\xd9\x75\x05\xfd\xf7\x05\x3f\x44\x4b\xfe\x48\xb2\xc0\x6e\xb1\x87\x5e\x62\x49\xf3\xc1\x99\x67\xe6\x19\x92\x89\x63\xb8\xe1\x29\x42\x8e\x0c\x05\x51\x98\xc2\x7a\x07\x39\xbf\x94\x5b\x92\xe7\x28\x7e\x83\xdb\x07\xb8\x7f\x58\xc1\xc7\xdb\xbb\x55\x14\x04\x41\xdb\x02\xcd\x20\xba\xe1\xf5\x4e\xd0\xbc\x50\x70\xd9\x75\x71\x0c\x6d\x0b\x09\xaf\x2a\x64\xea\x40\xd6\xb6\x80\x2c\x85\xae\x0b\x82\xa0\x26\xc9\x33\xc9\x51\x2b\x47\xf7\xa4\x42\xf3\x35\x8e\x61\x55\x50\x09\x19\x2d\x11\xb6\x44\x8e\x23\x51\x05\x82\x0b\x05\x14\xe7\x65\xa4\xf5\x3f\xa6\x54\x51\x96\x83\xf2\x76\x95\x59\xae\x16\x7c\x83\x90\x35\xca\xb8\x2a\x90\xc1\x8e\x37\x20\xf0\x52\x34\x6c\xe4\xa9\x5f\xc2\xc4\x4c\x58\x1a\x04\xb4\xaa\xb9\x50\x30\x0d\x00\x26\x59\xa5\x26\xfa\x97\x72\xf3\xc3\x50\xc5\x85\x52\xf5\x24\xd0\x6f\x39\x55\x45\xb3\x8e\x12\x5e\xc5\x39\xbf\xe4\x35\x32\x52\xd3\x18\x85\xe0\x42\x4e\xce\x2b\x88\x86\x29\x5a\xe1\x0b\x1a\x52\x89\x7e\xe1\x33\x0a\x5b\x92\xbf\x20\xde\x90\x92\xa6\x44\xa1\x09\x53\x57\xc9\x64\x24\x21\xba\xc5\x8c\x34\xa5\xba\x73\xef\x5d\x77\x20\x1f\x08\x66\xa6\x1c\xf7\xb8\x85\x44\x20\x51\x28\x81\x00\xc3\xad\x56\x2f\x9a\x8a\x30\xfa\x1d\x7d\xe5\xe0\xfa\xf1\x0e\x92\x92\x22\x53\x51\x90\x35\x2c\xd1\x76\x53\x25\x08\x93\x06\x4a\x97\x71\x74\x63\x54\x56\xfd\xf7\x10\x32\x2e\x2a\xa2\x24\xd8\x84\xa3\x27\xcc\xa9\x54\x62\x37\x03\xab\xb9\x44\xb1\xa1\x09\x42\x1b\x00\x08\x54\x8d\x60\xf0\xc1\x4a\x5a\xef\x7c\x01\xea\xc8\xdf\xa2\x7f\xe8\x02\xdd\x55\xf3\xc0\x1a\x81\x6b\xd8\x65\x53\x55\x44\xec\xc0\x74\xe4\xf8\x4d\x8b\x6f\x51\x26\x82\xd6\x8a\x72\x66\xba\xb2\x6d\x61\x5d\xf2\xe4\xd9\x37\xf5\x58\xc1\x77\xb5\x7e\x28\x25\x1e\xfa\x30\x82\xd7\x1c\x68\xbb\xae\xcb\xb8\x38\x8b\xef\x9e\x3c\xf3\x38\x50\xbb\x1a\x1d\x46\x1a\xbb\x26\x51\x06\xa3\x57\x11\x0f\xe0\x1c\xe4\x81\xa5\xdf\x18\x77\x2a\x0d\x55\x28\x53\x28\x32\x92\xa0\x36\xee\x97\xad\x50\x15\x3c\x95\xc3\x50\xbc\x99\xd7\x6f\x83\x77\x6d\x0b\x82\xb0\x1c\x21\x7a\xa8\x35\xd1\x28\x67\xa6\xbf\xb4\xa0\x26\x32\x21\xe5\x30\xd3\x69\x4d\x04\xa9\x24\xcc\x4f\x4a\x1f\x8d\xd0\x95\xe9\xba\x51\x05\x17\xf4\x3b\x6a\x50\x42\x20\x8d\x2a\xee\x58\xc6\x0f\x52\xbf\x76\x9f\xbf\x08\xaa\x50\xb4\x2d\xb2\xd4\x17\xfa\x13\x91\x4b\x25\x90\x54\x94\xe5\x4f\x28\x6b\xce\x4c\x15\x42\xd8\x1a\x65\xa0\x3c\xea\xcd\x1c\xf6\xb3\x7d\x0b\x25\x09\x4a\x39\xb0\x9a\xee\x13\x3d\x10\xea\x74\x4f\xe7\x13\xc2\xa8\x79\xcc\x83\x19\x1f\x67\x57\x99\xed\xdb\xe0\xdd\x60\x9c\xbe\x5b\xe2\xbe\xc8\xaf\x13\x6f\x16\xd8\xb6\x3e\x59\x98\x78\x6e\x87\xc2\x71\xb8\x27\xf9\x53\x97\x8d\x30\x6a\xbf\x53\x21\xd5\x17\x2e\x52\x98\xee\x1b\xd8\xa9\xce\xce\xb3\xcb\xac\xf5\x83\xf8\xf5\x26\x6e\x99\xf9\x35\x25\x30\xb7\xa0\xcd\x4e\x63\xf1\xb3\x51\xdf\xda\xa8\x66\x32\xe9\x9d\xfd\xe1\xf6\x61\x01\x7f\xb8\xad\xc9\x0c\x16\x87\xe1\x1a\x33\x2e\x10\x24\xb2\x94\xb2\x3c\x00\xed\xd2\x89\xae\xae\x80\xd1\xd2\xb8\x00\xff\x4d\xef\x2e\x2f\xc0\x3e\x9d\x05\x00\x6e\x67\xbb\x28\x91\xe5\xaa\x80\xc5\x15\x94\xc8\x4e\x66\xec\xb6\xc0\x93\x59\x08\x94\x4d\xa9\xda\x56\xf7\x4f\xd7\xfd\xe9\x73\x0a\x01\x85\xd0\x4e\x49\xe4\xc9\x16\x2d\x9b\x75\x45\xd5\xf4\xc3\xb8\xae\x9e\x5c\x36\x87\xbb\xdb\x85\x69\x28\x41\x99\xca\x60\xf2\xfe\xeb\x64\x0f\xb2\x51\xf8\x6c\xe6\xea\xb1\x92\xfd\xee\xd5\x1e\x89\x2a\x1e\x89\x52\x28\xd8\xb1\xae\x16\xee\x35\x05\x4f\x9b\x04\xe5\x67\x4c\x29\x59\xed\x6a\x94\x63\x83\xff\x6f\xb4\xc5\x91\x92\xb7\xbf\xe1\x4c\x36\xd5\x2b\xf6\xc7\x4a\xde\x7e\x99\x14\x58\x9d\x34\x72\x92\x41\x4e\xba\x7c\x0b\x57\x67\xfb\xed\x09\x49\x8a\x62\x01\x1f\x4e\x16\xdc\x4a\x5b\xbf\xed\x93\xc8\x3d\xbe\x8d\x38\x0b\xf7\xeb\xeb\xda\x85\xa7\x38\x6b\x02\xe9\xf9\xb9\xf0\x04\x0e\xad\x99\x93\xdf\x70\xa6\xf0\x9b\xea\xa3\x8f\xdc\xbb\xc3\xd0\xb4\x82\x97\x7d\x5a\xad\x1e\xed\x27\x2d\xee\x66\xb6\xe5\x75\x4b\xfd\x6f\xd8\xef\xee\xc8\x73\xb6\x3b\x0d\x24\xe9\xb2\x11\x82\x37\x2c\x85\x09\xa3\xe5\xc4\xfd\xfd\xc5\x77\xfe\x88\xbc\x28\x84\xe7\xc6\xe5\x19\xaf\x66\x69\x27\xc6\xaf\xde\xcf\xaf\x56\x24\xad\x7e\x08\xfc\x59\xf7\xbf\x25\x48\x34\x3d\x18\x1b\x07\x5e\xfb\x72\xb9\x44\xf9\xf3\x38\xc1\xde\x27\xa3\xa5\x8b\x2e\x8e\xa1\x61\xf8\xad\xc6\x44\x9f\xfd\x9d\x5c\x2f\x66\xdc\x19\xdb\x7d\x0a\xee\x50\x3b\x02\x26\x9e\x6b\x11\x81\xd4\xca\xbc\xa9\x3e\xd2\xe8\xab\x01\x4d\x31\x0d\xf5\x7d\xa1\xb4\x37\x07\xc2\xd2\x3e\x1a\xc2\xc0\x8c\x36\x98\xc7\x26\xe3\x7d\x20\x2e\xab\x17\xf2\x3e\x08\x65\x98\xb7\xf3\xce\x68\x19\xfa\xc9\x7f\x8f\xdb\xeb\xc7\xbb\x8f\x7a\xb5\xe9\xe4\x85\x84\x17\x90\xe8\x6e\x62\x0a\xc8\x86\xd0\x92\xac\x4b\x04\x22\x4f\x24\xe7\x42\x9f\x84\xc7\x51\x9f\xf8\x14\xe9\xdb\xde\x74\x36\x1b\xe0\xe9\x36\x4a\x5b\x02\x49\x32\xcc\x1b\x22\xd2\x05\x30\x4d\xab\xb2\xdc\x85\x40\xd6\xd2\x04\x72\xb4\xba\x5e\xe0\x99\xf1\x2d\x3b\x0a\x5f\x1e\x41\x4b\xd6\x7c\x83\x0b\x90\xdc\xa2\xaf\x0b\x00\x09\x4f\x31\x47\x06\x54\xca\x46\x97\xb8\x92\xb9\x46\x5a\x1f\x52\x97\x76\x6e\xbc\x88\x11\xb8\xc3\x73\x8f\xf9\xc2\x5e\x4a\x38\x53\x82\x24\x0a\x18\x57\x80\x2c\xe3\x22\xb1\x97\x49\x89\x62\x83\x22\xea\x4f\xb3\xde\xad\xe2\x90\xa3\xf2\x91\x86\xb0\x6e\x14\xe4\x5c\x2d\xe0\xfd\x6a\x12\xba\xba\x6b\xc4\x6a\xc2\x68\x32\xad\x64\x3e\x82\x8f\xa5\x43\x06\xf9\x63\x47\x3c\x07\x89\x1b\x14\xa4\x84\x9a\x4b\x49\x75\x01\x8f\x51\x72\x0d\x27\xb7\x54\x25\x05\x6c\x48\xd9\xe0\xb0\xd7\xf4\x49\x7b\xe6\x98\x63\xfd\xdb\x6d\xfc\x82\x86\x70\xb1\xd1\x9a\x67\xb6\xb7\x84\x48\x3c\x38\xa8\x5c\x6c\x3c\x4e\x07\xa3\x66\x34\x51\x4c\x0c\xfd\x4c\xb9\xa0\xa3\xa1\x62\xd9\x7a\x94\x79\xf7\x63\xd9\xf9\xea\xa4\xf8\x67\xe9\xfb\xe6\x91\xfb\x93\xe2\xff\x1e\xc5\x2f\xfe\x53\x1c\xef\x5f\xc7\xd8\xee\xc7\x7d\x30\xd2\xeb\x82\xc1\x8b\xbe\x71\x0f\x6f\x6e\x90\x14\x9a\xd1\xf6\xd6\xbd\xbf\xc5\x71\xfb\x1f\x2b\xfb\x0f\x96\xe3\xfb\xc9\xdf\xbc\xfb\x99\x09\x32\x38\xb7\xc2\xd5\x7e\xa9\xa0\x0b\xfe\x0a\x00\x00\xff\xff\xf0\x51\xfe\x20\x05\x14\x00\x00")
 
 func templatesClientClientGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -128,8 +128,8 @@ func templatesClientClientGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/client/client.gotmpl", size: 5197, mode: os.FileMode(0644), modTime: time.Unix(1482416923, 0)}
-	a := &asset{bytes: bytes, info: info, digest: [32]uint8{0xa0, 0x8, 0xa7, 0x4f, 0xbe, 0x2b, 0x85, 0x72, 0xc2, 0xed, 0x24, 0xe8, 0xff, 0x6a, 0xb9, 0xa4, 0x43, 0x3e, 0xee, 0x90, 0x87, 0x31, 0xad, 0x92, 0x22, 0xbf, 0xbd, 0x75, 0x69, 0x77, 0x75, 0x23}}
+	info := bindataFileInfo{name: "templates/client/client.gotmpl", size: 5125, mode: os.FileMode(0644), modTime: time.Unix(1482416923, 0)}
+	a := &asset{bytes: bytes, info: info, digest: [32]uint8{0x9, 0xac, 0x8a, 0xfb, 0x5d, 0x8, 0x2b, 0x9d, 0x80, 0xd2, 0x63, 0x29, 0xb4, 0x26, 0x94, 0xeb, 0x1a, 0x5f, 0x8, 0x86, 0x2, 0x61, 0xde, 0x72, 0xdf, 0x36, 0xfa, 0xb4, 0xdd, 0xc0, 0xef, 0xd9}}
 	return a, nil
 }
 
diff --git a/hack/regen-samples.sh b/hack/regen-samples.sh
index 0ad73889..91c67e37 100755
--- a/hack/regen-samples.sh
+++ b/hack/regen-samples.sh
@@ -76,5 +76,12 @@ cd "${examples}/stream-client" || exit 1
 rm -rf client
 swagger generate client
 
+cd "${examples}/file-server" || exit 1
+cp restapi/configure_file_upload.go .
+rm -rf client cmd restapi
+swagger generate server
+swagger generate client
+mv configure_file_upload.go restapi/
+
 cd "${examples}" || exit 1
 go test -v ./...
