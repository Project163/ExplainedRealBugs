diff --git a/fixtures/codegen/existing-model.yml b/fixtures/codegen/existing-model.yml
new file mode 100644
index 00000000..a311cdd9
--- /dev/null
+++ b/fixtures/codegen/existing-model.yml
@@ -0,0 +1,88 @@
+swagger: "2.0"
+
+info:
+  version: "1.0"
+  title: "Existing model"
+  description: |
+      Sample API, which uses existing Go type to implement Swagger definition.
+
+produces:
+  - "application/json"
+
+consumes:
+  - "application/json"
+
+paths:
+  /keys:
+    get:
+      description: "Get a JSON Web Key Set"
+      tags:
+        - "jwk"
+      operationId: "GetJWKSet"
+      responses:
+        200:
+          description: "OK"
+          examples:
+            application/json:
+              keys:
+                - kid: ""
+                  kty: ""
+          schema:
+            $ref: "#/definitions/JsonWebKeySet"
+  /key:
+    get:
+      description: "Get JSON Web Key"
+      tags:
+        - "jwk"
+      operationId: "GetJWK"
+      responses:
+        200:
+          description: "OK"
+          schema:
+            $ref: "#/definitions/JsonWebKeySet"
+definitions:
+  JsonWebKeySet:
+    title: "JSON Web Key Set"
+    type: "object"
+    properties:
+      keys:
+        type: "array"
+        items:
+          $ref: "#/definitions/JsonWebKey"
+  JsonWebKey:
+    title: "JSON Web Key"
+    type: "object"
+    properties:
+      keys:
+        type: "array"
+        items:
+          $ref: "#/definitions/JsonWebKey"
+      kty:
+        type: "string"
+      use:
+        type: "string"
+      kid:
+        type: "string"
+      alg:
+        type: "string"
+      crv:
+        type: "string"
+      x:
+        type: "string"
+      "y":
+        type: "string"
+      d:
+        type: "string"
+      "n":
+        type: "string"
+      e:
+        type: "string"
+      k:
+        type: "string"
+    required:
+      - kty
+    x-go-type:
+      import:
+        package: "github.com/user/package"
+        alias: "jwk"
+      type: "Key"
diff --git a/generator/model.go b/generator/model.go
index 47417fb9..cabe905f 100644
--- a/generator/model.go
+++ b/generator/model.go
@@ -133,6 +133,12 @@ func makeGenDefinition(name, pkg string, schema spec.Schema, specDoc *loads.Docu
 	return makeGenDefinitionHierarchy(name, pkg, "", schema, specDoc, opts)
 }
 func makeGenDefinitionHierarchy(name, pkg, container string, schema spec.Schema, specDoc *loads.Document, opts *GenOpts) (*GenDefinition, error) {
+
+	_, ok := schema.Extensions["x-go-type"]
+	if ok {
+		return nil, nil
+	}
+
 	receiver := "m"
 	resolver := newTypeResolver("", specDoc)
 	resolver.ModelName = name
@@ -263,9 +269,59 @@ func makeGenDefinitionHierarchy(name, pkg, container string, schema spec.Schema,
 		DependsOn:      pg.Dependencies,
 		DefaultImports: defaultImports,
 		ExtraSchemas:   extras,
+		Imports:        findImports(&pg.GenSchema),
 	}, nil
 }
 
+func findImports(sch *GenSchema) map[string]string {
+	imp := map[string]string{}
+	t := sch.resolvedType
+	if t.Pkg != "" && t.PkgAlias != "" {
+		imp[t.PkgAlias] = t.Pkg
+	}
+	if sch.Items != nil {
+		sub := findImports(sch.Items)
+		for k, v := range sub {
+			imp[k] = v
+		}
+	}
+	if sch.AdditionalItems != nil {
+		sub := findImports(sch.AdditionalItems)
+		for k, v := range sub {
+			imp[k] = v
+		}
+	}
+	if sch.Object != nil {
+		sub := findImports(sch.Object)
+		for k, v := range sub {
+			imp[k] = v
+		}
+	}
+	if sch.Properties != nil {
+		for _, p := range sch.Properties {
+			sub := findImports(&p)
+			for k, v := range sub {
+				imp[k] = v
+			}
+		}
+	}
+	if sch.AdditionalProperties != nil {
+		sub := findImports(sch.AdditionalProperties)
+		for k, v := range sub {
+			imp[k] = v
+		}
+	}
+	if sch.AllOf != nil {
+		for _, p := range sch.AllOf {
+			sub := findImports(&p)
+			for k, v := range sub {
+				imp[k] = v
+			}
+		}
+	}
+	return imp
+}
+
 type schemaGenContext struct {
 	Required           bool
 	AdditionalProperty bool
diff --git a/generator/model_test.go b/generator/model_test.go
index aeafa669..3df702a2 100644
--- a/generator/model_test.go
+++ b/generator/model_test.go
@@ -1785,3 +1785,23 @@ func TestGenModel_Issue752_EOFErr(t *testing.T) {
 		}
 	}
 }
+
+func TestImports_ExistingModel(t *testing.T) {
+	specDoc, err := loads.Spec("../fixtures/codegen/existing-model.yml")
+	if assert.NoError(t, err) {
+		definitions := specDoc.Spec().Definitions
+		k := "JsonWebKeySet"
+		opts := opts()
+		genModel, err := makeGenDefinition(k, "models", definitions[k], specDoc, opts)
+		if assert.NoError(t, err) &&
+			assert.NotNil(t, genModel) &&
+			assert.NotNil(t, genModel.Imports) {
+			assert.Equal(t, "github.com/user/package", genModel.Imports["jwk"])
+		}
+		k = "JsonWebKey"
+		genModel, err = makeGenDefinition(k, "models", definitions[k], specDoc, opts)
+		if assert.NoError(t, err) {
+			assert.Nil(t, genModel)
+		}
+	}
+}
diff --git a/generator/support.go b/generator/support.go
index 4e1785d8..d0d645ed 100644
--- a/generator/support.go
+++ b/generator/support.go
@@ -517,8 +517,10 @@ func (a *appGenerator) makeCodegenApp() (GenApp, error) {
 		if err != nil {
 			return GenApp{}, err
 		}
-		//mod.ReceiverName = receiver
-		genMods = append(genMods, *mod)
+		if mod != nil {
+			//mod.ReceiverName = receiver
+			genMods = append(genMods, *mod)
+		}
 	}
 
 	log.Println("planning operations")
diff --git a/generator/typeresolver_test.go b/generator/typeresolver_test.go
index 369c5ec3..50b087b1 100644
--- a/generator/typeresolver_test.go
+++ b/generator/typeresolver_test.go
@@ -558,3 +558,52 @@ func assertPrimitiveResolve(t testing.TB, tpe, tfmt, exp string, tr resolvedType
 	assert.Equal(t, tfmt, tr.SwaggerFormat, fmt.Sprintf("expected %q (%q, %q) to for the swagger format but got %q", tfmt, tpe, exp, tr.SwaggerFormat))
 	assert.Equal(t, exp, tr.GoType, fmt.Sprintf("expected %q (%q, %q) to for the go type but got %q", exp, tpe, tfmt, tr.GoType))
 }
+
+func TestTypeResolver_ExistingModel(t *testing.T) {
+	doc, err := loads.Spec("../fixtures/codegen/existing-model.yml")
+	resolver := newTypeResolver("model", doc)
+	if assert.NoError(t, err) {
+		def := doc.Spec().Definitions["JsonWebKey"]
+		tpe, pkg, alias := knownDefGoType("JsonWebKey", def, nil)
+		assert.Equal(t, "jwk.Key", tpe)
+		assert.Equal(t, "github.com/user/package", pkg)
+		assert.Equal(t, "jwk", alias)
+		rest, err := resolver.ResolveSchema(&def, false, true)
+		if assert.NoError(t, err) {
+			assert.False(t, rest.IsMap)
+			assert.False(t, rest.IsArray)
+			assert.False(t, rest.IsTuple)
+			assert.False(t, rest.IsStream)
+			assert.False(t, rest.IsAliased)
+			assert.False(t, rest.IsBaseType)
+			assert.False(t, rest.IsInterface)
+			assert.True(t, rest.IsNullable)
+			assert.False(t, rest.IsPrimitive)
+			assert.False(t, rest.IsAnonymous)
+			assert.True(t, rest.IsComplexObject)
+			assert.False(t, rest.IsCustomFormatter)
+			assert.Equal(t, "jwk.Key", rest.GoType)
+			assert.Equal(t, "github.com/user/package", rest.Pkg)
+			assert.Equal(t, "jwk", rest.PkgAlias)
+		}
+		def = doc.Spec().Definitions["JsonWebKeySet"].Properties["keys"]
+		rest, err = resolver.ResolveSchema(&def, false, true)
+		if assert.NoError(t, err) {
+			assert.False(t, rest.IsMap)
+			assert.True(t, rest.IsArray)
+			assert.False(t, rest.IsTuple)
+			assert.False(t, rest.IsStream)
+			assert.False(t, rest.IsAliased)
+			assert.False(t, rest.IsBaseType)
+			assert.False(t, rest.IsInterface)
+			assert.False(t, rest.IsNullable)
+			assert.False(t, rest.IsPrimitive)
+			assert.False(t, rest.IsAnonymous)
+			assert.False(t, rest.IsComplexObject)
+			assert.False(t, rest.IsCustomFormatter)
+			assert.Equal(t, "[]jwk.Key", rest.GoType)
+			assert.Equal(t, "", rest.Pkg)
+			assert.Equal(t, "", rest.PkgAlias)
+		}
+	}
+}
diff --git a/generator/types.go b/generator/types.go
index 4ae9f4e5..1055d4a5 100644
--- a/generator/types.go
+++ b/generator/types.go
@@ -244,14 +244,42 @@ func newTypeResolver(pkg string, doc *loads.Document) *typeResolver {
 	resolver := typeResolver{ModelsPackage: pkg, Doc: doc}
 	resolver.KnownDefs = make(map[string]struct{}, 64)
 	for k, sch := range doc.OrigSpec().Definitions {
-		resolver.KnownDefs[k] = struct{}{}
-		if nm, ok := sch.Extensions["x-go-name"]; ok {
-			resolver.KnownDefs[nm.(string)] = struct{}{}
-		}
+		tpe, _, _ := knownDefGoType(k, sch, nil)
+		resolver.KnownDefs[tpe] = struct{}{}
 	}
 	return &resolver
 }
 
+// knownDefGoType returns go type, package and package alias for definition
+func knownDefGoType(def string, schema spec.Schema, clear func(string) string) (string, string, string) {
+	ext := schema.Extensions
+	if nm, ok := ext.GetString("x-go-name"); ok {
+		if clear == nil {
+			return nm, "", ""
+		}
+		return clear(nm), "", ""
+	}
+	v, ok := ext["x-go-type"]
+	if !ok {
+		if clear == nil {
+			return def, "", ""
+		}
+		return clear(def), "", ""
+	}
+	xt := v.(map[string]interface{})
+	t := xt["type"].(string)
+	imp := xt["import"].(map[string]interface{})
+	pkg := imp["package"].(string)
+	al, ok := imp["alias"]
+	var alias string
+	if ok {
+		alias = al.(string)
+	} else {
+		alias = filepath.Base(pkg)
+	}
+	return alias + "." + t, pkg, alias
+}
+
 type typeResolver struct {
 	Doc           *loads.Document
 	ModelsPackage string
@@ -277,15 +305,6 @@ func (t *typeResolver) resolveSchemaRef(schema *spec.Schema, isRequired bool) (r
 			err = er
 			return
 		}
-		var nm = filepath.Base(schema.Ref.GetURL().Fragment)
-		var tn string
-		if gn, ok := ref.Extensions["x-go-name"]; ok {
-			tn = gn.(string)
-			nm = tn
-		} /*else {
-			tn = swag.ToGoName(nm)
-		}*/
-
 		res, er := t.ResolveSchema(ref, false, isRequired)
 		if er != nil {
 			err = er
@@ -293,7 +312,10 @@ func (t *typeResolver) resolveSchemaRef(schema *spec.Schema, isRequired bool) (r
 		}
 		result = res
 
-		result.GoType = t.goTypeName(nm)
+		tpe, pkg, alias := knownDefGoType(filepath.Base(schema.Ref.GetURL().Fragment), *ref, t.goTypeName)
+		result.GoType = tpe
+		result.Pkg = pkg
+		result.PkgAlias = alias
 		result.HasDiscriminator = ref.Discriminator != ""
 		result.IsNullable = t.IsNullable(ref)
 		//result.IsAliased = true
@@ -441,7 +463,10 @@ func (t *typeResolver) resolveObject(schema *spec.Schema, isAnonymous bool) (res
 	result.IsBaseType = schema.Discriminator != ""
 	if !isAnonymous {
 		result.SwaggerType = object
-		result.GoType = t.goTypeName(t.ModelName)
+		tpe, pkg, alias := knownDefGoType(t.ModelName, *schema, t.goTypeName)
+		result.GoType = tpe
+		result.Pkg = pkg
+		result.PkgAlias = alias
 	}
 	if len(schema.AllOf) > 0 {
 		result.GoType = t.goTypeName(t.ModelName)
@@ -663,6 +688,8 @@ type resolvedType struct {
 	IsBaseType         bool
 
 	GoType        string
+	Pkg           string
+	PkgAlias      string
 	AliasedType   string
 	SwaggerType   string
 	SwaggerFormat string
