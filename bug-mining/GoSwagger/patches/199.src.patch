diff --git a/cmd/swagger/commands/generate/client.go b/cmd/swagger/commands/generate/client.go
index 676f357f..0e5f33c0 100644
--- a/cmd/swagger/commands/generate/client.go
+++ b/cmd/swagger/commands/generate/client.go
@@ -83,7 +83,7 @@ func (c *Client) Execute(args []string) error {
 		IncludeParameters: !c.SkipOperations,
 		IncludeResponses:  !c.SkipOperations,
 		ValidateSpec:      !c.SkipValidation,
-		FlattenSpec:			 !c.SkipFlattening,
+		FlattenSpec:       !c.SkipFlattening,
 		Tags:              c.Tags,
 		IncludeSupport:    true,
 		TemplateDir:       string(c.TemplateDir),
@@ -119,7 +119,7 @@ func (c *Client) Execute(args []string) error {
 		return err
 	}
 
-	fmt.Fprintf(os.Stderr, `Generation completed!
+	fmt.Fprintf(os.Stdout, `Generation completed!
 
 For this generation to compile you need to have some packages in your GOPATH:
 
diff --git a/cmd/swagger/commands/generate/model_test.go b/cmd/swagger/commands/generate/model_test.go
index f0da25f8..4ef9b1d9 100644
--- a/cmd/swagger/commands/generate/model_test.go
+++ b/cmd/swagger/commands/generate/model_test.go
@@ -2,6 +2,7 @@ package generate_test
 
 import (
 	"io/ioutil"
+	"log"
 	"os"
 	"path/filepath"
 	"testing"
@@ -22,6 +23,8 @@ func TestGenerateModel(t *testing.T) {
 		"todolist.simpleheader.yml",
 		"todolist.simplequery.yml",
 	}
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
 
 	base := filepath.FromSlash("../../../../")
 	for _, spec := range specs {
diff --git a/cmd/swagger/commands/generate/operation.go b/cmd/swagger/commands/generate/operation.go
index 71935f95..b3898176 100644
--- a/cmd/swagger/commands/generate/operation.go
+++ b/cmd/swagger/commands/generate/operation.go
@@ -26,18 +26,18 @@ import (
 // Operation the generate operation files command
 type Operation struct {
 	shared
-	Name          []string `long:"name" short:"n" required:"true" description:"the operations to generate, repeat for multiple"`
-	Tags          []string `long:"tags" description:"the tags to include, if not specified defaults to all"`
-	Principal     string   `short:"P" long:"principal" description:"the model to use for the security principal"`
-	DefaultScheme string   `long:"default-scheme" description:"the default scheme for this API" default:"http"`
-	NoHandler     bool     `long:"skip-handler" description:"when present will not generate an operation handler"`
-	NoStruct      bool     `long:"skip-parameters" description:"when present will not generate the parameter model struct"`
-	NoResponses   bool     `long:"skip-responses" description:"when present will not generate the response model struct"`
-	NoValidator   bool     `long:"skip-validator" description:"when present will not generate a model validator"`
-	NoURLBuilder  bool     `long:"skip-url-builder" description:"when present will not generate a URL builder"`
-	DumpData      bool     `long:"dump-data" description:"when present dumps the json for the template generator instead of generating files"`
-	SkipFlattening  bool     `long:"skip-flatten" description:"skips flattening of spec prior to generation"`
-	SkipValidation  bool     `long:"skip-validation" description:"skips validation of spec prior to generation"`
+	Name           []string `long:"name" short:"n" required:"true" description:"the operations to generate, repeat for multiple"`
+	Tags           []string `long:"tags" description:"the tags to include, if not specified defaults to all"`
+	Principal      string   `short:"P" long:"principal" description:"the model to use for the security principal"`
+	DefaultScheme  string   `long:"default-scheme" description:"the default scheme for this API" default:"http"`
+	NoHandler      bool     `long:"skip-handler" description:"when present will not generate an operation handler"`
+	NoStruct       bool     `long:"skip-parameters" description:"when present will not generate the parameter model struct"`
+	NoResponses    bool     `long:"skip-responses" description:"when present will not generate the response model struct"`
+	NoValidator    bool     `long:"skip-validator" description:"when present will not generate a model validator"`
+	NoURLBuilder   bool     `long:"skip-url-builder" description:"when present will not generate a URL builder"`
+	DumpData       bool     `long:"dump-data" description:"when present dumps the json for the template generator instead of generating files"`
+	SkipFlattening bool     `long:"skip-flatten" description:"skips flattening of spec prior to generation"`
+	SkipValidation bool     `long:"skip-validation" description:"skips validation of spec prior to generation"`
 }
 
 // Execute generates a model file
@@ -69,7 +69,7 @@ func (o *Operation) Execute(args []string) error {
 		IncludeValidator:  !o.NoValidator,
 		IncludeURLBuilder: !o.NoURLBuilder,
 		Tags:              o.Tags,
-		FlattenSpec:			 !o.SkipFlattening,
+		FlattenSpec:       !o.SkipFlattening,
 		ValidateSpec:      !o.SkipValidation,
 	}
 
@@ -100,7 +100,7 @@ func (o *Operation) Execute(args []string) error {
 		return err
 	}
 
-	fmt.Fprintf(os.Stderr, `Generation completed!
+	fmt.Fprintf(os.Stdout, `Generation completed!
 
 For this generation to compile you need to have some packages in your GOPATH:
 
diff --git a/cmd/swagger/commands/generate/server.go b/cmd/swagger/commands/generate/server.go
index 21d26fbd..2cb4c264 100644
--- a/cmd/swagger/commands/generate/server.go
+++ b/cmd/swagger/commands/generate/server.go
@@ -43,7 +43,7 @@ type Server struct {
 	FlagStrategy      string   `long:"flag-strategy" description:"the strategy to provide flags for the server" default:"go-flags" choice:"go-flags" choice:"pflag"`
 	CompatibilityMode string   `long:"compatibility-mode" description:"the compatibility mode for the tls server" default:"modern" choice:"modern" choice:"intermediate"`
 	SkipValidation    bool     `long:"skip-validation" description:"skips validation of spec prior to generation"`
-	SkipFlattening  bool     `long:"skip-flatten" description:"skips flattening of spec prior to generation"`
+	SkipFlattening    bool     `long:"skip-flatten" description:"skips flattening of spec prior to generation"`
 }
 
 // Execute runs this command
@@ -55,7 +55,7 @@ func (s *Server) Execute(args []string) error {
 	setDebug(cfg)
 
 	if s.WithContext {
-		fmt.Fprintf(os.Stderr, "--with-context is deprecated because recent go versions now include the context on the request object to which you have access on the params.HTTPRequest property")
+		fmt.Fprintf(os.Stdout, "--with-context is deprecated because recent go versions now include the context on the request object to which you have access on the params.HTTPRequest property")
 	}
 
 	if s.ExistingModels != "" {
@@ -94,7 +94,7 @@ func (s *Server) Execute(args []string) error {
 		IncludeMain:       !s.ExcludeMain,
 		IncludeSupport:    !s.SkipSupport,
 		ValidateSpec:      !s.SkipValidation,
-		FlattenSpec:			 !s.SkipFlattening,
+		FlattenSpec:       !s.SkipFlattening,
 		ExcludeSpec:       s.ExcludeSpec,
 		TemplateDir:       string(s.TemplateDir),
 		WithContext:       s.WithContext,
@@ -139,7 +139,7 @@ func (s *Server) Execute(args []string) error {
 		flagsPackage = "github.com/spf13/pflag"
 	}
 
-	fmt.Fprintf(os.Stderr, `Generation completed!
+	fmt.Fprintf(os.Stdout, `Generation completed!
 
 For this generation to compile you need to have some packages in your GOPATH:
 
diff --git a/cmd/swagger/commands/generate/support.go b/cmd/swagger/commands/generate/support.go
index c46fc07a..d517ff64 100644
--- a/cmd/swagger/commands/generate/support.go
+++ b/cmd/swagger/commands/generate/support.go
@@ -67,7 +67,7 @@ func (s *Support) Execute(args []string) error {
 		return err
 	}
 
-	fmt.Fprintf(os.Stderr, `Generation completed!
+	fmt.Fprintf(os.Stdout, `Generation completed!
 
 For this generation to compile you need to have some packages in your vendor or GOPATH:
 
diff --git a/cmd/swagger/swagger.go b/cmd/swagger/swagger.go
index feb6803f..b9c5da0f 100644
--- a/cmd/swagger/swagger.go
+++ b/cmd/swagger/swagger.go
@@ -28,11 +28,31 @@ func init() {
 	loads.AddLoader(fmts.YAMLMatcher, fmts.YAMLDoc)
 }
 
+var (
+	// Debug is true when the SWAGGER_DEBUG env var is not empty
+	Debug = os.Getenv("SWAGGER_DEBUG") != ""
+)
+
 var opts struct {
 	// Version bool `long:"version" short:"v" description:"print the version of the command"`
 }
 
 func main() {
+	// TODO: reactivate 'defer catch all' once product is stable
+	// Recovering from internal panics
+	// Stack may be printed in Debug mode
+	// Need import "runtime/debug".
+	//defer func() {
+	//	r := recover()
+	//	if r != nil {
+	//		log.Printf("Fatal error:", r)
+	//		if Debug {
+	//			debug.PrintStack()
+	//		}
+	//		os.Exit(1)
+	//	}
+	//}()
+
 	parser := flags.NewParser(&opts, flags.Default)
 	parser.ShortDescription = "helps you keep your API well described"
 	parser.LongDescription = `
diff --git a/generator/client.go b/generator/client.go
index 68e1e757..320a1a82 100644
--- a/generator/client.go
+++ b/generator/client.go
@@ -52,7 +52,7 @@ func GenerateClient(name string, modelNames, operationIDs []string, opts *GenOpt
 	}
 
 	// Validate and Expand. specDoc is in/out param.
-	specDoc,err = validateAndFlattenSpec(opts, specDoc)
+	specDoc, err = validateAndFlattenSpec(opts, specDoc)
 	if err != nil {
 		return err
 	}
diff --git a/generator/model.go b/generator/model.go
index 26f536b6..5c6da384 100644
--- a/generator/model.go
+++ b/generator/model.go
@@ -74,7 +74,7 @@ func GenerateDefinition(modelNames []string, opts *GenOpts) error {
 		// lookup schema
 		model, ok := specDoc.Spec().Definitions[modelName]
 		if !ok {
-			return fmt.Errorf("model %q not found in definitions in %s", modelName, specPath)
+			return fmt.Errorf("model %q not found in definitions given by %q", modelName, specPath)
 		}
 
 		// generate files
@@ -106,7 +106,7 @@ func (m *definitionGenerator) Generate() error {
 
 	mod, err := makeGenDefinition(m.Name, m.Target, m.Model, m.SpecDoc, m.opts)
 	if err != nil {
-		return err
+		return fmt.Errorf("could not generate definitions for model %s on target %s: %v", m.Name, m.Target, err)
 	}
 
 	if m.opts.DumpData {
@@ -116,8 +116,9 @@ func (m *definitionGenerator) Generate() error {
 	}
 
 	if m.opts.IncludeModel {
+		log.Println("including additional model")
 		if err := m.generateModel(mod); err != nil {
-			return fmt.Errorf("model: %s", err)
+			return fmt.Errorf("could not generate model: %v", err)
 		}
 	}
 	log.Println("generated model", m.Name)
@@ -126,6 +127,9 @@ func (m *definitionGenerator) Generate() error {
 }
 
 func (m *definitionGenerator) generateModel(g *GenDefinition) error {
+	if Debug {
+		log.Printf("rendering definitions for %+v", *g)
+	}
 	return m.opts.renderDefinition(g)
 }
 
@@ -164,7 +168,7 @@ func makeGenDefinitionHierarchy(name, pkg, container string, schema spec.Schema,
 		IncludeModel:     opts.IncludeModel,
 	}
 	if err := pg.makeGenSchema(); err != nil {
-		return nil, err
+		return nil, fmt.Errorf("could not generate schema for %s: %v", name, err)
 	}
 	dsi, ok := di.Discriminators["#/definitions/"+name]
 	if ok {
diff --git a/generator/model_test.go b/generator/model_test.go
index a3853af2..0fbd4508 100644
--- a/generator/model_test.go
+++ b/generator/model_test.go
@@ -17,6 +17,9 @@ package generator
 import (
 	"bytes"
 	"fmt"
+	"io/ioutil"
+	"log"
+	"os"
 	"regexp"
 	"strconv"
 	"strings"
@@ -2032,3 +2035,98 @@ func TestGenModel_Issue774(t *testing.T) {
 		}
 	}
 }
+
+// Non-regression when Debug mode activated
+// Run everything again in Debug mode, just to make
+// sure no side effect has been added while debugging
+// TODO: remove it when no more "if Debug {}" branches are
+// present in source code.
+func TestDebugModelEntries(t *testing.T) {
+	Debug = true
+	log.SetOutput(ioutil.Discard)
+	// Verification only: temporarily mute stderr for possible debug logs to stderr
+	//origStdout := os.Stdout
+	//origStderr := os.Stderr
+	//f, err := os.OpenFile("stderr.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0666)
+	//if err != nil {
+	//	panic("Test interrupted: cannot redirect stderr to log file")
+	//}
+	//os.Stdout = ioutil.Discard
+	//os.Stderr = f
+
+	defer func() {
+		log.SetOutput(os.Stdout)
+		//os.Stderr = origStderr
+		Debug = false
+	}()
+
+	TestGenerateModel_Sanity(t)
+	TestGenerateModel_DocString(t)
+	TestGenerateModel_PropertyValidation(t)
+	TestGenerateModel_SchemaField(t)
+	TestGenSchemaType(t)
+	TestGenerateModel_Primitives(t)
+	TestGenerateModel_Nota(t)
+	TestGenerateModel_NotaWithRef(t)
+	TestGenerateModel_NotaWithMeta(t)
+	TestGenerateModel_RunParameters(t)
+	TestGenerateModel_NotaWithName(t)
+	TestGenerateModel_NotaWithRefRegistry(t)
+	TestGenerateModel_WithCustomTag(t)
+	TestGenerateModel_NotaWithMetaRegistry(t)
+	TestGenerateModel_WithMap(t)
+	TestGenerateModel_WithMapInterface(t)
+	TestGenerateModel_WithMapRef(t)
+	TestGenerateModel_WithMapComplex(t)
+	TestGenerateModel_WithMapRegistry(t)
+	TestGenerateModel_WithMapRegistryRef(t)
+	TestGenerateModel_WithMapComplexRegistry(t)
+	TestGenerateModel_WithAdditional(t)
+	TestGenerateModel_JustRef(t)
+	TestGenerateModel_WithRef(t)
+	TestGenerateModel_WithNullableRef(t)
+	TestGenerateModel_Scores(t)
+	TestGenerateModel_JaggedScores(t)
+	TestGenerateModel_Notables(t)
+	TestGenerateModel_Notablix(t)
+	TestGenerateModel_Stats(t)
+	TestGenerateModel_Statix(t)
+	TestGenerateModel_WithItems(t)
+	TestGenerateModel_WithComplexItems(t)
+	TestGenerateModel_WithItemsAndAdditional(t)
+	TestGenerateModel_WithItemsAndAdditional2(t)
+	TestGenerateModel_WithComplexAdditional(t)
+	TestGenerateModel_SimpleTuple(t)
+	TestGenerateModel_TupleWithExtra(t)
+	TestGenerateModel_TupleWithComplex(t)
+	TestGenerateModel_WithTuple(t)
+	TestGenerateModel_WithTupleWithExtra(t)
+	TestGenerateModel_WithAllOfAndDiscriminator(t)
+	TestGenerateModel_WithAllOfAndDiscriminatorAndArrayOfPolymorphs(t)
+	TestGenerateModel_WithAllOf(t)
+	TestNumericKeys(t)
+	TestGenModel_Issue196(t)
+	TestGenModel_Issue222(t)
+	TestGenModel_Issue243(t)
+	TestGenModel_Issue252(t)
+	TestGenModel_Issue251(t)
+	TestGenModel_Issue257(t)
+	TestGenModel_Issue340(t)
+	TestGenModel_Issue381(t)
+	TestGenModel_Issue300(t)
+	TestGenModel_Issue398(t)
+	TestGenModel_Issue454(t)
+	TestGenModel_Issue423(t)
+	TestGenModel_Issue453(t)
+	TestGenModel_Issue455(t)
+	TestGenModel_Issue763(t)
+	TestGenModel_Issue811_NullType(t)
+	TestGenModel_Issue811_Emojis(t)
+	TestGenModel_Issue752_EOFErr(t)
+	TestImports_ExistingModel(t)
+	TestGenModel_Issue786(t)
+	TestGenModel_Issue822(t)
+	TestGenModel_Issue981(t)
+	TestGenModel_Issue774(t)
+	Debug = false
+}
diff --git a/generator/operation.go b/generator/operation.go
index 2c764b60..7b286335 100644
--- a/generator/operation.go
+++ b/generator/operation.go
@@ -29,7 +29,6 @@ import (
 	"github.com/go-openapi/runtime"
 	"github.com/go-openapi/spec"
 	"github.com/go-openapi/swag"
-
 )
 
 type respSort struct {
@@ -74,7 +73,7 @@ func GenerateServerOperation(operationNames []string, opts *GenOpts) error {
 	}
 
 	// Validate and Expand. specDoc is in/out param.
-	specDoc,err = validateAndFlattenSpec(opts, specDoc)
+	specDoc, err = validateAndFlattenSpec(opts, specDoc)
 	if err != nil {
 		return err
 	}
@@ -304,7 +303,7 @@ func (b *codeGenOpBuilder) MakeOperation() (GenOperation, error) {
 	}
 	// @eleanorrigby : letting the comment be. Commented in response to issue#890
 	// Post-flattening of spec we no longer need to reset defs for spec or use original spec in any case.
-	resolver := newTypeResolver(b.ModelsPackage, b.Doc/*.ResetDefinitions()*/)
+	resolver := newTypeResolver(b.ModelsPackage, b.Doc /*.ResetDefinitions()*/)
 	receiver := "o"
 
 	operation := b.Operation
diff --git a/generator/operation_test.go b/generator/operation_test.go
index 1f70936b..54d4ac50 100644
--- a/generator/operation_test.go
+++ b/generator/operation_test.go
@@ -366,7 +366,7 @@ func TestDateFormat_Spec2(t *testing.T) {
 
 func TestBuilder_Issue287(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	dr, _ := os.Getwd()
 
 	opts := &GenOpts{
@@ -406,7 +406,7 @@ func TestBuilder_Issue287(t *testing.T) {
 
 func TestBuilder_Issue465(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	dr, _ := os.Getwd()
 	opts := &GenOpts{
 		Spec:              filepath.FromSlash("../fixtures/bugs/465/swagger.yml"),
@@ -445,7 +445,7 @@ func TestBuilder_Issue465(t *testing.T) {
 
 func TestBuilder_Issue500(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	dr, _ := os.Getwd()
 	opts := &GenOpts{
 		Spec:              filepath.FromSlash("../fixtures/bugs/500/swagger.yml"),
@@ -537,7 +537,7 @@ func TestGenClient_Issue733(t *testing.T) {
 
 func TestGenServerIssue890_ValidationTrueFlatteningTrue(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	dr, _ := os.Getwd()
 	opts := &GenOpts{
 		Spec:              filepath.FromSlash("../fixtures/bugs/890/swagger.yaml"),
@@ -547,8 +547,8 @@ func TestGenServerIssue890_ValidationTrueFlatteningTrue(t *testing.T) {
 		IncludeParameters: true,
 		IncludeResponses:  true,
 		IncludeMain:       true,
-		ValidateSpec:			 true,
-		FlattenSpec:			 true,
+		ValidateSpec:      true,
+		FlattenSpec:       true,
 		APIPackage:        "restapi",
 		ModelPackage:      "model",
 		ServerPackage:     "server",
@@ -581,7 +581,7 @@ func TestGenServerIssue890_ValidationTrueFlatteningTrue(t *testing.T) {
 func TestGenClientIssue890_ValidationTrueFlatteningTrue(t *testing.T) {
 	defer func() {
 		dr, _ := os.Getwd()
-		os.RemoveAll(dr+"/restapi/")
+		os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
 	}()
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/890/swagger.yaml"
@@ -594,7 +594,7 @@ func TestGenClientIssue890_ValidationTrueFlatteningTrue(t *testing.T) {
 
 func TestGenServerIssue890_ValidationFalseFlattenTrue(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	dr, _ := os.Getwd()
 	opts := &GenOpts{
 		Spec:              filepath.FromSlash("../fixtures/bugs/890/swagger.yaml"),
@@ -604,8 +604,8 @@ func TestGenServerIssue890_ValidationFalseFlattenTrue(t *testing.T) {
 		IncludeParameters: true,
 		IncludeResponses:  true,
 		IncludeMain:       true,
-		ValidateSpec:			 false,
-		FlattenSpec:			 true,
+		ValidateSpec:      false,
+		FlattenSpec:       true,
 		APIPackage:        "restapi",
 		ModelPackage:      "model",
 		ServerPackage:     "server",
@@ -638,7 +638,7 @@ func TestGenServerIssue890_ValidationFalseFlattenTrue(t *testing.T) {
 func TestGenClientIssue890_ValidationFalseFlatteningTrue(t *testing.T) {
 	defer func() {
 		dr, _ := os.Getwd()
-		os.RemoveAll(dr+"/restapi/")
+		os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
 	}()
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/890/swagger.yaml"
@@ -651,7 +651,7 @@ func TestGenClientIssue890_ValidationFalseFlatteningTrue(t *testing.T) {
 
 func TestGenServerIssue890_ValidationFalseFlattenFalse(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	dr, _ := os.Getwd()
 	opts := &GenOpts{
 		Spec:              filepath.FromSlash("../fixtures/bugs/890/swagger.yaml"),
@@ -661,7 +661,7 @@ func TestGenServerIssue890_ValidationFalseFlattenFalse(t *testing.T) {
 		IncludeParameters: true,
 		IncludeResponses:  true,
 		IncludeMain:       true,
-		ValidateSpec:			 false,
+		ValidateSpec:      false,
 		FlattenSpec:       false,
 		APIPackage:        "restapi",
 		ModelPackage:      "model",
@@ -680,7 +680,7 @@ func TestGenServerIssue890_ValidationFalseFlattenFalse(t *testing.T) {
 func TestGenClientIssue890_ValidationFalseFlattenFalse(t *testing.T) {
 	defer func() {
 		dr, _ := os.Getwd()
-		os.RemoveAll(dr+"/restapi/")
+		os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
 	}()
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/890/swagger.yaml"
@@ -693,7 +693,7 @@ func TestGenClientIssue890_ValidationFalseFlattenFalse(t *testing.T) {
 
 func TestGenServerIssue890_ValidationTrueFlattenFalse(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	dr, _ := os.Getwd()
 	opts := &GenOpts{
 		Spec:              filepath.FromSlash("../fixtures/bugs/890/swagger.yaml"),
@@ -703,7 +703,7 @@ func TestGenServerIssue890_ValidationTrueFlattenFalse(t *testing.T) {
 		IncludeParameters: true,
 		IncludeResponses:  true,
 		IncludeMain:       true,
-		ValidateSpec:			 true,
+		ValidateSpec:      true,
 		FlattenSpec:       false,
 		APIPackage:        "restapi",
 		ModelPackage:      "model",
@@ -722,7 +722,7 @@ func TestGenServerIssue890_ValidationTrueFlattenFalse(t *testing.T) {
 func TestGenClientIssue890_ValidationTrueFlattenFalse(t *testing.T) {
 	defer func() {
 		dr, _ := os.Getwd()
-		os.RemoveAll(dr+"/restapi/")
+		os.RemoveAll(filepath.Join(filepath.FromSlash(dr), "restapi"))
 	}()
 	opts := testGenOpts()
 	opts.Spec = "../fixtures/bugs/890/swagger.yaml"
diff --git a/generator/server_test.go b/generator/server_test.go
index 74bad7dc..cd15af79 100644
--- a/generator/server_test.go
+++ b/generator/server_test.go
@@ -84,7 +84,7 @@ func testAppGenerator(t testing.TB, specPath, name string) (*appGenerator, error
 
 func TestServer_UrlEncoded(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	gen, err := testAppGenerator(t, "../fixtures/codegen/simplesearch.yml", "search")
 	if assert.NoError(t, err) {
 		app, err := gen.makeCodegenApp()
@@ -115,7 +115,7 @@ func TestServer_UrlEncoded(t *testing.T) {
 
 func TestServer_MultipartForm(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	gen, err := testAppGenerator(t, "../fixtures/codegen/shipyard.yml", "shipyard")
 	if assert.NoError(t, err) {
 		app, err := gen.makeCodegenApp()
@@ -153,7 +153,7 @@ func TestServer_InvalidSpec(t *testing.T) {
 
 func TestServer_TrailingSlash(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	gen, err := testAppGenerator(t, "../fixtures/bugs/899/swagger.yml", "trailing slash")
 	if assert.NoError(t, err) {
 		app, err := gen.makeCodegenApp()
@@ -174,7 +174,7 @@ func TestServer_TrailingSlash(t *testing.T) {
 
 func TestServer_Issue987(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	gen, err := testAppGenerator(t, "../fixtures/bugs/987/swagger.yml", "deeper consumes produces")
 	if assert.NoError(t, err) {
 		app, err := gen.makeCodegenApp()
@@ -198,7 +198,7 @@ func TestServer_Issue987(t *testing.T) {
 
 func TestServer_FilterByTag(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
-	defer log.SetOutput(os.Stderr)
+	defer log.SetOutput(os.Stdout)
 	gen, err := testAppGenerator(t, "../fixtures/codegen/simplesearch.yml", "search")
 	if assert.NoError(t, err) {
 		gen.GenOpts.Tags = []string{"search"}
@@ -218,3 +218,60 @@ func TestServer_FilterByTag(t *testing.T) {
 		}
 	}
 }
+
+// Checking error handling code: panic on mismatched template
+// High level test with AppGenerator
+func badTemplateCall() {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	gen, err := testAppGenerator(nil, "../fixtures/bugs/899/swagger.yml", "trailing slash")
+	if err != nil {
+		return
+	}
+	app, err := gen.makeCodegenApp()
+	log.SetOutput(ioutil.Discard)
+	if err != nil {
+		return
+	}
+	buf := bytes.NewBuffer(nil)
+	r := templates.MustGet("serverBuilderX").Execute(buf, app)
+
+	// Should never reach here
+	log.Printf("%+v\n", r)
+}
+
+func TestServer_BadTemplate(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	assert.Panics(t, badTemplateCall, "templates.MustGet() did not panic() as currently expected")
+}
+
+// Checking error handling code: panic on bad parsing template
+// High level test with AppGenerator
+func badParseCall() {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	var badParse = `{{{ define "T1" }}T1{{end}}{{ define "T2" }}T2{{end}}`
+
+	templates.AddFile("badparse", badParse)
+	gen, _ := testAppGenerator(nil, "../fixtures/bugs/899/swagger.yml", "trailing slash")
+	app, _ := gen.makeCodegenApp()
+	log.SetOutput(ioutil.Discard)
+	tpl := templates.MustGet("badparse")
+
+	// Should never reach here
+	buf := bytes.NewBuffer(nil)
+	r := tpl.Execute(buf, app)
+
+	log.Printf("%+v\n", r)
+}
+
+func TestServer_ErrorParsingTemplate(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	assert.Panics(t, badParseCall, "templates.MustGet() did not panic() as currently expected")
+}
diff --git a/generator/shared.go b/generator/shared.go
index 171e7a2c..febe52b8 100644
--- a/generator/shared.go
+++ b/generator/shared.go
@@ -108,9 +108,9 @@ func GoLangOpts() *LanguageOpts {
 	return opts
 }
 
-// Debug when the env var DEBUG is not empty
+// Debug when the env var DEBUG or SWAGGER_DEBUG is not empty
 // the generators will be very noisy about what they are doing
-var Debug = os.Getenv("DEBUG") != ""
+var Debug = os.Getenv("DEBUG") != "" || os.Getenv("SWAGGER_DEBUG") != ""
 
 func findSwaggerSpec(nm string) (string, error) {
 	specs := []string{"swagger.json", "swagger.yml", "swagger.yaml"}
@@ -311,7 +311,7 @@ type GenOpts struct {
 	DumpData          bool
 	WithContext       bool
 	ValidateSpec      bool
-	FlattenSpec				bool
+	FlattenSpec       bool
 	defaultsEnsured   bool
 
 	Spec              string
@@ -339,40 +339,57 @@ type GenOpts struct {
 	Copyright         string
 }
 
-// TargetPath returns the target path relative to the server package
+// TargetPath returns the target generation path relative to the server package
+// Method used by templates, e.g. with {{ .TargetPath }}
+// Errors are not fatal: an empty string is returned instead
 func (g *GenOpts) TargetPath() string {
 	tgtAbs, err := filepath.Abs(g.Target)
 	if err != nil {
-		log.Fatalln(err)
+		log.Printf("could not evaluate target generation path \"%s\": you must create the target directory beforehand: %v", g.Target, err)
+		return ""
 	}
+	tgtAbs = filepath.ToSlash(tgtAbs)
 	srvrAbs, err := filepath.Abs(g.ServerPackage)
 	if err != nil {
-		log.Fatalln(err)
+		log.Printf("could not evaluate target server path \"%s\": %v", g.ServerPackage, err)
+		return ""
 	}
+	srvrAbs = filepath.ToSlash(srvrAbs)
 	tgtRel, err := filepath.Rel(srvrAbs, tgtAbs)
 	if err != nil {
-		log.Fatalln(err)
+		log.Printf("Target path \"%s\" and server path \"%s\" are not related. You shouldn't specify an absolute path in --server-package: %v", g.Target, g.ServerPackage, err)
+		return ""
 	}
+	tgtRel = filepath.ToSlash(tgtRel)
 	return tgtRel
 }
 
 // SpecPath returns the path to the spec relative to the server package
+// Method used by templates, e.g. with {{ .SpecPath }}
+// Errors are not fatal: an empty string is returned instead
 func (g *GenOpts) SpecPath() string {
 	if strings.HasPrefix(g.Spec, "http://") || strings.HasPrefix(g.Spec, "https://") {
 		return g.Spec
 	}
+	// Local specifications
 	specAbs, err := filepath.Abs(g.Spec)
 	if err != nil {
-		log.Fatalln(err)
+		log.Printf("could not evaluate target generation path \"%s\": you must create the target directory beforehand: %v", g.Spec, err)
+		return ""
 	}
+	specAbs = filepath.ToSlash(specAbs)
 	srvrAbs, err := filepath.Abs(g.ServerPackage)
 	if err != nil {
-		log.Fatalln(err)
+		log.Printf("could not evaluate target server path \"%s\": %v", g.ServerPackage, err)
+		return ""
 	}
+	srvrAbs = filepath.ToSlash(srvrAbs)
 	specRel, err := filepath.Rel(srvrAbs, specAbs)
 	if err != nil {
-		log.Fatalln(err)
+		log.Printf("Specification path \"%s\" and server path \"%s\" are not related. You shouldn't specify an absolute path in --server-package: %v", g.Spec, g.ServerPackage, err)
+		return ""
 	}
+	specRel = filepath.ToSlash(specRel)
 	return specRel
 }
 
@@ -459,14 +476,21 @@ func (g *GenOpts) render(t *TemplateOpts, data interface{}) ([]byte, error) {
 	}
 
 	if templ == nil {
-		// try to load template from disk
-		content, err := ioutil.ReadFile(t.Source)
+		// try to load template from disk, in TemplateDir if specified
+		var templateFile string
+		if g.TemplateDir != "" {
+			templateFile = filepath.Join(g.TemplateDir, t.Source)
+		} else {
+			templateFile = t.Source
+		}
+		content, err := ioutil.ReadFile(templateFile)
 		if err != nil {
-			return nil, err
+			return nil, fmt.Errorf("error while opening %s template file: %v", templateFile, err)
 		}
 		tt, err := template.New(t.Source).Funcs(FuncMap).Parse(string(content))
 		if err != nil {
-			return nil, err
+			return nil, fmt.Errorf("template parsing failed on template %s: %v", t.Name, err)
+			//return nil, err
 		}
 		templ = tt
 	}
@@ -476,50 +500,72 @@ func (g *GenOpts) render(t *TemplateOpts, data interface{}) ([]byte, error) {
 
 	var tBuf bytes.Buffer
 	if err := templ.Execute(&tBuf, data); err != nil {
-		return nil, err
+		return nil, fmt.Errorf("template execution failed for template %s: %v", t.Name, err)
 	}
+	//if Debug {
+	log.Printf("executed template %s", t.Source)
+	//}
 
 	return tBuf.Bytes(), nil
 }
 
+// Render template and write generated source code
+// generated code is reformatted ("linted"), which gives an
+// additional level of checking. If this step fails, the generated
+// is still dumped, for template debugging purposes.
 func (g *GenOpts) write(t *TemplateOpts, data interface{}) error {
 	dir, fname, err := g.location(t, data)
 	if err != nil {
-		return err
+		return fmt.Errorf("failed to resolve template location for template %s: %v", t.Name, err)
 	}
 
 	if t.SkipExists && fileExists(dir, fname) {
-		log.Printf("skipping %s because it already exists", filepath.Join(dir, fname))
+		if Debug {
+			log.Printf("skipping generation of %s because it already exists and skip_exist directive is set for %s", filepath.Join(dir, fname), t.Name)
+		}
 		return nil
 	}
 
-	log.Printf("creating %q in %q as %s", fname, dir, t.Name)
+	log.Printf("creating generated file %q in %q as %s", fname, dir, t.Name)
 	content, err := g.render(t, data)
 	if err != nil {
-		return err
+		return fmt.Errorf("failed rendering template data for %s: %v", t.Name, err)
 	}
 
 	if dir != "" {
-		if Debug {
-			log.Printf("skipping creating directory %q for %s because it's an empty string", dir, t.Name)
-		}
-		if e := os.MkdirAll(dir, 0700); e != nil {
-			return e
+		_, exists := os.Stat(dir)
+		if os.IsNotExist(exists) {
+			if Debug {
+				log.Printf("creating directory %q for \"%s\"", dir, t.Name)
+			}
+			// Directory settings consistent with file privileges.
+			// Environment's umask may alter this setup
+			if e := os.MkdirAll(dir, 0755); e != nil {
+				return e
+			}
 		}
 	}
 
 	// Conditionally format the code, unless the user wants to skip
 	formatted := content
+	var writeerr error
+
 	if !t.SkipFormat {
 		formatted, err = g.LanguageOpts.FormatContent(fname, content)
 		if err != nil {
-			err = fmt.Errorf("format %q failed: %v", t.Name, err)
+			log.Printf("source formatting failed on template-generated source (%q for %s). Check that your template produces valid code", filepath.Join(dir, fname), t.Name)
+			writeerr = ioutil.WriteFile(filepath.Join(dir, fname), content, 0644)
+			if writeerr != nil {
+				return fmt.Errorf("failed to write (unformatted) file %q in %q: %v", fname, dir, writeerr)
+			}
+			log.Printf("unformatted generated source %q has been dumped for template debugging purposes. DO NOT build on this source!", fname)
+			return fmt.Errorf("source formatting on generated source %q failed: %v", t.Name, err)
 		}
 	}
 
-	writeerr := ioutil.WriteFile(filepath.Join(dir, fname), formatted, 0644)
+	writeerr = ioutil.WriteFile(filepath.Join(dir, fname), formatted, 0644)
 	if writeerr != nil {
-		log.Printf("Failed to write %q: %s", fname, writeerr)
+		return fmt.Errorf("failed to write file %q in %q: %v", fname, dir, writeerr)
 	}
 	return err
 }
@@ -779,7 +825,7 @@ func validateAndFlattenSpec(opts *GenOpts, specDoc *loads.Document) (*loads.Docu
 	// Validate if needed
 	if opts.ValidateSpec {
 		if err := validateSpec(opts.Spec, specDoc); err != nil {
-			return specDoc,err
+			return specDoc, err
 		}
 	}
 
@@ -798,6 +844,5 @@ func validateAndFlattenSpec(opts *GenOpts, specDoc *loads.Document) (*loads.Docu
 		err = analysis.Flatten(flattenOpts)
 	}
 
-	return specDoc,nil
+	return specDoc, nil
 }
-
diff --git a/generator/shared_test.go b/generator/shared_test.go
index cc1b290c..26b50618 100644
--- a/generator/shared_test.go
+++ b/generator/shared_test.go
@@ -1 +1,409 @@
 package generator
+
+import (
+	"fmt"
+	"io/ioutil"
+	"log"
+	"os"
+	"path/filepath"
+	"testing"
+
+	"github.com/stretchr/testify/assert"
+)
+
+// TargetPath and SpecPath are used in server.gotmpl
+// as template variables: {{ .TestTargetPath }} and
+// {{ .SpecPath }}, to construct the go generate
+// directive.
+// TODO: there is a catch, since these methods are sensitive
+// to the CWD of the current swagger command (or go
+// generate when working on resulting template)
+// NOTE:
+// Errors in TargetPath are hard to simulate since
+// they occur only on os.Getwd() errors
+// Windows style path is difficult to test on unix
+// since the filepath pkg is platform dependant
+func TestShared_TargetPath(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	cwd, _ := os.Getwd()
+
+	// relative target
+	var opts = new(GenOpts)
+	opts.Target = "./a/b/c"
+	opts.ServerPackage = "y"
+	expected := "../a/b/c"
+	result := opts.TargetPath()
+	assert.Equal(t, expected, result)
+
+	// relative target, server path
+	opts = new(GenOpts)
+	opts.Target = "./a/b/c"
+	opts.ServerPackage = "y/z"
+	expected = "../../a/b/c"
+	result = opts.TargetPath()
+	assert.Equal(t, expected, result)
+
+	// absolute target
+	opts = new(GenOpts)
+	opts.Target = filepath.Join(cwd, "a/b/c")
+	opts.ServerPackage = "y"
+	expected = "../a/b/c"
+	result = opts.TargetPath()
+	assert.Equal(t, expected, result)
+
+	// absolute target, server path
+	opts = new(GenOpts)
+	opts.Target = "./a/b/c"
+	opts.ServerPackage = "y/z"
+	expected = "../../a/b/c"
+	result = opts.TargetPath()
+	assert.Equal(t, expected, result)
+
+	// absolute server package
+	opts = new(GenOpts)
+	opts.Target = "/a/b/c"
+	opts.ServerPackage = "/y/z"
+	expected = "../../a/b/c"
+	result = opts.TargetPath()
+	assert.Equal(t, expected, result)
+
+	// TODO:
+	// unrelated path (Windows specific)
+	// TargetPath() is expected to fail
+	// when target and server reside on
+	// different volumes.
+	//if runtime.GOOS == "windows" {
+	//	log.Println("INFO:Need some additional testing on windows")
+	//opts = new(GenOpts)
+	//opts.Target = "C:/a/b/c"
+	//opts.ServerPackage = "D:/y/z"
+	//expected = ""
+	//result = opts.TargetPath()
+	//assert.Equal(t, expected, result)
+	//}
+}
+
+// NOTE: file://url is not supported
+func TestShared_SpecPath(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	cwd, _ := os.Getwd()
+
+	// http URL spec
+	var opts = new(GenOpts)
+	opts.Spec = "http://a/b/c"
+	opts.ServerPackage = "y"
+	expected := opts.Spec
+	result := opts.SpecPath()
+	assert.Equal(t, expected, result)
+
+	// https URL spec
+	opts = new(GenOpts)
+	opts.Spec = "https://a/b/c"
+	opts.ServerPackage = "y"
+	expected = opts.Spec
+	result = opts.SpecPath()
+	assert.Equal(t, expected, result)
+
+	// relative spec
+	opts = new(GenOpts)
+	opts.Spec = "./a/b/c"
+	opts.ServerPackage = "y"
+	expected = "../a/b/c"
+	result = opts.SpecPath()
+	assert.Equal(t, expected, result)
+
+	// relative spec, server path
+	opts = new(GenOpts)
+	opts.Spec = "./a/b/c"
+	opts.ServerPackage = "y/z"
+	expected = "../../a/b/c"
+	result = opts.SpecPath()
+	assert.Equal(t, expected, result)
+
+	// absolute spec
+	opts = new(GenOpts)
+	opts.Spec = filepath.Join(cwd, "a/b/c")
+	opts.ServerPackage = "y"
+	expected = "../a/b/c"
+	result = opts.SpecPath()
+	assert.Equal(t, expected, result)
+
+	// absolute spec, server path
+	opts = new(GenOpts)
+	opts.Spec = "./a/b/c"
+	opts.ServerPackage = "y/z"
+	expected = "../../a/b/c"
+	result = opts.SpecPath()
+	assert.Equal(t, expected, result)
+
+	// absolute server package
+	opts = new(GenOpts)
+	opts.Spec = "/a/b/c"
+	opts.ServerPackage = "/y/z"
+	expected = "../../a/b/c"
+	result = opts.SpecPath()
+	assert.Equal(t, expected, result)
+
+	// TODO:
+	// unrelated path (Windows specific)
+	// SpecPath() is expected to fail
+	// when spec and server reside on
+	// different volumes.
+	// This shouldn't happen with go, since everything
+	// should be under the same GOPATH
+	// NOTE: a better error handling strategy would be
+	// to check that os.Getwd() and Rel() work well upstream
+	// and assume in functions that no error is returned.
+	//if runtime.GOOS == "windows" {
+	//	log.SetOutput(os.Stdout)
+	//	log.Println("INFO:Need some additional testing on windows")
+	//opts = new(GenOpts)
+	//opts.Spec = "C:/a/b/c"
+	//opts.ServerPackage = "D:/y/z"
+	//expected = ""
+	//result = opts.SpecPath()
+	//assert.Equal(t, expected, result)
+	//}
+}
+
+// Low level testing: templates not found (higher level calls raise panic(), see above)
+func TestShared_NotFoundTemplate(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	opts := GenOpts{}
+	tplOpts := TemplateOpts{
+		Name:       "NotFound",
+		Source:     "asset:notfound",
+		Target:     ".",
+		FileName:   "test_notfound.go",
+		SkipExists: false,
+		SkipFormat: false,
+	}
+
+	buf, err := opts.render(&tplOpts, nil)
+	assert.Error(t, err, "Error should be handled here")
+	assert.Nil(t, buf, "Upon error, GenOpts.render() should return nil buffer")
+}
+
+// Low level testing: invalid template => Get() returns not found (higher level calls raise panic(), see above)
+// TODO: better error discrimination between absent definition and non-parsing template
+func TestShared_GarbledTemplate(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	garbled := "func x {{;;; garbled"
+
+	templates.AddFile("garbled", garbled)
+	opts := GenOpts{}
+	tplOpts := TemplateOpts{
+		Name:       "Garbled",
+		Source:     "asset:garbled",
+		Target:     ".",
+		FileName:   "test_garbled.go",
+		SkipExists: false,
+		SkipFormat: false,
+	}
+
+	buf, err := opts.render(&tplOpts, nil)
+	assert.Error(t, err, "Error should be handled here")
+	assert.Nil(t, buf, "Upon error, GenOpts.render() should return nil buffer")
+}
+
+// Template execution failure
+type myTemplateData struct {
+}
+
+func (*myTemplateData) MyFaultyMethod() (string, error) {
+	return "", fmt.Errorf("myFaultyError")
+}
+
+func TestShared_ExecTemplate(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	// Not a failure: no value data
+	execfailure1 := "func x {{ .NotInData }}"
+
+	templates.AddFile("execfailure1", execfailure1)
+	opts := new(GenOpts)
+	tplOpts := TemplateOpts{
+		Name:       "execFailure1",
+		Source:     "asset:execfailure1",
+		Target:     ".",
+		FileName:   "test_execfailure1.go",
+		SkipExists: false,
+		SkipFormat: false,
+	}
+
+	buf1, err := opts.render(&tplOpts, nil)
+	assert.NoError(t, err, "Template rendering should put <no value> instead of missing data, and report no error")
+	assert.Equal(t, string(buf1), "func x <no value>")
+
+	execfailure2 := "func {{ .MyFaultyMethod }}"
+
+	templates.AddFile("execfailure2", execfailure2)
+	opts = new(GenOpts)
+	tplOpts2 := TemplateOpts{
+		Name:       "execFailure2",
+		Source:     "asset:execfailure2",
+		Target:     ".",
+		FileName:   "test_execfailure2.go",
+		SkipExists: false,
+		SkipFormat: false,
+	}
+
+	data := new(myTemplateData)
+	buf2, err := opts.render(&tplOpts2, data)
+	assert.Error(t, err, "Error should be handled here: missing func in template yields an error")
+	assert.Contains(t, err.Error(), "template execution failed")
+	assert.Nil(t, buf2, "Upon error, GenOpts.render() should return nil buffer")
+}
+
+// Test correctly parsed templates, with bad formatting
+func TestShared_BadFormatTemplate(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+
+	defer func() {
+		os.Remove("test_badformat.gol")
+		os.Remove("test_badformat2.gol")
+		log.SetOutput(os.Stdout)
+		Debug = false
+	}()
+
+	// Not skipping format
+	badFormat := "func x {;;; garbled"
+
+	Debug = true
+	templates.AddFile("badformat", badFormat)
+
+	opts := GenOpts{}
+	opts.LanguageOpts = GoLangOpts()
+	tplOpts := TemplateOpts{
+		Name:   "badformat",
+		Source: "asset:badformat",
+		Target: ".",
+		// Extension ".gol" won't mess with go if cleanup is not performed
+		FileName:   "test_badformat.gol",
+		SkipExists: false,
+		SkipFormat: false,
+	}
+
+	data := appGenerator{
+		Name:    "badtest",
+		Package: "wrongpkg",
+	}
+
+	err := opts.write(&tplOpts, data)
+
+	// The badly formatted file has been dumped for debugging purposes
+	_, exists := os.Stat(tplOpts.FileName)
+	assert.True(t, !os.IsNotExist(exists), "The template file has not been generated as expected")
+	os.Remove(tplOpts.FileName)
+
+	assert.NotNil(t, err)
+	assert.Contains(t, err.Error(), "source formatting on generated source")
+
+	// Skipping format
+	opts = GenOpts{}
+	opts.LanguageOpts = GoLangOpts()
+	tplOpts2 := TemplateOpts{
+		Name:       "badformat2",
+		Source:     "asset:badformat",
+		Target:     ".",
+		FileName:   "test_badformat2.gol",
+		SkipExists: false,
+		SkipFormat: true,
+	}
+
+	err2 := opts.write(&tplOpts2, data)
+
+	// The unformatted file has been dumped without format checks
+	_, exists2 := os.Stat(tplOpts2.FileName)
+	assert.True(t, !os.IsNotExist(exists2), "The template file has not been generated as expected")
+	os.Remove(tplOpts2.FileName)
+
+	assert.Nil(t, err2)
+
+	// os.RemoveAll(filepath.Join(filepath.FromSlash(dr),"restapi"))
+}
+
+// Test dir creation
+func TestShared_DirectoryTemplate(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+
+	defer func() {
+		os.RemoveAll("TestGenDir")
+		log.SetOutput(os.Stdout)
+		Debug = false
+	}()
+
+	// Not skipping format
+	content := "func x {}"
+
+	Debug = true
+	templates.AddFile("gendir", content)
+
+	opts := GenOpts{}
+	opts.LanguageOpts = GoLangOpts()
+	tplOpts := TemplateOpts{
+		Name:   "gendir",
+		Source: "asset:gendir",
+		Target: "TestGenDir",
+		// Extension ".gol" won't mess with go if cleanup is not performed
+		FileName:   "test_gendir.gol",
+		SkipExists: false,
+		SkipFormat: true,
+	}
+
+	data := appGenerator{
+		Name:    "gentest",
+		Package: "stubpkg",
+	}
+
+	err := opts.write(&tplOpts, data)
+
+	// The badly formatted file has been dumped for debugging purposes
+	_, exists := os.Stat(filepath.Join(tplOpts.Target, tplOpts.FileName))
+	assert.True(t, !os.IsNotExist(exists), "The template file has not been generated as expected")
+	os.RemoveAll(tplOpts.Target)
+
+	assert.Nil(t, err)
+}
+
+// Test templates which are not assets (open in file)
+// Low level testing: templates loaded from file
+func TestShared_LoadTemplate(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	opts := GenOpts{}
+	tplOpts := TemplateOpts{
+		Name:       "File",
+		Source:     "File",
+		Target:     ".",
+		FileName:   "file.go",
+		SkipExists: false,
+		SkipFormat: false,
+	}
+
+	buf, err := opts.render(&tplOpts, nil)
+	//spew.Dump(err)
+	assert.Error(t, err, "Error should be handled here")
+	assert.Contains(t, err.Error(), "open File")
+	assert.Contains(t, err.Error(), "error while opening")
+	assert.Nil(t, buf, "Upon error, GenOpts.render() should return nil buffer")
+
+	opts.TemplateDir = filepath.Join(".", "myTemplateDir")
+	buf, err = opts.render(&tplOpts, nil)
+	//spew.Dump(err)
+	assert.Error(t, err, "Error should be handled here")
+	assert.Contains(t, err.Error(), "open "+filepath.Join("myTemplateDir", "File"))
+	assert.Contains(t, err.Error(), "error while opening")
+	assert.Nil(t, buf, "Upon error, GenOpts.render() should return nil buffer")
+
+}
diff --git a/generator/support.go b/generator/support.go
index 3d31c864..4e823e23 100644
--- a/generator/support.go
+++ b/generator/support.go
@@ -170,15 +170,16 @@ func checkPrefixAndFetchRelativePath(childpath string, parentpath string) (bool,
 
 }
 
+// TODO: handle error with a returned error rather than panic()
 func baseImport(tgt string) string {
 	tgtAbsPath, err := filepath.Abs(tgt)
 	if err != nil {
-		log.Fatalln(err)
+		log.Fatalf("could not evaluate base import path with target \"%s\". Target directory must be created beforehand: %v", tgt, err)
 	}
 	var tgtAbsPathExtended string
 	tgtAbsPathExtended, err = filepath.EvalSymlinks(tgtAbsPath)
 	if err != nil {
-		log.Fatalln(err)
+		log.Fatalf("could not evaluate base import path with target \"%s\" (with symlink resolution): %v", tgtAbsPath, err)
 	}
 
 	gopath := os.Getenv("GOPATH")
@@ -601,7 +602,7 @@ func (a *appGenerator) makeCodegenApp() (GenApp, error) {
 			a.GenOpts,
 		)
 		if err != nil {
-			return GenApp{}, err
+			return GenApp{}, fmt.Errorf("error in model %s while planning definitions: %v", mn, err)
 		}
 		if mod != nil {
 			//mod.ReceiverName = receiver
diff --git a/generator/support_test.go b/generator/support_test.go
index 1dce3be4..85e011a7 100644
--- a/generator/support_test.go
+++ b/generator/support_test.go
@@ -1,7 +1,9 @@
 package generator
 
 import (
+	"log"
 	"os"
+	"path/filepath"
 	goruntime "runtime"
 	"strings"
 	"testing"
@@ -76,7 +78,7 @@ func TestBaseImport(t *testing.T) {
 
 	oldgopath := os.Getenv("GOPATH")
 	defer os.Setenv("GOPATH", oldgopath)
-	defer os.RemoveAll(tempdir + "/root")
+	defer os.RemoveAll(filepath.Join(tempdir, "root"))
 
 	for _, item := range checkbaseimporttest {
 
@@ -88,22 +90,28 @@ func TestBaseImport(t *testing.T) {
 		// Change GOPATH
 		_ = os.Setenv("GOPATH", item.gopath)
 
-		// Create Symlink
-		_ = os.Symlink(item.symlinkdest, item.symlinksrc)
+		if item.symlinksrc != "" {
+			// Create Symlink
+			if err := os.Symlink(item.symlinkdest, item.symlinksrc); err == nil {
 
-		// Test
-		actualpath := baseImport(item.targetpath)
+				// Test
+				actualpath := baseImport(item.targetpath)
 
-		if goruntime.GOOS == "windows" {
-			item.expectedpath = strings.Replace(item.expectedpath, "/", "\\", -1)
-		}
+				if goruntime.GOOS == "windows" {
+					item.expectedpath = strings.Replace(item.expectedpath, "/", "\\", -1)
+				}
 
-		if actualpath != item.expectedpath {
-			t.Errorf("baseImport(%s): expected %s, actual %s", item.targetpath, item.expectedpath, actualpath)
-		}
+				if actualpath != item.expectedpath {
+					t.Errorf("baseImport(%s): expected %s, actual %s", item.targetpath, item.expectedpath, actualpath)
+				}
 
-		os.RemoveAll(tempdir + "/root")
+				os.RemoveAll(filepath.Join(tempdir, "root"))
 
+			} else {
+				log.Printf("WARNING:TestBaseImport with symlink could not be carried on. Symlink creation failed for %s -> %s: %v", item.symlinksrc, item.symlinkdest, err)
+				log.Printf("WARNING:TestBaseImport with symlink on Windows requires extended privileges (admin or a user with SeCreateSymbolicLinkPrivilege)")
+			}
+		}
 	}
 
 }
