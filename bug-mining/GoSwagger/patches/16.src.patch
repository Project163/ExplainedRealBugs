diff --git a/fixtures/codegen/todolist.enums.yml b/fixtures/codegen/todolist.enums.yml
index bf341402..78f7e33b 100644
--- a/fixtures/codegen/todolist.enums.yml
+++ b/fixtures/codegen/todolist.enums.yml
@@ -143,5 +143,45 @@ definitions:
           type: string
           enum: ["snow white", "tweetie", "bambi", "red riding hood"]
 
-
+  # provided as part of issue #72
+  # the enum of the anonymous schema under delegate comes out without a validation.
+  NewPrototype:
+    required:
+      - role
+      - delegate
+    type: object
+    description: Description of a new prototype
+    properties:
+      activating_user:
+        required:
+          - name
+        type: object
+        description: Repository creating user to whom the rule should apply
+        properties:
+          name:
+            type: string
+            description: The username for the activating_user
+      role:
+        enum:
+          - read
+          - write
+          - admin
+        type: string
+        description: Role that should be applied to the delegate
+      delegate:
+        required:
+          - name
+          - kind
+        type: object
+        description: Information about the user or team to which the rule grants access
+        properties:
+          kind:
+            enum:
+              - user
+              - team
+            type: string
+            description: Whether the delegate is a user or a team
+          name:
+            type: string
+            description: The name for the delegate team or user
 
diff --git a/fixtures/codegen/todolist.models.yml b/fixtures/codegen/todolist.models.yml
index 2d69b50f..1da6c353 100644
--- a/fixtures/codegen/todolist.models.yml
+++ b/fixtures/codegen/todolist.models.yml
@@ -530,48 +530,6 @@ definitions:
         type: string
         description: '(Custom Only) If specified, the ref/SHA1 used to checkout a git repository.'
 
-  # provided as part of issue #72
-  # the enum of the anonymous schema under delegate comes out without a validation.
-  NewPrototype:
-    required:
-      - role
-      - delegate
-    type: object
-    description: Description of a new prototype
-    properties:
-      activating_user:
-        required:
-          - name
-        type: object
-        description: Repository creating user to whom the rule should apply
-        properties:
-          name:
-            type: string
-            description: The username for the activating_user
-      role:
-        enum:
-          - read
-          - write
-          - admin
-        type: string
-        description: Role that should be applied to the delegate
-      delegate:
-        required:
-          - name
-          - kind
-        type: object
-        description: Information about the user or team to which the rule grants access
-        properties:
-          kind:
-            enum:
-              - user
-              - team
-            type: string
-            description: Whether the delegate is a user or a team
-          name:
-            type: string
-            description: The name for the delegate team or user
-
   Comment:
     type: "object"
     required:
diff --git a/generator/enum_test.go b/generator/enum_test.go
index 4f1aab8a..20be72fa 100644
--- a/generator/enum_test.go
+++ b/generator/enum_test.go
@@ -226,3 +226,35 @@ func TestEnum_ObjectThing(t *testing.T) {
 		}
 	}
 }
+
+func TestEnum_NewPrototype(t *testing.T) {
+	// ensure that the enum validation for the anonymous object under the delegate property
+	// is rendered.
+	specDoc, err := spec.Load("../fixtures/codegen/todolist.enums.yml")
+	if assert.NoError(t, err) {
+		definitions := specDoc.Spec().Definitions
+		k := "NewPrototype"
+		schema := definitions[k]
+		genModel, err := makeGenDefinition(k, "models", schema, specDoc)
+		if assert.NoError(t, err) {
+			buf := bytes.NewBuffer(nil)
+			err := modelTemplate.Execute(buf, genModel)
+			if assert.NoError(t, err) {
+				ff, err := formatGoFile("object_thing.go", buf.Bytes())
+				if assert.NoError(t, err) {
+					res := string(ff)
+					assertInCode(t, "ActivatingUser NewPrototypeActivatingUser `json:\"activating_user,omitempty\"`", res)
+					assertInCode(t, "Delegate NewPrototypeDelegate `json:\"delegate\"`", res)
+					assertInCode(t, "Role string `json:\"role\"`", res)
+					assertInCode(t, "var newPrototypeRoleEnum []interface{}", res)
+					assertInCode(t, "var newPrototypeDelegateKindEnum []interface{}", res)
+					assertInCode(t, "m.validateDelegate(formats)", res)
+					assertInCode(t, "m.validateRole(formats)", res)
+					assertInCode(t, "m.validateActivatingUser(formats)", res)
+					assertInCode(t, "m.Delegate.Validate(formats)", res)
+					assertInCode(t, "m.ActivatingUser.Validate(formats)", res)
+				}
+			}
+		}
+	}
+}
diff --git a/generator/model.go b/generator/model.go
index f951043d..5658e1b3 100644
--- a/generator/model.go
+++ b/generator/model.go
@@ -352,10 +352,37 @@ func (sg *schemaGenContext) MergeResult(other *schemaGenContext) {
 
 func (sg *schemaGenContext) buildProperties() error {
 	for k, v := range sg.Schema.Properties {
-		emprop := sg.NewStructBranch(k, v)
+		// check if this requires de-anonymizing, if so lift this as a new struct and extra schema
+		tpe, err := sg.TypeResolver.ResolveSchema(&v, true)
+		if err != nil {
+			return err
+		}
+
+		vv := v
+		var hasValidations bool
+		if tpe.IsComplexObject && tpe.IsAnonymous && len(v.Properties) > 0 {
+			pg := sg.makeNewStruct(sg.Name+swag.ToGoName(k), v)
+			if sg.Path != "" {
+				pg.Path = sg.Path + "+ \".\"+" + fmt.Sprintf("%q", k)
+			} else {
+				pg.Path = fmt.Sprintf("%q", k)
+			}
+			if err := pg.makeGenSchema(); err != nil {
+				return err
+			}
+			vv = *spec.RefProperty("#/definitions/" + pg.Name)
+			hasValidations = pg.GenSchema.HasValidations
+			sg.MergeResult(pg)
+			sg.ExtraSchemas[pg.Name] = pg.GenSchema
+		}
+
+		emprop := sg.NewStructBranch(k, vv)
 		if err := emprop.makeGenSchema(); err != nil {
 			return err
 		}
+		if hasValidations || emprop.GenSchema.HasValidations {
+			emprop.GenSchema.HasValidations = true
+		}
 		sg.MergeResult(emprop)
 		sg.GenSchema.Properties = append(sg.GenSchema.Properties, emprop.GenSchema)
 	}
diff --git a/generator/model_test.go b/generator/model_test.go
index ffcd2184..9fa887df 100644
--- a/generator/model_test.go
+++ b/generator/model_test.go
@@ -586,19 +586,19 @@ func TestGenerateModel_WithAdditional(t *testing.T) {
 				if assert.NoError(t, err) {
 					res := buf.String()
 					assertInCode(t, "type "+k+" struct {", res)
-					assertInCode(t, "Data "+k+"DataP0 `json:\"data,omitempty\"`", res)
-					assertInCode(t, "type "+k+"DataP0 struct {", res)
-					assertInCode(t, k+"DataP0 map[string]string `json:\"-\"`", res)
+					assertInCode(t, "Data "+k+"Data `json:\"data,omitempty\"`", res)
+					assertInCode(t, "type "+k+"Data struct {", res)
+					assertInCode(t, k+"Data map[string]string `json:\"-\"`", res)
 					assertInCode(t, "Name string `json:\"name,omitempty\"`", res)
-					assertInCode(t, k+"DataP0) UnmarshalJSON", res)
-					assertInCode(t, k+"DataP0) MarshalJSON", res)
+					assertInCode(t, k+"Data) UnmarshalJSON", res)
+					assertInCode(t, k+"Data) MarshalJSON", res)
 					assertInCode(t, "json.Marshal(m)", res)
-					assertInCode(t, "json.Marshal(m."+k+"DataP0)", res)
+					assertInCode(t, "json.Marshal(m."+k+"Data)", res)
 					assertInCode(t, "json.Unmarshal(data, &stage1)", res)
 					assertInCode(t, "json.Unmarshal(data, &stage2)", res)
 					assertInCode(t, "json.Unmarshal(v, &toadd)", res)
 					assertInCode(t, "result[k] = toadd", res)
-					assertInCode(t, "m."+k+"DataP0 = result", res)
+					assertInCode(t, "m."+k+"Data = result", res)
 					for _, p := range sch.Properties {
 						assertInCode(t, "delete(stage2, \""+p.Name+"\")", res)
 					}
diff --git a/generator/operation_test.go b/generator/operation_test.go
index 51d9ee20..8c9da477 100644
--- a/generator/operation_test.go
+++ b/generator/operation_test.go
@@ -5,7 +5,6 @@ import (
 	"testing"
 
 	"github.com/go-swagger/go-swagger/spec"
-	"github.com/kr/pretty"
 	"github.com/stretchr/testify/assert"
 )
 
@@ -65,7 +64,7 @@ func TestMakeOperation(t *testing.T) {
 	if assert.NoError(t, err) {
 		gO, err := b.MakeOperation()
 		if assert.NoError(t, err) {
-			pretty.Println(gO)
+			//pretty.Println(gO)
 			assert.Equal(t, "getTasks", gO.Name)
 			assert.Len(t, gO.Params, 2)
 			assert.Len(t, gO.Responses, 1)
diff --git a/generator/schemavalidation_test.go b/generator/schemavalidation_test.go
index eb247847..24708e09 100644
--- a/generator/schemavalidation_test.go
+++ b/generator/schemavalidation_test.go
@@ -324,22 +324,24 @@ func TestSchemaValidation_NamedNestedObject(t *testing.T) {
 					if assert.NoError(t, err) {
 						res := string(formatted)
 						assertInCode(t, k+") Validate(formats", res)
+						assertInCode(t, k+"Meta) Validate(formats", res)
 						assertInCode(t, k+") validateMeta(formats", res)
+						assertInCode(t, "m.Meta.Validate(formats)", res)
 						assertInCode(t, "err := validate.MinLength(\"meta\"+\".\"+\"first\",", res)
 						assertInCode(t, "err := validate.MaxLength(\"meta\"+\".\"+\"first\",", res)
 						assertInCode(t, "err := validate.Pattern(\"meta\"+\".\"+\"first\",", res)
 						assertInCode(t, "err := validate.Minimum(\"meta\"+\".\"+\"second\",", res)
 						assertInCode(t, "err := validate.Maximum(\"meta\"+\".\"+\"second\",", res)
 						assertInCode(t, "err := validate.MultipleOf(\"meta\"+\".\"+\"second\",", res)
-						assertInCode(t, "iThirdSize := int64(len(m.Meta.Third))", res)
+						assertInCode(t, "iThirdSize := int64(len(m.Third))", res)
 						assertInCode(t, "err := validate.MinItems(\"meta\"+\".\"+\"third\",", res)
 						assertInCode(t, "err := validate.MaxItems(\"meta\"+\".\"+\"third\",", res)
 						assertInCode(t, "err := validate.Minimum(\"meta\"+\".\"+\"third\"+\".\"+strconv.Itoa(i),", res)
 						assertInCode(t, "err := validate.Maximum(\"meta\"+\".\"+\"third\"+\".\"+strconv.Itoa(i),", res)
 						assertInCode(t, "err := validate.MultipleOf(\"meta\"+\".\"+\"third\"+\".\"+strconv.Itoa(i),", res)
-						assertInCode(t, "iFourthSize := int64(len(m.Meta.Fourth))", res)
-						assertInCode(t, "iiFourthSize := int64(len(m.Meta.Fourth[i]))", res)
-						assertInCode(t, "iiiFourthSize := int64(len(m.Meta.Fourth[i][ii]))", res)
+						assertInCode(t, "iFourthSize := int64(len(m.Fourth))", res)
+						assertInCode(t, "iiFourthSize := int64(len(m.Fourth[i]))", res)
+						assertInCode(t, "iiiFourthSize := int64(len(m.Fourth[i][ii]))", res)
 						assertInCode(t, "err := validate.MinItems(\"meta\"+\".\"+\"fourth\"+\".\"+strconv.Itoa(i),", res)
 						assertInCode(t, "err := validate.MaxItems(\"meta\"+\".\"+\"fourth\"+\".\"+strconv.Itoa(i),", res)
 						assertInCode(t, "err := validate.MinItems(\"meta\"+\".\"+\"fourth\"+\".\"+strconv.Itoa(i)+\".\"+strconv.Itoa(ii),", res)
@@ -372,6 +374,8 @@ func TestSchemaValidation_NestedObjectProps(t *testing.T) {
 					if assert.NoError(t, err) {
 						res := string(formatted)
 						assertInCode(t, k+") Validate(formats", res)
+						assertInCode(t, k+"Args) Validate(formats", res)
+						assertInCode(t, k+k+"ArgsMeta) Validate(formats", res)
 						assertInCode(t, "m.validateArgs(formats", res)
 						assertInCode(t, "err := validate.MinLength(\"args\"+\".\"+\"meta\"+\".\"+\"first\",", res)
 						assertInCode(t, "err := validate.MaxLength(\"args\"+\".\"+\"meta\"+\".\"+\"first\",", res)
@@ -379,15 +383,15 @@ func TestSchemaValidation_NestedObjectProps(t *testing.T) {
 						assertInCode(t, "err := validate.Minimum(\"args\"+\".\"+\"meta\"+\".\"+\"second\",", res)
 						assertInCode(t, "err := validate.Maximum(\"args\"+\".\"+\"meta\"+\".\"+\"second\",", res)
 						assertInCode(t, "err := validate.MultipleOf(\"args\"+\".\"+\"meta\"+\".\"+\"second\",", res)
-						assertInCode(t, "iThirdSize := int64(len(m.Args.Meta.Third))", res)
+						assertInCode(t, "iThirdSize := int64(len(m.Third))", res)
 						assertInCode(t, "err := validate.MinItems(\"args\"+\".\"+\"meta\"+\".\"+\"third\",", res)
 						assertInCode(t, "err := validate.MaxItems(\"args\"+\".\"+\"meta\"+\".\"+\"third\",", res)
 						assertInCode(t, "err := validate.Minimum(\"args\"+\".\"+\"meta\"+\".\"+\"third\"+\".\"+strconv.Itoa(i),", res)
 						assertInCode(t, "err := validate.Maximum(\"args\"+\".\"+\"meta\"+\".\"+\"third\"+\".\"+strconv.Itoa(i),", res)
 						assertInCode(t, "err := validate.MultipleOf(\"args\"+\".\"+\"meta\"+\".\"+\"third\"+\".\"+strconv.Itoa(i),", res)
-						assertInCode(t, "iFourthSize := int64(len(m.Args.Meta.Fourth))", res)
-						assertInCode(t, "iiFourthSize := int64(len(m.Args.Meta.Fourth[i]))", res)
-						assertInCode(t, "iiiFourthSize := int64(len(m.Args.Meta.Fourth[i][ii]))", res)
+						assertInCode(t, "iFourthSize := int64(len(m.Fourth))", res)
+						assertInCode(t, "iiFourthSize := int64(len(m.Fourth[i]))", res)
+						assertInCode(t, "iiiFourthSize := int64(len(m.Fourth[i][ii]))", res)
 						assertInCode(t, "err := validate.MinItems(\"args\"+\".\"+\"meta\"+\".\"+\"fourth\"+\".\"+strconv.Itoa(i),", res)
 						assertInCode(t, "err := validate.MaxItems(\"args\"+\".\"+\"meta\"+\".\"+\"fourth\"+\".\"+strconv.Itoa(i),", res)
 						assertInCode(t, "err := validate.MinItems(\"args\"+\".\"+\"meta\"+\".\"+\"fourth\"+\".\"+strconv.Itoa(i)+\".\"+strconv.Itoa(ii),", res)
