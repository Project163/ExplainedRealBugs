diff --git a/generator/client.go b/generator/client.go
index cf917951..d701d5dd 100644
--- a/generator/client.go
+++ b/generator/client.go
@@ -47,6 +47,10 @@ func GenerateClient(name string, modelNames, operationIDs []string, opts *GenOpt
 		}
 	}
 
+	if err := opts.CheckOpts(); err != nil {
+		return err
+	}
+
 	// Load the spec
 	_, specDoc, err := loadSpec(opts.Spec)
 	if err != nil {
diff --git a/generator/model.go b/generator/model.go
index 90d90b97..87718843 100644
--- a/generator/model.go
+++ b/generator/model.go
@@ -59,6 +59,10 @@ func GenerateDefinition(modelNames []string, opts *GenOpts) error {
 		}
 	}
 
+	if err := opts.CheckOpts(); err != nil {
+		return err
+	}
+
 	// Load the spec
 	specPath, specDoc, err := loadSpec(opts.Spec)
 	if err != nil {
diff --git a/generator/operation.go b/generator/operation.go
index 81b503a7..49f34c1d 100644
--- a/generator/operation.go
+++ b/generator/operation.go
@@ -69,6 +69,10 @@ func GenerateServerOperation(operationNames []string, opts *GenOpts) error {
 		}
 	}
 
+	if err := opts.CheckOpts(); err != nil {
+		return err
+	}
+
 	// Load the spec
 	_, specDoc, err := loadSpec(opts.Spec)
 	if err != nil {
diff --git a/generator/server_test.go b/generator/server_test.go
index f71b1736..85ef5c1a 100644
--- a/generator/server_test.go
+++ b/generator/server_test.go
@@ -8,6 +8,7 @@ import (
 	"log"
 	"os"
 	"path/filepath"
+	"regexp"
 	"strings"
 	"testing"
 
@@ -431,13 +432,18 @@ func TestServer_Issue1746(t *testing.T) {
 		}
 	}()
 	opts := testGenOpts()
-	// NOTE: test fails when target != "."
-	opts.Target = "."
-	opts.Spec = "../../fixtures/bugs/1746/fixture-1746.yaml"
+
+	opts.Target = filepath.Join("x")
+	_ = os.Mkdir(opts.Target, 0755)
+	opts.Spec = filepath.Join("..", "..", "fixtures", "bugs", "1746", "fixture-1746.yaml")
+	tgtSpec := regexp.QuoteMeta(filepath.Join("..", "..", opts.Spec))
 
 	err = GenerateServer("", nil, nil, &opts)
 	assert.NoError(t, err)
-	gulp, err := ioutil.ReadFile(filepath.Join("restapi", "configure_example_swagger_server.go"))
+	gulp, err := ioutil.ReadFile(filepath.Join("x", "restapi", "configure_example_swagger_server.go"))
 	assert.NoError(t, err)
-	assertInCode(t, `//go:generate swagger generate server --target .. --name ExampleSwaggerServer`, string(gulp))
+	tgtPath := regexp.QuoteMeta(filepath.Join("..", "..", opts.Target))
+	assertRegexpInCode(t, `go:generate swagger generate server.+\-\-target `+tgtPath, string(gulp))
+	assertRegexpInCode(t, `go:generate swagger generate server.+\-\-name\s+ExampleSwaggerServer`, string(gulp))
+	assertRegexpInCode(t, `go:generate swagger generate server.+\-\-spec\s+`+tgtSpec, string(gulp))
 }
diff --git a/generator/shared.go b/generator/shared.go
index 9e9b4720..9a2a9e45 100644
--- a/generator/shared.go
+++ b/generator/shared.go
@@ -583,57 +583,82 @@ type GenOpts struct {
 	Copyright              string
 }
 
-// TargetPath returns the target generation path relative to the server package
-// Method used by templates, e.g. with {{ .TargetPath }}
-// Errors are not fatal: an empty string is returned instead
-func (g *GenOpts) TargetPath() string {
-	tgtAbs, err := filepath.Abs(g.Target)
-	if err != nil {
-		log.Printf("could not evaluate target generation path \"%s\": you must create the target directory beforehand: %v", g.Target, err)
-		return ""
+// CheckOpts carries out some global consistency checks on options.
+//
+// At the moment, these checks simply protect TargetPath() and SpecPath()
+// functions. More checks may be added here.
+func (g *GenOpts) CheckOpts() error {
+	if !filepath.IsAbs(g.Target) {
+		if _, err := filepath.Abs(g.Target); err != nil {
+			return fmt.Errorf("could not locate target %s: %v", g.Target, err)
+		}
 	}
-	tgtAbs = filepath.ToSlash(tgtAbs)
-	srvrAbs, err := filepath.Abs(g.ServerPackage)
-	if err != nil {
-		log.Printf("could not evaluate target server path \"%s\": %v", g.ServerPackage, err)
-		return ""
+	if filepath.IsAbs(g.ServerPackage) {
+		return fmt.Errorf("you shouldn't specify an absolute path in --server-package: %s", g.ServerPackage)
 	}
-	srvrAbs = filepath.ToSlash(srvrAbs)
-	tgtRel, err := filepath.Rel(srvrAbs, tgtAbs)
-	if err != nil {
-		log.Printf("Target path \"%s\" and server path \"%s\" are not related. You shouldn't specify an absolute path in --server-package: %v", g.Target, g.ServerPackage, err)
-		return ""
+	if !filepath.IsAbs(g.Spec) && !strings.HasPrefix(g.Spec, "http://") && !strings.HasPrefix(g.Spec, "https://") {
+		if _, err := filepath.Abs(g.Spec); err != nil {
+			return fmt.Errorf("could not locate spec: %s", g.Spec)
+		}
+	}
+	return nil
+}
+
+// TargetPath returns the target generation path relative to the server package.
+// This method is used by templates, e.g. with {{ .TargetPath }}
+//
+// Errors cases are prevented by calling CheckOpts beforehand.
+//
+// Example:
+// Target: ${PWD}/tmp
+// ServerPackage: abc/efg
+//
+// Server is generated in ${PWD}/tmp/abc/efg
+// relative TargetPath returned: ../../../tmp
+//
+func (g *GenOpts) TargetPath() string {
+	var tgt string
+	if g.Target == "" {
+		tgt = "." // That's for windows
+	} else {
+		tgt = g.Target
 	}
-	tgtRel = filepath.ToSlash(tgtRel)
+	tgtAbs, _ := filepath.Abs(tgt)
+	srvPkg := filepath.FromSlash(g.LanguageOpts.ManglePackagePath(g.ServerPackage, "server"))
+	srvrAbs := filepath.Join(tgtAbs, srvPkg)
+	tgtRel, _ := filepath.Rel(srvrAbs, filepath.Dir(tgtAbs))
+	tgtRel = filepath.Join(tgtRel, filepath.Base(tgtAbs))
 	return tgtRel
 }
 
-// SpecPath returns the path to the spec relative to the server package
-// Method used by templates, e.g. with {{ .SpecPath }}
-// Errors are not fatal: an empty string is returned instead
+// SpecPath returns the path to the spec relative to the server package.
+// If the spec is remote keep this absolute location.
+//
+// If spec is not relative to server (e.g. lives on a different drive on windows),
+// then the resolved path is absolute.
+//
+// This method is used by templates, e.g. with {{ .SpecPath }}
+//
+// Errors cases are prevented by calling CheckOpts beforehand.
 func (g *GenOpts) SpecPath() string {
 	if strings.HasPrefix(g.Spec, "http://") || strings.HasPrefix(g.Spec, "https://") {
 		return g.Spec
 	}
 	// Local specifications
-	specAbs, err := filepath.Abs(g.Spec)
-	if err != nil {
-		log.Printf("could not evaluate target generation path \"%s\": you must create the target directory beforehand: %v", g.Spec, err)
-		return ""
-	}
-	specAbs = filepath.ToSlash(specAbs)
-	srvrAbs, err := filepath.Abs(g.ServerPackage)
-	if err != nil {
-		log.Printf("could not evaluate target server path \"%s\": %v", g.ServerPackage, err)
-		return ""
+	specAbs, _ := filepath.Abs(g.Spec)
+	var tgt string
+	if g.Target == "" {
+		tgt = "." // That's for windows
+	} else {
+		tgt = g.Target
 	}
-	srvrAbs = filepath.ToSlash(srvrAbs)
-	specRel, err := filepath.Rel(srvrAbs, specAbs)
+	tgtAbs, _ := filepath.Abs(tgt)
+	srvPkg := filepath.FromSlash(g.LanguageOpts.ManglePackagePath(g.ServerPackage, "server"))
+	srvAbs := filepath.Join(tgtAbs, srvPkg)
+	specRel, err := filepath.Rel(srvAbs, specAbs)
 	if err != nil {
-		log.Printf("Specification path \"%s\" and server path \"%s\" are not related. You shouldn't specify an absolute path in --server-package: %v", g.Spec, g.ServerPackage, err)
-		return ""
+		return specAbs
 	}
-	specRel = filepath.ToSlash(specRel)
 	return specRel
 }
 
diff --git a/generator/shared_test.go b/generator/shared_test.go
index dadf5894..402ca8b0 100644
--- a/generator/shared_test.go
+++ b/generator/shared_test.go
@@ -5,7 +5,9 @@ import (
 	"io/ioutil"
 	"log"
 	"os"
+	"path"
 	"path/filepath"
+	"runtime"
 	"strings"
 	"testing"
 
@@ -14,18 +16,57 @@ import (
 	"github.com/stretchr/testify/assert"
 )
 
-// TargetPath and SpecPath are used in server.gotmpl
-// as template variables: {{ .TestTargetPath }} and
-// {{ .SpecPath }}, to construct the go generate
-// directive.
+const testPath = "a/b/c"
+
 // TODO: there is a catch, since these methods are sensitive
 // to the CWD of the current swagger command (or go
 // generate when working on resulting template)
 // NOTE:
-// Errors in TargetPath are hard to simulate since
+// Errors in CheckOpts are hard to simulate since
 // they occur only on os.Getwd() errors
 // Windows style path is difficult to test on unix
 // since the filepath pkg is platform dependant
+func TestShared_CheckOpts(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer log.SetOutput(os.Stdout)
+
+	var opts = new(GenOpts)
+	_ = opts.EnsureDefaults()
+	cwd, _ := os.Getwd()
+
+	opts.Target = filepath.Join(".", "a", "b", "c")
+	opts.ServerPackage = filepath.Join(cwd, "a", "b", "c")
+	err := opts.CheckOpts()
+	assert.Error(t, err)
+
+	opts.Target = filepath.Join(cwd, "a", "b", "c")
+	opts.ServerPackage = testPath
+	err = opts.CheckOpts()
+	assert.NoError(t, err)
+
+	opts.Target = filepath.Join(cwd, "a", "b", "c")
+	opts.ServerPackage = testPath
+	opts.Spec = "https:/ab/c"
+	err = opts.CheckOpts()
+	assert.NoError(t, err)
+
+	opts.Target = filepath.Join(cwd, "a", "b", "c")
+	opts.ServerPackage = testPath
+	opts.Spec = "http:/ab/c"
+	err = opts.CheckOpts()
+	assert.NoError(t, err)
+
+	opts.Target = filepath.Join("a", "b", "c")
+	opts.ServerPackage = testPath
+	opts.Spec = filepath.Join(cwd, "x")
+	err = opts.CheckOpts()
+	assert.NoError(t, err)
+}
+
+// TargetPath and SpecPath are used in server.gotmpl
+// as template variables: {{ .TestTargetPath }} and
+// {{ .SpecPath }}, to construct the go generate
+// directive.
 func TestShared_TargetPath(t *testing.T) {
 	log.SetOutput(ioutil.Discard)
 	defer log.SetOutput(os.Stdout)
@@ -34,58 +75,39 @@ func TestShared_TargetPath(t *testing.T) {
 
 	// relative target
 	var opts = new(GenOpts)
-	opts.Target = "./a/b/c"
+	_ = opts.EnsureDefaults()
+	opts.Target = filepath.Join(".", "a", "b", "c")
 	opts.ServerPackage = "y"
-	expected := "../a/b/c"
+	expected := filepath.Join("..", "..", "c")
 	result := opts.TargetPath()
 	assert.Equal(t, expected, result)
 
 	// relative target, server path
 	opts = new(GenOpts)
-	opts.Target = "./a/b/c"
+	_ = opts.EnsureDefaults()
+	opts.Target = filepath.Join(".", "a", "b", "c")
 	opts.ServerPackage = "y/z"
-	expected = "../../a/b/c"
+	expected = filepath.Join("..", "..", "..", "c")
 	result = opts.TargetPath()
 	assert.Equal(t, expected, result)
 
 	// absolute target
 	opts = new(GenOpts)
-	opts.Target = filepath.Join(cwd, "a/b/c")
+	_ = opts.EnsureDefaults()
+	opts.Target = filepath.Join(cwd, "a", "b", "c")
 	opts.ServerPackage = "y"
-	expected = "../a/b/c"
+	expected = filepath.Join("..", "..", "c")
 	result = opts.TargetPath()
 	assert.Equal(t, expected, result)
 
 	// absolute target, server path
 	opts = new(GenOpts)
-	opts.Target = "./a/b/c"
-	opts.ServerPackage = "y/z"
-	expected = "../../a/b/c"
-	result = opts.TargetPath()
-	assert.Equal(t, expected, result)
-
-	// absolute server package
-	opts = new(GenOpts)
-	opts.Target = "/a/b/c"
-	opts.ServerPackage = "/y/z"
-	expected = "../../a/b/c"
+	_ = opts.EnsureDefaults()
+	opts.Target = filepath.Join(cwd, "a", "b", "c")
+	opts.ServerPackage = path.Join("y", "z")
+	expected = filepath.Join("..", "..", "..", "c")
 	result = opts.TargetPath()
 	assert.Equal(t, expected, result)
-
-	// TODO:
-	// unrelated path (Windows specific)
-	// TargetPath() is expected to fail
-	// when target and server reside on
-	// different volumes.
-	//if runtime.GOOS == "windows" {
-	//	log.Println("INFO:Need some additional testing on windows")
-	//opts = new(GenOpts)
-	//opts.Target = "C:/a/b/c"
-	//opts.ServerPackage = "D:/y/z"
-	//expected = ""
-	//result = opts.TargetPath()
-	//assert.Equal(t, expected, result)
-	//}
 }
 
 // NOTE: file://url is not supported
@@ -97,6 +119,7 @@ func TestShared_SpecPath(t *testing.T) {
 
 	// http URL spec
 	var opts = new(GenOpts)
+	_ = opts.EnsureDefaults()
 	opts.Spec = "http://a/b/c"
 	opts.ServerPackage = "y"
 	expected := opts.Spec
@@ -105,6 +128,7 @@ func TestShared_SpecPath(t *testing.T) {
 
 	// https URL spec
 	opts = new(GenOpts)
+	_ = opts.EnsureDefaults()
 	opts.Spec = "https://a/b/c"
 	opts.ServerPackage = "y"
 	expected = opts.Spec
@@ -113,64 +137,63 @@ func TestShared_SpecPath(t *testing.T) {
 
 	// relative spec
 	opts = new(GenOpts)
-	opts.Spec = "./a/b/c"
+	_ = opts.EnsureDefaults()
+	opts.Spec = filepath.Join(".", "a", "b", "c")
+	opts.Target = filepath.Join("d")
 	opts.ServerPackage = "y"
-	expected = "../a/b/c"
+	expected = filepath.Join("..", "..", "a", "b", "c")
 	result = opts.SpecPath()
 	assert.Equal(t, expected, result)
 
 	// relative spec, server path
 	opts = new(GenOpts)
-	opts.Spec = "./a/b/c"
+	_ = opts.EnsureDefaults()
+	opts.Spec = filepath.Join(".", "a", "b", "c")
+	opts.Target = filepath.Join("d", "e")
 	opts.ServerPackage = "y/z"
-	expected = "../../a/b/c"
+	expected = filepath.Join("..", "..", "..", "..", "a", "b", "c")
 	result = opts.SpecPath()
 	assert.Equal(t, expected, result)
 
-	// absolute spec
+	// relative spec, server path
 	opts = new(GenOpts)
-	opts.Spec = filepath.Join(cwd, "a/b/c")
-	opts.ServerPackage = "y"
-	expected = "../a/b/c"
+	_ = opts.EnsureDefaults()
+	opts.Spec = filepath.Join(".", "a", "b", "c")
+	opts.Target = filepath.Join(".", "a", "b")
+	opts.ServerPackage = "y/z"
+	expected = filepath.Join("..", "..", "c")
 	result = opts.SpecPath()
 	assert.Equal(t, expected, result)
 
-	// absolute spec, server path
+	// absolute spec
 	opts = new(GenOpts)
-	opts.Spec = "./a/b/c"
-	opts.ServerPackage = "y/z"
-	expected = "../../a/b/c"
+	_ = opts.EnsureDefaults()
+	opts.Spec = filepath.Join(cwd, "a", "b", "c")
+	opts.ServerPackage = "y"
+	expected = filepath.Join("..", "a", "b", "c")
 	result = opts.SpecPath()
 	assert.Equal(t, expected, result)
 
-	// absolute server package
+	// absolute spec, server path
 	opts = new(GenOpts)
-	opts.Spec = "/a/b/c"
-	opts.ServerPackage = "/y/z"
-	expected = "../../a/b/c"
+	_ = opts.EnsureDefaults()
+	opts.Spec = filepath.Join("..", "a", "b", "c")
+	opts.Target = ""
+	opts.ServerPackage = path.Join("y", "z")
+	expected = filepath.Join("..", "..", "..", "a", "b", "c")
 	result = opts.SpecPath()
 	assert.Equal(t, expected, result)
 
-	// TODO:
-	// unrelated path (Windows specific)
-	// SpecPath() is expected to fail
-	// when spec and server reside on
-	// different volumes.
-	// This shouldn't happen with go, since everything
-	// should be under the same GOPATH
-	// NOTE: a better error handling strategy would be
-	// to check that os.Getwd() and Rel() work well upstream
-	// and assume in functions that no error is returned.
-	//if runtime.GOOS == "windows" {
-	//	log.SetOutput(os.Stdout)
-	//	log.Println("INFO:Need some additional testing on windows")
-	//opts = new(GenOpts)
-	//opts.Spec = "C:/a/b/c"
-	//opts.ServerPackage = "D:/y/z"
-	//expected = ""
-	//result = opts.SpecPath()
-	//assert.Equal(t, expected, result)
-	//}
+	if runtime.GOOS == "windows" {
+		opts = new(GenOpts)
+		_ = opts.EnsureDefaults()
+		opts.Spec = filepath.Join("a", "b", "c")
+		opts.Target = filepath.Join("Z:", "e", "f", "f")
+		opts.ServerPackage = "y/z"
+		expected, _ = filepath.Abs(opts.Spec)
+		result = opts.SpecPath()
+		assert.Equal(t, expected, result)
+	}
 }
 
 // Low level testing: templates not found (higher level calls raise panic(), see above)
diff --git a/generator/support.go b/generator/support.go
index 821e6f9c..1725556a 100644
--- a/generator/support.go
+++ b/generator/support.go
@@ -57,6 +57,9 @@ func newAppGenerator(name string, modelNames, operationIDs []string, opts *GenOp
 	if opts == nil {
 		return nil, errors.New("gen opts are required")
 	}
+	if err := opts.CheckOpts(); err != nil {
+		return nil, err
+	}
 
 	templates.LoadDefaults()
 	if opts.Template != "" {
