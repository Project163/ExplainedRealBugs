diff --git a/docs/content/generate/spec.md b/docs/content/generate/spec.md
index bb7ea03a..9e724ed1 100644
--- a/docs/content/generate/spec.md
+++ b/docs/content/generate/spec.md
@@ -43,7 +43,7 @@ To use you can add a go:generate comment to your main file for example:
 
 The command requires a main package or file and it wants your code to compile. It uses the go tools loader to load an
 application and then scan all the packages that are in use by the code base.
-This means that for something to be discoverable it needs to be reachable by a codepath triggered through the main
+This means that for something to be discoverable it needs to be reachable by a code path triggered through the main
 package.
 
 If an annotation is not yet supported or you want to merge with a pre-existing spec, you can use the -i parameter.
@@ -54,7 +54,7 @@ swagger generate spec -i ./swagger.yml -o ./swagger.json
 
 #### Parsing rules
 
-:warning: This command relies heavily on the way godoc works. :warning: 
+:warning: This command relies heavily on the way godoc works. :warning:
 
 This means you should be very aware of all the things godoc supports.
 
@@ -83,3 +83,18 @@ There are several annotations that mark a comment block as a participant for the
 * [swagger:model](model)
 * [swagger:allOf](allOf)
 * [swagger:strfmt](strfmt)
+* [swagger:discriminated](discriminated)
+
+#### Embedded types
+
+For the embedded schema's there are a set of rules for the spec generator to vary the definition it generates.
+When an embedded type isn't decorated with the `swagger:allOf` annotation, then the properties from the embedded value
+will be included in the generated definition as if they were defined on the definition.
+But when the embedded type is decorated with the `swagger:allOf` annotation then the all of element will be defined as
+a "$ref" property instead. For an annotated type there is also the possibility to specify an argument, the value of
+this argument will be used as the value for the `x-class` extension. This allows for generators that support the
+`x-class` extension to reliably build a serializer for a type with a discriminator
+
+#### Describe definitions
+
+#### Describe parameters
diff --git a/fixtures/goparsing/classification/models/nomodel.go b/fixtures/goparsing/classification/models/nomodel.go
index dea70326..0d727d11 100644
--- a/fixtures/goparsing/classification/models/nomodel.go
+++ b/fixtures/goparsing/classification/models/nomodel.go
@@ -329,3 +329,182 @@ type MapTastic struct {
 type Interfaced struct {
 	CustomData interface{} `json:"custom_data"`
 }
+
+// A BaseStruct is a struct that has subtypes.
+//
+// it should deserialize into one of the struct types that
+// enlist for being implementations of this struct
+//
+// swagger:model animal
+type BaseStruct struct {
+	// ID of this no model instance.
+	// ids in this application start at 11 and are smaller than 1000
+	//
+	// required: true
+	// minimum: > 10
+	// maximum: < 1000
+	ID int64 `json:"id"`
+
+	// Name of this no model instance
+	//
+	// min length: 4
+	// max length: 50
+	// pattern: [A-Za-z0-9-.]*
+	// required: true
+	Name string `json:"name"`
+
+	// StructType the type of this polymorphic model
+	//
+	// discriminator: true
+	StructType string `json:"jsonClass"`
+}
+
+/* TODO: implement this in the scanner
+
+// A Lion is a struct that "subtypes" the BaseStruct
+//
+// it does so because it included the fields in the struct body
+// The scanner assumes it will follow the rules and describes this type
+// as discriminated in the swagger spec based on the discriminator value
+// annotation.
+//
+// swagger:model lion
+// swagger:discriminatorValue animal org.horrible.java.fqpn.TheLionDataObjectFactoryInstanceServiceImpl
+type Lion struct {
+	// ID of this no model instance.
+	// ids in this application start at 11 and are smaller than 1000
+	//
+	// required: true
+	// minimum: > 10
+	// maximum: < 1000
+	ID int64 `json:"id"`
+
+	// Name of this no model instance
+	//
+	// min length: 4
+	// max length: 50
+	// pattern: [A-Za-z0-9-.]*
+	// required: true
+	Name string `json:"name"`
+
+	// StructType the type of this polymorphic model
+	StructType string `json:"jsonClass"`
+
+	// Leader is true when this is the leader of its group
+	//
+	// default value: false
+	Leader bool `json:"leader"`
+}
+*/
+
+// A Giraffe is a struct that embeds BaseStruct
+//
+// the annotation is not necessary here because of inclusion
+// of a discriminated type
+// it infers the name of the x-class value from its context
+//
+// swagger:model giraffe
+type Giraffe struct {
+	// swagger:allOf
+	BaseStruct
+
+	// NeckSize the size of the neck of this giraffe
+	NeckSize int64 `json:"neckSize"`
+}
+
+// A Gazelle is a struct is discriminated for BaseStruct.
+//
+// The struct includes the BaseStruct and that embedded value
+// is annotated with the discriminator value annotation so it
+// where it only requires 1 argument because it knows which
+// discriminator type this belongs to
+//
+// swagger:model gazelle
+type Gazelle struct {
+	// swagger:allOf a.b.c.d.E
+	BaseStruct
+
+	// The size of the horns
+	HornSize float32 `json:"hornSize"`
+}
+
+// Identifiable is an interface for things that have an ID
+type Identifiable interface {
+	// ID of this no model instance.
+	// ids in this application start at 11 and are smaller than 1000
+	//
+	// required: true
+	// minimum: > 10
+	// maximum: < 1000
+	// swagger:name id
+	ID() int64
+}
+
+// WaterType is an interface describing a water type
+//
+// swagger:model water
+type WaterType interface {
+	// swagger:name sweetWater
+	SweetWater() bool
+	// swagger:name saltWater
+	SaltWater() bool
+}
+
+// Fish represents a base type implemented as interface
+// the nullary methods of this interface will be included as
+//
+// swagger:model fish
+type Fish interface {
+	Identifiable // interfaces like this are included as if they were defined directly on this type
+
+	// embeds decorated with allOf are included as refs
+
+	// swagger:allOf
+	WaterType
+
+	// swagger:allOf
+	mods.ExtraInfo
+
+	mods.EmbeddedColor
+
+	Items(id, size int64) []string
+
+	// Name of this no model instance
+	//
+	// min length: 4
+	// max length: 50
+	// pattern: [A-Za-z0-9-.]*
+	// required: true
+	// swagger:name name
+	Name() string
+
+	// StructType the type of this polymorphic model
+	// Discriminator: true
+	// swagger:name jsonClass
+	StructType() string
+}
+
+// TeslaCar is a tesla car
+//
+// swagger:model
+type TeslaCar interface {
+	// The model of tesla car
+	//
+	// discriminated: true
+	// swagger:name model
+	Model() string
+
+	// AutoPilot returns true when it supports autopilot
+	// swagger:name autoPilot
+	AutoPilot() bool
+}
+
+// The ModelS version of the tesla car
+//
+// swagger:model modelS
+type ModelS struct {
+	// swagger:allOf com.tesla.models.ModelS
+	TeslaCar
+	// The edition of this Model S
+	Edition string `json:"edition"`
+}
diff --git a/fixtures/goparsing/classification/transitive/mods/interfaces.go b/fixtures/goparsing/classification/transitive/mods/interfaces.go
new file mode 100644
index 00000000..546b8ba3
--- /dev/null
+++ b/fixtures/goparsing/classification/transitive/mods/interfaces.go
@@ -0,0 +1,16 @@
+package mods
+
+// ExtraInfo is an interface for things that have extra info
+// swagger:model extra
+type ExtraInfo interface {
+	// swagger:name extraInfo
+	ExtraInfo() string
+}
+
+// EmbeddedColor is a color
+//
+// swagger:model color
+type EmbeddedColor interface {
+	// swagger:name colorName
+	ColorName() string
+}
diff --git a/generator/discriminators.go b/generator/discriminators.go
index 083d5342..3c2a5cb1 100644
--- a/generator/discriminators.go
+++ b/generator/discriminators.go
@@ -30,10 +30,13 @@ func discriminatorInfo(doc *spec.Document) *discInfo {
 	baseTypes := make(map[string]discor)
 	for _, sch := range doc.AllDefinitions() {
 		if sch.Schema.Discriminator != "" {
+			tpe, _ := sch.Schema.Extensions.GetString("x-go-name")
+			if tpe == "" {
+				tpe = swag.ToGoName(sch.Name)
+			}
 			baseTypes[sch.Ref.String()] = discor{
-				// TODO: more trickery to allow for name customization
 				FieldName: sch.Schema.Discriminator,
-				GoType:    swag.ToGoName(sch.Name),
+				GoType:    tpe,
 				JSONName:  sch.Name,
 			}
 		}
@@ -44,15 +47,24 @@ func discriminatorInfo(doc *spec.Document) *discInfo {
 		for _, ao := range sch.Schema.AllOf {
 			if ao.Ref.String() != "" {
 				if bt, ok := baseTypes[ao.Ref.String()]; ok {
+					name, _ := sch.Schema.Extensions.GetString("x-class")
+					if name == "" {
+						name, _ = sch.Schema.Extensions.GetString("x-go-name")
+					}
+					if name == "" {
+						name = swag.ToGoName(sch.Name)
+					}
+					tpe, _ := sch.Schema.Extensions.GetString("x-go-name")
+					if tpe == "" {
+						tpe = swag.ToGoName(sch.Name)
+					}
 					dce := discee{
-						FieldName: bt.FieldName,
-						// TODO: more trickery to allow for name customization
-						FieldValue: swag.ToGoName(sch.Name),
+						FieldName:  bt.FieldName,
+						FieldValue: name,
 						Ref:        sch.Ref,
 						ParentRef:  ao.Ref,
 						JSONName:   sch.Name,
-						// TODO: more trickery to allow for name customization
-						GoType: swag.ToGoName(sch.Name),
+						GoType:     tpe,
 					}
 					subTypes[sch.Ref.String()] = dce
 					bt.Children = append(bt.Children, dce)
diff --git a/scan/classifier.go b/scan/classifier.go
index fc10a32d..3b962708 100644
--- a/scan/classifier.go
+++ b/scan/classifier.go
@@ -128,7 +128,7 @@ func (pc *programClassifier) Classify(prog *loader.Program) (*classifiedProgram,
 								} else {
 									return nil, fmt.Errorf("classifier: already annotated as %s, can't also be %q", seenStruct, matches[1])
 								}
-							case "strfmt":
+							case "strfmt", "name", "discriminated":
 								// TODO: perhaps collect these and pass along to avoid lookups later on
 							case "allOf":
 							default:
diff --git a/scan/doc.go b/scan/doc.go
index c80af2ff..013a4e42 100644
--- a/scan/doc.go
+++ b/scan/doc.go
@@ -52,6 +52,12 @@ in the definitions object of swagger.
 The struct gets analyzed and all the collected models are added to the tree.
 The refs are tracked separately so that they can be renamed later on.
 
+When this annotation is found to be on an interface instead of a struct, the properties are provided
+through exported nullary methods.
+
+A property of an interface model can have a Discriminator: true annotation to mark that field as
+the field that will contain the discriminator value.
+
 swagger:route [method] [path pattern] [operation id] [?tag1 tag2 tag3]
 
 A swagger:route annotation links a path to a method.
diff --git a/scan/routes.go b/scan/routes.go
index 51de57e6..7df8ec45 100644
--- a/scan/routes.go
+++ b/scan/routes.go
@@ -187,7 +187,7 @@ func (rp *routesParser) Parse(gofile *ast.File, target interface{}) error {
 		sp := new(sectionedParser)
 		sp.setTitle = func(lines []string) { op.Summary = joinDropLast(lines) }
 		sp.setDescription = func(lines []string) { op.Description = joinDropLast(lines) }
-		sr := newSetResponses2(rp.definitions, rp.responses, opResponsesSetter(op))
+		sr := newSetResponses(rp.definitions, rp.responses, opResponsesSetter(op))
 		sp.taggers = []tagParser{
 			newMultiLineTagParser("Consumes", newMultilineDropEmptyParser(rxConsumes, opConsumesSetter(op))),
 			newMultiLineTagParser("Produces", newMultilineDropEmptyParser(rxProduces, opProducesSetter(op))),
diff --git a/scan/scanner.go b/scan/scanner.go
index 3141be53..690802fa 100644
--- a/scan/scanner.go
+++ b/scan/scanner.go
@@ -54,8 +54,10 @@ var (
 	rxSwaggerAnnotation  = regexp.MustCompile("swagger:([\\p{L}\\p{N}\\p{Pd}\\p{Pc}]+)")
 	rxMeta               = regexp.MustCompile("swagger:meta")
 	rxStrFmt             = regexp.MustCompile("swagger:strfmt\\p{Zs}*(\\p{L}[\\p{L}\\p{N}\\p{Pd}\\p{Pc}]+)$")
-	rxAllOf              = regexp.MustCompile("swagger:allOf")
+	rxName               = regexp.MustCompile("swagger:name\\p{Zs}*(\\p{L}[\\p{L}\\p{N}\\p{Pd}\\p{Pc}\\.]+)$")
+	rxAllOf              = regexp.MustCompile("swagger:allOf\\p{Zs}*(\\p{L}[\\p{L}\\p{N}\\p{Pd}\\p{Pc}\\.]+)?$")
 	rxModelOverride      = regexp.MustCompile("swagger:model\\p{Zs}*(\\p{L}[\\p{L}\\p{N}\\p{Pd}\\p{Pc}]+)?$")
+	rxDiscriminated      = regexp.MustCompile("swagger:discriminated\\p{Zs}*(\\p{L}[\\p{L}\\p{N}\\p{Pd}\\p{Pc}\\p{Zs}]+)$")
 	rxResponseOverride   = regexp.MustCompile("swagger:response\\p{Zs}*(\\p{L}[\\p{L}\\p{N}\\p{Pd}\\p{Pc}]+)?$")
 	rxParametersOverride = regexp.MustCompile("swagger:parameters\\p{Zs}*(\\p{L}[\\p{L}\\p{N}\\p{Pd}\\p{Pc}\\p{Zs}]+)$")
 	rxRoute              = regexp.MustCompile(
@@ -66,7 +68,7 @@ var (
 			"\\p{Zs}+" +
 			rxOpTags +
 			"\\p{Zs}+" +
-			rxOpID + "$")
+			rxOpID + "\\p{Zs}*$")
 
 	rxSpace              = regexp.MustCompile("\\p{Zs}+")
 	rxNotAlNumSpaceComma = regexp.MustCompile("[^\\p{L}\\p{N}\\p{Zs},]")
@@ -74,20 +76,21 @@ var (
 	rxStripComments      = regexp.MustCompile("^[^\\w\\+]*")
 	rxStripTitleComments = regexp.MustCompile("^[^\\p{L}]*[Pp]ackage\\p{Zs}+[^\\p{Zs}]+\\p{Zs}*")
 
-	rxIn        = regexp.MustCompile("[Ii]n\\p{Zs}*:\\p{Zs}*(query|path|header|body|formData)$")
-	rxRequired  = regexp.MustCompile("[Rr]equired\\p{Zs}*:\\p{Zs}*(true|false)$")
-	rxReadOnly  = regexp.MustCompile("[Rr]ead(?:\\p{Zs}*|[\\p{Pd}\\p{Pc}])?[Oo]nly\\p{Zs}*:\\p{Zs}*(true|false)$")
-	rxConsumes  = regexp.MustCompile("[Cc]onsumes\\p{Zs}*:")
-	rxProduces  = regexp.MustCompile("[Pp]roduces\\p{Zs}*:")
-	rxSecurity  = regexp.MustCompile("[Ss]ecurity\\p{Zs}*:")
-	rxResponses = regexp.MustCompile("[Rr]esponses\\p{Zs}*:")
-	rxSchemes   = regexp.MustCompile("[Ss]chemes\\p{Zs}*:\\p{Zs}*((?:(?:https?|HTTPS?|wss?|WSS?)[\\p{Zs},]*)+)$")
-	rxVersion   = regexp.MustCompile("[Vv]ersion\\p{Zs}*:\\p{Zs}*(.+)$")
-	rxHost      = regexp.MustCompile("[Hh]ost\\p{Zs}*:\\p{Zs}*(.+)$")
-	rxBasePath  = regexp.MustCompile("[Bb]ase\\p{Zs}*-*[Pp]ath\\p{Zs}*:\\p{Zs}*" + rxPath + "$")
-	rxLicense   = regexp.MustCompile("[Ll]icense\\p{Zs}*:\\p{Zs}*(.+)$")
-	rxContact   = regexp.MustCompile("[Cc]ontact\\p{Zs}*-?(?:[Ii]info\\p{Zs}*)?:\\p{Zs}*(.+)$")
-	rxTOS       = regexp.MustCompile("[Tt](:?erms)?\\p{Zs}*-?[Oo]f?\\p{Zs}*-?[Ss](?:ervice)?\\p{Zs}*:")
+	rxIn            = regexp.MustCompile("[Ii]n\\p{Zs}*:\\p{Zs}*(query|path|header|body|formData)$")
+	rxRequired      = regexp.MustCompile("[Rr]equired\\p{Zs}*:\\p{Zs}*(true|false)$")
+	rxDiscriminator = regexp.MustCompile("[Dd]iscriminator\\p{Zs}*:\\p{Zs}*(true|false)$")
+	rxReadOnly      = regexp.MustCompile("[Rr]ead(?:\\p{Zs}*|[\\p{Pd}\\p{Pc}])?[Oo]nly\\p{Zs}*:\\p{Zs}*(true|false)$")
+	rxConsumes      = regexp.MustCompile("[Cc]onsumes\\p{Zs}*:")
+	rxProduces      = regexp.MustCompile("[Pp]roduces\\p{Zs}*:")
+	rxSecurity      = regexp.MustCompile("[Ss]ecurity\\p{Zs}*:")
+	rxResponses     = regexp.MustCompile("[Rr]esponses\\p{Zs}*:")
+	rxSchemes       = regexp.MustCompile("[Ss]chemes\\p{Zs}*:\\p{Zs}*((?:(?:https?|HTTPS?|wss?|WSS?)[\\p{Zs},]*)+)$")
+	rxVersion       = regexp.MustCompile("[Vv]ersion\\p{Zs}*:\\p{Zs}*(.+)$")
+	rxHost          = regexp.MustCompile("[Hh]ost\\p{Zs}*:\\p{Zs}*(.+)$")
+	rxBasePath      = regexp.MustCompile("[Bb]ase\\p{Zs}*-*[Pp]ath\\p{Zs}*:\\p{Zs}*" + rxPath + "$")
+	rxLicense       = regexp.MustCompile("[Ll]icense\\p{Zs}*:\\p{Zs}*(.+)$")
+	rxContact       = regexp.MustCompile("[Cc]ontact\\p{Zs}*-?(?:[Ii]info\\p{Zs}*)?:\\p{Zs}*(.+)$")
+	rxTOS           = regexp.MustCompile("[Tt](:?erms)?\\p{Zs}*-?[Oo]f?\\p{Zs}*-?[Ss](?:ervice)?\\p{Zs}*:")
 )
 
 // Many thanks go to https://github.com/yvasiyarov/swagger
diff --git a/scan/scanner_test.go b/scan/scanner_test.go
index 0dbcb6a9..4ea4cf0e 100644
--- a/scan/scanner_test.go
+++ b/scan/scanner_test.go
@@ -543,6 +543,33 @@ func TestSchemaValueExtractors(t *testing.T) {
 		" swagger:model     ",
 		"swagger:model      ",
 	}
+
+	allOf := []string{
+		"// swagger:allOf ",
+		"* swagger:allOf ",
+		"* swagger:allOf ",
+		" swagger:allOf ",
+		"swagger:allOf ",
+		"// swagger:allOf    ",
+		"* swagger:allOf     ",
+		"* swagger:allOf    ",
+		" swagger:allOf     ",
+		"swagger:allOf      ",
+	}
+
+	discriminated := []string{
+		"// swagger:discriminated ",
+		"* swagger:discriminated ",
+		"* swagger:discriminated ",
+		" swagger:discriminated ",
+		"swagger:discriminated ",
+		"// swagger:discriminated    ",
+		"* swagger:discriminated     ",
+		"* swagger:discriminated    ",
+		" swagger:discriminated     ",
+		"swagger:discriminated      ",
+	}
+
 	parameters := []string{
 		"// swagger:parameters ",
 		"* swagger:parameters ",
@@ -572,6 +599,10 @@ func TestSchemaValueExtractors(t *testing.T) {
 
 	verifySwaggerOneArgSwaggerTag(t, rxStrFmt, strfmts, validParams, append(invalidParams, "", "  ", " "))
 	verifySwaggerOneArgSwaggerTag(t, rxModelOverride, models, append(validParams, "", "  ", " "), invalidParams)
+
+	verifySwaggerOneArgSwaggerTag(t, rxAllOf, allOf, append(validParams, "", "  ", " "), invalidParams)
+	verifySwaggerMultiArgSwaggerTag(t, rxDiscriminated, discriminated, validParams, invalidParams)
+
 	verifySwaggerMultiArgSwaggerTag(t, rxParametersOverride, parameters, validParams, invalidParams)
 
 	verifyMinMax(t, rxf(rxMinimumFmt, ""), "min", []string{"", ">", "="})
@@ -816,8 +847,9 @@ func verifySwaggerOneArgSwaggerTag(t *testing.T, matcher *regexp.Regexp, prefixe
 		for _, param := range validParams {
 			line := pref + param
 			matches := matcher.FindStringSubmatch(line)
-			assert.Len(t, matches, 2)
-			assert.Equal(t, strings.TrimSpace(param), matches[1])
+			if assert.Len(t, matches, 2) {
+				assert.Equal(t, strings.TrimSpace(param), matches[1])
+			}
 		}
 	}
 
diff --git a/scan/schema.go b/scan/schema.go
index 8b2fd16f..6a4094f0 100644
--- a/scan/schema.go
+++ b/scan/schema.go
@@ -162,11 +162,13 @@ func (sd *schemaDecl) inferNames() (goName string, name string) {
 type schemaParser struct {
 	program   *loader.Program
 	postDecls []schemaDecl
+	known     map[string]spec.Schema
 }
 
 func newSchemaParser(prog *loader.Program) *schemaParser {
 	scp := new(schemaParser)
 	scp.program = prog
+	scp.known = make(map[string]spec.Schema)
 	return scp
 }
 
@@ -215,11 +217,18 @@ func (scp *schemaParser) parseDecl(definitions map[string]spec.Schema, decl *sch
 	// * when the struct field points to a model it becomes a ref: #/definitions/ModelName
 	// * the first line of the comment is the title
 	// * the following lines are the description
-	if tpe, ok := decl.TypeSpec.Type.(*ast.StructType); ok {
+	switch tpe := decl.TypeSpec.Type.(type) {
+	case *ast.StructType:
 		if err := scp.parseStructType(decl.File, schPtr, tpe, make(map[string]struct{})); err != nil {
 			return err
 		}
+	case *ast.InterfaceType:
+		if err := scp.parseInterfaceType(decl.File, schPtr, tpe, make(map[string]struct{})); err != nil {
+			return err
+		}
+	default:
 	}
+
 	if decl.Name != decl.GoName {
 		schPtr.AddExtension("x-go-name", decl.GoName)
 	}
@@ -236,7 +245,7 @@ func (scp *schemaParser) parseDecl(definitions map[string]spec.Schema, decl *sch
 	return nil
 }
 
-func (scp *schemaParser) parseEmbeddedStruct(gofile *ast.File, schema *spec.Schema, expr ast.Expr, seenPreviously map[string]struct{}) error {
+func (scp *schemaParser) parseEmbeddedType(gofile *ast.File, schema *spec.Schema, expr ast.Expr, seenPreviously map[string]struct{}) error {
 	switch tpe := expr.(type) {
 	case *ast.Ident:
 		// do lookup of type
@@ -252,6 +261,9 @@ func (scp *schemaParser) parseEmbeddedStruct(gofile *ast.File, schema *spec.Sche
 		if st, ok := ts.Type.(*ast.StructType); ok {
 			return scp.parseStructType(file, schema, st, seenPreviously)
 		}
+		if st, ok := ts.Type.(*ast.InterfaceType); ok {
+			return scp.parseInterfaceType(file, schema, st, seenPreviously)
+		}
 
 	case *ast.SelectorExpr:
 		// look up package, file and then type
@@ -266,6 +278,9 @@ func (scp *schemaParser) parseEmbeddedStruct(gofile *ast.File, schema *spec.Sche
 		if st, ok := ts.Type.(*ast.StructType); ok {
 			return scp.parseStructType(file, schema, st, seenPreviously)
 		}
+		if st, ok := ts.Type.(*ast.InterfaceType); ok {
+			return scp.parseInterfaceType(file, schema, st, seenPreviously)
+		}
 	}
 	return fmt.Errorf("unable to resolve embedded struct for: %v\n", expr)
 }
@@ -314,173 +329,312 @@ func (scp *schemaParser) parseAllOfMember(gofile *ast.File, schema *spec.Schema,
 		schema.Ref = ref
 		scp.postDecls = append(scp.postDecls, *sd)
 	} else {
-		if st, ok := ts.Type.(*ast.StructType); ok {
+		switch st := ts.Type.(type) {
+		case *ast.StructType:
 			return scp.parseStructType(file, schema, st, seenPreviously)
+		case *ast.InterfaceType:
+			return scp.parseInterfaceType(file, schema, st, seenPreviously)
 		}
 	}
 
 	return nil
 }
+func (scp *schemaParser) parseInterfaceType(gofile *ast.File, bschema *spec.Schema, tpe *ast.InterfaceType, seenPreviously map[string]struct{}) error {
+	if tpe.Methods == nil {
+		return nil
+	}
 
-func (scp *schemaParser) parseStructType(gofile *ast.File, bschema *spec.Schema, tpe *ast.StructType, seenPreviously map[string]struct{}) error {
-	if tpe.Fields != nil {
-		var schema *spec.Schema
-		seenProperties := seenPreviously
-
-		for _, fld := range tpe.Fields.List {
-			if len(fld.Names) == 0 {
-				// if this created an allOf property then we have to rejig the schema var
-				// because all the fields collected that aren't from embedded structs should go in
-				// their own proper schema
-				// first process embedded structs in order of embedding
-				if allOfMember(fld.Doc) {
-					if schema == nil {
-						schema = new(spec.Schema)
-					}
-					var newSch spec.Schema
-					// when the embedded struct is annotated with swagger:allOf it will be used as allOf property
-					// otherwise the fields will just be included as normal properties
-					if err := scp.parseAllOfMember(gofile, &newSch, fld.Type, seenProperties); err != nil {
-						return err
-					}
-					bschema.AllOf = append(bschema.AllOf, newSch)
-					continue
-				}
+	// first check if this has embedded interfaces, if so make sure to refer to those by ref
+	// when they are decorated with an allOf annotation
+	// go over the method list again and this time collect the nullary methods and parse the comments
+	// as if they are properties on a struct
+	var schema *spec.Schema
+	seenProperties := seenPreviously
+	hasAllOf := false
+
+	for _, fld := range tpe.Methods.List {
+		if len(fld.Names) == 0 {
+			// if this created an allOf property then we have to rejig the schema var
+			// because all the fields collected that aren't from embedded structs should go in
+			// their own proper schema
+			// first process embedded structs in order of embedding
+			if allOfMember(fld.Doc) {
+				hasAllOf = true
 				if schema == nil {
-					schema = bschema
+					schema = new(spec.Schema)
 				}
-
+				var newSch spec.Schema
 				// when the embedded struct is annotated with swagger:allOf it will be used as allOf property
 				// otherwise the fields will just be included as normal properties
-				if err := scp.parseEmbeddedStruct(gofile, schema, fld.Type, seenProperties); err != nil {
+				if err := scp.parseAllOfMember(gofile, &newSch, fld.Type, seenProperties); err != nil {
 					return err
 				}
-			}
-		}
-		if schema != nil && len(bschema.AllOf) > 0 {
-			bschema.AllOf = append(bschema.AllOf, *schema)
-		}
-		if schema == nil {
-			schema = bschema
-		}
 
-		// then add and possibly override values
-		if schema.Properties == nil {
-			schema.Properties = make(map[string]spec.Schema)
-		}
-		schema.Typed("object", "")
-		for _, fld := range tpe.Fields.List {
-			var tag string
-			if fld.Tag != nil {
-				val, err := strconv.Unquote(fld.Tag.Value)
-				if err == nil {
-					tag = reflect.StructTag(val).Get("json")
+				if fld.Doc != nil {
+					for _, cmt := range fld.Doc.List {
+						for _, ln := range strings.Split(cmt.Text, "\n") {
+							matches := rxAllOf.FindStringSubmatch(ln)
+							ml := len(matches)
+							if ml > 1 {
+								mv := matches[ml-1]
+								if mv != "" {
+									bschema.AddExtension("x-class", mv)
+								}
+							}
+						}
+					}
 				}
+
+				bschema.AllOf = append(bschema.AllOf, newSch)
+				continue
 			}
-			if len(fld.Names) > 0 && fld.Names[0] != nil && fld.Names[0].IsExported() && (tag == "" || tag[0] != '-') {
-				var nm, gnm string
-				nm = fld.Names[0].Name
-				gnm = nm
-				if fld.Tag != nil && len(strings.TrimSpace(fld.Tag.Value)) > 0 /*&& fld.Tag.Value[0] != '-'*/ {
-					tv, err := strconv.Unquote(fld.Tag.Value)
-					if err != nil {
-						return err
-					}
 
-					if strings.TrimSpace(tv) != "" {
-						st := reflect.StructTag(tv)
-						if st.Get("json") != "" {
-							nm = strings.Split(st.Get("json"), ",")[0]
+			var newSch spec.Schema
+			// when the embedded struct is annotated with swagger:allOf it will be used as allOf property
+			// otherwise the fields will just be included as normal properties
+			if err := scp.parseEmbeddedType(gofile, &newSch, fld.Type, seenProperties); err != nil {
+				return err
+			}
+			bschema.AllOf = append(bschema.AllOf, newSch)
+			hasAllOf = true
+		}
+	}
+	if schema == nil {
+		schema = bschema
+	}
+	// then add and possibly override values
+	if schema.Properties == nil {
+		schema.Properties = make(map[string]spec.Schema)
+	}
+	schema.Typed("object", "")
+	for _, fld := range tpe.Methods.List {
+		if mtpe, ok := fld.Type.(*ast.FuncType); ok && mtpe.Params.NumFields() == 0 && mtpe.Results.NumFields() == 1 {
+			gnm := fld.Names[0].Name
+			nm := gnm
+			if fld.Doc != nil {
+				for _, cmt := range fld.Doc.List {
+					for _, ln := range strings.Split(cmt.Text, "\n") {
+						matches := rxName.FindStringSubmatch(ln)
+						ml := len(matches)
+						if ml > 1 {
+							nm = matches[ml-1]
 						}
 					}
 				}
+			}
 
-				ps := schema.Properties[nm]
-				if err := parseProperty(scp, gofile, fld.Type, schemaTypable{&ps, 0}); err != nil {
-					return err
-				}
+			ps := schema.Properties[nm]
+			if err := parseProperty(scp, gofile, mtpe.Results.List[0].Type, schemaTypable{&ps, 0}); err != nil {
+				return err
+			}
 
-				sp := new(sectionedParser)
-				sp.setDescription = func(lines []string) { ps.Description = joinDropLast(lines) }
-				if ps.Ref.String() == "" {
-					sp.taggers = []tagParser{
-						newSingleLineTagParser("maximum", &setMaximum{schemaValidations{&ps}, rxf(rxMaximumFmt, "")}),
-						newSingleLineTagParser("minimum", &setMinimum{schemaValidations{&ps}, rxf(rxMinimumFmt, "")}),
-						newSingleLineTagParser("multipleOf", &setMultipleOf{schemaValidations{&ps}, rxf(rxMultipleOfFmt, "")}),
-						newSingleLineTagParser("minLength", &setMinLength{schemaValidations{&ps}, rxf(rxMinLengthFmt, "")}),
-						newSingleLineTagParser("maxLength", &setMaxLength{schemaValidations{&ps}, rxf(rxMaxLengthFmt, "")}),
-						newSingleLineTagParser("pattern", &setPattern{schemaValidations{&ps}, rxf(rxPatternFmt, "")}),
-						newSingleLineTagParser("minItems", &setMinItems{schemaValidations{&ps}, rxf(rxMinItemsFmt, "")}),
-						newSingleLineTagParser("maxItems", &setMaxItems{schemaValidations{&ps}, rxf(rxMaxItemsFmt, "")}),
-						newSingleLineTagParser("unique", &setUnique{schemaValidations{&ps}, rxf(rxUniqueFmt, "")}),
-						newSingleLineTagParser("required", &setRequiredSchema{schema, nm}),
-						newSingleLineTagParser("readOnly", &setReadOnlySchema{&ps}),
-					}
+			if err := scp.createParser(nm, schema, &ps, fld).Parse(fld.Doc); err != nil {
+				return err
+			}
 
-					itemsTaggers := func(items *spec.Schema, level int) []tagParser {
-						// the expression is 1-index based not 0-index
-						itemsPrefix := fmt.Sprintf(rxItemsPrefixFmt, level+1)
-						return []tagParser{
-							newSingleLineTagParser(fmt.Sprintf("items%dMaximum", level), &setMaximum{schemaValidations{items}, rxf(rxMaximumFmt, itemsPrefix)}),
-							newSingleLineTagParser(fmt.Sprintf("items%dMinimum", level), &setMinimum{schemaValidations{items}, rxf(rxMinimumFmt, itemsPrefix)}),
-							newSingleLineTagParser(fmt.Sprintf("items%dMultipleOf", level), &setMultipleOf{schemaValidations{items}, rxf(rxMultipleOfFmt, itemsPrefix)}),
-							newSingleLineTagParser(fmt.Sprintf("items%dMinLength", level), &setMinLength{schemaValidations{items}, rxf(rxMinLengthFmt, itemsPrefix)}),
-							newSingleLineTagParser(fmt.Sprintf("items%dMaxLength", level), &setMaxLength{schemaValidations{items}, rxf(rxMaxLengthFmt, itemsPrefix)}),
-							newSingleLineTagParser(fmt.Sprintf("items%dPattern", level), &setPattern{schemaValidations{items}, rxf(rxPatternFmt, itemsPrefix)}),
-							newSingleLineTagParser(fmt.Sprintf("items%dMinItems", level), &setMinItems{schemaValidations{items}, rxf(rxMinItemsFmt, itemsPrefix)}),
-							newSingleLineTagParser(fmt.Sprintf("items%dMaxItems", level), &setMaxItems{schemaValidations{items}, rxf(rxMaxItemsFmt, itemsPrefix)}),
-							newSingleLineTagParser(fmt.Sprintf("items%dUnique", level), &setUnique{schemaValidations{items}, rxf(rxUniqueFmt, itemsPrefix)}),
-						}
+			if nm != gnm {
+				ps.AddExtension("x-go-name", gnm)
+			}
+			seenProperties[nm] = struct{}{}
+			schema.Properties[nm] = ps
+		}
 
-					}
-					// check if this is a primitive, if so parse the validations from the
-					// doc comments of the slice declaration.
-					if ftped, ok := fld.Type.(*ast.ArrayType); ok {
-						ftpe := ftped
-						items, level := ps.Items, 0
-						for items != nil && items.Schema != nil {
-							switch iftpe := ftpe.Elt.(type) {
-							case *ast.ArrayType:
-								eleTaggers := itemsTaggers(items.Schema, level)
-								sp.taggers = append(eleTaggers, sp.taggers...)
-								ftpe = iftpe
-							case *ast.Ident:
-								if iftpe.Obj == nil {
-									sp.taggers = append(itemsTaggers(items.Schema, level), sp.taggers...)
+	}
+	if schema != nil && hasAllOf {
+		bschema.AllOf = append(bschema.AllOf, *schema)
+	}
+	for k := range schema.Properties {
+		if _, ok := seenProperties[k]; !ok {
+			delete(schema.Properties, k)
+		}
+	}
+	return nil
+}
+
+func (scp *schemaParser) parseStructType(gofile *ast.File, bschema *spec.Schema, tpe *ast.StructType, seenPreviously map[string]struct{}) error {
+	if tpe.Fields == nil {
+		return nil
+	}
+	var schema *spec.Schema
+	seenProperties := seenPreviously
+	hasAllOf := false
+
+	for _, fld := range tpe.Fields.List {
+		if len(fld.Names) == 0 {
+			// if this created an allOf property then we have to rejig the schema var
+			// because all the fields collected that aren't from embedded structs should go in
+			// their own proper schema
+			// first process embedded structs in order of embedding
+			if allOfMember(fld.Doc) {
+				hasAllOf = true
+				if schema == nil {
+					schema = new(spec.Schema)
+				}
+				var newSch spec.Schema
+				// when the embedded struct is annotated with swagger:allOf it will be used as allOf property
+				// otherwise the fields will just be included as normal properties
+				if err := scp.parseAllOfMember(gofile, &newSch, fld.Type, seenProperties); err != nil {
+					return err
+				}
+
+				if fld.Doc != nil {
+					for _, cmt := range fld.Doc.List {
+						for _, ln := range strings.Split(cmt.Text, "\n") {
+							matches := rxAllOf.FindStringSubmatch(ln)
+							ml := len(matches)
+							if ml > 1 {
+								mv := matches[ml-1]
+								if mv != "" {
+									bschema.AddExtension("x-class", mv)
 								}
-								break
-								//default:
-								//return fmt.Errorf("unknown field type (%T) ele for %q", iftpe, nm)
 							}
-							items = items.Schema.Items
-							level = level + 1
 						}
 					}
-				} else {
-					sp.taggers = []tagParser{
-						newSingleLineTagParser("required", &setRequiredSchema{schema, nm}),
-					}
 				}
-				if err := sp.Parse(fld.Doc); err != nil {
+
+				bschema.AllOf = append(bschema.AllOf, newSch)
+				continue
+			}
+			if schema == nil {
+				schema = bschema
+			}
+
+			// when the embedded struct is annotated with swagger:allOf it will be used as allOf property
+			// otherwise the fields will just be included as normal properties
+			if err := scp.parseEmbeddedType(gofile, schema, fld.Type, seenProperties); err != nil {
+				return err
+			}
+		}
+	}
+	if schema == nil {
+		schema = bschema
+	}
+
+	// then add and possibly override values
+	if schema.Properties == nil {
+		schema.Properties = make(map[string]spec.Schema)
+	}
+	schema.Typed("object", "")
+	for _, fld := range tpe.Fields.List {
+		var tag string
+		if fld.Tag != nil {
+			val, err := strconv.Unquote(fld.Tag.Value)
+			if err == nil {
+				tag = reflect.StructTag(val).Get("json")
+			}
+		}
+		if len(fld.Names) > 0 && fld.Names[0] != nil && fld.Names[0].IsExported() && (tag == "" || tag[0] != '-') {
+			var nm, gnm string
+			nm = fld.Names[0].Name
+			gnm = nm
+			if fld.Tag != nil && len(strings.TrimSpace(fld.Tag.Value)) > 0 /*&& fld.Tag.Value[0] != '-'*/ {
+				tv, err := strconv.Unquote(fld.Tag.Value)
+				if err != nil {
 					return err
 				}
 
-				if nm != gnm {
-					ps.AddExtension("x-go-name", gnm)
+				if strings.TrimSpace(tv) != "" {
+					st := reflect.StructTag(tv)
+					if st.Get("json") != "" {
+						nm = strings.Split(st.Get("json"), ",")[0]
+					}
 				}
-				seenProperties[nm] = struct{}{}
-				schema.Properties[nm] = ps
 			}
-		}
-		for k := range schema.Properties {
-			if _, ok := seenProperties[k]; !ok {
-				delete(schema.Properties, k)
+
+			ps := schema.Properties[nm]
+			if err := parseProperty(scp, gofile, fld.Type, schemaTypable{&ps, 0}); err != nil {
+				return err
+			}
+
+			if err := scp.createParser(nm, schema, &ps, fld).Parse(fld.Doc); err != nil {
+				return err
+			}
+
+			if nm != gnm {
+				ps.AddExtension("x-go-name", gnm)
 			}
+			seenProperties[nm] = struct{}{}
+			schema.Properties[nm] = ps
+		}
+	}
+	if schema != nil && hasAllOf {
+		bschema.AllOf = append(bschema.AllOf, *schema)
+	}
+	for k := range schema.Properties {
+		if _, ok := seenProperties[k]; !ok {
+			delete(schema.Properties, k)
 		}
 	}
 	return nil
 }
 
+func (scp *schemaParser) createParser(nm string, schema, ps *spec.Schema, fld *ast.Field) *sectionedParser {
+
+	sp := new(sectionedParser)
+	sp.setDescription = func(lines []string) { ps.Description = joinDropLast(lines) }
+	if ps.Ref.String() == "" {
+		sp.taggers = []tagParser{
+			newSingleLineTagParser("maximum", &setMaximum{schemaValidations{ps}, rxf(rxMaximumFmt, "")}),
+			newSingleLineTagParser("minimum", &setMinimum{schemaValidations{ps}, rxf(rxMinimumFmt, "")}),
+			newSingleLineTagParser("multipleOf", &setMultipleOf{schemaValidations{ps}, rxf(rxMultipleOfFmt, "")}),
+			newSingleLineTagParser("minLength", &setMinLength{schemaValidations{ps}, rxf(rxMinLengthFmt, "")}),
+			newSingleLineTagParser("maxLength", &setMaxLength{schemaValidations{ps}, rxf(rxMaxLengthFmt, "")}),
+			newSingleLineTagParser("pattern", &setPattern{schemaValidations{ps}, rxf(rxPatternFmt, "")}),
+			newSingleLineTagParser("minItems", &setMinItems{schemaValidations{ps}, rxf(rxMinItemsFmt, "")}),
+			newSingleLineTagParser("maxItems", &setMaxItems{schemaValidations{ps}, rxf(rxMaxItemsFmt, "")}),
+			newSingleLineTagParser("unique", &setUnique{schemaValidations{ps}, rxf(rxUniqueFmt, "")}),
+			newSingleLineTagParser("required", &setRequiredSchema{schema, nm}),
+			newSingleLineTagParser("readOnly", &setReadOnlySchema{ps}),
+			newSingleLineTagParser("discriminator", &setDiscriminator{schema, nm}),
+		}
+
+		itemsTaggers := func(items *spec.Schema, level int) []tagParser {
+			// the expression is 1-index based not 0-index
+			itemsPrefix := fmt.Sprintf(rxItemsPrefixFmt, level+1)
+			return []tagParser{
+				newSingleLineTagParser(fmt.Sprintf("items%dMaximum", level), &setMaximum{schemaValidations{items}, rxf(rxMaximumFmt, itemsPrefix)}),
+				newSingleLineTagParser(fmt.Sprintf("items%dMinimum", level), &setMinimum{schemaValidations{items}, rxf(rxMinimumFmt, itemsPrefix)}),
+				newSingleLineTagParser(fmt.Sprintf("items%dMultipleOf", level), &setMultipleOf{schemaValidations{items}, rxf(rxMultipleOfFmt, itemsPrefix)}),
+				newSingleLineTagParser(fmt.Sprintf("items%dMinLength", level), &setMinLength{schemaValidations{items}, rxf(rxMinLengthFmt, itemsPrefix)}),
+				newSingleLineTagParser(fmt.Sprintf("items%dMaxLength", level), &setMaxLength{schemaValidations{items}, rxf(rxMaxLengthFmt, itemsPrefix)}),
+				newSingleLineTagParser(fmt.Sprintf("items%dPattern", level), &setPattern{schemaValidations{items}, rxf(rxPatternFmt, itemsPrefix)}),
+				newSingleLineTagParser(fmt.Sprintf("items%dMinItems", level), &setMinItems{schemaValidations{items}, rxf(rxMinItemsFmt, itemsPrefix)}),
+				newSingleLineTagParser(fmt.Sprintf("items%dMaxItems", level), &setMaxItems{schemaValidations{items}, rxf(rxMaxItemsFmt, itemsPrefix)}),
+				newSingleLineTagParser(fmt.Sprintf("items%dUnique", level), &setUnique{schemaValidations{items}, rxf(rxUniqueFmt, itemsPrefix)}),
+			}
+
+		}
+		// check if this is a primitive, if so parse the validations from the
+		// doc comments of the slice declaration.
+		if ftped, ok := fld.Type.(*ast.ArrayType); ok {
+			ftpe := ftped
+			items, level := ps.Items, 0
+			for items != nil && items.Schema != nil {
+				switch iftpe := ftpe.Elt.(type) {
+				case *ast.ArrayType:
+					eleTaggers := itemsTaggers(items.Schema, level)
+					sp.taggers = append(eleTaggers, sp.taggers...)
+					ftpe = iftpe
+				case *ast.Ident:
+					if iftpe.Obj == nil {
+						sp.taggers = append(itemsTaggers(items.Schema, level), sp.taggers...)
+					}
+					break
+					//default:
+					//return fmt.Errorf("unknown field type (%T) ele for %q", iftpe, nm)
+				}
+				items = items.Schema.Items
+				level = level + 1
+			}
+		}
+	} else {
+		sp.taggers = []tagParser{
+			newSingleLineTagParser("required", &setRequiredSchema{schema, nm}),
+		}
+	}
+	return sp
+}
+
 func (scp *schemaParser) packageForFile(gofile *ast.File) (*loader.PackageInfo, error) {
 	for pkg, pkgInfo := range scp.program.AllPackages {
 		if pkg.Name() == gofile.Name.Name {
diff --git a/scan/schema_test.go b/scan/schema_test.go
index 0c223e7c..7e1464a1 100644
--- a/scan/schema_test.go
+++ b/scan/schema_test.go
@@ -414,3 +414,71 @@ func TestInterfaceField(t *testing.T) {
 	schema := noModelDefs["Interfaced"]
 	assertProperty(t, &schema, "object", "custom_data", "", "CustomData")
 }
+
+func TestStructDiscriminators(t *testing.T) {
+	_ = classificationProg
+	schema := noModelDefs["animal"]
+
+	assert.Equal(t, "BaseStruct", schema.Extensions["x-go-name"])
+	assert.Equal(t, schema.Discriminator, "jsonClass")
+
+	sch := noModelDefs["gazelle"]
+	assert.Len(t, sch.AllOf, 2)
+	cl, _ := sch.Extensions.GetString("x-class")
+	assert.Equal(t, "a.b.c.d.E", cl)
+	cl, _ = sch.Extensions.GetString("x-go-name")
+	assert.Equal(t, "Gazelle", cl)
+
+	sch = noModelDefs["giraffe"]
+	assert.Len(t, sch.AllOf, 2)
+	cl, _ = sch.Extensions.GetString("x-class")
+	assert.Equal(t, "", cl)
+	cl, _ = sch.Extensions.GetString("x-go-name")
+	assert.Equal(t, "Giraffe", cl)
+
+	//sch = noModelDefs["lion"]
+
+	//b, _ := json.MarshalIndent(sch, "", "  ")
+	//fmt.Println(string(b))
+
+}
+
+func TestInterfaceDiscriminators(t *testing.T) {
+	_ = classificationProg
+	schema, ok := noModelDefs["fish"]
+	if assert.True(t, ok) && assert.Len(t, schema.AllOf, 5) {
+		sch := schema.AllOf[0]
+		assert.Len(t, sch.Properties, 1)
+		assertProperty(t, &sch, "integer", "id", "int64", "ID")
+
+		sch = schema.AllOf[1]
+		assert.Equal(t, "#/definitions/water", sch.Ref.String())
+		sch = schema.AllOf[2]
+		assert.Equal(t, "#/definitions/extra", sch.Ref.String())
+
+		sch = schema.AllOf[3]
+		assert.Len(t, sch.Properties, 1)
+		assertProperty(t, &sch, "string", "colorName", "", "ColorName")
+
+		sch = schema.AllOf[4]
+		assert.Len(t, sch.Properties, 2)
+		assertProperty(t, &sch, "string", "name", "", "Name")
+		assertProperty(t, &sch, "string", "jsonClass", "", "StructType")
+		assert.Equal(t, "jsonClass", sch.Discriminator)
+	}
+
+	schema, ok = noModelDefs["modelS"]
+	if assert.True(t, ok) {
+		assert.Len(t, schema.AllOf, 2)
+		cl, _ := schema.Extensions.GetString("x-class")
+		assert.Equal(t, "com.tesla.models.ModelS", cl)
+		cl, _ = schema.Extensions.GetString("x-go-name")
+		assert.Equal(t, "ModelS", cl)
+
+		sch := schema.AllOf[0]
+		assert.Equal(t, "#/definitions/TeslaCar", sch.Ref.String())
+		sch = schema.AllOf[1]
+		assert.Len(t, sch.Properties, 1)
+		assertProperty(t, &sch, "string", "edition", "", "Edition")
+	}
+}
diff --git a/scan/validators.go b/scan/validators.go
index ba30406d..0fb8fcb6 100644
--- a/scan/validators.go
+++ b/scan/validators.go
@@ -333,6 +333,36 @@ func (su *setReadOnlySchema) Parse(lines []string) error {
 	return nil
 }
 
+type setDiscriminator struct {
+	schema *spec.Schema
+	field  string
+}
+
+func (su *setDiscriminator) Matches(line string) bool {
+	return rxDiscriminator.MatchString(line)
+}
+
+func (su *setDiscriminator) Parse(lines []string) error {
+	if len(lines) == 0 || (len(lines) == 1 && len(lines[0]) == 0) {
+		return nil
+	}
+	matches := rxDiscriminator.FindStringSubmatch(lines[0])
+	if len(matches) > 1 && len(matches[1]) > 0 {
+		req, err := strconv.ParseBool(matches[1])
+		if err != nil {
+			return err
+		}
+		if req {
+			su.schema.Discriminator = su.field
+		} else {
+			if su.schema.Discriminator == su.field {
+				su.schema.Discriminator = ""
+			}
+		}
+	}
+	return nil
+}
+
 type setRequiredSchema struct {
 	schema *spec.Schema
 	field  string
@@ -472,7 +502,7 @@ func (ss *setSecurityDefinitions) Parse(lines []string) error {
 	return nil
 }
 
-func newSetResponses2(definitions map[string]spec.Schema, responses map[string]spec.Response, setter func(*spec.Response, map[int]spec.Response)) *setOpResponses {
+func newSetResponses(definitions map[string]spec.Schema, responses map[string]spec.Response, setter func(*spec.Response, map[int]spec.Response)) *setOpResponses {
 	return &setOpResponses{
 		set:         setter,
 		rx:          rxResponses,
@@ -480,12 +510,6 @@ func newSetResponses2(definitions map[string]spec.Schema, responses map[string]s
 		responses:   responses,
 	}
 }
-func newSetResponses(setter func(*spec.Response, map[int]spec.Response)) *setOpResponses {
-	return &setOpResponses{
-		set: setter,
-		rx:  rxResponses,
-	}
-}
 
 type setOpResponses struct {
 	set         func(*spec.Response, map[int]spec.Response)
