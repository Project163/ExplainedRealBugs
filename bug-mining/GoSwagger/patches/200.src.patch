diff --git a/cmd/swagger/commands/generate/client.go b/cmd/swagger/commands/generate/client.go
index 0e5f33c0..3b68cca6 100644
--- a/cmd/swagger/commands/generate/client.go
+++ b/cmd/swagger/commands/generate/client.go
@@ -15,9 +15,8 @@
 package generate
 
 import (
-	"fmt"
 	"io/ioutil"
-	"os"
+	"log"
 	"path/filepath"
 
 	"github.com/go-swagger/go-swagger/generator"
@@ -119,7 +118,7 @@ func (c *Client) Execute(args []string) error {
 		return err
 	}
 
-	fmt.Fprintf(os.Stdout, `Generation completed!
+	log.Printf(`Generation completed!
 
 For this generation to compile you need to have some packages in your GOPATH:
 
diff --git a/cmd/swagger/commands/generate/operation.go b/cmd/swagger/commands/generate/operation.go
index b3898176..4685b863 100644
--- a/cmd/swagger/commands/generate/operation.go
+++ b/cmd/swagger/commands/generate/operation.go
@@ -16,8 +16,7 @@ package generate
 
 import (
 	"errors"
-	"fmt"
-	"os"
+	"log"
 	"path/filepath"
 
 	"github.com/go-swagger/go-swagger/generator"
@@ -100,7 +99,7 @@ func (o *Operation) Execute(args []string) error {
 		return err
 	}
 
-	fmt.Fprintf(os.Stdout, `Generation completed!
+	log.Printf(`Generation completed!
 
 For this generation to compile you need to have some packages in your GOPATH:
 
diff --git a/cmd/swagger/commands/generate/server.go b/cmd/swagger/commands/generate/server.go
index 2cb4c264..77c68e98 100644
--- a/cmd/swagger/commands/generate/server.go
+++ b/cmd/swagger/commands/generate/server.go
@@ -15,9 +15,8 @@
 package generate
 
 import (
-	"fmt"
 	"io/ioutil"
-	"os"
+	"log"
 	"path/filepath"
 	"strings"
 
@@ -55,7 +54,7 @@ func (s *Server) Execute(args []string) error {
 	setDebug(cfg)
 
 	if s.WithContext {
-		fmt.Fprintf(os.Stdout, "--with-context is deprecated because recent go versions now include the context on the request object to which you have access on the params.HTTPRequest property")
+		log.Printf("--with-context is deprecated because recent go versions now include the context on the request object to which you have access on the params.HTTPRequest property")
 	}
 
 	if s.ExistingModels != "" {
@@ -139,7 +138,7 @@ func (s *Server) Execute(args []string) error {
 		flagsPackage = "github.com/spf13/pflag"
 	}
 
-	fmt.Fprintf(os.Stdout, `Generation completed!
+	log.Printf(`Generation completed!
 
 For this generation to compile you need to have some packages in your GOPATH:
 
diff --git a/cmd/swagger/commands/generate/support.go b/cmd/swagger/commands/generate/support.go
index d517ff64..a40273be 100644
--- a/cmd/swagger/commands/generate/support.go
+++ b/cmd/swagger/commands/generate/support.go
@@ -15,8 +15,7 @@
 package generate
 
 import (
-	"fmt"
-	"os"
+	"log"
 	"path/filepath"
 
 	"github.com/go-swagger/go-swagger/generator"
@@ -67,7 +66,7 @@ func (s *Support) Execute(args []string) error {
 		return err
 	}
 
-	fmt.Fprintf(os.Stdout, `Generation completed!
+	log.Printf(`Generation completed!
 
 For this generation to compile you need to have some packages in your vendor or GOPATH:
 
diff --git a/generator/model.go b/generator/model.go
index 5c6da384..4aea3260 100644
--- a/generator/model.go
+++ b/generator/model.go
@@ -281,7 +281,8 @@ func makeGenDefinitionHierarchy(name, pkg, container string, schema spec.Schema,
 
 	return &GenDefinition{
 		GenCommon: GenCommon{
-			Copyright: opts.Copyright,
+			Copyright:        opts.Copyright,
+			TargetImportPath: filepath.ToSlash(baseImport(opts.Target)),
 		},
 		Package:        opts.LanguageOpts.MangleName(filepath.Base(pkg), "definitions"),
 		GenSchema:      pg.GenSchema,
diff --git a/generator/operation.go b/generator/operation.go
index 7b286335..f825d4b5 100644
--- a/generator/operation.go
+++ b/generator/operation.go
@@ -464,7 +464,8 @@ func (b *codeGenOpBuilder) MakeOperation() (GenOperation, error) {
 	}
 	return GenOperation{
 		GenCommon: GenCommon{
-			Copyright: b.GenOpts.Copyright,
+			Copyright:        b.GenOpts.Copyright,
+			TargetImportPath: filepath.ToSlash(baseImport(b.GenOpts.Target)),
 		},
 		Package:              b.APIPackage,
 		RootPackage:          b.RootAPIPackage,
diff --git a/generator/structs.go b/generator/structs.go
index fb724cfd..fa484ece 100644
--- a/generator/structs.go
+++ b/generator/structs.go
@@ -14,8 +14,12 @@ import (
 
 // GenCommon contains common properties needed across
 // definitions, app and operations
+// TargetImportPath may be used by templates to import other (possibly
+// generated) packages in the generation path (e.g. relative to GOPATH).
+// TargetImportPath is NOT used by standard templates.
 type GenCommon struct {
-	Copyright string
+	Copyright        string
+	TargetImportPath string
 }
 
 // GenDefinition contains all the properties to generate a
diff --git a/generator/support.go b/generator/support.go
index 4e823e23..e86da0a4 100644
--- a/generator/support.go
+++ b/generator/support.go
@@ -170,11 +170,16 @@ func checkPrefixAndFetchRelativePath(childpath string, parentpath string) (bool,
 
 }
 
-// TODO: handle error with a returned error rather than panic()
 func baseImport(tgt string) string {
+	// On Windows, filepath.Abs("") behaves differently than on Unix.
+	// Windows: yields an error, since Abs() does not know the volume.
+	// UNIX: returns current working directory
+	if tgt == "" {
+		tgt = "."
+	}
 	tgtAbsPath, err := filepath.Abs(tgt)
 	if err != nil {
-		log.Fatalf("could not evaluate base import path with target \"%s\". Target directory must be created beforehand: %v", tgt, err)
+		log.Fatalf("could not evaluate base import path with target \"%s\": %v", tgt, err)
 	}
 	var tgtAbsPathExtended string
 	tgtAbsPathExtended, err = filepath.EvalSymlinks(tgtAbsPath)
@@ -685,7 +690,8 @@ func (a *appGenerator) makeCodegenApp() (GenApp, error) {
 		sort.Sort(v)
 		opGroup := GenOperationGroup{
 			GenCommon: GenCommon{
-				Copyright: a.GenOpts.Copyright,
+				Copyright:        a.GenOpts.Copyright,
+				TargetImportPath: filepath.ToSlash(baseImport(a.Target)),
 			},
 			Name:           k,
 			Operations:     v,
@@ -727,7 +733,8 @@ func (a *appGenerator) makeCodegenApp() (GenApp, error) {
 
 	return GenApp{
 		GenCommon: GenCommon{
-			Copyright: a.GenOpts.Copyright,
+			Copyright:        a.GenOpts.Copyright,
+			TargetImportPath: filepath.ToSlash(baseImport(a.Target)),
 		},
 		APIPackage:          a.ServerPackage,
 		Package:             a.Package,
diff --git a/generator/template_repo_test.go b/generator/template_repo_test.go
index 795b0dde..31033fad 100644
--- a/generator/template_repo_test.go
+++ b/generator/template_repo_test.go
@@ -2,9 +2,12 @@ package generator
 
 import (
 	"bytes"
-	"testing"
-
+	"github.com/go-openapi/loads"
 	"github.com/stretchr/testify/assert"
+	"testing"
+        "os"
+        "io/ioutil"
+        "log"
 )
 
 var (
@@ -17,6 +20,9 @@ var (
 	customMultiple        = `{{define "bindprimitiveparam" }}custom primitive{{end}}`
 	customNewTemplate     = `new template`
 	customExistingUsesNew = `{{define "bindprimitiveparam" }}{{ template "newtemplate" }}{{end}}`
+	// Test template environment
+	copyright        = `{{ .Copyright }}`
+	targetImportPath = `{{ .TargetImportPath }}`
 )
 
 func TestCustomTemplates(t *testing.T) {
@@ -209,3 +215,126 @@ func TestRepoRecursiveTemplates(t *testing.T) {
 
 	assert.Equal(t, expected, b.String())
 }
+
+// Test that definitions are available to templates
+// TODO: should test also with the codeGenApp context
+
+// Test copyright definition
+func TestDefinitionCopyright(t *testing.T) {
+        log.SetOutput(os.Stdout)
+
+	repo := NewRepository(nil)
+
+	err := repo.AddFile("copyright", copyright)
+	assert.NoError(t, err)
+
+	templ, err := repo.Get("copyright")
+	assert.Nil(t, err)
+
+	opts := opts()
+	opts.Copyright = "My copyright clause"
+	expected := opts.Copyright
+
+	// executes template against model definitions
+	genModel, err := getModelEnvironment("../fixtures/codegen/todolist.models.yml", opts)
+	assert.Nil(t, err)
+
+	rendered := bytes.NewBuffer(nil)
+	err = templ.Execute(rendered, genModel)
+	assert.Nil(t, err)
+
+	assert.Equal(t, expected, rendered.String())
+
+	// executes template against operations definitions
+	genOperation, err := getOperationEnvironment("get", "/media/search", "../fixtures/codegen/instagram.yml", opts)
+	assert.Nil(t, err)
+
+	rendered.Reset()
+
+	err = templ.Execute(rendered, genOperation)
+	assert.Nil(t, err)
+
+	assert.Equal(t, expected, rendered.String())
+
+}
+
+// Test TargetImportPath definition
+func TestDefinitionTargetImportPath(t *testing.T) {
+        log.SetOutput(os.Stdout)
+
+	repo := NewRepository(nil)
+
+	err := repo.AddFile("targetimportpath", targetImportPath)
+	assert.NoError(t, err)
+
+	templ, err := repo.Get("targetimportpath")
+	assert.Nil(t, err)
+
+	opts := opts()
+	// Non existing target would panic: to be tested too, but in another module
+	opts.Target = "../fixtures"
+	var expected = "github.com/go-swagger/go-swagger/fixtures"
+
+	// executes template against model definitions
+	genModel, err := getModelEnvironment("../fixtures/codegen/todolist.models.yml", opts)
+	assert.Nil(t, err)
+
+	rendered := bytes.NewBuffer(nil)
+	err = templ.Execute(rendered, genModel)
+	assert.Nil(t, err)
+
+	assert.Equal(t, expected, rendered.String())
+
+	// executes template against operations definitions
+	genOperation, err := getOperationEnvironment("get", "/media/search", "../fixtures/codegen/instagram.yml", opts)
+	assert.Nil(t, err)
+
+	rendered.Reset()
+
+	err = templ.Execute(rendered, genOperation)
+	assert.Nil(t, err)
+
+	assert.Equal(t, expected, rendered.String())
+
+}
+
+// Simulates a definition environment for model templates
+func getModelEnvironment(spec string, opts *GenOpts) (*GenDefinition, error) {
+        // Don't want stderr output to pollute CI
+        log.SetOutput(ioutil.Discard)
+        defer log.SetOutput(os.Stdout)
+
+	specDoc, err := loads.Spec("../fixtures/codegen/todolist.models.yml")
+	if err != nil {
+		return nil, err
+	}
+	definitions := specDoc.Spec().Definitions
+
+	for k, schema := range definitions {
+		genModel, err := makeGenDefinition(k, "models", schema, specDoc, opts)
+		if err != nil {
+			return nil, err
+		}
+		// One is enough
+		return genModel, nil
+	}
+	return nil, nil
+}
+
+// Simulates a definition environment for operation templates
+func getOperationEnvironment(operation string, path string, spec string, opts *GenOpts) (*GenOperation, error) {
+        // Don't want stderr output to pollute CI
+        log.SetOutput(ioutil.Discard)
+        defer log.SetOutput(os.Stdout)
+
+	b, err := methodPathOpBuilder(operation, path, spec)
+	if err != nil {
+		return nil, err
+	}
+	b.GenOpts = opts
+	g, err := b.MakeOperation()
+	if err != nil {
+		return nil, err
+	}
+	return &g, nil
+}
