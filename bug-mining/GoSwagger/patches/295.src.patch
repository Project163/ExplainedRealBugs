diff --git a/fixtures/enhancements/1771/.gitignore b/fixtures/enhancements/1771/.gitignore
new file mode 100644
index 00000000..1e16265b
--- /dev/null
+++ b/fixtures/enhancements/1771/.gitignore
@@ -0,0 +1,3 @@
+gen-*
+!gen-fixtures.sh
+*.log
diff --git a/fixtures/enhancements/1771/fixture-1771.yaml b/fixtures/enhancements/1771/fixture-1771.yaml
new file mode 100644
index 00000000..5d7861d1
--- /dev/null
+++ b/fixtures/enhancements/1771/fixture-1771.yaml
@@ -0,0 +1,76 @@
+---
+  swagger: "2.0"
+  info:
+    title: "invalid slice validations in simple parameters"
+    version: "0.0.1"
+    description: "repro issue 1771"
+    license:
+      name: "Apache 2.0"
+      url: "http://www.apache.org/licenses/LICENSE-2.0.html"
+  paths:
+    /getRecords:
+      get:
+        summary: retrieves a batch of key data
+        parameters:
+        - name: keys
+          description: a list of keys to retrieve data for
+          in: query
+          type: array
+          required: true
+          items:
+            minItems: 1
+            maxItems: 10
+            type: string
+          collectionFormat: multi
+        - name: fault1
+          in: query
+          type: string
+          minimum: 12
+          exclusiveMinimum: true
+          maximum: 15
+          exclusiveMaximum: true
+          multipleOf: 2
+          minLength: 10
+        - name: fault2
+          in: query
+          type: number
+          minLength: 1
+          pattern: "abc"
+          maxLength: 15
+          uniqueItems: true
+          maximum: 20
+        - name: fault3
+          in: query
+          type: integer
+          minLength: 1
+          pattern: "abc"
+          maxLength: 15
+          uniqueItems: true
+          maximum: 20
+        - name: fault4
+          in: query
+          type: boolean
+          minLength: 1
+          pattern: "abc"
+          maxLength: 15
+          uniqueItems: true
+          maximum: 20
+        responses:
+          200:
+            description: "OK"
+
+    /getFiles:
+      get:
+        consumes: [ multipart/form-data ]
+        parameters:
+        - name: upload
+          in: formData
+          type: file
+          minLength: 1
+          pattern: "abc"
+          maxLength: 15
+          uniqueItems: true
+          maximum: 20
+        responses:
+          200:
+            description: "OK"
diff --git a/fixtures/enhancements/1771/gen-fixtures.sh b/fixtures/enhancements/1771/gen-fixtures.sh
new file mode 100755
index 00000000..7431b760
--- /dev/null
+++ b/fixtures/enhancements/1771/gen-fixtures.sh
@@ -0,0 +1,74 @@
+#! /bin/bash
+if [[ ${1} == "--clean" ]] ; then
+    clean=1
+fi
+continueOnError=
+# A small utility to build fixture servers
+# Fixtures with models only
+testcases="fixture-1771.yaml"
+for opts in  "" ; do
+for testcase in ${testcases} ; do
+    grep -q discriminator ${testcase}
+    discriminated=$?
+    if [[ ${discriminated} -eq 0 && ${opts} == "--with-expand" ]] ; then
+        echo "Skipped ${testcase} with ${opts}: discriminator not supported with ${opts}"
+        continue
+    fi
+    if [[ ${testcase} == "../1479/fixture-1479-part.yaml" && ${opts} == "--with-expand" ]] ; then
+        echo "Skipped ${testcase} with ${opts}: known issue with enum in anonymous allOf not validated. See you next PR"
+        continue
+    fi
+
+    spec=${testcase}
+    testcase=`basename ${testcase}`
+    if [[ -z ${opts} ]]; then
+        target=./gen-${testcase%.*}-flatten
+    else
+        target=./gen-${testcase%.*}-expand
+    fi
+    serverName="codegensrv"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Model generation for ${spec} with opts=${opts}"
+    serverName="nrcodegen"
+    swagger generate server --skip-validation ${opts} --spec ${spec} --target ${target} --name=${serverName} 1>${testcase%.*}.log 2>&1
+    # 1>x.log 2>&1
+    #
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        if [[ ! -z ${continueOnError} ]] ; then
+            failures="${failures} codegen:${spec}"
+            continue
+        else
+            exit 1
+        fi
+    fi
+    echo "${spec}: Generation OK"
+    if [[ ! -d ${target}/models ]] ; then
+        echo "No model in this spec! Continue building server"
+    fi
+    if [[ -d ${target}/cmd/${serverName}"-server" ]] ; then
+        (cd ${target}/cmd/${serverName}"-server"; go build)
+        #(cd ${target}/models; go build)
+        if [[ $? != 0 ]] ; then
+            echo "Build failed for ${spec}"
+            if [[ ! -z ${continueOnError} ]] ; then
+                failures="${failures} build:${spec}"
+                continue
+            else
+                exit 1
+            fi
+        fi
+        echo "${spec}: Build OK"
+        if [[ -n ${clean} ]] ; then
+             rm -rf ${target}
+        fi
+    fi
+done
+done
+if [[ ! -z ${failures} ]] ; then
+    echo ${failures}|tr ' ' '\n'
+else
+    echo "No failures"
+fi
+exit
diff --git a/fixtures/enhancements/2163/.gitignore b/fixtures/enhancements/2163/.gitignore
new file mode 100644
index 00000000..1e16265b
--- /dev/null
+++ b/fixtures/enhancements/2163/.gitignore
@@ -0,0 +1,3 @@
+gen-*
+!gen-fixtures.sh
+*.log
diff --git a/fixtures/enhancements/2163/fixture-2163.yaml b/fixtures/enhancements/2163/fixture-2163.yaml
new file mode 100644
index 00000000..b7ea5404
--- /dev/null
+++ b/fixtures/enhancements/2163/fixture-2163.yaml
@@ -0,0 +1,83 @@
+---
+  swagger: "2.0"
+  info:
+    title: "validations inconsistent with schema type"
+    version: "0.0.1"
+    description: "inconsistent validations"
+    license:
+      name: "Apache 2.0"
+      url: "http://www.apache.org/licenses/LICENSE-2.0.html"
+  definitions:
+    obj:
+      type: object
+      properties:
+        a:
+          type: number
+          format: double
+          maximum: 1000000000
+          minimum: 1
+          pattern: "[-]?\\d+(.\\d{1,2})?"
+          maxLength: 13
+          minLength: 1
+        b:
+          type: string
+          minimum: 13
+          maxLength: 5
+        c:
+          type: string
+          maximum: 144
+          maxLength: 5
+          multipleOf: 12
+          enum: [ 'a', 'b' ]
+        d:
+          type: boolean
+          maximum: 15
+          exclusiveMaximum: true
+          minimum: 1
+          exclusiveMinimum: true
+          minProperties: 12
+        e:
+          type: object
+          maximum: 15
+          minProperties: 12
+          uniqueItems: true
+          enum: [ {"x": 1} ]
+        f:
+          type: array
+          uniqueItems: true
+          minimum: 15
+          items:
+            type: object
+            minProperties: 13
+            maximum: 15
+        g:
+          type: integer
+          maximum: 10
+          minimum: 1
+          pattern: "[-]?\\d+(.\\d{1,2})?"
+          maxLength: 13
+          minLength: 1
+          maxProperties: 12
+
+        #h:
+        #  type: file
+        #  maximum: 10
+        #  minimum: 1
+        #  pattern: "[-]?\\d+(.\\d{1,2})?"
+        #  maxLength: 13
+        #  minLength: 1
+        #  maxProperties: 12
+
+  paths:
+    /getRecords:
+      get:
+        operationId: getRecords
+        parameters:
+          - name: records
+            in: body
+            required: true
+            schema:
+              $ref: '#/definitions/obj'
+        responses:
+          200:
+            description: "OK"
diff --git a/fixtures/enhancements/2163/gen-fixtures.sh b/fixtures/enhancements/2163/gen-fixtures.sh
new file mode 100755
index 00000000..99299b6b
--- /dev/null
+++ b/fixtures/enhancements/2163/gen-fixtures.sh
@@ -0,0 +1,76 @@
+#! /bin/bash
+if [[ ${1} == "--clean" ]] ; then
+    clean=1
+fi
+continueOnError=
+# A small utility to build fixture servers
+# Fixtures with models only
+testcases="fixture-2163.yaml"
+#testcases="${testcases} ../1487/fixture-844-variations.yaml"
+#testcases="${testcases} ../1487/fixture-itching.yaml"
+for opts in  "" ; do
+for testcase in ${testcases} ; do
+    grep -q discriminator ${testcase}
+    discriminated=$?
+    if [[ ${discriminated} -eq 0 && ${opts} == "--with-expand" ]] ; then
+        echo "Skipped ${testcase} with ${opts}: discriminator not supported with ${opts}"
+        continue
+    fi
+    if [[ ${testcase} == "../1479/fixture-1479-part.yaml" && ${opts} == "--with-expand" ]] ; then
+        echo "Skipped ${testcase} with ${opts}: known issue with enum in anonymous allOf not validated. See you next PR"
+        continue
+    fi
+
+    spec=${testcase}
+    testcase=`basename ${testcase}`
+    if [[ -z ${opts} ]]; then
+        target=./gen-${testcase%.*}-flatten
+    else
+        target=./gen-${testcase%.*}-expand
+    fi
+    serverName="codegensrv"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Model generation for ${spec} with opts=${opts}"
+    serverName="nrcodegen"
+    swagger generate server --skip-validation ${opts} --spec ${spec} --target ${target} --name=${serverName} 1>${testcase%.*}.log 2>&1
+    # 1>x.log 2>&1
+    #
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        if [[ ! -z ${continueOnError} ]] ; then
+            failures="${failures} codegen:${spec}"
+            continue
+        else
+            exit 1
+        fi
+    fi
+    echo "${spec}: Generation OK"
+    if [[ ! -d ${target}/models ]] ; then
+        echo "No model in this spec! Continue building server"
+    fi
+    if [[ -d ${target}/cmd/${serverName}"-server" ]] ; then
+        (cd ${target}/cmd/${serverName}"-server"; go build)
+        #(cd ${target}/models; go build)
+        if [[ $? != 0 ]] ; then
+            echo "Build failed for ${spec}"
+            if [[ ! -z ${continueOnError} ]] ; then
+                failures="${failures} build:${spec}"
+                continue
+            else
+                exit 1
+            fi
+        fi
+        echo "${spec}: Build OK"
+        if [[ -n ${clean} ]] ; then
+             rm -rf ${target}
+        fi
+    fi
+done
+done
+if [[ ! -z ${failures} ]] ; then
+    echo ${failures}|tr ' ' '\n'
+else
+    echo "No failures"
+fi
+exit
diff --git a/generator/build_test.go b/generator/build_test.go
index 824578a6..768efa05 100644
--- a/generator/build_test.go
+++ b/generator/build_test.go
@@ -46,6 +46,12 @@ func TestGenerateAndBuild(t *testing.T) {
 		"issue 2278": {
 			"../fixtures/bugs/2278/fixture-2278.yaml",
 		},
+		"issue 2163": {
+			"../fixtures/enhancements/2163/fixture-2163.yaml",
+		},
+		"issue 1771": {
+			"../fixtures/enhancements/1771/fixture-1771.yaml",
+		},
 	}
 
 	for name, cas := range cases {
diff --git a/generator/operation.go b/generator/operation.go
index bc7b0666..f89920bc 100644
--- a/generator/operation.go
+++ b/generator/operation.go
@@ -587,7 +587,7 @@ func (b *codeGenOpBuilder) MakeHeader(receiver, name string, hdr spec.Header) (G
 
 	id := swag.ToGoName(name)
 	res := GenHeader{
-		sharedValidations: sharedValidationsFromSimple(hdr.CommonValidations, true), // NOTE: Required is not defined by the Swagger schema for header. Set arbitrarily to true for convenience in templates.
+		sharedValidations: sharedValidationsFromSimple(tpe, hdr.CommonValidations, true), // NOTE: Required is not defined by the Swagger schema for header. Set arbitrarily to true for convenience in templates.
 		resolvedType:      tpe,
 		Package:           b.GenOpts.LanguageOpts.ManglePackageName(b.APIPackage, defaultOperationsTarget),
 		ReceiverName:      receiver,
@@ -626,7 +626,7 @@ func (b *codeGenOpBuilder) MakeHeader(receiver, name string, hdr spec.Header) (G
 func (b *codeGenOpBuilder) MakeHeaderItem(receiver, paramName, indexVar, path, valueExpression string, items, parent *spec.Items) (GenItems, error) {
 	var res GenItems
 	res.resolvedType = simpleResolvedType(items.Type, items.Format, items.Items)
-	res.sharedValidations = sharedValidationsFromSimple(items.CommonValidations, false)
+	res.sharedValidations = sharedValidationsFromSimple(res.resolvedType, items.CommonValidations, false)
 	res.Name = paramName
 	res.Path = path
 	res.Location = "header"
@@ -656,6 +656,8 @@ func (b *codeGenOpBuilder) MakeHeaderItem(receiver, paramName, indexVar, path, v
 
 // HasValidations resolves the validation status for simple schema objects
 func (b *codeGenOpBuilder) HasValidations(sh spec.CommonValidations, rt resolvedType) (hasValidations bool, hasSliceValidations bool) {
+	guardSimpleValidations(rt.SwaggerType, &sh)
+
 	hasNumberValidation := sh.Maximum != nil || sh.Minimum != nil || sh.MultipleOf != nil
 	hasStringValidation := sh.MaxLength != nil || sh.MinLength != nil || sh.Pattern != ""
 	hasSliceValidations = sh.MaxItems != nil || sh.MinItems != nil || sh.UniqueItems || len(sh.Enum) > 0
@@ -667,7 +669,7 @@ func (b *codeGenOpBuilder) MakeParameterItem(receiver, paramName, indexVar, path
 	debugLog("making parameter item recv=%s param=%s index=%s valueExpr=%s path=%s location=%s", receiver, paramName, indexVar, valueExpression, path, location)
 	var res GenItems
 	res.resolvedType = simpleResolvedType(items.Type, items.Format, items.Items)
-	res.sharedValidations = sharedValidationsFromSimple(items.CommonValidations, false)
+	res.sharedValidations = sharedValidationsFromSimple(res.resolvedType, items.CommonValidations, false)
 	res.Name = paramName
 	res.Path = path
 	res.Location = location
@@ -742,7 +744,7 @@ func (b *codeGenOpBuilder) MakeParameter(receiver string, resolver *typeResolver
 	} else {
 		// Process parameters declared in other inputs: path, query, header (SimpleSchema)
 		res.resolvedType = simpleResolvedType(param.Type, param.Format, param.Items)
-		res.sharedValidations = sharedValidationsFromSimple(param.CommonValidations, param.Required)
+		res.sharedValidations = sharedValidationsFromSimple(res.resolvedType, param.CommonValidations, param.Required)
 
 		res.ZeroValue = res.resolvedType.Zero()
 
diff --git a/generator/shared.go b/generator/shared.go
index 9321bf00..0bd7da26 100644
--- a/generator/shared.go
+++ b/generator/shared.go
@@ -927,7 +927,9 @@ func gatherExtraSchemas(extraMap map[string]GenSchema) (extras GenSchemaList) {
 	return
 }
 
-func sharedValidationsFromSimple(v spec.CommonValidations, isRequired bool) (sh sharedValidations) {
+func sharedValidationsFromSimple(tpe resolvedType, v spec.CommonValidations, isRequired bool) (sh sharedValidations) {
+	guardSimpleValidations(tpe.SwaggerType, &v)
+
 	sh = sharedValidations{
 		Required:         isRequired,
 		Maximum:          v.Maximum,
@@ -947,6 +949,8 @@ func sharedValidationsFromSimple(v spec.CommonValidations, isRequired bool) (sh
 }
 
 func sharedValidationsFromSchema(v spec.Schema, isRequired bool) (sh sharedValidations) {
+	// validation guards have already been carried out directly by the type resolver
+
 	sh = sharedValidations{
 		Required:         isRequired,
 		Maximum:          v.Maximum,
diff --git a/generator/types.go b/generator/types.go
index 2b0956e7..f939cf5f 100644
--- a/generator/types.go
+++ b/generator/types.go
@@ -715,6 +715,8 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 	tpe := t.firstType(schema)
 	var returns bool
 
+	guardValidations(tpe, schema)
+
 	returns, result, err = t.resolveSchemaRef(schema, isRequired)
 
 	if returns {
@@ -796,9 +798,214 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 	default:
 		err = fmt.Errorf("unresolvable: %v (format %q)", schema.Type, schema.Format)
 	}
+
 	return
 }
 
+func warnSkipValidation(val string, types interface{}) {
+	log.Printf("warning: validation %q not compatible with type %v. Skipped", val, types)
+}
+
+func removeStringValidations(schema *spec.Schema) {
+	if schema.Pattern != "" {
+		schema.Pattern = ""
+		warnSkipValidation("pattern", schema.Type)
+	}
+	if schema.MinLength != nil {
+		schema.MinLength = nil
+		warnSkipValidation("minLength", schema.Type)
+	}
+	if schema.MaxLength != nil {
+		schema.MaxLength = nil
+		warnSkipValidation("maxLength", schema.Type)
+	}
+}
+
+func removeStringCommonValidations(tpe string, schema *spec.CommonValidations) {
+	if schema.Pattern != "" {
+		schema.Pattern = ""
+		warnSkipValidation("pattern", tpe)
+	}
+	if schema.MinLength != nil {
+		schema.MinLength = nil
+		warnSkipValidation("minLength", tpe)
+	}
+	if schema.MaxLength != nil {
+		schema.MaxLength = nil
+		warnSkipValidation("maxLength", tpe)
+	}
+}
+
+func removeNumberValidations(schema *spec.Schema) {
+	if schema.Minimum != nil {
+		schema.Minimum = nil
+		warnSkipValidation("minimum", schema.Type)
+	}
+	if schema.Maximum != nil {
+		schema.Maximum = nil
+		warnSkipValidation("maximum", schema.Type)
+	}
+	if schema.ExclusiveMaximum {
+		schema.ExclusiveMaximum = false
+		warnSkipValidation("exclusiveMaximum", schema.Type)
+	}
+	if schema.ExclusiveMinimum {
+		schema.ExclusiveMinimum = false
+		warnSkipValidation("exclusiveMinimum", schema.Type)
+	}
+	if schema.MultipleOf != nil {
+		schema.MultipleOf = nil
+		warnSkipValidation("multipleOf", schema.Type)
+	}
+}
+
+func removeNumberCommonValidations(tpe string, schema *spec.CommonValidations) {
+	if schema.Minimum != nil {
+		schema.Minimum = nil
+		warnSkipValidation("minimum", tpe)
+	}
+	if schema.Maximum != nil {
+		schema.Maximum = nil
+		warnSkipValidation("maximum", tpe)
+	}
+	if schema.ExclusiveMaximum {
+		schema.ExclusiveMaximum = false
+		warnSkipValidation("exclusiveMaximum", tpe)
+	}
+	if schema.ExclusiveMinimum {
+		schema.ExclusiveMinimum = false
+		warnSkipValidation("exclusiveMinimum", tpe)
+	}
+	if schema.MultipleOf != nil {
+		schema.MultipleOf = nil
+		warnSkipValidation("multipleOf", tpe)
+	}
+}
+
+func removeSliceValidations(schema *spec.Schema) {
+	if schema.MaxItems != nil {
+		schema.MaxItems = nil
+		warnSkipValidation("maxItems", schema.Type)
+	}
+	if schema.MinItems != nil {
+		schema.MinItems = nil
+		warnSkipValidation("minItems", schema.Type)
+	}
+	if schema.UniqueItems {
+		schema.UniqueItems = false
+		warnSkipValidation("uniqueItems", schema.Type)
+	}
+}
+
+func removeSliceCommonValidations(tpe string, schema *spec.CommonValidations) {
+	if schema.MaxItems != nil {
+		schema.MaxItems = nil
+		warnSkipValidation("maxItems", tpe)
+	}
+	if schema.MinItems != nil {
+		schema.MinItems = nil
+		warnSkipValidation("minItems", tpe)
+	}
+	if schema.UniqueItems {
+		schema.UniqueItems = false
+		warnSkipValidation("uniqueItems", tpe)
+	}
+}
+
+func removeObjectValidations(schema *spec.Schema) {
+	if schema.MaxProperties != nil {
+		schema.MaxProperties = nil
+		warnSkipValidation("maxProperties", schema.Type)
+	}
+	if schema.MinProperties != nil {
+		schema.MinProperties = nil
+		warnSkipValidation("minProperties", schema.Type)
+	}
+}
+
+// guardValidations removes (with a warning) validations that don't fit with the schema type.
+//
+// Notice that the "enum" validation is allowed on any type.
+func guardValidations(tpe string, schema *spec.Schema) {
+	switch tpe {
+	case array:
+		removeStringValidations(schema)
+		removeNumberValidations(schema)
+		removeObjectValidations(schema)
+
+	case boolean:
+		removeStringValidations(schema)
+		removeNumberValidations(schema)
+		removeSliceValidations(schema)
+		removeObjectValidations(schema)
+
+	case file:
+		removeNumberValidations(schema)
+		removeSliceValidations(schema)
+		removeObjectValidations(schema)
+
+		// keep MinLength/MaxLength on file
+		if schema.Pattern != "" {
+			schema.Pattern = ""
+			warnSkipValidation("pattern", schema)
+		}
+
+	case number, integer:
+		removeStringValidations(schema)
+		removeSliceValidations(schema)
+		removeObjectValidations(schema)
+
+	case str:
+		removeNumberValidations(schema)
+		removeSliceValidations(schema)
+		removeObjectValidations(schema)
+
+	case object:
+		removeStringValidations(schema)
+		removeNumberValidations(schema)
+		removeSliceValidations(schema)
+
+	case "null":
+		// mapped as interface{}: no validations allowed atm (TODO(fred): support minProperties, maxProperties)
+		removeStringValidations(schema)
+		removeNumberValidations(schema)
+		removeSliceValidations(schema)
+		removeObjectValidations(schema)
+	}
+}
+
+// guardSimpleValidations removes (with a warning) validations that don't fit with the simple schema type.
+func guardSimpleValidations(tpe string, validations *spec.CommonValidations) {
+	switch tpe {
+	case array:
+		removeStringCommonValidations(tpe, validations)
+		removeNumberCommonValidations(tpe, validations)
+
+	case boolean:
+		removeStringCommonValidations(tpe, validations)
+		removeNumberCommonValidations(tpe, validations)
+		removeSliceCommonValidations(tpe, validations)
+
+	case file:
+		removeNumberCommonValidations(tpe, validations)
+		removeSliceCommonValidations(tpe, validations)
+
+		// keep MinLength/MaxLength on file
+		if validations.Pattern != "" {
+			validations.Pattern = ""
+			warnSkipValidation("pattern", tpe)
+		}
+
+	case number, integer:
+		removeStringCommonValidations(tpe, validations)
+		removeSliceCommonValidations(tpe, validations)
+
+	case str:
+		removeNumberCommonValidations(tpe, validations)
+		removeSliceCommonValidations(tpe, validations)
+	}
+}
+
 // resolvedType is a swagger type that has been resolved and analyzed for usage
 // in a template
 type resolvedType struct {
diff --git a/hack/codegen-fixtures.yaml b/hack/codegen-fixtures.yaml
index f043e502..b917d4bc 100755
--- a/hack/codegen-fixtures.yaml
+++ b/hack/codegen-fixtures.yaml
@@ -211,3 +211,13 @@
 - dir: fixtures/bugs/2342
   skipped:
     skipModel: true
+- dir: fixtures/enhancements/2163
+  skipped:
+    skipServer: true
+    skipClient: true
+    skipExpand: true
+- dir: fixtures/enhancements/1771
+  skipped:
+    skipModel: true
+    skiClient: true
+    skipExpand: true
