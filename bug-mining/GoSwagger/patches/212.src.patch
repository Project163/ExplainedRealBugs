diff --git a/fixtures/bugs/1042/fixture-1042-2.yaml b/fixtures/bugs/1042/fixture-1042-2.yaml
new file mode 100644
index 00000000..3a45e586
--- /dev/null
+++ b/fixtures/bugs/1042/fixture-1042-2.yaml
@@ -0,0 +1,42 @@
+swagger: "2.0"
+info:
+  title: allOf marshalling
+  description: |
+    when the specification incorrectly defines the allOf,
+    generated unmarshalling is wrong.
+    This fixture asserts that with correct spec, the generated models are correct.
+  version: "0.0"
+  
+basePath: "/test"
+
+paths:
+  "/allof":
+    get:
+      responses:
+        '200':
+          description: test
+          schema:
+            "$ref": "#/definitions/ExtendedErrorModel"
+  
+definitions:
+  ErrorModel:
+    type: object
+    required:
+      - message
+      - code
+    properties:
+      message:
+        type: string
+      code:
+        type: integer
+        minimum: 100
+        maximum: 600
+  ExtendedErrorModel:
+    allOf:
+      - $ref: '#/definitions/ErrorModel'
+      - type: object
+        required:
+          - rootCause
+        properties:
+          rootCause:
+            type: string
diff --git a/fixtures/bugs/1042/fixture-1042-bad.json b/fixtures/bugs/1042/fixture-1042-bad.json
new file mode 100644
index 00000000..8f38b21d
--- /dev/null
+++ b/fixtures/bugs/1042/fixture-1042-bad.json
@@ -0,0 +1,62 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "allOf marshalling",
+    "description": "when the specification incorrectly defines the allOf,\ngenerated unmarshalling is wrong.\nThis fixture asserts that with correct spec, the generated models are correct.\n",
+    "version": "0.0"
+  },
+  "basePath": "/test",
+  "paths": {
+    "/allof": {
+      "get": {
+        "responses": {
+          "200": {
+            "description": "test",
+            "schema": {
+              "$ref": "#/definitions/B"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A": {
+      "description": "a first definition A",
+      "type": "object",
+      "properties": {
+        "f1": {
+          "type": "string"
+        },
+        "f2": {
+          "type": "string"
+        }
+      }
+    },
+    "B": {
+      "description": "a second definition B, which extends A",
+      "type": "object",
+      "allOf": [
+        {
+          "$ref": "#/definitions/A"
+        },
+        null
+      ],
+      "required": [
+        "f3",
+        "f4"
+      ],
+      "properties": {
+        "f3": {
+          "type": "string"
+        },
+        "f4": {
+          "type": "array",
+          "items": {
+            "type": "string"
+          }
+        }
+      }
+    }
+  }
+}
diff --git a/fixtures/bugs/1042/fixture-1042-bad.yaml b/fixtures/bugs/1042/fixture-1042-bad.yaml
new file mode 100644
index 00000000..16c7b261
--- /dev/null
+++ b/fixtures/bugs/1042/fixture-1042-bad.yaml
@@ -0,0 +1,47 @@
+swagger: "2.0"
+info:
+  title: allOf marshalling
+  description: |
+    when the specification incorrectly defines the allOf,
+    generated unmarshalling is wrong.
+    This fixture asserts that with correct spec, the generated models are correct.
+  version: "0.0"
+  
+basePath: "/test"
+
+paths:
+  "/allof":
+    get:
+      responses:
+        '200':
+          description: test
+          schema:
+            "$ref": "#/definitions/B"
+  
+definitions:
+  A:
+    description: a first definition A
+    type: object
+    properties:
+      f1:
+        type: string
+      f2: 
+        type: string
+
+  B:
+    description: a second definition B, which extends A
+    type: object
+    allOf:
+      - "$ref": "#/definitions/A"
+      -
+    required:
+    - f3
+    - f4
+    properties:
+      f3: 
+        type: string
+      f4: 
+        type: array
+        items:
+          type: string
+
diff --git a/fixtures/bugs/1042/fixture-1042.json b/fixtures/bugs/1042/fixture-1042.json
new file mode 100644
index 00000000..60f28e52
--- /dev/null
+++ b/fixtures/bugs/1042/fixture-1042.json
@@ -0,0 +1,63 @@
+{
+  "swagger": "2.0",
+  "info": {
+    "title": "allOf marshalling",
+    "description": "when the specification incorrectly defines the allOf,\ngenerated unmarshalling is wrong.\nThis fixture asserts that with correct spec, the generated models are correct.\n",
+    "version": "0.0"
+  },
+  "basePath": "/test",
+  "paths": {
+    "/allof": {
+      "get": {
+        "responses": {
+          "200": {
+            "description": "test",
+            "schema": {
+              "$ref": "#/definitions/B"
+            }
+          }
+        }
+      }
+    }
+  },
+  "definitions": {
+    "A": {
+      "description": "a first definition A",
+      "type": "object",
+      "properties": {
+        "f1": {
+          "type": "string"
+        },
+        "f2": {
+          "type": "string"
+        }
+      }
+    },
+    "B": {
+      "description": "a second definition B, which extends A",
+      "type": "object",
+      "allOf": [
+        {
+          "$ref": "#/definitions/A"
+        },
+        {
+          "required": [
+            "f3",
+            "f4"
+          ],
+          "properties": {
+            "f3": {
+              "type": "string"
+            },
+            "f4": {
+              "type": "array",
+              "items": {
+                "type": "string"
+              }
+            }
+          }
+        }
+      ]
+    }
+  }
+}
diff --git a/fixtures/bugs/1042/fixture-1042.yaml b/fixtures/bugs/1042/fixture-1042.yaml
new file mode 100644
index 00000000..777a4ed2
--- /dev/null
+++ b/fixtures/bugs/1042/fixture-1042.yaml
@@ -0,0 +1,46 @@
+swagger: "2.0"
+info:
+  title: allOf marshalling
+  description: |
+    when the specification incorrectly defines the allOf,
+    generated unmarshalling is wrong.
+    This fixture asserts that with correct spec, the generated models are correct.
+  version: "0.0"
+  
+basePath: "/test"
+
+paths:
+  "/allof":
+    get:
+      responses:
+        '200':
+          description: test
+          schema:
+            "$ref": "#/definitions/B"
+  
+definitions:
+  A:
+    description: a first definition A
+    type: object
+    properties:
+      f1:
+        type: string
+      f2: 
+        type: string
+
+  B:
+    description: a second definition B, which extends A
+    type: object
+    allOf:
+      - "$ref": "#/definitions/A"
+      -
+        required:
+          - f3
+          - f4
+        properties:
+          f3: 
+            type: string
+          f4: 
+            type: array
+            items:
+              type: string
diff --git a/fixtures/bugs/1042/gen-fixtures.sh b/fixtures/bugs/1042/gen-fixtures.sh
new file mode 100755
index 00000000..4ac8b9f7
--- /dev/null
+++ b/fixtures/bugs/1042/gen-fixtures.sh
@@ -0,0 +1,94 @@
+#! /bin/bash 
+if [[ ${1} == "--clean" ]] ; then
+    clean=1
+fi
+# Acknowledgements
+testcases="${testcases} fixture-1042.yaml"   
+testcases="${testcases} fixture-1042-2.yaml"   
+for testcase in ${testcases} ; do
+    spec=${testcase}
+    testcase=`basename ${testcase}`
+    target=./gen-${testcase%.*}
+    serverName="codegensrv"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Model generation for ${spec}"
+    swagger generate model --skip-validation --spec ${spec} --target ${target} --output=${testcase%.*}.log
+    # 1>x.log 2>&1
+    #
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Generation OK"
+    if [[ ! -d ${target}/models ]] ; then
+        echo "No model in this spec! Skipped"
+    else
+        (cd ${target}/models; go build)
+        if [[ $? != 0 ]] ; then
+            echo "Build failed for ${spec}"
+            exit 1
+        fi
+        echo "${spec}: Build OK"
+        if [[ -n ${clean} ]] ; then 
+             rm -rf ${target}
+        fi
+    fi
+done
+exit
+testcases=`cd ../../codegen;ls -1|grep -vE 'azure|bitbucket|existing-model|issue72|todolist.simple.yml'`
+#testcases=${testcases}" fixture-1062.json fixture-984.yaml"
+#testcases=`cd ../../codegen;ls -1|grep  'todolist.enums.yml'`
+for testcase in ${testcases} ; do
+    target=./gen-${testcase%.*}
+    if [[ -f ../../codegen/${testcase} ]] ; then
+      spec=../../codegen/${testcase}
+    else 
+      spec=${testcase}
+    fi
+    serverName="nrcodegen"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Server generation for ${spec}"
+    swagger generate server --skip-validation --spec ${spec} --target ${target} --name=${serverName} 1>${testcase%.*}.log 2>&1
+    #--output=${testcase%.*}.log
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Generation OK"
+    (cd ${target}/cmd/${serverName}"-server"; go build)
+    if [[ $? != 0 ]] ; then
+        echo "Build failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Build OK"
+    if [[ -n ${clean} ]] ; then 
+        rm -rf ${target}
+    fi
+done
+# TODO(fredbi): enable non reg again
+testcases=
+for testcase in ${testcases} ; do
+    target=./gen-${testcase%.*}
+    spec=./${testcase}
+    serverName="bugfix"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Generation for ${spec}"
+    swagger generate server --spec ${spec} --target ${target} --quiet --name=${serverName}
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Generation OK"
+    (cd ${target}/cmd/${serverName}"-server"; go build)
+    if [[ $? != 0 ]] ; then
+        echo "Build failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Build OK"
+    if [[ -n ${clean} ]] ; then 
+        rm -rf ${target}
+    fi
+done
diff --git a/fixtures/bugs/1042/pet_test.go b/fixtures/bugs/1042/pet_test.go
new file mode 100644
index 00000000..2b96cabb
--- /dev/null
+++ b/fixtures/bugs/1042/pet_test.go
@@ -0,0 +1,53 @@
+//+build integration
+
+package main
+
+import (
+	"bytes"
+	"encoding/json"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strings"
+	"testing"
+
+	"github.com/go-openapi/runtime"
+	"github.com/go-openapi/strfmt"
+	"github.com/go-swagger/go-swagger/fixtures/bugs/1232/gen-fixture-1232/models"
+	"github.com/stretchr/testify/assert"
+)
+
+//"github.com/go-swagger/go-swagger/fixtures/bugs/1232/gen-fixture-1232/mode"
+
+func Test_Pet(t *testing.T) {
+	base := "pet-data"
+	cwd, _ := os.Getwd()
+	filepath.Walk(cwd, func(path string, info os.FileInfo, err error) error {
+		fixture := info.Name()
+		if !info.IsDir() && strings.HasPrefix(fixture, base) {
+			// read fixture
+			buf, _ := ioutil.ReadFile(fixture)
+			body := bytes.NewBuffer(buf)
+
+			t.Logf("Fixture: %s", string(buf))
+			// unmarshall into model
+			consumer := runtime.JSONConsumer()
+			model, err := models.UnmarshalPet(body, consumer)
+			if assert.NoError(t, err) {
+				err = model.Validate(strfmt.Default)
+				if err == nil {
+					t.Logf("Validation for %s returned: valid", fixture)
+
+				} else {
+					t.Logf("Validation for %s returned: invalid, with: %v", fixture, err)
+				}
+			}
+			resp, erm := json.MarshalIndent(model, "", "  ")
+			if assert.NoError(t, erm) {
+				t.Logf("Marshalled as: %s", string(resp))
+			}
+		}
+		return nil
+	})
+
+}
diff --git a/fixtures/bugs/1232/discriminatedMarshalling_test.go b/fixtures/bugs/1232/discriminatedMarshalling_test.go
new file mode 100644
index 00000000..1ddc1451
--- /dev/null
+++ b/fixtures/bugs/1232/discriminatedMarshalling_test.go
@@ -0,0 +1,47 @@
+//+build integration
+
+package main
+
+import (
+	"encoding/json"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strings"
+	"testing"
+
+	"github.com/go-openapi/strfmt"
+	"github.com/go-swagger/go-swagger/fixtures/bugs/1232/gen-fixture-1232/models"
+	"github.com/stretchr/testify/assert"
+)
+
+func Test_Pet(t *testing.T) {
+	base := "pet-data"
+	cwd, _ := os.Getwd()
+	filepath.Walk(cwd, func(path string, info os.FileInfo, err error) error {
+		fixture := info.Name()
+		if !info.IsDir() && strings.HasPrefix(fixture, base) {
+			// read fixture
+			buf, _ := ioutil.ReadFile(fixture)
+
+			t.Logf("Fixture: %s", string(buf))
+			input := []interface{}{}
+			json.Unmarshal(buf, input)
+
+			// unmarshall into model
+			model := models.TupleThing{}
+			err = model.UnmarshalJSON(buf)
+			if assert.NoError(t, err) {
+				err = model.Validate(strfmt.Default)
+				if err == nil {
+					t.Logf("Validation for %s returned: valid", fixture)
+
+				} else {
+					t.Logf("Validation for %s returned: invalid, with: %v", fixture, err)
+				}
+			}
+		}
+		return nil
+	})
+
+}
diff --git a/fixtures/bugs/1232/fixture-1232.yaml b/fixtures/bugs/1232/fixture-1232.yaml
new file mode 100644
index 00000000..2218100b
--- /dev/null
+++ b/fixtures/bugs/1232/fixture-1232.yaml
@@ -0,0 +1,75 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: 'issue 1232'
+  description: verifies marshalling code on discriminated type
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /pet:
+    get:
+      operationId: getPet
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      parameters:
+      - name: aPet
+        in: body 
+        schema: 
+          $ref: '#/definitions/Pet'
+      responses:
+        default:
+          description: Generic Out
+          schema:
+            $ref: '#/definitions/Pet'
+  /cat:
+    get:
+      operationId: getCat
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      parameters:
+      - name: aCat
+        in: body 
+        schema: 
+          $ref: '#/definitions/Cat'
+      responses:
+        default:
+          description: Generic Out
+          schema:
+            $ref: '#/definitions/Pet'
+definitions:
+  Pet:
+    type: object
+    discriminator: petType
+    properties:
+      name:
+        type: string
+      petType:
+        type: string
+    required:
+    - name
+    - petType
+
+  Cat:
+    type: object
+    description: A representation of a cat
+    allOf:
+    - $ref: '#/definitions/Pet'
+    - properties:
+        huntingSkill:
+          type: string
+          description: The measured skill for hunting
+          default: lazy
+          enum:
+          - clueless
+          - lazy
+          - adventurous
+          - aggressive
+      required:
+      - huntingSkill
diff --git a/fixtures/bugs/1232/gen-fixtures.sh b/fixtures/bugs/1232/gen-fixtures.sh
new file mode 100755
index 00000000..a1b6efbf
--- /dev/null
+++ b/fixtures/bugs/1232/gen-fixtures.sh
@@ -0,0 +1,117 @@
+#! /bin/bash 
+if [[ ${1} == "--clean" ]] ; then
+    clean=1
+fi
+# Acknowledgements
+testcases="${testcases} fixture-1232.yaml"   
+#testcases="${testcases} ../1198/fixture-1198.yaml"      # passed ok
+# A small utility to build fixture servers
+# Fixtures with models only
+#testcases="${testcases} fixture-allOf.yaml"  # this one still reveals bugs
+# non reg
+#testcases="${testcases} ../../codegen/billforward.discriminators.yml"
+#testcases="${testcases} ../1277/cloudbreak.json"
+
+#testcases="${testcases} fixture-1479-part.yaml"        # passed ok
+#testcases="${testcases} fixture-simple-allOf.yaml"     # passed ok
+#testcases="${testcases} fixture-complex-allOf.yaml"    # passed ok
+#testcases="${testcases} fixture-is-nullable.yaml"      # passed ok
+#testcases="${testcases} fixture-itching.yaml"          # passed ok
+#testcases="${testcases} fixture-additionalProps.yaml"  # passed ok
+#testcases="${testcases} fixture-tuple.yaml"            # passed ok
+#testcases="fixture-1047.yaml fixture-1093.yaml fixture-1066.yaml fixture-arrays.yaml fixture-nested.yaml fixture-1203.yaml fixture-1328.yaml fixture-x-const.yaml fixture-ci.yaml fixture-types.yaml quay-discovery.json fixture-body.yaml fixture-951.json fixture-1062.json fixture-984.yaml"
+#testcases="${testcase} todolist.schemavalidation.yml todolist.enums.yml fixture-tuple.yaml fixture-edge.yaml fixture-1047.yaml fixture-1093.yaml fixture-1066.yaml fixture-arrays.yaml fixture-nested.yaml fixture-1203.yaml fixture-1328.yaml fixture-x-const.yaml fixture-ext.yaml fixture-ci.yaml fixture-types.yaml fixture-body.yaml"
+#testcases="${testcases} fixture-simple-tuple.yaml"
+for testcase in ${testcases} ; do
+    spec=${testcase}
+    testcase=`basename ${testcase}`
+    target=./gen-${testcase%.*}
+    serverName="codegensrv"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Model generation for ${spec}"
+    swagger generate model --skip-validation --spec ${spec} --target ${target} --output=${testcase%.*}.log
+    # 1>x.log 2>&1
+    #
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Generation OK"
+    if [[ ! -d ${target}/models ]] ; then
+        echo "No model in this spec! Skipped"
+    else
+        (cd ${target}/models; go build)
+        if [[ $? != 0 ]] ; then
+            echo "Build failed for ${spec}"
+            exit 1
+        fi
+        echo "${spec}: Build OK"
+        if [[ -n ${clean} ]] ; then 
+             rm -rf ${target}
+        fi
+    fi
+done
+exit
+# Non reg codegen
+# NOTE(fredbi): 
+# - azure: invalid spec 
+# - bitbucket: model does not compile
+# - issue72: invalid spec
+# - todolist.discriminator: ok now
+testcases=`cd ../../codegen;ls -1|grep -vE 'azure|bitbucket|existing-model|issue72|todolist.simple.yml'`
+#testcases=${testcases}" fixture-1062.json fixture-984.yaml"
+#testcases=`cd ../../codegen;ls -1|grep  'todolist.enums.yml'`
+for testcase in ${testcases} ; do
+    target=./gen-${testcase%.*}
+    if [[ -f ../../codegen/${testcase} ]] ; then
+      spec=../../codegen/${testcase}
+    else 
+      spec=${testcase}
+    fi
+    serverName="nrcodegen"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Server generation for ${spec}"
+    swagger generate server --skip-validation --spec ${spec} --target ${target} --name=${serverName} 1>${testcase%.*}.log 2>&1
+    #--output=${testcase%.*}.log
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Generation OK"
+    (cd ${target}/cmd/${serverName}"-server"; go build)
+    if [[ $? != 0 ]] ; then
+        echo "Build failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Build OK"
+    if [[ -n ${clean} ]] ; then 
+        rm -rf ${target}
+    fi
+done
+# TODO(fredbi): enable non reg again
+testcases=
+for testcase in ${testcases} ; do
+    target=./gen-${testcase%.*}
+    spec=./${testcase}
+    serverName="bugfix"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Generation for ${spec}"
+    swagger generate server --spec ${spec} --target ${target} --quiet --name=${serverName}
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Generation OK"
+    (cd ${target}/cmd/${serverName}"-server"; go build)
+    if [[ $? != 0 ]] ; then
+        echo "Build failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Build OK"
+    if [[ -n ${clean} ]] ; then 
+        rm -rf ${target}
+    fi
+done
diff --git a/fixtures/bugs/1232/pet-data-1.json b/fixtures/bugs/1232/pet-data-1.json
new file mode 100644
index 00000000..f2a9a200
--- /dev/null
+++ b/fixtures/bugs/1232/pet-data-1.json
@@ -0,0 +1,5 @@
+{
+    "petType": "cat",
+    "name": "fluffy",
+    "huntingSkills": "lazy"
+}
diff --git a/fixtures/bugs/1232/pet-data-2.json b/fixtures/bugs/1232/pet-data-2.json
new file mode 100644
index 00000000..c2c7e782
--- /dev/null
+++ b/fixtures/bugs/1232/pet-data-2.json
@@ -0,0 +1,5 @@
+{
+    "petType": "pet",
+    "name": "medor",
+    "huntingSkills": "lazy"
+}
diff --git a/fixtures/bugs/1232/pet-data-3.json b/fixtures/bugs/1232/pet-data-3.json
new file mode 100644
index 00000000..95d31d84
--- /dev/null
+++ b/fixtures/bugs/1232/pet-data-3.json
@@ -0,0 +1,5 @@
+{
+    "petType": "Cat",
+    "name": "minou",
+    "huntingSkill": "aggressive"
+}
diff --git a/fixtures/bugs/1232/pet_test.go b/fixtures/bugs/1232/pet_test.go
new file mode 100644
index 00000000..3c8b91e9
--- /dev/null
+++ b/fixtures/bugs/1232/pet_test.go
@@ -0,0 +1,53 @@
+//+build ignore
+
+package main
+
+import (
+	"bytes"
+	"encoding/json"
+	"io/ioutil"
+	"os"
+	"path/filepath"
+	"strings"
+	"testing"
+
+	"github.com/go-openapi/runtime"
+	"github.com/go-openapi/strfmt"
+	"github.com/go-swagger/go-swagger/fixtures/bugs/1232/gen-fixture-1232/models"
+	"github.com/stretchr/testify/assert"
+)
+
+//"github.com/go-swagger/go-swagger/fixtures/bugs/1232/gen-fixture-1232/mode"
+
+func Test_Pet(t *testing.T) {
+	base := "pet-data"
+	cwd, _ := os.Getwd()
+	filepath.Walk(cwd, func(path string, info os.FileInfo, err error) error {
+		fixture := info.Name()
+		if !info.IsDir() && strings.HasPrefix(fixture, base) {
+			// read fixture
+			buf, _ := ioutil.ReadFile(fixture)
+			body := bytes.NewBuffer(buf)
+
+			t.Logf("Fixture: %s", string(buf))
+			// unmarshall into model
+			consumer := runtime.JSONConsumer()
+			model, err := models.UnmarshalPet(body, consumer)
+			if assert.NoError(t, err) {
+				err = model.Validate(strfmt.Default)
+				if err == nil {
+					t.Logf("Validation for %s returned: valid", fixture)
+
+				} else {
+					t.Logf("Validation for %s returned: invalid, with: %v", fixture, err)
+				}
+			}
+			resp, erm := json.MarshalIndent(model, "", "  ")
+			if assert.NoError(t, erm) {
+				t.Logf("Marshalled as: %s", string(resp))
+			}
+		}
+		return nil
+	})
+
+}
diff --git a/fixtures/bugs/1336/fixture-1336.yaml b/fixtures/bugs/1336/fixture-1336.yaml
new file mode 100644
index 00000000..331e51c6
--- /dev/null
+++ b/fixtures/bugs/1336/fixture-1336.yaml
@@ -0,0 +1,59 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: broken code when using array of polymorphic type
+  description: broken code produced on polymorphic type
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      parameters: 
+        - name: sanity 
+          in: body 
+          schema: 
+            $ref: '#/definitions/sanityCheck'
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  sanityCheck:
+    description: an extensible empty object 
+    type: object
+    additionalProperties: true
+  Graph:
+    type: object
+    properties:
+      Nodes:
+        type: array
+        items:
+          $ref: "#/definitions/Node"
+  Node:
+    type: object
+    discriminator: NodeType
+    required:
+      - NodeType
+    properties:
+      NodeType:
+        type: string
+  CodeBlockNode:
+    allOf:
+      - $ref: "#/definitions/Node"
+      - properties:
+          Code:
+            type: string
+  # Added an addition subtype
+  DocBlockNode:
+    allOf:
+      - $ref: "#/definitions/Node"
+      - properties:
+          Doc:
+            type: string
diff --git a/fixtures/bugs/1479/fixture-1479-part.yaml b/fixtures/bugs/1479/fixture-1479-part.yaml
new file mode 100644
index 00000000..81146c45
--- /dev/null
+++ b/fixtures/bugs/1479/fixture-1479-part.yaml
@@ -0,0 +1,531 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: "check nested AllOf validations (from Pouch Engine API)"
+  description: |
+    The breakage with allOf occurs when a schema with an allOf has itself a  
+    property which is an allOf construct
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: nothing
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  ContainerCreateConfig:
+    allOf:
+      - $ref: "#/definitions/ContainerConfig"
+      - type: "object"
+        properties:
+          HostConfig:
+            $ref: "#/definitions/HostConfig"
+          NetworkingConfig:
+            $ref: "#/definitions/NetworkingConfig"
+  ContainerConfig:
+    type: "object"
+    description: "Configuration for a container that is portable between hosts"
+    required: 
+      - Image
+    properties:
+      Hostname:
+        description: "The hostname to use for the container, as a valid RFC 1123 hostname."
+        type: "string"
+        format: hostname
+        minLength: 1
+      Domainname:
+        description: "The domain name to use for the container."
+        type: "string"
+      User:
+        description: "The user that commands are run as inside the container."
+        type: "string"
+      AttachStdin:
+        description: "Whether to attach to `stdin`."
+        type: "boolean"
+        x-nullable: false
+      AttachStdout:
+        description: "Whether to attach to `stdout`."
+        type: "boolean"
+        x-nullable: false
+        default: true
+      AttachStderr:
+        description: "Whether to attach to `stderr`."
+        type: "boolean"
+        x-nullable: false
+        default: true
+      ExposedPorts:
+        description: "An object mapping ports to an empty object in the form:`{<port>/<tcp|udp>: {}}`"
+        type: "object"
+        additionalProperties:
+          type: "object"
+          enum:
+            - {}
+          default: {}
+      Tty:
+        description: "Attach standard streams to a TTY, including `stdin` if it is not closed."
+        type: "boolean"
+        x-nullable: false
+      OpenStdin:
+        description: "Open `stdin`"
+        type: "boolean"
+        x-nullable: false
+      StdinOnce:
+        description: "Close `stdin` after one attached client disconnects"
+        type: "boolean"
+        x-nullable: false
+      Env:
+        description: |
+          A list of environment variables to set inside the container in the form `["VAR=value", ...]`. A variable without `=` is removed from the environment, rather than to have an empty value.
+        type: "array"
+        items:
+          type: "string"
+      Cmd:
+        description: "Command to run specified an array of strings."
+        type: "array"
+        items:
+          type: "string"
+      ArgsEscaped:
+        description: "Command is already escaped (Windows only)"
+        type: "boolean"
+        x-nullable: false
+      Image:
+        description: "The name of the image to use when creating the container"
+        type: "string"
+        x-nullable: false
+      Volumes:
+        description: "An object mapping mount point paths inside the container to empty objects."
+        type: "object"
+        additionalProperties:
+          type: "object"
+          enum:
+            - {}
+          default: {}
+      WorkingDir:
+        description: "The working directory for commands to run in."
+        type: "string"
+      Entrypoint:
+        description: |
+          The entry point for the container as a string or an array of strings.
+          If the array consists of exactly one empty string (`[""]`) then the entry point is reset to system default.
+        type: "array"
+        items:
+          type: "string"
+      NetworkDisabled:
+        description: "Disable networking for the container."
+        type: "boolean"
+      MacAddress:
+        description: "MAC address of the container."
+        type: "string"
+      OnBuild:
+        description: "`ONBUILD` metadata that were defined."
+        type: "array"
+        items:
+          type: "string"
+      Labels:
+        description: "User-defined key/value metadata."
+        type: "object"
+        additionalProperties:
+          type: "string"
+      StopSignal:
+        description: "Signal to stop a container as a string or unsigned integer."
+        type: "string"
+        default: "SIGTERM"
+        x-nullable: false
+      StopTimeout:
+        description: "Timeout to stop a container in seconds."
+        type: "integer"
+        default: 10
+      Shell:
+        description: "Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell."
+        type: "array"
+        items:
+          type: "string"
+      Rich:
+        type: "boolean"
+        description: "Whether to start container in rich container mode. (default false)"
+        x-nullable: false
+      RichMode:
+        type: "string"
+        description: "Choose one rich container mode.(default dumb-init)"
+        enum:
+          - "dumb-init"
+          - "sbin-init"
+          - "systemd"
+      InitScript:
+        type: "string"
+        description: "Initial script executed in container. The script will be executed before entrypoint or command"
+      DiskQuota:
+        type: "object"
+        description: "Set disk quota for container"
+        x-nullable: true
+        additionalProperties:
+          type: "string"
+      SpecAnnotation:
+        description: "annotations send to runtime spec."
+        type: "object"
+        additionalProperties:
+          type: "string"
+      QuotaID:
+        type: "string"
+        description: "set disk quota by specified quota id, if id < 0, it means pouchd alloc a unique quota id"
+ 
+  NetworkingConfig:
+    description: "Configuration for a network used to create a container."
+    type: "object"
+    properties:
+      EndpointsConfig:
+        additionalProperties:
+          $ref: "#/definitions/EndpointSettings"
+          x-nullable: true
+
+  EndpointSettings:
+    description: "Configuration for a network endpoint."
+    type: "object"
+    properties:
+      # Configurations
+      IPAMConfig:
+        $ref: "#/definitions/EndpointIPAMConfig"
+        x-nullable: true
+      Links:
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - "container_1"
+          - "container_2"
+      Aliases:
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - "server_x"
+          - "server_y"
+
+      # Operational data
+      NetworkID:
+        description: |
+          Unique ID of the network.
+        type: "string"
+        example: "08754567f1f40222263eab4102e1c733ae697e8e354aa9cd6e18d7402835292a"
+      EndpointID:
+        description: |
+          Unique ID for the service endpoint in a Sandbox.
+        type: "string"
+        example: "b88f5b905aabf2893f3cbc4ee42d1ea7980bbc0a92e2c8922b1e1795298afb0b"
+      Gateway:
+        description: |
+          Gateway address for this network.
+        type: "string"
+        example: "172.17.0.1"
+      IPAddress:
+        description: |
+          IPv4 address.
+        type: "string"
+        example: "172.17.0.4"
+      IPPrefixLen:
+        description: |
+          Mask length of the IPv4 address.
+        type: "integer"
+        example: 16
+      IPv6Gateway:
+        description: |
+          IPv6 gateway address.
+        type: "string"
+        example: "2001:db8:2::100"
+      GlobalIPv6Address:
+        description: |
+          Global IPv6 address.
+        type: "string"
+        example: "2001:db8::5689"
+      GlobalIPv6PrefixLen:
+        description: |
+          Mask length of the global IPv6 address.
+        type: "integer"
+        format: "int64"
+        example: 64
+      MacAddress:
+        description: |
+          MAC address for the endpoint on this network.
+        type: "string"
+        example: "02:42:ac:11:00:04"
+      DriverOpts:
+        description: |
+          DriverOpts is a mapping of driver options and values. These options
+          are passed directly to the driver and are driver specific.
+        type: "object"
+        x-nullable: true
+        additionalProperties:
+          type: "string"
+        example:
+          com.example.some-label: "some-value"
+          com.example.some-other-label: "some-other-value"
+
+  EndpointIPAMConfig:
+    description: "IPAM configurations for the endpoint"
+    type: "object"
+    properties:
+      IPv4Address:
+        description: "ipv4 address"
+        type: "string"
+      IPv6Address:
+        description: "ipv6 address"
+        type: "string"
+      LinkLocalIPs:
+        description: "link to the list of local ip"
+        type: "array"
+        x-nullable: false
+        items:
+          type: "string"
+
+  HostConfig:
+    description: "Container configuration that depends on the host we are running on"
+    type: "object"
+    allOf:
+      - properties:
+          # Applicable to all platforms
+          Binds:
+            type: "array"
+            description: |
+              A list of volume bindings for this container. Each volume binding is a string in one of these forms:
+
+              - `host-src:container-dest` to bind-mount a host path into the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
+              - `host-src:container-dest:ro` to make the bind mount read-only inside the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
+              - `volume-name:container-dest` to bind-mount a volume managed by a volume driver into the container. `container-dest` must be an _absolute_ path.
+              - `volume-name:container-dest:ro` to mount the volume read-only inside the container.  `container-dest` must be an _absolute_ path.
+            items:
+              type: "string"
+          ContainerIDFile:
+            type: "string"
+            description: "Path to a file where the container ID is written"
+          LogConfig:
+            type: "object"
+            description: "The logging configuration for this container"
+            properties:
+              Type:
+                type: "string"
+                enum:
+                  - "json-file"
+                  - "syslog"
+                  - "journald"
+                  - "gelf"
+                  - "fluentd"
+                  - "awslogs"
+                  - "splunk"
+                  - "etwlogs"
+                  - "none"
+              Config:
+                type: "object"
+                additionalProperties:
+                  type: "string"
+          RestartPolicy:
+            type: "object"
+            description: "Restart policy to be used to manage the container"
+            $ref: "#/definitions/RestartPolicy"
+          NetworkMode:
+            type: "string"
+            description: "Network mode to use for this container. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to."
+          AutoRemove:
+            type: "boolean"
+            description: "Automatically remove the container when the container's process exits. This has no effect if `RestartPolicy` is set."
+          VolumeDriver:
+            type: "string"
+            description: "Driver that this container uses to mount volumes."
+          VolumesFrom:
+            type: "array"
+            description: "A list of volumes to inherit from another container, specified in the form `<container name>[:<ro|rw>]`."
+            items:
+              type: "string"
+          CapAdd:
+            type: "array"
+            description: "A list of kernel capabilities to add to the container."
+            items:
+              type: "string"
+          CapDrop:
+            type: "array"
+            description: "A list of kernel capabilities to drop from the container."
+            items:
+              type: "string"
+          Dns:
+            type: "array"
+            description: "A list of DNS servers for the container to use."
+            items:
+              type: "string"
+          DnsOptions:
+            type: "array"
+            description: "A list of DNS options."
+            items:
+              type: "string"
+          DnsSearch:
+            type: "array"
+            description: "A list of DNS search domains."
+            items:
+              type: "string"
+          ExtraHosts:
+            type: "array"
+            description: |
+              A list of hostnames/IP mappings to add to the container's `/etc/hosts` file. Specified in the form `["hostname:IP"]`.
+            items:
+              type: "string"
+          GroupAdd:
+            type: "array"
+            description: "A list of additional groups that the container process will run as."
+            items:
+              type: "string"
+          IpcMode:
+            type: "string"
+            description: |
+                    IPC sharing mode for the container. Possible values are:
+                    - `"none"`: own private IPC namespace, with /dev/shm not mounted
+                    - `"private"`: own private IPC namespace
+                    - `"shareable"`: own private IPC namespace, with a possibility to share it with other containers
+                    - `"container:<name|id>"`: join another (shareable) container's IPC namespace
+                    - `"host"`: use the host system's IPC namespace
+                    If not specified, daemon default is used, which can either be `"private"`
+                    or `"shareable"`, depending on daemon version and configuration.
+          Cgroup:
+            type: "string"
+            description: "Cgroup to use for the container."
+          Links:
+            type: "array"
+            description: "A list of links for the container in the form `container_name:alias`."
+            items:
+              type: "string"
+          OomScoreAdj:
+            type: "integer"
+            description: |
+                An integer value containing the score given to the container in order to tune OOM killer preferences.
+                The range is in [-1000, 1000].
+            type: "integer"
+            format: "int"
+            x-nullable: false
+            minimum: -1000
+            maximum: 1000
+          PidMode:
+            type: "string"
+            description: |
+              Set the PID (Process) Namespace mode for the container. It can be either:
+              - `"container:<name|id>"`: joins another container's PID namespace
+              - `"host"`: use the host's PID namespace inside the container
+          Privileged:
+            type: "boolean"
+            description: "Gives the container full access to the host."
+          PublishAllPorts:
+            type: "boolean"
+            description: "Allocates a random host port for all of a container's exposed ports."
+          ReadonlyRootfs:
+            type: "boolean"
+            description: "Mount the container's root filesystem as read only."
+          SecurityOpt:
+            type: "array"
+            description: "A list of string values to customize labels for MLS systems, such as SELinux."
+            items:
+              type: "string"
+          StorageOpt:
+            type: "object"
+            description: |
+              Storage driver options for this container, in the form `{"size": "120G"}`.
+            additionalProperties:
+              type: "string"
+          Tmpfs:
+            type: "object"
+            description: |
+              A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: `{ "/run": "rw,noexec,nosuid,size=65536k" }`.
+            additionalProperties:
+              type: "string"
+          UTSMode:
+            type: "string"
+            description: "UTS namespace to use for the container."
+          UsernsMode:
+            type: "string"
+            description: "Sets the usernamespace mode for the container when usernamespace remapping option is enabled."
+          ShmSize:
+            type: "integer"
+            description: "Size of `/dev/shm` in bytes. If omitted, the system uses 64MB."
+            minimum: 0
+          Sysctls:
+            type: "object"
+            description: |
+              A list of kernel parameters (sysctls) to set in the container. For example: `{"net.ipv4.ip_forward": "1"}`
+            additionalProperties:
+              type: "string"
+          Runtime:
+            type: "string"
+            description: "Runtime to use with this container."
+          # Applicable to Windows
+          ConsoleSize:
+            type: "array"
+            description: "Initial console size, as an `[height, width]` array. (Windows only)"
+            minItems: 2
+            maxItems: 2
+            items:
+              type: "integer"
+              minimum: 0
+          Isolation:
+            type: "string"
+            description: "Isolation technology of the container. (Windows only)"
+            enum:
+              - "default"
+              - "process"
+              - "hyperv"
+          EnableLxcfs:
+            description: "Whether to enable lxcfs."
+            type: "boolean"
+            x-nullable: false
+          Rich:
+            type: "boolean"
+            description: "Whether to start container in rich container mode. (default false)"
+            x-nullable: false
+          RichMode:
+            type: "string"
+            description: "Choose one rich container mode.(default dumb-init)"
+            enum:
+             - "dumb-init"
+             - "sbin-init"
+             - "systemd"
+          InitScript:
+            type: "string"
+            description: "Initial script executed in container. The script will be executed before entrypoint or command"
+      - $ref: "#/definitions/Resources"
+
+  Resources:
+    description: "A container's resources (cgroups config, ulimits, etc)"
+    type: "object"
+    properties:
+      # Applicable to all platforms
+      CpuShares:
+        description: "An integer value representing this container's relative CPU weight versus other containers."
+        type: "integer"
+      Memory:
+        description: "Memory limit in bytes."
+        type: "integer"
+        default: 0
+      # Applicable to UNIX platforms
+      CgroupParent:
+        description: "Path to `cgroups` under which the container's `cgroup` is created. If the path is not absolute, the path is considered to be relative to the `cgroups` path of the init process. Cgroups are created if they do not already exist."
+        type: "string"
+      BlkioWeight:
+        description: "Block IO weight (relative weight)."
+        type: "integer"
+        format: "uint16"
+        x-nullable: false
+        minimum: 0
+        maximum: 1000
+
+  RestartPolicy:
+    description: "Define container's restart policy"
+    type: "object"
+    properties:
+      Name:
+        type: "string"
+      MaximumRetryCount:
+        type: "integer"
+
diff --git a/fixtures/bugs/1479/fixture-1479.yaml b/fixtures/bugs/1479/fixture-1479.yaml
new file mode 100644
index 00000000..50795904
--- /dev/null
+++ b/fixtures/bugs/1479/fixture-1479.yaml
@@ -0,0 +1,3313 @@
+---
+swagger: "2.0"
+schemes:
+  - "http"
+  - "https"
+produces:
+  - "application/json"
+  - "text/plain"
+consumes:
+  - "application/json"
+  - "text/plain"
+basePath: "/v1.24"
+info:
+  title: "Pouch Engine API"
+  version: "1.24"
+  description: |
+    API is an HTTP API served by Pouch Engine.
+
+produces:
+        - "application/json"
+paths:
+  /_ping:
+    get:
+      summary: ""
+      description: ""
+      responses:
+        200:
+          description: "no error"
+          schema:
+            type: "string"
+            example: "OK"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+
+  /version:
+    get:
+      summary: "Get Pouchd version"
+      description: ""
+      responses:
+        200:
+          schema:
+            $ref: '#/definitions/SystemVersion'
+          description: "no error"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+
+  /info:
+    get:
+      summary: "Get System information"
+      description: ""
+      responses:
+        200:
+          schema:
+            $ref: '#/definitions/SystemInfo'
+          description: "no error"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+
+  /auth:
+    post:
+      summary: "Check auth configuration"
+      description: "Validate credentials for a registry and, if available, get an identity token for accessing the registry without password."
+      consumes:
+        - "application/json"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "An identity token was generated successfully."
+          schema:
+            $ref: "#/definitions/AuthResponse"
+        401:
+          description: "Login unauthorized"
+          schema:
+            $ref: "#/responses/401ErrorResponse"
+        500:
+          description: "Server error"
+          schema:
+            $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "authConfig"
+          in: "body"
+          description: "Authentication to check"
+          schema:
+            $ref: "#/definitions/AuthConfig"
+  
+  /daemon/update:
+    post:
+      summary: "Update daemon's labels and image proxy"
+      consumes:
+        - "application/json"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "no error"
+        400:
+          description: "bad parameter"
+          schema:
+            $ref: '#/definitions/Error'
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "DaemonUpdateConfig"
+          in: body
+          description: "Config used to update daemon, only labels and image proxy are allowed."
+          schema:
+            $ref: "#/definitions/DaemonUpdateConfig"
+
+  /images/create:
+    post:
+      summary: "Create an image by pulling from a registry or importing from an existing source file"
+      consumes:
+        - "text/plain"
+        - "application/octet-stream"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "no error"
+        404:
+          schema:
+            $ref: '#/definitions/Error'
+          description: "image not found"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "fromImage"
+          in: "query"
+          description: "Name of the image to pull. The name may include a tag or digest. This parameter may only be used when pulling an image. The pull is cancelled if the HTTP connection is closed."
+          type: "string"
+        - name: "fromSrc"
+          in: "query"
+          description: "Source to import. The value may be a URL from which the image can be retrieved or `-` to read the image from the request body. This parameter may only be used when importing an image."
+          type: "string"
+        - name: "repo"
+          in: "query"
+          description: "Repository name given to an image when it is imported. The repo may include a tag. This parameter may only be used when importing an image."
+          type: "string"
+        - name: "tag"
+          in: "query"
+          description: "Tag or digest. If empty when pulling an image, this causes all tags for the given image to be pulled."
+          type: "string"
+        - name: "inputImage"
+          in: "body"
+          description: "Image content if the value `-` has been specified in fromSrc query parameter"
+          schema:
+            type: "string"
+          required: false
+        - name: "X-Registry-Auth"
+          in: "header"
+          description: "A base64-encoded auth configuration. [See the authentication section for details.](#section/Authentication)"
+          type: "string"
+
+  /images/{imageid}/json:
+    get:
+      summary: "Inspect a image"
+      description: "Return the information about image"
+      operationId: "ImageInspect"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "no error"
+          schema:
+            $ref: "#/definitions/ImageInfo"
+          examples:
+            application/json:
+              CreatedAt: "2017-12-19 15:32:09"
+              Digest: "sha256:e216a057b1cb1efc11f8a268f37ef62083e70b1b38323ba252e25ac88904a7e8"
+              ID: "e216a057b1cb"
+              Name: "ubuntu:12.04"
+              Size: 103579269
+              Tag: "12.04"
+        404:
+          description: "no such image"
+          schema:
+            $ref: "#/definitions/Error"
+          examples:
+            application/json:
+              message: "No such image: e216a057b1cb"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - $ref: "#/parameters/imageid"
+
+  /images/json:
+    get:
+      summary: "List Images"
+      description: "Return a list of stored images."
+      operationId: "ImageList"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "Summary image data for the images matching the query"
+          schema:
+            type: "array"
+            items:
+              $ref: "#/definitions/ImageInfo"
+          examples:
+            application/json:
+              - Id: "sha256:e216a057b1cb1efc11f8a268f37ef62083e70b1b38323ba252e25ac88904a7e8"
+                ParentId: ""
+                RepoTags:
+                  - "ubuntu:12.04"
+                  - "ubuntu:precise"
+                RepoDigests:
+                  - "ubuntu@sha256:992069aee4016783df6345315302fa59681aae51a8eeb2f889dea59290f21787"
+                Created: 1474925151
+                Size: 103579269
+                VirtualSize: 103579269
+                SharedSize: 0
+                Labels: {}
+                Containers: 2
+              - Id: "sha256:3e314f95dcace0f5e4fd37b10862fe8398e3c60ed36600bc0ca5fda78b087175"
+                ParentId: ""
+                RepoTags:
+                  - "ubuntu:12.10"
+                  - "ubuntu:quantal"
+                RepoDigests:
+                  - "ubuntu@sha256:002fba3e3255af10be97ea26e476692a7ebed0bb074a9ab960b2e7a1526b15d7"
+                  - "ubuntu@sha256:68ea0200f0b90df725d99d823905b04cf844f6039ef60c60bf3e019915017bd3"
+                Created: 1403128455
+                Size: 172064416
+                VirtualSize: 172064416
+                SharedSize: 0
+                Labels: {}
+                Containers: 5
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "all"
+          in: "query"
+          description: "Show all images. Only images from a final layer (no children) are shown by default."
+          type: "boolean"
+        - name: "filters"
+          in: "query"
+          description: |
+            A JSON encoded value of the filters (a `map[string][]string`) to process on the images list. Available filters:
+
+            - `before`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
+            - `dangling=true`
+            - `label=key` or `label="key=value"` of an image label
+            - `reference`=(`<image-name>[:<tag>]`)
+            - `since`=(`<image-name>[:<tag>]`,  `<image id>` or `<image@digest>`)
+          type: "string"
+        - name: "digests"
+          in: "query"
+          description: "Show digest information as a `RepoDigests` field on each image."
+          type: "boolean"
+
+  /images/search:
+    get:
+      summary: "Search images"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "No error"
+          schema:
+            type: "array"
+            items:
+              $ref: "#/definitions/SearchResultItem"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+
+  /images/{imageid}:
+    delete:
+      summary: "Remove an image"
+      description: "Remove an image by reference."
+      parameters:
+        - $ref: "#/parameters/imageid"
+        - name: "force"
+          in: "query"
+          description: "Remove the image even if it is being used"
+          type: "boolean"
+          default: false
+      responses:
+        204:
+          description: "No error"
+        404:
+          description: "no such image"
+          schema:
+            $ref: "#/definitions/Error"
+          examples:
+            application/json:
+              message: "No such image: c2ada9df5af8"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+
+  /containers/create:
+    post:
+      summary: "Create a container"
+      consumes:
+        - "application/json"
+      produces:
+        - "application/json"
+      parameters:
+        - name: "name"
+          in: "query"
+          description: "Assign the specified name to the container. Must match `/?[a-zA-Z0-9_-]+`."
+          type: "string"
+          pattern: "/?[a-zA-Z0-9_-]+"
+        - name: "body"
+          in: "body"
+          description: "Container to create"
+          schema:
+            $ref: "#/definitions/ContainerCreateConfig"
+          required: true
+      responses:
+        201:
+          description: "Container created successfully"
+          schema:
+            $ref: "#/definitions/ContainerCreateResp"
+          examples:
+            application/json:
+              Id: "e90e34656806"
+              Warnings: []
+        400:
+          description: "bad parameter"
+          schema:
+            $ref: "#/definitions/Error"
+        404:
+          description: "no such image"
+          schema:
+            $ref: "#/definitions/Error"
+          examples:
+            application/json:
+              message: "image: xxx:latest: not found"
+        409:
+          description: "conflict"
+          schema:
+            $ref: "#/definitions/Error"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}/json:
+    get:
+      summary: "Inspect a container"
+      description: "Return low-level information about a container."
+      operationId: "ContainerInspect"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "no error"
+          schema:
+            $ref: "#/definitions/ContainerJSON"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "size"
+          in: "query"
+          type: "boolean"
+          description: "Return the size of container as fields `SizeRw` and `SizeRootFs`"
+      tags: ["Container"]
+
+  /containers/json:
+    get:
+      summary: "List containers"
+      operationId: "ContainerList"
+      produces: ["application/json"]
+      responses:
+        200:
+          description: "Summary containers that matches the query"
+          schema:
+            type: "array"
+            items:
+              $ref: "#/definitions/Container"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "all"
+          in: "query"
+          description: "Return all containers. By default, only running containers are shown"
+          type: "boolean"
+          default: false
+
+  /containers/{id}/rename:
+    post:
+      summary: "Rename a container"
+      operationId: "ContainerRename"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "name"
+          in: "query"
+          required: true
+          description: "New name for the container"
+          type: "string"
+      responses:
+        204:
+          description: "no error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        409:
+          description: "name already in use"
+          schema:
+            $ref: "#/definitions/Error"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}/restart:
+    post:
+      summary: "Restart a container"
+      operationId: "ContainerRestart"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "name"
+          in: "query"
+          required: true
+          description: "New name for the container"
+          type: "string"
+        - name: "t"
+          in: "query"
+          description: "Number of seconds to wait before killing the container"
+          type: "integer"
+      responses:
+        204:
+          description: "no error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}/start:
+    post:
+      summary: "Start a container"
+      operationId: "ContainerStart"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "detachKeys"
+          in: "query"
+          description: "Override the key sequence for detaching a container. Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`."
+          type: "string"
+      responses:
+        204:
+          description: "no error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}/stop:
+    post:
+      summary: "Stop a container"
+      operationId: "ContainerStop"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "t"
+          in: "query"
+          description: "Number of seconds to wait before killing the container"
+          type: "integer"
+      responses:
+        204:
+          description: "no error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}/pause:
+    post:
+      summary: "Pause a container"
+      operationId: "ContainerPause"
+      parameters:
+        - $ref: "#/parameters/id"
+      responses:
+        204:
+          description: "no error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}/unpause:
+    post:
+      summary: "Unpause a container"
+      operationId: "ContainerUnpause"
+      parameters:
+        - $ref: "#/parameters/id"
+      responses:
+        204:
+          description: "no error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}/top:
+    post:
+      summary: "Display the running processes of a container"
+      operationId: "ContainerTop"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "ps_args"
+          in: "query"
+          description: "top arguments"
+          type: "string"
+      responses:
+        200:
+          description: "no error"
+          schema:
+            $ref: "#/definitions/ContainerProcessList"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}:
+    delete:
+      summary: "Remove one container"
+      operationId: "ContainerRemove"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "force"
+          in: "query"
+          description: "If the container is running, force query is used to kill it and remove it forcefully."
+          type: "boolean"
+      responses:
+        204:
+          description: "no error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+
+  /containers/{id}/exec:
+    post:
+      summary: "Create an exec instance"
+      description: "Run a command inside a running container."
+      operationId: "ContainerExec"
+      consumes:
+        - "application/json"
+      produces:
+        - "application/json"
+      responses:
+        201:
+          description: "no error"
+          schema:
+            $ref: "#/definitions/ExecCreateResp"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        409:
+          description: "container is paused"
+          schema:
+            $ref: "#/definitions/Error"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "body"
+          in: "body"
+          schema:
+            $ref: "#/definitions/ExecCreateConfig"
+          required: true
+      tags: ["Exec"]
+
+  /containers/{id}/logs:
+    get:
+      summary: "Get container logs"
+      description: |
+        Get `stdout` and `stderr` logs from a container.
+
+        Note: This endpoint works only for containers with the `json-file` or `journald` logging driver.
+      operationId: "ContainerLogs"
+      responses:
+        101:
+          description: "logs returned as a stream"
+          schema:
+            type: "string"
+            format: "binary"
+        200:
+          description: "logs returned as a string in response body"
+          schema:
+            type: "string"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "id"
+          in: "path"
+          required: true
+          description: "ID or name of the container"
+          type: "string"
+        - name: "follow"
+          in: "query"
+          description: |
+            Return the logs as a stream.
+          type: "boolean"
+          default: false
+        - name: "stdout"
+          in: "query"
+          description: "Return logs from `stdout`"
+          type: "boolean"
+          default: false
+        - name: "stderr"
+          in: "query"
+          description: "Return logs from `stderr`"
+          type: "boolean"
+          default: false
+        - name: "since"
+          in: "query"
+          description: "Only return logs since this time, as a UNIX timestamp"
+          type: "integer"
+          default: 0
+        - name: "until"
+          in: "query"
+          description: "Only return logs before this time, as a UNIX timestamp"
+          type: "integer"
+          default: 0
+        - name: "timestamps"
+          in: "query"
+          description: "Add timestamps to every log line"
+          type: "boolean"
+          default: false
+        - name: "tail"
+          in: "query"
+          description: "Only return this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines."
+          type: "string"
+          default: "all"
+      tags: ["Container"]
+
+  /containers/{id}/resize:
+    post:
+      summary: "changes the size of the tty for a container"
+      operationId: "ContainerResize"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "height"
+          in: "query"
+          description: "height of the tty"
+          type: "string"
+        - name: "width"
+          in: "query"
+          description: "width of the tty"
+          type: "string"
+      responses:
+        200:
+          description: "no error"
+        400:
+          description: "bad parameter"
+          schema:
+            $ref: "#/definitions/Error"
+      tags: ["Container"]
+
+  /exec/{id}/start:
+    post:
+      summary: "Start an exec instance"
+      description: "Starts a previously set up exec instance. If detach is true, this endpoint returns immediately after starting the command. Otherwise, it sets up an interactive session with the command."
+      operationId: "ExecStart"
+      consumes:
+        - "application/json"
+      produces:
+        - "application/vnd.raw-stream"
+      responses:
+        200:
+          description: "No error"
+        404:
+          description: "No such exec instance"
+          schema:
+            $ref: "#/definitions/Error"
+        409:
+          description: "Container is stopped or paused"
+          schema:
+            $ref: "#/definitions/Error"
+      parameters:
+        - name: "execStartConfig"
+          in: "body"
+          schema:
+            $ref: "#/definitions/ExecStartConfig"
+        - name: "id"
+          in: "path"
+          description: "Exec instance ID"
+          required: true
+          type: "string"
+      tags: ["Exec"]
+
+  /exec/{id}/json:
+    get:
+      summary: "Inspect an exec instance"
+      description: "Return low-level information about an exec instance."
+      operationId: "ExecInspect"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "No error"
+          schema:
+            $ref: "#/definitions/ContainerExecInspect"
+        404:
+          description: "No such exec instance"
+          schema:
+            $ref: "#/responses/404ErrorResponse"
+        500:
+          description: "Server error"
+          schema:
+            $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "id"
+          in: "path"
+          description: "Exec instance ID"
+          required: true
+          type: "string"
+      tags: ["Exec"]
+
+  /containers/{id}/attach:
+    post:
+      summary: "Attach to a container"
+      description: |
+        Attach to a container to read its output or send it input. You can attach to the same container multiple times and you can reattach to containers that have been detached.
+
+        Either the `stream` or `logs` parameter must be `true` for this endpoint to do anything.
+
+        ### Hijacking
+
+        This endpoint hijacks the HTTP connection to transport `stdin`, `stdout`, and `stderr` on the same socket.
+
+        This is the response from the daemon for an attach request:
+
+        ```
+        HTTP/1.1 200 OK
+        Content-Type: application/vnd.raw-stream
+
+        [STREAM]
+        ```
+
+        After the headers and two new lines, the TCP connection can now be used for raw, bidirectional communication between the client and server.
+
+        To hint potential proxies about connection hijacking, the Pouch client can also optionally send connection upgrade headers.
+
+        For example, the client sends this request to upgrade the connection:
+
+        ```
+        POST /containers/16253994b7c4/attach?stream=1&stdout=1 HTTP/1.1
+        Upgrade: tcp
+        Connection: Upgrade
+        ```
+
+        The Pouch daemon will respond with a `101 UPGRADED` response, and will similarly follow with the raw stream:
+
+        ```
+        HTTP/1.1 101 UPGRADED
+        Content-Type: application/vnd.raw-stream
+        Connection: Upgrade
+        Upgrade: tcp
+
+        [STREAM]
+        ```
+
+        ### Stream format
+
+        When the TTY setting is disabled in [`POST /containers/create`](#operation/ContainerCreate), the stream over the hijacked connected is multiplexed to separate out `stdout` and `stderr`. The stream consists of a series of frames, each containing a header and a payload.
+
+        The header contains the information which the stream writes (`stdout` or `stderr`). It also contains the size of the associated frame encoded in the last four bytes (`uint32`).
+
+        It is encoded on the first eight bytes like this:
+
+        ```go
+        header := [8]byte{STREAM_TYPE, 0, 0, 0, SIZE1, SIZE2, SIZE3, SIZE4}
+        ```
+
+        `STREAM_TYPE` can be:
+
+        - 0: `stdin` (is written on `stdout`)
+        - 1: `stdout`
+        - 2: `stderr`
+
+        `SIZE1, SIZE2, SIZE3, SIZE4` are the four bytes of the `uint32` size encoded as big endian.
+
+        Following the header is the payload, which is the specified number of bytes of `STREAM_TYPE`.
+
+        The simplest way to implement this protocol is the following:
+
+        1. Read 8 bytes.
+        2. Choose `stdout` or `stderr` depending on the first byte.
+        3. Extract the frame size from the last four bytes.
+        4. Read the extracted size and output it on the correct output.
+        5. Goto 1.
+
+        ### Stream format when using a TTY
+
+        When the TTY setting is enabled in [`POST /containers/create`](#operation/ContainerCreate), the stream is not multiplexed. The data exchanged over the hijacked connection is simply the raw data from the process PTY and client's `stdin`.
+
+      operationId: "ContainerAttach"
+      produces:
+        - "application/vnd.raw-stream"
+      responses:
+        101:
+          description: "no error, hints proxy about hijacking"
+        200:
+          description: "no error, no upgrade header found"
+        400:
+          description: "bad parameter"
+          schema:
+            $ref: "#/definitions/Error"
+        404:
+          description: "no such container"
+          schema:
+            $ref: "#/definitions/Error"
+          examples:
+            application/json:
+              message: "No such container: c2ada9df5af8"
+        500:
+          description: "server error"
+          schema:
+            $ref: "#/definitions/Error"
+      parameters:
+        - name: "id"
+          in: "path"
+          required: true
+          description: "ID or name of the container"
+          type: "string"
+        - name: "detachKeys"
+          in: "query"
+          description: "Override the key sequence for detaching a container.Format is a single character `[a-Z]` or `ctrl-<value>` where `<value>` is one of: `a-z`, `@`, `^`, `[`, `,` or `_`."
+          type: "string"
+        - name: "logs"
+          in: "query"
+          description: |
+            Replay previous logs from the container.
+
+            This is useful for attaching to a container that has started and you want to output everything since the container started.
+
+            If `stream` is also enabled, once all the previous output has been returned, it will seamlessly transition into streaming current output.
+          type: "boolean"
+          default: false
+        - name: "stream"
+          in: "query"
+          description: "Stream attached streams from the time the request was made onwards"
+          type: "boolean"
+          default: false
+        - name: "stdin"
+          in: "query"
+          description: "Attach to `stdin`"
+          type: "boolean"
+          default: false
+        - name: "stdout"
+          in: "query"
+          description: "Attach to `stdout`"
+          type: "boolean"
+          default: false
+        - name: "stderr"
+          in: "query"
+          description: "Attach to `stderr`"
+          type: "boolean"
+          default: false
+      tags: ["Container"]
+  /containers/{id}/update:
+    post:
+      summary: "Update the configurations of a container"
+      operationId: "ContainerUpdate"
+      parameters:
+        - $ref: "#/parameters/id"
+        - name: "updateConfig"
+          in: "body"
+          schema:
+            $ref: "#/definitions/UpdateConfig"
+      responses:
+        200:
+          description: "no error"
+        400:
+          description: "bad parameter"
+          schema:
+            $ref: "#/definitions/Error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      tags: ["Container"]
+  /containers/{id}/upgrade:
+      post:
+        summary: "Upgrade a container with new image and args"
+        operationId: "ContainerUpgrade"
+        parameters:
+          - $ref: "#/parameters/id"
+          - name: "upgradeConfig"
+            in: "body"
+            schema:
+              $ref: "#/definitions/ContainerUpgradeConfig"
+        responses:
+          200:
+            description: "no error"
+          400:
+            description: "bad parameter"
+            schema:
+              $ref: "#/definitions/Error"
+          404:
+            $ref: "#/responses/404ErrorResponse"
+          500:
+            $ref: "#/responses/500ErrorResponse"
+        tags: ["Container"]
+
+  /volumes:
+    get:
+      summary: "List volumes"
+      operationId: "VolumeList"
+      produces: ["application/json"]
+      responses:
+        200:
+          description: "Summary volume data that matches the query"
+          schema:
+            $ref: "#/definitions/VolumeListResp"
+          examples:
+            application/json:
+              Volumes:
+                - CreatedAt: "2017-07-19T12:00:26Z"
+                  Name: "tardis"
+                  Driver: "local"
+                  Mountpoint: "/var/lib/pouch/volumes/tardis"
+                  Labels:
+                    com.example.some-label: "some-value"
+                    com.example.some-other-label: "some-other-value"
+                  Scope: "local"
+                  Options:
+                    device: "tmpfs"
+                    o: "size=100m,uid=1000"
+                    type: "tmpfs"
+              Warnings: []
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "filters"
+          in: "query"
+          description: |
+            JSON encoded value of the filters (a `map[string][]string`) to
+            process on the volumes list. Available filters:
+
+            - `dangling=<boolean>` When set to `true` (or `1`), returns all
+               volumes that are not in use by a container. When set to `false`
+               (or `0`), only volumes that are in use by one or more
+               containers are returned.
+            - `driver=<volume-driver-name>` Matches volumes based on their driver.
+            - `label=<key>` or `label=<key>:<value>` Matches volumes based on
+               the presence of a `label` alone or a `label` and a value.
+            - `name=<volume-name>` Matches all or part of a volume name.
+          type: "string"
+          format: "json"
+      tags: ["Volume"]
+
+  /volumes/create:
+    post:
+      summary: "Create a volume"
+      operationId: "VolumeCreate"
+      consumes: ["application/json"]
+      produces: ["application/json"]
+      responses:
+        201:
+          description: "The volume was created successfully"
+          schema:
+            $ref: "#/definitions/VolumeInfo"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "body"
+          in: "body"
+          required: true
+          description: "Volume configuration"
+          schema:
+            $ref: "#/definitions/VolumeCreateConfig"
+      tags: ["Volume"]
+
+  /volumes/{id}:
+    get:
+      summary: "Inspect a volume"
+      operationId: "VolumeInspect"
+      produces: ["application/json"]
+      responses:
+        200:
+          description: "No error"
+          schema:
+            $ref: "#/definitions/VolumeInfo"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - $ref: "#/parameters/id"
+      tags: ["Volume"]
+
+    delete: 
+      summary: "Delete a volume"
+      operationId: "VolumeDelete"
+      responses:
+        204:
+          description: "No error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - $ref: "#/parameters/id"
+      tags: ["Volume"]
+
+  /networks/create:
+    post:
+      summary: "Create a network"
+      operationId: "NetworkCreate"
+      consumes: ["application/json"]
+      produces: ["application/json"]
+      responses:
+        201:
+          description: "The network was created successfully"
+          schema:
+            $ref: "#/definitions/NetworkCreateResp"
+        400:
+          description: "bad parameter"
+          schema:
+            $ref: "#/definitions/Error"
+        409:
+          description: "name already in use"
+          schema:
+            $ref: "#/definitions/Error"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - name: "NetworkCreateConfig"
+          in: "body"
+          required: true
+          description: "Network configuration"
+          schema:
+            $ref: "#/definitions/NetworkCreateConfig"
+      tags: ["Network"]
+
+  /networks/{id}:
+    get:
+      summary: "Inspect a network"
+      operationId: "NetworkInspect"
+      produces:
+        - "application/json"
+      responses:
+        200:
+          description: "No error"
+          schema:
+            $ref: "#/definitions/NetworkInspectResp"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - $ref: "#/parameters/id"
+      tags: ["Network"]
+
+    delete:
+      summary: "Remove a network"
+      operationId: "NetworkDelete"
+      responses:
+        204:
+          description: "No error"
+        403:
+          description: "operation not supported for pre-defined networks"
+          schema:
+            $ref: "#/definitions/Error"
+        404:
+          $ref: "#/responses/404ErrorResponse"
+        500:
+          $ref: "#/responses/500ErrorResponse"
+      parameters:
+        - $ref: "#/parameters/id"
+      tags: ["Network"]
+
+  /networks:
+      get:
+        summary: "List networks"
+        operationId: "NetworkList"
+        produces: ["application/json"]
+        responses:
+          200:
+            description: "Summary networks that matches the query"
+            schema:
+                $ref: "#/definitions/NetworkResource"
+          500:
+            $ref: "#/responses/500ErrorResponse"
+        tags: ["Network"]
+
+definitions:
+  Error:
+    type: "object"
+    properties:
+      message:
+        type: string
+
+  SystemVersion:
+    type: "object"
+    properties:
+      Version:
+        type: "string"
+        description: "version of Pouch Daemon"
+        example: "0.1.2"
+      ApiVersion:
+        type: "string"
+        description: "Api Version held by daemon"
+        example: ""
+      GitCommit:
+        type: "string"
+        description: "Commit ID held by the latest commit operation"
+        example: ""
+      GoVersion:
+        type: "string"
+        description: "version of Go runtime"
+        example: "1.8.3"
+      Os:
+        type: "string"
+        description: "Operating system type of underlying system"
+        example: "linux"
+      Arch:
+        type: "string"
+        description: "Arch type of underlying hardware"
+        example: "amd64"
+      KernelVersion:
+        type: "string"
+        description: "Operating system kernel version"
+        example: "3.13.0-106-generic"
+      BuildTime:
+        type: "string"
+        description: "The time when this binary of daemon is built"
+        example: "2017-08-29T17:41:57.729792388+00:00"
+
+  SystemInfo:
+    type: "object"
+    properties:
+      ID:
+        description: |
+          Unique identifier of the daemon.
+
+          <p><br /></p>
+
+          > **Note**: The format of the ID itself is not part of the API, and
+          > should not be considered stable.
+        type: "string"
+        example: "7TRN:IPZB:QYBB:VPBQ:UMPP:KARE:6ZNR:XE6T:7EWV:PKF4:ZOJD:TPYS"
+      Containers:
+        description: "Total number of containers on the host."
+        type: "integer"
+        example: 14
+      ContainersRunning:
+        description: |
+          Number of containers with status `"running"`.
+        type: "integer"
+        example: 3
+      ContainersPaused:
+        description: |
+          Number of containers with status `"paused"`.
+        type: "integer"
+        example: 1
+      ContainersStopped:
+        description: |
+          Number of containers with status `"stopped"`.
+        type: "integer"
+        example: 10
+      Images:
+        description: |
+          Total number of images on the host.
+
+          Both _tagged_ and _untagged_ (dangling) images are counted.
+        type: "integer"
+        example: 508
+      Driver:
+        description: "Name of the storage driver in use."
+        type: "string"
+        example: "overlay2"
+      DriverStatus:
+        description: |
+          Information specific to the storage driver, provided as
+          "label" / "value" pairs.
+
+          This information is provided by the storage driver, and formatted
+          in a way consistent with the output of `pouch info` on the command
+          line.
+
+          <p><br /></p>
+
+          > **Note**: The information returned in this field, including the
+          > formatting of values and labels, should not be considered stable,
+          > and may change without notice.
+        type: "array"
+        items:
+          type: "array"
+          items:
+            type: "string"
+        example:
+          - ["Backing Filesystem", "extfs"]
+          - ["Supports d_type", "true"]
+          - ["Native Overlay Diff", "true"]
+      PouchRootDir:
+        description: |
+          Root directory of persistent Pouch state.
+
+          Defaults to `/var/lib/pouch` on Linux.
+        type: "string"
+        example: "/var/lib/pouch"
+      Debug:
+        description: "Indicates if the daemon is running in debug-mode / with debug-level logging enabled."
+        type: "boolean"
+        example: true
+      LoggingDriver:
+        description: |
+          The logging driver to use as a default for new containers.
+        type: "string"
+      CgroupDriver:
+        description: |
+          The driver to use for managing cgroups.
+        type: "string"
+        x-nullable: false
+        enum: ["cgroupfs", "systemd"]
+        default: "cgroupfs"
+        example: "cgroupfs"
+      KernelVersion:
+        description: |
+          Kernel version of the host.
+          On Linux, this information obtained from `uname`.
+        type: "string"
+      OperatingSystem:
+        description: |
+          Name of the host's operating system, for example: "Ubuntu 16.04.2 LTS".
+        type: "string"
+        example: "Alpine Linux v3.5"
+      OSType:
+        description: |
+          Generic type of the operating system of the host, as returned by the
+          Go runtime (`GOOS`).
+
+          Currently returned value is "linux". A full list of
+          possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).
+        type: "string"
+        example: "linux"
+      Architecture:
+        description: |
+          Hardware architecture of the host, as returned by the Go runtime
+          (`GOARCH`).
+
+          A full list of possible values can be found in the [Go documentation](https://golang.org/doc/install/source#environment).
+        type: "string"
+        example: "x86_64"
+      NCPU:
+        description: |
+          The number of logical CPUs usable by the daemon.
+
+          The number of available CPUs is checked by querying the operating
+          system when the daemon starts. Changes to operating system CPU
+          allocation after the daemon is started are not reflected.
+        type: "integer"
+        example: 4
+      MemTotal:
+        description: |
+          Total amount of physical memory available on the host, in kilobytes (kB).
+        type: "integer"
+        format: "int64"
+        example: 2095882240
+
+      IndexServerAddress:
+        description: |
+          Address / URL of the index server that is used for image search,
+          and as a default for user authentication.
+        type: "string"
+      DefaultRegistry:
+        description: |
+          default registry can be defined by user.
+        type: "string"
+      RegistryConfig:
+        $ref: "#/definitions/RegistryServiceConfig"
+      HttpProxy:
+        description: |
+          HTTP-proxy configured for the daemon. This value is obtained from the
+          [`HTTP_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
+
+          Containers do not automatically inherit this configuration.
+        type: "string"
+        example: "http://user:pass@proxy.corp.example.com:8080"
+      HttpsProxy:
+        description: |
+          HTTPS-proxy configured for the daemon. This value is obtained from the
+          [`HTTPS_PROXY`](https://www.gnu.org/software/wget/manual/html_node/Proxies.html) environment variable.
+
+          Containers do not automatically inherit this configuration.
+        type: "string"
+        example: "https://user:pass@proxy.corp.example.com:4443"
+      Name:
+        description: "Hostname of the host."
+        type: "string"
+        example: "node5.corp.example.com"
+      Labels:
+        description: |
+          User-defined labels (key/value metadata) as set on the daemon.
+        type: "array"
+        items:
+          type: "string"
+        example: ["storage=ssd", "production"]
+      ExperimentalBuild:
+        description: |
+          Indicates if experimental features are enabled on the daemon.
+        type: "boolean"
+        example: true
+      ServerVersion:
+        description: |
+          Version string of the daemon.
+        type: "string"
+        example: "17.06.0-ce"
+      Runtimes:
+        description: |
+          List of [OCI compliant](https://github.com/opencontainers/runtime-spec)
+          runtimes configured on the daemon. Keys hold the "name" used to
+          reference the runtime.
+
+          The Pouch daemon relies on an OCI compliant runtime (invoked via the
+          `containerd` daemon) as its interface to the Linux kernel namespaces,
+          cgroups, and SELinux.
+
+          The default runtime is `runc`, and automatically configured. Additional
+          runtimes can be configured by the user and will be listed here.
+        type: "object"
+        additionalProperties:
+          $ref: "#/definitions/Runtime"
+        default:
+          runc:
+            path: "pouch-runc"
+        example:
+          runc:
+            path: "pouch-runc"
+          runc-master:
+            path: "/go/bin/runc"
+          custom:
+            path: "/usr/local/bin/my-oci-runtime"
+            runtimeArgs: ["--debug", "--systemd-cgroup=false"]
+      DefaultRuntime:
+        description: |
+          Name of the default OCI runtime that is used when starting containers.
+          The default can be overridden per-container at create time.
+        type: "string"
+        x-nullable: false
+        default: "runc"
+        example: "runc"
+      LiveRestoreEnabled:
+        description: |
+          Indicates if live restore is enabled.
+          If enabled, containers are kept running when the daemon is shutdown
+          or upon daemon start if running containers are detected.
+        type: "boolean"
+        x-nullable: false
+        default: false
+        example: false
+      LxcfsEnabled:
+        description: |
+          Indicates if lxcfs is enabled.
+        type: "boolean"
+        x-nullable: false
+        default: false
+        example: false
+      ContainerdCommit:
+        $ref: "#/definitions/Commit"
+      RuncCommit:
+        $ref: "#/definitions/Commit"
+      SecurityOptions:
+        description: |
+          List of security features that are enabled on the daemon, such as
+          apparmor, seccomp, SELinux, and user-namespaces (userns).
+
+          Additional configuration options for each security feature may
+          be present, and are included as a comma-separated list of key/value
+          pairs.
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - "name=apparmor"
+          - "name=seccomp,profile=default"
+          - "name=selinux"
+          - "name=userns"
+      ListenAddresses:
+        description: "List of addresses the pouchd listens on"
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - ["unix:///var/run/pouchd.sock", "tcp://0.0.0.0:4243"]
+
+  DaemonUpdateConfig:
+    type: "object"
+    properties:
+      Labels:
+        description: "Labels indentified the attributes of daemon"
+        type: "array"
+        items:
+          type: "string"
+        example: ["storage=ssd", "zone=hangzhou"]
+      ImageProxy:
+        description: "Image proxy used to pull image."
+        type: "string"
+
+  RegistryServiceConfig:
+    description: |
+      RegistryServiceConfig stores daemon registry services configuration.
+    type: "object"
+    x-nullable: true
+    properties:
+      AllowNondistributableArtifactsCIDRs:
+        description: |
+          List of IP ranges to which nondistributable artifacts can be pushed,
+          using the CIDR syntax [RFC 4632](https://tools.ietf.org/html/4632).
+
+          Some images contain artifacts whose distribution is restricted by license.
+          When these images are pushed to a registry, restricted artifacts are not
+          included.
+
+          This configuration override this behavior, and enables the daemon to
+          push nondistributable artifacts to all registries whose resolved IP
+          address is within the subnet described by the CIDR syntax.
+
+          This option is useful when pushing images containing
+          nondistributable artifacts to a registry on an air-gapped network so
+          hosts on that network can pull the images without connecting to
+          another server.
+
+          > **Warning**: Nondistributable artifacts typically have restrictions
+          > on how and where they can be distributed and shared. Only use this
+          > feature to push artifacts to private registries and ensure that you
+          > are in compliance with any terms that cover redistributing
+          > nondistributable artifacts.
+
+        type: "array"
+        items:
+          type: "string"
+        example: ["::1/128", "127.0.0.0/8"]
+      AllowNondistributableArtifactsHostnames:
+        description: |
+          List of registry hostnames to which nondistributable artifacts can be
+          pushed, using the format `<hostname>[:<port>]` or `<IP address>[:<port>]`.
+
+          Some images (for example, Windows base images) contain artifacts
+          whose distribution is restricted by license. When these images are
+          pushed to a registry, restricted artifacts are not included.
+
+          This configuration override this behavior for the specified
+          registries.
+
+          This option is useful when pushing images containing
+          nondistributable artifacts to a registry on an air-gapped network so
+          hosts on that network can pull the images without connecting to
+          another server.
+
+          > **Warning**: Nondistributable artifacts typically have restrictions
+          > on how and where they can be distributed and shared. Only use this
+          > feature to push artifacts to private registries and ensure that you
+          > are in compliance with any terms that cover redistributing
+          > nondistributable artifacts.
+        type: "array"
+        items:
+          type: "string"
+        example: ["registry.internal.corp.example.com:3000", "[2001:db8:a0b:12f0::1]:443"]
+      InsecureRegistryCIDRs:
+        description: |
+          List of IP ranges of insecure registries, using the CIDR syntax
+          ([RFC 4632](https://tools.ietf.org/html/4632)). Insecure registries
+          accept un-encrypted (HTTP) and/or untrusted (HTTPS with certificates
+          from unknown CAs) communication.
+
+          By default, local registries (`127.0.0.0/8`) are configured as
+          insecure. All other registries are secure. Communicating with an
+          insecure registry is not possible if the daemon assumes that registry
+          is secure.
+
+          This configuration override this behavior, insecure communication with
+          registries whose resolved IP address is within the subnet described by
+          the CIDR syntax.
+
+          Registries can also be marked insecure by hostname. Those registries
+          are listed under `IndexConfigs` and have their `Secure` field set to
+          `false`.
+
+          > **Warning**: Using this option can be useful when running a local
+          > registry, but introduces security vulnerabilities. This option
+          > should therefore ONLY be used for testing purposes. For increased
+          > security, users should add their CA to their system's list of trusted
+          > CAs instead of enabling this option.
+        type: "array"
+        items:
+          type: "string"
+        example: ["::1/128", "127.0.0.0/8"]
+      IndexConfigs:
+        type: "object"
+        additionalProperties:
+          $ref: "#/definitions/IndexInfo"
+        example:
+          "127.0.0.1:5000":
+            "Name": "127.0.0.1:5000"
+            "Mirrors": []
+            "Secure": false
+            "Official": false
+          "[2001:db8:a0b:12f0::1]:80":
+            "Name": "[2001:db8:a0b:12f0::1]:80"
+            "Mirrors": []
+            "Secure": false
+            "Official": false
+          "registry.internal.corp.example.com:3000":
+            Name: "registry.internal.corp.example.com:3000"
+            Mirrors: []
+            Secure: false
+            Official: false
+      Mirrors:
+        description: "List of registry URLs that act as a mirror for the official registry."
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - "https://hub-mirror.corp.example.com:5000/"
+          - "https://[2001:db8:a0b:12f0::1]/"
+
+  IndexInfo:
+    description:
+      IndexInfo contains information about a registry.
+    type: "object"
+    x-nullable: true
+    properties:
+      Name:
+        description: |
+          Name of the registry.
+        type: "string"
+      Mirrors:
+        description: |
+          List of mirrors, expressed as URIs.
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - "https://hub-mirror.corp.example.com:5000/"
+      Secure:
+        description: |
+          Indicates if the the registry is part of the list of insecure
+          registries.
+
+          If `false`, the registry is insecure. Insecure registries accept
+          un-encrypted (HTTP) and/or untrusted (HTTPS with certificates from
+          unknown CAs) communication.
+
+          > **Warning**: Insecure registries can be useful when running a local
+          > registry. However, because its use creates security vulnerabilities
+          > it should ONLY be enabled for testing purposes. For increased
+          > security, users should add their CA to their system's list of
+          > trusted CAs instead of enabling this option.
+        type: "boolean"
+        example: true
+      Official:
+        description: |
+          Indicates whether this is an official registry.
+        type: "boolean"
+        example: true
+
+  Runtime:
+    description: |
+      Runtime describes an [OCI compliant](https://github.com/opencontainers/runtime-spec)
+      runtime.
+
+      The runtime is invoked by the daemon via the `containerd` daemon. OCI
+      runtimes act as an interface to the Linux kernel namespaces, cgroups,
+      and SELinux.
+    type: "object"
+    properties:
+      path:
+        description: |
+          Name and, optional, path, of the OCI executable binary.
+
+          If the path is omitted, the daemon searches the host's `$PATH` for the
+          binary and uses the first result.
+        type: "string"
+        example: "/usr/local/bin/my-oci-runtime"
+      runtimeArgs:
+        description: |
+          List of command-line arguments to pass to the runtime when invoked.
+        type: "array"
+        x-nullable: true
+        items:
+          type: "string"
+        example: ["--debug", "--systemd-cgroup=false"]
+
+  Commit:
+    description: |
+      Commit holds the Git-commit (SHA1) that a binary was built from, as
+      reported in the version-string of external tools, such as `containerd`,
+      or `runC`.
+    type: "object"
+    properties:
+      ID:
+        description: "Actual commit ID of external tool."
+        type: "string"
+        example: "cfb82a876ecc11b5ca0977d1733adbe58599088a"
+      Expected:
+        description: |
+          Commit ID of external tool expected by pouchd as set at build time.
+        type: "string"
+        example: "2d41c047c83e09a6d61d464906feb2a2f3c52aa4"
+
+  AuthConfig:
+    type: "object"
+    properties:
+      Username:
+        type: "string"
+      Password:
+        type: "string"
+      Auth:
+        type: "string"
+      ServerAddress:
+        type: "string"
+      IdentityToken:
+        type: "string"
+        description: "IdentityToken is used to authenticate the user and get an access token for the registry"
+      RegistryToken:
+        type: "string"
+        description: "RegistryToken is a bearer token to be sent to a registry"
+
+  AuthResponse:
+    description: "The response returned by login to a registry"
+    type: "object"
+    required: [Status]
+    properties:
+      Status:
+        description: "The status of the authentication"
+        type: "string"
+        x-nullable: false
+      IdentityToken:
+        description: "An opaque token used to authenticate a user after a successful login"
+        type: "string"
+        x-nullable: false
+
+  ContainerCreateConfig:
+    description: | 
+      ContainerCreateConfig is used for API "POST /containers/create".
+      It wraps all kinds of config used in container creation.
+      It can be used to encode client params in client and unmarshal request body in daemon side.
+    allOf:
+      - $ref: "#/definitions/ContainerConfig"
+      - type: "object"
+        properties:
+          HostConfig:
+            $ref: "#/definitions/HostConfig"
+          NetworkingConfig:
+            $ref: "#/definitions/NetworkingConfig"
+
+  ContainerConfig:
+    type: "object"
+    description: "Configuration for a container that is portable between hosts"
+    required: 
+      - Image
+    properties:
+      Hostname:
+        description: "The hostname to use for the container, as a valid RFC 1123 hostname."
+        type: "string"
+        format: hostname
+        minLength: 1
+      Domainname:
+        description: "The domain name to use for the container."
+        type: "string"
+      User:
+        description: "The user that commands are run as inside the container."
+        type: "string"
+      AttachStdin:
+        description: "Whether to attach to `stdin`."
+        type: "boolean"
+        x-nullable: false
+      AttachStdout:
+        description: "Whether to attach to `stdout`."
+        type: "boolean"
+        x-nullable: false
+        default: true
+      AttachStderr:
+        description: "Whether to attach to `stderr`."
+        type: "boolean"
+        x-nullable: false
+        default: true
+      ExposedPorts:
+        description: "An object mapping ports to an empty object in the form:`{<port>/<tcp|udp>: {}}`"
+        type: "object"
+        additionalProperties:
+          type: "object"
+          enum:
+            - {}
+          default: {}
+      Tty:
+        description: "Attach standard streams to a TTY, including `stdin` if it is not closed."
+        type: "boolean"
+        x-nullable: false
+      OpenStdin:
+        description: "Open `stdin`"
+        type: "boolean"
+        x-nullable: false
+      StdinOnce:
+        description: "Close `stdin` after one attached client disconnects"
+        type: "boolean"
+        x-nullable: false
+      Env:
+        description: |
+          A list of environment variables to set inside the container in the form `["VAR=value", ...]`. A variable without `=` is removed from the environment, rather than to have an empty value.
+        type: "array"
+        items:
+          type: "string"
+      Cmd:
+        description: "Command to run specified an array of strings."
+        type: "array"
+        items:
+          type: "string"
+      ArgsEscaped:
+        description: "Command is already escaped (Windows only)"
+        type: "boolean"
+        x-nullable: false
+      Image:
+        description: "The name of the image to use when creating the container"
+        type: "string"
+        x-nullable: false
+      Volumes:
+        description: "An object mapping mount point paths inside the container to empty objects."
+        type: "object"
+        additionalProperties:
+          type: "object"
+          enum:
+            - {}
+          default: {}
+      WorkingDir:
+        description: "The working directory for commands to run in."
+        type: "string"
+      Entrypoint:
+        description: |
+          The entry point for the container as a string or an array of strings.
+          If the array consists of exactly one empty string (`[""]`) then the entry point is reset to system default.
+        type: "array"
+        items:
+          type: "string"
+      NetworkDisabled:
+        description: "Disable networking for the container."
+        type: "boolean"
+      MacAddress:
+        description: "MAC address of the container."
+        type: "string"
+      OnBuild:
+        description: "`ONBUILD` metadata that were defined."
+        type: "array"
+        items:
+          type: "string"
+      Labels:
+        description: "User-defined key/value metadata."
+        type: "object"
+        additionalProperties:
+          type: "string"
+      StopSignal:
+        description: "Signal to stop a container as a string or unsigned integer."
+        type: "string"
+        default: "SIGTERM"
+        x-nullable: false
+      StopTimeout:
+        description: "Timeout to stop a container in seconds."
+        type: "integer"
+        default: 10
+      Shell:
+        description: "Shell for when `RUN`, `CMD`, and `ENTRYPOINT` uses a shell."
+        type: "array"
+        items:
+          type: "string"
+      Rich:
+        type: "boolean"
+        description: "Whether to start container in rich container mode. (default false)"
+        x-nullable: false
+      RichMode:
+        type: "string"
+        description: "Choose one rich container mode.(default dumb-init)"
+        enum:
+          - "dumb-init"
+          - "sbin-init"
+          - "systemd"
+      InitScript:
+        type: "string"
+        description: "Initial script executed in container. The script will be executed before entrypoint or command"
+      DiskQuota:
+        type: "object"
+        description: "Set disk quota for container"
+        x-nullable: true
+        additionalProperties:
+          type: "string"
+      SpecAnnotation:
+        description: "annotations send to runtime spec."
+        type: "object"
+        additionalProperties:
+          type: "string"
+      QuotaID:
+        type: "string"
+        description: "set disk quota by specified quota id, if id < 0, it means pouchd alloc a unique quota id"
+ 
+  ContainerCreateResp:
+    description: "response returned by daemon when container create successfully"
+    type: "object"
+    required: [Id, Warnings]
+    properties:
+      Id:
+        description: "The ID of the created container"
+        type: "string"
+        x-nullable: false
+      Name:
+        description: "The name of the created container"
+        type: "string"
+      Warnings:
+        description: "Warnings encountered when creating the container"
+        type: "array"
+        x-nullable: false
+        items:
+          type: "string"
+
+  HostConfig:
+    description: "Container configuration that depends on the host we are running on"
+    type: "object"
+    allOf:
+      - properties:
+          # Applicable to all platforms
+          Binds:
+            type: "array"
+            description: |
+              A list of volume bindings for this container. Each volume binding is a string in one of these forms:
+
+              - `host-src:container-dest` to bind-mount a host path into the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
+              - `host-src:container-dest:ro` to make the bind mount read-only inside the container. Both `host-src`, and `container-dest` must be an _absolute_ path.
+              - `volume-name:container-dest` to bind-mount a volume managed by a volume driver into the container. `container-dest` must be an _absolute_ path.
+              - `volume-name:container-dest:ro` to mount the volume read-only inside the container.  `container-dest` must be an _absolute_ path.
+            items:
+              type: "string"
+          ContainerIDFile:
+            type: "string"
+            description: "Path to a file where the container ID is written"
+          LogConfig:
+            type: "object"
+            description: "The logging configuration for this container"
+            properties:
+              Type:
+                type: "string"
+                enum:
+                  - "json-file"
+                  - "syslog"
+                  - "journald"
+                  - "gelf"
+                  - "fluentd"
+                  - "awslogs"
+                  - "splunk"
+                  - "etwlogs"
+                  - "none"
+              Config:
+                type: "object"
+                additionalProperties:
+                  type: "string"
+          RestartPolicy:
+            type: "object"
+            description: "Restart policy to be used to manage the container"
+            $ref: "#/definitions/RestartPolicy"
+          NetworkMode:
+            type: "string"
+            description: "Network mode to use for this container. Supported standard values are: `bridge`, `host`, `none`, and `container:<name|id>`. Any other value is taken as a custom network's name to which this container should connect to."
+          PortBindings:
+            type: "object"
+            description: "A map of exposed container ports and the host port they should map to."
+            $ref: "#/definitions/PortMap"
+          AutoRemove:
+            type: "boolean"
+            description: "Automatically remove the container when the container's process exits. This has no effect if `RestartPolicy` is set."
+          VolumeDriver:
+            type: "string"
+            description: "Driver that this container uses to mount volumes."
+          VolumesFrom:
+            type: "array"
+            description: "A list of volumes to inherit from another container, specified in the form `<container name>[:<ro|rw>]`."
+            items:
+              type: "string"
+          CapAdd:
+            type: "array"
+            description: "A list of kernel capabilities to add to the container."
+            items:
+              type: "string"
+          CapDrop:
+            type: "array"
+            description: "A list of kernel capabilities to drop from the container."
+            items:
+              type: "string"
+          Dns:
+            type: "array"
+            description: "A list of DNS servers for the container to use."
+            items:
+              type: "string"
+          DnsOptions:
+            type: "array"
+            description: "A list of DNS options."
+            items:
+              type: "string"
+          DnsSearch:
+            type: "array"
+            description: "A list of DNS search domains."
+            items:
+              type: "string"
+          ExtraHosts:
+            type: "array"
+            description: |
+              A list of hostnames/IP mappings to add to the container's `/etc/hosts` file. Specified in the form `["hostname:IP"]`.
+            items:
+              type: "string"
+          GroupAdd:
+            type: "array"
+            description: "A list of additional groups that the container process will run as."
+            items:
+              type: "string"
+          IpcMode:
+            type: "string"
+            description: |
+                    IPC sharing mode for the container. Possible values are:
+                    - `"none"`: own private IPC namespace, with /dev/shm not mounted
+                    - `"private"`: own private IPC namespace
+                    - `"shareable"`: own private IPC namespace, with a possibility to share it with other containers
+                    - `"container:<name|id>"`: join another (shareable) container's IPC namespace
+                    - `"host"`: use the host system's IPC namespace
+                    If not specified, daemon default is used, which can either be `"private"`
+                    or `"shareable"`, depending on daemon version and configuration.
+          Cgroup:
+            type: "string"
+            description: "Cgroup to use for the container."
+          Links:
+            type: "array"
+            description: "A list of links for the container in the form `container_name:alias`."
+            items:
+              type: "string"
+          OomScoreAdj:
+            type: "integer"
+            description: |
+                An integer value containing the score given to the container in order to tune OOM killer preferences.
+                The range is in [-1000, 1000].
+            type: "integer"
+            format: "int"
+            x-nullable: false
+            minimum: -1000
+            maximum: 1000
+          PidMode:
+            type: "string"
+            description: |
+              Set the PID (Process) Namespace mode for the container. It can be either:
+              - `"container:<name|id>"`: joins another container's PID namespace
+              - `"host"`: use the host's PID namespace inside the container
+          Privileged:
+            type: "boolean"
+            description: "Gives the container full access to the host."
+          PublishAllPorts:
+            type: "boolean"
+            description: "Allocates a random host port for all of a container's exposed ports."
+          ReadonlyRootfs:
+            type: "boolean"
+            description: "Mount the container's root filesystem as read only."
+          SecurityOpt:
+            type: "array"
+            description: "A list of string values to customize labels for MLS systems, such as SELinux."
+            items:
+              type: "string"
+          StorageOpt:
+            type: "object"
+            description: |
+              Storage driver options for this container, in the form `{"size": "120G"}`.
+            additionalProperties:
+              type: "string"
+          Tmpfs:
+            type: "object"
+            description: |
+              A map of container directories which should be replaced by tmpfs mounts, and their corresponding mount options. For example: `{ "/run": "rw,noexec,nosuid,size=65536k" }`.
+            additionalProperties:
+              type: "string"
+          UTSMode:
+            type: "string"
+            description: "UTS namespace to use for the container."
+          UsernsMode:
+            type: "string"
+            description: "Sets the usernamespace mode for the container when usernamespace remapping option is enabled."
+          ShmSize:
+            type: "integer"
+            description: "Size of `/dev/shm` in bytes. If omitted, the system uses 64MB."
+            minimum: 0
+          Sysctls:
+            type: "object"
+            description: |
+              A list of kernel parameters (sysctls) to set in the container. For example: `{"net.ipv4.ip_forward": "1"}`
+            additionalProperties:
+              type: "string"
+          Runtime:
+            type: "string"
+            description: "Runtime to use with this container."
+          # Applicable to Windows
+          ConsoleSize:
+            type: "array"
+            description: "Initial console size, as an `[height, width]` array. (Windows only)"
+            minItems: 2
+            maxItems: 2
+            items:
+              type: "integer"
+              minimum: 0
+          Isolation:
+            type: "string"
+            description: "Isolation technology of the container. (Windows only)"
+            enum:
+              - "default"
+              - "process"
+              - "hyperv"
+          EnableLxcfs:
+            description: "Whether to enable lxcfs."
+            type: "boolean"
+            x-nullable: false
+          Rich:
+            type: "boolean"
+            description: "Whether to start container in rich container mode. (default false)"
+            x-nullable: false
+          RichMode:
+            type: "string"
+            description: "Choose one rich container mode.(default dumb-init)"
+            enum:
+             - "dumb-init"
+             - "sbin-init"
+             - "systemd"
+          InitScript:
+            type: "string"
+            description: "Initial script executed in container. The script will be executed before entrypoint or command"
+      - $ref: "#/definitions/Resources"
+
+  UpdateConfig:
+    description: "UpdateConfig holds the mutable attributes of a Container. Those attributes can be updated at runtime."
+    allOf:
+      - $ref: "#/definitions/Resources"
+      - properties:
+          RestartPolicy:
+            $ref: "#/definitions/RestartPolicy"
+          Image:
+            type: "string"
+            description: "Image ID or Name"
+          Env:
+            description: |
+              A list of environment variables to set inside the container in the form `["VAR=value", ...]`. A variable without `=` is removed from the environment, rather than to have an empty value.
+            type: "array"
+            items:
+              type: "string"
+          Labels:
+            description: "List of labels set to container."
+            type: "object"
+            additionalProperties:
+              type: "string"
+
+  ContainerUpgradeConfig:
+    description: |
+      ContainerUpgradeConfig is used for API "POST /containers/upgrade".
+      It wraps all kinds of config used in container upgrade.
+      It can be used to encode client params in client and unmarshal request body in daemon side.
+    allOf:
+      - $ref: "#/definitions/ContainerConfig"
+      - type: "object"
+        properties:
+          HostConfig:
+            $ref: "#/definitions/HostConfig"
+
+  Resources:
+    description: "A container's resources (cgroups config, ulimits, etc)"
+    type: "object"
+    properties:
+      # Applicable to all platforms
+      CpuShares:
+        description: "An integer value representing this container's relative CPU weight versus other containers."
+        type: "integer"
+      Memory:
+        description: "Memory limit in bytes."
+        type: "integer"
+        default: 0
+      # Applicable to UNIX platforms
+      CgroupParent:
+        description: "Path to `cgroups` under which the container's `cgroup` is created. If the path is not absolute, the path is considered to be relative to the `cgroups` path of the init process. Cgroups are created if they do not already exist."
+        type: "string"
+      BlkioWeight:
+        description: "Block IO weight (relative weight)."
+        type: "integer"
+        format: "uint16"
+        x-nullable: false
+        minimum: 0
+        maximum: 1000
+      BlkioWeightDevice:
+        description: |
+          Block IO weight (relative device weight) in the form `[{"Path": "device_path", "Weight": weight}]`.
+        type: "array"
+        items:
+          $ref: "#/definitions/WeightDevice"
+      BlkioDeviceReadBps:
+        description: |
+          Limit read rate (bytes per second) from a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
+        type: "array"
+        items:
+          $ref: "#/definitions/ThrottleDevice"
+      BlkioDeviceWriteBps:
+        description: |
+          Limit write rate (bytes per second) to a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
+        type: "array"
+        items:
+          $ref: "#/definitions/ThrottleDevice"
+      BlkioDeviceReadIOps:
+        description: |
+          Limit read rate (IO per second) from a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
+        type: "array"
+        items:
+          $ref: "#/definitions/ThrottleDevice"
+      BlkioDeviceWriteIOps:
+        description: |
+          Limit write rate (IO per second) to a device, in the form `[{"Path": "device_path", "Rate": rate}]`.
+        type: "array"
+        items:
+          $ref: "#/definitions/ThrottleDevice"
+      CpuPeriod:
+        description: |
+          CPU CFS (Completely Fair Scheduler) period.
+          The length of a CPU period in microseconds.
+        type: "integer"
+        format: "int64"
+        minimum: 1000
+        maximum: 1000000
+      CpuQuota:
+        description: |
+          CPU CFS (Completely Fair Scheduler) quota.
+          Microseconds of CPU time that the container can get in a CPU period."
+        type: "integer"
+        format: "int64"
+        minimum: 1000
+      CpuRealtimePeriod:
+        description: "The length of a CPU real-time period in microseconds. Set to 0 to allocate no time allocated to real-time tasks."
+        type: "integer"
+        format: "int64"
+      CpuRealtimeRuntime:
+        description: "The length of a CPU real-time runtime in microseconds. Set to 0 to allocate no time allocated to real-time tasks."
+        type: "integer"
+        format: "int64"
+      CpusetCpus:
+        description: "CPUs in which to allow execution (e.g., `0-3`, `0,1`)"
+        type: "string"
+        example: "0-3"
+      CpusetMems:
+        description: "Memory nodes (MEMs) in which to allow execution (0-3, 0,1). Only effective on NUMA systems."
+        type: "string"
+      Devices:
+        description: "A list of devices to add to the container."
+        type: "array"
+        items:
+          $ref: "#/definitions/DeviceMapping"
+      DeviceCgroupRules:
+        description: "a list of cgroup rules to apply to the container"
+        type: "array"
+        items:
+          type: "string"
+          example: "c 13:* rwm"
+      DiskQuota:
+        description: "Disk limit (in bytes)."
+        type: "integer"
+        format: "int64"
+      KernelMemory:
+        description: "Kernel memory limit in bytes."
+        type: "integer"
+        format: "int64"
+      MemoryReservation:
+        description: "Memory soft limit in bytes."
+        type: "integer"
+        format: "int64"
+      MemorySwap:
+        description: "Total memory limit (memory + swap). Set as `-1` to enable unlimited swap."
+        type: "integer"
+        format: "int64"
+      MemorySwappiness:
+        description: "Tune a container's memory swappiness behavior. Accepts an integer between 0 and 100."
+        type: "integer"
+        format: "int64"
+        minimum: -1
+        maximum: 100
+      NanoCPUs:
+        description: "CPU quota in units of 10<sup>-9</sup> CPUs."
+        type: "integer"
+        format: "int64"
+      OomKillDisable:
+        description: "Disable OOM Killer for the container."
+        type: "boolean"
+        x-nullable: true
+      PidsLimit:
+        description: |
+          Tune a container's pids limit. Set -1 for unlimited. Only on Linux 4.4 does this paramter support.
+        type: "integer"
+        format: "int64"
+      Ulimits:
+        description: |
+          A list of resource limits to set in the container. For example: `{"Name": "nofile", "Soft": 1024, "Hard": 2048}`"
+        type: "array"
+        items:
+          type: "object"
+          properties:
+            Name:
+              description: "Name of ulimit"
+              type: "string"
+            Soft:
+              description: "Soft limit"
+              type: "integer"
+            Hard:
+              description: "Hard limit"
+              type: "integer"
+      # Applicable to Windows
+      CpuCount:
+        description: |
+          The number of usable CPUs (Windows only).
+          On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is `CPUCount` first, then `CPUShares`, and `CPUPercent` last.
+        type: "integer"
+        format: "int64"
+      CpuPercent:
+        description: |
+          The usable percentage of the available CPUs (Windows only).
+          On Windows Server containers, the processor resource controls are mutually exclusive. The order of precedence is `CPUCount` first, then `CPUShares`, and `CPUPercent` last.
+        type: "integer"
+        format: "int64"
+      IOMaximumIOps:
+        description: "Maximum IOps for the container system drive (Windows only)"
+        type: "integer"
+        format: "uint64"
+      IOMaximumBandwidth:
+        description: "Maximum IO in bytes per second for the container system drive (Windows only)"
+        type: "integer"
+        format: "uint64"
+      IntelRdtL3Cbm:
+        description: "IntelRdtL3Cbm specifies settings for Intel RDT/CAT group that the container is placed into to limit the resources (e.g., L3 cache) the container has available."
+        type: "string"
+
+      # applicable to AliKenerl 4.9
+      ScheLatSwitch:
+        description: "ScheLatSwitch enables scheduler latency count in cpuacct"
+        type: "integer"
+        format: "int64"
+        x-nullable: false
+        minimum: 0
+        maximum: 1
+      MemoryWmarkRatio:
+        description: | 
+          MemoryWmarkRatio is an integer value representing this container's memory low water mark percentage. 
+          The value of memory low water mark is memory.limit_in_bytes * MemoryWmarkRatio. The range is in [0, 100].
+        type: "integer"
+        format: "int64"
+        x-nullable: true
+        minimum: 0
+        maximum: 100
+      MemoryExtra:
+        description: |
+          MemoryExtra is an integer value representing this container's memory high water mark percentage.
+          The range is in [0, 100].
+        type: "integer"
+        format: "int64"
+        x-nullable: true
+        minimum: 0
+        maximum: 100
+      MemoryForceEmptyCtl:
+        description: "MemoryForceEmptyCtl represents whether to reclaim the page cache when deleting cgroup."
+        type: "integer"
+        format: "int64"
+        x-nullable: false
+        minimum: 0
+        maximum: 1
+
+  ThrottleDevice:
+    type: "object"
+    properties:
+      Path:
+        description: "Device path"
+        type: "string"
+      Rate:
+        description: "Rate"
+        type: "integer"
+        format: "uint64"
+        x-nullable: false
+        minimum: 0
+
+  WeightDevice:
+    type: "object"
+    description: "Weight for BlockIO Device"
+    properties:
+      Path:
+        description: "Weight Device"
+        type: "string"
+      Weight:
+        type: "integer"
+        format: "uint16"
+        x-nullable: false
+        minimum: 0
+
+  DeviceMapping:
+    type: "object"
+    description: "A device mapping between the host and container"
+    properties:
+      PathOnHost:
+        description: "path on host of the device mapping"
+        type: "string"
+      PathInContainer:
+        description: "path in container of the device mapping"
+        type: "string"
+      CgroupPermissions:
+        description: "cgroup permissions of the device"
+        type: "string"
+    example:
+      PathOnHost: "/dev/deviceName"
+      PathInContainer: "/dev/deviceName"
+      CgroupPermissions: "mrw"
+
+  Container:
+    description: |
+      an array of Container contains response of Engine API:
+      GET "/containers/json"
+    type: "object"
+    properties:
+      Id:
+        description: "Container ID"
+        type: "string"
+      Names:
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - "container_1"
+          - "container_2"
+      Image:
+        type: "string"
+      ImageID:
+        type: "string"
+      Command:
+        type: "string"
+      Created:
+        description: "Created time of container in daemon."
+        type: "integer"
+        format: "int64"
+      SizeRw:
+        type: "integer"
+        format: "int64"
+      SizeRootFs:
+        type: "integer"
+        format: "int64"
+      Labels:
+        type: "object"
+        additionalProperties:
+          type: "string"
+      State:
+        type: "string"
+      Status:
+        type: "string"
+      HostConfig:
+        description: |
+          In Moby's API, HostConfig field in Container struct has following type 
+          struct { NetworkMode string `json:",omitempty"` }
+          In Pouch, we need to pick runtime field in HostConfig from daemon side to judge runtime type,
+          So Pouch changes this type to be the complete HostConfig.
+          Incompatibility exists, ATTENTION.
+        $ref: "#/definitions/HostConfig"
+        x-nullable: false
+      Mounts:
+        type: "array"
+        description: "Set of mount point in a container."
+        items:
+          $ref: "#/definitions/MountPoint"
+      NetworkSettings:
+        type: "object"
+        properties:
+          Networks:
+            additionalProperties:
+              $ref: "#/definitions/EndpointSettings"
+              x-nullable: true
+
+  NetworkingConfig:
+    description: "Configuration for a network used to create a container."
+    type: "object"
+    properties:
+      EndpointsConfig:
+        additionalProperties:
+          $ref: "#/definitions/EndpointSettings"
+          x-nullable: true
+
+  EndpointSettings:
+    description: "Configuration for a network endpoint."
+    type: "object"
+    properties:
+      # Configurations
+      IPAMConfig:
+        $ref: "#/definitions/EndpointIPAMConfig"
+        x-nullable: true
+      Links:
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - "container_1"
+          - "container_2"
+      Aliases:
+        type: "array"
+        items:
+          type: "string"
+        example:
+          - "server_x"
+          - "server_y"
+
+      # Operational data
+      NetworkID:
+        description: |
+          Unique ID of the network.
+        type: "string"
+        example: "08754567f1f40222263eab4102e1c733ae697e8e354aa9cd6e18d7402835292a"
+      EndpointID:
+        description: |
+          Unique ID for the service endpoint in a Sandbox.
+        type: "string"
+        example: "b88f5b905aabf2893f3cbc4ee42d1ea7980bbc0a92e2c8922b1e1795298afb0b"
+      Gateway:
+        description: |
+          Gateway address for this network.
+        type: "string"
+        example: "172.17.0.1"
+      IPAddress:
+        description: |
+          IPv4 address.
+        type: "string"
+        example: "172.17.0.4"
+      IPPrefixLen:
+        description: |
+          Mask length of the IPv4 address.
+        type: "integer"
+        example: 16
+      IPv6Gateway:
+        description: |
+          IPv6 gateway address.
+        type: "string"
+        example: "2001:db8:2::100"
+      GlobalIPv6Address:
+        description: |
+          Global IPv6 address.
+        type: "string"
+        example: "2001:db8::5689"
+      GlobalIPv6PrefixLen:
+        description: |
+          Mask length of the global IPv6 address.
+        type: "integer"
+        format: "int64"
+        example: 64
+      MacAddress:
+        description: |
+          MAC address for the endpoint on this network.
+        type: "string"
+        example: "02:42:ac:11:00:04"
+      DriverOpts:
+        description: |
+          DriverOpts is a mapping of driver options and values. These options
+          are passed directly to the driver and are driver specific.
+        type: "object"
+        x-nullable: true
+        additionalProperties:
+          type: "string"
+        example:
+          com.example.some-label: "some-value"
+          com.example.some-other-label: "some-other-value"
+
+  EndpointIPAMConfig:
+    description: "IPAM configurations for the endpoint"
+    type: "object"
+    properties:
+      IPv4Address:
+        description: "ipv4 address"
+        type: "string"
+      IPv6Address:
+        description: "ipv6 address"
+        type: "string"
+      LinkLocalIPs:
+        description: "link to the list of local ip"
+        type: "array"
+        x-nullable: false
+        items:
+          type: "string"
+
+  ImageInfo:
+    description: "An object containing all details of an image at API side"
+    type: "object"
+    properties:
+      Id:
+        description: "ID of an image."
+        type: "string"
+        x-nullable: false
+      RepoTags:
+        description: "repository with tag."
+        type: "array"
+        items:
+          type: "string"
+      RepoDigests:
+        description: "repository with digest."
+        type: "array"
+        items:
+          type: "string"
+      CreatedAt:
+        description: "time of image creation."
+        type: "string"
+        x-nullable: false
+      Size:
+        description: "size of image's taking disk space."
+        type: "integer"
+        x-nullable: false
+      Config:
+        $ref: "#/definitions/ContainerConfig"
+      Architecture:
+        description: "the CPU architecture."
+        type: "string"
+        x-nullable: false
+      Os:
+        description: "the name of the operating system."
+        type: "string"
+        x-nullable: false
+      RootFS:
+        description: "the rootfs key references the layer content addresses used by the image."
+        type: "object"
+        required: [Type]
+        properties:
+          Type:
+            description: "type of the rootfs"
+            type: "string"
+            x-nullable: false
+          Layers:
+            description: "an array of layer content hashes"
+            type: "array"
+            items:
+              type: "string"
+          BaseLayer:
+            description: "the base layer content hash."
+            type: "string"
+
+  SearchResultItem:
+    type: "object"
+    description: "search result item in search results."
+    properties:
+      description:
+        type: "string"
+        description: "description just shows the description of this image"
+      is_official:
+        type: "boolean"
+        description: "is_official shows if this image is marked official."
+      is_automated:
+        type: "boolean"
+        description: "is_automated means whether this image is automated."
+      name:
+        type: "string"
+        description: "name represents the name of this image"
+      star_count:
+        type: "integer"
+        description: "star_count refers to the star count of this image."
+
+  VolumeInfo:
+    type: "object"
+    description: "Volume represents the configuration of a volume for the container."
+    properties:
+      Name:
+        description: "Name is the name of the volume."
+        type: "string"
+      Driver:
+        description: "Driver is the Driver name used to create the volume."
+        type: "string"
+      Mountpoint:
+        description: "Mountpoint is the location on disk of the volume."
+        type: "string"
+      CreatedAt:
+        type: "string"
+        format: "dateTime"
+        description: "Date/Time the volume was created."
+      Status:
+        description: "Status provides low-level status information about the volume."
+        type: "object"
+        additionalProperties:
+          type: "object"
+          enum:
+            - {}
+          default: {}
+      Labels:
+        description: "Labels is metadata specific to the volume."
+        type: "object"
+        additionalProperties:
+          type: "string"
+      Scope:
+        description: |
+          Scope describes the level at which the volume exists
+          (e.g. `global` for cluster-wide or `local` for machine level)
+        type: "string"
+
+  VolumeCreateConfig:
+    description: "config used to create a volume"
+    type: "object"
+    properties:
+      Name:
+        description: "The new volume's name. If not specified, Pouch generates a name."
+        type: "string"
+        x-nullable: false
+      Driver:
+        description: "Name of the volume driver to use."
+        type: "string"
+        default: "local"
+        x-nullable: false
+      DriverOpts:
+        description: "A mapping of driver options and values. These options are passed directly to the driver and are driver specific."
+        type: "object"
+        additionalProperties:
+          type: "string"
+      Labels:
+        description: "User-defined key/value metadata."
+        type: "object"
+        additionalProperties:
+          type: "string"
+    example:
+      Name: "tardis"
+      Labels:
+        com.example.some-label: "some-value"
+        com.example.some-other-label: "some-other-value"
+      Driver: "custom"
+
+  VolumeListResp:
+    type: "object"
+    required: [Volumes, Warnings]
+    properties:
+      Volumes:
+        type: "array"
+        x-nullable: false
+        description: "List of volumes"
+        items:
+          $ref: "#/definitions/VolumeInfo"
+      Warnings:
+        type: "array"
+        x-nullable: false
+        description: "Warnings that occurred when fetching the list of volumes"
+        items:
+          type: "string"
+
+  ExecCreateConfig:
+    type: "object"
+    description: is a small subset of the Config struct that holds the configuration.
+    properties:
+      User:
+        type: "string"
+        description: "User that will run the command"
+        x-nullable: false
+      Privileged:
+        type: "boolean"
+        description: "Is the container in privileged mode"
+      Tty:
+        type: "boolean"
+        description: "Attach standard streams to a tty"
+      AttachStdin:
+        type: "boolean"
+        description: "Attach the standard input, makes possible user interaction"
+      AttachStderr:
+        type: "boolean"
+        description: "Attach the standard error"
+      AttachStdout:
+        type: "boolean"
+        description: "Attach the standard output"
+      Detach:
+        type: "boolean"
+        description: "Execute in detach mode"
+      DetachKeys:
+        type: "string"
+        description: "Escape keys for detach"
+      Cmd:
+        type: "array"
+        description: "Execution commands and args"
+        minItems: 1
+        items:
+          type: "string"
+  ContainerProcessList:
+    description: OK Response to ContainerTop operation
+    type: "object"
+    properties:
+      Titles:
+        description: "The ps column titles"
+        type: "array"
+        items:
+          type: "string"
+      Processes:
+        description: "Each process running in the container, where each is process is an array of values corresponding to the titles"
+        type: "array"
+        items:
+          type: "array"
+          items:
+            type: "string"
+
+  ExecCreateResp:
+    type: "object"
+    description: contains response of Remote API POST "/containers/{name:.*}/exec".
+    properties:
+      Id:
+        type: "string"
+        description: ID is the exec ID
+
+  ExecStartConfig:
+    type: "object"
+    description: ExecStartConfig is a temp struct used by execStart.
+    properties:
+      Detach:
+        description: ExecStart will first check if it's detached
+        type: "boolean"
+      Tty:
+        description: Check if there's a tty
+        type: "boolean"
+    example:
+      Detach: false
+      Tty: false
+  
+  ContainerExecInspect:
+    type: "object"
+    description: holds information about a running process started.
+    properties:
+      ID:
+        type: "string"
+        description: "The ID of this exec"
+      Running:
+        type: "boolean"
+      ExitCode:
+        type: "integer"
+        description: "The last exit code of this container"
+      ProcessConfig:
+        $ref: "#/definitions/ProcessConfig"
+      OpenStdin:
+        type: "boolean"
+      OpenStderr:
+        type: "boolean"
+      OpenStdout:
+        type: "boolean"
+      CanRemove:
+        type: "boolean"
+      ContainerID:
+        type: "string"
+        description: "The ID of this container"
+      DetachKeys:
+        type: "string"
+
+  ProcessConfig:
+    type: "object"
+    description: ExecProcessConfig holds information about the exec process.
+    properties:
+      privileged:
+        type: "boolean"
+      user:
+        type: "string"
+      tty:
+        type: "boolean"
+      entrypoint:
+        type: "string"
+      arguments:
+        type: "array"
+        items:
+          type: "string"
+
+  ContainerJSON:
+    description: | 
+      ContainerJSON contains response of Engine API:
+      GET "/containers/{id}/json"
+    type: "object"
+    properties:
+      Id:
+        description: "The ID of the container"
+        type: "string"
+      Created:
+        description: "The time the container was created"
+        type: "string"
+      Path:
+        description: "The path to the command being run"
+        type: "string"
+      Args:
+        description: "The arguments to the command being run"
+        type: "array"
+        items:
+          type: "string"
+      State:
+        description: "The state of the container."
+        $ref: "#/definitions/ContainerState"
+      Image:
+        description: "The container's image"
+        type: "string"
+      ResolvConfPath:
+        type: "string"
+      HostnamePath:
+        type: "string"
+      HostsPath:
+        type: "string"
+      LogPath:
+        type: "string"
+      Name:
+        type: "string"
+      RestartCount:
+        type: "integer"
+      Driver:
+        type: "string"
+      MountLabel:
+        type: "string"
+      ProcessLabel:
+        type: "string"
+      AppArmorProfile:
+        type: "string"
+      ExecIDs:
+        type: "string"
+      HostConfig:
+        $ref: "#/definitions/HostConfig"
+      SizeRw:
+        description: "The size of files that have been created or changed by this container."
+        type: "integer"
+        format: "int64"
+        x-nullable: true
+      SizeRootFs:
+        description: "The total size of all the files in this container."
+        type: "integer"
+        format: "int64"
+        x-nullable: true
+      Config:
+        $ref: "#/definitions/ContainerConfig"
+      Snapshotter:
+        $ref: "#/definitions/SnapshotterData"
+      GraphDriver:
+        $ref: "#/definitions/GraphDriverData"
+      Mounts:
+        type: "array"
+        description: "Set of mount point in a container."
+        items:
+          $ref: "#/definitions/MountPoint"
+      NetworkSettings:
+        description: "NetworkSettings exposes the network settings in the API."
+        $ref: "#/definitions/NetworkSettings"
+
+  ContainerState:
+    type: "object"
+    properties:
+      Status:
+        $ref: "#/definitions/Status"
+      Running:
+        description: |
+          Whether this container is running.
+
+          Note that a running container can be _paused_. The `Running` and `Paused`
+          booleans are not mutually exclusive:
+
+          When pausing a container (on Linux), the cgroups freezer is used to suspend
+          all processes in the container. Freezing the process requires the process to
+          be running. As a result, paused containers are both `Running` _and_ `Paused`.
+
+          Use the `Status` field instead to determine if a container's state is "running".
+        type: "boolean"
+      Paused:
+        description: "Whether this container is paused."
+        type: "boolean"
+      Restarting:
+        description: "Whether this container is restarting."
+        type: "boolean"
+      OOMKilled:
+        description: "Whether this container has been killed because it ran out of memory."
+        type: "boolean"
+      Dead:
+        description: "Whether this container is dead."
+        type: "boolean"
+      Pid:
+        description: "The process ID of this container"
+        type: "integer"
+      ExitCode:
+        description: "The last exit code of this container"
+        type: "integer"
+      Error:
+        description: "The error message of this container"
+        type: "string"
+      StartedAt:
+        description: "The time when this container was last started."
+        type: "string"
+      FinishedAt:
+        description: "The time when this container last exited."
+        type: "string"
+
+  ContainerLogsOptions:
+    type: "object"
+    properties:
+      ShowStdout:
+        description: "Return logs from `stdout`"
+        type: "boolean"
+      ShowStderr:
+        description: "Return logs from `stderr`"
+        type: "boolean"
+      Since:
+        description: "Only return logs after this time, as a UNIX timestamp"
+        type: "string"
+      Until:
+        description: "Only reture logs before this time, as a UNIX timestamp"
+        type: "string"
+      Timestamps:
+        description: "Add timestamps to every log line"
+        type: "boolean"
+      Follow:
+        description: "Return logs as a stream"
+        type: "boolean"
+      Tail:
+        description: "Only reture this number of log lines from the end of the logs. Specify as an integer or `all` to output all log lines."
+        type: "string"
+      Details:
+        description: "Show extra details provided to logs"
+        type: "boolean"
+
+
+    description: The parameters to filter the log.
+
+
+  Status:
+    description: The status of the container. For example, "running" or "exited".
+    type: "string"
+    enum: ["created", "running", "stopped", "paused", "restarting", "removing", "exited", "dead"]
+
+  SnapshotterData:
+    description: "Information about a container's snapshotter."
+    type: "object"
+    required: [Name, Data]
+    properties:
+      Name:
+        type: "string"
+        x-nullable: false
+      Data:
+        type: "object"
+        x-nullable: false
+        additionalProperties:
+          type: "string"
+
+  GraphDriverData:
+    description: "Information about a container's graph driver."
+    type: "object"
+    required: [Name, Data]
+    properties:
+      Name:
+        type: "string"
+        x-nullable: false
+      Data:
+        type: "object"
+        x-nullable: false
+        additionalProperties:
+          type: "string"
+
+  MountPoint:
+    type: "object"
+    description: "A mount point inside a container"
+    x-nullable: false
+    properties:
+      Type:
+        type: "string"
+      ID:
+        type: "string"
+      Name:
+        type: "string"
+      Source:
+        type: "string"
+      Destination:
+        type: "string"
+      Driver:
+        type: "string"
+      Mode:
+        type: "string"
+      RW:
+        type: "boolean"
+      CopyData:
+        type: "boolean"
+      Named:
+        type: "boolean"
+      Replace:
+        type: "string"
+      Propagation:
+        type: "string"
+
+  NetworkSettings:
+    description: "NetworkSettings exposes the network settings in the API."
+    type: "object"
+    properties:
+      Bridge:
+        description: Name of the network'a bridge (for example, `pouch-br`).
+        type: "string"
+        example: "pouch-br"
+      SandboxID:
+        description: SandboxID uniquely represents a container's network stack.
+        type: "string"
+        example: "9d12daf2c33f5959c8bf90aa513e4f65b561738661003029ec84830cd503a0c3"
+      HairpinMode:
+        description: "Indicates if hairpin NAT should be enabled on the virtual interface"
+        type: "boolean"
+        example: false
+      LinkLocalIPv6Address:
+        description: "IPv6 unicast address using the link-local prefix"
+        type: "string"
+        example: "fe80::42:acff:fe11:1"
+      LinkLocalIPv6PrefixLen:
+        description: Prefix length of the IPv6 unicast address.
+        type: "integer"
+        example: "64"
+      Ports:
+        $ref: "#/definitions/PortMap"
+      SandboxKey:
+        description: SandboxKey identifies the sandbox
+        type: "string"
+        example: "/var/run/pouch/netns/8ab54b426c38"
+
+      # TODO is SecondaryIPAddresses actually used?
+      SecondaryIPAddresses:
+        description: ""
+        type: "array"
+        items:
+          $ref: "#/definitions/IPAddress"
+        x-nullable: true
+
+      # TODO is SecondaryIPv6Addresses actually used?
+      SecondaryIPv6Addresses:
+        description: ""
+        type: "array"
+        items:
+          $ref: "#/definitions/IPAddress"
+        x-nullable: true
+      Networks:
+        description: "Information about all networks that the container is connected to"
+        type: "object"
+        additionalProperties:
+          $ref: "#/definitions/EndpointSettings"
+          x-nullable: true
+
+  IPAddress:
+    description: Address represents an IPv4 or IPv6 IP address.
+    type: "object"
+    properties:
+      Addr:
+        description: IP address.
+        type: "string"
+      PrefixLen:
+        description: Mask length of the IP address.
+        type: "integer"
+
+  PortMap:
+    description: |
+      PortMap describes the mapping of container ports to host ports, using the
+      container's port-number and protocol as key in the format `<port>/<protocol>`,
+      for example, `80/udp`.
+
+      If a container's port is mapped for both `tcp` and `udp`, two separate
+      entries are added to the mapping table.
+    type: "object"
+    additionalProperties:
+      type: "array"
+      items:
+        $ref: "#/definitions/PortBinding"
+    example:
+      "443/tcp":
+        - HostIp: "127.0.0.1"
+          HostPort: "4443"
+      "80/tcp":
+        - HostIp: "0.0.0.0"
+          HostPort: "80"
+        - HostIp: "0.0.0.0"
+          HostPort: "8080"
+      "80/udp":
+        - HostIp: "0.0.0.0"
+          HostPort: "80"
+      "2377/tcp": null
+
+  PortBinding:
+    description: "PortBinding represents a binding between a host IP address and a host port"
+    type: "object"
+    x-nullable: true
+    properties:
+      HostIp:
+        description: "Host IP address that the container's port is mapped to."
+        type: "string"
+        example: "127.0.0.1"
+      HostPort:
+        description: "Host port number that the container's port is mapped to."
+        type: "string"
+        example: "4443"
+
+  RestartPolicy:
+    description: "Define container's restart policy"
+    type: "object"
+    properties:
+      Name:
+        type: "string"
+      MaximumRetryCount:
+        type: "integer"
+
+  NetworkCreateConfig:
+    type: "object"
+    description: "contains the request for the remote API: POST /networks/create"
+    allOf:
+      - properties:
+          Name:
+            description: "Name is the name of the network."
+            type: "string"
+      - $ref: "#/definitions/NetworkCreate"
+
+  NetworkCreateResp:
+    type: "object"
+    description: "contains the response for the remote API: POST /networks/create"
+    properties:
+      Id:
+        description: "ID is the id of the network."
+        type: "string"
+      Warning:
+        description: "Warning means the message of create network result."
+        type: "string"
+
+  NetworkCreate:
+    type: "object"
+    description: "is the expected body of the \"create network\" http request message"
+    properties:
+      CheckDuplicate:
+        type: "boolean"
+        description: "CheckDuplicate is used to check the network is duplicate or not."
+      Driver:
+        type: "string"
+        description: "Driver means the network's driver."
+      EnableIPv6:
+        type: "boolean"
+      IPAM:
+        type: "object"
+        $ref: "#/definitions/IPAM"
+      Internal:
+        type: "boolean"
+        description: "Internal checks the network is internal network or not."
+      Options:
+        type: "object"
+        additionalProperties:
+          type: "string"
+      Labels:
+        type: "object"
+        additionalProperties:
+          type: "string"
+
+  NetworkInspectResp:
+    type: "object"
+    description: "is the expected body of the 'GET networks/{id}'' http request message"
+    properties:
+      Name:
+        type: "string"
+        description: "Name is the requested name of the network"
+      Id:
+        type: "string"
+        description: "ID uniquely identifies a network on a single machine"
+      Scope:
+        type: "string"
+        description: "Scope describes the level at which the network exists."
+      Driver:
+        type: "string"
+        description: "Driver means the network's driver."
+      EnableIPv6:
+        type: "boolean"
+        description: "EnableIPv6 represents whether to enable IPv6."
+      IPAM:
+        type: "object"
+        description: "IPAM is the network's IP Address Management."
+        $ref: "#/definitions/IPAM"
+      Internal:
+        type: "boolean"
+        description: "Internal checks the network is internal network or not."
+      Options:
+        type: "object"
+        description: "Options holds the network specific options to use for when creating the network."
+        additionalProperties:
+          type: "string"
+      Labels:
+        type: "object"
+        description: "Labels holds metadata specific to the network being created."
+        additionalProperties:
+          type: "string"
+
+  NetworkResource:
+    type: "object"
+    description: "NetworkResource is the body of the \"get network\" http response message"
+    properties:
+      Name:
+        description: "Name is the requested name of the network"
+        type: "string"
+      Id:
+        description: "ID uniquely identifies a network on a single machine"
+        type: "string"
+      Scope:
+        description: "Scope describes the level at which the network exists (e.g. `global` for cluster-wide or `local` for machine level)"
+        type: "string"
+      Driver:
+        description: "Driver is the Driver name used to create the network (e.g. `bridge`, `overlay`)"
+        type: "string"
+      EnableIPv6:
+        description: "EnableIPv6 represents whether to enable IPv6"
+        type: "boolean"
+      IPAM:
+        description: ""
+        type: "object"
+        $ref: "#/definitions/IPAM"
+      Internal:
+        description: "Internal represents if the network is used internal only"
+        type: "boolean"
+      Containers:
+        description: "Containers contains endpoints belonging to the network"
+        type: "object"
+      IndexConfigs:
+        type: "object"
+        additionalProperties:
+          $ref: "#/definitions/EndpointResource"
+      Options:
+        description: "Options holds the network specific options to use for when creating the network"
+        type: "object"
+        x-nullable: true
+        additionalProperties:
+          type: "string"
+        example:
+          com.example.some-options: "some-option"
+          com.example.some-other-options: "some-other-option"
+      Labels:
+        description: "Labels holds metadata specific to the network being created"
+        type: "object"
+        x-nullable: true
+        additionalProperties:
+          type: "string"
+        example:
+          com.example.some-label: "some-label"
+          com.example.some-other-label: "some-other-label"
+
+  EndpointResource:
+    type: "object"
+    description: "NetworkResource is the body of the \"get network\" http response message"
+    properties:
+      Name:
+        description: "Name is the requested name of the network"
+        type: "string"
+      EndpointID:
+        description: "EndpointID represents the endpoint's id"
+        type: "string"
+      MacAddress:
+        description: "MacAddress represents the enpoint's mac address"
+        type: "string"
+      IPv4Address:
+        description: "IPv4Address represents the enpoint's ipv4 address"
+        type: "string"
+      IPv6Address:
+        description: "IPv4Address represents the enpoint's ipv6 address"
+        type: "string"
+
+  IPAM:
+    type: "object"
+    description: "represents IP Address Management"
+    properties:
+      Driver:
+        type: "string"
+      Options:
+        type: "object"
+        additionalProperties:
+          type: "string"
+      Config:
+        type: "array"
+        items:
+          $ref: '#/definitions/IPAMConfig'
+
+  IPAMConfig:
+    description: "represents IPAM configurations"
+    type: "object"
+    x-nullable: false
+    properties:
+      Subnet:
+        type: "string"
+      IPRange:
+        type: "string"
+      Gateway:
+        type: "string"
+      AuxAddress:
+        type: "object"
+        additionalProperties:
+          type: "string"
+
+  ResizeOptions:
+    description: "options of resizing container tty size"
+    type: "object"
+    properties:
+      Height:
+        type: "integer"
+      Width:
+        type: "integer"
+
+parameters:
+  id:
+    name: id
+    in: path
+    required: true
+    description: ID or name of the container
+    type: string
+  imageid:
+    name: imageid
+    in: path
+    required: true
+    description: Image name or id
+    type: string
+
+responses:
+  401ErrorResponse:
+    description: An unexpected 401 error occured.
+    schema:
+      $ref: "#/definitions/Error"
+  404ErrorResponse:
+    description: An unexpected 404 error occured.
+    schema:
+      $ref: "#/definitions/Error"
+  500ErrorResponse:
+    description: An unexpected server error occured.
+    schema:
+      $ref: "#/definitions/Error"
+
diff --git a/fixtures/bugs/1487/fixture-844-variations.yaml b/fixtures/bugs/1487/fixture-844-variations.yaml
new file mode 100644
index 00000000..fb62b843
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-844-variations.yaml
@@ -0,0 +1,87 @@
+---
+  swagger: "2.0"
+  info: 
+    title: "allOf bugs with empty objects"
+    version: "0.0.1"
+    description: "repro"
+    license: 
+      name: "Apache 2.0"
+      url: "http://www.apache.org/licenses/LICENSE-2.0.html"
+  definitions: 
+    foo: 
+      type: "object"
+    bar: 
+      type: "object"
+    nonInterface:
+      type: "object"
+      additionalProperties:
+        type: string
+        format: date
+    # this one is generated as interface{} and validation is not honored
+    emptyEnum:
+      type: "object"
+      enum: 
+        - "abc"
+        - "def"
+    variation0:
+      allOf: 
+        - 
+          $ref: "#/definitions/foo"
+        - 
+          $ref: "#/definitions/bar"
+    variation1:
+      allOf: 
+        - 
+          $ref: "#/definitions/foo"
+        - 
+          $ref: "#/definitions/nonInterface"
+    variation2:
+      type: "object"
+      properties:
+        prop1:
+          $ref: '#/definitions/emptyEnum'
+    variation3:
+      type: "object"
+      properties:
+        prop1:
+          type: array
+          minItems: 10
+          items: 
+            $ref: '#/definitions/emptyEnum'
+    tupleVariation:
+      type: "array"
+      items: 
+        - type: integer
+          maximum: 10 
+        - $ref: '#/definitions/bar'
+        - $ref: '#/definitions/nonInterface'
+        - type: array 
+          maxItems: 10
+          items: 
+            $ref: '#/definitions/bar'
+      additionalItems:
+        $ref: '#/definitions/foo'
+    addItemsVariation:
+      type: "array"
+      items: 
+        - type: integer
+          maximum: 10 
+        - $ref: '#/definitions/bar'
+      additionalItems:
+        type: array 
+        uniqueItems: true
+        items:
+          $ref: '#/definitions/foo'
+  paths: 
+    /: 
+      get: 
+        responses: 
+          200: 
+            description: "OK"
+            schema: 
+              allOf: 
+                - 
+                  $ref: "#/definitions/foo"
+                - 
+                  $ref: "#/definitions/bar"
+
diff --git a/fixtures/bugs/1487/fixture-additionalProps.yaml b/fixtures/bugs/1487/fixture-additionalProps.yaml
new file mode 100644
index 00000000..01426e86
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-additionalProps.yaml
@@ -0,0 +1,302 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: fixture for additionalProperties
+  description: various patterns of additionalProperties
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  additionalThings:
+    type: object
+    required: [ origin ]
+    properties:
+      origin: 
+        type: string
+        enum: [ print, e-book, collection, museum ]
+      status: 
+        type: string
+        enum: [ OK, KO ]
+    additionalProperties:
+      type: string
+      enum: [ bookshop, amazon, library ]
+  additionalSliceOfObjects:
+    type: object 
+    properties: 
+      prop1:
+        type: string
+    additionalProperties:
+      type: array
+      uniqueItems: true
+      items: 
+        type: object
+        properties:
+          prop2: 
+            type: integer
+  additionalSliceOfPrimitives:
+    type: object 
+    properties: 
+      prop1:
+        type: string
+    additionalProperties:
+      type: array
+      uniqueItems: true
+      items: 
+        type: string
+        format: date
+  additionalSliceOfAliasedPrimitives:
+    type: object 
+    properties: 
+      prop2:
+        type: string
+        format: uuid
+    additionalProperties:
+      type: array
+      maxItems: 10
+      items: 
+        $ref: '#/definitions/aliasedDate'
+  additionalSliceOfAliasedNullablePrimitives:
+    type: object 
+    properties: 
+      prop3:
+        type: string
+        format: uuid
+    additionalProperties:
+      type: array
+      minItems: 10
+      items: 
+        $ref: '#/definitions/aliasedNullableDate'
+  additionalSliceOfSlice:
+    type: object 
+    properties: 
+      prop4:
+        type: string
+        format: uuid
+    additionalProperties:
+      type: array
+      items: 
+        type: array
+        maxItems: 10
+        items: 
+          type: object
+          uniqueItems: true
+          properties: 
+            prop5:
+              type: integer 
+              maximum: 10
+  additionalObject:
+    type: object
+    properties:
+      mockId: 
+        type: number
+    additionalProperties:
+      type: object
+      required: [ mockB ]
+      properties:
+        mockA: 
+          type: string
+          pattern: '^[A-Z]$'
+        mockB:
+          type: string
+          minLength: 1
+        mockC:
+          type: number
+  additionalEmptyObject:
+    type: object
+    properties:
+      # this one is rendered as interface{}: this is debatable
+      propA: 
+        type: object
+    additionalProperties:
+      # this one is rendered as map[string]interface{}, which is correct
+      type: object
+  emptyObjectWithAdditionalSlice:
+    type: object
+    additionalProperties:
+      type: array
+      items:
+        type: object
+        properties:
+          dummyProp1: 
+            type: string
+            format: date
+  additionalThingsNested:
+    type: object
+    properties:
+      origin: 
+        type: string
+        enum: [ goPrint, goE-book, goCollection, goMuseum ]
+    additionalProperties:
+      type: object
+      properties:
+        printerAddress: 
+          type: string
+        printerDate: 
+          type: string
+          format: date
+        printerCountry:
+          type: string
+          enum: [ "US", "FR", "UK", "BE", "CA", "DE"]
+      additionalProperties:
+        type: object
+        properties:
+          averageDelay:
+            type: string
+            format: duration
+  noValidationThing:
+    type: object
+    additionalProperties: true
+    properties:
+      discourse: 
+        type: string
+      hoursSpent:
+        type: number
+  interfaceThing:
+    type: object
+    additionalProperties: true
+  additionalFormatedThing:
+    type: object
+    additionalProperties:
+      type: string 
+      format: date
+  aliasedDate:
+    type: string
+    format: date
+  aliasedNullableDate:
+    type: string
+    format: date
+    x-nullable: true
+  additionalObjectWithAliasedThing:
+    type: object
+    properties:
+      blob:
+        type: integer
+        minimum: 1
+    additionalProperties:
+      $ref: '#/definitions/aliasedDate'
+  additionalObjectWithNullableThing:
+    type: object
+    properties:
+      blob:
+        type: integer
+        minimum: 1
+    additionalProperties:
+      $ref: '#/definitions/aliasedNullableDate'
+  additionalDateWithNullableThing:
+    type: object
+    properties:
+      nullableDate:
+        $ref: '#/definitions/aliasedNullableDate'
+    properties:
+      blob:
+        type: integer
+        minimum: 1
+    additionalProperties:
+      $ref: '#/definitions/aliasedNullableDate'
+  additionalObjectWithFormatedThing:
+    type: object
+    required: [ blob ]
+    properties:
+      blob:
+        type: integer
+        minimum: 1
+    additionalProperties:
+      type: string 
+      format: date
+  additionalArrayThing:
+    type: object
+    properties:
+      thisOneNotRequired:
+        type: integer
+        maximum: 10
+    additionalProperties:
+      type: array
+      uniqueItems: true
+      items: 
+        type: string
+        format: uuid
+  additionalNullableArrayThing:
+    type: object
+    properties:
+      thisOneNotRequired:
+        type: integer
+        maximum: 10
+    additionalProperties:
+      type: array
+      x-nullable: true
+      uniqueItems: true
+      items: 
+        type: string
+        format: isbn
+  additionalArrayOfRefedThing:
+    type: object
+    properties:
+      thisOneNotRequired:
+        type: integer
+        maximum: 10
+    additionalProperties:
+      type: array
+      uniqueItems: true
+      items: 
+        $ref: '#/definitions/aliasedDate' 
+  additionalTransitiveRefedThing:
+    type: object
+    properties:
+      thisOneNotRequired:
+        type: integer
+        maximum: 10
+    additionalProperties:
+      type: array
+      uniqueItems: true
+      items: 
+        $ref: '#/definitions/transitiveRefedThing' 
+  transitiveRefedThing:
+    type: object
+    properties:
+      thisOneNotRequiredEither:
+        type: integer
+        maximum: 20
+    additionalProperties:
+      type: object
+      properties: 
+        a1: 
+          type: string
+          format: date-time
+      additionalProperties:
+        $ref: '#/definitions/noValidationThing'
+  additionalArrayOfInterface:
+    type: object
+    properties:
+      thisOneNotRequired:
+        type: integer
+        maximum: 10
+    additionalProperties:
+      type: array
+      uniqueItems: true
+      items: 
+        type: object
+        additionalProperties: true
+  additionalArrayOfRefedObject:
+    type: object
+    properties:
+      thisOneNotRequired:
+        type: integer
+        maximum: 10
+    additionalProperties:
+      type: array
+      uniqueItems: true
+      items: 
+        $ref: '#/definitions/noValidationThing' 
diff --git a/fixtures/bugs/1487/fixture-allOf-flat.yaml b/fixtures/bugs/1487/fixture-allOf-flat.yaml
new file mode 100644
index 00000000..5b62d5c4
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-allOf-flat.yaml
@@ -0,0 +1,392 @@
+---
+  consumes: 
+    - "application/json"
+  produces: 
+    - "application/json"
+  swagger: "2.0"
+  info: 
+    description: "A test of enum validation generation for tuples and additionalItems.\nDerived from fixtures/codegen/todolist.enum.yml\n"
+    title: "fixture for enums with additional"
+    version: "1.0.0"
+  paths: 
+    /models: 
+      get: 
+        description: "Used to see if a codegen can render all the possible enum categories"
+        tags: 
+          - "testcgen"
+        summary: "many model variations"
+        operationId: "modelOp"
+        parameters: 
+          - 
+            name: "manyThings"
+            in: "body"
+            schema: 
+              $ref: "#/definitions/allThingsNested"
+        responses: 
+          default: 
+            description: "Generic Out"
+            schema: 
+              $ref: "#/definitions/allThings"
+  definitions: 
+    aliasedDate: 
+      type: "string"
+      format: "date"
+    aliasedNullableDate: 
+      type: "string"
+      format: "date"
+      x-nullable: true
+    allThings: 
+      type: "object"
+      allOf: 
+        - 
+          $ref: "#/definitions/allThingsAllOf0"
+        - 
+          $ref: "#/definitions/allThingsAllOf1"
+        - 
+          $ref: "#/definitions/allThingsAllOf2"
+        - 
+          $ref: "#/definitions/allThingsAllOf3"
+        - 
+          $ref: "#/definitions/allThingsAllOf4"
+        - 
+          $ref: "#/definitions/allThingsAllOf5"
+        - 
+          $ref: "#/definitions/allThingsAllOf6"
+        - 
+          $ref: "#/definitions/allThingsAllOf7"
+        - 
+          $ref: "#/definitions/allThingsAllOf8"
+        - 
+          $ref: "#/definitions/allThingsAllOf9"
+    allThingsAllOf0: 
+      type: "object"
+      required: 
+        - "origin"
+      properties: 
+        additionalProperties: 
+          type: "string"
+          enum: 
+            - "bookshop"
+            - "amazon"
+            - "library"
+        origin: 
+          type: "string"
+          enum: 
+            - "print"
+            - "e-book"
+            - "collection"
+            - "museum"
+        status: 
+          type: "string"
+          enum: 
+            - "OK"
+            - "KO"
+      x-go-gen-location: "models"
+    allThingsAllOf1: 
+      type: "object"
+      properties: 
+        mockId: 
+          type: "number"
+      additionalProperties: 
+        $ref: "#/definitions/allThingsAllOf1AdditionalProperties"
+      x-go-gen-location: "models"
+    allThingsAllOf1AdditionalProperties: 
+      type: "object"
+      required: 
+        - "mockB"
+      properties: 
+        mockA: 
+          type: "string"
+          pattern: "^[A-Z]$"
+        mockB: 
+          type: "string"
+          minLength: 1
+        mockC: 
+          type: "number"
+      x-go-gen-location: "models"
+    allThingsAllOf2: 
+      type: "object"
+      properties: 
+        origin2: 
+          type: "string"
+          enum: 
+            - "goPrint"
+            - "goE-book"
+            - "goCollection"
+            - "goMuseum"
+      additionalProperties: 
+        $ref: "#/definitions/allThingsAllOf2AdditionalProperties"
+      x-go-gen-location: "models"
+    allThingsAllOf2AdditionalProperties: 
+      type: "object"
+      properties: 
+        printerAddress: 
+          type: "string"
+        printerCountry: 
+          type: "string"
+          enum: 
+            - "US"
+            - "FR"
+            - "UK"
+            - "BE"
+            - "CA"
+            - "DE"
+        printerDate: 
+          type: "string"
+          format: "date"
+      additionalProperties: 
+        $ref: "#/definitions/allThingsAllOf2AdditionalPropertiesAdditionalProperties"
+      x-go-gen-location: "models"
+    allThingsAllOf2AdditionalPropertiesAdditionalProperties: 
+      type: "object"
+      properties: 
+        averageDelay: 
+          type: "string"
+          format: "duration"
+      x-go-gen-location: "models"
+    allThingsAllOf3: 
+      type: "object"
+      properties: 
+        discourse: 
+          type: "string"
+        hoursSpent: 
+          type: "number"
+      additionalProperties: true
+      x-go-gen-location: "models"
+    allThingsAllOf4: 
+      type: "object"
+      properties: 
+        blob: 
+          type: "integer"
+          minimum: 1
+      additionalProperties: 
+        $ref: "#/definitions/aliasedDate"
+      x-go-gen-location: "models"
+    allThingsAllOf5: 
+      type: "object"
+      properties: 
+        blob2: 
+          type: "integer"
+          minimum: 1
+      additionalProperties: 
+        $ref: "#/definitions/aliasedNullableDate"
+      x-go-gen-location: "models"
+    allThingsAllOf6: 
+      type: "object"
+      properties: 
+        nullableDate: 
+          $ref: "#/definitions/aliasedNullableDate"
+      x-go-gen-location: "models"
+    allThingsAllOf7: 
+      type: "object"
+      properties: 
+        blob3: 
+          type: "integer"
+          minimum: 1
+      additionalProperties: 
+        $ref: "#/definitions/aliasedNullableDate"
+      x-go-gen-location: "models"
+    allThingsAllOf8: 
+      type: "object"
+      required: 
+        - "blob4"
+      properties: 
+        blob4: 
+          type: "integer"
+          minimum: 1
+      additionalProperties: 
+        type: "string"
+        format: "date"
+      x-go-gen-location: "models"
+    allThingsAllOf9: 
+      type: "object"
+      properties: 
+        thisOneNotRequired: 
+          type: "integer"
+          maximum: 10
+      additionalProperties: 
+        type: "array"
+        uniqueItems: true
+        items: 
+          type: "string"
+          format: "uuid"
+      x-go-gen-location: "models"
+    allThingsNested: 
+      type: "object"
+      allOf: 
+        - 
+          $ref: "#definitions/allThings"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf1"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf2"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf3"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf4"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf5"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf6"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf7"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf8"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf9"
+        - 
+          $ref: "#/definitions/allThingsNestedAllOf10"
+    allThingsNestedAllOf1: 
+      type: "object"
+      required: 
+        - "origin"
+      properties: 
+        additionalProperties: 
+          type: "string"
+          enum: 
+            - "bookshop"
+            - "amazon"
+            - "library"
+        origin: 
+          type: "string"
+          enum: 
+            - "print"
+            - "e-book"
+            - "collection"
+            - "museum"
+        status: 
+          type: "string"
+          enum: 
+            - "OK"
+            - "KO"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf10: 
+      type: "object"
+      properties: 
+        thisOneNotRequired: 
+          type: "integer"
+          maximum: 10
+      additionalProperties: 
+        type: "array"
+        uniqueItems: true
+        items: 
+          type: "string"
+          format: "uuid"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf2: 
+      type: "object"
+      properties: 
+        mockId: 
+          type: "number"
+      additionalProperties: 
+        $ref: "#/definitions/allThingsNestedAllOf2AdditionalProperties"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf2AdditionalProperties: 
+      type: "object"
+      required: 
+        - "mockB"
+      properties: 
+        mockA: 
+          type: "string"
+          pattern: "^[A-Z]$"
+        mockB: 
+          type: "string"
+          minLength: 1
+        mockC: 
+          type: "number"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf3: 
+      type: "object"
+      properties: 
+        origin2: 
+          type: "string"
+          enum: 
+            - "goPrint"
+            - "goE-book"
+            - "goCollection"
+            - "goMuseum"
+      additionalProperties: 
+        $ref: "#/definitions/allThingsNestedAllOf3AdditionalProperties"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf3AdditionalProperties: 
+      type: "object"
+      properties: 
+        printerAddress: 
+          type: "string"
+        printerCountry: 
+          type: "string"
+          enum: 
+            - "US"
+            - "FR"
+            - "UK"
+            - "BE"
+            - "CA"
+            - "DE"
+        printerDate: 
+          type: "string"
+          format: "date"
+      additionalProperties: 
+        $ref: "#/definitions/allThingsNestedAllOf3AdditionalPropertiesAdditionalProperties"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf3AdditionalPropertiesAdditionalProperties: 
+      type: "object"
+      properties: 
+        averageDelay: 
+          type: "string"
+          format: "duration"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf4: 
+      type: "object"
+      properties: 
+        discourse: 
+          type: "string"
+        hoursSpent: 
+          type: "number"
+      additionalProperties: true
+      x-go-gen-location: "models"
+    allThingsNestedAllOf5: 
+      type: "object"
+      properties: 
+        blob: 
+          type: "integer"
+          minimum: 1
+      additionalProperties: 
+        $ref: "#/definitions/aliasedDate"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf6: 
+      type: "object"
+      properties: 
+        blob2: 
+          type: "integer"
+          minimum: 1
+      additionalProperties: 
+        $ref: "#/definitions/aliasedNullableDate"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf7: 
+      type: "object"
+      properties: 
+        nullableDate: 
+          $ref: "#/definitions/aliasedNullableDate"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf8: 
+      type: "object"
+      properties: 
+        blob3: 
+          type: "integer"
+          minimum: 1
+      additionalProperties: 
+        $ref: "#/definitions/aliasedNullableDate"
+      x-go-gen-location: "models"
+    allThingsNestedAllOf9: 
+      type: "object"
+      required: 
+        - "blob4"
+      properties: 
+        blob4: 
+          type: "integer"
+          minimum: 1
+      additionalProperties: 
+        type: "string"
+        format: "date"
+      x-go-gen-location: "models"
+
diff --git a/fixtures/bugs/1487/fixture-allOf.yaml b/fixtures/bugs/1487/fixture-allOf.yaml
new file mode 100644
index 00000000..4f9c8529
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-allOf.yaml
@@ -0,0 +1,313 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: fixture for enums with additional 
+  description: |
+    A test of enum validation generation for tuples and additionalItems.
+    Derived from fixtures/codegen/todolist.enum.yml
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: Used to see if a codegen can render all the possible enum categories
+      tags:
+        - testcgen
+      parameters:
+        - name: manyThings 
+          in: body
+          schema:
+            $ref: '#/definitions/allThingsNested'
+      responses:
+        default:
+          description: Generic Out
+          schema:
+            $ref: '#/definitions/allThings'
+
+definitions:
+  aliasedDate:
+    type: string
+    format: date
+  aliasedNullableDate:
+    type: string
+    format: date
+    x-nullable: true
+  allThings:
+    type: object
+    # TODO: add slices and tuples
+    # TODO: nested allOf
+    # x-go-names wreck additionalProperties
+    allOf:
+      - 
+        #x-go-name: additionalThing
+        type: object
+        required: [ origin ]
+        properties:
+          origin: 
+            type: string
+            enum: [ print, e-book, collection, museum ]
+          status: 
+            type: string
+            enum: [ OK, KO ]
+          additionalProperties:
+            type: string
+            enum: [ bookshop, amazon, library ]
+      - 
+        # x-go-name: additionalObject
+        type: object
+        properties:
+          mockId: 
+           type: number
+        additionalProperties:
+          type: object
+          required: [ mockB ]
+          properties:
+            mockA: 
+              type: string
+              pattern: '^[A-Z]$'
+            mockB:
+              type: string
+              minLength: 1
+            mockC:
+              type: number
+      -  
+        # x-go-name: additionalThingsNested
+        type: object
+        properties:
+          origin2: 
+            type: string
+            enum: [ goPrint, goE-book, goCollection, goMuseum ]
+        additionalProperties:
+          type: object
+          properties:
+            printerAddress: 
+              type: string
+            printerDate: 
+              type: string
+              format: date
+            printerCountry:
+              type: string
+              enum: [ "US", "FR", "UK", "BE", "CA", "DE"]
+          additionalProperties:
+            type: object
+            properties:
+              averageDelay:
+                type: string
+                format: duration
+      -  
+        # x-go-name: noValidationThing
+        # ERROR IN ALLOF
+        type: object
+        additionalProperties: true
+        properties:
+          discourse: 
+            type: string
+          hoursSpent:
+            type: number
+        #-  
+        # TODO: breaks generation
+        # x-go-name: interfaceThing
+        # ERROR IN ALLOF
+        #type: object
+        #additionalProperties: true
+        #-  
+        # x-go-name: additionalFormatedThing
+        # TODO: breaks generation
+        #type: object
+        #additionalProperties:
+        #  type: string 
+        #  format: date
+      -  
+        #x-go-name: additionalObjectWithAliasedThing
+        type: object
+        properties:
+          blob:
+            type: integer
+            minimum: 1
+        additionalProperties:
+          $ref: '#/definitions/aliasedDate'
+      - 
+        # x-go-name: additionalObjectWithNullableThing
+        type: object
+        properties:
+          blob2:
+            type: integer
+            minimum: 1
+        additionalProperties:
+          $ref: '#/definitions/aliasedNullableDate'
+      -  
+        #x-go-name: additionalDateWithNullableObject
+        type: object
+        properties:
+          nullableDate:
+            $ref: '#/definitions/aliasedNullableDate'
+      - 
+        #x-go-name: additionalDateWithNullableThing
+        type: object
+        properties:
+          blob3:
+            type: integer
+            minimum: 1
+        additionalProperties:
+          $ref: '#/definitions/aliasedNullableDate'
+      - 
+        #x-go-name: additionalObjectWithFormatedThing
+        type: object
+        required: [ blob4 ]
+        properties:
+          blob4:
+            type: integer
+            minimum: 1
+        additionalProperties:
+          type: string 
+          format: date
+      - 
+        #x-go-name: additionalArrayThing
+        type: object
+        properties:
+          thisOneNotRequired:
+            type: integer
+            maximum: 10
+        additionalProperties:
+          type: array
+          uniqueItems: true
+          items: 
+            type: string
+            format: uuid
+  
+  allThingsNested:
+    type: object
+    # TODO: add slices and tuples
+    # TODO: nested allOf
+    # x-go-names wreck additionalProperties
+    allOf:
+      - 
+        $ref: '#/definitions/allThings'
+      - 
+        #x-go-name: additionalThing
+        type: object
+        required: [ origin ]
+        properties:
+          origin: 
+            type: string
+            enum: [ print, e-book, collection, museum ]
+          status: 
+            type: string
+            enum: [ OK, KO ]
+          additionalProperties:
+            type: string
+            enum: [ bookshop, amazon, library ]
+      - 
+        # x-go-name: additionalObject
+        type: object
+        properties:
+          mockId: 
+           type: number
+        additionalProperties:
+          type: object
+          required: [ mockB ]
+          properties:
+            mockA: 
+              type: string
+              pattern: '^[A-Z]$'
+            mockB:
+              type: string
+              minLength: 1
+            mockC:
+              type: number
+      -  
+        # x-go-name: additionalThingsNested
+        type: object
+        properties:
+          origin2: 
+            type: string
+            enum: [ goPrint, goE-book, goCollection, goMuseum ]
+        additionalProperties:
+          type: object
+          properties:
+            printerAddress: 
+              type: string
+            printerDate: 
+              type: string
+              format: date
+            printerCountry:
+              type: string
+              enum: [ "US", "FR", "UK", "BE", "CA", "DE"]
+          additionalProperties:
+            type: object
+            properties:
+              averageDelay:
+                type: string
+                format: duration
+      -  
+        # x-go-name: noValidationThing
+        # ERROR IN ALLOF
+        type: object
+        additionalProperties: true
+        properties:
+          discourse: 
+            type: string
+          hoursSpent:
+            type: number
+      -  
+        #x-go-name: additionalObjectWithAliasedThing
+        type: object
+        properties:
+          blob:
+            type: integer
+            minimum: 1
+        additionalProperties:
+          $ref: '#/definitions/aliasedDate'
+      - 
+        # x-go-name: additionalObjectWithNullableThing
+        type: object
+        properties:
+          blob2:
+            type: integer
+            minimum: 1
+        additionalProperties:
+          $ref: '#/definitions/aliasedNullableDate'
+      -  
+        #x-go-name: additionalDateWithNullableObject
+        type: object
+        properties:
+          nullableDate:
+            $ref: '#/definitions/aliasedNullableDate'
+      - 
+        #x-go-name: additionalDateWithNullableThing
+        type: object
+        properties:
+          blob3:
+            type: integer
+            minimum: 1
+        additionalProperties:
+          $ref: '#/definitions/aliasedNullableDate'
+      - 
+        #x-go-name: additionalObjectWithFormatedThing
+        type: object
+        required: [ blob4 ]
+        properties:
+          blob4:
+            type: integer
+            minimum: 1
+        additionalProperties:
+          type: string 
+          format: date
+      - 
+        #x-go-name: additionalArrayThing
+        type: object
+        properties:
+          thisOneNotRequired:
+            type: integer
+            maximum: 10
+        additionalProperties:
+          type: array
+          uniqueItems: true
+          items: 
+            type: string
+            format: uuid
diff --git a/fixtures/bugs/1487/fixture-basetypes.yaml b/fixtures/bugs/1487/fixture-basetypes.yaml
new file mode 100644
index 00000000..8d2f058e
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-basetypes.yaml
@@ -0,0 +1,195 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: 'tests on polymorphic types: part I base types'
+  description: different types of base types and types based upon base types (by aliasing or composition)
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  # different sorts of base types, from trivial to rich
+  trivialBase:
+    type: object
+    description: 'do not expect validations on this trivialBase: validation should be empty'
+    discriminator: trivialType
+    required:  
+      - trivialType
+    properties:
+      trivialType: 
+        type: string
+  trivialBaseWithValidation:
+    type: object
+    description: 'do not expect validation on the discriminator: they are documentary only'
+    discriminator: trivialTypeWithValidation
+    required: 
+      - trivialTypeWithValidation
+    properties:
+      trivialTypeWithValidation: 
+        description: 'not actually validated. This is documentary only'
+        type: string
+        maxLength: 255
+  baseWithProperty:
+    type: object
+    discriminator: baseWithPropertyType
+    required:
+      - baseWithPropertyType
+    properties:
+      baseWithPropertyType:
+        type: string
+      baseSize:
+        description: this one for sanity check simple validations
+        type: integer
+        minimum: 0
+  baseWithAddProps:
+    type: object
+    description: 'BREAKS'
+    discriminator: baseWithAddPropsType
+    required:
+      - baseWithAddPropsType
+    properties:
+      baseWithAddPropsType: 
+        description: this one for sanity check simple validations
+        type: string
+        format: hostname
+    additionalProperties:
+      type: object
+      properties:
+        baseAddProp:
+          type: integer
+          minimum: 0
+  baseWithMap:
+    description: 'PASS'
+    type: object
+    discriminator: baseWithMapType
+    required:
+      - baseWithMapType
+    properties:
+      baseWithMapType:
+        type: string
+    additionalProperties: true
+  baseWithTuple:
+    description: 'BREAKS'
+    type: object
+    discriminator: baseWithTupleType
+    required:
+      - baseWithTupleType
+    properties:
+      baseWithTupleType:
+        type: string
+      baseTuple: 
+        type: array
+        items:
+          - type: integer
+            minimum: 0
+          - type: string
+            format: date
+        additionalItems:
+          type: string
+          format: uuid
+  baseWithAllOf:
+    type: object
+    discriminator: baseWithAllOfType
+    required:
+      - baseWithAllOfType
+    properties:
+      baseWithAllOfType:
+        type: string
+      baseComposition:
+        type: object 
+        allOf: 
+          - properties:
+              baseProp1:
+                type: string
+            additionalProperties:
+              type: object
+              properties:
+                extendedProp1:
+                  type: string
+          - properties:
+              baseProp2:
+                type: string
+            additionalProperties:
+              type: object
+              properties:
+                extendedProp1:
+                  type: string
+  #
+  # Composition patterns on base types
+  #
+  # Aliases on 'trivialBase'
+  trivialSliceAlias:
+    type: array 
+    items: 
+      $ref: '#/definitions/trivialBase'
+  trivialSliceAliasWithValidation:
+    type: array 
+    maxItems: 15
+    items: 
+      $ref: '#/definitions/trivialBase'
+  trivialMapAlias:
+    type: object 
+    additionalProperties: 
+      $ref: '#/definitions/trivialBase'
+  # Aliases on trivialBaseWithValidation
+  trivialWithValidationSliceAlias:
+    type: array 
+    items: 
+      $ref: '#/definitions/trivialBaseWithValidation'
+  trivialWithValidationSliceAliasWithValidation:
+    type: array 
+    maxItems: 15
+    items: 
+      $ref: '#/definitions/trivialBaseWithValidation'
+  trivialWithValidationMapAlias:
+    type: object 
+    additionalProperties: 
+      $ref: '#/definitions/trivialBaseWithValidation'
+  # Aliases on ...
+  # TODO
+  # Compositions of base type 'trivialBase'
+  # As properties
+  trivialInProps:
+    type: object 
+    properties:
+      genericTrivialProp:
+        $ref: '#/definitions/trivialBase'
+  # As items
+  trivialInItems:
+    type: array
+    maxItems: 10
+    items:
+      $ref: '#/definitions/trivialBase'
+  # As additional properties
+  trivialInAddProps:
+    type: object 
+    properties:
+      prop1:
+        type: integer 
+        minimum: 10
+    additionalProperties:
+      $ref: '#/definitions/trivialBase'
+  # As tuple elements, with additionalItems
+  trivialInTuple:
+    type: array
+    items:
+      - type: integer       # sanity check element
+        minimum: 10
+      - $ref: '#/definitions/trivialBase'
+    additionalItems:
+     $ref: '#/definitions/trivialBase'
+
+  # As allOf: means creating a new subtype. 
+  # This is multiple inehritance and this story shall also be told...
diff --git a/fixtures/bugs/1487/fixture-complex-allOf.yaml b/fixtures/bugs/1487/fixture-complex-allOf.yaml
new file mode 100644
index 00000000..504e6964
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-complex-allOf.yaml
@@ -0,0 +1,98 @@
+
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: fixture for nested allOf with ref
+  description: |
+    We check that validation bubbles up properly, with various compounds of 
+    complex structures, as well as no validation is generated when not necessary.
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: Used to see if a codegen can render all the possible enum categories
+      responses:
+        default:
+          description: Generic Out
+
+definitions:
+  # with slices
+  sliceOfAllOf:
+    type: array
+    uniqueItems: true
+    items:
+      # this one should issue a warning
+      allOf:
+        - type: object 
+          properties: 
+            prop0:
+              type: string
+              format: uuid
+        - $ref: '#/definitions/sliceOfInterfaces'
+  sliceOfInterfaces:
+    type: array
+    items:
+      type: object 
+      additionalProperties: true
+  sliceOfInterfacesWithValidation:
+    type: array
+    maxItems: 10
+    items:
+      type: object 
+      additionalProperties: true
+  allOfAliases:
+    allOf:
+      - $ref: '#/definitions/aliasedDate'
+      - $ref: '#/definitions/aliasedNullableDate'
+  allOfSlicesOfAliases:
+    type: object
+    allOf:
+      - type: object 
+        properties: 
+          prop1:
+            type: array 
+            maxItems: 10
+            items:
+              $ref: '#/definitions/aliasedDate'
+      - type: object 
+        properties: 
+          prop2:
+            type: array 
+            maxItems: 20
+            items:
+              $ref: '#/definitions/aliasedNullableDate'
+  sliceMix:
+    # This one is actually impossible to unmarshall
+    # However, the generated unmarshalling and validation code is interesting to observe
+    # to better understand how the generator works
+    allOf:
+      - $ref: '#/definitions/sliceOfAllOf'
+      - $ref: '#/definitions/sliceOfInterfaces'
+  objectMix:
+    allOf:
+      - type: object      # expect no validation here?
+      - type: object
+        properties:
+          prop1:
+            allOf:
+              - $ref: '#/definitions/aliasedDate'
+              - $ref: '#/definitions/aliasedNullableDate'
+      - type: object
+        properties:
+          prop2:
+            allOf:
+              - $ref: '#/definitions/aliasedDate'
+              - $ref: '#/definitions/aliasedNullableDate'
+  aliasedDate:
+    type: string
+    format: date
+  aliasedNullableDate:
+    type: string
+    format: date
+    x-nullable: true
diff --git a/fixtures/bugs/1487/fixture-errors.yaml b/fixtures/bugs/1487/fixture-errors.yaml
new file mode 100644
index 00000000..e9c4005e
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-errors.yaml
@@ -0,0 +1,28 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: fixture with erroneous statements
+  description: see how the codegen reacts with invalid things (used to cover error cases in UT)
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  arrayWithoutItems:
+    description: in swagger, an array **MUST** have an items schema
+    type: array
+  multipleTypes:
+    description: 'in swagger, an array **MUST** have an items schema: therefore this definition is invalid'
+    type: [ object, array ]
diff --git a/fixtures/bugs/1487/fixture-is-nullable.yaml b/fixtures/bugs/1487/fixture-is-nullable.yaml
new file mode 100644
index 00000000..8bdd4c85
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-is-nullable.yaml
@@ -0,0 +1,32 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: fixture for x-nullable flag
+  description: just an elementary check with the x-nullable tag
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: Used to see if a codegen can render all the possible enum categories
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  thingWithNullableDates:
+    type: object
+    properties:
+      prop1: 
+        type: string
+        format: date
+      prop2: 
+        type: string
+        format: date
+        x-nullable: true
diff --git a/fixtures/bugs/1487/fixture-itching.yaml b/fixtures/bugs/1487/fixture-itching.yaml
new file mode 100644
index 00000000..8c56917b
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-itching.yaml
@@ -0,0 +1,197 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: fixture for additionalProperties
+  description: |
+    This one regroups a number of itching cases, essentially around additionalProperties.
+    In particular, we test some things with empty objects (no properties) which have additionalProperties of diverse sorts.
+    We also added here some funny models using the special types Files, string format: binary and interface{}
+    These special cases do not correspond to actual API specs: we use them to verify the internal behavior of the general.
+
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: Used to see if a codegen can render all the possible enum categories
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  emptyObjectWithAdditionalSlice:
+    type: object
+    additionalProperties:
+      type: array
+      items:
+        type: object
+        properties:
+          dummyProp1: 
+            type: string
+            format: date
+  emptyObjectWithAdditionalNestedSlice:
+    type: object
+    additionalProperties:
+      type: array
+      items:
+        type: array 
+        items: 
+          type: array
+          items:
+            type: object
+            properties:
+              dummyProp1: 
+                type: string
+                format: date
+  aliasedThing:
+    type: object
+    properties: 
+      prop1: 
+        type: string
+        format: date
+  nullableThing:
+    type: string
+    format: date
+    # atm, such check is not supported
+    #pattern: '^2017-..-..$'
+    x-nullable: true
+  emptyObjectWithAdditionalAlias:
+    type: object
+    additionalProperties:
+      $ref: '#/definitions/aliasedThing'
+  emptyObjectWithAdditionalNullable:
+    type: object
+    additionalProperties:
+      $ref: '#/definitions/nullableThing'
+  objectWithEmptyObject:
+    type: object
+    properties:
+      nonEmptyObj: 
+        $ref: '#/definitions/nullableThing'
+      emptyObj: 
+        $ref: '#/definitions/emptyObjectWithAdditionalAlias'
+  emptyObjectWithAdditionalNullablePrimitive:
+    type: object
+    additionalProperties:
+      type: string
+      format: date
+      x-nullable: true
+  emptyObjectWithAdditionalNonNullablePrimitive:
+    type: object
+    additionalProperties:
+      type: string
+      format: date
+      # atm, such check is not supported
+      #pattern: '^2018-..-..$'
+  notValidatedAdditionalProps:
+    type: object
+    properties: 
+      prop2:
+        type: string
+        format: uuid
+    additionalProperties:
+      type: object 
+      additionalProperties: 
+        type: object 
+        additionalProperties: 
+          type: string
+  notValidatedAdditionalPropsSlice:
+    type: object
+    properties: 
+      prop2:
+        type: string
+        format: uuid
+    additionalProperties:
+      type: array 
+      items:
+        additionalProperties: 
+          type: object 
+          additionalProperties: 
+            type: string
+  # At the moment, this one generates a non-empty Validate()
+  # this is because of the len(properties) validation criterion
+  notValidatedAtAll:
+    type: object
+    properties: 
+      prop2:
+        type: string
+    additionalProperties:
+      type: array 
+      items:
+        additionalProperties: 
+          type: object 
+          additionalProperties: 
+            type: string
+  enumsWithAdditionalProps:
+    type: object
+    enum: 
+      - '{ "a": 1, "b": 2 }'
+      - '{ "a": 3, "b": 4 }'
+    additionalProperties:
+      type: object
+      enum: 
+        - '{ "b": 2 }'
+        - '{ "b": 4 }'
+  goodOldFormatIssue:
+    type: object 
+    required: [ myFile ]
+    properties:
+      myFile: 
+        type: string
+        format: binary
+      anotherFile: 
+        type: string
+        format: binary
+      alternateFile:
+        type: file
+      thisAliasedFile: 
+        $ref:  '#/definitions/aliasedFile'
+      thisNullableAliasedFile: 
+        $ref:  '#/definitions/aliasedNullableFile'
+      thisAlternateAliasedFile:
+        $ref:  '#/definitions/aliasedTypeFile'
+      thisNullableAlternateAliasedFile:
+        $ref:  '#/definitions/aliasedTypeNullableFile'
+      myBytes: 
+        type: string
+        format: byte
+  sliceOfAliasedFiles:
+    type: array 
+    minItems: 4
+    items: 
+      $ref: '#/definitions/aliasedFile'
+  additionalFile:
+    type: object
+    properties: 
+      dirName:
+        type: string
+    additionalProperties:
+      type: string
+      format: binary
+  additionalAliasedFile:
+  aliasedFile:
+    type: string
+    format: binary
+  aliasedTypeFile:
+    type: file
+  aliasedNullableFile:
+    type: string
+    format: binary
+    x-nullable: true
+  aliasedTypeNullableFile:
+    type: file
+    x-nullable: true
+  topLevelFormatIssue:
+    type: object 
+    properties:
+      myFile: 
+        type: string
+        format: binary
+      myAlternateFile: 
+        type: file
diff --git a/fixtures/bugs/1487/fixture-nested-maps.yaml b/fixtures/bugs/1487/fixture-nested-maps.yaml
new file mode 100644
index 00000000..55f0c14d
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-nested-maps.yaml
@@ -0,0 +1,160 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: Nested maps
+  description: |
+    Testes focused on nested maps (i.e.nested AdditionalProperties)
+
+produces:
+  - application/json
+
+consumes:
+  - application/json
+
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: Used to see if a codegen can render all the possible parameter variations for a header param
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  NamedNestedMapComplex:
+    type: object
+    additionalProperties:
+      type: object
+      additionalProperties:
+        type: object
+        additionalProperties:
+          type: object
+          properties:
+            name:
+              type: string
+              minLength: 10
+              maxLength: 50
+              pattern: "\\w+"
+            age:
+              type: integer
+              format: int32
+              multipleOf: 1
+              minimum: 1
+              maximum: 200
+              exclusiveMaximum: true
+              exclusiveMinimum: true
+  NamedNestedMapWithSlice:
+    type: object
+    additionalProperties:
+      type: object
+      additionalProperties:
+        type: object
+        additionalProperties:
+          type: array
+          maxItems: 100
+          items:
+            type: string
+            minLength: 10
+  NestedMapValidations:
+    type: object
+    properties:
+      meta:
+        type: object
+        additionalProperties:
+          type: object
+          additionalProperties:
+            type: object
+            additionalProperties:
+              type: integer
+              format: int64
+              minimum: 3
+              maximum: 6
+              multipleOf: 1
+  NestedMapComplexValidations:
+    type: object
+    properties:
+      meta:
+        type: object
+        additionalProperties:
+          type: object
+          additionalProperties:
+            type: object
+            additionalProperties:
+              type: object
+              properties:
+                name:
+                  type: string
+                  minLength: 10
+                  maxLength: 50
+                  pattern: "\\w+"
+                age:
+                  type: integer
+                  format: int32
+                  multipleOf: 1
+                  minimum: 1
+                  maximum: 200
+                  exclusiveMaximum: true
+                  exclusiveMinimum: true
+  NestedMapNoValidations:
+    type: object
+    additionalProperties:
+      type: object
+      additionalProperties:
+        type: object
+        additionalProperties:
+          type: object
+          properties:
+            name:
+              type: string
+            age:
+              type: integer 
+  NestedMapSliceOfInterface:
+    type: object
+    additionalProperties:
+      type: object
+      additionalProperties:
+        type: object
+        additionalProperties:
+          type: array
+          items:
+            $ref: '#/definitions/aliasInterface'
+  NestedMapMaxSliceOfInterface:
+    type: object
+    additionalProperties:
+      type: object
+      additionalProperties:
+        type: object
+        additionalProperties:
+          type: array
+          maxItems: 10
+          items:
+            $ref: '#/definitions/aliasInterface'
+  aliasInterface:
+    type: object
+    additionalProperties: true
+  testNestedInterface:
+    type: object
+    properties:
+      meta:
+        type: object
+        additionalProperties:
+          type: object
+          additionalProperties:
+            type: object
+            additionalProperties:
+              type: object
+              additionalProperties: true
+  testNestedAliasedInterface:
+    type: object
+    properties:
+      meta:
+        type: object
+        additionalProperties:
+          type: object
+          additionalProperties:
+            type: object
+            additionalProperties:
+              $ref: '#/definitions/aliasInterface'
diff --git a/fixtures/bugs/1487/fixture-polymorphism.yaml b/fixtures/bugs/1487/fixture-polymorphism.yaml
new file mode 100644
index 00000000..53e1fbcf
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-polymorphism.yaml
@@ -0,0 +1,158 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: check validation codegen on polymorphic types
+  description: various patterns of polymorphic types with or without validation
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  # TODO: map of polymorphic types
+  # TODO: tuple in base type
+  # TODO: marshal aliases of base type
+  # TODO: marshal additional properties in base type
+  MapOfNodes:
+    type: object
+    additionalProperties:
+      $ref: "#/definitions/Node"
+  # Issue: Validate() is empty
+  Graph:
+    type: object
+    properties:
+      Nodes:
+        type: array
+        items:
+          $ref: "#/definitions/Node"
+  SmallGraph:
+    type: object
+    properties:
+      Nodes:
+        maxItems: 10
+        type: array
+        items:
+          $ref: "#/definitions/Node"
+  # Issue: Validate() is empty instead of just return nil
+  Node:
+    type: object
+    discriminator: NodeType
+    required:
+      - NodeType
+    properties:
+      NodeType:
+        type: string
+      NodeSize:
+        type: integer
+        minimum: 0
+  SmallNode:
+    type: object
+    discriminator: NodeType
+    required:
+      - NodeType
+    properties:
+      NodeType:
+        # no validations are taken into account on discriminator property
+        # (purely documentary)
+        type: string
+        maxLength: 255
+  CodeBlockNode:
+    allOf:
+      - $ref: "#/definitions/Node"
+      - properties:
+          Code:
+            type: string
+  # Added an additional subtype
+  DocBlockNode:
+    allOf:
+      - $ref: "#/definitions/Node"
+      - properties:
+          Doc:
+            type: string
+            maxLength: 1000
+  # Issue: alias generated, without Validate()
+  arrayOfBaseTypes:
+    type: array
+    items:
+      $ref: '#/definitions/myBaseType'
+  smallArrayOfBaseTypes:
+    type: array
+    maxItems: 12
+    items:
+      $ref: '#/definitions/myBaseType'
+  # Issue: broken codegen
+  tupleOfBaseTypes:                 # OK
+    type: array
+    items:
+      - $ref: '#/definitions/mySubType1'
+      - $ref: '#/definitions/mySubType2'
+      - $ref: '#/definitions/myBaseType'                # tuple element is a base type
+      # BROKEN - $ref: '#/definitions/smallArrayOfBaseTypes'     # tuple element is an alias on base type (slice)
+      # BROKEN - $ref: '#/definitions/MapOfNodes'                # tuple element is an alias on base type (map)
+  mapOfBaseTypes:
+    type: object 
+    properties: 
+      dummy:
+        type: integer
+        multipleOf: 10
+    additionalProperties:
+      $ref: "#/definitions/myBaseType"
+  tupleWithAdditionalBaseTypes:
+    type: array
+    items:
+      - type: integer
+        minimum: 100
+      - $ref: '#/definitions/mySubType1'
+      - $ref: '#/definitions/mySubType2'
+    additionalItems:
+      $ref: '#/definitions/myBaseType'                # additionalItems are a base type
+  mySubType1:
+    allOf:
+      - $ref: "#/definitions/myBaseType"
+      - properties:
+          subprop1:
+            type: string 
+            format: date
+  mySubType2:
+    allOf:
+      - $ref: "#/definitions/myBaseType"
+      - type: object 
+        additionalProperties:
+          $ref: "#/definitions/myBaseType"
+  myBaseType:
+    type: object
+    discriminator: myObjectType
+    required:
+      - myObjectType
+    properties:
+      myObjectType:
+        type: string
+      myObjectPrice:
+        type: number
+        minimum: 0
+      myObjectResellers:
+        type: array 
+        items: 
+          type: object 
+          required: [name]
+          properties: 
+            name: 
+              type: string
+            address: 
+              type: string
+    additionalProperties:
+      type: array
+      items:
+        additionalProperties: true
+
diff --git a/fixtures/bugs/1487/fixture-simple-allOf.yaml b/fixtures/bugs/1487/fixture-simple-allOf.yaml
new file mode 100644
index 00000000..f9b99741
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-simple-allOf.yaml
@@ -0,0 +1,87 @@
+
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: fixture for nested allOf with ref
+  description: we test various composition combinations, including nested, and nested isolated with a properties (e.g. issue #1479)
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      responses:
+        default:
+          description: Generic Out
+
+definitions:
+  notReallyComposedThing:
+    allOf:
+      - type: object 
+        properties: 
+          prop0:
+            type: string
+            format: uuid
+  composedThing:
+    allOf:
+      - type: object 
+        properties: 
+          prop1:
+            type: string
+            format: uuid
+      - type: object 
+        properties: 
+          prop2:
+            type: string
+            format: uuid
+  simpleNestedObject:
+    allOf:
+      - $ref: '#/definitions/composedThing'
+      - type: object 
+        properties: 
+          prop3:
+            type: string
+            format: uuid
+  deepNestedObject:
+    type: object
+    allOf:
+      - $ref: '#/definitions/simpleNestedObject'
+      - type: object 
+        allOf:
+          - type: object 
+            properties: 
+              prop4:
+                type: string
+                format: uuid
+          - type: object 
+            properties: 
+              prop5:
+                type: string
+                format: date
+  breakNestedObject:
+    type: object
+    allOf:
+      - $ref: '#/definitions/simpleNestedObject'
+      - type: object 
+        properties: 
+          prop6:
+            type: string
+            format: uuid
+          prop7:
+            type: object
+            allOf:
+              - type: object
+                properties:
+                  prop8:
+                    type: integer
+                    minimum: 12
+              - type: object
+                properties:
+                  prop9:
+                    type: integer
+                    maximum: 12
diff --git a/fixtures/bugs/1487/fixture-tuple.yaml b/fixtures/bugs/1487/fixture-tuple.yaml
new file mode 100644
index 00000000..33badbad
--- /dev/null
+++ b/fixtures/bugs/1487/fixture-tuple.yaml
@@ -0,0 +1,87 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: fixture for tuples and additionalItems
+  description: check different patterns of additionalItems validations or absence thereof
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  comics:
+    type: array
+    items:
+      # no validation expected here
+      - type: string
+      # validation expected here
+      - type: object
+        required: [narrative]
+        properties:
+          narrative:
+            type: string
+      # validation expected here too
+      - type: object
+        properties:
+          marketingBS:
+            type: string
+      # validation expected here
+      - type: object
+        properties:
+          character:
+            type: string
+            pattern: '^[A-Z]+$'
+          author:
+            type: string
+            minLength: 1
+      # validation expected here
+      - type: array
+        items: 
+          type: string
+          format: isbn
+      - type: integer
+  classics:
+    type: array
+    items:
+      # no validation here
+      - type: integer 
+      # validation here
+      - type: string 
+        format: isbn
+      # validation here
+      - $ref: '#/definitions/comics'
+    additionalItems:
+      # validation expected here
+      type: array
+      items:
+        - type: object
+          properties:
+            title:
+              type: string
+              enum: [ 'Les Misrables', 'Bleak House', 'Sherlock Holmes', 'Siddhartha' ]
+            period:
+              type: string
+        - type: array
+          items:
+            type: string
+            format: date
+        - type: object
+          properties:
+            origin: 
+              type: string
+              enum: [ print, e-book, collection, museum ]
+          additionalProperties:
+              type: string
+              enum: [ bookshop, amazon, library ]
+        - $ref: '#/definitions/comics'
diff --git a/fixtures/bugs/1487/gen-fixtures.sh b/fixtures/bugs/1487/gen-fixtures.sh
new file mode 100755
index 00000000..85a2ad4d
--- /dev/null
+++ b/fixtures/bugs/1487/gen-fixtures.sh
@@ -0,0 +1,152 @@
+#! /bin/bash 
+if [[ ${1} == "--clean" ]] ; then
+    clean=1
+fi
+continueOnError=1
+# A small utility to build fixture servers
+# Fixtures with models only
+
+
+#testcases="${testcases} ../../codegen/issue72.json"
+#testcases="${testcases} ../../canary/bitbucket.org/swagger.json"
+#testcases="${testcases} ../../codegen/azure-text-analyis.json"
+#testcases="${testcases} ../../codegen/todolist.simple.yml"
+#testcases="${testcases} swagger-gsma.yaml"
+#testcases="${testcases} ../844/swagger.json"
+#testcases="${testcases} fixture-844-variations.yaml"
+#testcases="${testcases} fixture-anonymous-enum.yaml"
+#testcases="${testcases} fixture-nested-maps.yaml"
+#testcases="${testcases} fixture-errors.yaml"
+#testcases="${testcases} fixture-simple-allOf.yaml"
+#testcases="${testcases} fixture-complex-allOf.yaml"
+#testcases="${testcases} fixture-is-nullable.yaml"
+#testcases="${testcases} fixture-itching.yaml"
+#testcases="${testcases} fixture-additionalProps.yaml"
+#testcases="${testcases} fixture-tuple.yaml"
+#testcases="${testcases} fixture-allOf.yaml"
+testcases="${testcases} ../1479/fixture-1479-part.yaml"
+#testcases="${testcases} ../1198/fixture-1198.yaml"
+#testcases="${testcases} ../1042/fixture-1042.yaml"
+#testcases="${testcases} ../1042/fixture-1042-2.yaml"
+#testcases="${testcases} ../979/fixture-979.yaml"
+#testcases="${testcases} ../842/fixture-842.yaml"
+#testcases="${testcases} ../607/fixture-607.yaml"
+#testcases="${testcases} ../1336/fixture-1336.yaml"
+#testcases="${testcases} ../1277/cloudbreak.json"
+#testcases="${testcases} ../../codegen/todolist.schemavalidation.yml"
+#testcases="${testcases} ../../codegen/todolist.discriminators.yml"
+#testcases="${testcases} ../../codegen/billforward.discriminators.yml"
+#opts="--skip-flatten"
+#export SWAGGER_DEBUG=1
+for testcase in ${testcases} ; do
+    spec=${testcase}
+    testcase=`basename ${testcase}`
+    if [[ -z ${opts} ]]; then
+        target=./gen-${testcase%.*}-flatten
+    else
+        target=./gen-${testcase%.*}-expand
+    fi
+    serverName="codegensrv"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Model generation for ${spec}"
+    swagger generate model --skip-validation ${opts} --spec=${spec} --target=${target} --output=${testcase%.*}.log
+    # 1>x.log 2>&1
+    #
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        if [[ ! -z ${continueOnError} ]] ; then
+            failures="${failures} codegen:${spec}"
+            continue
+        else
+            exit 1
+        fi
+    fi
+    echo "${spec}: Generation OK"
+    if [[ ! -d ${target}/models ]] ; then
+        echo "No model in this spec! Skipped"
+    else
+        (cd ${target}/models; go build)
+        if [[ $? != 0 ]] ; then
+            echo "Build failed for ${spec}"
+            if [[ ! -z ${continueOnError} ]] ; then
+                failures="${failures} build:${spec}"
+                continue
+            else
+                exit 1
+            fi
+        fi
+        echo "${spec}: Build OK"
+        if [[ -n ${clean} ]] ; then 
+             rm -rf ${target}
+        fi
+    fi
+done
+if [[ ! -z ${failures} ]] ; then 
+    echo ${failures}|tr ' ' '\n'
+else
+    echo "No failures"
+fi
+exit
+# Non reg codegen
+# NOTE(fredbi): 
+# - azure: invalid spec 
+# - bitbucket: model does not compile
+# - issue72: invalid spec
+# - todolist.discriminator: ok now
+testcases=`cd ../../codegen;ls -1|grep -vE 'azure|bitbucket|existing-model|issue72|todolist.simple.yml'`
+#testcases=${testcases}" fixture-1062.json fixture-984.yaml"
+#testcases=`cd ../../codegen;ls -1|grep  'todolist.enums.yml'`
+for testcase in ${testcases} ; do
+    target=./gen-${testcase%.*}
+    if [[ -f ../../codegen/${testcase} ]] ; then
+      spec=../../codegen/${testcase}
+    else 
+      spec=${testcase}
+    fi
+    serverName="nrcodegen"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Server generation for ${spec}"
+    swagger generate server --skip-validation --spec ${spec} --target ${target} --name=${serverName} 1>${testcase%.*}.log 2>&1
+    #--output=${testcase%.*}.log
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Generation OK"
+    (cd ${target}/cmd/${serverName}"-server"; go build)
+    if [[ $? != 0 ]] ; then
+        echo "Build failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Build OK"
+    if [[ -n ${clean} ]] ; then 
+        rm -rf ${target}
+    fi
+done
+# TODO(fredbi): enable non reg again
+testcases=
+for testcase in ${testcases} ; do
+    target=./gen-${testcase%.*}
+    spec=./${testcase}
+    serverName="bugfix"
+    rm -rf ${target}
+    mkdir ${target}
+    echo "Generation for ${spec}"
+    swagger generate server --spec ${spec} --target ${target} --quiet --name=${serverName}
+    if [[ $? != 0 ]] ; then
+        echo "Generation failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Generation OK"
+    (cd ${target}/cmd/${serverName}"-server"; go build)
+    if [[ $? != 0 ]] ; then
+        echo "Build failed for ${spec}"
+        exit 1
+    fi
+    echo "${spec}: Build OK"
+    if [[ -n ${clean} ]] ; then 
+        rm -rf ${target}
+    fi
+done
diff --git a/fixtures/bugs/606/fixture-606.yaml b/fixtures/bugs/606/fixture-606.yaml
new file mode 100644
index 00000000..9c78f40f
--- /dev/null
+++ b/fixtures/bugs/606/fixture-606.yaml
@@ -0,0 +1,61 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: broken code because Validate() is not produced
+  description: broken code produced on polymorphic type
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  RangeFilter:
+    allOf:
+    - $ref: '#/definitions/Filter'
+    - properties:
+        config:
+          properties:
+            gt:
+              format: double
+              type: number
+            gte:
+              format: double
+              type: number
+            lt:
+              format: double
+              type: number
+            lte:
+              format: double
+              type: number
+          type: object
+      required:
+      - config
+      type: object
+  Filter:
+    discriminator: type
+    properties:
+      type:
+        type: string
+    required:
+    - type
+    type: object
+  NotFilter:
+    allOf:
+    - $ref: '#/definitions/Filter'
+    - properties:
+        config:
+          $ref: '#/definitions/Filter'
+      required:
+      - config
+      type: object
diff --git a/fixtures/bugs/607/fixture-607.yaml b/fixtures/bugs/607/fixture-607.yaml
new file mode 100644
index 00000000..2a61508e
--- /dev/null
+++ b/fixtures/bugs/607/fixture-607.yaml
@@ -0,0 +1,63 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: broken code when using array of polymorphic type
+  description: broken code produced on polymorphic type
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  RangeFilter:
+    allOf:
+      - $ref: '#/definitions/Filter'
+      - properties:
+          config:
+            properties:
+              gt:
+                format: double
+                type: number
+              gte:
+                format: double
+                type: number
+              lt:
+                format: double
+                type: number
+              lte:
+                format: double
+                type: number
+            type: object
+        required:
+          - config
+        type: object
+  Filter:
+    discriminator: type
+    properties:
+      type:
+        type: string
+    required:
+      - type
+    type: object
+  AndFilter:
+    allOf:
+      - $ref: '#/definitions/Filter'
+      - properties:
+          config:
+            items:
+              $ref: '#/definitions/Filter'
+            type: array
+        required:
+          - config
+        type: object
diff --git a/fixtures/bugs/842/fixture-842.yaml b/fixtures/bugs/842/fixture-842.yaml
new file mode 100644
index 00000000..f5133820
--- /dev/null
+++ b/fixtures/bugs/842/fixture-842.yaml
@@ -0,0 +1,34 @@
+swagger: '2.0'
+info:
+  title: polymorphic type containing an array of the base type
+  description: codegen fails to produce code that builds
+paths:
+  /execute:
+    post:
+      responses:
+        200:
+          schema:
+            type: "array"
+            items:
+              $ref: "#/definitions/Value"
+
+definitions:
+  Value:
+    type: "object"
+    discriminator: "ValueType"
+    required:
+      - "ValueType"
+    properties:
+      ValueType:
+        type: "string"
+
+  ValueArray:
+    allOf:
+      - $ref: "#/definitions/Value"
+      - required:
+          - "Values"
+        properties:
+          Values:
+            type: "array"
+            items:
+              $ref: "#/definitions/Value"
diff --git a/fixtures/bugs/979/fixture-979.yaml b/fixtures/bugs/979/fixture-979.yaml
new file mode 100644
index 00000000..c0898ed1
--- /dev/null
+++ b/fixtures/bugs/979/fixture-979.yaml
@@ -0,0 +1,38 @@
+swagger: '2.0'
+
+info:
+  version: "1.0.0"
+  title: allOf without the explicit type object
+  description: checking that properties is enough to figure out an object schema
+produces:
+  - application/json
+consumes:
+  - application/json
+paths:
+  /models:
+    get:
+      operationId: modelOp
+      summary: many model variations
+      description: no description
+      tags:
+        - testcgen
+      responses:
+        default:
+          description: Generic Out
+definitions:
+  Cluster:
+    type: object 
+    allOf:
+      - $ref: '#/definitions/NewCluster'
+      - properties:
+          result: 
+            description: results of cluster creation 
+            type: string  
+          status:
+            description: status of cluster created|updated|running|deleted 
+            type: string
+  NewCluster:
+    type: object
+    properties: 
+      dummyProp1:
+        type: integer
diff --git a/generator/bindata.go b/generator/bindata.go
index 16878ba9..1b9a2436 100644
--- a/generator/bindata.go
+++ b/generator/bindata.go
@@ -156,7 +156,7 @@ func templatesClientFacadeGotmpl() (*asset, error) {
 	return a, nil
 }
 
-var _templatesClientParameterGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5a\x5f\x73\xdb\xb8\x11\x7f\xe7\xa7\xd8\xaa\xee\x55\xf4\x38\xd4\x3d\xfb\x46\x9d\xc9\xd9\xbe\xc6\x9d\x69\xce\x4d\x3c\xd7\x87\x4c\xa6\x03\x93\x2b\x09\x17\x12\xa0\x01\x50\xb6\xaa\xe1\x77\xef\xe0\x0f\x49\x90\x22\x25\x2a\x8e\xe3\x66\x2e\x4f\x92\x40\x60\xb1\xfb\xdb\xdf\xfe\x01\xa8\xd9\x0c\x2e\x78\x82\xb0\x44\x86\x82\x28\x4c\xe0\x6e\x03\x4b\xfe\x4a\x3e\x90\xe5\x12\xc5\x4f\x70\xf9\x2b\xbc\xfd\xf5\x16\xae\x2e\xaf\x6f\xa3\x20\x08\xb6\x5b\xa0\x0b\x88\x2e\x78\xbe\x11\x74\xb9\x52\xf0\xaa\x2c\x67\x33\xd8\x6e\x21\xe6\x59\x86\x4c\x75\x9e\x6d\xb7\x80\x2c\x81\xb2\x0c\x82\x20\x27\xf1\x27\xb2\x44\x3d\x39\xba\x71\xdf\xf5\x83\xd9\x0c\x6e\x57\x54\xc2\x82\xa6\x08\x0f\x44\xb6\x95\x51\x2b\x04\xa7\x0d\x28\xce\xd3\x48\xcf\xbf\x4a\xa8\xa2\x6c\x09\xaa\x5e\x97\x99\x1d\x73\xc1\xd7\x08\x8b\x42\x19\x51\x2b\x64\xb0\xe1\x05\x08\x7c\x25\x0a\xd6\x92\x54\x6d\x61\xd4\x26\x2c\x09\x02\x9a\xe5\x5c\x28\x98\x06\x00\x13\x86\x6a\xb6\x52\x2a\x9f\x04\xfa\xd7\x92\xa7\x84\x2d\x23\x2e\x96\xb3\xc7\x99\x7e\x14\x73\xa6\xf0\x51\xb9\xa7\x54\xad\x8a\xbb\x28\xe6\xd9\x6c\xc9\x5f\xf1\x1c\x19\xc9\xe9\x4c\x14\x4c\xd1\x0c\x27\xc3\x33\xb4\x26\x7b\x1e\xa3\x10\x5c\xc8\x3d\x13\xd6\x24\xa5\x09\x51\x66\x8b\x58\x1c\xd0\x63\x16\xa7\x14\x99\xd5\x58\x2a\xb1\xc8\xd4\xa0\x5a\xe6\xa9\x99\xb8\xdd\x82\x20\x6c\x89\x10\x5d\xe2\x82\x14\xa9\xba\x36\x10\x49\x30\x6e\xcd\x05\x65\x6a\x01\x93\xbf\xdc\x4f\x20\x2a\x4b\x3b\xdf\xf9\xda\x5b\x7b\xf2\x09\x37\x67\x70\xb2\x26\x69\x81\x70\x3e\x87\xa8\x25\x44\x3f\x85\xb2\x84\x8e\x3c\x37\xbd\x23\x35\x34\x54\x79\x8b\x0f\x7a\x36\x91\x31\x49\xe9\x7f\x11\xa2\xb7\x24\xd3\x53\x6f\x88\x20\x99\x84\x58\x20\x51\x28\x81\x00\xc3\x07\xd8\x37\x93\xdf\xfd\x8e\xb1\xd2\x22\x1f\xa8\x5a\x19\x76\x24\xd6\x4e\x30\xdb\x4b\xa0\x8c\x2a\x6a\xd6\x26\x51\xb0\x28\x58\x7c\x60\xf3\x69\x08\xa7\xfb\x76\xdc\x5a\x73\x74\x00\xb9\x91\xb2\x5c\x13\x61\x38\xd7\x80\x5d\x3f\x72\x53\xdf\x10\xe9\xf0\xaf\xc7\x18\x57\x10\x5d\xcb\x5f\x68\x8a\x66\xb6\x7d\xb0\x26\x82\xe9\xfd\xa2\xeb\xcb\xb2\xac\x96\xcc\xab\x1d\xaf\xe5\x8d\xa0\x19\x55\x74\x8d\x7a\x76\xf4\x77\x7e\xbb\xc9\xb1\x2c\xa7\x16\xe0\xb6\x4f\xff\xbc\x9e\xd4\x5e\x6f\x34\xf1\x44\x40\x59\x86\x1d\x7f\xdb\xef\xde\x17\x23\x35\x00\x68\x4d\x14\xa8\x0a\xc1\xe0\x87\x5d\x9c\x2a\x98\xb6\x47\xa1\xb1\x23\xe4\xdc\x19\x4c\x58\x02\x53\x07\xd4\x6b\x21\xc8\x26\xac\x7f\xfe\x93\xe4\xd5\x0f\x2d\x8e\xca\x58\x9b\xc5\x88\xe2\x22\x84\x29\x17\x7a\xce\xdb\x22\x4d\xc9\x5d\x8a\x00\x21\x94\xe5\x0f\xbe\x7d\x1e\xce\x50\x03\x7d\xd6\x0b\x42\x00\x60\x86\x63\x92\xa1\x55\xf2\x96\x66\xc8\x0b\xe5\x88\x71\x0e\xb1\xa8\x70\x76\x4f\xb4\xa0\x32\x28\x47\x70\xfd\xdf\x54\xad\xdc\xa2\xe7\xa2\xfd\x99\x81\x51\xcf\x21\x77\x34\xa5\x6a\x03\x8a\x83\x44\x05\x04\x94\xdb\x99\x33\x20\x20\xf0\xbe\x40\xa9\xc6\x04\x89\xa7\xf5\xb4\x92\xa1\x3f\xa3\xcb\x42\x10\x45\x39\xfb\x1e\x44\x2f\x19\x44\xda\xec\x6f\x2c\x84\xd4\xe7\x04\xce\x85\xad\xe1\x2f\x10\x38\xae\x7b\x80\x05\x17\xc7\x47\x8e\x53\x7b\x1a\xab\xc7\x4a\x50\xe4\xc6\x5e\x36\x6e\x1a\xf7\x58\x1a\xfe\x01\x43\xe7\x6b\xd5\x9f\x36\xd4\xa3\xe2\xc7\x51\xe4\x1c\x62\xf5\x78\x5c\x9c\xbc\xb9\xbd\xbd\xb9\x30\xcd\xe3\x4b\x84\x4a\x21\x15\xcf\xc0\xd3\xe1\xb3\x82\xa6\x59\x3f\xb5\x7d\x30\x9c\xea\xee\x3e\xb2\x63\xdf\xe3\xe6\x7b\xdc\xf4\xe0\xd0\x90\xe6\x1c\x2c\x6b\x9a\xc0\xd9\x4b\x18\x9d\x96\x09\x65\x12\x48\x9a\x1a\x5a\xe7\x7a\x1c\x15\x0a\x69\x99\xad\xd9\xce\xcd\x93\xd7\x37\xd7\x7a\xb7\x9c\x53\xa6\x02\x4d\x6d\x3d\xb8\xdd\xc2\xaa\xc8\x08\xf3\x45\x03\xcf\xd1\x76\x47\xa0\x36\x39\x8d\x49\x9a\x9a\x93\xb1\x44\x20\x02\xe1\x41\x50\xa5\x90\x69\xb1\x04\x0c\xb5\xdf\xb9\x08\x39\x9d\x05\x6a\x93\xe3\xde\x68\x95\x4a\x14\xb1\x82\x6d\xd0\xef\xc0\x01\x6b\xb7\x5b\xed\xd6\x4b\xd4\x4e\xc8\x8d\x66\x15\xa1\xee\x52\x1e\x7f\xaa\xaf\x03\x3a\x33\x7c\xac\x4f\x67\xf6\x57\xab\xfd\x70\xc7\xc1\xa7\x30\xc1\x4d\xba\x66\x0a\xc5\x82\xc4\xd8\x0c\xbd\x57\x02\x49\x36\x40\x96\x53\x9f\x04\x83\x01\xeb\x02\xd0\x51\x25\x95\xfa\x9b\x3b\x65\x1b\x68\x92\x77\x48\x92\x8b\x94\x4b\x14\x4d\x28\x79\xd7\x20\x7b\x9b\x99\x76\x27\x1c\xd4\x89\xbb\x5b\xeb\x03\xf0\x93\xa2\x9f\xcd\x5c\x62\xd7\x69\xaf\x8d\x6c\x67\x23\x92\x24\xd2\xd0\xad\xee\xc1\xf9\x30\xfb\x0c\x83\xa5\x4d\xb7\x3a\xef\x44\xef\x30\x46\xba\x46\x51\x4d\xd8\x17\x10\xe1\x41\x65\x9e\x72\x0e\xe8\xaa\x12\xbd\x47\x35\x66\xaf\xb0\xc9\x69\x3d\x52\x1c\x8a\x07\x64\x7d\x55\x10\x47\xda\xd5\xc5\x70\x08\xa6\x7d\x24\x9c\x57\xf6\x78\x64\xaa\x88\x58\x9b\x5c\xb5\xb1\xcf\xcc\x9b\x27\x37\xbc\x7d\x04\xf1\x84\x8e\xe5\xc1\x4b\xd8\xdf\xd6\x74\xd7\xfc\x21\x0b\x2b\x5d\xe7\xba\xdd\xf3\x7c\xe8\xa5\x8c\xda\x0c\x6f\xec\x99\x3d\xf9\x25\xba\xb0\x3e\x67\xee\xc8\x1d\xeb\xd2\x97\x83\xa3\x4f\xeb\x0e\x1a\x43\x06\x7b\x0a\xce\x5d\x5f\xa2\x2d\xea\xa9\xdb\xfd\x65\xc0\x16\xd8\xda\x5e\xff\x2c\x6e\xb6\x30\x45\x68\xd7\xf2\x93\x41\xd3\x4f\x0e\xd8\x7e\x72\xb8\x1a\x18\x9d\xa6\xbd\xaa\x7c\x99\x4e\xe0\x6b\x97\x7d\x27\xaf\xcb\xe9\x93\x7e\x52\xef\x20\xb8\x5b\xc3\x86\x11\xfa\xbc\x3a\xb6\xcb\x82\x4e\x73\xfc\xfc\x34\x38\xc2\xc6\x6f\x9d\x05\x83\x7e\xee\x73\xca\xbc\x37\x26\x5d\x8c\xbb\x26\x52\x47\xb6\xa0\x0a\x6f\xb9\xeb\xf3\xcd\x09\x00\xa5\x3b\x12\x58\xdf\xd8\xd3\x40\xf5\xc2\xab\x75\x64\xfe\x9c\x0c\xde\xda\x6f\x2a\xa0\x32\xdb\x26\x23\x37\x7e\x06\x02\x97\xee\x0d\x53\xf4\x0e\x97\x54\x2a\xb1\x09\xc1\xbc\xcc\xb2\x07\x0c\xba\xd0\xbf\xe0\x7c\x0e\x42\xd3\xbc\xba\x09\x3e\xb2\x45\x09\x7f\x32\x52\xfe\x34\x07\x46\x53\x83\x6f\x1d\x05\x28\x84\x39\xa7\x81\x06\x11\x04\x4a\xf8\xf0\xd1\xec\x6f\x9c\xd0\x4a\x92\x55\x3b\xee\xdc\xed\x78\x61\xa8\xe5\x48\xa5\x3f\x7e\xe6\xc9\xc6\xcc\x0f\xeb\x13\x8e\x23\xa3\x4f\x22\x4b\xb2\xd7\x69\xca\x1f\xae\xb2\x5c\x6d\x7e\x23\x69\x81\x7a\x05\x5d\x98\xc0\x34\xbf\xaf\x1e\x73\x81\x52\xda\xa3\x50\xad\x3d\x54\x27\xf9\xe6\xa6\xe1\x5a\xfe\xab\x40\xb1\xa9\x98\x17\x00\xcc\x66\x70\xaf\x87\xac\x73\x8d\xc8\x2a\xc6\xbd\x55\xb5\x3a\xf6\x8e\xe2\x5e\xf4\xfa\x14\x5a\x4c\xb6\x4e\x39\xa0\xa3\x41\x78\x48\xdc\xdc\x70\xa7\x67\xb9\x76\x44\x13\x28\x43\xcb\xcf\xe7\x03\xbb\x7b\xb8\xdc\xf7\x5d\x19\xb8\x95\xda\xf4\x5f\xb8\xc8\x88\x52\x28\x5c\x9c\xfa\xbf\xa7\x03\x1b\x87\x07\x55\xab\x71\xbd\x30\x17\x51\xbe\xd0\xe8\xbd\x12\x94\x2d\xa7\xa1\x3b\xe4\xd5\x1f\x75\xf2\xe8\x70\xa1\x46\xba\xc7\x14\x87\xf4\x64\x52\x93\xa1\x9e\xed\x07\x4b\xc3\x89\x69\xf7\x05\xac\x93\x72\x36\x20\x7d\x54\xbc\xec\xd5\xbd\xec\xde\x1a\x69\xe0\xdc\xe5\x12\x51\xab\x36\x53\x73\xa2\x56\xbd\x44\xed\x18\x54\xaf\x1c\xb6\x67\x8c\x7f\xfb\xe8\x7f\xda\x38\xa4\x87\x59\x9e\xeb\x77\x6b\x4b\xc7\xd9\xe1\x51\x92\x8f\xa7\xcc\x58\xdf\x78\x88\xbf\x41\x92\xa0\x68\x63\xbe\x32\x63\x63\x50\xf7\x56\x7f\xc7\xfd\x28\xdc\xb5\x54\x0f\xf5\x7a\x4f\xbf\x4b\xe8\x4b\xc7\xe3\x93\x6c\x73\x65\x64\x9c\xba\xe0\x22\xb3\xff\x6f\xe9\xf3\xeb\x8e\x67\x6b\x3d\xf6\xfa\xb5\xcf\x2f\x3d\x58\x74\xd0\xf0\x73\x44\xd7\xb4\x9e\x7f\x7f\x38\x2f\x07\x8d\x19\xc7\x14\xae\xc5\x97\x2d\x5c\x43\xe2\x46\x16\xae\xa1\xe5\x63\x0a\xd7\xe2\x29\x85\x6b\x60\xe3\xf0\xa0\x6a\xcf\x52\xb8\x7a\x4c\x19\x59\xb8\xea\xb8\x19\xe6\x65\xbf\xf0\x67\xa8\x5b\x03\xdf\x8f\x69\xe9\x4a\xff\x62\xd7\x4b\x0f\xb6\x73\x2c\x3b\x3a\x79\x1d\x64\xe3\x99\x8b\x15\x4d\x9b\xc3\x86\x6e\x3c\xcd\x88\xe7\x7e\x37\xd0\xe7\x42\x1d\x21\xf6\x3d\x5a\xbf\x47\x3e\x7c\x94\xc6\xc7\x9a\x7e\x5c\xc0\x7f\xce\x60\x6d\x5c\x61\x7a\xdf\x63\xce\x52\xde\x99\xc9\x03\x26\x3c\x98\x8c\x9d\xa7\xf6\xe9\x38\x07\x92\xe7\xc8\x92\xe9\x9e\x49\x36\x5b\x75\x81\x69\x63\xb8\x53\x91\xac\x53\xd7\xad\x39\x07\xe2\xa0\x75\xf0\xeb\x11\xdb\x4c\x09\x3b\x65\x41\xfb\x62\xd8\xc6\x3a\xca\xf7\xa0\x5d\x03\xdc\x42\xff\x28\xb4\xfb\x33\xef\xff\x99\x62\xbf\x73\xca\x30\x19\x4a\x86\xfa\x94\x1a\xfd\x83\x53\xf6\xf3\xc6\x02\xbf\x9f\x16\x93\xed\x36\xba\xe0\x69\x8a\xb1\xa2\x9c\xd9\x15\x65\x39\x09\x07\x0f\x50\xf5\xe9\x89\x98\x10\x1d\xd1\x24\x8d\xe9\xb5\x87\x6c\xd2\xec\x8a\xa2\x63\xfb\x0b\x97\x7e\xfc\x1e\xa3\x2a\x9d\xa3\xb5\x1e\x91\x68\x9f\x45\x69\xff\x08\x50\xf5\xff\xc3\x4a\xdb\x1b\xa9\x66\x4d\xc2\x51\x9a\x5c\x29\x8b\xdc\xfc\x09\x77\x4d\x04\x25\x89\xa0\x31\x10\xb1\x2c\x32\x64\x4a\x9e\x81\xa4\x2c\x46\x78\x40\x28\x24\x26\xe0\x93\xc5\x8a\x7c\x40\x88\x09\x73\xef\x57\x57\x08\x0b\x2a\xa4\x02\xaa\x30\x03\x6a\xff\xfc\x6b\x35\x22\x12\xa8\xfa\x6b\xf3\x7a\x56\xcf\x90\xc0\x17\xf6\x5d\xad\xc0\x35\xe5\x85\xb4\x22\xed\x02\x8b\x18\x28\xbe\x44\xb5\x42\x61\x51\x4f\x91\x4d\xf7\x40\x19\xc2\xdf\xe0\xc7\xaa\x91\x3a\xfe\xd4\xb3\x47\xf2\x87\x1f\x3f\x8e\xee\xd6\xfa\xdf\xf0\x07\xbb\x2f\x24\x6d\xc8\xd4\x75\xca\x2b\x61\xba\x34\xbd\x8f\x57\x98\x11\xff\x8d\xaa\x37\x66\xf3\x04\x4c\x0d\x13\xea\x51\x77\x89\x62\x72\x69\xd8\x7d\x68\x2e\x56\xfa\x1f\x75\x8a\xef\xce\x65\xde\xb8\x1b\x95\xbe\xde\xb8\x36\x6e\xfa\xc4\x16\xb8\x0b\xa4\xd7\x0a\xb8\x6f\x8e\x1e\x02\xa5\x4f\x83\x46\x14\x17\x32\xba\xe0\x59\xce\x25\x55\xf8\x9b\xfd\x1f\x37\xe5\xec\x4a\x3f\xd1\xab\x74\x1c\x3a\xef\xb9\x45\x8c\xa6\x41\x19\xfc\x2f\x00\x00\xff\xff\x59\x07\xb9\x31\xad\x2f\x00\x00")
+var _templatesClientParameterGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5a\x5f\x73\xdb\xb8\x11\x7f\xe7\xa7\xd8\xaa\xee\x55\xf4\x38\xd4\x3d\xfb\x46\x9d\xb9\xb3\x7d\x8d\x3b\xd3\x9c\x9b\x78\xae\x0f\x99\x4c\x07\x26\x57\x12\x2e\x24\x40\x03\xa0\x64\x55\xc3\xef\xde\xc1\x1f\x92\x20\x45\x4a\x54\x12\xc7\x77\xd3\x3c\x49\x02\x81\xc5\xee\x6f\x7f\xfb\x07\xa0\x66\x33\xb8\xe2\x09\xc2\x12\x19\x0a\xa2\x30\x81\x87\x2d\x2c\xf9\x2b\xb9\x21\xcb\x25\x8a\x1f\xe0\xfa\x17\x78\xf3\xcb\x3d\xdc\x5c\xdf\xde\x47\x41\x10\xec\x76\x40\x17\x10\x5d\xf1\x7c\x2b\xe8\x72\xa5\xe0\x55\x59\xce\x66\xb0\xdb\x41\xcc\xb3\x0c\x99\xea\x3c\xdb\xed\x00\x59\x02\x65\x19\x04\x41\x4e\xe2\x8f\x64\x89\x7a\x72\x74\xe7\xbe\xeb\x07\xb3\x19\xdc\xaf\xa8\x84\x05\x4d\x11\x36\x44\xb6\x95\x51\x2b\x04\xa7\x0d\x28\xce\xd3\x48\xcf\xbf\x49\xa8\xa2\x6c\x09\xaa\x5e\x97\x99\x1d\x73\xc1\xd7\x08\x8b\x42\x19\x51\x2b\x64\xb0\xe5\x05\x08\x7c\x25\x0a\xd6\x92\x54\x6d\x61\xd4\x26\x2c\x09\x02\x9a\xe5\x5c\x28\x98\x06\x00\x13\x86\x6a\xb6\x52\x2a\x9f\x04\xfa\xd7\x92\xa7\x84\x2d\x23\x2e\x96\xb3\xa7\x99\x7e\x14\x73\xa6\xf0\x49\xb9\xa7\x54\xad\x8a\x87\x28\xe6\xd9\x6c\xc9\x5f\xf1\x1c\x19\xc9\xe9\x4c\x14\x4c\xd1\x0c\x27\xc3\x33\xb4\x26\x07\x1e\xa3\x10\x5c\xc8\x03\x13\xd6\x24\xa5\x09\x51\x66\x8b\x58\x1c\xd1\x63\x16\xa7\x14\x99\xd5\x58\x2a\xb1\xc8\xd4\xa0\x5a\xe6\xa9\x99\xb8\xdb\x81\x20\x6c\x89\x10\x5d\xe3\x82\x14\xa9\xba\x35\x10\x49\x30\x6e\xcd\x05\x65\x6a\x01\x93\xbf\x3c\x4e\x20\x2a\x4b\x3b\xdf\xf9\xda\x5b\x7b\xf6\x11\xb7\x17\x70\xb6\x26\x69\x81\x70\x39\x87\xa8\x25\x44\x3f\x85\xb2\x84\x8e\x3c\x37\xbd\x23\x35\x34\x54\x79\x83\x1b\x3d\x9b\xc8\x98\xa4\xf4\xbf\x08\xd1\x1b\x92\xe9\xa9\x77\x44\x90\x4c\x42\x2c\x90\x28\x94\x40\x80\xe1\x06\x0e\xcd\xe4\x0f\xbf\x61\xac\xb4\xc8\x0d\x55\x2b\xc3\x8e\xc4\xda\x09\x66\x7b\x09\x94\x51\x45\xcd\xda\x24\x0a\x16\x05\x8b\x8f\x6c\x3e\x0d\xe1\xfc\xd0\x8e\x3b\x6b\x8e\x0e\x20\x37\x52\x96\x6b\x22\x0c\xe7\x1a\xb0\xeb\x47\x6e\xea\x6b\x22\x1d\xfe\xf5\x18\xe3\x0a\xa2\x5b\xf9\x33\x4d\xd1\xcc\xb6\x0f\xd6\x44\x30\xbd\x5f\x74\x7b\x5d\x96\xd5\x92\x79\xb5\xe3\xad\xbc\x13\x34\xa3\x8a\xae\x51\xcf\x8e\xfe\xce\xef\xb7\x39\x96\xe5\xd4\x02\xdc\xf6\xe9\x9f\xd7\x93\xda\xeb\x8d\x26\x9e\x08\x28\xcb\xb0\xe3\x6f\xfb\xdd\xfb\x62\xa4\x06\x00\xad\x89\x02\x55\x21\x18\x7c\xb7\x8f\x53\x05\xd3\xee\x24\x34\xf6\x84\x5c\x3a\x83\x09\x4b\x60\xea\x80\xfa\x51\x08\xb2\x0d\xeb\x9f\xff\x24\x79\xf5\x43\x8b\xa3\x32\xd6\x66\x31\xa2\xb8\x08\x61\xca\x85\x9e\xf3\xa6\x48\x53\xf2\x90\x22\x40\x08\x65\xf9\x9d\x6f\x9f\x87\x33\xd4\x40\x5f\xf4\x82\x10\x00\x98\xe1\x98\x64\x68\x95\xbc\xa7\x19\xf2\x42\x39\x62\x5c\x42\x2c\x2a\x9c\xdd\x13\x2d\xa8\x0c\xca\x11\x5c\xff\x37\x55\x2b\xb7\xe8\xb9\x68\x7f\x61\x60\xd4\x73\xc8\x03\x4d\xa9\xda\x82\xe2\x20\x51\x01\x01\xe5\x76\xe6\x0c\x08\x08\x7c\x2c\x50\xaa\x31\x41\xe2\x69\x3d\xad\x64\xe8\xcf\xe8\xba\x10\x44\x51\xce\xbe\x05\xd1\x4b\x06\x91\x36\xfb\x0f\x16\x42\xea\x53\x02\xe7\xca\xd6\xf0\x17\x08\x1c\xd7\x3d\xc0\x82\x8b\xd3\x23\xc7\xa9\x3d\x8d\xd5\x53\x25\x28\x72\x63\x2f\x1b\x37\x8d\x7b\x2c\x0d\xff\x0f\x43\xe7\x6b\xd5\x9f\x36\xd4\xa3\xe2\xc7\x51\xe4\x12\x62\xf5\x74\x5a\x9c\xbc\xbe\xbf\xbf\xbb\x32\xcd\xe3\x4b\x84\x4a\x21\x15\xcf\xc0\xd3\xe1\x93\x82\xa6\x59\x3f\xb5\x7d\x30\x9c\xeb\xee\x3e\xb2\x63\xdf\xe2\xe6\x5b\xdc\xf4\xe0\xd0\x90\xe6\x12\x2c\x6b\x9a\xc0\x39\x48\x18\x9d\x96\x09\x65\x12\x48\x9a\x1a\x5a\xe7\x7a\x1c\x15\x0a\x69\x99\xad\xd9\xce\xcd\x93\x1f\xef\x6e\xf5\x6e\x39\xa7\x4c\x05\x9a\xda\x7a\x70\xb7\x83\x55\x91\x11\xe6\x8b\x06\x9e\xa3\xed\x8e\x40\x6d\x73\x1a\x93\x34\x35\x27\x63\x89\x40\x04\xc2\x46\x50\xa5\x90\x69\xb1\x04\x0c\xb5\xdf\xba\x08\x39\x9f\x05\x6a\x9b\xe3\xc1\x68\x95\x4a\x14\xb1\x82\x5d\xd0\xef\xc0\x01\x6b\x77\x3b\xed\xd6\x6b\xd4\x4e\xc8\x8d\x66\x15\xa1\x1e\x52\x1e\x7f\xac\xaf\x03\x3a\x33\x7c\xac\xcf\x67\xf6\x57\xab\xfd\x70\xc7\xc1\xcf\x61\x82\x9b\x74\xcb\x14\x8a\x05\x89\xb1\x19\x7a\xa7\x04\x92\x6c\x80\x2c\xe7\x3e\x09\x06\x03\xd6\x05\xa0\xa3\x4a\x2a\xf5\x37\x77\xca\x36\xd0\x24\x6f\x91\x24\x57\x29\x97\x28\x9a\x50\xf2\xae\x41\x0e\x36\x33\xed\x4e\x38\xa8\x13\x77\xb7\xd6\x07\xe0\x27\x45\x3f\x9b\xb9\xc4\xae\xd3\x5e\x1b\xd9\xce\x46\x24\x49\xa4\xa1\x5b\xdd\x83\xf3\x61\xf6\x19\x06\x4b\x9b\x6e\x75\xde\x89\xde\x62\x8c\x74\x8d\xa2\x9a\x70\x28\x20\xc2\xa3\xca\x7c\xce\x39\xa0\xab\x4a\xf4\x0e\xd5\x98\xbd\xc2\x26\xa7\xf5\x48\x71\x28\x1e\x91\xf5\x55\x41\x1c\x69\x57\x17\xc3\x21\x98\x0e\x91\x70\x5e\xd9\xe3\x91\xa9\x22\x62\x6d\x72\xd5\xc6\x3e\x33\x6f\x3e\xbb\xe1\xed\x23\x88\x27\x74\x2c\x0f\x5e\xc2\xfe\xb6\xa6\xfb\xe6\x0f\x59\x58\xe9\x3a\xd7\xed\x9e\xe7\x43\x2f\x65\xd4\x66\x78\x63\xcf\xec\xc9\x2f\xd1\x85\xf5\x39\x73\x4f\xee\x58\x97\xbe\x1c\x1c\x7d\x5a\x77\xd0\x18\x32\xd8\x53\x70\xee\xfa\x12\x6d\x51\x4f\xdd\xee\x2f\x03\xb6\xc0\xd6\xf6\xfa\x67\x71\xb3\x85\x29\x42\xfb\x96\x9f\x0d\x9a\x7e\x76\xc4\xf6\xb3\xe3\xd5\xc0\xe8\x34\xed\x55\xe5\xcb\x74\x02\x5f\xbb\xec\x3b\x79\x5d\x4e\x9f\xf5\x93\x7a\x0f\xc1\xfd\x1a\x36\x8c\xd0\xa7\xd5\xb1\x7d\x16\x74\x9a\xe3\xe7\xa7\xc1\x09\x36\xfe\xd1\x59\x30\xe8\xe7\x3e\xa7\xcc\x7b\x63\xd2\xc5\xb8\x6b\x22\x75\x64\x0b\xaa\xf0\x9e\xbb\x3e\xdf\x9c\x00\x50\xba\x23\x81\xf5\x8d\x3d\x0d\x54\x2f\xbc\x5a\x47\xe6\x4f\xc9\xe0\xad\xfd\xa6\x02\x2a\xb3\x6d\x32\x72\xe3\x17\x20\x70\xe9\xde\x30\x45\x6f\x71\x49\xa5\x12\xdb\x10\xcc\xcb\x2c\x7b\xc0\xa0\x0b\xfd\x0b\x2e\xe7\x20\x34\xcd\xab\x9b\xe0\x13\x5b\x94\xf0\x07\x23\xe5\x4f\x73\x60\x34\x35\xf8\xd6\x51\x80\x42\x98\x73\x1a\x68\x10\x41\xa0\x84\xf7\x1f\xcc\xfe\xc6\x09\xad\x24\x59\xb5\xe3\xce\xdd\x8e\x17\x86\x5a\x8e\x54\xfa\xe3\x27\x9e\x6c\xcd\xfc\xb0\x3e\xe1\x38\x32\xfa\x24\xb2\x24\xfb\x31\x4d\xf9\xe6\x26\xcb\xd5\xf6\x57\x92\x16\xa8\x57\xd0\x85\x09\x4c\xf3\xfb\xe6\x29\x17\x28\xa5\x3d\x0a\xd5\xda\x43\x75\x92\x6f\x6e\x1a\x6e\xe5\xbf\x0a\x14\xdb\x8a\x79\x01\xc0\x6c\x06\x8f\x7a\xc8\x3a\xd7\x88\xac\x62\xdc\x5b\x55\xab\x63\xef\x28\x1e\x45\xaf\x4f\xa1\xc5\x64\xeb\x94\x23\x3a\x1a\x84\x87\xc4\xcd\x0d\x77\x7a\x96\x6b\x47\x34\x81\x32\xb4\xfc\x72\x3e\xb0\xbb\x87\xcb\x63\xdf\x95\x81\x5b\xa9\x4d\xff\x99\x8b\x8c\x28\x85\xc2\xc5\xa9\xff\x7b\x3a\xb0\x71\x78\x54\xb5\x1a\xd7\x2b\x73\x11\xe5\x0b\x8d\xde\x29\x41\xd9\x72\x1a\xba\x43\x5e\xfd\x51\x27\x8f\x0e\x17\x6a\xa4\x7b\x4c\x71\x48\x4f\x26\x35\x19\xea\xd9\x7e\xb0\x34\x9c\x98\x76\x5f\xc0\x3a\x29\x17\x03\xd2\x47\xc5\xcb\x41\xdd\xcb\xee\xad\x91\x06\xce\x5d\x2e\x11\xb5\x6a\x33\x35\x27\x6a\xd5\x4b\xd4\x8e\x41\xf5\xca\x61\x7b\xc6\xf8\xb7\x8f\xfe\xe7\x8d\x43\x7a\x98\xe5\xb9\x7e\xbf\xb6\x74\x9c\x1d\x9e\x24\xf9\x74\xca\x8c\xf5\x8d\x87\xf8\x6b\x24\x09\x8a\x36\xe6\x2b\x33\x36\x06\x75\x6f\xf5\x37\xdc\x4f\xc2\x5d\x4b\xf5\x50\xaf\xf7\xf4\xbb\x84\xbe\x74\x3c\x3e\xc9\x36\x57\x46\xc6\xa9\x0b\x2e\x32\xfb\xff\x96\x3e\xbf\xee\x79\xb6\xd6\xe3\xa0\x5f\xfb\xfc\xd2\x83\x45\x07\x0d\x3f\x47\x74\x4d\xeb\xf9\xf7\x87\xf3\x72\xd0\x98\x71\x4a\xe1\x5a\x7c\xd9\xc2\x35\x24\x6e\x64\xe1\x1a\x5a\x3e\xa6\x70\x2d\x3e\xa7\x70\x0d\x6c\x1c\x1e\x55\xed\x59\x0a\x57\x8f\x29\x23\x0b\x57\x1d\x37\xc3\xbc\xec\x17\xfe\x0c\x75\x6b\xe0\xfb\x29\x2d\x5d\xe9\x5f\xec\x7a\xe9\xc1\x76\x8e\x65\x47\x27\xaf\x83\x6c\x3c\x73\xb5\xa2\x69\x73\xd8\xd0\x8d\xa7\x19\xf1\xdc\xef\x06\xfa\x5c\xa8\x23\xc4\xbe\x47\xeb\xf7\xc8\xfb\x0f\xd2\xf8\x58\xd3\x8f\x0b\xf8\xcf\x05\xac\x8d\x2b\x4c\xef\x7b\xca\x59\xca\x3b\x33\x79\xc0\x84\x47\x93\xb1\xf3\xd4\x21\x1d\xe7\x40\xf2\x1c\x59\x32\x3d\x30\xc9\x66\xab\x2e\x30\x6d\x0c\xf7\x2a\x92\x75\xea\xba\x35\xe7\x48\x1c\xb4\x0e\x7e\x3d\x62\x9b\x29\x61\xa7\x2c\x68\x5f\x0c\xdb\x58\x47\xf9\x01\xb4\x6b\x80\x5b\xe8\x9f\x84\x76\x7f\xe6\xfd\x9d\x29\xf6\x1b\xa7\x0c\x93\xa1\x64\xa8\x4f\xa9\xd1\x3f\x38\x65\x3f\x6d\x2d\xf0\x87\x69\x31\xd9\xed\xa2\x2b\x9e\xa6\x18\x2b\xca\x99\x5d\x51\x96\x93\x70\xf0\x00\x55\x9f\x9e\x88\x09\xd1\x11\x4d\xd2\x98\x5e\x7b\xc8\x26\xcd\xae\x28\x3a\xb5\xbf\x70\xe9\xc7\xef\x31\xaa\xd2\x39\x5a\xeb\x11\x89\xf6\x59\x94\xf6\x8f\x00\x55\xff\x3f\xac\xb4\xbd\x91\x6a\xd6\x24\x1c\xa5\xc9\x95\xb2\xc8\xcd\x9f\x70\xd7\x44\x50\x92\x08\x1a\x03\x11\xcb\x22\x43\xa6\xe4\x05\x48\xca\x62\x84\x0d\x42\x21\x31\x01\x9f\x2c\x56\xe4\x06\x21\x26\xcc\xbd\x5f\x5d\x21\x2c\xa8\x90\x0a\xa8\xc2\x0c\xa8\xfd\xf3\xaf\xd5\x88\x48\xa0\xea\xaf\xcd\xeb\x59\x3d\x43\x02\x5f\xd8\x77\xb5\x02\xd7\x94\x17\xd2\x8a\xb4\x0b\x2c\x62\xa0\xf8\x12\xd5\x0a\x85\x45\x3d\x45\x36\x3d\x00\x65\x08\x7f\x83\xef\xab\x46\xea\xf4\x53\xcf\x01\xc9\xef\xbf\xff\x30\xba\x5b\xeb\x7f\xc3\x1f\xec\xbf\x90\xb4\x21\x53\xd7\x29\xaf\x84\xe9\xd2\xf4\x2e\x5e\x61\x46\xfc\x37\xaa\xde\x98\xcd\x13\x30\x35\x4c\xa8\x47\xdd\x25\x8a\xc9\xa5\x61\xf7\xa1\xb9\x58\xe9\x7f\xd4\x29\xbe\x7b\x97\x79\x3a\xe9\x8c\xe8\xfa\x5a\x7d\x74\x07\xfe\xda\xca\xe9\x17\xe9\x85\x7f\x8f\x00\x95\xd0\xea\x50\xcc\xb7\xd6\xe1\xc2\x11\x58\xa0\xf4\x89\xda\xd8\xc8\x85\x8c\xae\x78\x96\x73\x49\x15\xfe\x6a\xff\x69\x4e\x39\xbb\xd1\x4f\xf4\x2a\x9d\x29\x1c\xbf\xdc\x22\x46\xd3\xa0\x0c\xfe\x17\x00\x00\xff\xff\xc9\x09\xb6\xd2\x4f\x30\x00\x00")
 
 func templatesClientParameterGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -171,7 +171,7 @@ func templatesClientParameterGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/client/parameter.gotmpl", size: 12205, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
+	info := bindataFileInfo{name: "templates/client/parameter.gotmpl", size: 12367, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -196,7 +196,7 @@ func templatesClientResponseGotmpl() (*asset, error) {
 	return a, nil
 }
 
-var _templatesDocstringGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x6c\x8d\x31\x0a\xc3\x30\x0c\x45\x77\x9f\xe2\x93\xbd\xf1\x25\x3a\x77\xea\x05\x82\xad\xb4\x82\x58\x2e\xb1\xba\x54\xe8\xee\x25\x0d\x94\x24\x64\xfb\x88\xf7\x9e\xcc\x32\x8d\x2c\x84\x2e\xd7\xd4\x74\x66\x79\x74\xee\x01\x30\xbb\x80\x47\xf4\x77\xd6\x89\xe0\x6e\x86\x54\x4b\x21\xd1\xed\x6d\x65\xae\xd4\xd2\xcc\x2f\xe5\x2a\x70\x0f\x31\x86\x18\xb1\x15\x0e\xc0\xe2\x91\xe4\xff\x9c\x1a\x1d\x3b\xfb\x87\x67\xfe\x22\xfd\xa8\xe7\xbb\x0c\xc2\x1f\x42\x7f\x1b\x0a\x9d\xf5\xd7\xf9\x0d\x00\x00\xff\xff\xae\xbb\x3b\x77\xeb\x00\x00\x00")
+var _templatesDocstringGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x6c\x8e\x41\x0e\x82\x40\x0c\x45\xf7\x73\x8a\x1f\xf6\x32\x97\x70\xed\xca\x0b\x10\xf8\x68\x13\xa6\x63\x98\x71\x63\xd3\xbb\x1b\x43\x44\x82\xec\x9a\xf6\xbf\xff\x6a\x36\x70\x14\x25\x9a\x21\xf7\xa5\xce\xa2\xb7\xc6\x3d\x00\x66\x27\xc8\x88\xf6\x2a\x75\x22\xdc\x11\x80\x65\xdb\xe7\x94\xa8\xf5\xe8\xf4\x01\xce\x2c\xfd\x2c\x8f\x2a\x59\xe1\x1e\x62\x0c\x31\xc2\xec\x87\xed\x02\x5f\x96\x3a\x60\x35\x73\x2a\xdc\xb7\x1d\xfe\xf0\x57\xb6\xd2\xee\x66\xb8\x3f\x53\xa7\xf2\x22\xda\x4b\x97\xb8\x49\x2c\xb2\xcd\xf8\x0e\x00\x00\xff\xff\x79\x3c\xdd\x12\x09\x01\x00\x00")
 
 func templatesDocstringGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -211,7 +211,7 @@ func templatesDocstringGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/docstring.gotmpl", size: 235, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
+	info := bindataFileInfo{name: "templates/docstring.gotmpl", size: 265, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -276,7 +276,7 @@ func templatesModelvalidatorGotmpl() (*asset, error) {
 	return a, nil
 }
 
-var _templatesSchemaGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5a\x5f\x8f\xdb\xb8\x11\x7f\xd7\xa7\x98\x1a\x7b\x0b\x29\xf0\xca\x45\xd0\xa7\x14\xfb\xb0\x49\x7a\x3d\x17\x48\x72\xd8\x4d\x53\xa0\x69\xd0\xa3\xa5\xd1\x9a\x39\x89\x54\x48\xca\x7b\xae\xa0\xef\x5e\x90\xd4\x1f\x4a\x96\x64\x7b\x37\x57\xe4\x8a\x7b\x93\xa5\xe1\x70\xfe\x71\xe6\x37\x43\x97\x25\xd0\x04\xc2\x35\x8b\xd2\x22\xc6\x37\x3c\xc6\x14\xae\xaa\xca\x03\xb0\x5f\x08\x8b\x21\x5c\xcb\x97\x44\xe2\xfb\x7d\x8e\xfa\xf9\x2f\xbf\xe4\x5c\x28\x8c\x35\x9d\xd2\xef\xca\x12\x72\x22\x23\x92\xd2\xff\x20\x84\x6f\x49\x86\x50\x55\x40\x99\x42\x91\x90\x08\xa1\xf4\x00\x34\x3f\x9a\x00\x17\x10\xde\xe2\x97\x82\x0a\x8c\x21\xfc\x81\xc8\x0f\x24\xa5\x31\x51\x94\x33\x09\x55\x25\x0a\xa6\x68\x86\x61\xfd\x96\x6c\x52\x2c\x4b\x40\x16\x83\x11\xc9\x08\x25\x08\xbb\x47\x08\x6f\xd2\xf4\x5d\xd2\xbc\x6e\xa4\x0d\xd7\xf2\x86\x71\xb6\xcf\x78\x21\xbb\x6f\xee\xb2\x1f\x05\xcf\x51\x28\x8a\xbd\xef\xcd\xfa\x8b\x70\x2d\xdf\x17\x79\xaa\x15\x28\x4b\x50\x98\xe5\x29\x51\x08\x0b\xa5\x5f\x26\x14\xd3\x78\xad\x55\x5a\x40\x68\x29\x30\x95\x96\xb6\x23\x95\x4a\x14\x91\x1a\xa3\xed\xd4\xa8\x77\x3c\x78\x73\x65\x94\xf8\x81\xc8\x9b\x38\xa6\xda\x28\x24\x9d\x16\xd8\x12\x8f\x52\x5e\xf5\x48\x01\x56\x2b\x43\xdf\x09\x19\xf3\x48\x2a\x41\xd9\xfd\x62\x82\xc3\x80\x41\x7f\x75\x6e\xe9\xf6\x9d\xf3\x5e\xf3\xe8\x6e\x8e\x5f\x55\x0d\xa2\x64\x8c\xa8\x09\x1d\x3f\x80\x8c\xe4\x1f\xad\x80\x9f\x7a\x7e\x90\xd1\x16\x33\xa2\x23\xf1\x24\xc1\xcb\x12\x59\x7c\x60\xf3\xfe\x8b\xbe\x11\xd7\x0a\xb3\xa1\xfd\x4e\xb4\x9e\x5d\x7a\xe0\xa4\xf3\xcd\x66\x18\xcd\x58\xcc\x7c\x77\x8c\xf5\xf1\x24\x1b\x1d\x88\x37\x0c\xc0\x2e\x9c\x5d\x92\xf0\xaf\xdc\x1c\xfc\x1e\x59\xef\x40\xb6\xbf\xca\xf2\xe0\x90\x75\x54\x83\xd3\xd5\x31\x3b\x72\xc8\xbc\x51\xd1\x8e\x1f\xb8\x11\xe9\x1a\xd7\xd7\x4e\x3f\x72\xcc\x4e\x3c\x60\x4f\x38\x5a\xbf\xb9\x43\xd5\x37\x67\xef\x79\xee\x14\x3d\xe6\xfc\x7c\xa3\x27\xa7\xd3\xba\xf2\x3c\x80\xa6\xfc\x45\x24\xc3\x7e\xf5\x1b\xe1\xfb\x92\xc7\xfb\x3a\x36\xbd\xf9\x92\x94\x14\x2c\x02\xbf\x2c\xe1\x22\xbc\xc5\x08\xe9\x0e\x85\xe6\x5b\x55\xf0\xcc\xdd\xec\x22\xb4\x6f\x83\x91\x0a\x6c\xd4\x9b\x56\x4e\x57\xa4\x5e\xe5\xc4\x2f\x70\x11\xbe\xa6\x32\x12\x34\xa3\x8c\x28\x2e\xbe\xd7\x07\xaa\x55\x48\xa0\x2a\x04\x33\x1b\x09\xca\x54\x02\x8b\xef\xbe\x2c\x86\x4b\x3e\x90\xb4\xc0\x5e\x61\xec\x96\xf5\x55\x81\xaa\x0a\xcb\xb2\x6f\xb6\xaa\x32\x5b\xba\x39\xfb\x91\xe6\xb8\x43\x35\x6a\x91\x1d\x49\xe7\x6d\x12\x40\xdf\x2a\x0c\xe7\xad\x72\x8e\x5e\x70\x0d\x3b\x92\x0e\xb5\xeb\x1f\xa3\x1a\x70\xf9\x8c\x2b\x8d\x65\xd6\x0d\x84\x0a\xc0\x9f\x43\x4e\x81\x73\x40\x87\xca\xed\x2c\x19\x17\x6d\x5a\xec\xb6\xf4\x56\x2b\xf8\x3b\xcb\x88\x90\x5b\x2d\xd9\x08\x8a\xbb\x4b\x69\x84\x50\x34\x34\x12\x72\x9e\xee\x33\x2e\xf2\x2d\x8d\x40\xea\x8f\x12\x78\x32\x8e\x00\x3d\xe3\xb7\x13\xf8\xfb\x02\x49\x8c\x02\x28\x0f\x6f\xcd\xd3\x12\x22\xce\x64\x91\xa1\x80\x06\x11\xbe\xaa\x5f\x04\xe0\x9b\x43\x7b\xc8\x6a\x09\x28\x04\x17\xd6\x85\x3b\x22\x00\x53\xcc\x90\x29\x09\x1f\x3f\x7d\x96\x9c\x85\xb7\xe4\xe1\x0d\x4a\x49\xee\xd1\x03\x13\xf2\x42\xc0\x8b\xeb\x76\xab\x66\x8b\x5a\x9a\x25\x5c\x36\x0c\x82\x3f\x1b\xda\x3f\x5c\x03\xa3\x69\x1d\x21\x75\x60\x33\x9a\x9a\x7d\x3d\xed\xcd\x7a\x5f\x81\xb2\x48\x15\x4c\x88\xe9\x01\x24\x5c\xc0\xbf\x97\x8d\x7c\x5a\x06\x9b\x09\x5a\x81\xed\x16\x7c\xf3\x79\xd9\x08\x59\xcc\x5a\xd1\xaf\x57\x76\x76\x0b\x0c\x87\x5a\xc9\x9e\xe0\x63\xa2\x37\x07\xad\x96\xfc\x1a\x48\x9e\x23\x8b\x7d\xfb\x7b\xa9\x25\x09\x3c\x4b\x54\x2f\x86\xe6\x13\xa3\xa9\x4e\x85\xc7\x23\x69\x2a\x88\x1e\x1d\x3a\x67\x46\xcd\xf1\x98\x59\xad\xe0\x01\x81\x21\xc6\xa0\x38\x68\xee\xa0\xb6\x54\x82\x7a\xa0\x11\x2e\x41\x72\x48\xa8\x90\x4a\x37\x36\x1c\x08\x6c\x8a\x24\x41\x6d\x3d\xdd\xa8\xb4\x8e\xa2\xbc\x50\x34\x35\x12\xdd\xa4\x69\x2d\x63\xe0\x8d\xfb\x62\x2c\x88\x3a\x13\x1f\xf1\xb9\xdd\xb6\x73\x78\xe5\x59\xab\x9d\xb0\x0c\x3e\x7e\xda\xec\x15\x3e\xd5\x60\x9b\x22\xd1\x2a\x6b\x56\x32\x7c\x8b\x0f\x2f\x8d\x45\xcc\x0e\x41\x87\x0a\x9c\xf4\x69\x2a\x9c\x5e\xf6\x7c\x72\x9d\x9b\x9d\x8c\x4b\xd4\x16\x6b\xbb\x6b\x01\xad\x47\xa8\xb4\xee\xd1\xce\xe1\x90\xa0\x8a\xb6\x86\x6e\x67\xea\x0f\x4f\xcc\x0f\x8d\x5d\x47\x52\x77\x55\x41\x83\x26\xc2\xfa\xc0\xde\xa3\x32\x10\xd7\x02\x49\x28\x07\x31\x39\xce\xc4\x02\x18\xf8\x49\xa7\x96\x17\x83\xb2\x38\xbe\xe4\x27\xe3\xdd\x99\xc4\xb3\x29\x92\x25\x5c\xd6\xd2\x9c\x91\x74\x3a\x96\x75\xb2\xc7\xb6\x52\x58\x8c\xe4\x9f\x24\xdf\x12\x16\x1b\x0d\x51\x96\x8d\x41\xc2\x13\xec\x70\x86\x98\xab\x15\xbc\x77\x9d\x34\xed\x20\x2a\xa1\x90\xf6\x18\xc6\xa8\x50\x64\x94\x21\x3c\x6c\xa9\x76\xb3\x76\x94\xe2\x10\x09\xd4\x45\x4e\x57\xcb\x36\xe0\x8d\xdb\x4d\x7c\xeb\x23\xea\x01\xc8\x07\xaa\x43\xe3\x0c\x75\xac\xf3\x6d\x3a\xbe\xf8\x79\x09\x17\x3b\x6d\xd6\x83\x18\x36\x6a\x46\x44\xe2\x01\x20\xfa\x19\xaa\xea\x45\x9d\x68\x9d\x62\xd0\x82\x2c\xbf\xc8\x73\x14\xe0\x77\x82\x58\xd8\x12\x04\xcd\xa7\x8b\x5d\x60\x91\xc5\x00\xd8\x0c\x06\x0e\x5a\xb4\xc3\xb1\xc2\x7c\x74\x3d\x5f\xc2\xa5\x15\x68\xcc\x6d\x53\xb5\xa1\xa9\x0e\xed\xd7\x4b\x37\xf9\x0f\xfb\x02\x27\x83\x35\x5c\xb8\x30\xc7\xdc\xff\xd3\xf3\xe7\x4b\x58\x50\x66\xa2\x74\xc6\xfd\x26\x42\x5e\xc0\x77\x5f\xce\x0c\x45\xcf\xab\xbc\xc6\x44\xee\x0c\x4b\x43\xa7\xb5\x7c\xc5\xb3\x3c\xc5\x5f\xde\x6d\x3e\x63\x64\xd0\x95\x6d\x45\xc3\xf5\x78\x17\x78\xd5\x6b\x5d\x1b\x0f\x34\x80\x5f\x63\x43\x8b\xd1\xda\x69\x98\x71\xc6\xa8\xa7\x0e\xd3\x68\x6b\xb0\xf6\xe1\x48\xc3\x00\x47\x87\x58\xed\x00\xac\x1d\xd5\x39\x7d\xfc\x3c\x82\x1e\xc6\xe2\x53\x3b\x8a\x6f\xbd\xab\x70\x43\xfa\x31\xb6\xf9\x0a\xed\xc5\xff\xaa\xc5\x70\x55\x9d\x1e\xdc\xd4\xad\x47\xf8\x1a\x13\x52\xa4\xaa\x5d\xdb\x98\x66\xde\x30\x8d\xa4\x41\x07\xd8\xfe\x76\xf7\xee\xad\xbf\xa9\x61\x46\x60\x73\x80\xa3\xfb\xf4\xd4\xf8\x26\xa5\x44\x4e\x60\xc2\x66\xb5\x4e\xab\x6a\x66\x79\x4b\xd8\x25\x43\x83\xff\x5b\xe9\x7c\x2b\x97\x5f\x96\x6e\xd4\xf9\x9a\xa8\xb5\x41\x50\x55\xc1\x12\x2e\x27\x13\x65\x9b\xe4\xba\x2c\xe9\x06\xd5\xe4\xd6\x9b\x27\x30\x7d\x76\xe8\x89\xeb\x71\x3b\xf8\x2a\x18\x49\xe9\xbd\x6c\xde\x1b\x87\x39\x29\x73\xce\x3b\x83\x71\xdd\x3e\xc7\xbb\x41\x84\x77\xed\xa5\x9b\x80\xfd\xfa\x16\xe1\x47\x1d\xe3\x8a\xee\x6c\xd6\xd5\xbe\x42\xf3\xfe\x55\x21\x15\xcf\xbe\xe7\x22\x23\x4a\xe9\xea\xa8\x73\xab\x6f\x11\xd6\x2b\xce\x14\xa1\x4c\x42\xf8\x4f\x14\x1c\x16\xfe\xbf\x16\x8b\x20\x08\xc0\x1d\xc0\xf5\xe2\x0e\x24\x2a\x09\x64\x42\x03\x8b\x3e\x12\xc1\x33\x30\xc4\x94\xe5\x85\xfa\x95\xc3\xbd\xf6\x80\xef\x6b\x46\x61\xad\x77\x9d\xa2\x03\x9d\x79\x06\x1b\x06\x41\x38\x60\x1d\xb4\xae\xeb\x94\x7e\xe3\xa8\x2c\x50\x09\x8a\x3b\x3c\xa6\x37\x91\x56\x6b\x5e\xa8\xe3\x6a\x4f\x68\xed\xec\xeb\x9b\x6e\xdc\xb6\x12\x4e\x5f\xd0\xd7\xfa\x50\xe7\x71\x95\x7b\x7c\x9d\x50\x1d\x89\xa7\x70\x2d\xef\x8a\x8d\x5b\xe4\xe6\xee\x85\x66\x6f\x7e\xc6\xca\x66\x63\x90\xdf\x8b\xe5\x41\x0a\x3a\xdb\x34\xff\x77\xb5\xb2\x7b\x3e\xe5\x1a\xe1\xa4\x4b\x84\x47\x5f\x21\xfc\x96\x2e\x10\x6a\x4b\x1f\x98\x6f\xfc\xd2\xc0\x98\xe4\x9c\x1b\x83\x6f\xf2\xbe\x60\x08\xf3\xaf\xaa\x0a\xbc\xd1\x29\xed\x1d\x0a\x6a\x76\x17\x83\xeb\x62\xf0\x9a\x10\xaa\xaf\xe8\x3f\x34\xf3\xdc\x8e\xdb\x15\xcc\xcc\x8d\xeb\x57\x4d\x7a\x3b\x32\x49\x36\xbf\x3b\xda\xab\xf3\xe6\xca\x57\x36\xe7\xd0\x04\xee\x15\xf8\x29\xb2\x3a\x1d\x07\xf0\xc7\xc7\xb3\x32\x58\xc0\xb6\x70\xad\x5e\xa6\x02\x28\x81\x24\xeb\xeb\xa6\x37\x59\xad\xa0\x56\x08\xdb\x79\x88\xb4\x73\xa3\xb2\x84\x6d\x91\x11\x76\x38\x6a\x1c\x2f\x7f\x6d\xef\xd8\xb6\x8a\x07\x4d\xe4\x44\xb4\x3f\x73\x5d\xff\xb5\x9a\xc5\xa0\x55\xcc\x4f\x0c\x56\x92\x20\x95\x48\x32\x15\xde\xe2\x3d\x95\x4a\xec\x5d\xec\xe1\xe0\xbe\xd6\xa4\x75\x1d\x6d\x9e\x87\x8f\xbd\x38\x3a\xd1\xe6\x41\x43\x78\xa6\x8d\x7e\x05\x4c\x68\x40\x61\x87\x8c\x5e\x52\x46\xc4\xde\xf9\x1f\x0a\xd5\x72\x65\xc8\x94\x89\xf5\x49\xc7\x4f\xc1\xbd\x1e\xdb\x09\xe8\x43\xed\x58\x6b\x50\x83\xe0\x7a\x6a\x3c\x66\x51\xb9\x33\x33\x91\x0f\xe4\x3e\xfc\x87\xa0\x0a\x0d\x10\x1a\x61\x66\x26\xbd\x2e\xe8\xfd\xda\x7a\x0e\x18\x8f\x02\xdb\x7a\xb4\x35\xd9\xa9\x75\xfd\x8f\x51\xe8\x16\x49\x6c\x91\xac\x9d\x40\xcd\x4c\x0d\xbb\x39\xf8\xb3\x51\x4b\xea\x6d\x87\xd1\xed\x40\x44\xef\xbf\x01\x00\x00\xff\xff\xa5\x25\x83\x2f\xd1\x24\x00\x00")
+var _templatesSchemaGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5a\x5f\x6f\xdb\xc8\x11\x7f\xd7\xa7\x98\x0a\x3e\x97\x34\x64\x0a\x08\xfa\xe4\xc2\x0f\x4e\xae\xd7\xaa\xc0\x25\x07\x3b\x77\x05\x9a\x06\xbd\x15\x39\xb4\x36\x21\x77\x95\xdd\xa5\x7c\x2a\xc1\xef\x5e\xec\x1f\x92\x4b\x8a\xa4\xa4\x38\x77\xc8\x15\xf5\x93\x4c\xce\xce\xce\xfc\x66\x76\xfe\x2d\xcb\x12\x68\x0a\xd1\x8a\xc5\x59\x91\xe0\xf7\x3c\xc1\x0c\xae\xab\x6a\x06\x60\xdf\x10\x96\x40\xb4\x92\x2f\x89\xc4\xb7\xfb\x2d\xea\xdf\x7f\xf9\x65\xcb\x85\xc2\x44\xd3\x29\xfd\xac\x2c\x61\x4b\x64\x4c\x32\xfa\x1f\x84\xe8\x35\xc9\x11\xaa\x0a\x28\x53\x28\x52\x12\x23\x94\x33\x00\xcd\xef\x5a\x33\x64\x5c\x41\xc0\x85\x66\xb4\x6a\x28\xa2\x95\x7c\x50\x02\x49\x1e\x42\x55\x95\xe5\xf2\x0a\xcc\x12\xfd\x77\x07\x6b\x22\x11\xcc\x46\x54\x02\xc9\x9e\xc8\x5e\xc2\x4f\x24\xa3\x09\x51\x64\x9d\x61\xd4\xd2\xfe\xc8\x12\x14\xc0\xb8\xc8\x49\x06\x31\x67\x09\x55\x94\x33\xb9\x80\x27\x84\x98\xb0\x3f\x2a\xd8\x90\x1d\x02\xf1\x58\x0a\xd4\x6b\x30\x01\xd2\x0a\x01\x3d\xf1\x6e\x40\x6d\xa8\x84\x78\x83\xf1\x47\x2d\xc3\x87\x42\x2a\x48\xb9\x00\x49\x18\x55\x7b\xfb\x22\x8c\x60\xd6\x08\xb2\x62\xa0\x36\x08\x09\xa6\x94\x19\x19\x80\xa7\xe6\x89\xa7\x8b\x92\x98\xa5\x0b\xcb\x3a\x47\xc2\x24\xa8\x0d\x51\x86\xaa\x60\x58\x63\x2c\x95\x28\x62\x05\x1b\x9e\x25\x94\x3d\x36\x1b\x1c\xe3\xbe\x21\x12\x48\x8d\x12\x06\x21\xa4\x05\x8b\x23\xb3\xfc\x6a\x69\xcc\x6b\xff\x44\xc1\x14\xcd\x31\xf2\xf0\x84\xc6\x5a\xc8\x12\x70\xb4\x65\x09\x82\xb0\x47\x84\xe8\x2e\xcb\xde\xa4\xd0\xb0\xa8\xfd\x47\xde\x31\xce\xf6\x39\x2f\x24\x78\xec\xdb\x65\x3f\x08\xbe\x45\xa1\x28\x76\xde\xd7\xeb\x2f\xa2\x95\x7c\x5b\x6c\x33\x34\xe6\x07\x85\xf9\x36\x23\x0a\x61\xae\xf4\xc3\x94\x62\x96\xac\xb4\x25\xe6\x10\x59\x0a\xcc\xa4\xa5\x6d\x49\x2d\x52\x43\xb4\xad\x1a\x6e\xc7\x83\x27\xc6\x33\xa3\xbf\x11\x79\x97\x58\x9f\x21\xd9\xb8\xc0\x96\x78\x90\xf2\xba\x43\x0a\xb0\x5c\x1a\xfa\x56\xc8\x84\xc7\x52\x09\xca\x1e\xe7\x23\x1c\x7a\x0c\xba\xab\xb7\x96\x6e\xef\xac\x45\x39\xfb\x96\xc7\x0f\x53\xfc\xaa\xaa\x77\x3a\x87\x88\xea\x23\x1b\x84\x90\x93\xed\x3b\x2b\xe0\xfb\x8e\x1d\x64\xbc\xc1\x9c\xe8\x08\x70\x92\xe0\x65\x89\x2c\x39\xc0\xbc\xfb\xa0\x0b\xe2\x4a\x61\xde\xc7\xef\x44\xf4\xec\xd2\x03\x23\x9d\x0f\x9b\x61\x34\x81\x98\x79\xef\x81\xf5\xee\x24\x8c\x0e\xc4\xeb\x3b\x60\xeb\xce\x3e\x49\xf4\x57\x6e\x02\x6e\x87\xac\x73\x20\x9b\xff\xca\xf2\xe0\x90\xb5\x54\xbd\xd3\xd5\x32\x3b\x72\xc8\x66\x83\xa2\x1d\x3f\x70\x03\xd2\xd5\xa6\x77\x46\x3f\x72\xcc\x4e\x3c\x60\xcf\x38\x5a\xbf\xbb\x43\xd5\x85\xb3\xf3\x7b\xea\x14\x7d\xce\xf9\xf9\x4a\x4f\x4e\xab\x75\xa5\xb3\x6c\x5d\x76\xc4\x24\xc7\x6e\xd5\x31\xc0\xf7\x25\x4f\xf6\xce\x37\x67\xd3\x29\xc9\x00\xd6\xaf\x65\xaa\x0a\x1e\x51\x49\x93\x60\xcb\x12\x36\x45\x4e\x58\x67\x4b\x93\x7c\xa9\x84\x2d\xcf\xf6\x39\x17\xdb\x0d\x8d\x8d\x80\x86\xa5\xce\xbb\x10\x94\x25\x5c\x44\xf7\x18\x23\xdd\xa1\x70\x4c\xaf\x7c\xf9\x2f\xdc\x56\xe1\xa0\x00\x41\x38\xa4\x97\xc3\x4b\x27\xb9\x4e\x32\xc6\x4f\x70\x11\x7d\x4b\x65\x2c\x68\x4e\x19\x51\x5c\x7c\xa7\xcf\x68\x23\xb0\x40\x55\x08\x66\x36\x12\x94\xa9\x14\xe6\xdf\x7c\x9a\xf7\x97\xfc\x44\xb2\x02\x3b\xb9\xb6\x5d\xd6\x55\x05\xaa\x2a\x2a\xcb\xae\x25\xaa\xca\x6c\xe9\xa7\x81\x06\xe1\x07\x54\x83\x20\xcb\xdf\x10\xe4\x11\x19\x82\x1d\xc9\xa6\x91\x0e\xa1\x8b\x35\xc3\x69\xac\xcf\x41\x0b\x6e\x61\x47\xb2\x3e\x66\xad\xe7\x2f\x97\xf0\x23\xcb\x89\x90\x1b\x4d\x35\x50\x72\x3f\x64\x34\xd6\xc5\xa3\xa3\xe9\x82\x25\xf5\x4b\xa9\x71\x1c\x5c\x3b\x33\x18\x9e\xc0\x3f\x10\x48\x74\x95\x4d\x79\x74\x6f\x7e\x2d\x74\xa5\x2d\x8b\x1c\x45\x53\x4d\xbe\x72\x0f\x42\x08\xcc\x49\x3f\x64\xb5\x00\x14\x82\x0b\x0b\xe7\x8e\x08\xc0\x0c\x73\x64\x4a\xc2\xbb\xf7\x1f\x24\x67\xd1\x3d\x79\xfa\x1e\xa5\x24\x8f\xda\xc2\xda\xa9\x85\x80\x9b\xdb\x66\xab\x7a\x0b\x27\xcd\x02\x2e\x6b\x06\xe1\x9f\x0d\xed\x1f\x6e\x81\xd1\xcc\x59\xcb\xb9\x2e\xa3\x99\xd9\x77\xa6\x91\x75\xfb\x0a\x94\x45\xa6\x60\x44\xcc\x19\x98\x3a\xff\xdf\x8b\x5a\x3e\x2d\x83\x0d\x1f\x8d\xc0\x76\x0b\xbe\xfe\xb0\xa8\x85\x2c\x26\x51\x0c\xdc\xca\x16\xb7\xd0\x70\x70\x4a\x76\x04\x1f\x12\xbd\x3e\x4a\x4e\xf2\x5b\x20\xdb\x2d\xb2\x24\xb0\xff\x2f\xb4\x24\xe1\xcc\x12\xb9\xc5\x50\xbf\x62\x34\xd3\xf1\xf3\xb8\x27\x8d\x39\xd1\x67\xbb\xce\x99\x5e\x73\xdc\x67\x96\x4b\xdd\xd4\x31\xc4\x04\x14\x07\xcd\xdd\xc6\x07\xf5\x44\x63\x5c\x80\xe4\x90\x52\x21\x95\xee\x42\xb9\x6e\xf8\x8a\x34\x45\x8d\x9e\x6e\x72\x1a\x43\x51\x5e\x28\x9a\x19\x89\xee\xb2\xcc\xc9\x18\xce\x86\x6d\x31\xe4\x44\x2d\xc4\x47\x6c\x6e\xb7\x6d\x0d\x5e\xcd\x2c\x6a\x27\x2c\x83\x77\xef\xd7\x7b\x85\xcf\x05\x6c\x5d\xa4\x5a\x65\xcd\x4a\x46\xaf\xf1\xe9\xa5\x41\xc4\xec\x10\xb6\xa5\x84\x17\xca\x4c\x5a\xd4\xcb\x5e\x8c\xae\xf3\x82\x93\x35\x89\x0e\xdf\x16\x77\x2d\xa0\xb5\x08\x95\xd6\x3c\xda\x38\x1c\x52\x54\xf1\xc6\xd0\xed\x4c\x86\x71\x9d\xab\x2e\x78\x07\xc2\x68\x55\x41\x5d\x82\x44\xee\xc0\x3e\xa2\x32\x75\xb1\x6b\x8c\xcb\x9e\x4f\x0e\x33\xb1\x55\x0f\xfc\xac\x43\xcb\x4d\x2f\xf1\x0d\x2f\xf9\xd9\x58\x77\x22\xf0\xac\x8b\x74\x01\x97\x4e\x9a\x33\x82\x4e\xcb\x72\xe7\xba\xf3\xe8\x1e\x3f\x15\x54\x60\x62\x0b\xab\xe0\x24\xf9\x16\x30\x5f\xeb\xba\x66\x51\x03\x12\x9d\x80\xc3\x19\x62\x2e\x97\xf0\xd6\x37\xd2\xb8\x81\xa8\x84\x42\xda\x63\x98\xa0\x42\x91\x53\x86\xf0\xb4\xa1\xda\xcc\xda\x50\x8a\x43\x2c\x50\x67\x53\xc2\x92\xd6\xe1\xed\x08\x43\xfb\xb7\x3e\xa2\x33\x00\xf9\x44\xb5\x6b\x9c\xa1\x8e\x35\xbe\x0d\xc7\x17\x1f\x17\x70\xb1\xd3\xb0\x1e\xf8\xb0\x51\x33\x26\x12\x0f\x4a\x9e\x8f\x50\x55\x37\x2e\xd0\x7a\xc9\xa0\x29\xa3\x82\x62\xbb\x45\x01\x41\x2b\x88\x2d\x21\xc2\xb0\x7e\x75\xb1\xb3\x13\xab\x7e\x91\xd1\x9b\x52\x68\xd1\x0e\x67\x11\xd3\xde\xf5\x62\x01\x97\x56\xa0\x21\xb3\x8d\xe5\x86\x3a\x3b\x34\x6f\x2f\xfd\xe0\xdf\x6f\x26\xbc\x08\x56\x73\xe1\xc2\x1c\xf3\xe0\x4f\x2f\x5e\x2c\x60\x4e\x99\xf1\xd2\x09\xf3\x1b\x0f\xb9\x81\x6f\x3e\x9d\xe9\x8a\xb3\x59\x35\xab\x21\xf2\x07\x8e\x76\xf6\xf6\x8a\xe7\xdb\x0c\x7f\x79\xb3\xfe\x80\xb1\x82\xa6\x7f\x8d\x56\xc3\xad\xe3\x75\xa7\xdf\xad\x2d\x50\x77\x09\x6e\xea\xe8\x8f\x2e\x8d\x31\x06\x2d\x75\x18\x46\x1b\xc0\x9a\x1f\x47\xba\x0c\x38\x3a\xf9\x6a\xa6\x66\xcd\x5c\xd5\x6b\xfe\x9f\xd7\x85\x34\x33\xc0\x86\xdf\x74\x75\xdc\xf7\xed\xe7\xf6\x20\x5f\x7b\x1f\xe2\x1f\x91\x2f\xd0\x8f\x7c\x09\xb8\xbf\x40\x37\xf2\x5b\x75\x24\x3e\x7a\xe3\x03\x29\xfd\x9f\xa9\x26\x30\x25\x45\xa6\x9a\xb5\x35\x34\xd3\xc0\xd4\x92\x86\x6d\x4d\xf9\xf7\x87\x37\xaf\x83\xb5\xab\x84\x42\x1b\xa6\x3c\xdd\xc7\x6f\x21\xee\x32\x4a\xe4\x48\xd9\x5a\xaf\xd6\x91\x5f\x4d\x2c\x6f\x08\xdb\x78\x6d\x5a\x94\x46\xba\xc0\xca\x15\x94\xa5\xef\xc8\x81\x26\x6a\x30\x08\xab\x2a\x5c\xc0\xe5\x68\x2c\x6f\xe2\x70\x1b\xc8\x7d\x3f\x1d\xdd\x7a\xfd\x0c\xa6\x57\x87\x96\xb8\x1d\xc6\x21\x50\xe1\x40\xd6\xe9\x24\x9c\xce\x98\xcf\x8b\xea\x53\xd6\xe9\x8d\x21\xf7\x5b\x7c\xe8\x79\x78\xdb\x00\xfb\x39\x22\x70\xb7\x52\x3f\x68\x1f\x57\x74\x67\x13\x83\xb6\x15\x9a\xe7\xaf\x0a\xa9\x78\xfe\x1d\x17\x39\x51\x4a\x27\x70\x73\xe9\x64\x8b\xc0\x57\x9c\x29\x42\x99\x84\xe8\x9f\x28\x38\xcc\x83\x7f\xcd\xe7\x61\x18\x82\x3f\x58\xec\xf8\x9d\x0d\x04\x64\x44\x03\x5b\x20\xa5\x82\xe7\x60\x88\x29\xdb\x16\xea\x57\x76\x77\x67\x81\x20\xd0\x8c\x22\xa7\xb7\xcb\x22\xa1\x8e\x3c\xbd\x0d\xc3\x30\xea\xb1\x0e\x1b\xd3\xb5\x4a\x7f\xef\xa9\x2c\x50\x09\x8a\x3b\x3c\xa6\x37\x91\x56\x6b\x5e\xa8\xe3\x6a\x8f\x68\xed\xed\x1b\x98\x81\x81\xed\x76\xbc\xd6\xa5\xab\xf5\xa1\xce\xc3\x2a\x77\xf8\x7a\xae\x3a\xe0\x4f\xd1\x4a\x3e\x14\x6b\x3f\x0f\x4f\xdd\x77\x4d\xde\x68\x3d\x2f\x79\xcb\x62\xdd\xc9\x25\x43\x75\x42\x0d\xef\xff\xb3\xf9\x41\x40\x7b\x76\x36\xef\xe3\x7f\x36\xd6\xff\x73\xa9\xbc\xfd\x7d\xca\xed\xcd\x49\x77\x37\x9f\x7d\x73\xf3\x7b\xba\xb7\x71\x48\x1f\xc0\x37\x7c\x57\x63\xa3\xc6\x19\x17\x35\x5f\xe5\x35\x4d\xbf\x51\xba\xae\x2a\x98\xc1\x90\xdf\x3f\xa0\xa0\x66\x77\xd1\xbb\xa5\x87\x59\xed\x42\xee\x8b\x14\xa7\x12\x17\x4d\xc0\xbe\xae\x3f\x4b\x09\x8e\x7c\x4a\x12\xda\x97\xf5\x74\xc5\xb8\x6e\x8b\x90\x34\xff\xd7\x71\x35\xf4\x7c\xbf\x2f\xec\xae\x16\xc1\x2b\x49\xae\x6d\xfc\x3a\xe1\x7b\x96\x6b\x3b\xb9\xaf\x3f\xc5\x68\xa6\x3e\xd2\x46\x9c\xa1\x70\x64\x3e\x80\xb1\xf1\xc8\x08\x00\x54\x37\xc3\x76\xda\xac\x43\xd8\xd0\x47\x1b\xed\xd7\x36\xeb\x42\x99\xcf\x3f\x18\xaf\xf7\x32\xda\x2a\xee\x3e\x60\x31\xdf\x7f\x4c\xe4\xe8\xa6\x07\x6f\x5a\xee\x83\x66\x7c\xc4\xe7\xaf\x7c\x07\xb0\x6c\x82\x5e\xe3\x1d\x1e\x8e\x67\x86\xae\xf1\x4e\xed\xc8\xc3\xf6\x13\x97\xd4\x54\x7b\x12\xa4\x12\x69\xae\xa2\x7b\x7c\xa4\x52\x89\xbd\x5f\x3d\x79\x95\x6b\xc7\x8a\xd7\x5e\x7c\x59\x5e\x81\x37\x19\x80\x84\xa3\x34\x26\x6e\x4c\x70\x82\x05\xae\x96\x9e\xb3\xd6\xb5\x86\xf7\x41\x4d\xe7\xe7\x89\xde\xec\x17\x01\xb5\x67\x9f\x6d\xa2\x5f\xa1\x6e\x0e\xdd\xcd\x94\xab\xb6\x5e\x52\x46\xc4\xde\xc3\xa2\xc1\xcd\xb8\xe1\xa8\xdf\x8d\x95\xc4\x1d\xb6\x23\xe5\x21\xb5\xd3\xc9\x5e\x22\x84\xdb\xb1\x29\xa7\xed\x5c\xbc\xd1\x97\x7c\x22\x8f\xd1\x3f\x04\x55\x68\x8a\xc5\x01\x66\x66\x60\xef\x37\x06\x5f\x5a\xcf\x1e\xe3\xc1\xe2\xdf\x4d\x28\x47\xbb\xd9\xb6\x47\x34\x0a\xdd\x23\x49\x6c\xb5\x6f\x07\x89\x13\xc3\xdf\xf6\x3a\xe3\x6a\x10\x49\xbd\x6d\xff\xfc\x78\x65\xf4\xec\xbf\x01\x00\x00\xff\xff\xe8\xa1\xed\x50\x45\x28\x00\x00")
 
 func templatesSchemaGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -291,12 +291,12 @@ func templatesSchemaGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/schema.gotmpl", size: 9425, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
+	info := bindataFileInfo{name: "templates/schema.gotmpl", size: 10309, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
 
-var _templatesSchemabodyGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5a\xdf\x6f\xdb\x36\x10\x7e\xf7\x5f\x71\x30\xf2\x90\x14\x8e\xf2\xde\xb7\x14\xdd\x8f\x0c\x58\x3b\xa4\xdd\x5e\x8a\x01\x65\x25\x3a\xe6\x20\x89\x9a\x48\xb5\xf3\x04\xfd\xef\x03\xa5\x48\xe2\x6f\x51\xb6\x97\x38\xae\xdf\x62\x9b\x3a\x1e\xef\xbb\xfb\xbe\xcb\x51\x75\x0d\x09\x5e\x93\x1c\xc3\x92\xc5\x1b\x9c\xa1\x37\x34\xd9\x2e\xa1\x69\x18\x2f\xab\x98\x43\xbd\x00\xa8\x6b\x28\x51\xfe\x80\x21\xba\x4d\xd3\xf7\x6b\x68\x9a\x05\x40\xfb\x35\x59\x03\x2d\xe1\x12\xe5\x09\x5c\x44\x77\xec\x43\xf5\xe5\xe3\xb6\xc0\x10\xdd\xb1\x37\x88\xe1\xfe\xef\x1f\xfe\x29\x68\xc9\x71\x72\x25\x3e\xdc\xe6\x34\xdf\x66\xb4\x62\xbd\x19\xd9\xfe\x6f\x25\x2d\x70\xc9\x09\x96\x7e\xed\x37\xca\x31\x5c\x44\x6f\x09\x8b\x4b\x92\x91\x1c\x71\x5a\xfe\x48\x70\x9a\x40\xf4\x0e\x65\x58\x5e\x2e\x7b\x96\x53\xde\x7a\x36\xba\xe0\x73\xf6\x4a\x35\xd3\x1b\x12\xab\x3f\x56\x45\x8a\xf5\x9f\xdb\x05\x1c\x67\x45\x8a\x38\x86\x65\x51\x92\xaf\x5c\xac\x5b\x0b\xc7\x96\x10\x59\xcc\xe1\x94\x59\xcd\xa8\x56\xba\xe0\xfb\xcc\xe4\x89\x71\x64\x9b\xe9\x79\x07\xd8\xdf\xf9\xdd\x1c\xcf\x13\x15\x6d\x65\x91\xf9\xf9\x5a\x9c\x29\xfa\x19\xb1\xdb\x24\x21\x9c\xd0\x1c\xa5\xae\xc4\xe9\x96\x5a\xd7\x5d\x2b\x6e\xdc\xdc\xa8\xa1\x48\x68\xcc\x78\x49\xf2\x87\xa5\xe3\x71\xed\x10\xd7\x4a\x1e\xb4\xab\xb6\x7f\xa0\x94\x24\x48\x3c\xf9\x96\xc6\x1f\x7c\xd6\x2c\xd9\x2b\xd2\x54\x4a\xdc\x2e\x95\xc7\xb4\xbd\x12\xfe\xd7\x35\x14\x88\xc5\x28\x25\xff\x62\xbb\xe1\xbe\x38\x84\x83\x2d\x7a\xdd\x53\xd3\x6b\xdb\x88\x43\x86\x8a\x4f\x5d\x18\xfe\x54\xa2\xd3\x51\x85\xf0\xc3\x1d\x1e\xf8\xfc\x17\xa3\xf9\xeb\xe5\xf5\xf2\xb3\x04\x88\x8c\xb5\x06\x7d\x77\x6e\xc9\xdc\x1d\xc7\x99\x8a\x53\x18\x4a\xdd\x73\x5a\x1e\xcc\x87\xa7\x35\x63\xd0\x90\x15\x97\x0b\x19\x18\x37\x2e\xad\xc5\x31\xcc\x7d\x3d\xa9\x80\x18\x8b\x3a\x28\x3e\x05\x21\xd0\x1f\xdd\x0c\xbe\xad\xac\xb4\x72\x7e\xe4\x59\xca\x47\x92\xb4\xd3\x78\xe7\xf2\x4f\xb4\xfd\x45\x72\xd2\xba\x95\xfc\xa9\xae\x0d\xa2\x37\xc4\xc4\x42\xd9\x17\x0a\x47\x5f\xda\x19\xdb\xa4\xba\x49\x72\x96\x21\x98\x20\xe0\xe1\x14\x0a\x6c\xbe\x0d\xc3\x36\xf3\x6f\x34\x54\xc7\x58\x38\x8f\x55\x32\xc1\x7e\x41\xcc\xb7\x2b\xe7\x1d\x8c\xed\x02\x99\x6e\x1e\xd1\x49\xf0\x04\x3e\xd3\xf6\x11\x63\xa5\x1d\x8e\xf4\x34\x2c\x41\x06\xd0\x45\x73\x3b\x50\xdc\xbe\xf4\xb6\x37\x0c\x6e\x5e\x9b\x5e\xae\x05\x7f\x1f\x9a\x1b\xa3\xdc\xf4\xf5\x22\xb7\xb7\xdd\x39\x42\xfb\x5b\xb5\xbb\x0d\xed\x68\xdd\xad\xec\x48\xae\x32\xb9\x4d\xd3\xc8\x4b\xe6\x2d\xf9\x3b\x3f\x69\x19\x45\x61\xfb\x55\x0f\xdb\x2e\x94\x30\xb9\xf2\xa0\x1c\x30\x10\x77\x00\x01\xf4\xc7\xd4\xeb\xf0\xf8\xda\x09\xed\x30\x63\x1b\xa1\x35\x10\xb3\xfb\x07\xdd\xf0\x54\xdb\xf0\x7d\xd6\x54\x70\x27\x10\x52\x54\xe1\xd9\x76\xcc\x5a\xeb\x4e\x9c\x59\xa5\xf6\xc2\x25\xaf\xff\x53\x12\xbd\x6f\x84\x6f\xfa\x1a\x7c\x7e\xe5\xb3\x15\xe9\x69\xd6\xe8\x4c\xdd\x7b\xc1\xca\x76\x16\xb4\x43\x09\xda\x90\x0b\xc3\x1e\x93\x22\x67\x65\x1d\x11\x9a\xa6\x01\x77\x38\xa4\xf3\x0b\xb7\xc7\x50\xf6\x65\x7a\x8f\xff\xae\x48\xd9\x6e\xb2\xa2\x19\x11\x66\xf8\x76\xf0\xbf\xa7\x5b\x59\x8e\x2c\xa4\x3b\x95\xf4\xa7\xa1\x3c\x67\xc1\x69\x9a\x85\xae\x38\xb4\xe2\x73\x45\x67\x08\xdd\x1e\x37\x04\xae\xe8\x3a\xc6\xfb\x86\xfe\xe8\xb3\xea\xa0\xc1\xb8\x73\xf0\x1e\x36\x14\x37\x47\xe2\x56\x83\x66\x85\x0b\x64\x04\x30\xd1\x3d\xfa\xf6\x2b\x66\x0c\x3d\xe0\xfd\x8a\x5a\x1b\xc0\x7b\xe6\xef\xe1\xe3\x77\x5f\xff\x69\x43\xe2\xa5\xa9\xa0\x77\xb0\x6d\x84\xcc\x3b\xa1\x0e\x8f\xc0\xf1\x4c\x91\x8d\x54\x0d\xd7\x4b\xf9\xe4\xa3\x70\x06\x0c\x90\xc3\x87\xc9\x5a\xf5\xdb\xbc\xd4\x14\x75\x61\xab\x5e\xdf\x7d\x9c\x7d\x88\xfe\xa4\x5a\x6c\xbb\x4b\xb1\xe1\xf2\x24\xf4\xa1\xf4\x84\xe1\x0d\xc1\xc2\xf4\x71\xa2\x8c\x8d\x62\x79\x02\x75\x0f\x17\xbc\xf7\xe5\x3b\x9a\xf7\xce\x9d\xd5\x6f\xae\xfa\x9d\xc5\xe7\x2c\x3e\x87\xb9\xc2\x0c\x11\x20\xbb\x04\x4d\xbd\x87\x70\x60\x21\x3a\x55\x1d\x3a\x5d\x39\x68\xfe\x57\x32\x77\xa6\x8c\x1d\x5a\x68\x9a\xd7\x6d\x1a\xdf\xe3\x18\x93\xaf\xb8\xec\xf0\x8e\xac\x2b\x57\x33\x52\xfc\xa0\xdd\x9d\xe9\x22\x74\x3e\x8e\x4b\x56\x33\x3b\x40\x77\x2c\x47\x51\x34\x85\xd0\x5a\x6d\x81\x51\x05\x7f\x58\x5d\xae\x36\xab\x85\xbb\x7d\x90\x7b\x87\xdb\x3c\xb1\x36\x0f\xfe\x74\xf3\xa4\x94\x63\xac\xe4\x39\xf4\x93\xd1\xc4\xfe\xf8\xf6\x2f\x8c\xe8\x93\x69\x2b\xd7\x3e\xc3\x49\xd5\xd3\xb4\x6c\xd8\x4c\xb4\x81\x6e\x28\x7d\x48\xda\xb3\x77\xa1\x92\x0a\x86\xb0\x17\x28\x1d\x39\xdf\x6d\xfe\x38\xab\x6a\x63\x11\xa3\x0c\x2b\x3b\x0e\xbc\xeb\x1a\x4c\x42\xd3\x5c\x5e\x0d\x51\x59\x49\x0e\x1a\x7d\xa4\xdd\x0b\x43\xd4\x2e\xaf\x14\x2b\x12\x9f\x1d\x49\x92\x39\x39\x44\x05\x73\xf7\x80\x6a\xe1\xb4\x1e\xd4\x4f\x40\xb4\xe2\xa3\xfa\xed\x76\x4f\xb4\xcb\xfb\xbf\x93\x77\x46\x13\xaf\xfc\xee\xf3\x9e\xef\xa9\x5e\x11\x7b\xd2\xfc\xb9\x2f\xea\xcf\x40\x39\xee\xf2\x87\xd7\x95\xe4\xba\xfc\xa5\x62\xbe\x29\xfa\xcd\x2b\x10\x2b\x80\x6f\x30\x7c\x41\x0c\x03\x17\xb1\x6b\x37\x64\x11\xfc\xce\x70\x02\x6b\x5a\x42\x95\x67\x88\x6d\x50\x9a\x92\xfc\x01\x0a\x9a\x6e\x33\x5a\x16\x1b\x12\xb7\xcb\x59\xf4\xea\x26\xa0\x8b\xb5\xf2\x5c\x40\x13\xeb\xf8\xa7\xe6\xc8\x67\x0f\xf3\xc6\x90\x23\x74\xff\x05\x00\x00\xff\xff\xef\xaa\x1a\x27\x4a\x31\x00\x00")
+var _templatesSchemabodyGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5a\x5b\x6f\xdb\x36\x14\x7e\xf7\xaf\x38\x30\xf2\x90\x04\xb6\xfc\xde\xb7\x14\xdd\x25\x03\xd6\x0e\x69\xb7\x97\x62\x40\x59\x89\x8e\x39\x48\xa4\x26\xd2\xed\x3c\x43\xff\x7d\x20\x55\x59\xa4\x78\x11\x65\x7b\x89\xe3\xfa\xcd\x89\x8f\x0e\xcf\xf5\xfb\x8e\x0f\xb5\xdd\x42\x86\x97\x84\x62\x98\xf2\x74\x85\x0b\xf4\x9a\x65\x9b\x29\xd4\x35\x17\xd5\x3a\x15\xb0\x9d\x00\x6c\xb7\x50\x21\xfa\x88\x21\xb9\xcb\xf3\x77\x4b\xa8\xeb\x09\x80\xfa\x37\x59\x02\xab\xe0\x1a\xd1\x0c\xae\x92\x7b\xfe\x7e\xfd\xf9\xc3\xa6\xc4\x90\xdc\xf3\xd7\x88\xe3\xf6\xf3\x0f\xff\x94\xac\x12\x38\xbb\x91\x7f\xdc\x51\x46\x37\x05\x5b\xf3\x56\x8d\xae\xff\xb7\x8a\x95\xb8\x12\x04\x6b\xdf\xb6\x07\x51\x0c\x57\xc9\x1b\xc2\xd3\x8a\x14\x84\x22\xc1\xaa\x1f\x09\xce\x33\x48\xde\xa2\x02\xeb\xe2\xba\x65\x94\x09\x65\x59\x67\x42\xc8\xd8\x1b\x53\x4d\xab\x48\x4a\x7f\x58\x97\x39\xee\x7f\xad\x04\x04\x2e\xca\x1c\x09\x0c\xd3\xb2\x22\x5f\x84\x94\x5b\x4a\xc3\xa6\x90\x38\xd4\xe1\x9c\x3b\xd5\x98\x5a\x9a\xe0\x87\xd4\xd0\xcc\x72\xd9\xa5\x7a\x9c\x03\x87\x1b\xbf\x9f\xe1\x34\x33\xb3\x6d\x08\xd9\x7f\xcf\xa5\x4f\xc9\xcf\x88\xdf\x65\x19\x11\x84\x51\x94\xfb\x0a\xa7\x11\x75\xca\xcd\x0d\x33\x16\x0b\x33\x14\x19\x4b\xb9\xa8\x08\x7d\x9c\x7a\x1e\xef\x39\x31\x37\xea\x40\x49\x6d\xfe\x40\x39\xc9\x90\x7c\xf2\x0d\x4b\xdf\x87\xb4\x39\xaa\x57\x96\xa9\x56\xb8\x4d\x29\x77\x65\x7b\x23\xed\xdf\x6e\xa1\x44\x3c\x45\x39\xf9\x17\xbb\x15\xb7\xcd\x21\x0d\x54\xd9\x6b\x9e\x1a\x96\x55\x11\x87\x02\x95\x1f\x9b\x30\xfc\x69\x44\xa7\x81\x0a\x69\x87\x3f\x3c\xf0\xe9\x2f\xce\xe8\xab\xe9\x7c\xfa\x69\x20\xb7\xfa\x9f\x66\xba\xee\x05\x2e\xcc\x4c\xc5\xe5\xa9\x79\xae\x57\x09\xe3\x13\xa4\xd4\x58\x40\xe4\xcc\xcc\x95\x9e\x1a\x7f\x66\x94\xc6\x2e\xd0\x6d\x47\x99\x29\xb1\x84\x9a\x64\x7c\x8c\xca\x41\xeb\xba\x1d\x7e\x33\xf8\xfa\xe1\x8b\x5b\xa0\xa8\xc0\x19\x08\x09\x88\x29\x2b\x4a\xc6\x95\x3a\xb8\x5d\xf4\x92\x23\x7d\xdd\x41\xa8\x1b\xe4\x1b\x77\x7e\x62\xea\x1b\xcd\x81\x49\xdf\x08\xf3\xb3\x45\x01\x16\xcd\x38\xc0\xfc\xca\x40\xef\x6b\x37\x96\xdb\x20\x38\x08\xdb\x7a\x74\x06\xa0\x79\xe7\x85\x91\xce\xd0\x81\x71\x87\x85\x0f\xfa\xd6\x35\xbd\x70\x46\xe0\x62\x14\x26\xee\x8b\x86\x47\xc3\xc1\x48\x0c\x1c\x07\x81\x5a\x7a\x22\x9f\x51\x13\x46\xd7\x81\xc7\x84\x43\x33\x73\x73\x2b\x8d\x3e\x10\xdc\x03\x00\x0f\x07\xbf\x83\xd3\xe1\xc7\xbd\x61\xf1\x5e\x12\x0e\x81\xc1\x2e\xe8\x35\x4c\xb4\xa8\xeb\x53\x70\xe3\x4c\xec\x18\x6c\x0e\xc1\xb1\x83\xaf\x7f\xe2\xed\x50\x56\x47\xba\x61\x4c\x39\x0b\x10\x1b\x44\x30\xab\x37\x5c\xdf\xf6\xc3\xb6\x0f\x3e\x0c\x4a\x1e\x15\x10\x64\x08\x54\x30\x1c\x70\x6e\x97\xb4\xbb\x19\x4f\x6f\xe6\xe8\x53\xfd\xee\xc7\x43\x6f\x92\x18\x3d\x48\x8c\x9d\x21\xbe\xcf\x9e\xd2\xba\xeb\xf0\xa6\x8a\xaf\xb6\x53\x26\x5e\x7f\xe1\x8c\x6a\xb5\x17\xcd\x7b\xdd\x47\x8d\xf4\xbe\x12\xb1\x6a\x7b\xf0\xf9\x99\xcf\xd5\xa4\xe7\xd9\xa3\x23\x79\xef\x05\x33\xdb\x85\xd0\x8e\x45\x68\xbb\x5a\xd8\x9d\x31\x48\x72\x4e\xd4\x91\xa1\xa9\x6b\xf0\x87\x43\xf3\x5f\x9a\xdd\x85\xb2\x6d\xd3\x07\xfc\xf7\x9a\x54\xea\x90\x19\x2b\x88\x54\x23\x36\x3b\xfb\x5b\xb8\xd5\xe9\x68\xd4\xcf\xd5\x73\x62\x9e\x0b\xe1\xd4\xf5\xa4\xcf\x38\x6c\x2d\xc6\x92\xce\x2e\x74\x07\x5c\x24\xf8\xa2\xeb\xb9\x05\xb0\xf8\xa7\xbf\xd2\x8e\xda\x9f\x7b\xf7\xf3\x71\xbb\x73\x7b\x73\xee\x54\x68\x77\xb8\xcc\x8c\x4c\x4c\xf2\x80\xbe\xfe\x8a\x39\x47\x8f\xf8\xb0\xa6\xee\xed\x72\x03\x6b\xfa\xf8\x2d\x7d\x68\xfe\x74\x65\xe2\xa5\xb1\xa0\xe6\x6a\x44\xc8\x82\x6b\xec\xf8\x08\x9c\xe2\xaa\xd9\xbd\x4a\x0e\xf0\xa5\xee\x79\x47\x9c\xde\x53\xf6\xd9\x2c\xf7\xba\xdf\x65\x65\x8f\x51\x27\xae\xee\x0d\x5d\xdb\x39\x7a\xf5\xa9\xb9\xd8\x75\xe1\xe2\xca\xcb\x93\xc0\x87\x31\x13\x8e\xde\x5f\x8f\x68\x78\xab\x59\x9e\x80\xdd\xe3\x09\xef\x5d\xf5\x96\xd1\xd6\xb8\x0b\xfb\x8d\x65\xbf\x0b\xf9\x5c\xc8\x67\x98\x7c\x7c\xe8\x3b\x96\x80\xdc\x14\x34\xf4\xba\xc2\x91\x89\xe8\x5c\x79\xe8\x7c\xe9\xa0\xfe\x5f\xc1\xdc\x5b\x32\xee\xd4\x42\x5d\xbf\x52\x65\xfc\x80\x53\x4c\xbe\xe0\xaa\xc9\x77\xe2\x94\x9c\x8d\x28\xf1\xa3\x4e\x77\xb6\x89\xd0\xd8\xd8\x89\xcc\x46\x4e\x80\xfe\x58\x76\xa4\x68\x13\xa1\xb3\xdb\x22\xa3\x0a\xe1\xb0\xfa\x4c\xad\x67\x13\xff\xf8\xa0\xcf\x0e\x77\x34\x73\x0e\x0f\xe1\x72\x0b\x94\x94\x67\xad\x14\x70\xfa\xc9\x60\xe2\xf0\xfc\xb6\x6f\x8f\xf4\x37\xd3\x4e\xac\x7d\x06\x4f\x4d\x6f\x14\x1a\xd6\x03\x63\xa0\x3f\x95\xa1\x4c\xba\xab\x77\x62\x82\x0a\x86\xb8\xf7\x2c\x3d\x35\xdf\x1c\xfe\x6d\x57\xa5\x62\x91\xa2\x02\x1b\x27\xee\x70\xd7\xb7\x98\x84\xba\xbe\xbe\xd9\x45\x65\xa6\x19\x68\xcd\x91\x6e\x2b\x2c\x52\xbb\xbe\x31\xb4\x68\x78\x76\x22\x45\xe6\xc5\x10\x33\x99\xfb\x07\xb4\x17\x4e\xa7\xa3\x61\x00\x62\x6b\xd1\xb1\xdf\x7e\xf7\x44\xfb\xbc\x26\x3c\x78\x67\x34\xf0\x66\xf0\x21\xaf\x03\x9f\xeb\x15\x71\xa0\xcc\x9f\xfb\xa2\xfe\x92\x28\xcf\x5d\x7e\xdd\x7e\xd0\xfb\xf2\x97\x35\x0f\x6d\xd1\x17\xb7\x20\x25\x40\xac\x30\x7c\x46\x1c\x37\xaf\x78\xaa\x03\x79\x02\xbf\x73\x9c\xc1\x92\x55\xb0\xa6\x05\xe2\x2b\x94\xe7\x84\x3e\x42\xc9\xf2\x4d\xc1\xaa\x72\x45\x52\x25\xce\x93\xdb\x45\xc4\x14\xeb\xc4\xb9\x88\x21\xd6\xf3\xa3\xe6\xc4\x77\x0f\xe3\xd6\x90\x5d\xea\xfe\x0b\x00\x00\xff\xff\xd9\xc6\x61\x63\x71\x31\x00\x00")
 
 func templatesSchemabodyGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -311,7 +311,7 @@ func templatesSchemabodyGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/schemabody.gotmpl", size: 12618, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
+	info := bindataFileInfo{name: "templates/schemabody.gotmpl", size: 12657, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -336,7 +336,7 @@ func templatesSchematypeGotmpl() (*asset, error) {
 	return a, nil
 }
 
-var _templatesSchemavalidatorGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5c\x5f\x73\xdb\xb8\x11\x7f\xae\x3e\xc5\x56\x93\x76\xc4\x9c\x4a\xdd\x43\xa7\x0f\x4e\xdd\x19\xf7\xce\xd7\xd3\xf4\x92\x78\xe2\x5c\x1e\x9a\xc9\x34\xb0\x04\x49\xb8\x23\x41\x06\x20\x1d\xbb\x1c\x7d\xf7\x0e\xf8\x17\x20\x01\x12\x94\xa8\x44\x56\xf4\x26\x81\x20\xb0\xbb\xd8\xfd\xed\xe2\x07\x92\x49\x02\x4b\xbc\x22\x14\xc3\x38\x64\xc4\x27\x11\xb9\xc7\x2b\x82\xbd\xe5\x3d\xf2\xc8\x12\x45\x01\x1b\xc3\x76\x3b\x02\x48\x12\x20\x2b\x70\xdf\xe0\x4f\x31\x61\x78\x99\x35\x92\x15\x60\xc6\xe0\xe2\x12\xf2\xee\xb8\xec\x90\xf5\x47\x74\x09\x13\xfc\x09\xdc\x7f\x05\x6f\x1f\x43\x0c\x63\x1e\x31\x42\xd7\x63\x07\x26\x34\x88\xc0\x9d\xf3\x57\xb1\xe7\xa1\x3b\x0f\x3b\xb0\xdd\xde\xa6\x17\x93\x04\x30\x15\x13\x4c\xf2\x39\x6f\x50\xb4\x81\xed\x36\x49\xe4\x9f\xd8\xe3\x18\xb6\xdb\xf1\xb8\xec\x3e\x15\x32\x86\x8c\xd0\x68\x05\xe3\x3f\x7d\x1a\x83\xfb\x4b\xb0\x40\x11\x09\x68\x71\x91\xac\x40\xcc\x3a\x09\x98\x98\xf9\x8a\x06\xf4\xd1\x0f\x62\x5e\x17\x43\x4c\x94\xcb\x9b\x09\x91\x8d\x9f\x24\xee\x3b\xe4\xc5\xf8\xfa\x21\x64\x98\xf3\x6c\x5c\xfb\x51\x9d\x72\x20\xe7\x45\x6a\xb5\x3f\x5e\x02\x25\x1e\x24\x23\x00\x00\x86\xa3\x98\x51\xd1\x3e\x02\xc8\xed\x9d\xf5\xae\x6c\xff\x92\xd0\x5f\x30\x5d\xa7\x16\xd0\x1b\xbf\xec\x31\xac\xe9\xb2\x45\x2b\xc6\xac\xd4\x82\xed\xf6\x79\xbb\x79\x1c\x31\xb2\x22\xf8\xce\xca\xa3\x87\x2e\xe5\x8b\x1e\x47\xa6\xbc\x24\xf8\xae\xca\xdf\xa0\x28\xc2\x8c\x1a\x55\xcf\xaf\x1f\x91\xe2\x1f\x93\x44\x92\xfa\xe3\x1e\x2e\x4f\xfc\xd8\x6f\x73\x78\x71\x3d\xeb\x2d\x70\xe6\xf6\x33\x5a\xaf\x31\xcb\xc0\x86\xd0\x08\xaf\x71\x8a\x60\x73\x1a\x1d\x14\x57\xda\xe6\x26\xd9\xdc\xd9\xc0\x2b\x2f\x40\x95\x28\x7f\xfb\xeb\x5e\x51\x95\xdb\x26\xfd\x7b\xfd\xb0\xf0\x62\x4e\xee\x71\xd5\xbe\x47\xac\xb5\x5b\x3d\xbb\xfe\x6d\x5a\xbd\xb4\x4d\xcd\xea\x65\xfb\xce\x56\x8f\xbd\x88\x84\x1e\x7e\xbd\x32\x1b\xbe\xec\x32\xac\x35\x53\xf3\xec\x65\x15\x59\xf6\x5d\x0d\x70\x4d\x0b\x9f\x9b\xcd\x84\xce\x31\x06\x4c\x63\x5f\x31\x45\x92\xb8\x6f\xf0\x02\x93\x7b\xcc\x5e\x21\x5f\xc8\xe7\x16\xd6\x11\x1a\x22\xbe\x40\x1e\xf9\x1f\x06\x37\xbf\xaa\x36\xde\xc6\xab\x15\x79\x80\xed\x56\x4c\x75\x08\x87\xec\x67\xba\x1d\xed\x34\xe7\x3f\xc4\x3c\x0a\xfc\x9f\x02\xe6\xa7\x10\x0b\xdb\x2d\xa4\x77\x27\x09\x44\xd8\x0f\x3d\x14\x61\x18\xe7\x76\x21\x01\xcd\xba\xaf\xd2\xee\x63\x70\xcb\xc1\xf2\x81\xab\x5f\xa3\x24\x29\xaa\x41\xee\x91\x05\xb6\x2a\x02\x5b\xcb\xc0\xc1\x8d\x6c\x69\xc7\x9a\x25\x4d\xb6\x14\x35\xdb\x4b\x42\xe7\x11\xf6\x79\x8a\x7b\xd9\xaf\x5c\x2f\x31\xdd\x9c\x2e\xf1\xc3\x3b\xc4\x1a\xbe\x94\x3b\xd8\xad\xf8\x73\x71\x09\x84\x8a\x00\xf2\xb0\x48\xc2\x3a\x19\x1d\x63\x82\x53\xa6\xd4\xe7\xb8\xb4\xcb\xf0\xa6\xb4\xd1\xad\x48\x35\x85\x94\x7b\x18\xbb\x61\x5f\x7d\x6a\xf9\xea\xca\x56\x52\xee\xa3\xec\xaf\x94\x7c\x8a\x71\x97\xbe\x52\xaf\xa1\x55\x1e\x36\x52\x24\x74\x4e\xf1\x79\x15\x30\x48\x31\xa2\xa6\x59\x5f\x80\x3e\x04\x12\x0f\xac\x79\x1d\x13\x72\xdc\x48\x9b\x2b\x2c\xcc\xff\xff\x8c\xf8\xbb\x12\x78\x79\xd1\x3a\xe7\xff\x44\x1c\xa7\x35\x4a\xd9\x72\xe5\x11\xc4\x2b\x10\x85\xd4\xa4\x49\x22\x3b\xaa\x30\xe8\xf7\x2f\xea\x8d\x7f\x07\x33\xcc\xd4\x3b\x7f\xf7\x5d\xa9\x6c\x92\x7c\x26\xd1\xa6\xa6\x4e\xa5\x92\xd8\xaa\xcb\xe9\x2b\xdb\xa0\x17\xea\x39\xf2\x0d\xe9\x7a\xf3\xcf\x68\xed\xce\xf9\x7f\x30\x0b\x26\x06\x5c\x86\x44\x78\x8a\x18\x87\xe5\xc3\x48\x43\x00\x2c\x02\x1a\x11\x1a\x63\xa9\x51\x11\xaa\x5c\x87\xa2\xa5\xca\x6d\x21\x0b\x42\xcc\xa2\x47\x29\x41\xb9\x55\xdf\xfa\xbd\xe5\xca\xc9\x2b\x9b\xfb\x95\xb4\xa8\x6a\xf2\x2e\xfc\x5a\xaf\x9b\xea\x49\xf5\x09\x95\x70\x68\xde\xec\xe6\x1e\x82\x27\x59\x4e\xe6\x7a\xef\x4c\xc7\xb9\xc7\x53\x08\x7e\x17\x43\x61\xc6\xdc\xc9\x73\xcc\x58\xc0\xb8\x5b\xf9\x98\xf3\x42\x5c\x4f\x24\x23\xe6\x5e\x7d\x8f\xcb\x79\x44\xac\xf5\x0c\x32\x67\xd4\x5c\x93\x5a\xb8\x48\x86\xd5\x5b\x4f\x6f\xf7\x7a\xd1\x21\x51\x50\x3e\x0a\x0d\x25\xc7\xcf\x88\x5f\x2d\x97\x44\x28\x8c\xbc\x9b\x6c\xf5\x09\xae\x45\xa5\xab\xeb\xf2\x55\xab\x95\x9c\x1b\x52\x78\xa1\x5d\x09\xa6\xda\x20\xed\x7c\x92\x16\xdb\xea\x8e\x9a\x8d\x6d\x30\xdb\x2b\x8c\x97\x12\x94\x15\xf7\xe4\x20\xa5\xbd\xe5\xdf\xf8\xb1\xc2\x2d\x86\xe8\x1a\x9b\xa2\xa7\xc2\x24\xc8\x40\xa9\x6d\x71\x2b\x51\x15\x48\x52\xc2\x6d\x3f\x34\xaa\x21\x51\x3b\x0a\xe5\xce\x7e\x53\xd0\xa5\x2a\x32\x96\xd7\x1b\xf0\xde\x50\x44\x5d\x4f\xa5\x57\x4b\x50\x65\xa8\x80\xbc\x02\x16\xf4\xda\x36\x40\x41\xaf\x8d\x12\x0b\xd6\xb0\xa4\x41\x02\xd9\x68\x9d\x0a\x68\xba\xd6\xe4\x2a\x5a\x25\x8c\x56\x2e\x64\xce\xe5\x5e\x79\x5e\xb1\x5b\x36\x75\xd1\xbb\x93\xd2\xd3\x36\xad\x74\x09\xdc\xda\x6e\x25\xce\x0e\xc2\x98\x6d\xa7\x6d\xad\x12\xfd\xdb\x38\xf4\xb0\x1c\x78\xb5\xba\x60\x36\x83\xb7\xaf\x7f\x7c\x7d\x51\xa0\x24\xa1\x6b\x40\x65\x67\x20\x69\x6f\xbe\x09\x62\x6f\x09\xeb\x00\x36\x98\xe1\xa9\x18\xfe\x31\x88\x81\x63\x0c\xd1\x86\x70\x60\x88\x70\x0c\x88\x02\xe1\xbc\x0c\xaf\xd9\x0c\x50\x04\x9b\x28\x0a\xf9\xc5\x6c\xb6\x26\xd1\x26\xbe\x73\x17\x81\x3f\x5b\x07\x7f\xe1\x19\x9b\x23\xff\x4c\x6f\xe5\x9d\xea\x19\xdc\xa5\x66\x52\xc3\x11\x87\xdb\x1c\xab\x11\xf6\xe9\xe8\xa6\xfd\xf7\xc8\x30\x63\xc7\x26\x5c\x37\xf8\x15\x63\xe8\xb1\x65\xc8\xfa\xce\xbc\x65\xa8\x97\x28\x6c\x19\x48\xcd\xb6\x4d\x13\xd4\xab\x7e\xb5\xae\x81\x7e\x75\x7e\x06\x51\x87\xa0\x5d\xac\xab\x7d\x63\x01\x63\xb1\xe8\xd9\xe1\xce\x0f\x81\x1f\x7a\xf8\xe1\xf5\xdd\x6f\x78\x11\x49\x41\x34\xd7\x17\x27\xa6\x2c\x60\x97\x03\x86\xcf\x00\x5f\x10\xff\xad\xd1\xbf\x5f\x28\xb7\xe3\xfe\xf1\xc0\xac\x85\x18\xbd\x85\x30\x59\x4a\xd3\x76\x0a\x28\xaf\x0f\x47\xb9\x45\xfd\x6f\x2e\x70\x1b\xd4\x05\x0b\x7c\xf0\x51\xd8\x60\x2e\x7a\x42\xda\xd7\x45\xb3\xce\xfa\x5e\x42\xaf\xd4\x19\x24\xa6\xa2\x84\x25\x77\xce\xe7\x34\xc2\x6c\x85\x16\x58\x07\xf3\x07\xdf\x21\xed\x0b\xde\x1d\x2c\x76\x90\x22\xb5\x7e\x4f\x69\xc2\x5f\x29\x7e\x64\x93\x69\x51\xf8\xa9\x98\xc9\x10\x18\x06\xad\xce\x94\xc7\xc0\x94\x87\x4a\x35\xe9\x93\x58\x57\xd6\xe8\x91\x2f\x1a\x6b\xad\xfe\x6b\x99\xc6\x7a\x12\x3d\xa9\xd3\x2b\xf9\x1c\x2a\xf5\xec\x9a\x78\x3a\xa0\x44\x63\x0d\xf5\x50\xae\x41\x08\x98\xa9\x00\xc5\xcc\x0d\x8c\x52\x8c\xac\xd4\x41\x3d\x37\x33\x86\x6c\x60\xde\xc0\xf4\x3d\x3f\x34\x6c\x5a\x6c\xb6\x2b\xc6\x8d\x4a\xf7\x16\x65\xf8\xb2\xdc\x6a\x3d\x0c\xfe\x51\x92\x97\xb5\x65\xe8\x76\x0e\xfb\xa5\x3c\xb1\xc5\x6b\x3b\x76\x5e\x6c\xb0\x8f\x0c\x31\x26\xd7\x71\x59\xd3\xa4\xf1\x04\x48\xf9\x80\xa1\x1c\x34\xcf\xd6\x41\x24\xae\x5e\x5c\x4a\xc4\xeb\x68\x11\x50\x1e\xc1\xa4\x81\xbf\xca\x73\x08\xd2\xdd\xf5\x83\x43\x91\x13\x17\x28\x8c\x62\x86\x79\xfa\xa4\x42\xfe\xd0\x42\x3d\x97\x8b\xb1\xfe\xd0\x31\x8e\x72\x19\x2e\xb5\x63\xd4\xc1\xdd\xa9\x05\xf9\xa8\x38\x96\x4b\x6d\x38\xba\x47\x4c\x5c\x5c\x20\x1f\x37\xca\x56\x78\xff\x81\x14\x75\x5f\xb2\x1d\xad\x62\xba\x00\x42\x49\x34\x71\xd2\xb4\x2a\x6e\x15\x4a\xbd\xff\xa0\x2c\xe8\x12\x33\xbc\x5a\xe1\xe5\x6d\x3a\x81\x30\x63\x29\x59\x95\xfe\x7f\xe3\x01\x75\x7f\xa5\x3e\x62\x7c\x83\xbc\xc9\xfb\x0f\x77\x8f\x11\x9e\x7c\x4c\x92\xf4\x4a\x69\xdd\x8f\xce\x14\xfe\xcc\xb0\xb6\x0e\x08\x11\x25\x8b\x09\x66\xcc\xc9\x1f\x82\x10\x5a\xfd\x77\x0a\xf7\x15\xaf\x2c\xa4\x2b\x0b\x11\xbd\x8a\x97\x80\xc2\x10\xd3\xb4\x16\xd3\xf6\x98\xc2\x7d\x36\xc1\x76\x94\x59\x60\xa2\xd9\x02\xa8\xc5\xa2\x1c\xc6\xf2\xd3\x1d\x79\x24\x5c\x3f\x84\x01\x8b\xf0\xd2\x74\xc6\x5c\x01\xba\x98\x49\x6a\xcc\xea\x0f\xe8\xde\x6e\x84\x28\xda\x4c\xc1\x2b\xaa\xc3\xcc\xdb\xa7\x95\xe3\x95\x98\x58\x42\x60\x03\x1c\x0d\x54\xbb\xa2\x4e\xf7\x9a\x3b\x90\x96\x65\xe9\x22\x68\x0a\x61\x8d\xb0\xb9\x94\x53\xe3\x8a\x59\x3d\x0f\x93\x37\x50\xe2\x8d\xf4\xb5\x47\x76\xbe\x59\xc4\xb0\x29\x08\xaa\x4e\x6a\x24\xec\x15\x0a\x52\x79\x63\x1f\x0f\xb2\xb8\x07\x0d\x8a\x6a\xa2\xd6\xc8\x28\xbb\xd9\x85\xc7\xf3\xcc\xea\xcf\x5a\xbc\xff\x99\xd6\xfd\xd5\x66\x9b\x00\x28\x25\x3b\x92\x28\x28\x9f\x12\x19\x36\x14\x4a\x35\x07\x88\x87\xee\xc3\xb5\x5a\x6a\xcd\x53\x88\x54\x87\x8b\xba\x97\x1b\xe3\xa8\xa4\x75\x87\x8c\xa3\x63\x4c\x29\x95\xa2\xad\xd1\x53\x76\xeb\x15\x3d\x87\x4e\x1d\x15\xf9\x7e\x1c\x91\x33\x7c\xd0\x94\x1a\xee\x12\x34\xa6\xed\xac\x88\x86\x82\x4f\x28\x45\xe3\xd9\xc6\x33\x49\x60\x13\xfb\x88\xca\x42\x94\x0b\x6d\x28\x22\x86\xb0\xac\xf0\x96\x1f\x09\x5f\x88\x42\x84\xa6\xe2\xa4\xcd\x0d\x83\xa8\x25\xfa\xbe\xde\x55\x67\x6f\x84\xe3\xac\xfc\xc8\x7d\x83\xd7\x84\x47\xec\x51\x5e\xcd\x2a\xd2\xd3\xb6\xd1\xc8\x48\x7a\x54\x56\xa9\x88\xb6\xda\xf3\x53\xfa\xad\xaf\x76\x9b\x64\xcf\xa3\x14\x2f\x26\x51\x91\x9b\x24\x63\x06\xec\x27\x31\x70\x66\x00\x27\x7b\xa3\xc7\x24\x59\xf3\x81\xa8\x1d\x1f\x80\xeb\x3e\x6c\x81\xd4\x9c\x25\xec\x30\xcc\xa7\x90\x23\x59\x93\xb0\x6a\x27\xc9\x75\x2c\xa0\xe5\x49\xc1\x1e\x44\x79\xf6\x78\x63\x87\x9e\xad\x3a\x9a\xa5\x97\x5e\xbd\xaa\x98\x6c\xdd\xbb\x58\xc5\x03\x78\x8e\x63\xab\x93\xa2\xcb\x64\xc9\x82\xf0\x06\x2d\x7e\x47\xc2\xb5\xb2\x4d\xa4\xd3\x87\xd8\xec\xa9\x5f\xed\x77\xb7\xef\xb7\xf9\xfd\xf0\x3e\x7f\x38\x7f\x9f\xcd\xd2\x92\x63\x20\xbb\xd9\xfa\xf7\x61\xbd\xbb\x45\x87\x16\x99\xd3\x6a\x63\x52\xdf\x79\x56\xaf\x4e\xbe\x44\xa1\x23\x91\xa9\xca\x1b\x13\xfb\x1f\x6c\x8d\xc7\x53\x18\xdf\x05\xcb\xc7\xf1\x54\x37\xc2\x9e\x8a\x66\x59\xdf\xc3\x54\xf4\x72\xe0\x1f\xf0\x7d\x23\x57\x07\x8c\xbb\x22\x45\x06\x9c\x44\xb8\xf2\xc2\x6b\x71\x45\xdc\xe5\xba\xae\xa3\xcb\xe7\x56\xb1\x60\x9d\x74\xe4\xe2\xb8\x5e\x04\x97\x3b\x18\x01\x06\x5a\x4b\x8a\xe9\x4f\xb9\x3a\xee\x61\x01\x6d\xd9\x6c\x7f\xbf\x5c\x4f\xab\xa9\xdc\x86\x03\x84\x36\x1e\x50\xed\x22\xc0\x87\x8a\xb9\x45\xa7\xa2\xb0\x53\xa9\x42\x68\xa5\x0b\xf5\x1b\x5f\xa9\xb5\x9c\x61\x5f\x42\x71\xbf\x99\xec\x29\x47\xd0\xd0\x8e\xd0\xa0\x1e\xc5\x64\x32\x08\x59\x70\x06\x6d\x85\x6c\x83\x35\xd8\x89\x65\xe8\x4d\x32\x9c\xe4\x2e\xc9\x3e\xcc\x76\xdb\x3e\x69\xcb\xce\x4e\x2e\x4e\xef\xb4\x5d\x0c\xdd\xe9\x11\x74\xb6\x76\x68\x47\xd0\xf6\x9b\x7b\x92\x79\x47\x18\x98\xfd\xd9\xbf\xfc\x3d\x9b\x22\x46\xf3\xbf\xf5\x48\x2d\xde\xc6\x39\x3a\x3e\xd0\x72\x65\x07\x8e\x58\xe3\xfe\xcf\xd4\xe3\xc8\xaa\x23\xad\xfc\xf6\xc1\x6e\x50\xee\x84\x8a\xa7\xa7\x19\xfd\x7d\x02\xbf\xbe\x86\xa6\xbd\x5f\x13\x0c\x9a\x1d\x06\x80\x85\xa6\x47\x3e\x99\xac\xde\x45\x27\x59\x9e\x31\x68\xb6\x52\xb3\x59\xfd\x8c\x21\xbf\x45\x2a\x20\xfb\xd5\x0b\x27\x7f\x12\x61\xab\xfe\x0e\x65\xc2\x6e\xa7\x16\x47\x09\x14\xa7\x7b\xd4\x61\xb9\x84\x87\x88\x75\xa5\x44\x18\x86\x46\x34\x1e\x95\x1c\xb3\x73\xd9\x1c\x7f\xc8\xa6\xd2\xbc\xaf\xb8\xd7\xbb\x8a\xd2\xb2\xed\xff\xae\xb4\x4d\x59\xd8\xc2\xac\x1a\x0e\x74\xda\x1f\x2e\x1d\xfc\xe4\xe5\xcc\xd0\x1d\x65\x91\x99\xd3\x41\xc2\xed\xce\x64\xd0\xb1\xe6\x91\x2f\x58\x36\x1e\x92\x10\x3a\x33\x42\x67\x46\xe8\xcc\x08\x0d\xc0\x08\xb5\x84\x6d\x0b\x2b\x74\xe6\x85\x4e\x23\x65\x3f\x4d\x0c\x38\xf3\x42\x5f\x27\xc1\x1b\xb0\xa2\xd9\x62\xc7\x0e\xd9\x17\xf2\xbd\xb8\x9f\x93\x2b\xe2\xbf\x10\xf5\x63\xc3\xce\x3d\x4d\xbc\x38\xd3\x43\x07\x0a\xf9\xd1\x99\xd1\x79\xc2\x8c\x8e\xe1\x43\x6b\x9a\x2f\x1f\x5a\x97\x79\x07\xdd\xb6\x3d\xa1\x6a\xce\x72\xd7\x76\xde\x9f\x7d\x3b\x05\xda\x40\x3b\xb6\x2a\x7c\x5b\xa1\xb7\xb9\x30\x36\xeb\x66\x07\x8c\xe6\xb5\xab\xd8\xdb\xfa\x15\xdd\xc3\x96\xd9\x57\x05\xa1\xfe\xed\xd3\xb6\x6f\x08\xba\x66\xd9\xa5\xcf\x0b\xb6\x83\xa6\x16\x46\x9a\x38\x69\x7c\xc7\xaa\xfa\xf5\xff\x00\x00\x00\xff\xff\x3d\x42\x94\xa1\x48\x65\x00\x00")
+var _templatesSchemavalidatorGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5d\x5b\x93\xdb\xb6\xf5\x7f\xfe\xeb\x53\x9c\xbf\xc6\xed\x48\x8e\x4c\xe5\xa1\xd3\x87\x4d\xdd\x19\xd7\x71\x9a\x9d\xc6\xb1\xc7\x4e\xf2\xd0\x4c\xa6\xc6\x92\x47\x12\x62\x12\xa4\x01\x4a\xde\x2d\x47\xdf\xbd\x03\xf0\x06\x92\x00\x05\xea\xe2\xd5\x6e\xe4\xa7\x15\x09\x02\xe7\x7e\xf9\x01\xa4\xb3\x0c\x02\x5c\x50\x86\x30\x4e\x38\x8d\x68\x4a\x37\xb8\xa0\x18\x06\x1b\x12\xd2\x80\xa4\x31\x1f\xc3\x76\x3b\x02\xc8\x32\xa0\x0b\xf0\xde\xe1\xa7\x35\xe5\x18\xe4\x17\xe9\x02\x90\x73\xb8\x7a\x0e\xc5\x70\xac\x06\xe4\xe3\x09\x0b\x60\x82\x9f\xc0\xfb\x67\xfc\xd3\x5d\x82\x30\x16\x29\xa7\x6c\x39\x9e\xc2\x84\xc5\x29\x78\xd7\xe2\xc7\x75\x18\x92\x9b\x10\xa7\xb0\xdd\xbe\x57\x37\xb3\x0c\x90\xc9\x05\x26\xc5\x9a\x6f\x49\xba\x82\xed\x36\xcb\xf4\x3f\x31\x14\x08\xdb\xed\x78\x5c\x0d\x9f\x49\x1a\x13\x4e\x59\xba\x80\xf1\x9f\x3e\x8d\xc1\xfb\x21\xf6\x49\x4a\x63\x56\xde\xa4\x0b\x90\xab\x4e\x62\x2e\x57\x7e\xc1\x62\x76\x17\xc5\x6b\xd1\x26\x43\x2e\x54\xd0\x9b\x13\x91\xcf\x9f\x65\xde\x2f\x24\x5c\xe3\xab\xdb\x84\xa3\x10\xf9\xbc\xee\xb3\x4e\xab\x89\xa6\xdf\x28\xa9\xfd\xff\x73\x60\x34\x84\x6c\x04\x00\xc0\x31\x5d\x73\x26\xaf\x8f\x00\x0a\x79\xe7\xa3\x6b\xd9\xbf\xa6\xec\x07\x64\x4b\x25\x01\xb3\xf0\xab\x11\xc7\x15\x5d\xae\xb4\x72\xce\x9a\x2d\xd8\x6e\x9f\xf6\x8b\x67\x2a\x67\x6e\x10\xbe\x37\xf3\xe4\x76\x17\xf3\xe5\x88\x33\x63\x5e\x23\x7c\x5f\xe6\xdf\x92\x34\x45\xce\xac\xac\x17\xf7\xcf\x88\xf1\x0f\x59\xa6\x51\xfd\xe1\x00\x93\xa7\xd1\x3a\xea\x33\x78\x79\x3f\x1f\x2d\xe3\xcc\xfb\xcf\x64\xb9\x44\x9e\x07\x1b\xca\x52\x5c\xa2\x8a\x60\xd7\x2c\x3d\x69\x5c\xe9\x5b\x9b\xe6\x6b\xe7\x13\x2f\xc2\x98\xd4\xa4\xfc\xf5\x2f\x07\x79\x55\x21\x1b\xf5\xf3\xd5\xad\x1f\xae\x05\xdd\x60\x7d\xfd\x00\x5f\xeb\x97\x7a\x7e\xff\x8f\x29\xf5\x4a\x36\x2d\xa9\x57\xd7\xf7\x96\xfa\x3a\x4c\x69\x12\xe2\x9b\x85\x5d\xf0\xd5\x90\xe3\x4a\x53\x89\xe7\x20\xa9\xe8\xb4\xef\x2b\x80\x57\xac\xb4\xb9\xf9\x5c\xf2\xbc\x46\x40\xb6\x8e\x1a\xa2\xc8\x32\xef\x1d\xfa\x48\x37\xc8\x7f\x24\x91\xa4\xcf\x2b\xa5\x23\x39\x24\xc2\x27\x21\xfd\x2f\x82\x57\xdc\x6d\x5e\x7c\xbf\x5e\x2c\xe8\x2d\x6c\xb7\x72\xa9\x53\x18\xe4\x30\xd1\xed\x29\xa7\x6b\xf1\x72\x2d\xd2\x38\xfa\x2e\xe6\x91\x0a\xb1\x6a\x81\xf9\x53\x48\x57\x28\xef\xbe\x4f\x39\x92\x08\x7c\x22\x10\x26\x34\x7e\x87\x24\x78\x19\xc6\x02\xf9\x14\xa8\x00\x12\x72\x24\xc1\x1d\xa0\xb4\xdc\x00\x83\x19\x08\xca\x7c\x04\x9a\x42\x10\xa3\x50\xb5\x0c\x47\x11\x87\x1b\x04\x22\xa0\xaa\x0a\xe1\xe9\x5c\x11\xa1\xc8\x48\x31\x4a\x42\x92\x22\x8c\x0b\xe9\xd3\x98\xe5\x44\x2d\x14\x51\x63\xf0\x2a\x92\x0b\xf2\xeb\xbf\x46\x59\x56\xd6\x9c\x22\xa4\x3e\x3a\x95\x9a\xbd\xc5\xe6\xd1\x55\xe9\xa8\xad\x96\xbe\x6c\x1a\x93\x95\xe1\x6b\xca\xae\x53\x8c\x84\x8a\xae\xf9\x5f\xb5\x38\xbd\x6b\x16\xe0\xed\x2f\x84\x77\x2c\xb6\x30\xe3\xf7\xf2\xc7\xd5\x73\xa0\x4c\xba\x69\x88\x32\xd5\x9b\x68\x9c\x5a\xd3\x68\x63\x49\x73\x26\x55\x43\x8e\x2f\x4a\x17\xde\xca\x84\x56\x52\x79\x80\xb0\x3b\xf2\x35\x27\xb0\x7b\x67\xb6\xa6\xf2\x10\x66\x7f\x66\xf4\xd3\x1a\x77\xf1\xab\x8d\x3a\x36\xcb\xc7\xf5\x14\x2d\x07\xa8\x2c\xb0\x88\x39\xa8\x18\xd1\xe2\x6c\x68\x1a\x38\x45\xbc\x3f\x32\xe7\xad\x98\xf0\xac\x6a\x9f\x55\x5f\x29\x6f\xd6\x11\xb1\xf8\xfd\x3d\x11\xbf\x54\xe1\x57\x94\x57\xaf\xc5\x3f\x88\x40\x55\x0f\x55\x57\x5e\x84\x94\x08\x0c\xaa\xb6\xbb\xb8\x7c\xcd\x52\xe4\x0b\xe2\x63\xfb\x46\x9e\x42\xa6\x25\x39\xa0\x14\x91\x65\xba\x79\x4b\x35\x7c\xfd\x4d\xfb\xe2\xdf\xc0\x1e\x9c\xda\x83\xbf\xfa\xaa\x12\x91\xe4\xf7\x33\x4d\x57\x2d\x31\xb4\x44\xa1\x67\xd7\x9c\xde\x52\x22\x35\x9e\xf0\x9a\x24\x72\xcc\x9b\x0d\x72\x4e\x03\x9c\xea\x53\x29\x0b\x12\x9f\xc9\xd2\xbb\x16\xff\x46\x1e\x4f\x2c\x91\x1e\x32\x69\x7b\x79\x22\xcc\xe7\xd7\xa6\x00\xf0\x63\x96\x52\xb6\x46\xed\x62\x93\xdc\x4a\xb5\xe5\x25\x2d\x5f\x26\x3c\x4e\x90\xa7\x77\x5a\xd2\xf3\xea\xc1\x9d\xa7\x6b\x73\xd0\xec\xe5\x59\x69\xae\xba\xad\x14\xf0\x43\xae\x68\x98\x30\xec\xb2\xd6\xf0\x99\x69\x59\x35\x24\x1c\x37\xc8\x52\x01\x4b\x64\xc8\x49\x8a\x01\xf8\x71\x80\x90\xc6\xe0\x93\x30\x04\x9a\x0a\x0c\x17\x57\x90\xae\xa8\x90\x05\x04\x47\x81\x7c\x83\x81\xb2\x09\x52\xac\x97\xde\x25\x28\xea\x12\x61\x87\xda\xec\x6a\xa2\x0b\x4b\xfa\x6d\x3b\x55\x47\x52\x8d\xe0\xd0\x7d\xde\x2b\x3c\x05\x27\x79\x85\x22\xcc\xbe\xaa\xe6\xd9\xe0\x0c\xe2\x8f\x72\x2a\xe4\xdc\x9b\x3c\x45\xce\x63\x2e\xbc\xda\xd7\xa6\xdf\xc8\xfb\x99\x66\x00\x85\x8f\x6f\xb0\x5a\x47\xca\x78\x60\xc8\x99\x8e\xba\xf6\xd4\x0a\x1e\xf5\xad\x3d\x05\x6c\xb1\xb4\xae\x85\xb5\xab\x36\x0d\x29\x8c\x48\xd2\xa8\xd9\x94\x19\x95\xf1\x57\x00\x09\x02\x2a\xa5\x44\xc2\xb7\xb9\xb1\xd3\xda\x34\x0a\x81\x7c\x4f\xc4\x0b\xd3\xa8\xba\x24\xaa\x59\x7b\x4d\x12\xf0\x4c\xa3\xef\xb5\x42\x2c\x50\xbf\x06\xe2\xb7\x2f\x74\xd8\x9a\xa4\x1f\x29\x34\xe6\x93\x66\x46\xa9\x8c\xc3\x22\xb7\x56\xde\x28\x9e\xc9\x43\xbc\xe5\x91\x7f\xe1\x5d\x1d\xf6\x39\x61\x4b\xb4\xf9\x69\xed\xa0\x45\x44\xef\x53\x74\xad\xec\x46\x38\x6f\x78\xf5\x61\x01\xbb\x15\xac\x1b\xcb\x76\xe2\xf4\xb3\xa2\xbf\x7a\x5b\x35\x3d\x8d\xec\x51\x0f\x28\xc3\x6c\xe3\x76\x35\xc0\xa0\xd3\x9a\x9d\x0d\x09\xcb\xe8\x62\xe6\xa6\x13\x5b\x0e\xf0\xf6\x7a\xcd\x6e\xa0\xb3\xc4\xd1\x8e\x23\x39\x47\x4e\x4b\xc0\x6a\x8a\xfd\x60\x76\x4c\x53\x19\x52\x66\xe3\x76\xee\xdf\x7a\x98\x92\xa2\x8e\x25\x01\xa5\x8a\xe2\x9b\xdf\xd1\x4f\x1b\x29\x4c\xb3\x94\xdc\xe2\xbd\x17\x61\x58\xa2\x33\xb6\x21\x66\x1b\x6f\x8c\x74\x2d\x06\x1a\x0f\x75\x74\x64\x55\xde\x10\x7a\xf6\xa0\xc6\x4c\x8b\x85\x92\x46\x20\xff\x69\x9d\x84\xa8\xc7\x83\x56\xad\x37\x9f\xc3\x4f\x6f\xbe\x7d\x73\x55\xe9\x88\x2d\xb5\x5c\x02\x54\x8d\x16\xab\x78\x1d\x06\xb0\x8c\x61\x85\x1c\x67\x72\xfa\xbb\x78\x0d\x02\x31\x2f\x50\x38\xa1\x02\x81\x30\xa0\x42\x54\x5e\x3f\x9f\x03\x49\x61\x95\xa6\x89\xb8\x9a\xcf\x97\x34\x5d\xad\x6f\x3c\x3f\x8e\xe6\xcb\xf8\x99\xc8\xf1\x43\xfd\x4f\xf5\xa8\x68\x33\xd2\x61\xaf\xce\x1c\xed\xa1\xba\x4c\x2d\x9b\x6a\x5e\x77\xae\x6e\x34\x52\xd3\xd7\x02\x6c\xc3\x3e\xaa\x35\x68\x37\x01\x75\x49\x5c\x58\xbc\xaf\x9e\x82\xdc\x79\x55\x6c\xf2\x49\x92\xae\x65\x98\x35\xe3\x3b\xf5\xfa\x97\x1d\xbf\x2f\xb8\xe3\xd7\xeb\x4a\xcd\xcc\x52\x20\x7c\x85\x82\x73\xa7\xa9\xae\x4a\x0d\xb4\x2c\xa5\x70\x9a\x1b\x84\x68\x9d\xae\x49\x18\x16\xf0\x9f\x90\x7a\xa7\x4c\x55\xef\x25\xe8\xc7\xbb\x21\x70\x08\xe0\xd7\xc3\x45\xa9\xc3\x22\x85\x72\x4e\xee\x3a\x4e\x50\xaf\xd3\x86\x06\x3d\xfb\x54\xb2\x42\xb4\x4f\xd4\xac\x56\xbb\x7e\xd7\x86\x1d\x9a\xad\x04\x0c\x03\x1a\x72\x7b\x39\x05\xba\xec\x0c\x37\xf4\xf4\x0c\xbb\x15\x93\x9b\xf4\xcb\x38\x4a\x42\xbc\x7d\xa3\x72\xa2\x16\xba\xaf\xcd\x55\xbb\xad\x20\xda\x51\x0e\xed\x59\x0c\xed\x5d\x3b\xf4\x15\x42\xf7\x51\x06\xed\xcd\x48\x6f\xea\xed\xe8\xda\x9c\xa2\xfa\x2b\x9a\x33\xaa\x1f\x1c\xe8\x18\x4c\x85\x35\xc4\x9a\x72\xfc\x63\x28\x60\x4c\xe5\x85\xc9\x68\xda\x5d\x64\xeb\x97\x09\xa1\xe5\x71\x04\x11\x49\x3a\x00\xed\xc0\xc0\x79\xbf\x31\x73\x67\x4b\xad\x57\x63\xdd\x70\xa7\x7b\xb2\x06\xd2\xd6\xf8\xaa\x29\xb7\x9c\x1c\xa3\x38\x3c\x63\x18\x40\xa2\x16\x2e\xd3\x81\x12\x4c\x4d\x56\x21\xac\x88\x24\x02\x6e\xd6\xda\x3e\xe3\x47\x16\x7f\x06\x72\x13\xaf\x53\x30\x25\x96\x2b\x40\x6f\xe9\x01\x4d\xc1\x8f\x23\x14\xb9\xad\x11\x78\xc2\x71\x61\x80\x1a\xed\x5d\x77\x35\xe4\x49\x55\x2c\x28\x32\x3f\xa3\x9a\xb8\x9c\x37\x22\x49\x11\x6d\xb4\xc9\xdd\x93\x14\x40\x3f\x08\xbc\x77\xc7\x6b\x20\xdf\xa1\xb9\x37\xc5\x7e\x67\x74\xb5\x87\x89\x9e\x2c\x99\xdb\x6f\x4d\xe5\x86\x84\xb5\xe5\x9a\x17\xae\xac\xf9\xb8\xe9\xf5\x28\xf8\x82\x5d\x8b\x31\xd7\xb8\x2c\xd4\xde\xf3\xdc\x60\xac\x55\xdb\x21\xcf\x71\x89\xee\x16\x79\xaf\xc9\xdb\xe2\x91\x76\x36\xe1\x61\x86\x23\x43\x34\x3a\xf9\xbe\x87\x3a\x47\xa1\x85\xb1\x63\x6d\x75\x5c\x36\x3b\x3a\x1e\x77\x6f\x9b\x1d\x8d\xed\x34\x4b\x6d\xbc\xab\x16\x1d\xb4\xcd\xd7\x5b\x66\xf5\x2c\xe3\xbc\x48\xa7\x78\xd1\x7f\xb8\x96\xb4\xa7\x2a\x68\xf7\x2d\x67\x77\x05\x4b\x83\x40\x74\x9e\x4d\xc8\x7e\x0f\xa6\xdf\x90\x75\x27\x0e\x7b\x0d\x6b\x6a\x24\xda\x81\x08\xa0\xc9\x3a\xef\x05\xf8\xbb\x40\x7e\x5f\x1c\xf2\x33\x57\xd8\x6d\x98\xcf\x64\x57\x3b\x71\x38\x73\x94\x33\x80\x6f\x6e\xb0\x9b\xc1\x2c\x65\xfd\x23\x25\x52\xaa\xb9\x3e\x65\x52\x0c\x28\x5d\xaa\x71\xd4\xa4\xb2\x4f\xbc\xf5\x31\x49\xd5\xbe\x23\x2d\xef\xce\xd4\x21\x46\x8e\x2c\x40\x4e\xd9\xa2\x71\xc6\x40\xf5\x0f\x54\x40\x82\x5c\x32\x8b\x01\xdc\xdc\x41\xcb\x2f\x2d\xa7\x14\x8d\x18\xa0\xce\xd1\x91\x70\x2f\xa7\x90\x61\x8b\x62\xd5\xfe\x7a\x2b\x52\xec\x0e\x61\x03\xc2\xcd\x25\xba\x5c\xa2\xcb\xd9\x45\x97\xd6\xf3\x5a\x8f\xeb\xe8\xc5\x7d\x47\x8c\xfd\x15\x46\xc4\x72\xc6\x58\x07\xb3\xf2\x4b\x93\xce\x3b\x05\x95\xbd\xe9\x92\x7a\xb2\x8c\xd5\xa6\xc9\xd5\x73\x4d\xd1\x23\x3f\x66\x22\x85\x49\xa7\x60\x6c\x9c\x6c\xd7\x9e\x6e\x1f\x12\x95\xa5\x7f\xe1\x45\x42\x9d\x7d\x2f\x8e\xc1\xb7\xad\x52\xce\xf5\x7f\x3b\xe6\x69\xdc\x86\xe7\xc6\x39\xda\xd5\xe8\xb4\x55\x3a\x8e\xca\x23\x98\x4a\x86\xa3\x0d\x51\x27\x44\x7c\x12\x61\x07\xbb\x83\x5f\x7f\xab\x82\x78\xb6\x1d\x2d\xd6\xcc\x07\xca\x68\x3a\x99\x2a\xf3\x94\x8f\x4a\xa6\x7e\xfd\xad\xa1\xd1\x00\x39\x2e\x16\x18\xbc\x57\x0b\x48\x31\x56\x94\xd5\x81\xe1\x77\x11\x33\xef\x67\x16\x11\x2e\x56\x24\x9c\xfc\xfa\xdb\xcd\x5d\x8a\x93\x0f\x59\xa6\xee\x54\xd2\xfd\x30\x9d\xc1\x9f\x39\x1a\x7b\x9d\x84\x30\xea\x4f\x90\xf3\x69\xe1\x1b\x92\xab\xff\xcc\x60\x53\x1f\x67\x91\xd4\x65\x25\xff\x66\x16\x9f\x03\x49\x12\x64\xaa\x33\x36\x8e\x98\xc1\x26\x5f\x60\x3b\xca\x25\x30\x31\xe0\xa0\xcd\xd3\x43\x7a\x34\xd7\xdf\x17\x28\x5c\xe1\xd5\x6d\x12\xf3\x14\x03\xdb\x79\xe2\x26\xbe\xa2\x5d\xcc\xc3\x04\xec\xc6\x5c\x13\x92\xae\x66\x10\x96\x71\x2e\xb7\xf6\x59\x6d\x78\x55\x72\xac\x72\x61\x27\x4b\x5a\x4e\xf8\x34\xd8\xd9\xad\xf3\x29\xa8\xd6\x53\x29\xc1\x90\x15\x0c\xc4\x16\x54\xce\xac\x1a\x73\x0a\x93\xc5\x05\x46\xc3\xd1\xb6\xe7\x68\x6e\xe9\xc3\x36\x27\xa8\x07\x35\x3d\xe1\x20\x57\xd0\xba\x31\x77\x7f\xd0\xc9\x3d\xa9\x53\xd4\x0b\xf5\x7a\x46\x35\xcc\xcd\x3d\x9e\xd6\x30\xa2\xcd\xfa\x9f\x18\xcd\xbf\x79\xd9\xc5\x01\x2a\xca\xce\xc4\x0b\xaa\x37\x02\x8e\xeb\x0a\x15\x9b\x47\xf0\x87\xdd\x67\xfa\x5a\xa9\xb5\x48\x21\x1a\x6c\x20\xbb\x74\x61\xf5\xa3\x6a\x07\xfd\x98\x7e\x74\x8e\x29\xa5\x66\xb4\xd7\x7b\xaa\x61\x83\xbc\xe7\xd4\xa9\xa3\x3e\xe7\x70\x1e\x9e\x73\x7c\xa7\xa9\x38\xdc\xc7\x69\x3a\xf5\x71\xf9\xf7\x7c\x0e\x25\x66\xaa\x9d\x98\x56\x38\x59\x96\xc1\x6a\x1d\x11\xa6\x13\x51\x29\xda\x52\x44\x1c\x43\xb2\xd2\x5a\xbe\xa5\xc2\x97\x85\x08\x53\xe4\xa8\xcb\x1d\x81\x34\xcf\xdc\x1c\x6a\x5d\x6d\x84\x5a\x1a\xce\x22\x4a\xbd\x77\xb8\xa4\x22\xe5\x77\xba\x36\x6b\x4f\x57\xd7\x46\x23\x2b\x4a\xab\x77\x38\x26\xf8\x34\x7f\xb1\xb4\xdc\x9b\x54\x71\x29\x3f\xfc\xe4\xc7\x51\x12\x0b\x25\xab\x3c\xc4\x35\x3a\xb8\x1d\x9b\xa1\x45\xdf\x56\xef\xf6\xb6\x9b\xb8\xf2\x85\x9c\x69\x3e\xb4\xde\x92\x69\x76\xd9\x53\x4b\x33\x66\x6c\xe5\xdd\x51\xe9\x92\x4a\x26\x13\xa7\xa6\xe9\x98\x7f\x27\x27\xce\xb5\xe3\x4e\x1a\x1c\xf4\x26\x96\xcb\xf6\x9e\xd4\x75\x15\x13\x39\x8a\x19\x14\x61\xb6\xfc\xe7\xbe\xd7\xd6\xc4\xbb\x6d\xaf\x1d\x68\xfb\x08\x53\xc7\xf7\x19\x28\x03\xc2\x0a\xf4\x09\x3e\xaf\xa8\xbf\x02\x9a\x6f\x6a\xe7\xfb\x46\xc5\x7e\x72\xe3\x2c\x9d\xdb\xb1\x34\x03\x07\x03\xce\xa0\x1c\x70\x04\x23\x7f\x3f\x70\x87\x7e\x7a\x75\x63\xdb\xdf\xa8\xbb\x7b\x57\x23\xeb\x67\xa3\x41\xfe\x24\xe0\x71\xf2\x96\xf8\x1f\x89\xf4\x82\xdc\x67\xa7\x43\x36\xc1\x1c\x58\xb2\x6d\xd9\xba\x38\x6a\xbf\x8f\x1e\xdf\x3f\x4f\xe7\x9b\x4e\x82\x32\x65\xbd\xb3\xf1\xc2\x41\x70\x92\xab\xe7\x59\x09\xcd\x07\x48\x1a\x21\x55\x0f\x57\x74\x9c\xd6\x4b\x7b\xf4\x64\xee\x70\x15\x87\xaa\x14\x9d\xb4\x61\x89\x69\x5b\x2d\xa3\x3a\x8f\xd6\x1f\x68\x38\xfc\xe8\xd7\x78\x3c\x83\xf1\x4d\x1c\xdc\x8d\x67\xa6\x19\x0e\x64\x34\x2f\x09\x43\x64\x72\xd4\x14\xfe\x0e\x5f\x77\x0a\xb9\x98\x0b\xef\x65\x51\x05\x60\xed\x59\xaf\xe4\x1d\xf9\x94\xe7\x79\x53\x53\xb1\xe7\xe4\xdf\x7d\xae\xdb\x0e\xf4\x9e\x0d\x69\xa8\xda\x5b\x19\xe1\x8c\x92\x94\xcb\x3f\xe6\xd6\x69\x80\x04\x8c\x3d\x95\xfb\xf3\x7a\xb3\xd5\x2c\xa5\x5c\x00\x62\xe8\x03\x89\x9b\x43\x64\x33\xcc\xe4\xda\x72\x50\x59\xf5\x37\x71\x64\xe8\xc5\x92\xcd\xa8\x88\x76\xb5\x5a\xe1\x50\xb4\xf9\xb0\x95\xdc\xf1\x68\x30\x60\xd2\xd0\xc1\xa5\xe5\x62\x7a\x10\x72\x00\x94\xfa\xba\x9c\x0e\xa4\xb4\x17\x04\x35\x18\x81\x7a\x94\x2d\xb4\xbb\x9b\xed\xd7\x5b\xb7\x0b\x4c\x37\xa0\xd6\x6c\xb4\xbb\xe0\xdb\xc7\x87\xde\xba\xca\xa1\x3f\x82\xf6\x3f\x3c\x10\xe9\x3d\x43\xc7\x1c\x0e\x0d\x17\x9f\xce\x28\x7d\xb4\xf8\xd9\xf6\xd4\xf2\x83\x1c\x67\x07\x16\x3b\x6a\xf6\xc8\x1e\x6b\xed\x63\x6d\x23\xce\xac\x3a\x32\xd2\xef\xee\xec\x16\xe6\x1e\x51\xf1\xf4\x30\xbd\x7f\x88\xe3\xb7\x75\x68\xeb\x14\xbb\xc1\xa0\x3b\xe0\x08\x61\xa1\x6b\x91\x0f\x26\xab\x1b\xa3\x44\xfb\xf7\x90\x8f\x4a\xe8\x9b\x50\xad\x0d\xa8\xe2\x11\xad\x80\x1c\x56\x2f\x3c\xfa\x6d\x2a\x57\xf6\xf7\x28\x13\xf6\xdb\xd2\x3a\xcb\x40\xf1\x78\xf7\xc1\x1c\x55\x78\x0a\x5f\xef\xe0\xde\x87\x43\xa3\xd6\x7d\xb4\x73\x36\x2e\x97\xbd\x31\x5d\x54\x86\x6f\xe8\x1c\xf4\xfd\x1c\x4d\x6d\xbb\xbe\x9c\xb3\xfb\xa5\x04\x97\xb2\xd0\x8e\x1e\x5b\x76\xfb\x76\xbc\x2a\x71\xf4\x9d\xaf\x0b\x42\x77\x96\x45\x66\x01\x07\x49\xb3\xbb\x80\x41\xe7\x9a\x47\xbe\x60\xd9\x78\x4a\x40\xe8\x82\x08\x5d\x10\xa1\x0b\x22\x74\x04\x44\xa8\xc7\x6d\x7b\x50\xa1\x0b\x2e\xf4\x38\x52\xf6\xc3\x8c\x01\x17\x5c\xe8\x7e\x12\xbc\x25\x56\x74\xaf\xb8\xa1\x43\xee\x85\xfc\x20\xec\xe7\xd1\x15\xf1\x5f\x08\xfa\x71\x41\xe7\x1e\x66\xbc\xb8\xc0\x43\x27\x72\xf9\xd1\x05\xd1\x79\xc0\x88\x8e\xe5\x43\xe0\xed\xff\x16\x65\x48\x99\x77\xd2\xb6\xed\x01\x55\x73\x8e\x5d\xdb\xa5\x3f\xfb\xe3\x14\x68\x47\xea\xd8\x6a\xf7\xed\x0d\xbd\x5d\xc5\xb8\xe8\xcd\x2d\x30\xda\x75\x57\xa3\xb7\xed\x3b\xa6\xc3\x96\xe5\xa7\xee\x5b\xff\x9d\x49\xdf\x77\xed\x3d\x3b\xed\xda\x67\x9a\xfa\x83\xa6\x31\x8c\x74\xe3\xa4\xf5\x05\xbc\xfa\xaf\xff\x05\x00\x00\xff\xff\x7f\xed\xca\xcf\xb7\x75\x00\x00")
 
 func templatesSchemavalidatorGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -351,7 +351,7 @@ func templatesSchemavalidatorGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/schemavalidator.gotmpl", size: 25928, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
+	info := bindataFileInfo{name: "templates/schemavalidator.gotmpl", size: 30135, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -596,7 +596,7 @@ func templatesTuplefieldGotmpl() (*asset, error) {
 	return a, nil
 }
 
-var _templatesTupleserializerGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5a\x5b\x6f\xdc\x36\x16\x7e\xb6\x7e\xc5\xd9\x81\xeb\x95\xb2\xb2\xa6\x49\xf7\xc9\x0b\x17\x48\x9a\x74\x9b\x02\x75\x8a\xa4\xdd\x7d\x30\x8c\x94\x33\x3a\x63\x33\xd6\x2d\x14\x35\x13\xef\x40\xff\x7d\x71\x48\x89\xa2\x24\x6a\x66\x92\x38\x59\x60\xeb\x97\xc4\x23\x91\x3c\xf7\xdb\x27\x6e\xb7\x10\xe3\x8a\x67\x08\x33\x59\x15\x09\xbe\x41\xc1\x59\xc2\xff\x83\x62\x06\x75\xed\xcd\xe7\xf0\x7b\x96\x32\x51\xde\xb0\xe4\xe7\x37\xaf\x2e\xa0\x6a\x7f\x95\x20\x6f\x78\x09\x6a\x13\xc8\xbb\x02\x61\x25\xf2\x14\x18\xa8\x65\x4c\x08\x76\xe7\xad\xaa\x6c\x09\xfe\x76\x1b\xbd\xc6\x25\xf2\x35\x8a\x0b\x96\x62\x5d\xc3\xa3\xed\x16\x0a\x56\x2e\x15\x21\x88\xe8\x29\xd4\x75\xd0\x27\xe5\x0b\xb6\x81\xcb\xab\xc5\x9d\xc4\x00\x50\x88\x5c\xc0\xd6\x03\x98\xcf\xa1\x94\xec\x1a\xe1\x71\x08\xd7\x28\x41\xde\xa0\xa6\x06\x8b\x4a\xc2\xbb\xaa\xb4\x1e\x79\x00\x6b\x26\xf4\xfa\xc7\x70\x79\xf5\xae\xcc\xb3\xe8\x35\xdb\xfc\x82\x65\xc9\xae\xd1\x03\x58\x54\x2b\x38\x3b\x07\x22\x52\x46\x17\xb8\x79\x56\xad\x56\x28\x88\x74\xe0\x01\xc4\xb8\xa4\xb7\x6a\xdb\x05\x6e\x9e\xe3\x32\x8f\x51\xf8\x8b\x6a\xd5\xbc\x8d\x7e\x2f\xf1\xa2\x4a\x17\x28\xfc\xc0\xf3\x00\xf8\x8a\x38\xa5\x3d\xf4\x52\xaf\xf7\x4f\x34\xfd\xe0\x1f\xea\xdd\x5f\xce\x21\xe3\x89\x12\x05\x40\xa0\xac\x44\x46\xcf\x3d\x80\xda\xb3\xc5\x7b\xe2\x01\x6c\xb7\x74\x62\xf4\x34\x8e\xb9\xe4\x79\xc6\x92\x97\x12\xd3\x92\xec\xa2\x05\x4b\x58\x29\x5f\x66\x31\x7e\x00\x9e\x49\xbd\x1e\xb3\x58\xbf\xdf\x6e\x41\xb0\xec\x1a\xe1\x98\xc7\x1f\x42\x38\x5e\xb3\x84\xf8\x8a\x7e\x15\x79\x81\x42\x72\xa4\x73\xf8\x0a\x12\xcc\xfc\x86\x41\xf8\x9e\x76\xd1\x7a\xa8\xeb\x86\x43\x52\xd0\x58\x3f\x7a\xc3\x65\xb7\xfa\x2a\x50\xab\x77\x2b\x6c\xac\x32\x7a\xe6\xd4\x99\x96\xdc\xcf\x72\xa9\x38\x8f\x5e\x96\x17\x55\x92\xb0\x45\x82\x01\xd4\xf5\x89\x11\x94\x38\xa0\xf7\xb6\x83\x41\x5d\x47\x3d\x07\x53\x2b\x5a\x27\x73\x58\x61\x60\x07\xb2\x04\xfd\xab\x79\x38\x76\xab\x1f\x2c\xe5\x9f\x5b\x6a\x6b\x77\x1a\x3b\xd4\x63\xbb\x4c\xda\x74\x64\x0e\x43\xe3\x6f\x8f\x1b\x5e\x57\xb9\x80\xb7\x21\x34\xd6\xd4\x16\x6e\xac\x61\x2d\x3e\xbb\x32\xa2\x91\x9f\xc8\x9c\xc5\x31\x51\x96\x98\x16\x09\x93\x08\xb3\x72\x79\x83\x29\xfb\xed\xae\xc0\xd9\x04\x33\xd3\xd6\x5f\xb3\x24\x68\x16\xec\x33\xb8\xdb\xe4\x3b\x8d\x4e\x36\x1f\x72\x64\xd9\xbf\x67\x7e\x25\x98\xdb\xa4\x23\xa3\xb6\x66\x55\x26\xd8\x70\x79\x33\x96\xfb\xd4\x08\xae\x16\x1d\x47\xff\x62\x49\x85\x2f\x3e\x14\x02\xcb\x92\xe7\x99\xf6\xac\x53\x65\xc0\x97\xe5\x8b\x0f\x45\x2e\x24\x36\x6e\x38\xce\x67\xc4\x65\x52\x36\x7f\x2d\x59\x8a\xa3\xb7\x4a\x06\x38\x07\x56\x14\x98\xc5\xfe\x57\x23\x19\x6a\x8f\x08\x8c\x3e\x4e\x3b\xff\xd4\x6a\x1a\x7a\x6d\xa3\xcb\x8c\x27\x5e\xed\x51\x55\xf8\xc5\xaa\x09\x93\x15\x81\x67\x32\x3f\xac\x22\x4c\x14\x04\x8b\x8a\x1f\x80\xaf\xab\x41\xa8\xab\x41\xa0\x4c\x1d\x33\xc9\xc8\x8d\x2e\xaf\x78\x26\x51\xac\xd8\x12\xb7\xf5\xd6\xce\x7f\x76\xc6\x3b\x35\x01\x3a\x60\x20\x72\x32\x10\x7a\xce\x58\x76\x3b\x8f\x5a\xd1\x86\x67\x17\x9c\xd3\x46\xbd\x67\x37\xd2\x8e\xaf\xf4\x61\x3c\x8a\x7e\x85\xb0\x0e\xa6\x2d\xaa\x22\xb7\x51\xb3\x5a\x1e\x78\xb5\xd7\xad\xf3\xac\xfe\xe0\x86\x95\xcf\x79\xb9\x14\x3c\xe5\x19\x93\x18\x7f\x6c\xab\x90\x2f\xde\xe1\x52\x6a\xed\x31\x28\xf2\xe4\x2e\xcd\x45\x71\xc3\x97\xe3\xf6\xa1\x94\xa2\x5a\xca\x4a\xe0\x17\x69\x21\x28\x25\x2a\x3d\xf5\x32\x22\xf1\x95\x57\xf2\x19\x2b\x91\xd2\xe2\xb3\x3c\xbe\x9b\x41\xa4\x95\xf5\x55\xda\x04\xa5\xfd\x51\x2e\x3b\x1a\xf7\x08\xda\x75\x72\x41\xde\xd3\xb2\x4b\x7f\xbf\xa9\x16\xea\x4f\xd3\x1f\x2c\x58\x89\x7d\x21\x7f\xae\xca\x69\x09\x77\x0a\xf8\xf9\xf2\x11\x37\x07\x34\x41\xb6\x9b\xf6\xe2\xf8\x69\x92\xbc\x5a\x59\x25\xb6\xad\x15\x96\x12\x6a\x2b\xc5\x8f\xa3\xbf\x9f\xdd\xc7\x2a\xf4\x9b\xe3\xda\x88\x0c\xf4\x0e\x46\x74\xdd\xf9\xa1\x15\xd3\x78\x9d\x89\xea\xa7\xaa\x25\x1d\x86\xb4\x2e\x66\xff\xcc\x1b\x66\xdf\x24\x7c\x89\xbd\xf8\xb6\xd6\x9a\x55\x46\x1d\xfe\xd0\x3c\xe4\x31\xee\xcc\x15\x84\x20\xaa\x4c\xf2\x14\x23\x0a\x84\x1f\xf2\xac\xac\x52\x32\x4f\xd0\x99\xa7\x31\xc2\xc9\x49\xfb\x8b\xe7\xd1\x8b\x57\x3f\x4e\x59\xc5\x28\xce\x2a\x15\xc3\xdf\x83\x46\x67\xdc\x8c\x3a\xcc\xf1\x31\xa6\x70\x65\xc0\x3f\x99\x11\xdc\x2a\x6e\x02\x5e\x60\x59\x25\xd2\x5d\x4d\x7b\xc1\x74\xfc\x36\x84\xe3\x82\x09\xcc\xa4\x9a\x0a\x1c\xb1\xd5\xbc\x26\x35\x66\x79\x76\x97\xe6\x55\xd9\x33\x7b\x6f\xc9\x38\x02\x27\x27\x90\x76\x93\x3b\x30\x4d\x64\xa3\x59\x68\x15\x9d\x5c\xfc\xc8\x31\x89\x7b\x1d\xbd\xb5\xd5\xf0\xa5\x47\x06\xab\xb2\xaa\x82\x47\xba\x89\x6c\x17\xb2\x8f\xd1\x07\x9f\xab\x9c\x39\x3d\x3e\x0c\x89\x35\x4e\x73\xf8\xf1\xe3\x64\xb2\xf3\x78\x3b\xd4\x46\x24\xf9\x6a\x0f\xb7\xe4\x4f\x1d\x5f\xee\x35\x7e\xd0\xf8\xda\xfc\x11\x5c\xe4\x7a\x78\x56\xf5\x78\x83\x7f\x15\x08\x49\x9e\xdf\xf2\xec\x9a\x1a\x9b\x08\x1e\xcd\x07\x5e\x99\x0b\x15\x09\xfe\xdf\x9f\x3c\x09\x61\xc6\xb3\x35\x4b\x38\x0d\x1a\x86\x40\x5d\xd3\xa8\x52\xe1\x19\x7c\xf3\x7e\x16\xee\x61\x37\xe8\x65\x1a\x97\x02\x5c\xd9\xc7\xa8\xe3\x1e\xbc\xae\x71\x9c\xbe\x37\xdf\xb7\x65\x27\xdc\x66\xc2\x84\xe7\x30\x4e\x30\x3b\x0e\xde\xaf\xaf\x7e\xb6\xee\x69\x4f\x2b\x81\x65\xb1\x2b\xb2\xbb\x47\xfd\xb8\x7a\x08\xf6\x87\x60\xff\xfa\xc1\xde\x49\xda\x7a\x8e\x29\xd5\x56\xc8\x8c\xde\xdd\x53\xd7\x32\x9f\xd3\x4b\xcb\x90\x1d\x3b\xba\xf3\xb0\x32\x88\xab\x67\x51\x0e\x32\xd5\x73\x38\x00\x82\x43\xcf\xed\x8e\x9c\xe8\x4a\xac\x63\x07\xc2\xd2\x40\x35\x84\xd1\xa0\xf5\xa8\x6e\xea\xa0\x76\xc0\x0c\xbe\x0e\xb5\x74\x2f\xa1\x7b\x7b\x06\x02\x59\x0c\x82\x6d\x42\x10\x98\xe6\x6b\x84\x8c\xa5\x18\x43\x61\x96\x84\x2a\xed\xb0\x38\x06\x99\x43\xca\x0a\xd2\x29\xdb\xd0\x11\x25\xe5\x91\x94\xdd\xa2\x9f\xb2\xe2\xb2\x94\x82\x67\xd7\x57\x23\x14\xad\xc7\xca\x00\xe7\xed\xb4\x62\x63\x04\xad\xec\x41\x6f\x60\x51\x5b\x4d\x27\xe9\x2b\x96\x4f\x5a\x4e\x0e\x83\x70\x77\x62\x0f\x31\x26\x28\xd1\x6f\x4f\x0c\x55\xaf\x26\x78\x26\x57\x30\xfb\xe6\xfd\x0c\xec\xf0\x18\x34\x78\x0e\xec\x70\x68\x80\x06\x40\x34\xfc\xc2\xf7\xf0\x6d\xc3\x27\x99\x77\x0c\x43\x80\x53\xb5\x7b\x61\xc2\x1e\xdd\xc0\x00\x93\xb7\x3d\xe4\xc3\xd8\xef\xd3\xa0\x48\x57\xc9\x98\xb4\xd3\x9a\x14\x39\x06\x0f\xbb\x33\xee\x1d\x41\x74\x28\xf3\xf2\xf6\x0a\xce\xb5\x84\x3d\x20\xcd\x5d\x69\xdd\xd6\x68\x95\xb6\xbb\xd7\xff\x08\x38\x6e\x0f\xea\xd2\x01\x74\xfb\x31\x97\x4f\x03\xe9\x14\x02\x26\xec\xc4\x42\x03\xc7\x20\xd3\x78\x47\x0a\xaf\x78\x1c\xc2\xe2\x49\x08\x8b\xef\x1a\xd4\x46\x3f\x26\xdb\xa8\xd3\xbc\x23\x5a\x41\x3f\xcf\xfb\xc0\xd5\x3e\x20\xe7\x95\xb8\xc8\xb3\xb6\x43\xd0\x98\x47\xe0\x1d\xf5\x47\xb0\xad\x77\x74\xd4\xe9\x55\x91\xf1\x8e\x6a\xef\x88\x18\x3a\x84\xa4\x4d\xef\x69\x16\x7f\x32\xc1\x83\x32\x6d\x13\xe8\x6e\x37\xb2\xc3\x7e\x3e\x57\x01\xae\x4d\xdc\xf8\x02\x85\xaa\xfa\x46\xd6\xe5\xea\x2e\x11\xeb\xaf\x3e\xdf\x4d\xc9\xec\x22\x67\x7f\xc6\x71\x7f\x58\x31\xf2\x81\x13\x5f\xf6\x5a\x3d\x94\x1b\x76\x1d\xfd\x90\x67\x4b\x26\x95\x3b\x75\x0e\x11\x84\x8d\xb7\xbb\xb1\x49\xd5\x69\xf5\x01\xc9\x83\xdc\xee\x50\xd0\xf2\xeb\x81\x93\x3b\xf1\xae\x51\x23\x62\xa0\x4c\xcd\x94\xd1\xbb\xab\x02\x8d\xe0\xaf\x49\xf4\xac\xbf\xe4\x78\xa2\xe5\x6f\x56\x75\x51\x50\x08\xbe\xd6\x7c\xac\xa8\xbf\x31\xd8\xa2\xb3\x9f\xed\x3d\x1e\x75\x29\x3b\x2a\x04\xe5\xc9\x3f\xc8\x2d\xcf\x66\x56\x0f\x66\x49\xf4\x1a\xdf\x57\x5c\x28\x5e\xc3\x3c\xe5\x74\x8c\xbc\x33\x6e\x33\xfb\x63\x6f\xd3\x39\xe2\xf1\x7f\xac\x8b\x41\x3b\xf3\x85\xa5\x9f\x9e\x17\x8d\x17\xfe\xc4\x76\xa4\x26\x97\x20\xce\x8a\x3c\xe6\xbd\xa7\x5b\xd3\x23\xeb\x26\xf8\x73\x3a\x94\x56\x63\xa7\x46\xfc\x09\xc1\x26\x3f\x84\x4e\x0b\xa4\xd1\xc4\x9e\x2c\xb9\x70\xe0\x97\x3d\x7c\x7e\x20\xdb\xe5\x41\x22\xb5\x2c\xed\x96\xa6\xee\xb5\xb3\x2a\xa1\xbe\x46\x16\xb7\x19\x27\x84\x89\xef\x0c\x13\x88\xef\xf4\x0c\x34\xca\xaf\x53\x5f\xd1\x9c\x10\xc6\x60\x08\x9e\x1e\xc8\x06\xc9\x6a\x80\x45\x52\xfe\xdb\x6e\xe9\x3f\x1a\x28\x3a\x92\x14\x1b\xf6\xd0\xd7\x69\x64\x34\x4a\xd5\xb5\x0d\x1c\x77\xbb\x46\x40\xaf\x60\x9b\x20\x84\x13\x07\xb9\xa0\x8b\x66\xa7\xc6\xa7\xb6\x28\x19\x0f\xfc\x22\xe2\xba\xe2\x40\xf1\x50\xfc\xca\x96\xb7\x94\x15\x5a\xce\x67\x33\x33\x33\x0e\x89\xee\x9c\x76\x3f\xbe\xa7\xfc\xf2\xbd\x63\x63\xe1\xb7\x05\x13\xb2\x84\xcb\xab\xa6\x2b\xfc\x92\x55\x72\x78\x09\xe0\xa1\x4e\x3e\xd4\x49\xf5\xf4\xa1\x4c\xfe\x7f\x95\xc9\xbd\x05\x6e\xba\x68\x35\x37\xbe\x0e\xaa\x7e\x23\xda\x1e\x28\x47\x7d\xae\xae\x66\xd8\x65\xfa\xdf\x82\x4b\x54\x99\x50\xdf\xc3\x70\xcf\x54\xe3\x89\x8a\x48\x34\x19\xd2\x5c\xfc\xd0\xbf\x43\x43\x69\x08\x27\x8d\x92\xdb\xa0\xae\x3a\x8a\xc7\x14\xb3\x13\x9a\x98\xae\x4d\xf7\x23\x99\xab\xa6\x1e\x52\xdf\x86\x23\xa6\x3e\x2f\x8a\xa2\x3d\x13\xa6\xf6\xb6\xc1\x9d\x17\x80\xe6\x6e\x16\xcb\x62\xdb\x75\xb5\x5f\xff\xc4\x4c\xcd\x08\x2c\xa5\x77\x1e\xbc\xeb\x46\x4d\xd4\x49\x40\xf9\x4f\xf7\x2c\xbf\xa9\xbb\x55\xae\xa3\x46\x97\x77\x1d\xfb\x2d\x7e\xac\x9b\x50\x9f\xc3\xcf\xae\xf4\xd6\x3b\x99\x39\x16\x3a\x4f\x3f\x35\xc7\x93\x4a\xfd\x6b\x09\x7e\x82\x59\x53\xe6\x03\xf8\x36\x30\x39\xa3\xd5\x75\xe0\x96\x65\x84\x08\x44\x3d\x97\xa0\x3d\x9d\xa1\xff\x1b\x00\x00\xff\xff\xb3\xe4\x12\x8d\x06\x2d\x00\x00")
+var _templatesTupleserializerGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xec\x5a\x5b\x73\xdb\xc6\x15\x7e\x16\x7e\xc5\x29\x47\x51\x01\x17\x02\x6d\xa7\x4f\xea\x28\x33\x76\xec\x34\xce\x4c\xe4\x8c\x9d\xb4\x0f\x1a\x8d\xb3\x24\x96\x12\x2c\xdc\xbc\x58\x88\x56\x39\xf8\xef\x9d\xb3\xbb\xd8\x0b\xb0\x20\x29\x5b\x56\xa7\x89\x5f\x6c\x91\xd8\xcb\xb9\x9f\xef\x7c\xe0\x66\x03\x29\x5d\x65\x25\x85\x19\x6f\xeb\x9c\xbe\xa5\x2c\x23\x79\xf6\x1f\xca\x66\xd0\x75\xc1\x7c\x0e\xbf\x95\x05\x61\xcd\x15\xc9\x7f\x7a\xfb\xfa\x0c\xda\xfe\x53\x03\xfc\x2a\x6b\x40\x6c\x02\x7e\x5b\x53\x58\xb1\xaa\x00\x02\x62\x19\x61\x8c\xdc\x06\xab\xb6\x5c\x42\xb8\xd9\x24\x6f\xe8\x92\x66\x37\x94\x9d\x91\x82\x76\x1d\x3c\xda\x6c\xa0\x26\xcd\x52\x5c\x04\x09\x7e\x0b\x5d\x17\xb9\x57\x85\x8c\xac\xe1\xfc\x62\x71\xcb\x69\x04\x94\xb1\x8a\xc1\x26\x00\x98\xcf\xa1\xe1\xe4\x92\xc2\x93\x18\x2e\x29\x07\x7e\x45\xe5\x6d\xb0\x68\x39\xbc\x6f\x1b\xeb\xab\x00\xe0\x86\x30\xb9\xfe\x09\x9c\x5f\xbc\x6f\xaa\x32\x79\x43\xd6\x3f\xd3\xa6\x21\x97\x34\x00\x58\xb4\x2b\x38\x39\x05\xbc\xa4\x49\xce\xe8\xfa\x79\xbb\x5a\x51\x86\x57\x47\x01\x40\x4a\x97\xf8\x54\x6c\x3b\xa3\xeb\x17\x74\x59\xa5\x94\x85\x8b\x76\xa5\x9e\x26\xbf\x35\xf4\xac\x2d\x16\x94\x85\x51\x10\x00\x64\x2b\x94\x14\xf7\xe0\x43\xb9\x3e\x3c\x92\xf7\x47\xff\x10\xcf\xfe\x72\x0a\x65\x96\x0b\x55\x00\x18\xe5\x2d\x2b\xf1\xfb\x00\xa0\x0b\x6c\xf5\x9e\x06\x00\x9b\x0d\x9e\x98\x3c\x4b\xd3\x8c\x67\x55\x49\xf2\x57\x9c\x16\x0d\xfa\x45\x2a\x96\x93\x86\xbf\x2a\x53\xfa\x11\xb2\x92\xcb\xf5\xb4\x4c\xe5\xf3\xcd\x06\x18\x29\x2f\x29\x1c\x66\xe9\xc7\x18\x0e\x6f\x48\x8e\x72\x25\xbf\xb0\xaa\xa6\x8c\x67\x14\xcf\xc9\x56\x90\xd3\x32\x54\x02\xc2\x77\xb8\x0b\xd7\x43\xd7\x29\x09\xd1\x40\x63\xfb\xc8\x0d\xe7\x66\xf5\x45\x24\x56\x6f\x37\xd8\xd8\x64\xf8\x9d\xd7\x66\x52\xf3\xb0\xac\xb8\x90\x3c\x79\xd5\x9c\xb5\x79\x4e\x16\x39\x8d\xa0\xeb\x8e\xb4\xa2\x28\x01\x3e\xb7\x03\x0c\xba\x2e\x71\x02\x4c\xac\xe8\x83\xcc\xe3\x85\x81\x1f\xd0\x13\xf8\xaf\x94\xe1\xd0\x6f\x7e\xb0\x8c\x7f\x6a\x99\xad\xdf\xa9\xfd\xd0\x8d\xfd\x32\xe9\xd3\x91\x3b\xf4\x1d\x7f\x7b\xa2\x64\x5d\x55\x0c\xde\xc5\xa0\xbc\x29\x3d\xac\xbc\x61\x2d\x3e\xb9\xd0\xaa\x61\x9c\xf0\x8a\xa4\x29\xde\xcc\x69\x51\xe7\x84\x53\x98\x35\xcb\x2b\x5a\x90\x5f\x6f\x6b\x3a\x9b\x10\x66\xda\xfb\x37\x24\x8f\xd4\x82\x5d\x0e\xf7\xbb\x7c\xab\xd3\xd1\xe7\x43\x89\x2c\xff\x3b\xee\x17\x8a\xf9\x5d\x3a\x72\x6a\xef\x56\xe1\x82\x75\xc6\xaf\xc6\x7a\x1f\x6b\xc5\xc5\xa2\xc3\xe4\x5f\x24\x6f\xe9\xcb\x8f\x35\xa3\x4d\x93\x55\xa5\x8c\xac\x63\xe1\xc0\x57\xcd\xcb\x8f\x75\xc5\x38\x55\x61\x38\xae\x67\x28\x65\xde\xa8\xbf\x96\xa4\xa0\xa3\xa7\x42\x07\x38\x05\x52\xd7\xb4\x4c\xc3\x07\xbb\x32\x96\x11\x11\x69\x7b\x1c\x9b\xf8\x94\x66\x1a\x46\xad\xb2\x65\x99\xe5\x41\x17\x60\x57\xf8\xd9\xea\x09\x93\x1d\x21\x2b\x79\xb5\x5f\x47\x98\x68\x08\xd6\x2d\x61\x04\xa1\xec\x06\xb1\xec\x06\x91\x70\x75\x4a\x38\xc1\x30\x3a\xbf\xc8\x4a\x4e\xd9\x8a\x2c\xe9\xa6\xdb\xd8\xf5\xcf\xae\x78\xc7\x3a\x41\x07\x02\x24\x5e\x01\xe2\xc0\x9b\xcb\xfe\xe0\x11\x2b\xfa\xf4\x34\xc9\x39\xed\xd4\x7b\x0e\x23\x19\xf8\xc2\x1e\x3a\xa2\xf0\x53\x0c\x37\xd1\xb4\x47\x45\xe6\x2a\x33\x8b\xe5\x51\xd0\x05\x66\x5d\x60\xe1\x83\x2b\xd2\xbc\xc8\x9a\x25\xcb\x8a\xac\x24\x9c\xa6\x77\x85\x0a\xd5\xe2\x3d\x5d\x72\x69\x3d\x02\x75\x95\xdf\x16\x15\xab\xaf\xb2\xe5\x18\x3e\x34\x9c\xb5\x4b\xde\x32\xfa\x45\x20\x04\x96\x44\x61\x27\xa7\x22\xa2\x5c\x55\xcb\x9f\x93\x86\x62\x59\x7c\x5e\xa5\xb7\x33\x48\xa4\xb1\x1e\x04\x26\x08\xeb\x8f\x6a\xd9\xc1\x18\x23\xc8\xd0\xa9\x18\x46\x4f\x2f\x2e\xfe\xfd\xb6\x5d\x88\x3f\x35\x3e\x58\x90\x86\xba\x4a\xfe\xd4\x36\xd3\x1a\x6e\x55\xf0\xf3\xf5\x43\x69\xf6\x00\x41\x76\x98\x3a\x79\xfc\x2c\xcf\x5f\xaf\xac\x16\xdb\xf7\x0a\xcb\x08\x9d\x55\xe2\xc7\xd9\xef\x56\xf7\xb1\x09\x43\x75\x5c\x9f\x91\x91\xdc\x41\xf0\x5e\x7f\x7d\xe8\xd5\xd4\x51\xa7\xb3\xfa\x99\x80\xa4\xc3\x94\x96\xcd\xec\x9f\x95\x12\xf6\x6d\x9e\x2d\xa9\x93\xdf\xd6\x5a\xbd\x4a\x9b\x23\x1c\xba\x07\x23\xc6\x5f\xb9\xa2\x18\x58\x5b\xf2\xac\xa0\x09\x26\xc2\xf7\x55\xd9\xb4\x05\xba\x27\x32\xee\x51\x4e\x38\x3a\xea\x3f\x65\x55\xf2\xf2\xf5\x0f\x53\x5e\xd1\x86\xb3\x5a\xc5\xf0\xf3\x00\xe8\x8c\xc1\xa8\xc7\x1d\x77\x71\x85\xaf\x02\xfe\xc9\x9c\xe0\x37\xb1\x4a\x78\x46\x9b\x36\xe7\xfe\x6e\xea\x24\xd3\xe1\xbb\x18\x0e\x6b\xc2\x68\xc9\xc5\x54\xe0\xc9\x2d\xf5\x18\xcd\x58\x56\xe5\x6d\x51\xb5\x8d\xe3\x76\x67\xc9\x38\x03\x27\x27\x90\x7e\x93\x3f\x31\x75\x66\x53\xbd\xd0\x6a\x3a\x15\xfb\x21\xa3\x79\xea\x20\x7a\x6b\xab\x96\x4b\x8e\x0c\x56\x67\x15\x0d\x0f\x6d\x93\xd8\x21\x64\x1f\x23\x0f\x3e\x15\x35\x73\x7a\x7c\x18\x5e\xa6\x82\x66\xff\xe3\xc7\xc5\x64\xeb\xf1\x76\xaa\x8d\xae\xcc\x56\x3b\xa4\xc5\x78\x32\x72\xf9\xd7\x84\x91\x8a\xb5\xf9\x23\x38\xab\xe4\xf0\x2c\xfa\xf1\x9a\xfe\x95\x51\xc8\xab\xea\x3a\x2b\x2f\x11\xd8\x24\xf0\x68\x3e\x88\xca\x8a\x89\x4c\x08\xff\xfe\xf4\x69\x0c\xb3\xac\xbc\x21\x79\x86\x83\x86\xbe\xa0\xeb\x70\x54\x69\xe9\x09\x7c\xf3\x61\x16\xef\x10\x37\x72\x2a\x8d\xcf\x00\xbe\xea\xa3\xcd\x71\x0f\x51\xa7\x02\xc7\x8d\xe6\xfb\xf6\xec\x44\xd8\x4c\xb8\xf0\x14\xc6\x05\x66\xcb\xc1\xbb\xed\xe5\x56\x6b\xc7\x7a\xd2\x08\xa4\x4c\x7d\x99\x6d\xbe\x72\xf3\xea\x6b\xb2\x7f\x4d\xf6\x87\x4f\x76\xa3\x69\x1f\x39\xba\x55\x5b\x29\x33\x7a\x76\x4f\xa8\x65\x3e\xc7\x87\x96\x23\x8d\x38\x12\x79\x58\x15\xc4\x87\x59\x44\x80\x4c\x61\x0e\x0f\x41\xb0\xef\xb9\xe6\xc8\x09\x54\x62\x1d\x3b\x50\x16\x07\xaa\x21\x8d\x06\x7d\x44\x99\xa9\x03\xe1\x80\x1e\x7c\x3d\x66\x31\x0f\xc1\x3c\x3d\x01\x46\x49\x0a\x8c\xac\x63\x60\xb4\xa8\x6e\x28\x94\xa4\xa0\x29\xd4\x7a\x49\x2c\xca\x0e\x49\x53\xe0\x15\x14\xa4\x46\x9b\x92\x35\x1e\xd1\x60\x1d\x29\xc8\x35\x0d\x0b\x52\x9f\x37\x9c\x65\xe5\xe5\xc5\x88\x45\x73\x44\x19\xf0\xbc\xc6\x2a\x36\x47\xd0\xeb\x1e\x39\x03\x8b\xd8\xaa\x91\x64\x28\x44\x3e\xea\x25\xd9\x8f\xc2\xdd\xca\x3d\xa4\x34\xa7\x9c\x86\xfd\x89\xb1\xc0\x6a\x2c\x2b\xf9\x0a\x66\xdf\x7c\x98\x81\x9d\x1e\x03\x80\xe7\xe1\x0e\x87\x0e\x50\x04\xa2\x96\x17\xbe\x83\xc7\x4a\x4e\x74\xef\x98\x86\x00\xaf\x69\x77\xd2\x84\xce\xbd\x91\x26\x26\xaf\x1d\xe6\x43\xfb\xef\xd3\xa8\x48\x5f\xcb\x98\xf4\xd3\x0d\x1a\x72\x4c\x1e\x9a\x33\xee\x9d\x41\xf4\x18\xf3\xfc\xfa\x02\x4e\xa5\x86\x0e\x91\xe6\xef\xb4\x7e\x6f\xf4\x46\xdb\x8e\xf5\xef\x40\xc7\xed\x60\x5d\x0c\x41\xb7\x9b\x73\xf9\x34\x92\x4e\x30\x60\xcc\x2e\x2c\x38\x70\x0c\x2a\x4d\x70\x20\xf8\x8a\x27\x31\x2c\x9e\xc6\xb0\xf8\x56\xb1\x36\xf2\x6b\xf4\x8d\x38\x2d\x38\xc0\x15\xf8\xf1\xd4\x25\xae\x76\x11\x39\xaf\xd9\x59\x55\xf6\x08\x41\x72\x1e\x51\x70\xe0\x8e\x60\x9b\xe0\xe0\xc0\xd8\x55\x5c\x13\x1c\x74\xc1\x01\x0a\xb4\xcf\x95\xf6\x7d\xcf\xca\xf4\x93\x2f\xdc\xab\xd2\xaa\x44\xf7\x87\x91\x9d\xf6\xf3\xb9\x48\x70\xe9\x62\x15\x0b\x98\xaa\xe2\x1d\x99\xa9\xd5\xa6\x10\xcb\xb7\x3e\xdf\x4e\xe9\xec\xbb\xce\x7e\x8d\xe3\x7f\xb1\xa2\xf5\x03\x2f\xbf\x1c\xf4\x76\x68\xd6\xe4\x32\xf9\xbe\x2a\x97\x84\x8b\x70\x32\x01\x11\xc5\x2a\xda\xfd\xdc\xa4\x40\x5a\x2e\x21\x09\x81\x64\xb6\x77\xc7\xde\xbe\xcc\xe5\xc3\x31\x94\x28\xb7\x8f\xf5\x92\xb8\xc3\x33\xdb\x83\xa2\xf1\x15\x7c\x77\x86\x76\x17\xbd\x6c\x36\xf3\x47\x46\xc1\x1c\xe1\x9e\x71\x3e\x64\x25\x82\x56\xa8\xf0\x98\x7e\xbf\xd4\xbe\x81\x47\x73\xab\x7c\x1d\x0b\x6c\x25\xc8\x83\x29\x79\x0c\xd1\xaa\x90\x18\x47\xaf\x48\xc3\xe9\x00\xb1\x34\x9d\x62\xea\x8e\xb7\x32\x7d\x83\x35\x87\x13\xf3\x89\x2a\xa7\x26\x65\x6b\x96\xdd\x48\x59\x56\x08\xc6\x34\x11\x6a\x9f\x39\x9c\x2d\xd5\x21\x23\x4c\xb5\xa5\x9f\xa1\xca\xbf\x63\x12\x9d\xcc\x2c\xc4\x68\xb1\x97\x6f\xe8\x87\x36\x63\x42\xd8\xb8\x2a\x32\x3c\x86\xdf\xea\x20\x9f\xfd\x3e\x14\x69\x8c\x91\x47\x42\x9a\xd3\xef\xd1\x1a\xfb\x1b\x63\x80\xbe\xee\x51\xfd\xdd\x13\xc2\xf1\x68\x64\xc0\x4a\xfa\x23\xd9\x52\x4a\x7d\x9a\x78\x11\xc4\x58\x78\xc7\xb8\x1a\xd3\x4b\xd0\xfe\x39\x88\xaa\x37\xd9\xb1\xd6\xdf\x33\x0b\x4d\xbe\x45\xde\xae\x90\x64\x3f\x1d\x5d\x2a\xe6\xe1\x5b\x9d\xf7\x09\x03\xdd\xce\xf7\x52\xa9\x17\x69\xbb\x36\x9d\x03\xbf\x45\x03\x78\x43\x49\xda\x17\xc7\x18\x8e\x06\x15\x64\xaf\x57\x08\xb0\xf5\x1d\xc0\x08\x91\x4c\xbd\x00\x54\xa3\xa4\x75\xbb\x7f\xdd\xc4\x58\xa9\x2a\x88\x6a\xe6\x2e\x8b\x8a\xb5\x71\xb3\xc1\xff\x70\x14\x32\x37\x62\x9a\xd8\xe3\xaa\xb1\xcd\x68\x08\xec\x3a\x9b\xf2\x36\xbb\x46\x14\x35\x23\xeb\x28\x86\x23\xcf\x75\x91\x49\x6c\xaf\xed\xa7\xb6\x08\x2d\xf7\x7c\x97\xe3\x07\xba\x9e\x93\x03\x4f\x0e\xbb\xe5\xdf\xb6\xa1\xa7\x91\x09\x14\xa0\x46\xcb\x41\xd7\xfa\x13\x99\xdb\xf3\x5b\x18\x2c\x44\xf5\x2f\x64\x79\x8d\xf5\xb8\x97\x7c\x36\xdb\xe5\x09\x3f\x53\x70\xf7\xe1\xe3\xcb\x0f\x19\x01\xc0\x3b\xcc\x50\x43\x16\x9c\x5f\xf4\x6b\x1e\x8b\x21\x3b\xa7\xa5\x01\x53\xd1\xb6\x17\x8b\xfb\xa0\xa8\xfd\x71\xd0\xc3\x61\xa0\xff\x69\xd3\x7f\x28\x04\x34\x86\x00\x3e\x98\xf6\x87\x46\x40\x43\xed\xa7\x09\xfe\xaf\x00\xe8\xff\x02\x00\xed\xc4\x2b\x7b\x61\x10\xf5\x33\xc4\xbd\x70\xcd\x48\x8c\x00\x44\xd0\xbe\x70\x2f\x12\xf5\xd5\x2e\x5c\x3d\x42\xfb\x37\xcb\x38\x15\xb5\x78\x08\xce\x74\x0b\xb5\xb7\xf9\x7a\x56\x4f\x09\x58\xeb\x54\x0f\x53\x85\x5c\xff\x88\x49\x7e\x8e\x7d\x02\x46\xbb\x80\x96\x0f\x24\xe8\xc7\x82\x00\x5b\x56\x45\x5d\x35\xc2\x63\x3d\x56\xf0\x34\xc4\xd8\x01\xa8\x46\xfd\x69\x46\xc4\xc7\x87\x8c\xd9\x90\x6d\xfa\xfa\xc0\x80\x1f\x22\x4d\x20\xa4\x3b\xab\xe2\x0b\x9e\x69\xe8\xf0\xc5\xb5\xdc\x0a\x3f\x86\x54\x91\x3c\x2f\x49\x92\x1d\x4c\x91\xcc\xd5\xc1\x6f\xd7\x86\x6d\xbf\x4f\x7c\x59\x15\x7e\x24\xba\xe7\x46\x96\xd1\x4d\xfe\x6f\xfb\x65\x5c\x62\x34\x30\x21\xfa\xab\xf8\x8d\xa4\xef\xa8\xd1\x8f\xf0\x3d\xfb\x2d\x79\xac\x5f\x34\x7e\x8e\x3c\xdb\x9a\x83\x73\x32\xf1\x2c\xf4\x9e\x6e\x32\x12\x4d\x1a\x5e\x72\x08\x0d\x02\x8b\xe0\x71\xa4\x2b\x6e\x6f\xeb\xc8\xaf\xcb\x88\xd9\x4b\x9c\x90\xc0\x3d\xc6\xd1\xff\x0d\x00\x00\xff\xff\x8f\x2c\x24\x17\xce\x30\x00\x00")
 
 func templatesTupleserializerGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -611,7 +611,7 @@ func templatesTupleserializerGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/tupleserializer.gotmpl", size: 11526, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
+	info := bindataFileInfo{name: "templates/tupleserializer.gotmpl", size: 12494, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -656,7 +656,7 @@ func templatesValidationPrimitiveGotmpl() (*asset, error) {
 	return a, nil
 }
 
-var _templatesValidationStructfieldGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x7c\x92\xb1\x4e\xc3\x30\x10\x86\xf7\x3c\xc5\xa9\x3b\x74\xaf\x10\x13\x0c\x48\xa0\x20\x10\xec\x56\x7d\x29\x27\x39\x97\xd4\xb5\x51\x2b\x2b\xef\x8e\x12\x3b\x89\x1d\xd9\x8c\xff\xfd\xf7\x7d\xb9\x5a\x75\x0e\x24\x36\xc4\x08\xbb\x5e\x77\x3d\x6a\x73\xfb\x16\x8a\xa4\x30\xd4\xf1\x53\x77\xfc\x34\x9a\xf8\xb4\x83\x61\xa8\x2a\xe7\xee\x80\x1a\xb8\xff\xc0\xb3\x25\x8d\x72\x1c\xee\xf7\x30\xc7\x03\x18\x6d\x71\xda\x42\x96\x1b\x42\xc8\x9a\xd5\x6d\x21\x84\x84\x31\xff\x83\xbc\x89\x2b\xb5\xb6\x0d\x44\x48\x07\x70\x6e\x6a\x9f\xaf\x47\x65\x2f\xf4\x8b\xeb\xda\xc3\xd8\x79\x8b\x73\x09\x9f\xd5\x13\xc7\x7a\x9f\x32\xfa\x65\xed\x71\xa3\x5f\xf9\xac\xde\x2a\x43\xbd\xc2\xba\x99\xbf\x10\x06\x50\x37\xd3\x57\x36\x1b\x85\x17\x78\x45\x3e\x99\x9f\xf5\x0d\xc0\x0f\x82\x21\xee\x0b\xbf\x31\x15\x10\xa7\x82\xb8\xcf\x09\xde\x85\x31\xa8\x39\xe0\x21\x79\x36\xaa\x0a\xb7\xbf\x18\x6c\x2f\xd1\xe9\x53\x5e\x2e\x5f\xda\xc2\xe1\x09\x4d\x9c\xd0\x51\x9b\xa3\xbf\x98\xce\x16\x63\x81\x9f\x14\xfe\x6c\xc8\x72\x18\xaa\xbf\x00\x00\x00\xff\xff\xac\xce\xff\x27\x08\x03\x00\x00")
+var _templatesValidationStructfieldGotmpl = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x7c\x92\x41\x6b\xfb\x30\x0c\xc5\xef\xf9\x14\x22\xf0\x3f\xfe\xd7\x7b\x19\xbb\x6c\x1d\x14\x36\x32\x56\xb6\xbb\xa9\x95\x4c\x90\x28\xa9\x63\x77\x2d\x26\xdf\x7d\xc4\x76\x13\x27\x24\xbd\xf9\xe9\xe9\xf7\x24\x1b\x5b\x0b\x12\x73\x62\x84\xb4\x51\x75\x83\x4a\x5f\xbf\x45\x49\x52\x68\xaa\xf9\xa5\x3e\x1e\xb4\x22\x2e\x52\xe8\xba\x24\xb1\xf6\x3f\x50\x0e\x0f\x9f\x78\x32\xa4\x50\xf6\xc5\xcd\x06\x6e\x72\x0b\x5a\x19\x74\x5d\xc8\x72\x46\x08\x99\x71\x79\x1d\x08\x21\xa1\xd7\x77\x90\x77\x71\xa1\xca\x54\x81\x08\x6a\x0b\xd6\x3a\x77\x77\x39\x96\xa6\xa5\x33\x8e\x6d\x8f\xbd\xe7\x53\xac\x9d\xf0\x8b\xf1\xc4\x71\xbc\x57\x0b\xf1\x43\xdb\xd3\x2c\x7e\xe4\x17\xe3\x4d\xa9\xa9\x29\x31\xcb\x6f\x13\x42\x01\xb2\xdc\x4d\x99\x75\xac\xbc\xc0\x1b\x72\xa1\x7f\xc6\x37\x00\x5f\x08\x09\xb1\xbf\x72\xc7\x69\x00\xf1\x34\x20\xf6\x97\x02\x3e\x84\xd6\xa8\x38\xe0\x41\x79\x36\xb2\x56\x76\xdf\x6b\xac\xda\x68\x75\xa7\x87\xcd\x07\x77\x65\xf1\x09\x4d\x3c\xa1\x23\x77\x89\xfe\x62\x3a\x19\x8c\x03\x7c\xe5\xce\x67\xdb\xb7\xcf\xa6\xd5\x75\xf5\x5a\xab\xca\x5d\x2c\x80\x5e\xfb\xb1\x87\x5f\x51\x14\xa8\x7c\x69\x6d\xf6\x8e\x87\x3f\xd5\x1f\x1d\xd9\x28\x62\x9d\x43\xfa\xef\x9c\x8e\x0d\x11\x1c\x8e\x5d\x97\xfc\x05\x00\x00\xff\xff\xa2\xaa\xcd\x0b\x8d\x03\x00\x00")
 
 func templatesValidationStructfieldGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -671,7 +671,7 @@ func templatesValidationStructfieldGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/validation/structfield.gotmpl", size: 776, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
+	info := bindataFileInfo{name: "templates/validation/structfield.gotmpl", size: 909, mode: os.FileMode(420), modTime: time.Unix(1482416923, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
diff --git a/generator/model.go b/generator/model.go
index 3f3ec729..3445711e 100644
--- a/generator/model.go
+++ b/generator/model.go
@@ -134,11 +134,77 @@ func (m *definitionGenerator) generateModel(g *GenDefinition) error {
 }
 
 func makeGenDefinition(name, pkg string, schema spec.Schema, specDoc *loads.Document, opts *GenOpts) (*GenDefinition, error) {
-	return makeGenDefinitionHierarchy(name, pkg, "", schema, specDoc, opts)
+	gd, err := makeGenDefinitionHierarchy(name, pkg, "", schema, specDoc, opts)
+
+	if err == nil && gd != nil {
+		// before yielding the schema to the renderer, we check if the top-level Validate method gets some content
+		// this means that the immediate content of the top level definitions has at least one validation.
+		//
+		// If none is found at this level and that no special case where no Validate() method is exposed at all
+		// (e.g. io.ReadCloser and interface{} types and their aliases), then there is an empty Validate() method which
+		// just return nil (the object abides by the runtime.Validatable interface, but knows it has nothing to validate).
+		//
+		// We do this at the top level because of the possibility of aliased types which always bubble up validation to types which
+		// are referring to them. This results in correct but inelegant code with empty validations.
+		gd.GenSchema.HasValidations = shallowValidationLookup(gd.GenSchema)
+	}
+	return gd, err
 }
 
-func makeGenDefinitionHierarchy(name, pkg, container string, schema spec.Schema, specDoc *loads.Document, opts *GenOpts) (*GenDefinition, error) {
+func shallowValidationLookup(sch GenSchema) bool {
+	// scan top level need for validations
+	//
+	// NOTE: this supersedes the previous NeedsValidation flag
+	// With the introduction of this shallow lookup, it is no more necessary
+	// to establish a distinction between HasValidations (e.g. carries on validations)
+	// and NeedsValidation (e.g. should have a Validate method with something in it).
+	// The latter was almost not used anyhow.
+
+	if sch.IsArray && sch.HasValidations {
+		return true
+	}
+	if sch.IsStream || sch.IsInterface { // these types have no validation - aliased types on those do not implement the Validatable interface
+		return false
+	}
+	if sch.Required || sch.IsCustomFormatter && !sch.IsStream {
+		return true
+	}
+	if sch.MaxLength != nil || sch.MinLength != nil || sch.Pattern != "" || sch.MultipleOf != nil || sch.Minimum != nil || sch.Maximum != nil || len(sch.Enum) > 0 || len(sch.ItemsEnum) > 0 {
+		return true
+	}
+	for _, a := range sch.AllOf {
+		if a.HasValidations {
+			return true
+		}
+	}
+	for _, p := range sch.Properties {
+		// Using a base type within another structure triggers validation of the base type.
+		// The discriminator property in the base type definition itself does not.
+		if (p.HasValidations || p.Required) && !(sch.IsBaseType && p.Name == sch.DiscriminatorField) || (p.IsAliased || p.IsComplexObject) && !(p.IsInterface || p.IsStream) {
+			return true
+		}
+	}
+	if sch.IsTuple && (sch.AdditionalItems != nil && (sch.AdditionalItems.HasValidations || sch.AdditionalItems.Required)) {
+		return true
+	}
+	if sch.HasAdditionalProperties && (sch.AdditionalProperties.IsInterface || sch.AdditionalProperties.IsStream) {
+		return false
+	}
 
+	if sch.HasAdditionalProperties && (sch.AdditionalProperties.HasValidations || sch.AdditionalProperties.Required || sch.AdditionalProperties.IsAliased && !(sch.AdditionalProperties.IsInterface || sch.AdditionalProperties.IsStream)) {
+		return true
+	}
+
+	if sch.IsAliased && (sch.IsPrimitive && sch.HasValidations) { // non primitive aliased have either other attributes with validation (above) or shall not validate
+		return true
+	}
+	if sch.HasBaseType || sch.IsSubType {
+		return true
+	}
+	return false
+}
+
+func makeGenDefinitionHierarchy(name, pkg, container string, schema spec.Schema, specDoc *loads.Document, opts *GenOpts) (*GenDefinition, error) {
 	_, ok := schema.Extensions[xGoType]
 	if ok {
 		return nil, nil
@@ -265,6 +331,8 @@ func makeGenDefinitionHierarchy(name, pkg, container string, schema spec.Schema,
 		"github.com/go-openapi/swag",
 		"github.com/go-openapi/validate",
 	}
+
+	// ExtraSchemas are inlined types rendered in the same model file
 	var extras []GenSchema
 	var extraKeys []string
 	for k := range pg.ExtraSchemas {
@@ -272,7 +340,10 @@ func makeGenDefinitionHierarchy(name, pkg, container string, schema spec.Schema,
 	}
 	sort.Strings(extraKeys)
 	for _, k := range extraKeys {
-		extras = append(extras, pg.ExtraSchemas[k])
+		// figure out if top level validations are needed
+		p := pg.ExtraSchemas[k]
+		p.HasValidations = shallowValidationLookup(p)
+		extras = append(extras, p)
 	}
 
 	return &GenDefinition{
@@ -382,11 +453,14 @@ func (sg *schemaGenContext) NewSliceBranch(schema *spec.Schema) *schemaGenContex
 		pg.Path = pg.Path + "+ \".\" + strconv.Itoa(" + indexVar + ")"
 	}
 	// check who is parent, if it's a base type then rewrite the value expression
-	var rewriteValueExpr bool
 	if sg.Discrimination != nil && sg.Discrimination.Discriminators != nil {
-		_, rewriteValueExpr = sg.Discrimination.Discriminators["#/definitions/"+sg.TypeResolver.ModelName]
+		_, rewriteValueExpr := sg.Discrimination.Discriminators["#/definitions/"+sg.TypeResolver.ModelName]
 		if (pg.IndexVar == "i" && rewriteValueExpr) || sg.GenSchema.ElemType.IsBaseType {
-			pg.ValueExpr = sg.Receiver + "." + swag.ToJSONName(sg.GenSchema.Name) + "Field"
+			if !sg.GenSchema.IsAliased {
+				pg.ValueExpr = sg.Receiver + "." + swag.ToJSONName(sg.GenSchema.Name) + "Field"
+			} else {
+				pg.ValueExpr = sg.Receiver
+			}
 		}
 	}
 	sg.GenSchema.IsBaseType = sg.GenSchema.ElemType.HasDiscriminator
@@ -447,9 +521,11 @@ func (sg *schemaGenContext) NewTupleElement(schema *spec.Schema, index int) *sch
 		pg.Path = pg.Path + "+ \".\"+\"" + strconv.Itoa(index) + "\""
 	}
 	pg.ValueExpr = pg.ValueExpr + ".P" + strconv.Itoa(index)
+
 	pg.Required = true
 	pg.IsTuple = true
 	pg.Schema = *schema
+
 	return pg
 }
 
@@ -530,17 +606,34 @@ func (sg *schemaGenContext) NewAdditionalProperty(schema spec.Schema) *schemaGen
 	if sg.Path != "" {
 		pg.Path = sg.Path + "+\".\"+" + pg.KeyVar
 	}
+	// propagates the special IsNullable override for maps of slices and
+	// maps of aliased types.
+	pg.GenSchema.IsMapNullOverride = sg.GenSchema.IsMapNullOverride
 	return pg
 }
 
-func hasValidations(model *spec.Schema, isRequired bool) (needsValidation bool, hasValidation bool) {
+func hasValidations(model *spec.Schema, isRequired bool) (hasValidation bool) {
+	// NOTE: needsValidation has gone deprecated and is replaced by top-level's shallowValidationLookup()
 	hasNumberValidation := model.Maximum != nil || model.Minimum != nil || model.MultipleOf != nil
 	hasStringValidation := model.MaxLength != nil || model.MinLength != nil || model.Pattern != ""
 	hasSliceValidations := model.MaxItems != nil || model.MinItems != nil || model.UniqueItems
+	hasEnum := len(model.Enum) > 0
+
+	// since this was added to deal with discriminator, we'll fix this when testing discriminated types
 	simpleObject := len(model.Properties) > 0 && model.Discriminator == ""
 
-	needsValidation = hasNumberValidation || hasStringValidation || hasSliceValidations || len(model.Enum) > 0
-	hasValidation = isRequired || needsValidation || simpleObject
+	// lift validations from allOf branches
+	hasAllOfValidation := false
+	for _, s := range model.AllOf {
+		hasAllOfValidation = hasValidations(&s, false)
+		hasAllOfValidation = s.Ref.String() != "" || hasAllOfValidation
+		if hasAllOfValidation {
+			break
+		}
+	}
+
+	hasValidation = hasNumberValidation || hasStringValidation || hasSliceValidations || hasEnum || simpleObject || hasAllOfValidation || isRequired
+
 	return
 }
 
@@ -562,10 +655,11 @@ func (sg *schemaGenContext) schemaValidations() sharedValidations {
 
 	isRequired := sg.Required
 	if model.Default != nil || model.ReadOnly {
+		// when readOnly or default is specified, this disables Required (Swagger-specific)
 		isRequired = false
 	}
 	hasSliceValidations := model.MaxItems != nil || model.MinItems != nil || model.UniqueItems
-	needsValidation, hasValidation := hasValidations(&model, isRequired)
+	hasValidation := hasValidations(&model, isRequired)
 
 	return sharedValidations{
 		Required:            sg.Required,
@@ -583,42 +677,51 @@ func (sg *schemaGenContext) schemaValidations() sharedValidations {
 		Enum:                model.Enum,
 		HasValidations:      hasValidation,
 		HasSliceValidations: hasSliceValidations,
-		NeedsValidation:     needsValidation,
-		NeedsRequired:       isRequired,
 	}
 }
-func (sg *schemaGenContext) MergeResult(other *schemaGenContext, liftsRequired bool) {
+
+func mergeValidation(other *schemaGenContext) bool {
+	// NOTE: NeesRequired and NeedsValidation are deprecated
 	if other.GenSchema.AdditionalProperties != nil && other.GenSchema.AdditionalProperties.HasValidations {
-		sg.GenSchema.HasValidations = true
+		return true
 	}
-	if other.GenSchema.AdditionalProperties != nil && other.GenSchema.AdditionalProperties.NeedsValidation {
-		sg.GenSchema.NeedsValidation = true
+	if other.GenSchema.AdditionalItems != nil && other.GenSchema.AdditionalItems.HasValidations {
+		return true
 	}
-	if liftsRequired && other.GenSchema.AdditionalProperties != nil && other.GenSchema.AdditionalProperties.NeedsRequired {
-		sg.GenSchema.NeedsRequired = true
-	}
-	if liftsRequired && other.GenSchema.AdditionalProperties != nil && other.GenSchema.AdditionalProperties.Required {
-		sg.GenSchema.Required = true
+	for _, sch := range other.GenSchema.AllOf {
+		if sch.HasValidations {
+			return true
+		}
 	}
 	if other.GenSchema.HasValidations {
-		sg.GenSchema.HasValidations = other.GenSchema.HasValidations
-	}
-	if other.GenSchema.NeedsValidation {
-		sg.GenSchema.NeedsValidation = other.GenSchema.NeedsValidation
+		return true
 	}
-	if liftsRequired && other.GenSchema.NeedsRequired {
-		sg.GenSchema.NeedsRequired = other.GenSchema.NeedsRequired
+	return false
+}
+
+func (sg *schemaGenContext) MergeResult(other *schemaGenContext, liftsRequired bool) {
+	sg.GenSchema.HasValidations = sg.GenSchema.HasValidations || mergeValidation(other)
+
+	if liftsRequired && other.GenSchema.AdditionalProperties != nil && other.GenSchema.AdditionalProperties.Required {
+		sg.GenSchema.Required = true
 	}
 	if liftsRequired && other.GenSchema.Required {
 		sg.GenSchema.Required = other.GenSchema.Required
 	}
+
 	if other.GenSchema.HasBaseType {
 		sg.GenSchema.HasBaseType = other.GenSchema.HasBaseType
 	}
+
 	sg.Dependencies = append(sg.Dependencies, other.Dependencies...)
+
+	// lift extra schemas
 	for k, v := range other.ExtraSchemas {
 		sg.ExtraSchemas[k] = v
 	}
+	if other.GenSchema.IsMapNullOverride {
+		sg.GenSchema.IsMapNullOverride = true
+	}
 }
 
 func (sg *schemaGenContext) buildProperties() error {
@@ -645,8 +748,8 @@ func (sg *schemaGenContext) buildProperties() error {
 
 		vv := v
 		var hasValidation bool
-		var needsValidation bool
 		if tpe.IsComplexObject && tpe.IsAnonymous && len(v.Properties) > 0 {
+			// this is an anonymous complex construct: build a new new type for it
 			pg := sg.makeNewStruct(sg.Name+swag.ToGoName(k), v)
 			pg.IsTuple = sg.IsTuple
 			if sg.Path != "" {
@@ -665,29 +768,32 @@ func (sg *schemaGenContext) buildProperties() error {
 
 			vv = *spec.RefProperty("#/definitions/" + pg.Name)
 			hasValidation = pg.GenSchema.HasValidations
-			needsValidation = pg.GenSchema.NeedsValidation
-			sg.MergeResult(pg, false)
 			sg.ExtraSchemas[pg.Name] = pg.GenSchema
+			// NOTE: MergeResult lifts validation status and extra schemas
+			sg.MergeResult(pg, false)
 		}
 
 		emprop := sg.NewStructBranch(k, vv)
 		emprop.IsTuple = sg.IsTuple
+
 		if err := emprop.makeGenSchema(); err != nil {
 			return err
 		}
 
-		if hasValidation || emprop.GenSchema.HasValidations {
+		// whatever the validations says, if we have an interface{}, do not validate
+		// NOTE: this may be the case when the type is left empty and we get a Enum validation.
+		if emprop.GenSchema.IsInterface || emprop.GenSchema.IsStream {
+			emprop.GenSchema.HasValidations = false
+		} else if hasValidation || emprop.GenSchema.HasValidations || emprop.GenSchema.Required || len(emprop.GenSchema.AllOf) > 0 {
 			emprop.GenSchema.HasValidations = true
 			sg.GenSchema.HasValidations = true
 		}
-		if needsValidation || emprop.GenSchema.NeedsValidation {
-			emprop.GenSchema.NeedsValidation = true
-			sg.GenSchema.NeedsValidation = true
-		}
-		// generates format validation on property, even when not Required
+
+		// generates format validation on property
 		emprop.GenSchema.HasValidations = emprop.GenSchema.HasValidations || (tpe.IsCustomFormatter && !tpe.IsStream) || (tpe.IsArray && tpe.ElemType.IsCustomFormatter && !tpe.ElemType.IsStream)
 
 		if emprop.Schema.Ref.String() != "" {
+			// expand the schema of this property, so we take informed decisions about its type
 			ref := emprop.Schema.Ref
 			var sch *spec.Schema
 			for ref.String() != "" {
@@ -706,6 +812,7 @@ func (sg *schemaGenContext) buildProperties() error {
 				ref = spec.Ref{}
 				sch = rsch
 			}
+
 			if emprop.Discrimination != nil {
 				if _, ok := emprop.Discrimination.Discriminators[emprop.Schema.Ref.String()]; ok {
 					emprop.GenSchema.IsBaseType = true
@@ -716,16 +823,12 @@ func (sg *schemaGenContext) buildProperties() error {
 					emprop.GenSchema.IsSubType = true
 				}
 			}
+
+			// set property name
 			var nm = filepath.Base(emprop.Schema.Ref.GetURL().Fragment)
-			var tn string
-			if gn, ok := emprop.Schema.Extensions[xGoName]; ok {
-				tn = gn.(string)
-			} else {
-				tn = swag.ToGoName(nm)
-			}
 
 			tr := newTypeResolver(sg.TypeResolver.ModelsPackage, sg.TypeResolver.Doc)
-			tr.ModelName = tn
+			tr.ModelName = goName(&emprop.Schema, swag.ToGoName(nm))
 			ttpe, err := tr.ResolveSchema(sch, false, true)
 			if err != nil {
 				return err
@@ -733,21 +836,47 @@ func (sg *schemaGenContext) buildProperties() error {
 			if ttpe.IsAliased {
 				emprop.GenSchema.IsAliased = true
 			}
-			nv, hv := hasValidations(sch, false)
+
+			// lift validations
+			hv := hasValidations(sch, false)
+
 			// include format validation, excluding binary
 			hv = hv || (ttpe.IsCustomFormatter && !ttpe.IsStream) || (ttpe.IsArray && ttpe.ElemType.IsCustomFormatter && !ttpe.ElemType.IsStream)
-			if hv {
+
+			// a base type property is always validated against the base type
+			// exception: for the base type definition itself (see shallowValidationLookup())
+			if (hv || emprop.GenSchema.IsBaseType) && !(emprop.GenSchema.IsInterface || emprop.GenSchema.IsStream) {
 				emprop.GenSchema.HasValidations = true
 			}
-			if nv {
-				emprop.GenSchema.NeedsValidation = true
-			}
 			if ttpe.HasAdditionalItems && sch.AdditionalItems.Schema != nil {
 				// when AdditionalItems specifies a Schema, there is a validation
-				emprop.GenSchema.HasValidations = true
+				// check if we stepped upon an exeption
+				child, err := tr.ResolveSchema(sch.AdditionalItems.Schema, false, true)
+				if err != nil {
+					return err
+				}
+				if !child.IsInterface && !child.IsStream {
+					emprop.GenSchema.HasValidations = true
+				}
+			}
+			if ttpe.IsMap && sch.AdditionalProperties != nil && sch.AdditionalProperties.Schema != nil {
+				// when AdditionalProperties specifies a Schema, there is a validation
+				// check if we stepped upon an exeption
+				child, err := tr.ResolveSchema(sch.AdditionalProperties.Schema, false, true)
+				if err != nil {
+					return err
+				}
+				if !child.IsInterface && !child.IsStream {
+					emprop.GenSchema.HasValidations = true
+				}
 			}
 		}
+
 		if sg.Schema.Discriminator == k {
+			// this is the discriminator property:
+			// it is required, but forced as non-nullable,
+			// since we never fill it with a zero-value
+			// TODO: when no other property than discriminator, there is no validation
 			emprop.GenSchema.IsNullable = false
 		}
 		if emprop.GenSchema.IsBaseType {
@@ -755,24 +884,32 @@ func (sg *schemaGenContext) buildProperties() error {
 		}
 		sg.MergeResult(emprop, false)
 
-		if customTag, found := emprop.Schema.Extensions[xGoCustomTag]; found {
-			emprop.GenSchema.CustomTag = customTag.(string)
-		}
+		// when discriminated, data is accessed via a getter func
 		if emprop.GenSchema.HasDiscriminator {
 			emprop.GenSchema.ValueExpression += "()"
 		}
+
+		// set custom serializer tag
+		if customTag, found := emprop.Schema.Extensions[xGoCustomTag]; found {
+			emprop.GenSchema.CustomTag = customTag.(string)
+		}
 		sg.GenSchema.Properties = append(sg.GenSchema.Properties, emprop.GenSchema)
 	}
 	sort.Sort(sg.GenSchema.Properties)
+
 	return nil
 }
 
 func (sg *schemaGenContext) buildAllOf() error {
-	if len(sg.Schema.AllOf) > 0 {
-		sort.Sort(sg.GenSchema.AllOf)
-		if sg.Container == "" {
-			sg.Container = sg.Name
-		}
+	if len(sg.Schema.AllOf) == 0 {
+		return nil
+	}
+
+	var hasArray, hasNonArray int
+
+	sort.Sort(sg.GenSchema.AllOf)
+	if sg.Container == "" {
+		sg.Container = sg.Name
 	}
 	if Debug {
 		log.Printf("building all of for %d entries", len(sg.Schema.AllOf))
@@ -780,20 +917,95 @@ func (sg *schemaGenContext) buildAllOf() error {
 		log.Println(string(b))
 	}
 	for i, sch := range sg.Schema.AllOf {
+		tpe, err := sg.TypeResolver.ResolveSchema(&sch, sch.Ref.String() == "", false)
+		if err != nil {
+			return err
+		}
+
+		// check for multiple arrays in allOf branches.
+		// Although a valid JSON-Schema construct, it is not suited for serialization.
+		// This is the same if we attempt to serialize an array with another object.
+		// We issue a generation warning on this.
+		if tpe.IsArray {
+			hasArray++
+		} else {
+			hasNonArray++
+		}
 		if Debug {
 			b, _ := json.MarshalIndent(sch, "", "  ")
 			log.Println("trying", string(b))
 		}
+		if (tpe.IsAnonymous && len(sch.AllOf) > 0) || (sch.Ref.String() == "" && !tpe.IsComplexObject && (tpe.IsArray || tpe.IsInterface || tpe.IsPrimitive)) {
+			// cases where anonymous structures cause the creation of a new type:
+			// - nested allOf: this one is itself a AllOf: build a new type for it
+			// - anonymous simple types for edge cases: array, primitive, interface{}
+			// NOTE: when branches are aliased or anonymous, the nullable property in the branch type is lost.
+			name := swag.ToVarName(goName(&sch, sg.Name+"AllOf"+strconv.Itoa(i)))
+			if Debug {
+				log.Printf("building anonymous nested allOf in %s: %s", sg.Name, name)
+			}
+			ng := sg.makeNewStruct(name, sch)
+			if err := ng.makeGenSchema(); err != nil {
+				return err
+			}
+
+			newsch := spec.RefProperty("#/definitions/" + ng.Name)
+			sg.Schema.AllOf[i] = *newsch
+
+			pg := sg.NewCompositionBranch(*newsch, i)
+			if err := pg.makeGenSchema(); err != nil {
+				return err
+			}
+
+			// lift extra schemas & validations from new type
+			pg.MergeResult(ng, true)
+
+			// lift validations when complex or ref'ed:
+			// - parent always calls its Validatable child
+			// - child may or may not have validations
+			//
+			// Exception: child is not Validatable when interface or stream
+			if !pg.GenSchema.IsInterface && !pg.GenSchema.IsStream {
+				sg.GenSchema.HasValidations = true
+			}
+
+			// add the newly created type to the list of schemas to be rendered inline
+			pg.ExtraSchemas[ng.Name] = ng.GenSchema
+
+			sg.MergeResult(pg, true)
+
+			sg.GenSchema.AllOf = append(sg.GenSchema.AllOf, pg.GenSchema)
+
+			continue
+		}
+
 		comprop := sg.NewCompositionBranch(sch, i)
 		if err := comprop.makeGenSchema(); err != nil {
 			return err
 		}
+		if comprop.GenSchema.IsMap && comprop.GenSchema.HasAdditionalProperties && comprop.GenSchema.AdditionalProperties != nil && !comprop.GenSchema.IsInterface {
+			// the anonymous branch is a map for AdditionalProperties: rewrite value expression
+			comprop.GenSchema.ValueExpression = comprop.GenSchema.ValueExpression + "." + comprop.Name
+			comprop.GenSchema.AdditionalProperties.ValueExpression = comprop.GenSchema.ValueExpression + "[" + comprop.GenSchema.AdditionalProperties.KeyVar + "]"
+		}
+
+		// lift validations when complex or ref'ed
+		if (comprop.GenSchema.IsComplexObject || comprop.Schema.Ref.String() != "") && !(comprop.GenSchema.IsInterface || comprop.GenSchema.IsStream) {
+			comprop.GenSchema.HasValidations = true
+		}
 		sg.MergeResult(comprop, true)
 		sg.GenSchema.AllOf = append(sg.GenSchema.AllOf, comprop.GenSchema)
 	}
-	if len(sg.Schema.AllOf) > 0 {
-		sg.GenSchema.IsNullable = true
+
+	if hasArray > 1 || (hasArray > 0 && hasNonArray > 0) {
+		log.Printf("warning: cannot generate serializable allOf with conflicting array definitions in %s", sg.Container)
 	}
+
+	sg.GenSchema.IsNullable = true
+
+	// prevent IsAliased to bubble up (e.g. when a single branch is itself aliased)
+	sg.GenSchema.IsAliased = sg.GenSchema.IsAliased && len(sg.GenSchema.AllOf) < 2
+
 	return nil
 }
 
@@ -818,16 +1030,23 @@ func newMapStack(context *schemaGenContext) (first, last *mapStack, err error) {
 		if err != nil {
 			return nil, nil, err
 		}
+
 		if !tpe.IsMap {
+			//reached the end of the rabbit hole
 			if tpe.IsComplexObject && tpe.IsAnonymous {
+				// found an anonymous object: create the struct from a newly created definition
 				nw := l.Context.makeNewStruct(l.Context.Name+" Anon", *l.Type.AdditionalProperties.Schema)
 				sch := spec.RefProperty("#/definitions/" + nw.Name)
 				l.NewObj = nw
+
 				l.Type.AdditionalProperties.Schema = sch
 				l.ValueRef = l.Context.NewAdditionalProperty(*sch)
 			}
+			// other cases where to stop are: a $ref or a simple object
 			break
 		}
+
+		// continue digging for maps
 		l.Next = &mapStack{
 			Previous: l,
 			Type:     l.Type.AdditionalProperties.Schema,
@@ -836,14 +1055,17 @@ func newMapStack(context *schemaGenContext) (first, last *mapStack, err error) {
 		l = l.Next
 	}
 
+	//return top and bottom entries of this stack of AdditionalProperties
 	return ms, l, nil
 }
 
+// Build rewinds the stack of additional properties, building schemas from bottom to top
 func (mt *mapStack) Build() error {
 	if mt.NewObj == nil && mt.ValueRef == nil && mt.Next == nil && mt.Previous == nil {
 		csch := mt.Type.AdditionalProperties.Schema
 		cp := mt.Context.NewAdditionalProperty(*csch)
 		d := mt.Context.TypeResolver.Doc
+
 		asch, err := analysis.Schema(analysis.SchemaOpts{
 			Root:     d.Spec(),
 			BasePath: d.SpecFilePath(),
@@ -853,19 +1075,43 @@ func (mt *mapStack) Build() error {
 			return err
 		}
 		cp.Required = !asch.IsSimpleSchema && !asch.IsMap
+
+		// when the schema is an array or an alias, this may result in inconsistent
+		// nullable status between the map element and the array element (resp. the aliased type).
+		//
+		// Example: when an object has no property and only additionalProperties,
+		// which turn out to be arrays of some other object.
+
+		// save the initial override
+		hadOverride := cp.GenSchema.IsMapNullOverride
 		if err := cp.makeGenSchema(); err != nil {
 			return err
 		}
+
+		// if we have an override at the top of stack, propagates it down nested arrays
+		if hadOverride && cp.GenSchema.IsArray {
+			// do it for nested arrays: override is also about map[string][][]... constructs
+			it := &cp.GenSchema
+			for it.Items != nil && it.IsArray {
+				it.Items.IsMapNullOverride = hadOverride
+				it = it.Items
+			}
+		}
+		// cover other cases than arrays (aliased types)
+		cp.GenSchema.IsMapNullOverride = hadOverride
+
 		mt.Context.MergeResult(cp, false)
 		mt.Context.GenSchema.AdditionalProperties = &cp.GenSchema
+
 		if Debug {
-			log.Println("early mapstack exit, nullable:", cp.GenSchema.IsNullable)
+			log.Printf("early mapstack exit, nullable: %t for %s", cp.GenSchema.IsNullable, cp.GenSchema.Name)
 		}
 		return nil
 	}
 	cur := mt
 	for cur != nil {
 		if cur.NewObj != nil {
+			// a new model has been created during the stack construction (new ref on anonymous object)
 			if err := cur.NewObj.makeGenSchema(); err != nil {
 				return err
 			}
@@ -878,33 +1124,55 @@ func (mt *mapStack) Build() error {
 		}
 
 		if cur.NewObj != nil {
+			// newly created model from anonymous object is declared as extra schema
 			cur.Context.MergeResult(cur.NewObj, false)
+
+			// propagates extra schemas
 			cur.Context.ExtraSchemas[cur.NewObj.Name] = cur.NewObj.GenSchema
 		}
 
 		if cur.ValueRef != nil {
+			// this is the genSchema for this new anonymous AdditionalProperty
 			if err := cur.Context.makeGenSchema(); err != nil {
 				return err
 			}
+
+			// if there is a ValueRef, we must have a NewObj (from newMapStack() construction)
 			cur.ValueRef.GenSchema.HasValidations = cur.NewObj.GenSchema.HasValidations
-			cur.ValueRef.GenSchema.NeedsValidation = cur.NewObj.GenSchema.NeedsValidation
 			cur.Context.MergeResult(cur.ValueRef, false)
 			cur.Context.GenSchema.AdditionalProperties = &cur.ValueRef.GenSchema
 		}
 
 		if cur.Previous != nil {
+			// we have a parent schema: build a schema for current AdditionalProperties
 			if err := cur.Context.makeGenSchema(); err != nil {
 				return err
 			}
 		}
 		if cur.Next != nil {
+			// we previously made a child schema: lifts things from that one
+			// - Required is not lifted (in a cascade of maps, only the last element is actually checked for Required)
 			cur.Context.MergeResult(cur.Next.Context, false)
 			cur.Context.GenSchema.AdditionalProperties = &cur.Next.Context.GenSchema
+
+			// lift validations
+			c := &cur.Next.Context.GenSchema
+			if (cur.Next.Context.Schema.Ref.String() != "" || c.IsAliased) && !(c.IsInterface || c.IsStream) {
+				// - we stopped on a ref, or anything else that require we call its Validate()
+				// - if the alias / ref is on an interface (or stream) type: no validation
+				cur.Context.GenSchema.HasValidations = true
+				cur.Context.GenSchema.AdditionalProperties.HasValidations = true
+			}
 		}
 		if cur.ValueRef != nil {
 			cur.Context.MergeResult(cur.ValueRef, false)
 			cur.Context.GenSchema.AdditionalProperties = &cur.ValueRef.GenSchema
 		}
+
+		if cur.Context.GenSchema.AdditionalProperties != nil {
+			// propagate overrides up the resolved schemas, but leave any ExtraSchema untouched
+			cur.Context.GenSchema.AdditionalProperties.IsMapNullOverride = cur.Context.GenSchema.IsMapNullOverride
+		}
 		cur = cur.Previous
 	}
 
@@ -935,11 +1203,13 @@ func (sg *schemaGenContext) buildAdditionalProperties() error {
 		return nil
 	}
 	addp := *sg.Schema.AdditionalProperties
+
 	wantsAdditional := addp.Schema != nil || addp.Allows
 	sg.GenSchema.HasAdditionalProperties = wantsAdditional
 	if !wantsAdditional {
 		return nil
 	}
+
 	// flag swap
 	if sg.GenSchema.IsComplexObject {
 		sg.GenSchema.IsAdditionalProperties = true
@@ -948,8 +1218,11 @@ func (sg *schemaGenContext) buildAdditionalProperties() error {
 	}
 
 	if addp.Schema == nil {
-		if addp.Allows { // map with interface{} value
+		// this is for AdditionalProperties:true|false
+		if addp.Allows {
+			// additionalProperties: true is rendered as: map[string]interface{}
 			addp.Schema = &spec.Schema{}
+
 			addp.Schema.Typed("object", "")
 			sg.GenSchema.HasAdditionalProperties = true
 			sg.GenSchema.IsComplexObject = false
@@ -972,6 +1245,7 @@ func (sg *schemaGenContext) buildAdditionalProperties() error {
 	}
 
 	if !sg.GenSchema.IsMap && (sg.GenSchema.IsAdditionalProperties && sg.Named) {
+		// this is a regular named schema for AdditionalProperties
 		sg.GenSchema.ValueExpression += "." + swag.ToGoName(sg.GenSchema.Name)
 		comprop := sg.NewAdditionalProperty(*addp.Schema)
 		d := sg.TypeResolver.Doc
@@ -987,12 +1261,35 @@ func (sg *schemaGenContext) buildAdditionalProperties() error {
 		if err := comprop.makeGenSchema(); err != nil {
 			return err
 		}
+
 		sg.MergeResult(comprop, false)
 		sg.GenSchema.AdditionalProperties = &comprop.GenSchema
+		sg.GenSchema.AdditionalProperties.ValueExpression = sg.GenSchema.ValueExpression + "[" + comprop.KeyVar + "]"
+
+		// rewrite value expression for arrays and arrays of arrays in maps (rendered as map[string][][]...)
+		if sg.GenSchema.AdditionalProperties.IsArray {
+			// maps of slices are where an override may take effect
+			sg.GenSchema.AdditionalProperties.Items.IsMapNullOverride = sg.GenSchema.AdditionalProperties.IsMapNullOverride
+			sg.GenSchema.AdditionalProperties.Items.ValueExpression = sg.GenSchema.ValueExpression + "[" + comprop.KeyVar + "]" + "[" + sg.GenSchema.AdditionalProperties.IndexVar + "]"
+			ap := sg.GenSchema.AdditionalProperties.Items
+			for ap != nil && ap.IsArray {
+				ap.Items.IsMapNullOverride = ap.IsMapNullOverride
+				ap.Items.ValueExpression = ap.ValueExpression + "[" + ap.IndexVar + "]"
+				ap = ap.Items
+			}
+		}
+
+		// lift validation
+		if (sg.GenSchema.AdditionalProperties.IsComplexObject || sg.GenSchema.AdditionalProperties.IsAliased || sg.GenSchema.AdditionalProperties.Required) && !(sg.GenSchema.AdditionalProperties.IsInterface || sg.GenSchema.IsStream) {
+			sg.GenSchema.HasValidations = true
+		}
 		return nil
 	}
 
 	if sg.GenSchema.IsMap && wantsAdditional {
+		// this is itself an AdditionalProperties schema with some AdditionalProperties.
+		// this also runs for aliased map types (with zero properties save additionalProperties)
+		//
 		// find out how deep this rabbit hole goes
 		// descend, unwind and rewrite
 		// This needs to be depth first, so it first goes as deep as it can and then
@@ -1009,7 +1306,7 @@ func (sg *schemaGenContext) buildAdditionalProperties() error {
 	}
 
 	if sg.GenSchema.IsAdditionalProperties && !sg.Named {
-		// for an anonoymous object, first build the new object
+		// for an anonymous object, first build the new object
 		// and then replace the current one with a $ref to the
 		// new object
 		newObj := sg.makeNewStruct(sg.GenSchema.Name+" P"+strconv.Itoa(sg.Index), sg.Schema)
@@ -1017,12 +1314,19 @@ func (sg *schemaGenContext) buildAdditionalProperties() error {
 			return err
 		}
 
+		hasMapNullOverride := sg.GenSchema.IsMapNullOverride
 		sg.GenSchema = GenSchema{}
 		sg.Schema = *spec.RefProperty("#/definitions/" + newObj.Name)
 		if err := sg.makeGenSchema(); err != nil {
 			return err
 		}
 		sg.MergeResult(newObj, false)
+
+		sg.GenSchema.IsMapNullOverride = hasMapNullOverride
+		if sg.GenSchema.IsArray {
+			sg.GenSchema.Items.IsMapNullOverride = hasMapNullOverride
+		}
+
 		sg.GenSchema.HasValidations = newObj.GenSchema.HasValidations
 		sg.ExtraSchemas[newObj.Name] = newObj.GenSchema
 		return nil
@@ -1060,7 +1364,7 @@ func (sg *schemaGenContext) makeNewStruct(name string, schema spec.Schema) *sche
 	}
 	if schema.Ref.String() == "" {
 		resolver := newTypeResolver(sg.TypeResolver.ModelsPackage, sg.TypeResolver.Doc)
-		resolver.ModelName = name //sg.TypeResolver.ModelName
+		resolver.ModelName = name
 		pg.TypeResolver = resolver
 	}
 	pg.GenSchema.IsVirtual = true
@@ -1074,6 +1378,7 @@ func (sg *schemaGenContext) buildArray() error {
 	if err != nil {
 		return err
 	}
+
 	// check if the element is a complex object, if so generate a new type for it
 	if tpe.IsComplexObject && tpe.IsAnonymous {
 		pg := sg.makeNewStruct(sg.Name+" items"+strconv.Itoa(sg.Index), *sg.Schema.Items.Schema)
@@ -1087,13 +1392,22 @@ func (sg *schemaGenContext) buildArray() error {
 		return sg.makeGenSchema()
 	}
 
+	// create the generation schema for items
 	elProp := sg.NewSliceBranch(sg.Schema.Items.Schema)
-	elProp.Required = true
+
+	// when building a slice of maps, the map item is not required
+	// items from maps of aliased or nullable type remain required
+
+	// NOTE(fredbi): since this is reset below, this Required = true serves the obscure purpose
+	// of indirectly lifting validations from the slice. This is carried on differently now.
+	// elProp.Required = true
+
 	if err := elProp.makeGenSchema(); err != nil {
 		return err
 	}
 
 	sg.MergeResult(elProp, false)
+
 	sg.GenSchema.IsBaseType = elProp.GenSchema.IsBaseType
 	sg.GenSchema.ItemsEnum = elProp.GenSchema.Enum
 	elProp.GenSchema.Suffix = "Items"
@@ -1103,33 +1417,48 @@ func (sg *schemaGenContext) buildArray() error {
 	if elProp.GenSchema.IsNullable {
 		sg.GenSchema.GoType = "[]*" + elProp.GenSchema.GoType
 	}
+
 	sg.GenSchema.IsArray = true
+
+	// all types are exported but the ones based on discriminator
 	sg.GenSchema.IsExported = !sg.GenSchema.ElemType.HasDiscriminator
 
 	schemaCopy := elProp.GenSchema
 	schemaCopy.Required = false
-	hv, _ := hasValidations(sg.Schema.Items.Schema, false)
+
+	// validations of items
+	hv := hasValidations(sg.Schema.Items.Schema, false)
+
 	// include format validation, excluding binary
 	hv = hv || (schemaCopy.IsCustomFormatter && !schemaCopy.IsStream) || (schemaCopy.IsArray && schemaCopy.ElemType.IsCustomFormatter && !schemaCopy.ElemType.IsStream)
-	schemaCopy.HasValidations = elProp.GenSchema.IsNullable || hv
+
+	schemaCopy.HasValidations = schemaCopy.HasValidations || elProp.GenSchema.IsNullable || hv || elProp.GenSchema.IsBaseType
+
+	// lift validations
+	sg.GenSchema.HasValidations = sg.GenSchema.HasValidations || schemaCopy.HasValidations
+
 	sg.GenSchema.Items = &schemaCopy
 	if sg.Named {
 		sg.GenSchema.AliasedType = sg.GenSchema.GoType
 	}
+
 	return nil
 }
 
 func (sg *schemaGenContext) buildItems() error {
-	presentsAsSingle := sg.Schema.Items != nil && sg.Schema.Items.Schema != nil
+	if sg.Schema.Items == nil {
+		// in swagger, arrays MUST have an items schema
+		return nil
+	}
+
+	// in Items spec, we have either Schema (array) or Schemas (tuple)
+	presentsAsSingle := sg.Schema.Items.Schema != nil
 	if presentsAsSingle && sg.Schema.AdditionalItems != nil { // unsure if this a valid of invalid schema
 		return fmt.Errorf("single schema (%s) can't have additional items", sg.Name)
 	}
 	if presentsAsSingle {
 		return sg.buildArray()
 	}
-	if sg.Schema.Items == nil {
-		return nil
-	}
 
 	// This is a tuple, build a new model that represents this
 	if sg.Named {
@@ -1140,14 +1469,19 @@ func (sg *schemaGenContext) buildItems() error {
 			if err := elProp.makeGenSchema(); err != nil {
 				return err
 			}
+			if elProp.GenSchema.IsInterface || elProp.GenSchema.IsStream {
+				elProp.GenSchema.HasValidations = false
+			}
 			sg.MergeResult(elProp, false)
+
 			elProp.GenSchema.Name = "p" + strconv.Itoa(i)
 			sg.GenSchema.Properties = append(sg.GenSchema.Properties, elProp.GenSchema)
+			sg.GenSchema.IsTuple = true
 		}
 		return nil
 	}
 
-	// for an anonoymous object, first build the new object
+	// for an anonymous object, first build the new object
 	// and then replace the current one with a $ref to the
 	// new tuple object
 	var sch spec.Schema
@@ -1201,6 +1535,7 @@ func (sg *schemaGenContext) buildAdditionalItems() error {
 		}
 
 		it := sg.NewAdditionalItems(sg.Schema.AdditionalItems.Schema)
+
 		if tpe.IsInterface {
 			it.Untyped = true
 		}
@@ -1208,6 +1543,12 @@ func (sg *schemaGenContext) buildAdditionalItems() error {
 		if err := it.makeGenSchema(); err != nil {
 			return err
 		}
+
+		// lift validations when complex is not anonymous or ref'ed
+		if (tpe.IsComplexObject || it.Schema.Ref.String() != "") && !(tpe.IsInterface || tpe.IsStream) {
+			it.GenSchema.HasValidations = true
+		}
+
 		sg.MergeResult(it, true)
 		sg.GenSchema.AdditionalItems = &it.GenSchema
 	}
@@ -1232,6 +1573,7 @@ func (sg *schemaGenContext) buildXMLName() error {
 func (sg *schemaGenContext) shortCircuitNamedRef() (bool, error) {
 	// This if block ensures that a struct gets
 	// rendered with the ref as embedded ref.
+	// TODO: RefHandled is actually set nowhere
 	if sg.RefHandled || !sg.Named || sg.Schema.Ref.String() == "" {
 		return false, nil
 	}
@@ -1259,11 +1601,13 @@ func (sg *schemaGenContext) shortCircuitNamedRef() (bool, error) {
 	sg.GenSchema.IsNullable = sg.GenSchema.IsNullable || nullableOverride
 	// prevent format from bubbling up in composed type
 	item.GenSchema.IsCustomFormatter = false
+
 	sg.MergeResult(item, true)
 	sg.GenSchema.AllOf = append(sg.GenSchema.AllOf, item.GenSchema)
 	return true, nil
 }
 
+// liftSpecialAllOf attempts to simplify the rendering of allOf constructs by lifting simple things into the current schema.
 func (sg *schemaGenContext) liftSpecialAllOf() error {
 	// if there is only a $ref or a primitive and an x-isnullable schema then this is a nullable pointer
 	// so this should not compose several objects, just 1
@@ -1285,15 +1629,24 @@ func (sg *schemaGenContext) liftSpecialAllOf() error {
 		if sg.TypeResolver.IsNullable(&sch) {
 			seenNullable = true
 		}
-		if len(sch.Type) > 0 || len(sch.Properties) > 0 || sch.Ref.GetURL() != nil {
+		if len(sch.Type) > 0 || len(sch.Properties) > 0 || sch.Ref.GetURL() != nil || len(sch.AllOf) > 0 {
 			seenSchema++
+			if seenSchema > 1 {
+				// won't do anything if several candidates for a lift
+				break
+			}
 			if (!tpe.IsAnonymous && tpe.IsComplexObject) || tpe.IsPrimitive {
+				// lifting complex ojects here results in inlined structs in the model
 				schemaToLift = sch
 			}
 		}
 	}
 
 	if seenSchema == 1 {
+		// when there only a single schema to lift in allOf, replace the schema by its allOf definition
+		if Debug {
+			log.Printf("lifted schema in allOf for %s", sg.Name)
+		}
 		sg.Schema = schemaToLift
 		sg.GenSchema.IsNullable = seenNullable
 	}
@@ -1407,6 +1760,7 @@ func (sg *schemaGenContext) makeGenSchema() error {
 	if err != nil {
 		return err
 	}
+
 	if Debug {
 		log.Println("gschema rrequired", sg.GenSchema.Required, "nullable", sg.GenSchema.IsNullable)
 	}
@@ -1414,9 +1768,13 @@ func (sg *schemaGenContext) makeGenSchema() error {
 	sg.GenSchema.resolvedType = tpe
 	sg.GenSchema.IsBaseType = tpe.IsBaseType
 	sg.GenSchema.HasDiscriminator = tpe.HasDiscriminator
+
 	// include format validations, excluding binary
-	sg.GenSchema.HasValidations = sg.GenSchema.HasValidations || (tpe.IsCustomFormatter && !tpe.IsStream) || (tpe.IsArray && tpe.ElemType.IsCustomFormatter && !tpe.ElemType.IsStream)
-	if tpe.IsArray && tpe.ElemType.IsBaseType {
+	sg.GenSchema.HasValidations = sg.GenSchema.HasValidations || (tpe.IsCustomFormatter && !tpe.IsStream) || (tpe.IsArray && tpe.ElemType != nil && tpe.ElemType.IsCustomFormatter && !tpe.ElemType.IsStream)
+
+	// usage of a polymorphic base type is rendered with getter funcs on private properties.
+	// In the case of aliased types, the value expression remains unchanged to the receiver.
+	if tpe.IsArray && tpe.ElemType != nil && tpe.ElemType.IsBaseType && sg.GenSchema.ValueExpression != sg.GenSchema.ReceiverName {
 		sg.GenSchema.ValueExpression += "()"
 	}
 
diff --git a/generator/model_test.go b/generator/model_test.go
index 5886fdd2..d29bf165 100644
--- a/generator/model_test.go
+++ b/generator/model_test.go
@@ -564,7 +564,8 @@ func TestGenerateModel_WithMapInterface(t *testing.T) {
 			assert.Equal(t, "map[string]interface{}", prop.GoType)
 			assert.True(t, prop.Required)
 			assert.True(t, prop.HasValidations)
-			assert.False(t, prop.NeedsValidation)
+			// NOTE(fredbi): NeedsValidation now deprecated
+			//assert.False(t, prop.NeedsValidation)
 			buf := bytes.NewBuffer(nil)
 			err := templates.MustGet("model").Execute(buf, genModel)
 			if assert.NoError(t, err) {
@@ -2482,7 +2483,8 @@ func TestGenModel_Issue910(t *testing.T) {
 							assertInCode(t, `if err := validate.Required("foo", "body", m.Foo); err != nil {`, res)
 							assertNotInCode(t, `if err := validate.Required("baz", "body", m.Baz); err != nil {`, res)
 							assertNotInCode(t, `if err := validate.Required("quux", "body", m.Quux); err != nil {`, res)
-							assertInCode(t, `if swag.IsZero(m.Quux) { // not required`, res)
+							// NOTE(fredbi); fixed Required in slices. This property has actually no validation
+							assertNotInCode(t, `if swag.IsZero(m.Quux) { // not required`, res)
 						} else {
 							fmt.Println(buf.String())
 						}
diff --git a/generator/moreschemavalidation_fixtures_test.go b/generator/moreschemavalidation_fixtures_test.go
new file mode 100644
index 00000000..e88ccb43
--- /dev/null
+++ b/generator/moreschemavalidation_fixtures_test.go
@@ -0,0 +1,8003 @@
+package generator
+
+func initFixture1479Part() {
+	// testing ../fixtures/bugs/1479/fixture-1479-part.yaml with flatten and expand (--skip-flatten)
+
+	/*
+		The breakage with allOf occurs when a schema with an allOf has itself a
+		property which is an allOf construct
+	*/
+
+	f := newModelFixture("../fixtures/bugs/1479/fixture-1479-part.yaml", "check nested AllOf validations (from Pouch Engine API)")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: container_create_config_all_of1.go
+	flattenRun.AddExpectations("container_create_config_all_of1.go", []string{
+		`type ContainerCreateConfigAllOf1 struct {`,
+		"	HostConfig *HostConfig `json:\"HostConfig,omitempty\"`",
+		"	NetworkingConfig *NetworkingConfig `json:\"NetworkingConfig,omitempty\"`",
+		`func (m *ContainerCreateConfigAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateHostConfig(formats); err != nil {`,
+		`	if err := m.validateNetworkingConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ContainerCreateConfigAllOf1) validateHostConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.HostConfig) {`,
+		`	if m.HostConfig != nil {`,
+		`		if err := m.HostConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("HostConfig"`,
+		`func (m *ContainerCreateConfigAllOf1) validateNetworkingConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.NetworkingConfig) {`,
+		`	if m.NetworkingConfig != nil {`,
+		`		if err := m.NetworkingConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("NetworkingConfig"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: container_config.go
+	flattenRun.AddExpectations("container_config.go", []string{
+		`type ContainerConfig struct {`,
+		"	ArgsEscaped bool `json:\"ArgsEscaped,omitempty\"`",
+		"	AttachStderr bool `json:\"AttachStderr,omitempty\"`",
+		"	AttachStdin bool `json:\"AttachStdin,omitempty\"`",
+		"	AttachStdout bool `json:\"AttachStdout,omitempty\"`",
+		"	Cmd []string `json:\"Cmd\"`",
+		"	DiskQuota map[string]string `json:\"DiskQuota,omitempty\"`",
+		"	Domainname string `json:\"Domainname,omitempty\"`",
+		"	Entrypoint []string `json:\"Entrypoint\"`",
+		"	Env []string `json:\"Env\"`",
+		"	ExposedPorts map[string]interface{} `json:\"ExposedPorts,omitempty\"`",
+		"	Hostname strfmt.Hostname `json:\"Hostname,omitempty\"`",
+		"	Image string `json:\"Image\"`",
+		"	InitScript string `json:\"InitScript,omitempty\"`",
+		"	Labels map[string]string `json:\"Labels,omitempty\"`",
+		"	MacAddress string `json:\"MacAddress,omitempty\"`",
+		"	NetworkDisabled bool `json:\"NetworkDisabled,omitempty\"`",
+		"	OnBuild []string `json:\"OnBuild\"`",
+		"	OpenStdin bool `json:\"OpenStdin,omitempty\"`",
+		"	QuotaID string `json:\"QuotaID,omitempty\"`",
+		"	Rich bool `json:\"Rich,omitempty\"`",
+		"	RichMode string `json:\"RichMode,omitempty\"`",
+		"	Shell []string `json:\"Shell\"`",
+		"	SpecAnnotation map[string]string `json:\"SpecAnnotation,omitempty\"`",
+		"	StdinOnce bool `json:\"StdinOnce,omitempty\"`",
+		"	StopSignal string `json:\"StopSignal,omitempty\"`",
+		"	StopTimeout *int64 `json:\"StopTimeout,omitempty\"`",
+		"	Tty bool `json:\"Tty,omitempty\"`",
+		"	User string `json:\"User,omitempty\"`",
+		"	Volumes map[string]interface{} `json:\"Volumes,omitempty\"`",
+		"	WorkingDir string `json:\"WorkingDir,omitempty\"`",
+		`func (m *ContainerConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateExposedPorts(formats); err != nil {`,
+		`	if err := m.validateHostname(formats); err != nil {`,
+		`	if err := m.validateImage(formats); err != nil {`,
+		`	if err := m.validateRichMode(formats); err != nil {`,
+		`	if err := m.validateVolumes(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var containerConfigExposedPortsValueEnum []interface{`,
+		`	var res []interface{`,
+		"	if err := json.Unmarshal([]byte(`[{}]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		containerConfigExposedPortsValueEnum = append(containerConfigExposedPortsValueEnum, v`,
+		`func (m *ContainerConfig) validateExposedPortsValueEnum(path, location string, value interface{}) error {`,
+		`	if err := validate.Enum(path, location, value, containerConfigExposedPortsValueEnum); err != nil {`,
+		`func (m *ContainerConfig) validateExposedPorts(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ExposedPorts) {`,
+		`	for k := range m.ExposedPorts {`,
+		`		if swag.IsZero(m.ExposedPorts[k]) {`,
+		`		if err := m.validateExposedPortsValueEnum("ExposedPorts"+"."+k, "body", m.ExposedPorts[k]); err != nil {`,
+		`func (m *ContainerConfig) validateHostname(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Hostname) {`,
+		`	if err := validate.MinLength("Hostname", "body", string(m.Hostname), 1); err != nil {`,
+		`	if err := validate.FormatOf("Hostname", "body", "hostname", m.Hostname.String(), formats); err != nil {`,
+		`func (m *ContainerConfig) validateImage(formats strfmt.Registry) error {`,
+		`	if err := validate.RequiredString("Image", "body", string(m.Image)); err != nil {`,
+		`var containerConfigTypeRichModePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"dumb-init\",\"sbin-init\",\"systemd\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		containerConfigTypeRichModePropEnum = append(containerConfigTypeRichModePropEnum, v`,
+		`	ContainerConfigRichModeDumbInit string = "dumb-init"`,
+		`	ContainerConfigRichModeSbinInit string = "sbin-init"`,
+		`	ContainerConfigRichModeSystemd string = "systemd"`,
+		`func (m *ContainerConfig) validateRichModeEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, containerConfigTypeRichModePropEnum); err != nil {`,
+		`func (m *ContainerConfig) validateRichMode(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.RichMode) {`,
+		`	if err := m.validateRichModeEnum("RichMode", "body", m.RichMode); err != nil {`,
+		`var containerConfigVolumesValueEnum []interface{`,
+		`	var res []interface{`,
+		"	if err := json.Unmarshal([]byte(`[{}]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		containerConfigVolumesValueEnum = append(containerConfigVolumesValueEnum, v`,
+		`func (m *ContainerConfig) validateVolumesValueEnum(path, location string, value interface{}) error {`,
+		`	if err := validate.Enum(path, location, value, containerConfigVolumesValueEnum); err != nil {`,
+		`func (m *ContainerConfig) validateVolumes(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Volumes) {`,
+		`	for k := range m.Volumes {`,
+		`		if swag.IsZero(m.Volumes[k]) {`,
+		`		if err := m.validateVolumesValueEnum("Volumes"+"."+k, "body", m.Volumes[k]); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("container_config.go", flattenRun.ExpectedFor("ContainerConfig").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: host_config_all_of0_log_config.go
+	flattenRun.AddExpectations("host_config_all_of0_log_config.go", []string{
+		`type HostConfigAllOf0LogConfig struct {`,
+		"	Config map[string]string `json:\"Config,omitempty\"`",
+		"	Type string `json:\"Type,omitempty\"`",
+		`func (m *HostConfigAllOf0LogConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateType(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var hostConfigAllOf0LogConfigTypeTypePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"json-file\",\"syslog\",\"journald\",\"gelf\",\"fluentd\",\"awslogs\",\"splunk\",\"etwlogs\",\"none\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		hostConfigAllOf0LogConfigTypeTypePropEnum = append(hostConfigAllOf0LogConfigTypeTypePropEnum, v`,
+		`	HostConfigAllOf0LogConfigTypeJSONFile string = "json-file"`,
+		`	HostConfigAllOf0LogConfigTypeSyslog string = "syslog"`,
+		`	HostConfigAllOf0LogConfigTypeJournald string = "journald"`,
+		`	HostConfigAllOf0LogConfigTypeGelf string = "gelf"`,
+		`	HostConfigAllOf0LogConfigTypeFluentd string = "fluentd"`,
+		`	HostConfigAllOf0LogConfigTypeAwslogs string = "awslogs"`,
+		`	HostConfigAllOf0LogConfigTypeSplunk string = "splunk"`,
+		`	HostConfigAllOf0LogConfigTypeEtwlogs string = "etwlogs"`,
+		`	HostConfigAllOf0LogConfigTypeNone string = "none"`,
+		`func (m *HostConfigAllOf0LogConfig) validateTypeEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, hostConfigAllOf0LogConfigTypeTypePropEnum); err != nil {`,
+		`func (m *HostConfigAllOf0LogConfig) validateType(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Type) {`,
+		`	if err := m.validateTypeEnum("Type", "body", m.Type); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: restart_policy.go
+	flattenRun.AddExpectations("restart_policy.go", []string{
+		`type RestartPolicy struct {`,
+		"	MaximumRetryCount int64 `json:\"MaximumRetryCount,omitempty\"`",
+		"	Name string `json:\"Name,omitempty\"`",
+		// empty validation
+		"func (m *RestartPolicy) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("restart_policy.go", flattenRun.ExpectedFor("RestartPolicy").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: endpoint_ip_a_m_config.go
+	flattenRun.AddExpectations("endpoint_ip_a_m_config.go", []string{
+		`type EndpointIPAMConfig struct {`,
+		"	IPV4Address string `json:\"IPv4Address,omitempty\"`",
+		"	IPV6Address string `json:\"IPv6Address,omitempty\"`",
+		"	LinkLocalIps []string `json:\"LinkLocalIPs\"`",
+		// empty validation
+		"func (m *EndpointIPAMConfig) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("endpoint_ip_a_m_config.go", flattenRun.ExpectedFor("EndpointIPAMConfig").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: host_config_all_of0.go
+	flattenRun.AddExpectations("host_config_all_of0.go", []string{
+		`type HostConfigAllOf0 struct {`,
+		"	AutoRemove bool `json:\"AutoRemove,omitempty\"`",
+		"	Binds []string `json:\"Binds\"`",
+		"	CapAdd []string `json:\"CapAdd\"`",
+		"	CapDrop []string `json:\"CapDrop\"`",
+		"	Cgroup string `json:\"Cgroup,omitempty\"`",
+		"	ConsoleSize []*int64 `json:\"ConsoleSize\"`",
+		"	ContainerIDFile string `json:\"ContainerIDFile,omitempty\"`",
+		"	DNS []string `json:\"Dns\"`",
+		"	DNSOptions []string `json:\"DnsOptions\"`",
+		"	DNSSearch []string `json:\"DnsSearch\"`",
+		"	EnableLxcfs bool `json:\"EnableLxcfs,omitempty\"`",
+		"	ExtraHosts []string `json:\"ExtraHosts\"`",
+		"	GroupAdd []string `json:\"GroupAdd\"`",
+		"	InitScript string `json:\"InitScript,omitempty\"`",
+		"	IpcMode string `json:\"IpcMode,omitempty\"`",
+		"	Isolation string `json:\"Isolation,omitempty\"`",
+		"	Links []string `json:\"Links\"`",
+		"	LogConfig *HostConfigAllOf0LogConfig `json:\"LogConfig,omitempty\"`",
+		"	NetworkMode string `json:\"NetworkMode,omitempty\"`",
+		"	OomScoreAdj int64 `json:\"OomScoreAdj,omitempty\"`",
+		"	PidMode string `json:\"PidMode,omitempty\"`",
+		"	Privileged bool `json:\"Privileged,omitempty\"`",
+		"	PublishAllPorts bool `json:\"PublishAllPorts,omitempty\"`",
+		"	ReadonlyRootfs bool `json:\"ReadonlyRootfs,omitempty\"`",
+		"	RestartPolicy *RestartPolicy `json:\"RestartPolicy,omitempty\"`",
+		"	Rich bool `json:\"Rich,omitempty\"`",
+		"	RichMode string `json:\"RichMode,omitempty\"`",
+		"	Runtime string `json:\"Runtime,omitempty\"`",
+		"	SecurityOpt []string `json:\"SecurityOpt\"`",
+		"	ShmSize *int64 `json:\"ShmSize,omitempty\"`",
+		"	StorageOpt map[string]string `json:\"StorageOpt,omitempty\"`",
+		"	Sysctls map[string]string `json:\"Sysctls,omitempty\"`",
+		"	Tmpfs map[string]string `json:\"Tmpfs,omitempty\"`",
+		"	UTSMode string `json:\"UTSMode,omitempty\"`",
+		"	UsernsMode string `json:\"UsernsMode,omitempty\"`",
+		"	VolumeDriver string `json:\"VolumeDriver,omitempty\"`",
+		"	VolumesFrom []string `json:\"VolumesFrom\"`",
+		`func (m *HostConfigAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateConsoleSize(formats); err != nil {`,
+		`	if err := m.validateIsolation(formats); err != nil {`,
+		`	if err := m.validateLogConfig(formats); err != nil {`,
+		`	if err := m.validateOomScoreAdj(formats); err != nil {`,
+		`	if err := m.validateRestartPolicy(formats); err != nil {`,
+		`	if err := m.validateRichMode(formats); err != nil {`,
+		`	if err := m.validateShmSize(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *HostConfigAllOf0) validateConsoleSize(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ConsoleSize) {`,
+		`	iConsoleSizeSize := int64(len(m.ConsoleSize)`,
+		`	if err := validate.MinItems("ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {`,
+		`	if err := validate.MaxItems("ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {`,
+		`	for i := 0; i < len(m.ConsoleSize); i++ {`,
+		`		if swag.IsZero(m.ConsoleSize[i]) {`,
+		`		if err := validate.MinimumInt("ConsoleSize"+"."+strconv.Itoa(i), "body", int64(*m.ConsoleSize[i]), 0, false); err != nil {`,
+		`var hostConfigAllOf0TypeIsolationPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"default\",\"process\",\"hyperv\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		hostConfigAllOf0TypeIsolationPropEnum = append(hostConfigAllOf0TypeIsolationPropEnum, v`,
+		`	HostConfigAllOf0IsolationDefault string = "default"`,
+		`	HostConfigAllOf0IsolationProcess string = "process"`,
+		`	HostConfigAllOf0IsolationHyperv string = "hyperv"`,
+		`func (m *HostConfigAllOf0) validateIsolationEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, hostConfigAllOf0TypeIsolationPropEnum); err != nil {`,
+		`func (m *HostConfigAllOf0) validateIsolation(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Isolation) {`,
+		`	if err := m.validateIsolationEnum("Isolation", "body", m.Isolation); err != nil {`,
+		`func (m *HostConfigAllOf0) validateLogConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.LogConfig) {`,
+		`	if m.LogConfig != nil {`,
+		`		if err := m.LogConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("LogConfig"`,
+		`func (m *HostConfigAllOf0) validateOomScoreAdj(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.OomScoreAdj) {`,
+		`	if err := validate.MinimumInt("OomScoreAdj", "body", int64(m.OomScoreAdj), -1000, false); err != nil {`,
+		`	if err := validate.MaximumInt("OomScoreAdj", "body", int64(m.OomScoreAdj), 1000, false); err != nil {`,
+		`func (m *HostConfigAllOf0) validateRestartPolicy(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.RestartPolicy) {`,
+		`	if m.RestartPolicy != nil {`,
+		`		if err := m.RestartPolicy.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("RestartPolicy"`,
+		`var hostConfigAllOf0TypeRichModePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"dumb-init\",\"sbin-init\",\"systemd\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		hostConfigAllOf0TypeRichModePropEnum = append(hostConfigAllOf0TypeRichModePropEnum, v`,
+		`	HostConfigAllOf0RichModeDumbInit string = "dumb-init"`,
+		`	HostConfigAllOf0RichModeSbinInit string = "sbin-init"`,
+		`	HostConfigAllOf0RichModeSystemd string = "systemd"`,
+		`func (m *HostConfigAllOf0) validateRichModeEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, hostConfigAllOf0TypeRichModePropEnum); err != nil {`,
+		`func (m *HostConfigAllOf0) validateRichMode(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.RichMode) {`,
+		`	if err := m.validateRichModeEnum("RichMode", "body", m.RichMode); err != nil {`,
+		`func (m *HostConfigAllOf0) validateShmSize(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ShmSize) {`,
+		`	if err := validate.MinimumInt("ShmSize", "body", int64(*m.ShmSize), 0, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: host_config.go
+	flattenRun.AddExpectations("host_config.go", []string{
+		`type HostConfig struct {`,
+		`	HostConfigAllOf0`,
+		`	Resources`,
+		`func (m *HostConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.HostConfigAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.Resources.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("host_config.go", []string{
+		`type HostConfig struct {`,
+		"	AutoRemove bool `json:\"AutoRemove,omitempty\"`",
+		"	Binds []string `json:\"Binds\"`",
+		"	CapAdd []string `json:\"CapAdd\"`",
+		"	CapDrop []string `json:\"CapDrop\"`",
+		"	Cgroup string `json:\"Cgroup,omitempty\"`",
+		"	ConsoleSize []*int64 `json:\"ConsoleSize\"`",
+		"	ContainerIDFile string `json:\"ContainerIDFile,omitempty\"`",
+		"	DNS []string `json:\"Dns\"`",
+		"	DNSOptions []string `json:\"DnsOptions\"`",
+		"	DNSSearch []string `json:\"DnsSearch\"`",
+		"	EnableLxcfs bool `json:\"EnableLxcfs,omitempty\"`",
+		"	ExtraHosts []string `json:\"ExtraHosts\"`",
+		"	GroupAdd []string `json:\"GroupAdd\"`",
+		"	InitScript string `json:\"InitScript,omitempty\"`",
+		"	IpcMode string `json:\"IpcMode,omitempty\"`",
+		"	Isolation string `json:\"Isolation,omitempty\"`",
+		"	Links []string `json:\"Links\"`",
+		"	LogConfig *HostConfigAO0LogConfig `json:\"LogConfig,omitempty\"`",
+		"	NetworkMode string `json:\"NetworkMode,omitempty\"`",
+		"	OomScoreAdj int64 `json:\"OomScoreAdj,omitempty\"`",
+		"	PidMode string `json:\"PidMode,omitempty\"`",
+		"	Privileged bool `json:\"Privileged,omitempty\"`",
+		"	PublishAllPorts bool `json:\"PublishAllPorts,omitempty\"`",
+		"	ReadonlyRootfs bool `json:\"ReadonlyRootfs,omitempty\"`",
+		"	RestartPolicy *HostConfigAO0RestartPolicy `json:\"RestartPolicy,omitempty\"`",
+		"	Rich bool `json:\"Rich,omitempty\"`",
+		"	RichMode string `json:\"RichMode,omitempty\"`",
+		"	Runtime string `json:\"Runtime,omitempty\"`",
+		"	SecurityOpt []string `json:\"SecurityOpt\"`",
+		"	ShmSize *int64 `json:\"ShmSize,omitempty\"`",
+		"	StorageOpt map[string]string `json:\"StorageOpt,omitempty\"`",
+		"	Sysctls map[string]string `json:\"Sysctls,omitempty\"`",
+		"	Tmpfs map[string]string `json:\"Tmpfs,omitempty\"`",
+		"	UTSMode string `json:\"UTSMode,omitempty\"`",
+		"	UsernsMode string `json:\"UsernsMode,omitempty\"`",
+		"	VolumeDriver string `json:\"VolumeDriver,omitempty\"`",
+		"	VolumesFrom []string `json:\"VolumesFrom\"`",
+		"	BlkioWeight uint16 `json:\"BlkioWeight,omitempty\"`",
+		"	CgroupParent string `json:\"CgroupParent,omitempty\"`",
+		"	CPUShares int64 `json:\"CpuShares,omitempty\"`",
+		"	Memory int64 `json:\"Memory,omitempty\"`",
+		`func (m *HostConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateConsoleSize(formats); err != nil {`,
+		`	if err := m.validateIsolation(formats); err != nil {`,
+		`	if err := m.validateLogConfig(formats); err != nil {`,
+		`	if err := m.validateOomScoreAdj(formats); err != nil {`,
+		`	if err := m.validateRestartPolicy(formats); err != nil {`,
+		`	if err := m.validateRichMode(formats); err != nil {`,
+		`	if err := m.validateShmSize(formats); err != nil {`,
+		`	if err := m.validateBlkioWeight(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *HostConfig) validateConsoleSize(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ConsoleSize) {`,
+		`	iConsoleSizeSize := int64(len(m.ConsoleSize)`,
+		`	if err := validate.MinItems("ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {`,
+		`	if err := validate.MaxItems("ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {`,
+		`	for i := 0; i < len(m.ConsoleSize); i++ {`,
+		`		if swag.IsZero(m.ConsoleSize[i]) {`,
+		`		if err := validate.MinimumInt("ConsoleSize"+"."+strconv.Itoa(i), "body", int64(*m.ConsoleSize[i]), 0, false); err != nil {`,
+		`var hostConfigTypeIsolationPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"default\",\"process\",\"hyperv\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		hostConfigTypeIsolationPropEnum = append(hostConfigTypeIsolationPropEnum, v`,
+		`func (m *HostConfig) validateIsolationEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, hostConfigTypeIsolationPropEnum); err != nil {`,
+		`func (m *HostConfig) validateIsolation(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Isolation) {`,
+		`	if err := m.validateIsolationEnum("Isolation", "body", m.Isolation); err != nil {`,
+		`func (m *HostConfig) validateLogConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.LogConfig) {`,
+		`	if m.LogConfig != nil {`,
+		`		if err := m.LogConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("LogConfig"`,
+		`func (m *HostConfig) validateOomScoreAdj(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.OomScoreAdj) {`,
+		`	if err := validate.MinimumInt("OomScoreAdj", "body", int64(m.OomScoreAdj), -1000, false); err != nil {`,
+		`	if err := validate.MaximumInt("OomScoreAdj", "body", int64(m.OomScoreAdj), 1000, false); err != nil {`,
+		`func (m *HostConfig) validateRestartPolicy(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.RestartPolicy) {`,
+		`	if m.RestartPolicy != nil {`,
+		`		if err := m.RestartPolicy.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("RestartPolicy"`,
+		`var hostConfigTypeRichModePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"dumb-init\",\"sbin-init\",\"systemd\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		hostConfigTypeRichModePropEnum = append(hostConfigTypeRichModePropEnum, v`,
+		`func (m *HostConfig) validateRichModeEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, hostConfigTypeRichModePropEnum); err != nil {`,
+		`func (m *HostConfig) validateRichMode(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.RichMode) {`,
+		`	if err := m.validateRichModeEnum("RichMode", "body", m.RichMode); err != nil {`,
+		`func (m *HostConfig) validateShmSize(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ShmSize) {`,
+		`	if err := validate.MinimumInt("ShmSize", "body", int64(*m.ShmSize), 0, false); err != nil {`,
+		`func (m *HostConfig) validateBlkioWeight(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.BlkioWeight) {`,
+		`	if err := validate.MinimumInt("BlkioWeight", "body", int64(m.BlkioWeight), 0, false); err != nil {`,
+		`	if err := validate.MaximumInt("BlkioWeight", "body", int64(m.BlkioWeight), 1000, false); err != nil {`,
+		`type HostConfigAO0LogConfig struct {`,
+		"	Config map[string]string `json:\"Config,omitempty\"`",
+		"	Type string `json:\"Type,omitempty\"`",
+		`func (m *HostConfigAO0LogConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateType(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var hostConfigAO0LogConfigTypeTypePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"json-file\",\"syslog\",\"journald\",\"gelf\",\"fluentd\",\"awslogs\",\"splunk\",\"etwlogs\",\"none\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		hostConfigAO0LogConfigTypeTypePropEnum = append(hostConfigAO0LogConfigTypeTypePropEnum, v`,
+		`	HostConfigAO0LogConfigTypeJSONFile string = "json-file"`,
+		`	HostConfigAO0LogConfigTypeSyslog string = "syslog"`,
+		`	HostConfigAO0LogConfigTypeJournald string = "journald"`,
+		`	HostConfigAO0LogConfigTypeGelf string = "gelf"`,
+		`	HostConfigAO0LogConfigTypeFluentd string = "fluentd"`,
+		`	HostConfigAO0LogConfigTypeAwslogs string = "awslogs"`,
+		`	HostConfigAO0LogConfigTypeSplunk string = "splunk"`,
+		`	HostConfigAO0LogConfigTypeEtwlogs string = "etwlogs"`,
+		`	HostConfigAO0LogConfigTypeNone string = "none"`,
+		`func (m *HostConfigAO0LogConfig) validateTypeEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, hostConfigAO0LogConfigTypeTypePropEnum); err != nil {`,
+		`func (m *HostConfigAO0LogConfig) validateType(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Type) {`,
+		`	if err := m.validateTypeEnum("LogConfig"+"."+"Type", "body", m.Type); err != nil {`,
+		`type HostConfigAO0RestartPolicy struct {`,
+		"	MaximumRetryCount int64 `json:\"MaximumRetryCount,omitempty\"`",
+		"	Name string `json:\"Name,omitempty\"`",
+		`func (m *HostConfigAO0RestartPolicy) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: container_create_config.go
+	flattenRun.AddExpectations("container_create_config.go", []string{
+		`type ContainerCreateConfig struct {`,
+		`	ContainerConfig`,
+		`	ContainerCreateConfigAllOf1`,
+		`func (m *ContainerCreateConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.ContainerConfig.Validate(formats); err != nil {`,
+		`	if err := m.ContainerCreateConfigAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("container_create_config.go", []string{
+		`type ContainerCreateConfig struct {`,
+		"	ArgsEscaped bool `json:\"ArgsEscaped,omitempty\"`",
+		"	AttachStderr bool `json:\"AttachStderr,omitempty\"`",
+		"	AttachStdin bool `json:\"AttachStdin,omitempty\"`",
+		"	AttachStdout bool `json:\"AttachStdout,omitempty\"`",
+		"	Cmd []string `json:\"Cmd\"`",
+		"	DiskQuota map[string]string `json:\"DiskQuota,omitempty\"`",
+		"	Domainname string `json:\"Domainname,omitempty\"`",
+		"	Entrypoint []string `json:\"Entrypoint\"`",
+		"	Env []string `json:\"Env\"`",
+		"	ExposedPorts map[string]interface{} `json:\"ExposedPorts,omitempty\"`",
+		"	Hostname strfmt.Hostname `json:\"Hostname,omitempty\"`",
+		"	Image string `json:\"Image\"`",
+		"	InitScript string `json:\"InitScript,omitempty\"`",
+		"	Labels map[string]string `json:\"Labels,omitempty\"`",
+		"	MacAddress string `json:\"MacAddress,omitempty\"`",
+		"	NetworkDisabled bool `json:\"NetworkDisabled,omitempty\"`",
+		"	OnBuild []string `json:\"OnBuild\"`",
+		"	OpenStdin bool `json:\"OpenStdin,omitempty\"`",
+		"	QuotaID string `json:\"QuotaID,omitempty\"`",
+		"	Rich bool `json:\"Rich,omitempty\"`",
+		"	RichMode string `json:\"RichMode,omitempty\"`",
+		"	Shell []string `json:\"Shell\"`",
+		"	SpecAnnotation map[string]string `json:\"SpecAnnotation,omitempty\"`",
+		"	StdinOnce bool `json:\"StdinOnce,omitempty\"`",
+		"	StopSignal string `json:\"StopSignal,omitempty\"`",
+		"	StopTimeout *int64 `json:\"StopTimeout,omitempty\"`",
+		"	Tty bool `json:\"Tty,omitempty\"`",
+		"	User string `json:\"User,omitempty\"`",
+		"	Volumes map[string]interface{} `json:\"Volumes,omitempty\"`",
+		"	WorkingDir string `json:\"WorkingDir,omitempty\"`",
+		`	HostConfig struct {`,
+		"		AutoRemove bool `json:\"AutoRemove,omitempty\"`",
+		"		Binds []string `json:\"Binds\"`",
+		"		CapAdd []string `json:\"CapAdd\"`",
+		"		CapDrop []string `json:\"CapDrop\"`",
+		"		Cgroup string `json:\"Cgroup,omitempty\"`",
+		"		ConsoleSize []*int64 `json:\"ConsoleSize\"`",
+		"		ContainerIDFile string `json:\"ContainerIDFile,omitempty\"`",
+		"		DNS []string `json:\"Dns\"`",
+		"		DNSOptions []string `json:\"DnsOptions\"`",
+		"		DNSSearch []string `json:\"DnsSearch\"`",
+		"		EnableLxcfs bool `json:\"EnableLxcfs,omitempty\"`",
+		"		ExtraHosts []string `json:\"ExtraHosts\"`",
+		"		GroupAdd []string `json:\"GroupAdd\"`",
+		"		InitScript string `json:\"InitScript,omitempty\"`",
+		"		IpcMode string `json:\"IpcMode,omitempty\"`",
+		"		Isolation string `json:\"Isolation,omitempty\"`",
+		"		Links []string `json:\"Links\"`",
+		"		LogConfig *ContainerCreateConfigHostConfigAO0LogConfig `json:\"LogConfig,omitempty\"`",
+		"		NetworkMode string `json:\"NetworkMode,omitempty\"`",
+		"		OomScoreAdj int64 `json:\"OomScoreAdj,omitempty\"`",
+		"		PidMode string `json:\"PidMode,omitempty\"`",
+		"		Privileged bool `json:\"Privileged,omitempty\"`",
+		"		PublishAllPorts bool `json:\"PublishAllPorts,omitempty\"`",
+		"		ReadonlyRootfs bool `json:\"ReadonlyRootfs,omitempty\"`",
+		"		RestartPolicy *ContainerCreateConfigHostConfigAO0RestartPolicy `json:\"RestartPolicy,omitempty\"`",
+		"		Rich bool `json:\"Rich,omitempty\"`",
+		"		RichMode string `json:\"RichMode,omitempty\"`",
+		"		Runtime string `json:\"Runtime,omitempty\"`",
+		"		SecurityOpt []string `json:\"SecurityOpt\"`",
+		"		ShmSize *int64 `json:\"ShmSize,omitempty\"`",
+		"		StorageOpt map[string]string `json:\"StorageOpt,omitempty\"`",
+		"		Sysctls map[string]string `json:\"Sysctls,omitempty\"`",
+		"		Tmpfs map[string]string `json:\"Tmpfs,omitempty\"`",
+		"		UTSMode string `json:\"UTSMode,omitempty\"`",
+		"		UsernsMode string `json:\"UsernsMode,omitempty\"`",
+		"		VolumeDriver string `json:\"VolumeDriver,omitempty\"`",
+		"		VolumesFrom []string `json:\"VolumesFrom\"`",
+		"		BlkioWeight uint16 `json:\"BlkioWeight,omitempty\"`",
+		"		CgroupParent string `json:\"CgroupParent,omitempty\"`",
+		"		CPUShares int64 `json:\"CpuShares,omitempty\"`",
+		"		Memory int64 `json:\"Memory,omitempty\"`",
+		"	} `json:\"HostConfig,omitempty\"`",
+		"	NetworkingConfig *ContainerCreateConfigAO1NetworkingConfig `json:\"NetworkingConfig,omitempty\"`",
+		`func (m *ContainerCreateConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateExposedPorts(formats); err != nil {`,
+		`	if err := m.validateHostname(formats); err != nil {`,
+		`	if err := m.validateImage(formats); err != nil {`,
+		`	if err := m.validateRichMode(formats); err != nil {`,
+		`	if err := m.validateVolumes(formats); err != nil {`,
+		`	if err := m.validateHostConfig(formats); err != nil {`,
+		`	if err := m.validateNetworkingConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var containerCreateConfigExposedPortsValueEnum []interface{`,
+		`	var res []interface{`,
+		"	if err := json.Unmarshal([]byte(`[{}]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		containerCreateConfigExposedPortsValueEnum = append(containerCreateConfigExposedPortsValueEnum, v`,
+		`func (m *ContainerCreateConfig) validateExposedPortsValueEnum(path, location string, value interface{}) error {`,
+		`	if err := validate.Enum(path, location, value, containerCreateConfigExposedPortsValueEnum); err != nil {`,
+		`func (m *ContainerCreateConfig) validateExposedPorts(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ExposedPorts) {`,
+		`	for k := range m.ExposedPorts {`,
+		`		if swag.IsZero(m.ExposedPorts[k]) {`,
+		`		if err := m.validateExposedPortsValueEnum("ExposedPorts"+"."+k, "body", m.ExposedPorts[k]); err != nil {`,
+		`func (m *ContainerCreateConfig) validateHostname(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Hostname) {`,
+		`	if err := validate.MinLength("Hostname", "body", string(m.Hostname), 1); err != nil {`,
+		`	if err := validate.FormatOf("Hostname", "body", "hostname", m.Hostname.String(), formats); err != nil {`,
+		`func (m *ContainerCreateConfig) validateImage(formats strfmt.Registry) error {`,
+		`	if err := validate.RequiredString("Image", "body", string(m.Image)); err != nil {`,
+		`var containerCreateConfigTypeRichModePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"dumb-init\",\"sbin-init\",\"systemd\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		containerCreateConfigTypeRichModePropEnum = append(containerCreateConfigTypeRichModePropEnum, v`,
+		`func (m *ContainerCreateConfig) validateRichModeEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, containerCreateConfigTypeRichModePropEnum); err != nil {`,
+		`func (m *ContainerCreateConfig) validateRichMode(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.RichMode) {`,
+		`	if err := m.validateRichModeEnum("RichMode", "body", m.RichMode); err != nil {`,
+		`var containerCreateConfigVolumesValueEnum []interface{`,
+		`	var res []interface{`,
+		"	if err := json.Unmarshal([]byte(`[{}]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		containerCreateConfigVolumesValueEnum = append(containerCreateConfigVolumesValueEnum, v`,
+		`func (m *ContainerCreateConfig) validateVolumesValueEnum(path, location string, value interface{}) error {`,
+		`	if err := validate.Enum(path, location, value, containerCreateConfigVolumesValueEnum); err != nil {`,
+		`func (m *ContainerCreateConfig) validateVolumes(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Volumes) {`,
+		`	for k := range m.Volumes {`,
+		`		if swag.IsZero(m.Volumes[k]) {`,
+		`		if err := m.validateVolumesValueEnum("Volumes"+"."+k, "body", m.Volumes[k]); err != nil {`,
+		`func (m *ContainerCreateConfig) validateHostConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.HostConfig) {`,
+		`	iConsoleSizeSize := int64(len(m.HostConfig.ConsoleSize)`,
+		`	if err := validate.MinItems("HostConfig"+"."+"ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {`,
+		`	if err := validate.MaxItems("HostConfig"+"."+"ConsoleSize", "body", iConsoleSizeSize, 2); err != nil {`,
+		`	for i := 0; i < len(m.HostConfig.ConsoleSize); i++ {`,
+		`		if swag.IsZero(m.HostConfig.ConsoleSize[i]) {`,
+		`		if err := validate.MinimumInt("HostConfig"+"."+"ConsoleSize"+"."+strconv.Itoa(i), "body", int64(*m.HostConfig.ConsoleSize[i]), 0, false); err != nil {`,
+		// TODO: enum if anonymous allOf is not honored (missing func)
+		// => will do that with Enum refactoring
+		`	if err := m.validateIsolationEnum("HostConfig"+"."+"Isolation", "body", m.HostConfig.Isolation); err != nil {`,
+		`	if m.HostConfig.LogConfig != nil {`,
+		`		if err := m.HostConfig.LogConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("HostConfig" + "." + "LogConfig"`,
+		`	if err := validate.MinimumInt("HostConfig"+"."+"OomScoreAdj", "body", int64(m.HostConfig.OomScoreAdj), -1000, false); err != nil {`,
+		`	if err := validate.MaximumInt("HostConfig"+"."+"OomScoreAdj", "body", int64(m.HostConfig.OomScoreAdj), 1000, false); err != nil {`,
+		`	if m.HostConfig.RestartPolicy != nil {`,
+		`		if err := m.HostConfig.RestartPolicy.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("HostConfig" + "." + "RestartPolicy"`,
+		`	if err := m.validateRichModeEnum("HostConfig"+"."+"RichMode", "body", m.HostConfig.RichMode); err != nil {`,
+		`	if err := validate.MinimumInt("HostConfig"+"."+"ShmSize", "body", int64(*m.HostConfig.ShmSize), 0, false); err != nil {`,
+		`	if err := validate.MinimumInt("HostConfig"+"."+"BlkioWeight", "body", int64(m.HostConfig.BlkioWeight), 0, false); err != nil {`,
+		`	if err := validate.MaximumInt("HostConfig"+"."+"BlkioWeight", "body", int64(m.HostConfig.BlkioWeight), 1000, false); err != nil {`,
+		`func (m *ContainerCreateConfig) validateNetworkingConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.NetworkingConfig) {`,
+		`	if m.NetworkingConfig != nil {`,
+		`		if err := m.NetworkingConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("NetworkingConfig"`,
+		`type ContainerCreateConfigAO1NetworkingConfig struct {`,
+		"	EndpointsConfig map[string]ContainerCreateConfigAO1NetworkingConfigEndpointsConfigAnon `json:\"EndpointsConfig,omitempty\"`",
+		`func (m *ContainerCreateConfigAO1NetworkingConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateEndpointsConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ContainerCreateConfigAO1NetworkingConfig) validateEndpointsConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.EndpointsConfig) {`,
+		`	for k := range m.EndpointsConfig {`,
+		`		if swag.IsZero(m.EndpointsConfig[k]) {`,
+		`		if val, ok := m.EndpointsConfig[k]; ok {`,
+		// NOTE: fixed incorrect IsNullable status in map element
+		//`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`type ContainerCreateConfigAO1NetworkingConfigEndpointsConfigAnon struct {`,
+		"	Aliases []string `json:\"Aliases\"`",
+		"	DriverOpts map[string]string `json:\"DriverOpts,omitempty\"`",
+		"	EndpointID string `json:\"EndpointID,omitempty\"`",
+		"	Gateway string `json:\"Gateway,omitempty\"`",
+		"	GlobalIPV6Address string `json:\"GlobalIPv6Address,omitempty\"`",
+		"	GlobalIPV6PrefixLen int64 `json:\"GlobalIPv6PrefixLen,omitempty\"`",
+		"	IPAMConfig *ContainerCreateConfigAO1NetworkingConfigEndpointsConfigAnonIPAMConfig `json:\"IPAMConfig,omitempty\"`",
+		"	IPAddress string `json:\"IPAddress,omitempty\"`",
+		"	IPPrefixLen int64 `json:\"IPPrefixLen,omitempty\"`",
+		"	IPV6Gateway string `json:\"IPv6Gateway,omitempty\"`",
+		"	Links []string `json:\"Links\"`",
+		"	MacAddress string `json:\"MacAddress,omitempty\"`",
+		"	NetworkID string `json:\"NetworkID,omitempty\"`",
+		`func (m *ContainerCreateConfigAO1NetworkingConfigEndpointsConfigAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateIPAMConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ContainerCreateConfigAO1NetworkingConfigEndpointsConfigAnon) validateIPAMConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.IPAMConfig) {`,
+		`	if m.IPAMConfig != nil {`,
+		`		if err := m.IPAMConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("IPAMConfig"`,
+		`type ContainerCreateConfigAO1NetworkingConfigEndpointsConfigAnonIPAMConfig struct {`,
+		"	IPV4Address string `json:\"IPv4Address,omitempty\"`",
+		"	IPV6Address string `json:\"IPv6Address,omitempty\"`",
+		"	LinkLocalIps []string `json:\"LinkLocalIPs\"`",
+		`func (m *ContainerCreateConfigAO1NetworkingConfigEndpointsConfigAnonIPAMConfig) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type ContainerCreateConfigHostConfigAO0LogConfig struct {`,
+		"	Config map[string]string `json:\"Config,omitempty\"`",
+		"	Type string `json:\"Type,omitempty\"`",
+		`func (m *ContainerCreateConfigHostConfigAO0LogConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateType(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var containerCreateConfigHostConfigAO0LogConfigTypeTypePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"json-file\",\"syslog\",\"journald\",\"gelf\",\"fluentd\",\"awslogs\",\"splunk\",\"etwlogs\",\"none\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		containerCreateConfigHostConfigAO0LogConfigTypeTypePropEnum = append(containerCreateConfigHostConfigAO0LogConfigTypeTypePropEnum, v`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeJSONFile string = "json-file"`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeSyslog string = "syslog"`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeJournald string = "journald"`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeGelf string = "gelf"`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeFluentd string = "fluentd"`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeAwslogs string = "awslogs"`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeSplunk string = "splunk"`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeEtwlogs string = "etwlogs"`,
+		`	ContainerCreateConfigHostConfigAO0LogConfigTypeNone string = "none"`,
+		`func (m *ContainerCreateConfigHostConfigAO0LogConfig) validateTypeEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, containerCreateConfigHostConfigAO0LogConfigTypeTypePropEnum); err != nil {`,
+		`func (m *ContainerCreateConfigHostConfigAO0LogConfig) validateType(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Type) {`,
+		`	if err := m.validateTypeEnum("HostConfig"+"."+"LogConfig"+"."+"Type", "body", m.Type); err != nil {`,
+		`type ContainerCreateConfigHostConfigAO0RestartPolicy struct {`,
+		"	MaximumRetryCount int64 `json:\"MaximumRetryCount,omitempty\"`",
+		"	Name string `json:\"Name,omitempty\"`",
+		`func (m *ContainerCreateConfigHostConfigAO0RestartPolicy) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+	}, []string{
+		// not expected
+		`			if val != nil {`,
+	},
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: resources.go
+	flattenRun.AddExpectations("resources.go", []string{
+		`type Resources struct {`,
+		"	BlkioWeight uint16 `json:\"BlkioWeight,omitempty\"`",
+		"	CgroupParent string `json:\"CgroupParent,omitempty\"`",
+		"	CPUShares int64 `json:\"CpuShares,omitempty\"`",
+		"	Memory int64 `json:\"Memory,omitempty\"`",
+		`func (m *Resources) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateBlkioWeight(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Resources) validateBlkioWeight(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.BlkioWeight) {`,
+		`	if err := validate.MinimumInt("BlkioWeight", "body", int64(m.BlkioWeight), 0, false); err != nil {`,
+		`	if err := validate.MaximumInt("BlkioWeight", "body", int64(m.BlkioWeight), 1000, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("resources.go", flattenRun.ExpectedFor("Resources").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: networking_config.go
+	flattenRun.AddExpectations("networking_config.go", []string{
+		`type NetworkingConfig struct {`,
+		"	EndpointsConfig NetworkingConfigEndpointsConfig `json:\"EndpointsConfig,omitempty\"`",
+		`func (m *NetworkingConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateEndpointsConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NetworkingConfig) validateEndpointsConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.EndpointsConfig) {`,
+		`	if err := m.EndpointsConfig.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("EndpointsConfig"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("networking_config.go", []string{
+		`type NetworkingConfig struct {`,
+		"	EndpointsConfig map[string]NetworkingConfigEndpointsConfigAnon `json:\"EndpointsConfig,omitempty\"`",
+		`func (m *NetworkingConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateEndpointsConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NetworkingConfig) validateEndpointsConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.EndpointsConfig) {`,
+		`	for k := range m.EndpointsConfig {`,
+		`		if swag.IsZero(m.EndpointsConfig[k]) {`,
+		`		if val, ok := m.EndpointsConfig[k]; ok {`,
+		// NOTE: fixed incorrect IsNullable status for map
+		//`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`type NetworkingConfigEndpointsConfigAnon struct {`,
+		"	Aliases []string `json:\"Aliases\"`",
+		"	DriverOpts map[string]string `json:\"DriverOpts,omitempty\"`",
+		"	EndpointID string `json:\"EndpointID,omitempty\"`",
+		"	Gateway string `json:\"Gateway,omitempty\"`",
+		"	GlobalIPV6Address string `json:\"GlobalIPv6Address,omitempty\"`",
+		"	GlobalIPV6PrefixLen int64 `json:\"GlobalIPv6PrefixLen,omitempty\"`",
+		"	IPAMConfig *NetworkingConfigEndpointsConfigAnonIPAMConfig `json:\"IPAMConfig,omitempty\"`",
+		"	IPAddress string `json:\"IPAddress,omitempty\"`",
+		"	IPPrefixLen int64 `json:\"IPPrefixLen,omitempty\"`",
+		"	IPV6Gateway string `json:\"IPv6Gateway,omitempty\"`",
+		"	Links []string `json:\"Links\"`",
+		"	MacAddress string `json:\"MacAddress,omitempty\"`",
+		"	NetworkID string `json:\"NetworkID,omitempty\"`",
+		`func (m *NetworkingConfigEndpointsConfigAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateIPAMConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NetworkingConfigEndpointsConfigAnon) validateIPAMConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.IPAMConfig) {`,
+		`	if m.IPAMConfig != nil {`,
+		`		if err := m.IPAMConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("IPAMConfig"`,
+		`type NetworkingConfigEndpointsConfigAnonIPAMConfig struct {`,
+		"	IPV4Address string `json:\"IPv4Address,omitempty\"`",
+		"	IPV6Address string `json:\"IPv6Address,omitempty\"`",
+		"	LinkLocalIps []string `json:\"LinkLocalIPs\"`",
+		`func (m *NetworkingConfigEndpointsConfigAnonIPAMConfig) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+	}, []string{
+		// not expected
+		`			if val != nil {`,
+	},
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: endpoint_settings.go
+	flattenRun.AddExpectations("endpoint_settings.go", []string{
+		`type EndpointSettings struct {`,
+		"	Aliases []string `json:\"Aliases\"`",
+		"	DriverOpts map[string]string `json:\"DriverOpts,omitempty\"`",
+		"	EndpointID string `json:\"EndpointID,omitempty\"`",
+		"	Gateway string `json:\"Gateway,omitempty\"`",
+		"	GlobalIPV6Address string `json:\"GlobalIPv6Address,omitempty\"`",
+		"	GlobalIPV6PrefixLen int64 `json:\"GlobalIPv6PrefixLen,omitempty\"`",
+		"	IPAMConfig *EndpointIPAMConfig `json:\"IPAMConfig,omitempty\"`",
+		"	IPAddress string `json:\"IPAddress,omitempty\"`",
+		"	IPPrefixLen int64 `json:\"IPPrefixLen,omitempty\"`",
+		"	IPV6Gateway string `json:\"IPv6Gateway,omitempty\"`",
+		"	Links []string `json:\"Links\"`",
+		"	MacAddress string `json:\"MacAddress,omitempty\"`",
+		"	NetworkID string `json:\"NetworkID,omitempty\"`",
+		`func (m *EndpointSettings) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateIPAMConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *EndpointSettings) validateIPAMConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.IPAMConfig) {`,
+		`	if m.IPAMConfig != nil {`,
+		`		if err := m.IPAMConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("IPAMConfig"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("endpoint_settings.go", []string{
+		`type EndpointSettings struct {`,
+		"	Aliases []string `json:\"Aliases\"`",
+		"	DriverOpts map[string]string `json:\"DriverOpts,omitempty\"`",
+		"	EndpointID string `json:\"EndpointID,omitempty\"`",
+		"	Gateway string `json:\"Gateway,omitempty\"`",
+		"	GlobalIPV6Address string `json:\"GlobalIPv6Address,omitempty\"`",
+		"	GlobalIPV6PrefixLen int64 `json:\"GlobalIPv6PrefixLen,omitempty\"`",
+		"	IPAMConfig *EndpointSettingsIPAMConfig `json:\"IPAMConfig,omitempty\"`",
+		"	IPAddress string `json:\"IPAddress,omitempty\"`",
+		"	IPPrefixLen int64 `json:\"IPPrefixLen,omitempty\"`",
+		"	IPV6Gateway string `json:\"IPv6Gateway,omitempty\"`",
+		"	Links []string `json:\"Links\"`",
+		"	MacAddress string `json:\"MacAddress,omitempty\"`",
+		"	NetworkID string `json:\"NetworkID,omitempty\"`",
+		`func (m *EndpointSettings) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateIPAMConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *EndpointSettings) validateIPAMConfig(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.IPAMConfig) {`,
+		`	if m.IPAMConfig != nil {`,
+		`		if err := m.IPAMConfig.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("IPAMConfig"`,
+		`type EndpointSettingsIPAMConfig struct {`,
+		"	IPV4Address string `json:\"IPv4Address,omitempty\"`",
+		"	IPV6Address string `json:\"IPv6Address,omitempty\"`",
+		"	LinkLocalIps []string `json:\"LinkLocalIPs\"`",
+		`func (m *EndpointSettingsIPAMConfig) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	//expandRun.AddExpectations("networking_config.go", flattenRun.ExpectedFor("NetworkingConfig").ExpectedLines, todo, noLines, noLines)
+	// load expectations for model: networking_config_endpoints_config.go
+	flattenRun.AddExpectations("networking_config_endpoints_config.go", []string{
+		`type NetworkingConfigEndpointsConfig map[string]*EndpointSettings`,
+		`func (m NetworkingConfigEndpointsConfig) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", NetworkingConfigEndpointsConfig(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+func initFixtureSimpleAllOf() {
+	// testing ../fixtures/bugs/1487/fixture-simple-allOf.yaml with flatten and expand (--skip-flatten)
+
+	/* we test various composition combinations, including nested, and nested isolated with a properties (e.g. issue #1479) */
+
+	f := newModelFixture("../fixtures/bugs/1487/fixture-simple-allOf.yaml", "fixture for nested allOf with ref")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: not_really_composed_thing_all_of0.go
+	flattenRun.AddExpectations("not_really_composed_thing_all_of0.go", []string{
+		`type NotReallyComposedThingAllOf0 struct {`,
+		"	Prop0 strfmt.UUID `json:\"prop0,omitempty\"`",
+		`func (m *NotReallyComposedThingAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp0(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NotReallyComposedThingAllOf0) validateProp0(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop0) {`,
+		`	if err := validate.FormatOf("prop0", "body", "uuid", m.Prop0.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: not_really_composed_thing.go
+	expandRun.AddExpectations("not_really_composed_thing.go", []string{
+		`type NotReallyComposedThing struct {`,
+		"	Prop0 strfmt.UUID `json:\"prop0,omitempty\"`",
+		`func (m *NotReallyComposedThing) UnmarshalJSON(raw []byte) error {`,
+		`	var dataAO0 struct {`,
+		"		Prop0 strfmt.UUID `json:\"prop0,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO0); err != nil {`,
+		`	m.Prop0 = dataAO0.Prop0`,
+		`func (m NotReallyComposedThing) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 1`,
+		`	var dataAO0 struct {`,
+		"		Prop0 strfmt.UUID `json:\"prop0,omitempty\"`",
+		`	dataAO0.Prop0 = m.Prop0`,
+		`	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0`,
+		`	if errAO0 != nil {`,
+		`		return nil, errAO0`,
+		`	_parts = append(_parts, jsonDataAO0`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *NotReallyComposedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp0(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NotReallyComposedThing) validateProp0(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop0) {`,
+		`	if err := validate.FormatOf("prop0", "body", "uuid", m.Prop0.String(), formats); err != nil {`,
+		`func (m *NotReallyComposedThing) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *NotReallyComposedThing) UnmarshalBinary(b []byte) error {`,
+		`	var res NotReallyComposedThing`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: simple_nested_object_all_of1.go
+	flattenRun.AddExpectations("simple_nested_object_all_of1.go", []string{
+		`type SimpleNestedObjectAllOf1 struct {`,
+		"	Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`func (m *SimpleNestedObjectAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp3(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *SimpleNestedObjectAllOf1) validateProp3(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop3) {`,
+		`	if err := validate.FormatOf("prop3", "body", "uuid", m.Prop3.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: break_nested_object_all_of1_prop7.go
+	flattenRun.AddExpectations("break_nested_object_all_of1_prop7.go", []string{
+		`type BreakNestedObjectAllOf1Prop7 struct {`,
+		`	BreakNestedObjectAllOf1Prop7AllOf0`,
+		`	BreakNestedObjectAllOf1Prop7AllOf1`,
+		`func (m *BreakNestedObjectAllOf1Prop7) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.BreakNestedObjectAllOf1Prop7AllOf0.Validate(formats); err != nil {`,
+		`	if err := m.BreakNestedObjectAllOf1Prop7AllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: composed_thing.go
+	flattenRun.AddExpectations("composed_thing.go", []string{
+		`type ComposedThing struct {`,
+		`	ComposedThingAllOf0`,
+		`	ComposedThingAllOf1`,
+		`func (m *ComposedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.ComposedThingAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.ComposedThingAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: composed_thing.go
+	expandRun.AddExpectations("composed_thing.go", []string{
+		`type ComposedThing struct {`,
+		"	Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		"	Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`func (m *ComposedThing) UnmarshalJSON(raw []byte) error {`,
+		`	var dataAO0 struct {`,
+		"		Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO0); err != nil {`,
+		`	m.Prop1 = dataAO0.Prop1`,
+		`	var dataAO1 struct {`,
+		"		Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop2 = dataAO1.Prop2`,
+		`func (m ComposedThing) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	var dataAO0 struct {`,
+		"		Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`	dataAO0.Prop1 = m.Prop1`,
+		`	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0`,
+		`	if errAO0 != nil {`,
+		`		return nil, errAO0`,
+		`	_parts = append(_parts, jsonDataAO0`,
+		`	var dataAO1 struct {`,
+		"		Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`	dataAO1.Prop2 = m.Prop2`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *ComposedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ComposedThing) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "uuid", m.Prop1.String(), formats); err != nil {`,
+		`func (m *ComposedThing) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "uuid", m.Prop2.String(), formats); err != nil {`,
+		`func (m *ComposedThing) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *ComposedThing) UnmarshalBinary(b []byte) error {`,
+		`	var res ComposedThing`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: break_nested_object.go
+	flattenRun.AddExpectations("break_nested_object.go", []string{
+		`type BreakNestedObject struct {`,
+		`	SimpleNestedObject`,
+		`	BreakNestedObjectAllOf1`,
+		`func (m *BreakNestedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.SimpleNestedObject.Validate(formats); err != nil {`,
+		`	if err := m.BreakNestedObjectAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: break_nested_object.go
+	expandRun.AddExpectations("break_nested_object.go", []string{
+		`type BreakNestedObject struct {`,
+		`	BreakNestedObjectAllOf0`,
+		"	Prop6 strfmt.UUID `json:\"prop6,omitempty\"`",
+		`	Prop7 struct {`,
+		"		Prop8 int64 `json:\"prop8,omitempty\"`",
+		"		Prop9 int64 `json:\"prop9,omitempty\"`",
+		"	} `json:\"prop7,omitempty\"`",
+		`func (m *BreakNestedObject) UnmarshalJSON(raw []byte) error {`,
+		`	var aO0 BreakNestedObjectAllOf0`,
+		`	if err := swag.ReadJSON(raw, &aO0); err != nil {`,
+		`	m.BreakNestedObjectAllOf0 = aO0`,
+		`	var dataAO1 struct {`,
+		"		Prop6 strfmt.UUID `json:\"prop6,omitempty\"`",
+		`		Prop7 struct {`,
+		"			Prop8 int64 `json:\"prop8,omitempty\"`",
+		"			Prop9 int64 `json:\"prop9,omitempty\"`",
+		"		} `json:\"prop7,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop6 = dataAO1.Prop6`,
+		`	m.Prop7 = dataAO1.Prop7`,
+		`func (m BreakNestedObject) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	aO0, err := swag.WriteJSON(m.BreakNestedObjectAllOf0`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO0`,
+		`	var dataAO1 struct {`,
+		"		Prop6 strfmt.UUID `json:\"prop6,omitempty\"`",
+		`		Prop7 struct {`,
+		"			Prop8 int64 `json:\"prop8,omitempty\"`",
+		"			Prop9 int64 `json:\"prop9,omitempty\"`",
+		"		} `json:\"prop7,omitempty\"`",
+		`	dataAO1.Prop6 = m.Prop6`,
+		`	dataAO1.Prop7 = m.Prop7`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *BreakNestedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.BreakNestedObjectAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.validateProp6(formats); err != nil {`,
+		`	if err := m.validateProp7(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *BreakNestedObject) validateProp6(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop6) {`,
+		`	if err := validate.FormatOf("prop6", "body", "uuid", m.Prop6.String(), formats); err != nil {`,
+		`func (m *BreakNestedObject) validateProp7(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop7) {`,
+		`	if err := validate.MinimumInt("prop7"+"."+"prop8", "body", int64(m.Prop7.Prop8), 12, false); err != nil {`,
+		`	if err := validate.MaximumInt("prop7"+"."+"prop9", "body", int64(m.Prop7.Prop9), 12, false); err != nil {`,
+		`func (m *BreakNestedObject) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *BreakNestedObject) UnmarshalBinary(b []byte) error {`,
+		`	var res BreakNestedObject`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+		`type BreakNestedObjectAllOf0 struct {`,
+		`	BreakNestedObjectAllOf0AllOf0`,
+		"	Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`func (m *BreakNestedObjectAllOf0) UnmarshalJSON(raw []byte) error {`,
+		`	var aO0 BreakNestedObjectAllOf0AllOf0`,
+		`	if err := swag.ReadJSON(raw, &aO0); err != nil {`,
+		`	m.BreakNestedObjectAllOf0AllOf0 = aO0`,
+		`	var dataAO1 struct {`,
+		"		Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop3 = dataAO1.Prop3`,
+		`func (m BreakNestedObjectAllOf0) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	aO0, err := swag.WriteJSON(m.BreakNestedObjectAllOf0AllOf0`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO0`,
+		`	var dataAO1 struct {`,
+		"		Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`	dataAO1.Prop3 = m.Prop3`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *BreakNestedObjectAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.BreakNestedObjectAllOf0AllOf0.Validate(formats); err != nil {`,
+		`	if err := m.validateProp3(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *BreakNestedObjectAllOf0) validateProp3(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop3) {`,
+		`	if err := validate.FormatOf("prop3", "body", "uuid", m.Prop3.String(), formats); err != nil {`,
+		`func (m *BreakNestedObjectAllOf0) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *BreakNestedObjectAllOf0) UnmarshalBinary(b []byte) error {`,
+		`	var res BreakNestedObjectAllOf0`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+		`type BreakNestedObjectAllOf0AllOf0 struct {`,
+		"	Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		"	Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`func (m *BreakNestedObjectAllOf0AllOf0) UnmarshalJSON(raw []byte) error {`,
+		`	var dataAO0 struct {`,
+		"		Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO0); err != nil {`,
+		`	m.Prop1 = dataAO0.Prop1`,
+		`	var dataAO1 struct {`,
+		"		Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop2 = dataAO1.Prop2`,
+		`func (m BreakNestedObjectAllOf0AllOf0) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	var dataAO0 struct {`,
+		"		Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`	dataAO0.Prop1 = m.Prop1`,
+		`	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0`,
+		`	if errAO0 != nil {`,
+		`		return nil, errAO0`,
+		`	_parts = append(_parts, jsonDataAO0`,
+		`	var dataAO1 struct {`,
+		"		Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`	dataAO1.Prop2 = m.Prop2`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *BreakNestedObjectAllOf0AllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *BreakNestedObjectAllOf0AllOf0) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "uuid", m.Prop1.String(), formats); err != nil {`,
+		`func (m *BreakNestedObjectAllOf0AllOf0) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "uuid", m.Prop2.String(), formats); err != nil {`,
+		`func (m *BreakNestedObjectAllOf0AllOf0) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *BreakNestedObjectAllOf0AllOf0) UnmarshalBinary(b []byte) error {`,
+		`	var res BreakNestedObjectAllOf0AllOf0`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: deep_nested_object_all_of1_all_of1.go
+	flattenRun.AddExpectations("deep_nested_object_all_of1_all_of1.go", []string{
+		`type DeepNestedObjectAllOf1AllOf1 struct {`,
+		"	Prop5 strfmt.Date `json:\"prop5,omitempty\"`",
+		`func (m *DeepNestedObjectAllOf1AllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp5(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *DeepNestedObjectAllOf1AllOf1) validateProp5(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop5) {`,
+		`	if err := validate.FormatOf("prop5", "body", "date", m.Prop5.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: deep_nested_object.go
+	flattenRun.AddExpectations("deep_nested_object.go", []string{
+		`type DeepNestedObject struct {`,
+		`	SimpleNestedObject`,
+		`	DeepNestedObjectAllOf1`,
+		`func (m *DeepNestedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.SimpleNestedObject.Validate(formats); err != nil {`,
+		`	if err := m.DeepNestedObjectAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: deep_nested_object.go
+	expandRun.AddExpectations("deep_nested_object.go", []string{
+		`type DeepNestedObject struct {`,
+		`	DeepNestedObjectAllOf0`,
+		`	DeepNestedObjectAllOf1`,
+		`func (m *DeepNestedObject) UnmarshalJSON(raw []byte) error {`,
+		`	var aO0 DeepNestedObjectAllOf0`,
+		`	if err := swag.ReadJSON(raw, &aO0); err != nil {`,
+		`	m.DeepNestedObjectAllOf0 = aO0`,
+		`	var aO1 DeepNestedObjectAllOf1`,
+		`	if err := swag.ReadJSON(raw, &aO1); err != nil {`,
+		`	m.DeepNestedObjectAllOf1 = aO1`,
+		`func (m DeepNestedObject) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	aO0, err := swag.WriteJSON(m.DeepNestedObjectAllOf0`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO0`,
+		`	aO1, err := swag.WriteJSON(m.DeepNestedObjectAllOf1`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *DeepNestedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.DeepNestedObjectAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.DeepNestedObjectAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *DeepNestedObject) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *DeepNestedObject) UnmarshalBinary(b []byte) error {`,
+		`	var res DeepNestedObject`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+		`type DeepNestedObjectAllOf0 struct {`,
+		`	DeepNestedObjectAllOf0AllOf0`,
+		"	Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`func (m *DeepNestedObjectAllOf0) UnmarshalJSON(raw []byte) error {`,
+		`	var aO0 DeepNestedObjectAllOf0AllOf0`,
+		`	if err := swag.ReadJSON(raw, &aO0); err != nil {`,
+		`	m.DeepNestedObjectAllOf0AllOf0 = aO0`,
+		`	var dataAO1 struct {`,
+		"		Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop3 = dataAO1.Prop3`,
+		`func (m DeepNestedObjectAllOf0) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	aO0, err := swag.WriteJSON(m.DeepNestedObjectAllOf0AllOf0`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO0`,
+		`	var dataAO1 struct {`,
+		"		Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`	dataAO1.Prop3 = m.Prop3`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *DeepNestedObjectAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.DeepNestedObjectAllOf0AllOf0.Validate(formats); err != nil {`,
+		`	if err := m.validateProp3(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *DeepNestedObjectAllOf0) validateProp3(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop3) {`,
+		`	if err := validate.FormatOf("prop3", "body", "uuid", m.Prop3.String(), formats); err != nil {`,
+		`func (m *DeepNestedObjectAllOf0) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *DeepNestedObjectAllOf0) UnmarshalBinary(b []byte) error {`,
+		`	var res DeepNestedObjectAllOf0`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+		`type DeepNestedObjectAllOf0AllOf0 struct {`,
+		"	Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		"	Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`func (m *DeepNestedObjectAllOf0AllOf0) UnmarshalJSON(raw []byte) error {`,
+		`	var dataAO0 struct {`,
+		"		Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO0); err != nil {`,
+		`	m.Prop1 = dataAO0.Prop1`,
+		`	var dataAO1 struct {`,
+		"		Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop2 = dataAO1.Prop2`,
+		`func (m DeepNestedObjectAllOf0AllOf0) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	var dataAO0 struct {`,
+		"		Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`	dataAO0.Prop1 = m.Prop1`,
+		`	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0`,
+		`	if errAO0 != nil {`,
+		`		return nil, errAO0`,
+		`	_parts = append(_parts, jsonDataAO0`,
+		`	var dataAO1 struct {`,
+		"		Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`	dataAO1.Prop2 = m.Prop2`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *DeepNestedObjectAllOf0AllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *DeepNestedObjectAllOf0AllOf0) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "uuid", m.Prop1.String(), formats); err != nil {`,
+		`func (m *DeepNestedObjectAllOf0AllOf0) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "uuid", m.Prop2.String(), formats); err != nil {`,
+		`func (m *DeepNestedObjectAllOf0AllOf0) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *DeepNestedObjectAllOf0AllOf0) UnmarshalBinary(b []byte) error {`,
+		`	var res DeepNestedObjectAllOf0AllOf0`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+		`type DeepNestedObjectAllOf1 struct {`,
+		"	Prop4 strfmt.UUID `json:\"prop4,omitempty\"`",
+		"	Prop5 strfmt.Date `json:\"prop5,omitempty\"`",
+		`func (m *DeepNestedObjectAllOf1) UnmarshalJSON(raw []byte) error {`,
+		`	var dataAO0 struct {`,
+		"		Prop4 strfmt.UUID `json:\"prop4,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO0); err != nil {`,
+		`	m.Prop4 = dataAO0.Prop4`,
+		`	var dataAO1 struct {`,
+		"		Prop5 strfmt.Date `json:\"prop5,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop5 = dataAO1.Prop5`,
+		`func (m DeepNestedObjectAllOf1) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	var dataAO0 struct {`,
+		"		Prop4 strfmt.UUID `json:\"prop4,omitempty\"`",
+		`	dataAO0.Prop4 = m.Prop4`,
+		`	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0`,
+		`	if errAO0 != nil {`,
+		`		return nil, errAO0`,
+		`	_parts = append(_parts, jsonDataAO0`,
+		`	var dataAO1 struct {`,
+		"		Prop5 strfmt.Date `json:\"prop5,omitempty\"`",
+		`	dataAO1.Prop5 = m.Prop5`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *DeepNestedObjectAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp4(formats); err != nil {`,
+		`	if err := m.validateProp5(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *DeepNestedObjectAllOf1) validateProp4(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop4) {`,
+		`	if err := validate.FormatOf("prop4", "body", "uuid", m.Prop4.String(), formats); err != nil {`,
+		`func (m *DeepNestedObjectAllOf1) validateProp5(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop5) {`,
+		`	if err := validate.FormatOf("prop5", "body", "date", m.Prop5.String(), formats); err != nil {`,
+		`func (m *DeepNestedObjectAllOf1) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *DeepNestedObjectAllOf1) UnmarshalBinary(b []byte) error {`,
+		`	var res DeepNestedObjectAllOf1`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: break_nested_object_all_of1.go
+	flattenRun.AddExpectations("break_nested_object_all_of1.go", []string{
+		`type BreakNestedObjectAllOf1 struct {`,
+		"	Prop6 strfmt.UUID `json:\"prop6,omitempty\"`",
+		"	Prop7 *BreakNestedObjectAllOf1Prop7 `json:\"prop7,omitempty\"`",
+		`func (m *BreakNestedObjectAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp6(formats); err != nil {`,
+		`	if err := m.validateProp7(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *BreakNestedObjectAllOf1) validateProp6(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop6) {`,
+		`	if err := validate.FormatOf("prop6", "body", "uuid", m.Prop6.String(), formats); err != nil {`,
+		`func (m *BreakNestedObjectAllOf1) validateProp7(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop7) {`,
+		`	if m.Prop7 != nil {`,
+		`		if err := m.Prop7.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("prop7"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: not_really_composed_thing.go
+	flattenRun.AddExpectations("not_really_composed_thing.go", []string{
+		`type NotReallyComposedThing struct {`,
+		`	NotReallyComposedThingAllOf0`,
+		`func (m *NotReallyComposedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.NotReallyComposedThingAllOf0.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("not_really_composed_thing.go", []string{
+		`type NotReallyComposedThing struct {`,
+		"	Prop0 strfmt.UUID `json:\"prop0,omitempty\"`",
+		`func (m *NotReallyComposedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp0(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NotReallyComposedThing) validateProp0(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop0) {`,
+		`	if err := validate.FormatOf("prop0", "body", "uuid", m.Prop0.String(), formats); err != nil {`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: simple_nested_object.go
+	flattenRun.AddExpectations("simple_nested_object.go", []string{
+		`type SimpleNestedObject struct {`,
+		`	ComposedThing`,
+		`	SimpleNestedObjectAllOf1`,
+		`func (m *SimpleNestedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.ComposedThing.Validate(formats); err != nil {`,
+		`	if err := m.SimpleNestedObjectAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: simple_nested_object.go
+	expandRun.AddExpectations("simple_nested_object.go", []string{
+		`type SimpleNestedObject struct {`,
+		`	SimpleNestedObjectAllOf0`,
+		"	Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`func (m *SimpleNestedObject) UnmarshalJSON(raw []byte) error {`,
+		`	var aO0 SimpleNestedObjectAllOf0`,
+		`	if err := swag.ReadJSON(raw, &aO0); err != nil {`,
+		`	m.SimpleNestedObjectAllOf0 = aO0`,
+		`	var dataAO1 struct {`,
+		"		Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop3 = dataAO1.Prop3`,
+		`func (m SimpleNestedObject) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	aO0, err := swag.WriteJSON(m.SimpleNestedObjectAllOf0`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO0`,
+		`	var dataAO1 struct {`,
+		"		Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		`	dataAO1.Prop3 = m.Prop3`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *SimpleNestedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.SimpleNestedObjectAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.validateProp3(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *SimpleNestedObject) validateProp3(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop3) {`,
+		`	if err := validate.FormatOf("prop3", "body", "uuid", m.Prop3.String(), formats); err != nil {`,
+		`func (m *SimpleNestedObject) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *SimpleNestedObject) UnmarshalBinary(b []byte) error {`,
+		`	var res SimpleNestedObject`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+		`type SimpleNestedObjectAllOf0 struct {`,
+		"	Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		"	Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`func (m *SimpleNestedObjectAllOf0) UnmarshalJSON(raw []byte) error {`,
+		`	var dataAO0 struct {`,
+		"		Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO0); err != nil {`,
+		`	m.Prop1 = dataAO0.Prop1`,
+		`	var dataAO1 struct {`,
+		"		Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`	if err := swag.ReadJSON(raw, &dataAO1); err != nil {`,
+		`	m.Prop2 = dataAO1.Prop2`,
+		`func (m SimpleNestedObjectAllOf0) MarshalJSON() ([]byte, error) {`,
+		`	_parts := make([][]byte, 0, 2`,
+		`	var dataAO0 struct {`,
+		"		Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`	dataAO0.Prop1 = m.Prop1`,
+		`	jsonDataAO0, errAO0 := swag.WriteJSON(dataAO0`,
+		`	if errAO0 != nil {`,
+		`		return nil, errAO0`,
+		`	_parts = append(_parts, jsonDataAO0`,
+		`	var dataAO1 struct {`,
+		"		Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`	dataAO1.Prop2 = m.Prop2`,
+		`	jsonDataAO1, errAO1 := swag.WriteJSON(dataAO1`,
+		`	if errAO1 != nil {`,
+		`		return nil, errAO1`,
+		`	_parts = append(_parts, jsonDataAO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *SimpleNestedObjectAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *SimpleNestedObjectAllOf0) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "uuid", m.Prop1.String(), formats); err != nil {`,
+		`func (m *SimpleNestedObjectAllOf0) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "uuid", m.Prop2.String(), formats); err != nil {`,
+		`func (m *SimpleNestedObjectAllOf0) MarshalBinary() ([]byte, error) {`,
+		`	if m == nil {`,
+		`		return nil, nil`,
+		`	return swag.WriteJSON(m`,
+		`func (m *SimpleNestedObjectAllOf0) UnmarshalBinary(b []byte) error {`,
+		`	var res SimpleNestedObjectAllOf0`,
+		`	if err := swag.ReadJSON(b, &res); err != nil {`,
+		`	*m = res`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: break_nested_object_all_of1_prop7_all_of0.go
+	flattenRun.AddExpectations("break_nested_object_all_of1_prop7_all_of0.go", []string{
+		`type BreakNestedObjectAllOf1Prop7AllOf0 struct {`,
+		"	Prop8 int64 `json:\"prop8,omitempty\"`",
+		`func (m *BreakNestedObjectAllOf1Prop7AllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp8(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *BreakNestedObjectAllOf1Prop7AllOf0) validateProp8(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop8) {`,
+		`	if err := validate.MinimumInt("prop8", "body", int64(m.Prop8), 12, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: deep_nested_object_all_of1_all_of0.go
+	flattenRun.AddExpectations("deep_nested_object_all_of1_all_of0.go", []string{
+		`type DeepNestedObjectAllOf1AllOf0 struct {`,
+		"	Prop4 strfmt.UUID `json:\"prop4,omitempty\"`",
+		`func (m *DeepNestedObjectAllOf1AllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp4(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *DeepNestedObjectAllOf1AllOf0) validateProp4(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop4) {`,
+		`	if err := validate.FormatOf("prop4", "body", "uuid", m.Prop4.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: break_nested_object_all_of1_prop7_all_of1.go
+	flattenRun.AddExpectations("break_nested_object_all_of1_prop7_all_of1.go", []string{
+		`type BreakNestedObjectAllOf1Prop7AllOf1 struct {`,
+		"	Prop9 int64 `json:\"prop9,omitempty\"`",
+		`func (m *BreakNestedObjectAllOf1Prop7AllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp9(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *BreakNestedObjectAllOf1Prop7AllOf1) validateProp9(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop9) {`,
+		`	if err := validate.MaximumInt("prop9", "body", int64(m.Prop9), 12, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: composed_thing_all_of0.go
+	flattenRun.AddExpectations("composed_thing_all_of0.go", []string{
+		`type ComposedThingAllOf0 struct {`,
+		"	Prop1 strfmt.UUID `json:\"prop1,omitempty\"`",
+		`func (m *ComposedThingAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ComposedThingAllOf0) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "uuid", m.Prop1.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: composed_thing_all_of1.go
+	flattenRun.AddExpectations("composed_thing_all_of1.go", []string{
+		`type ComposedThingAllOf1 struct {`,
+		"	Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		`func (m *ComposedThingAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ComposedThingAllOf1) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "uuid", m.Prop2.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: deep_nested_object_all_of1.go
+	flattenRun.AddExpectations("deep_nested_object_all_of1.go", []string{
+		`type DeepNestedObjectAllOf1 struct {`,
+		`	DeepNestedObjectAllOf1AllOf0`,
+		`	DeepNestedObjectAllOf1AllOf1`,
+		`func (m *DeepNestedObjectAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.DeepNestedObjectAllOf1AllOf0.Validate(formats); err != nil {`,
+		`	if err := m.DeepNestedObjectAllOf1AllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixtureComplexAllOf() {
+	// testing ../fixtures/bugs/1487/fixture-complex-allOf.yaml with flatten and expand (--skip-flatten)
+
+	/*
+	 */
+	f := newModelFixture("../fixtures/bugs/1487/fixture-complex-allOf.yaml", "fixture for nested allOf with ref")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: aliased_date.go
+	flattenRun.AddExpectations("aliased_date.go", []string{
+		`type AliasedDate strfmt.Date`,
+		`func (m AliasedDate) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("aliased_date.go", flattenRun.ExpectedFor("AliasedDate").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: object_mix_all_of2.go
+	flattenRun.AddExpectations("object_mix_all_of2.go", []string{
+		`type ObjectMixAllOf2 struct {`,
+		"	Prop2 *ObjectMixAllOf2Prop2 `json:\"prop2,omitempty\"`",
+		`func (m *ObjectMixAllOf2) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ObjectMixAllOf2) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if m.Prop2 != nil {`,
+		`		if err := m.Prop2.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("prop2"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: object_mix.go
+	flattenRun.AddExpectations("object_mix.go", []string{
+		`type ObjectMix struct {`,
+		`	ObjectMixAllOf1`,
+		`	ObjectMixAllOf2`,
+		`func (m *ObjectMix) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.ObjectMixAllOf1.Validate(formats); err != nil {`,
+		`	if err := m.ObjectMixAllOf2.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("object_mix.go", []string{
+		`type ObjectMix struct {`,
+		`	Prop1 struct {`,
+		`		ObjectMixProp1AllOf0`,
+		`		ObjectMixProp1AllOf1`,
+		"	} `json:\"prop1,omitempty\"`",
+		`	Prop2 struct {`,
+		`		ObjectMixProp2AllOf0`,
+		`		ObjectMixProp2AllOf1`,
+		"	} `json:\"prop2,omitempty\"`",
+		`func (m *ObjectMix) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ObjectMix) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`func (m *ObjectMix) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`type ObjectMixProp1AllOf0 strfmt.Date`,
+		`func (m ObjectMixProp1AllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type ObjectMixProp1AllOf1 strfmt.Date`,
+		`func (m ObjectMixProp1AllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type ObjectMixProp2AllOf0 strfmt.Date`,
+		`func (m ObjectMixProp2AllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type ObjectMixProp2AllOf1 strfmt.Date`,
+		`func (m ObjectMixProp2AllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_slices_of_aliases.go
+	flattenRun.AddExpectations("all_of_slices_of_aliases.go", []string{
+		`type AllOfSlicesOfAliases struct {`,
+		`	AllOfSlicesOfAliasesAllOf0`,
+		`	AllOfSlicesOfAliasesAllOf1`,
+		`func (m *AllOfSlicesOfAliases) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.AllOfSlicesOfAliasesAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.AllOfSlicesOfAliasesAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("all_of_slices_of_aliases.go", []string{
+		`type AllOfSlicesOfAliases struct {`,
+		"	Prop1 []strfmt.Date `json:\"prop1\"`",
+		"	Prop2 []*strfmt.Date `json:\"prop2\"`",
+		`func (m *AllOfSlicesOfAliases) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfSlicesOfAliases) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	iProp1Size := int64(len(m.Prop1)`,
+		`	if err := validate.MaxItems("prop1", "body", iProp1Size, 10); err != nil {`,
+		`	for i := 0; i < len(m.Prop1); i++ {`,
+		`		if err := validate.FormatOf("prop1"+"."+strconv.Itoa(i), "body", "date", m.Prop1[i].String(), formats); err != nil {`,
+		`func (m *AllOfSlicesOfAliases) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	iProp2Size := int64(len(m.Prop2)`,
+		`	if err := validate.MaxItems("prop2", "body", iProp2Size, 20); err != nil {`,
+		`	for i := 0; i < len(m.Prop2); i++ {`,
+		`		if swag.IsZero(m.Prop2[i]) {`,
+		`		if err := validate.FormatOf("prop2"+"."+strconv.Itoa(i), "body", "date", m.Prop2[i].String(), formats); err != nil {`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_aliases.go
+	flattenRun.AddExpectations("all_of_aliases.go", []string{
+		`type AllOfAliases struct {`,
+		`	AliasedDate`,
+		`	AliasedNullableDate`,
+		`func (m *AllOfAliases) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.AliasedDate.Validate(formats); err != nil {`,
+		`	if err := m.AliasedNullableDate.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("all_of_aliases.go", []string{
+		`type AllOfAliases struct {`,
+		`	AllOfAliasesAllOf0`,
+		`	AllOfAliasesAllOf1`,
+		`func (m *AllOfAliases) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.AllOfAliasesAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.AllOfAliasesAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type AllOfAliasesAllOf0 strfmt.Date`,
+		`func (m AllOfAliasesAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		// NOTE: the x-nullable has not been honored here
+		// so we don't have: `type AllOfAliasesAllOf1 *strfmt.Date`,
+		// this is by design, since nullability is honored by the container of the alias, not the
+		// alias itself. An allOf branch container is composing types, not pointers.
+		`type AllOfAliasesAllOf1 strfmt.Date`,
+		`func (m AllOfAliasesAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: object_mix_all_of1.go
+	flattenRun.AddExpectations("object_mix_all_of1.go", []string{
+		`type ObjectMixAllOf1 struct {`,
+		"	Prop1 *ObjectMixAllOf1Prop1 `json:\"prop1,omitempty\"`",
+		`func (m *ObjectMixAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ObjectMixAllOf1) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if m.Prop1 != nil {`,
+		`		if err := m.Prop1.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("prop1"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_slices_of_aliases_all_of0.go
+	flattenRun.AddExpectations("all_of_slices_of_aliases_all_of0.go", []string{
+		`type AllOfSlicesOfAliasesAllOf0 struct {`,
+		"	Prop1 []AliasedDate `json:\"prop1\"`",
+		`func (m *AllOfSlicesOfAliasesAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfSlicesOfAliasesAllOf0) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	iProp1Size := int64(len(m.Prop1)`,
+		`	if err := validate.MaxItems("prop1", "body", iProp1Size, 10); err != nil {`,
+		`	for i := 0; i < len(m.Prop1); i++ {`,
+		`		if err := m.Prop1[i].Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("prop1" + "." + strconv.Itoa(i)`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: slice_of_all_of.go
+	flattenRun.AddExpectations("slice_of_all_of.go", []string{
+		`type SliceOfAllOf []*SliceOfAllOfItems`,
+		`func (m SliceOfAllOf) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.UniqueItems("", "body", m); err != nil {`,
+		`	for i := 0; i < len(m); i++ {`,
+		`		if swag.IsZero(m[i]) {`,
+		`		if m[i] != nil {`,
+		`			if err := m[i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("slice_of_all_of.go", []string{
+		`type SliceOfAllOf []*SliceOfAllOfItems0`,
+		`func (m SliceOfAllOf) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.UniqueItems("", "body", m); err != nil {`,
+		`	for i := 0; i < len(m); i++ {`,
+		`		if swag.IsZero(m[i]) {`,
+		`		if m[i] != nil {`,
+		`			if err := m[i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+		`type SliceOfAllOfItems0 struct {`,
+		"	Prop0 strfmt.UUID `json:\"prop0,omitempty\"`",
+		`	SliceOfAllOfItems0AllOf1`,
+		`func (m *SliceOfAllOfItems0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp0(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *SliceOfAllOfItems0) validateProp0(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop0) {`,
+		`	if err := validate.FormatOf("prop0", "body", "uuid", m.Prop0.String(), formats); err != nil {`,
+		`type SliceOfAllOfItems0AllOf1 []interface{`,
+		// empty validation
+		"func (m SliceOfAllOfItems0AllOf1) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: object_mix_all_of2_prop2.go
+	flattenRun.AddExpectations("object_mix_all_of2_prop2.go", []string{
+		`type ObjectMixAllOf2Prop2 struct {`,
+		`	AliasedDate`,
+		`	AliasedNullableDate`,
+		`func (m *ObjectMixAllOf2Prop2) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.AliasedDate.Validate(formats); err != nil {`,
+		`	if err := m.AliasedNullableDate.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: slice_of_all_of_items_all_of0.go
+	flattenRun.AddExpectations("slice_of_all_of_items_all_of0.go", []string{
+		`type SliceOfAllOfItemsAllOf0 struct {`,
+		"	Prop0 strfmt.UUID `json:\"prop0,omitempty\"`",
+		`func (m *SliceOfAllOfItemsAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp0(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *SliceOfAllOfItemsAllOf0) validateProp0(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop0) {`,
+		`	if err := validate.FormatOf("prop0", "body", "uuid", m.Prop0.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: slice_of_interfaces.go
+	flattenRun.AddExpectations("slice_of_interfaces.go", []string{
+		`type SliceOfInterfaces []interface{`,
+		// empty validation
+		"func (m SliceOfInterfaces) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("slice_of_interfaces.go", flattenRun.ExpectedFor("SliceOfInterfaces").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: slice_of_interfaces_with_validation.go
+	flattenRun.AddExpectations("slice_of_interfaces_with_validation.go", []string{
+		`type SliceOfInterfacesWithValidation []interface{`,
+		`func (m SliceOfInterfacesWithValidation) Validate(formats strfmt.Registry) error {`,
+		`	iSliceOfInterfacesWithValidationSize := int64(len(m)`,
+		`	if err := validate.MaxItems("", "body", iSliceOfInterfacesWithValidationSize, 10); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("slice_of_interfaces_with_validation.go", flattenRun.ExpectedFor("SliceOfInterfacesWithValidation").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: aliased_nullable_date.go
+	flattenRun.AddExpectations("aliased_nullable_date.go", []string{
+		`type AliasedNullableDate strfmt.Date`,
+		`func (m AliasedNullableDate) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("aliased_nullable_date.go", flattenRun.ExpectedFor("AliasedNullableDate").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: slice_mix.go
+	flattenRun.AddExpectations("slice_mix.go", []string{
+		`type SliceMix struct {`,
+		`	SliceOfAllOf`,
+		`	SliceOfInterfaces`,
+		`func (m *SliceMix) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.SliceOfAllOf.Validate(formats); err != nil {`,
+		`	if err := m.SliceOfInterfaces.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		warning,
+		noLines)
+
+	expandRun.AddExpectations("slice_mix.go", []string{
+		`type SliceMix struct {`,
+		`	SliceMixAllOf0`,
+		`	SliceMixAllOf1`,
+		`func (m *SliceMix) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.SliceMixAllOf0.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type SliceMixAllOf0 []*SliceMixAllOf0Items0`,
+		`func (m SliceMixAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.UniqueItems("", "body", m); err != nil {`,
+		`	for i := 0; i < len(m); i++ {`,
+		`		if swag.IsZero(m[i]) {`,
+		`		if m[i] != nil {`,
+		`			if err := m[i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+		`type SliceMixAllOf0Items0 struct {`,
+		"	Prop0 strfmt.UUID `json:\"prop0,omitempty\"`",
+		`	SliceMixAllOf0Items0AllOf1`,
+		`func (m *SliceMixAllOf0Items0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp0(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *SliceMixAllOf0Items0) validateProp0(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop0) {`,
+		`	if err := validate.FormatOf("prop0", "body", "uuid", m.Prop0.String(), formats); err != nil {`,
+		`type SliceMixAllOf0Items0AllOf1 []interface{`,
+		`type SliceMixAllOf1 []interface{`,
+		// empty validation
+		"func (m SliceMixAllOf0Items0AllOf1) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: object_mix_all_of1_prop1.go
+	flattenRun.AddExpectations("object_mix_all_of1_prop1.go", []string{
+		`type ObjectMixAllOf1Prop1 struct {`,
+		`	AliasedDate`,
+		`	AliasedNullableDate`,
+		`func (m *ObjectMixAllOf1Prop1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.AliasedDate.Validate(formats); err != nil {`,
+		`	if err := m.AliasedNullableDate.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: slice_of_all_of_items.go
+	flattenRun.AddExpectations("slice_of_all_of_items.go", []string{
+		`type SliceOfAllOfItems struct {`,
+		`	SliceOfAllOfItemsAllOf0`,
+		`	SliceOfInterfaces`,
+		`func (m *SliceOfAllOfItems) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.SliceOfAllOfItemsAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.SliceOfInterfaces.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_slices_of_aliases_all_of1.go
+	flattenRun.AddExpectations("all_of_slices_of_aliases_all_of1.go", []string{
+		`type AllOfSlicesOfAliasesAllOf1 struct {`,
+		"	Prop2 []*AliasedNullableDate `json:\"prop2\"`",
+		`func (m *AllOfSlicesOfAliasesAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfSlicesOfAliasesAllOf1) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	iProp2Size := int64(len(m.Prop2)`,
+		`	if err := validate.MaxItems("prop2", "body", iProp2Size, 20); err != nil {`,
+		`	for i := 0; i < len(m.Prop2); i++ {`,
+		`		if swag.IsZero(m.Prop2[i]) {`,
+		`		if m.Prop2[i] != nil {`,
+		`			if err := m.Prop2[i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName("prop2" + "." + strconv.Itoa(i)`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixtureIsNullable() {
+	// testing ../fixtures/bugs/1487/fixture-is-nullable.yaml with flatten and expand (--skip-flatten)
+
+	/* just an elementary check with the x-nullable tag
+	 */
+	f := newModelFixture("../fixtures/bugs/1487/fixture-is-nullable.yaml", "fixture for x-nullable flag")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: thing_with_nullable_dates.go
+	flattenRun.AddExpectations("thing_with_nullable_dates.go", []string{
+		`type ThingWithNullableDates struct {`,
+		"	Prop1 strfmt.Date `json:\"prop1,omitempty\"`",
+		"	Prop2 *strfmt.Date `json:\"prop2,omitempty\"`",
+		`func (m *ThingWithNullableDates) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ThingWithNullableDates) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "date", m.Prop1.String(), formats); err != nil {`,
+		`func (m *ThingWithNullableDates) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "date", m.Prop2.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("thing_with_nullable_dates.go", flattenRun.ExpectedFor("ThingWithNullableDates").ExpectedLines, todo, noLines, noLines)
+
+}
+
+func initFixtureItching() {
+	// testing ../fixtures/bugs/1487/fixture-itching.yaml with flatten and expand (--skip-flatten)
+
+	/*
+		This one regroups a number of itching cases, essentially around additionalProperties.
+		In particular, we test some things with empty objects (no properties) which have additionalProperties of diverse sorts.
+		We also added here some funny models using the special types Files, string format: binary and interface{}
+		These special cases do not correspond to actual API specs: we use them to verify the internal behavior of the general.
+	*/
+	f := newModelFixture("../fixtures/bugs/1487/fixture-itching.yaml", "fixture for additionalProperties")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: top_level_format_issue_my_alternate_file.go
+	flattenRun.AddExpectations("top_level_format_issue_my_alternate_file.go", []string{
+		`import "io"`,
+		`type TopLevelFormatIssueMyAlternateFile io.ReadCloser`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: not_validated_additional_props.go
+	flattenRun.AddExpectations("not_validated_additional_props.go", []string{
+		`type NotValidatedAdditionalProps struct {`,
+		"	Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		"	NotValidatedAdditionalProps map[string]map[string]map[string]string `json:\"-\"`",
+		`func (m *NotValidatedAdditionalProps) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NotValidatedAdditionalProps) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "uuid", m.Prop2.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("not_validated_additional_props.go", flattenRun.ExpectedFor("NotValidatedAdditionalProps").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: aliased_nullable_file.go
+	flattenRun.AddExpectations("aliased_nullable_file.go", []string{
+		`import "io"`,
+		`type AliasedNullableFile io.ReadCloser`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("aliased_nullable_file.go", flattenRun.ExpectedFor("AliasedNullableFile").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: empty_object_with_additional_nullable_primitive.go
+	flattenRun.AddExpectations("empty_object_with_additional_nullable_primitive.go", []string{
+		`type EmptyObjectWithAdditionalNullablePrimitive map[string]*strfmt.Date`,
+		`func (m EmptyObjectWithAdditionalNullablePrimitive) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if err := validate.FormatOf(k, "body", "date", m[k].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("empty_object_with_additional_nullable_primitive.go", flattenRun.ExpectedFor("EmptyObjectWithAdditionalNullablePrimitive").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: empty_object_with_additional_alias.go
+	flattenRun.AddExpectations("empty_object_with_additional_alias.go", []string{
+		`type EmptyObjectWithAdditionalAlias map[string]AliasedThing`,
+		`func (m EmptyObjectWithAdditionalAlias) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", EmptyObjectWithAdditionalAlias(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("empty_object_with_additional_alias.go", []string{
+		`type EmptyObjectWithAdditionalAlias map[string]EmptyObjectWithAdditionalAliasAnon`,
+		`func (m EmptyObjectWithAdditionalAlias) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type EmptyObjectWithAdditionalAliasAnon struct {`,
+		"	Prop1 strfmt.Date `json:\"prop1,omitempty\"`",
+		`func (m *EmptyObjectWithAdditionalAliasAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *EmptyObjectWithAdditionalAliasAnon) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "date", m.Prop1.String(), formats); err != nil {`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nullable_thing.go
+	flattenRun.AddExpectations("nullable_thing.go", []string{
+		`type NullableThing strfmt.Date`,
+		`func (m NullableThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("nullable_thing.go", flattenRun.ExpectedFor("NullableThing").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: slice_of_aliased_files.go
+	flattenRun.AddExpectations("slice_of_aliased_files.go", []string{
+		`type SliceOfAliasedFiles []AliasedFile`,
+		`func (m SliceOfAliasedFiles) Validate(formats strfmt.Registry) error {`,
+		`	iSliceOfAliasedFilesSize := int64(len(m)`,
+		`	if err := validate.MinItems("", "body", iSliceOfAliasedFilesSize, 4); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("slice_of_aliased_files.go", []string{
+		`type SliceOfAliasedFiles []io.ReadCloser`,
+		`func (m SliceOfAliasedFiles) Validate(formats strfmt.Registry) error {`,
+		`	iSliceOfAliasedFilesSize := int64(len(m)`,
+		`	if err := validate.MinItems("", "body", iSliceOfAliasedFilesSize, 4); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: empty_object_with_additional_non_nullable_primitive.go
+	flattenRun.AddExpectations("empty_object_with_additional_non_nullable_primitive.go", []string{
+		`type EmptyObjectWithAdditionalNonNullablePrimitive map[string]strfmt.Date`,
+		`func (m EmptyObjectWithAdditionalNonNullablePrimitive) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if err := validate.FormatOf(k, "body", "date", m[k].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("empty_object_with_additional_non_nullable_primitive.go", flattenRun.ExpectedFor("EmptyObjectWithAdditionalNonNullablePrimitive").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: good_old_format_issue.go
+	flattenRun.AddExpectations("good_old_format_issue.go", []string{
+		`type GoodOldFormatIssue struct {`,
+		"	AlternateFile GoodOldFormatIssueAlternateFile `json:\"alternateFile,omitempty\"`",
+		"	AnotherFile io.ReadCloser `json:\"anotherFile,omitempty\"`",
+		"	MyBytes strfmt.Base64 `json:\"myBytes,omitempty\"`",
+		"	MyFile io.ReadCloser `json:\"myFile\"`",
+		"	ThisAliasedFile AliasedFile `json:\"thisAliasedFile,omitempty\"`",
+		"	ThisAlternateAliasedFile AliasedTypeFile `json:\"thisAlternateAliasedFile,omitempty\"`",
+		"	ThisNullableAliasedFile *AliasedNullableFile `json:\"thisNullableAliasedFile,omitempty\"`",
+		"	ThisNullableAlternateAliasedFile *AliasedTypeNullableFile `json:\"thisNullableAlternateAliasedFile,omitempty\"`",
+		`func (m *GoodOldFormatIssue) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMyBytes(formats); err != nil {`,
+		`	if err := m.validateMyFile(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *GoodOldFormatIssue) validateMyBytes(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.MyBytes) {`,
+		`	if err := validate.FormatOf("myBytes", "body", "byte", m.MyBytes.String(), formats); err != nil {`,
+		`func (m *GoodOldFormatIssue) validateMyFile(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("myFile", "body", io.ReadCloser(m.MyFile)); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("good_old_format_issue.go", []string{
+		`type GoodOldFormatIssue struct {`,
+		"	AlternateFile io.ReadCloser `json:\"alternateFile,omitempty\"`",
+		"	AnotherFile io.ReadCloser `json:\"anotherFile,omitempty\"`",
+		"	MyBytes strfmt.Base64 `json:\"myBytes,omitempty\"`",
+		"	MyFile io.ReadCloser `json:\"myFile\"`",
+		"	ThisAliasedFile io.ReadCloser `json:\"thisAliasedFile,omitempty\"`",
+		"	ThisAlternateAliasedFile io.ReadCloser `json:\"thisAlternateAliasedFile,omitempty\"`",
+		"	ThisNullableAliasedFile io.ReadCloser `json:\"thisNullableAliasedFile,omitempty\"`",
+		"	ThisNullableAlternateAliasedFile io.ReadCloser `json:\"thisNullableAlternateAliasedFile,omitempty\"`",
+		`func (m *GoodOldFormatIssue) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMyBytes(formats); err != nil {`,
+		`	if err := m.validateMyFile(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *GoodOldFormatIssue) validateMyBytes(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.MyBytes) {`,
+		`	if err := validate.FormatOf("myBytes", "body", "byte", m.MyBytes.String(), formats); err != nil {`,
+		`func (m *GoodOldFormatIssue) validateMyFile(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("myFile", "body", io.ReadCloser(m.MyFile)); err != nil {`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: empty_object_with_additional_slice_additional_properties_items.go
+	flattenRun.AddExpectations("empty_object_with_additional_slice_additional_properties_items.go", []string{
+		`type EmptyObjectWithAdditionalSliceAdditionalPropertiesItems struct {`,
+		"	DummyProp1 strfmt.Date `json:\"dummyProp1,omitempty\"`",
+		`func (m *EmptyObjectWithAdditionalSliceAdditionalPropertiesItems) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateDummyProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *EmptyObjectWithAdditionalSliceAdditionalPropertiesItems) validateDummyProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.DummyProp1) {`,
+		`	if err := validate.FormatOf("dummyProp1", "body", "date", m.DummyProp1.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: not_validated_additional_props_slice.go
+	flattenRun.AddExpectations("not_validated_additional_props_slice.go", []string{
+		`type NotValidatedAdditionalPropsSlice struct {`,
+		"	Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		"	NotValidatedAdditionalPropsSlice map[string][]map[string]map[string]string `json:\"-\"`",
+		`func (m *NotValidatedAdditionalPropsSlice) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NotValidatedAdditionalPropsSlice) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "uuid", m.Prop2.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: aliased_type_file.go
+	flattenRun.AddExpectations("aliased_type_file.go", []string{
+		`import "io"`,
+		`type AliasedTypeFile io.ReadCloser`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("aliased_type_file.go", flattenRun.ExpectedFor("AliasedTypeFile").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: object_with_empty_object.go
+	flattenRun.AddExpectations("object_with_empty_object.go", []string{
+		`type ObjectWithEmptyObject struct {`,
+		"	EmptyObj EmptyObjectWithAdditionalAlias `json:\"emptyObj,omitempty\"`",
+		"	NonEmptyObj *NullableThing `json:\"nonEmptyObj,omitempty\"`",
+		`func (m *ObjectWithEmptyObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateEmptyObj(formats); err != nil {`,
+		`	if err := m.validateNonEmptyObj(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ObjectWithEmptyObject) validateEmptyObj(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.EmptyObj) {`,
+		`	if err := m.EmptyObj.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("emptyObj"`,
+		`func (m *ObjectWithEmptyObject) validateNonEmptyObj(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.NonEmptyObj) {`,
+		`	if m.NonEmptyObj != nil {`,
+		`		if err := m.NonEmptyObj.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("nonEmptyObj"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("object_with_empty_object.go", []string{
+		`type ObjectWithEmptyObject struct {`,
+		"	EmptyObj map[string]ObjectWithEmptyObjectEmptyObjAnon `json:\"emptyObj,omitempty\"`",
+		"	NonEmptyObj *strfmt.Date `json:\"nonEmptyObj,omitempty\"`",
+		`func (m *ObjectWithEmptyObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateEmptyObj(formats); err != nil {`,
+		`	if err := m.validateNonEmptyObj(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ObjectWithEmptyObject) validateEmptyObj(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.EmptyObj) {`,
+		`	for k := range m.EmptyObj {`,
+		`		if swag.IsZero(m.EmptyObj[k]) {`,
+		`		if val, ok := m.EmptyObj[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`func (m *ObjectWithEmptyObject) validateNonEmptyObj(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.NonEmptyObj) {`,
+		`	if err := validate.FormatOf("nonEmptyObj", "body", "date", m.NonEmptyObj.String(), formats); err != nil {`,
+		`type ObjectWithEmptyObjectEmptyObjAnon struct {`,
+		"	Prop1 strfmt.Date `json:\"prop1,omitempty\"`",
+		`func (m *ObjectWithEmptyObjectEmptyObjAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ObjectWithEmptyObjectEmptyObjAnon) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "date", m.Prop1.String(), formats); err != nil {`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: aliased_file.go
+	flattenRun.AddExpectations("aliased_file.go", []string{
+		`import "io"`,
+		`type AliasedFile io.ReadCloser`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("aliased_file.go", flattenRun.ExpectedFor("AliasedFile").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: empty_object_with_additional_slice.go
+	flattenRun.AddExpectations("empty_object_with_additional_slice.go", []string{
+		`type EmptyObjectWithAdditionalSlice map[string][]EmptyObjectWithAdditionalSliceAdditionalPropertiesItems`,
+		`func (m EmptyObjectWithAdditionalSlice) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", EmptyObjectWithAdditionalSlice(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if err := validate.Required(k, "body", m[k]); err != nil {`,
+		`		for i := 0; i < len(m[k]); i++ {`,
+		`			if err := m[k][i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("empty_object_with_additional_slice.go", []string{
+		`type EmptyObjectWithAdditionalSlice map[string][]EmptyObjectWithAdditionalSliceItems0`,
+		`func (m EmptyObjectWithAdditionalSlice) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", EmptyObjectWithAdditionalSlice(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if err := validate.Required(k, "body", m[k]); err != nil {`,
+		`		for i := 0; i < len(m[k]); i++ {`,
+		`			if err := m[k][i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+		`type EmptyObjectWithAdditionalSliceItems0 struct {`,
+		"	DummyProp1 strfmt.Date `json:\"dummyProp1,omitempty\"`",
+		`func (m *EmptyObjectWithAdditionalSliceItems0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateDummyProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *EmptyObjectWithAdditionalSliceItems0) validateDummyProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.DummyProp1) {`,
+		`	if err := validate.FormatOf("dummyProp1", "body", "date", m.DummyProp1.String(), formats); err != nil {`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_aliased_file.go
+	flattenRun.AddExpectations("additional_aliased_file.go", []string{
+		`type AdditionalAliasedFile interface{`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("additional_aliased_file.go", flattenRun.ExpectedFor("AdditionalAliasedFile").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: good_old_format_issue_alternate_file.go
+	flattenRun.AddExpectations("good_old_format_issue_alternate_file.go", []string{
+		`import "io"`,
+		`type GoodOldFormatIssueAlternateFile io.ReadCloser`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: empty_object_with_additional_nested_slice_additional_properties_items_items_items.go
+	flattenRun.AddExpectations("empty_object_with_additional_nested_slice_additional_properties_items_items_items.go", []string{
+		`type EmptyObjectWithAdditionalNestedSliceAdditionalPropertiesItemsItemsItems struct {`,
+		"	DummyProp1 strfmt.Date `json:\"dummyProp1,omitempty\"`",
+		`func (m *EmptyObjectWithAdditionalNestedSliceAdditionalPropertiesItemsItemsItems) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateDummyProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *EmptyObjectWithAdditionalNestedSliceAdditionalPropertiesItemsItemsItems) validateDummyProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.DummyProp1) {`,
+		`	if err := validate.FormatOf("dummyProp1", "body", "date", m.DummyProp1.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: aliased_thing.go
+	flattenRun.AddExpectations("aliased_thing.go", []string{
+		`type AliasedThing struct {`,
+		"	Prop1 strfmt.Date `json:\"prop1,omitempty\"`",
+		`func (m *AliasedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AliasedThing) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	if err := validate.FormatOf("prop1", "body", "date", m.Prop1.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("aliased_thing.go", flattenRun.ExpectedFor("AliasedThing").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: additional_file.go
+	flattenRun.AddExpectations("additional_file.go", []string{
+		`type AdditionalFile struct {`,
+		"	DirName string `json:\"dirName,omitempty\"`",
+		"	AdditionalFile map[string]io.ReadCloser `json:\"-\"`",
+		// empty validation
+		"func (m *AdditionalFile) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("additional_file.go", flattenRun.ExpectedFor("AdditionalFile").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: aliased_type_nullable_file.go
+	flattenRun.AddExpectations("aliased_type_nullable_file.go", []string{
+		`import "io"`,
+		`type AliasedTypeNullableFile io.ReadCloser`,
+	},
+		// not expected
+		validatable,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("aliased_type_nullable_file.go", flattenRun.ExpectedFor("AliasedTypeNullableFile").ExpectedLines, validatable, noLines, noLines)
+
+	// load expectations for model: top_level_format_issue.go
+	flattenRun.AddExpectations("top_level_format_issue.go", []string{
+		`type TopLevelFormatIssue struct {`,
+		"	MyAlternateFile TopLevelFormatIssueMyAlternateFile `json:\"myAlternateFile,omitempty\"`",
+		"	MyFile io.ReadCloser `json:\"myFile,omitempty\"`",
+		// empty validation
+		"func (m *TopLevelFormatIssue) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("top_level_format_issue.go", []string{
+		`type TopLevelFormatIssue struct {`,
+		"	MyAlternateFile io.ReadCloser `json:\"myAlternateFile,omitempty\"`",
+		"	MyFile io.ReadCloser `json:\"myFile,omitempty\"`",
+		// empty validation
+		"func (m *TopLevelFormatIssue) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: enums_with_additional_props.go
+	flattenRun.AddExpectations("enums_with_additional_props.go", []string{
+		`type EnumsWithAdditionalProps map[string]interface{`,
+		`var enumsWithAdditionalPropsEnum []interface{`,
+		`	var res []EnumsWithAdditionalProps`,
+		"	if err := json.Unmarshal([]byte(`[\"{ \\\"a\\\": 1, \\\"b\\\": 2 }\",\"{ \\\"a\\\": 3, \\\"b\\\": 4 }\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		enumsWithAdditionalPropsEnum = append(enumsWithAdditionalPropsEnum, v`,
+		`func (m *EnumsWithAdditionalProps) validateEnumsWithAdditionalPropsEnum(path, location string, value EnumsWithAdditionalProps) error {`,
+		`	if err := validate.Enum(path, location, value, enumsWithAdditionalPropsEnum); err != nil {`,
+		`var enumsWithAdditionalPropsValueEnum []interface{`,
+		`	var res []interface{`,
+		"	if err := json.Unmarshal([]byte(`[\"{ \\\"b\\\": 2 }\",\"{ \\\"b\\\": 4 }\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		enumsWithAdditionalPropsValueEnum = append(enumsWithAdditionalPropsValueEnum, v`,
+		`func (m *EnumsWithAdditionalProps) validateEnumsWithAdditionalPropsValueEnum(path, location string, value interface{}) error {`,
+		`	if err := validate.Enum(path, location, value, enumsWithAdditionalPropsValueEnum); err != nil {`,
+		`func (m EnumsWithAdditionalProps) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if err := m.validateEnumsWithAdditionalPropsValueEnum(k, "body", m[k]); err != nil {`,
+		`	if err := m.validateEnumsWithAdditionalPropsEnum("", "body", m); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("enums_with_additional_props.go", flattenRun.ExpectedFor("EnumsWithAdditionalProps").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: empty_object_with_additional_nested_slice.go
+	flattenRun.AddExpectations("empty_object_with_additional_nested_slice.go", []string{
+		`type EmptyObjectWithAdditionalNestedSlice map[string][][][]EmptyObjectWithAdditionalNestedSliceAdditionalPropertiesItemsItemsItems`,
+		`func (m EmptyObjectWithAdditionalNestedSlice) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", EmptyObjectWithAdditionalNestedSlice(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if err := validate.Required(k, "body", m[k]); err != nil {`,
+		`		for i := 0; i < len(m[k]); i++ {`,
+		`			for ii := 0; ii < len(m[k][i]); ii++ {`,
+		`				for iii := 0; iii < len(m[k][i][ii]); iii++ {`,
+		`					if err := m[k][i][ii][iii].Validate(formats); err != nil {`,
+		`						if ve, ok := err.(*errors.Validation); ok {`,
+		`							return ve.ValidateName(k + "." + strconv.Itoa(i) + "." + strconv.Itoa(ii) + "." + strconv.Itoa(iii)`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("empty_object_with_additional_nested_slice.go", []string{
+		`type EmptyObjectWithAdditionalNestedSlice map[string][][][]EmptyObjectWithAdditionalNestedSliceItems0`,
+		`func (m EmptyObjectWithAdditionalNestedSlice) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", EmptyObjectWithAdditionalNestedSlice(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if err := validate.Required(k, "body", m[k]); err != nil {`,
+		`		for i := 0; i < len(m[k]); i++ {`,
+		`			for ii := 0; ii < len(m[k][i]); ii++ {`,
+		`				for iii := 0; iii < len(m[k][i][ii]); iii++ {`,
+		`					if err := m[k][i][ii][iii].Validate(formats); err != nil {`,
+		`						if ve, ok := err.(*errors.Validation); ok {`,
+		`							return ve.ValidateName(k + "." + strconv.Itoa(i) + "." + strconv.Itoa(ii) + "." + strconv.Itoa(iii)`,
+		`		return errors.CompositeValidationError(res...`,
+		`type EmptyObjectWithAdditionalNestedSliceItems0 struct {`,
+		"	DummyProp1 strfmt.Date `json:\"dummyProp1,omitempty\"`",
+		`func (m *EmptyObjectWithAdditionalNestedSliceItems0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateDummyProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *EmptyObjectWithAdditionalNestedSliceItems0) validateDummyProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.DummyProp1) {`,
+		`	if err := validate.FormatOf("dummyProp1", "body", "date", m.DummyProp1.String(), formats); err != nil {`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: empty_object_with_additional_nullable.go
+	flattenRun.AddExpectations("empty_object_with_additional_nullable.go", []string{
+		`type EmptyObjectWithAdditionalNullable map[string]NullableThing`,
+		`func (m EmptyObjectWithAdditionalNullable) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("empty_object_with_additional_nullable.go", []string{
+		`type EmptyObjectWithAdditionalNullable map[string]*strfmt.Date`,
+		`func (m EmptyObjectWithAdditionalNullable) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if err := validate.FormatOf(k, "body", "date", m[k].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		noLines,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: not_validated_at_all.go
+	flattenRun.AddExpectations("not_validated_at_all.go", []string{
+		`type NotValidatedAtAll struct {`,
+		"	Prop2 string `json:\"prop2,omitempty\"`",
+		"	NotValidatedAtAll map[string][]map[string]map[string]string `json:\"-\"`",
+		// empty validation
+		"func (m *NotValidatedAtAll) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("not_validated_at_all.go", flattenRun.ExpectedFor("NotValidatedAtAll").ExpectedLines, todo, noLines, noLines)
+}
+
+func initFixtureAdditionalProps() {
+	// testing ../fixtures/bugs/1487/fixture-additionalProps.yaml with expand (--skip-flatten)
+
+	/* various patterns of additionalProperties
+	 */
+	f := newModelFixture("../fixtures/bugs/1487/fixture-additionalProps.yaml", "fixture for additionalProperties")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: additional_object_with_formated_thing.go
+	flattenRun.AddExpectations("additional_object_with_formated_thing.go", []string{
+		`type AdditionalObjectWithFormatedThing struct {`,
+		"	Blob *int64 `json:\"blob\"`",
+		"	AdditionalObjectWithFormatedThing map[string]strfmt.Date `json:\"-\"`",
+		`func (m *AdditionalObjectWithFormatedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateBlob(formats); err != nil {`,
+		`	for k := range m.AdditionalObjectWithFormatedThing {`,
+		`		if swag.IsZero(m.AdditionalObjectWithFormatedThing[k]) {`,
+		`		if err := validate.FormatOf(k, "body", "date", m.AdditionalObjectWithFormatedThing[k].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalObjectWithFormatedThing) validateBlob(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("blob", "body", m.Blob); err != nil {`,
+		`	if err := validate.MinimumInt("blob", "body", int64(*m.Blob), 1, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: aliased_date.go
+	flattenRun.AddExpectations("aliased_date.go", []string{
+		`type AliasedDate strfmt.Date`,
+		`func (m AliasedDate) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("aliased_date.go", flattenRun.ExpectedFor("AliasedDate").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: additional_array_of_refed_thing.go
+	flattenRun.AddExpectations("additional_array_of_refed_thing.go", []string{
+		`type AdditionalArrayOfRefedThing struct {`,
+		"	ThisOneNotRequired int64 `json:\"thisOneNotRequired,omitempty\"`",
+		"	AdditionalArrayOfRefedThing map[string][]AliasedDate `json:\"-\"`",
+		`func (m *AdditionalArrayOfRefedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateThisOneNotRequired(formats); err != nil {`,
+		`	for k := range m.AdditionalArrayOfRefedThing {`,
+		`		if swag.IsZero(m.AdditionalArrayOfRefedThing[k]) {`,
+		`		if err := validate.UniqueItems(k, "body", m.AdditionalArrayOfRefedThing[k]); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalArrayOfRefedThing[k]); i++ {`,
+		`			if err := m.AdditionalArrayOfRefedThing[k][i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalArrayOfRefedThing) validateThisOneNotRequired(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ThisOneNotRequired) {`,
+		`	if err := validate.MaximumInt("thisOneNotRequired", "body", int64(m.ThisOneNotRequired), 10, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_object_with_nullable_thing.go
+	flattenRun.AddExpectations("additional_object_with_nullable_thing.go", []string{
+		`type AdditionalObjectWithNullableThing struct {`,
+		"	Blob int64 `json:\"blob,omitempty\"`",
+		"	AdditionalObjectWithNullableThing map[string]*AliasedNullableDate `json:\"-\"`",
+		`func (m *AdditionalObjectWithNullableThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateBlob(formats); err != nil {`,
+		`	for k := range m.AdditionalObjectWithNullableThing {`,
+		`		if swag.IsZero(m.AdditionalObjectWithNullableThing[k]) {`,
+		`		if val, ok := m.AdditionalObjectWithNullableThing[k]; ok {`,
+		`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalObjectWithNullableThing) validateBlob(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Blob) {`,
+		`	if err := validate.MinimumInt("blob", "body", int64(m.Blob), 1, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_things.go
+	flattenRun.AddExpectations("additional_things.go", []string{
+		`type AdditionalThings struct {`,
+		"	Origin *string `json:\"origin\"`",
+		"	Status string `json:\"status,omitempty\"`",
+		"	AdditionalThings map[string]string `json:\"-\"`",
+		`var additionalThingsValueEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"bookshop\",\"amazon\",\"library\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		additionalThingsValueEnum = append(additionalThingsValueEnum, v`,
+		`func (m *AdditionalThings) validateAdditionalThingsValueEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, additionalThingsValueEnum); err != nil {`,
+		`func (m *AdditionalThings) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateOrigin(formats); err != nil {`,
+		`	if err := m.validateStatus(formats); err != nil {`,
+		`	for k := range m.AdditionalThings {`,
+		`		if swag.IsZero(m.AdditionalThings[k]) {`,
+		`		if err := m.validateAdditionalThingsValueEnum(k, "body", m.AdditionalThings[k]); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var additionalThingsTypeOriginPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"print\",\"e-book\",\"collection\",\"museum\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		additionalThingsTypeOriginPropEnum = append(additionalThingsTypeOriginPropEnum, v`,
+		`	AdditionalThingsOriginPrint string = "print"`,
+		`	AdditionalThingsOriginEBook string = "e-book"`,
+		`	AdditionalThingsOriginCollection string = "collection"`,
+		`	AdditionalThingsOriginMuseum string = "museum"`,
+		`func (m *AdditionalThings) validateOriginEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, additionalThingsTypeOriginPropEnum); err != nil {`,
+		`func (m *AdditionalThings) validateOrigin(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("origin", "body", m.Origin); err != nil {`,
+		`	if err := m.validateOriginEnum("origin", "body", *m.Origin); err != nil {`,
+		`var additionalThingsTypeStatusPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"OK\",\"KO\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		additionalThingsTypeStatusPropEnum = append(additionalThingsTypeStatusPropEnum, v`,
+		`	AdditionalThingsStatusOK string = "OK"`,
+		`	AdditionalThingsStatusKO string = "KO"`,
+		`func (m *AdditionalThings) validateStatusEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, additionalThingsTypeStatusPropEnum); err != nil {`,
+		`func (m *AdditionalThings) validateStatus(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Status) {`,
+		`	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: transitive_refed_thing_additional_properties.go
+	flattenRun.AddExpectations("transitive_refed_thing_additional_properties.go", []string{
+		`type TransitiveRefedThingAdditionalProperties struct {`,
+		"	A1 strfmt.DateTime `json:\"a1,omitempty\"`",
+		"	TransitiveRefedThingAdditionalProperties map[string]*NoValidationThing `json:\"-\"`",
+		`func (m *TransitiveRefedThingAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateA1(formats); err != nil {`,
+		`	for k := range m.TransitiveRefedThingAdditionalProperties {`,
+		`		if val, ok := m.TransitiveRefedThingAdditionalProperties[k]; ok {`,
+		`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *TransitiveRefedThingAdditionalProperties) validateA1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.A1) {`,
+		`	if err := validate.FormatOf("a1", "body", "date-time", m.A1.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_object.go
+	flattenRun.AddExpectations("additional_object.go", []string{
+		`type AdditionalObject struct {`,
+		"	MockID float64 `json:\"mockId,omitempty\"`",
+		"	AdditionalObject map[string]*AdditionalObjectAdditionalProperties `json:\"-\"`",
+		`func (m *AdditionalObject) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m.AdditionalObject {`,
+		`		if val, ok := m.AdditionalObject[k]; ok {`,
+		`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_slice_of_objects_additional_properties_items.go
+	flattenRun.AddExpectations("additional_slice_of_objects_additional_properties_items.go", []string{
+		`type AdditionalSliceOfObjectsAdditionalPropertiesItems struct {`,
+		"	Prop2 int64 `json:\"prop2,omitempty\"`",
+		// empty validation
+		"func (m *AdditionalSliceOfObjectsAdditionalPropertiesItems) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_slice_of_aliased_nullable_primitives.go
+	flattenRun.AddExpectations("additional_slice_of_aliased_nullable_primitives.go", []string{
+		`type AdditionalSliceOfAliasedNullablePrimitives struct {`,
+		"	Prop3 strfmt.UUID `json:\"prop3,omitempty\"`",
+		"	AdditionalSliceOfAliasedNullablePrimitives map[string][]*AliasedNullableDate `json:\"-\"`",
+		`func (m *AdditionalSliceOfAliasedNullablePrimitives) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp3(formats); err != nil {`,
+		`	for k := range m.AdditionalSliceOfAliasedNullablePrimitives {`,
+		`		if swag.IsZero(m.AdditionalSliceOfAliasedNullablePrimitives[k]) {`,
+		`		iAdditionalSliceOfAliasedNullablePrimitivesSize := int64(len(m.AdditionalSliceOfAliasedNullablePrimitives[k])`,
+		`		if err := validate.MinItems(k, "body", iAdditionalSliceOfAliasedNullablePrimitivesSize, 10); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalSliceOfAliasedNullablePrimitives[k]); i++ {`,
+		`			if swag.IsZero(m.AdditionalSliceOfAliasedNullablePrimitives[k][i]) {`,
+		`			if m.AdditionalSliceOfAliasedNullablePrimitives[k][i] != nil {`,
+		`				if err := m.AdditionalSliceOfAliasedNullablePrimitives[k][i].Validate(formats); err != nil {`,
+		`					if ve, ok := err.(*errors.Validation); ok {`,
+		`						return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalSliceOfAliasedNullablePrimitives) validateProp3(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop3) {`,
+		`	if err := validate.FormatOf("prop3", "body", "uuid", m.Prop3.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_slice_of_slice.go
+	flattenRun.AddExpectations("additional_slice_of_slice.go", []string{
+		`type AdditionalSliceOfSlice struct {`,
+		"	Prop4 strfmt.UUID `json:\"prop4,omitempty\"`",
+		"	AdditionalSliceOfSlice map[string][][]*AdditionalSliceOfSliceAdditionalPropertiesItemsItems `json:\"-\"`",
+		`func (m *AdditionalSliceOfSlice) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp4(formats); err != nil {`,
+		`	for k := range m.AdditionalSliceOfSlice {`,
+		`		if err := validate.Required(k, "body", m.AdditionalSliceOfSlice[k]); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalSliceOfSlice[k]); i++ {`,
+		`			iiAdditionalSliceOfSliceSize := int64(len(m.AdditionalSliceOfSlice[k][i])`,
+		`			if err := validate.MaxItems(k+"."+strconv.Itoa(i), "body", iiAdditionalSliceOfSliceSize, 10); err != nil {`,
+		`			for ii := 0; ii < len(m.AdditionalSliceOfSlice[k][i]); ii++ {`,
+		`				if swag.IsZero(m.AdditionalSliceOfSlice[k][i][ii]) {`,
+		`				if m.AdditionalSliceOfSlice[k][i][ii] != nil {`,
+		`					if err := m.AdditionalSliceOfSlice[k][i][ii].Validate(formats); err != nil {`,
+		`						if ve, ok := err.(*errors.Validation); ok {`,
+		`							return ve.ValidateName(k + "." + strconv.Itoa(i) + "." + strconv.Itoa(ii)`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalSliceOfSlice) validateProp4(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop4) {`,
+		`	if err := validate.FormatOf("prop4", "body", "uuid", m.Prop4.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_object_with_aliased_thing.go
+	flattenRun.AddExpectations("additional_object_with_aliased_thing.go", []string{
+		`type AdditionalObjectWithAliasedThing struct {`,
+		"	Blob int64 `json:\"blob,omitempty\"`",
+		"	AdditionalObjectWithAliasedThing map[string]AliasedDate `json:\"-\"`",
+		`func (m *AdditionalObjectWithAliasedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateBlob(formats); err != nil {`,
+		`	for k := range m.AdditionalObjectWithAliasedThing {`,
+		`		if swag.IsZero(m.AdditionalObjectWithAliasedThing[k]) {`,
+		`		if val, ok := m.AdditionalObjectWithAliasedThing[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalObjectWithAliasedThing) validateBlob(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Blob) {`,
+		`	if err := validate.MinimumInt("blob", "body", int64(m.Blob), 1, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_things_nested_additional_properties.go
+	flattenRun.AddExpectations("additional_things_nested_additional_properties.go", []string{
+		`type AdditionalThingsNestedAdditionalProperties struct {`,
+		"	PrinterAddress string `json:\"printerAddress,omitempty\"`",
+		"	PrinterCountry string `json:\"printerCountry,omitempty\"`",
+		"	PrinterDate strfmt.Date `json:\"printerDate,omitempty\"`",
+		"	AdditionalThingsNestedAdditionalProperties map[string]*AdditionalThingsNestedAdditionalPropertiesAdditionalProperties `json:\"-\"`",
+		`func (m *AdditionalThingsNestedAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validatePrinterCountry(formats); err != nil {`,
+		`	if err := m.validatePrinterDate(formats); err != nil {`,
+		`	for k := range m.AdditionalThingsNestedAdditionalProperties {`,
+		`		if val, ok := m.AdditionalThingsNestedAdditionalProperties[k]; ok {`,
+		`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var additionalThingsNestedAdditionalPropertiesTypePrinterCountryPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"US\",\"FR\",\"UK\",\"BE\",\"CA\",\"DE\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		additionalThingsNestedAdditionalPropertiesTypePrinterCountryPropEnum = append(additionalThingsNestedAdditionalPropertiesTypePrinterCountryPropEnum, v`,
+		`	AdditionalThingsNestedAdditionalPropertiesPrinterCountryUS string = "US"`,
+		`	AdditionalThingsNestedAdditionalPropertiesPrinterCountryFR string = "FR"`,
+		`	AdditionalThingsNestedAdditionalPropertiesPrinterCountryUK string = "UK"`,
+		`	AdditionalThingsNestedAdditionalPropertiesPrinterCountryBE string = "BE"`,
+		`	AdditionalThingsNestedAdditionalPropertiesPrinterCountryCA string = "CA"`,
+		`	AdditionalThingsNestedAdditionalPropertiesPrinterCountryDE string = "DE"`,
+		`func (m *AdditionalThingsNestedAdditionalProperties) validatePrinterCountryEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, additionalThingsNestedAdditionalPropertiesTypePrinterCountryPropEnum); err != nil {`,
+		`func (m *AdditionalThingsNestedAdditionalProperties) validatePrinterCountry(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.PrinterCountry) {`,
+		`	if err := m.validatePrinterCountryEnum("printerCountry", "body", m.PrinterCountry); err != nil {`,
+		`func (m *AdditionalThingsNestedAdditionalProperties) validatePrinterDate(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.PrinterDate) {`,
+		`	if err := validate.FormatOf("printerDate", "body", "date", m.PrinterDate.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: empty_object_with_additional_slice_additional_properties_items.go
+	flattenRun.AddExpectations("empty_object_with_additional_slice_additional_properties_items.go", []string{
+		`type EmptyObjectWithAdditionalSliceAdditionalPropertiesItems struct {`,
+		"	DummyProp1 strfmt.Date `json:\"dummyProp1,omitempty\"`",
+		`func (m *EmptyObjectWithAdditionalSliceAdditionalPropertiesItems) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateDummyProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *EmptyObjectWithAdditionalSliceAdditionalPropertiesItems) validateDummyProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.DummyProp1) {`,
+		`	if err := validate.FormatOf("dummyProp1", "body", "date", m.DummyProp1.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_things_nested_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("additional_things_nested_additional_properties_additional_properties.go", []string{
+		`type AdditionalThingsNestedAdditionalPropertiesAdditionalProperties struct {`,
+		"	AverageDelay strfmt.Duration `json:\"averageDelay,omitempty\"`",
+		`func (m *AdditionalThingsNestedAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAverageDelay(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalThingsNestedAdditionalPropertiesAdditionalProperties) validateAverageDelay(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.AverageDelay) {`,
+		`	if err := validate.FormatOf("averageDelay", "body", "duration", m.AverageDelay.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_slice_of_slice_additional_properties_items_items.go
+	flattenRun.AddExpectations("additional_slice_of_slice_additional_properties_items_items.go", []string{
+		`type AdditionalSliceOfSliceAdditionalPropertiesItemsItems struct {`,
+		"	Prop5 int64 `json:\"prop5,omitempty\"`",
+		`func (m *AdditionalSliceOfSliceAdditionalPropertiesItemsItems) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp5(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalSliceOfSliceAdditionalPropertiesItemsItems) validateProp5(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop5) {`,
+		`	if err := validate.MaximumInt("prop5", "body", int64(m.Prop5), 10, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_object_additional_properties.go
+	flattenRun.AddExpectations("additional_object_additional_properties.go", []string{
+		`type AdditionalObjectAdditionalProperties struct {`,
+		"	MockA string `json:\"mockA,omitempty\"`",
+		"	MockB *string `json:\"mockB\"`",
+		"	MockC float64 `json:\"mockC,omitempty\"`",
+		`func (m *AdditionalObjectAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMockA(formats); err != nil {`,
+		`	if err := m.validateMockB(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalObjectAdditionalProperties) validateMockA(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.MockA) {`,
+		"	if err := validate.Pattern(\"mockA\", \"body\", string(m.MockA), `^[A-Z]$`); err != nil {",
+		`func (m *AdditionalObjectAdditionalProperties) validateMockB(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("mockB", "body", m.MockB); err != nil {`,
+		`	if err := validate.MinLength("mockB", "body", string(*m.MockB), 1); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_transitive_refed_thing.go
+	flattenRun.AddExpectations("additional_transitive_refed_thing.go", []string{
+		`type AdditionalTransitiveRefedThing struct {`,
+		"	ThisOneNotRequired int64 `json:\"thisOneNotRequired,omitempty\"`",
+		"	AdditionalTransitiveRefedThing map[string][]*TransitiveRefedThing `json:\"-\"`",
+		`func (m *AdditionalTransitiveRefedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateThisOneNotRequired(formats); err != nil {`,
+		`	for k := range m.AdditionalTransitiveRefedThing {`,
+		`		if err := validate.Required(k, "body", m.AdditionalTransitiveRefedThing[k]); err != nil {`,
+		`		if err := validate.UniqueItems(k, "body", m.AdditionalTransitiveRefedThing[k]); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalTransitiveRefedThing[k]); i++ {`,
+		`			if swag.IsZero(m.AdditionalTransitiveRefedThing[k][i]) {`,
+		`			if m.AdditionalTransitiveRefedThing[k][i] != nil {`,
+		`				if err := m.AdditionalTransitiveRefedThing[k][i].Validate(formats); err != nil {`,
+		`					if ve, ok := err.(*errors.Validation); ok {`,
+		`						return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalTransitiveRefedThing) validateThisOneNotRequired(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ThisOneNotRequired) {`,
+		`	if err := validate.MaximumInt("thisOneNotRequired", "body", int64(m.ThisOneNotRequired), 10, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_nullable_array_thing.go
+	flattenRun.AddExpectations("additional_nullable_array_thing.go", []string{
+		`type AdditionalNullableArrayThing struct {`,
+		"	ThisOneNotRequired int64 `json:\"thisOneNotRequired,omitempty\"`",
+		"	AdditionalNullableArrayThing map[string][]strfmt.ISBN `json:\"-\"`",
+		`func (m *AdditionalNullableArrayThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateThisOneNotRequired(formats); err != nil {`,
+		`	for k := range m.AdditionalNullableArrayThing {`,
+		`		if swag.IsZero(m.AdditionalNullableArrayThing[k]) {`,
+		`		if err := validate.UniqueItems(k, "body", m.AdditionalNullableArrayThing[k]); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalNullableArrayThing[k]); i++ {`,
+		`			if err := validate.FormatOf(k+"."+strconv.Itoa(i), "body", "isbn", m.AdditionalNullableArrayThing[k][i].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalNullableArrayThing) validateThisOneNotRequired(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ThisOneNotRequired) {`,
+		`	if err := validate.MaximumInt("thisOneNotRequired", "body", int64(m.ThisOneNotRequired), 10, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_slice_of_primitives.go
+	flattenRun.AddExpectations("additional_slice_of_primitives.go", []string{
+		`type AdditionalSliceOfPrimitives struct {`,
+		"	Prop1 string `json:\"prop1,omitempty\"`",
+		"	AdditionalSliceOfPrimitives map[string][]strfmt.Date `json:\"-\"`",
+		`func (m *AdditionalSliceOfPrimitives) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m.AdditionalSliceOfPrimitives {`,
+		`		if swag.IsZero(m.AdditionalSliceOfPrimitives[k]) {`,
+		`		if err := validate.UniqueItems(k, "body", m.AdditionalSliceOfPrimitives[k]); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalSliceOfPrimitives[k]); i++ {`,
+		`			if err := validate.FormatOf(k+"."+strconv.Itoa(i), "body", "date", m.AdditionalSliceOfPrimitives[k][i].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_array_thing.go
+	flattenRun.AddExpectations("additional_array_thing.go", []string{
+		`type AdditionalArrayThing struct {`,
+		"	ThisOneNotRequired int64 `json:\"thisOneNotRequired,omitempty\"`",
+		"	AdditionalArrayThing map[string][]strfmt.UUID `json:\"-\"`",
+		`func (m *AdditionalArrayThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateThisOneNotRequired(formats); err != nil {`,
+		`	for k := range m.AdditionalArrayThing {`,
+		`		if swag.IsZero(m.AdditionalArrayThing[k]) {`,
+		`		if err := validate.UniqueItems(k, "body", m.AdditionalArrayThing[k]); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalArrayThing[k]); i++ {`,
+		`			if err := validate.FormatOf(k+"."+strconv.Itoa(i), "body", "uuid", m.AdditionalArrayThing[k][i].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalArrayThing) validateThisOneNotRequired(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ThisOneNotRequired) {`,
+		`	if err := validate.MaximumInt("thisOneNotRequired", "body", int64(m.ThisOneNotRequired), 10, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: interface_thing.go
+	flattenRun.AddExpectations("interface_thing.go", []string{
+		`type InterfaceThing interface{`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: empty_object_with_additional_slice.go
+	flattenRun.AddExpectations("empty_object_with_additional_slice.go", []string{
+		`type EmptyObjectWithAdditionalSlice map[string][]EmptyObjectWithAdditionalSliceAdditionalPropertiesItems`,
+		`func (m EmptyObjectWithAdditionalSlice) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", EmptyObjectWithAdditionalSlice(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if err := validate.Required(k, "body", m[k]); err != nil {`,
+		`		for i := 0; i < len(m[k]); i++ {`,
+		`			if err := m[k][i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_slice_of_objects.go
+	flattenRun.AddExpectations("additional_slice_of_objects.go", []string{
+		`type AdditionalSliceOfObjects struct {`,
+		"	Prop1 string `json:\"prop1,omitempty\"`",
+		"	AdditionalSliceOfObjects map[string][]*AdditionalSliceOfObjectsAdditionalPropertiesItems `json:\"-\"`",
+		`func (m *AdditionalSliceOfObjects) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m.AdditionalSliceOfObjects {`,
+		`		if err := validate.Required(k, "body", m.AdditionalSliceOfObjects[k]); err != nil {`,
+		`		if err := validate.UniqueItems(k, "body", m.AdditionalSliceOfObjects[k]); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalSliceOfObjects[k]); i++ {`,
+		`			if swag.IsZero(m.AdditionalSliceOfObjects[k][i]) {`,
+		`			if m.AdditionalSliceOfObjects[k][i] != nil {`,
+		`				if err := m.AdditionalSliceOfObjects[k][i].Validate(formats); err != nil {`,
+		`					if ve, ok := err.(*errors.Validation); ok {`,
+		`						return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_things_nested.go
+	flattenRun.AddExpectations("additional_things_nested.go", []string{
+		`type AdditionalThingsNested struct {`,
+		"	Origin string `json:\"origin,omitempty\"`",
+		"	AdditionalThingsNested map[string]*AdditionalThingsNestedAdditionalProperties `json:\"-\"`",
+		`func (m *AdditionalThingsNested) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateOrigin(formats); err != nil {`,
+		`	for k := range m.AdditionalThingsNested {`,
+		`		if val, ok := m.AdditionalThingsNested[k]; ok {`,
+		`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var additionalThingsNestedTypeOriginPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"goPrint\",\"goE-book\",\"goCollection\",\"goMuseum\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		additionalThingsNestedTypeOriginPropEnum = append(additionalThingsNestedTypeOriginPropEnum, v`,
+		`	AdditionalThingsNestedOriginGoPrint string = "goPrint"`,
+		`	AdditionalThingsNestedOriginGoEBook string = "goE-book"`,
+		`	AdditionalThingsNestedOriginGoCollection string = "goCollection"`,
+		`	AdditionalThingsNestedOriginGoMuseum string = "goMuseum"`,
+		`func (m *AdditionalThingsNested) validateOriginEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, additionalThingsNestedTypeOriginPropEnum); err != nil {`,
+		`func (m *AdditionalThingsNested) validateOrigin(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Origin) {`,
+		`	if err := m.validateOriginEnum("origin", "body", m.Origin); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: no_validation_thing.go
+	flattenRun.AddExpectations("no_validation_thing.go", []string{
+		`type NoValidationThing struct {`,
+		"	Discourse string `json:\"discourse,omitempty\"`",
+		"	HoursSpent float64 `json:\"hoursSpent,omitempty\"`",
+		"	NoValidationThingAdditionalProperties map[string]interface{} `json:\"-\"`",
+		// empty validation
+		"func (m *NoValidationThing) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_array_of_interface.go
+	flattenRun.AddExpectations("additional_array_of_interface.go", []string{
+		`type AdditionalArrayOfInterface struct {`,
+		"	ThisOneNotRequired int64 `json:\"thisOneNotRequired,omitempty\"`",
+		"	AdditionalArrayOfInterface map[string][]interface{} `json:\"-\"`",
+		`func (m *AdditionalArrayOfInterface) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateThisOneNotRequired(formats); err != nil {`,
+		`	for k := range m.AdditionalArrayOfInterface {`,
+		`		if swag.IsZero(m.AdditionalArrayOfInterface[k]) {`,
+		`		if err := validate.UniqueItems(k, "body", m.AdditionalArrayOfInterface[k]); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalArrayOfInterface) validateThisOneNotRequired(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ThisOneNotRequired) {`,
+		`	if err := validate.MaximumInt("thisOneNotRequired", "body", int64(m.ThisOneNotRequired), 10, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_formated_thing.go
+	flattenRun.AddExpectations("additional_formated_thing.go", []string{
+		`type AdditionalFormatedThing map[string]strfmt.Date`,
+		`func (m AdditionalFormatedThing) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if err := validate.FormatOf(k, "body", "date", m[k].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: aliased_nullable_date.go
+	flattenRun.AddExpectations("aliased_nullable_date.go", []string{
+		`type AliasedNullableDate strfmt.Date`,
+		`func (m AliasedNullableDate) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.FormatOf("", "body", "date", strfmt.Date(m).String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_array_of_refed_object.go
+	flattenRun.AddExpectations("additional_array_of_refed_object.go", []string{
+		`type AdditionalArrayOfRefedObject struct {`,
+		"	ThisOneNotRequired int64 `json:\"thisOneNotRequired,omitempty\"`",
+		"	AdditionalArrayOfRefedObject map[string][]*NoValidationThing `json:\"-\"`",
+		`func (m *AdditionalArrayOfRefedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateThisOneNotRequired(formats); err != nil {`,
+		`	for k := range m.AdditionalArrayOfRefedObject {`,
+		`		if err := validate.Required(k, "body", m.AdditionalArrayOfRefedObject[k]); err != nil {`,
+		`		if err := validate.UniqueItems(k, "body", m.AdditionalArrayOfRefedObject[k]); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalArrayOfRefedObject[k]); i++ {`,
+		`			if swag.IsZero(m.AdditionalArrayOfRefedObject[k][i]) {`,
+		`			if m.AdditionalArrayOfRefedObject[k][i] != nil {`,
+		`				if err := m.AdditionalArrayOfRefedObject[k][i].Validate(formats); err != nil {`,
+		`					if ve, ok := err.(*errors.Validation); ok {`,
+		`						return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalArrayOfRefedObject) validateThisOneNotRequired(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ThisOneNotRequired) {`,
+		`	if err := validate.MaximumInt("thisOneNotRequired", "body", int64(m.ThisOneNotRequired), 10, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_slice_of_aliased_primitives.go
+	flattenRun.AddExpectations("additional_slice_of_aliased_primitives.go", []string{
+		`type AdditionalSliceOfAliasedPrimitives struct {`,
+		"	Prop2 strfmt.UUID `json:\"prop2,omitempty\"`",
+		"	AdditionalSliceOfAliasedPrimitives map[string][]AliasedDate `json:\"-\"`",
+		`func (m *AdditionalSliceOfAliasedPrimitives) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp2(formats); err != nil {`,
+		`	for k := range m.AdditionalSliceOfAliasedPrimitives {`,
+		`		if swag.IsZero(m.AdditionalSliceOfAliasedPrimitives[k]) {`,
+		`		iAdditionalSliceOfAliasedPrimitivesSize := int64(len(m.AdditionalSliceOfAliasedPrimitives[k])`,
+		`		if err := validate.MaxItems(k, "body", iAdditionalSliceOfAliasedPrimitivesSize, 10); err != nil {`,
+		`		for i := 0; i < len(m.AdditionalSliceOfAliasedPrimitives[k]); i++ {`,
+		`			if err := m.AdditionalSliceOfAliasedPrimitives[k][i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(k + "." + strconv.Itoa(i)`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalSliceOfAliasedPrimitives) validateProp2(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop2) {`,
+		`	if err := validate.FormatOf("prop2", "body", "uuid", m.Prop2.String(), formats); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: transitive_refed_thing.go
+	flattenRun.AddExpectations("transitive_refed_thing.go", []string{
+		`type TransitiveRefedThing struct {`,
+		"	ThisOneNotRequiredEither int64 `json:\"thisOneNotRequiredEither,omitempty\"`",
+		"	TransitiveRefedThing map[string]*TransitiveRefedThingAdditionalProperties `json:\"-\"`",
+		`func (m *TransitiveRefedThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateThisOneNotRequiredEither(formats); err != nil {`,
+		`	for k := range m.TransitiveRefedThing {`,
+		`		if val, ok := m.TransitiveRefedThing[k]; ok {`,
+		`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *TransitiveRefedThing) validateThisOneNotRequiredEither(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ThisOneNotRequiredEither) {`,
+		`	if err := validate.MaximumInt("thisOneNotRequiredEither", "body", int64(m.ThisOneNotRequiredEither), 20, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_empty_object.go
+	flattenRun.AddExpectations("additional_empty_object.go", []string{
+		`type AdditionalEmptyObject struct {`,
+		"	PropA interface{} `json:\"propA,omitempty\"`",
+		"	AdditionalEmptyObject map[string]interface{} `json:\"-\"`",
+		// empty validation
+		"func (m *AdditionalEmptyObject) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: additional_date_with_nullable_thing.go
+	flattenRun.AddExpectations("additional_date_with_nullable_thing.go", []string{
+		`type AdditionalDateWithNullableThing struct {`,
+		"	Blob int64 `json:\"blob,omitempty\"`",
+		"	NullableDate *AliasedNullableDate `json:\"nullableDate,omitempty\"`",
+		"	AdditionalDateWithNullableThing map[string]*AliasedNullableDate `json:\"-\"`",
+		`func (m *AdditionalDateWithNullableThing) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateBlob(formats); err != nil {`,
+		`	if err := m.validateNullableDate(formats); err != nil {`,
+		`	for k := range m.AdditionalDateWithNullableThing {`,
+		`		if swag.IsZero(m.AdditionalDateWithNullableThing[k]) {`,
+		`		if val, ok := m.AdditionalDateWithNullableThing[k]; ok {`,
+		`			if val != nil {`,
+		`				if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AdditionalDateWithNullableThing) validateBlob(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Blob) {`,
+		`	if err := validate.MinimumInt("blob", "body", int64(m.Blob), 1, false); err != nil {`,
+		`func (m *AdditionalDateWithNullableThing) validateNullableDate(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.NullableDate) {`,
+		`	if m.NullableDate != nil {`,
+		`		if err := m.NullableDate.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("nullableDate"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixtureTuple() {
+	// testing ../fixtures/bugs/1487/fixture-tuple.yaml with expand (--skip-flatten)
+
+	/* check different patterns of additionalItems validations or absence thereof
+	 */
+	f := newModelFixture("../fixtures/bugs/1487/fixture-tuple.yaml", "fixture for tuples and additionalItems")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: classics.go
+	flattenRun.AddExpectations("classics.go", []string{
+		`type Classics struct {`,
+		"	P0 *int64 `json:\"-\"`",
+		"	P1 *strfmt.ISBN `json:\"-\"`",
+		"	P2 Comics `json:\"-\"`",
+		"	ClassicsItems []ClassicsTupleAdditionalItems `json:\"-\"`",
+		`func (m *Classics) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateClassicsItems(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Classics) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`func (m *Classics) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`	if err := validate.FormatOf("1", "body", "isbn", m.P1.String(), formats); err != nil {`,
+		`func (m *Classics) validateP2(formats strfmt.Registry) error {`,
+		`	if err := m.P2.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("2"`,
+		`func (m *Classics) validateClassicsItems(formats strfmt.Registry) error {`,
+		`	for i := range m.ClassicsItems {`,
+		`		if err := m.ClassicsItems[i].Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName(strconv.Itoa(i + 3)`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("classics.go", []string{
+		`type Classics struct {`,
+		"	P0 *int64 `json:\"-\"`",
+		"	P1 *strfmt.ISBN `json:\"-\"`",
+		"	P2 *ClassicsTuple0 `json:\"-\"`",
+		"	ClassicsItems []*ClassicsClassicsItemsTuple0 `json:\"-\"`",
+		`func (m *Classics) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateClassicsItems(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Classics) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`func (m *Classics) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`	if err := validate.FormatOf("1", "body", "isbn", m.P1.String(), formats); err != nil {`,
+		`func (m *Classics) validateP2(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("2", "body", m.P2); err != nil {`,
+		`	if m.P2 != nil {`,
+		`		if err := m.P2.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("2"`,
+		`func (m *Classics) validateClassicsItems(formats strfmt.Registry) error {`,
+		`	for i := range m.ClassicsItems {`,
+		`		if m.ClassicsItems[i] != nil {`,
+		`			if err := m.ClassicsItems[i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName(strconv.Itoa(i + 3)`,
+		`type ClassicsClassicsItemsTuple0 struct {`,
+		"	P0 *ClassicsClassicsItemsTuple0P0 `json:\"-\"`",
+		"	P1 []strfmt.Date `json:\"-\"`",
+		"	P2 *ClassicsClassicsItemsTuple0P2 `json:\"-\"`",
+		"	P3 *ClassicsClassicsItemsTuple0P3Tuple0 `json:\"-\"`",
+		`func (m *ClassicsClassicsItemsTuple0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateP3(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ClassicsClassicsItemsTuple0) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P0", "body", m.P0); err != nil {`,
+		`	if m.P0 != nil {`,
+		`		if err := m.P0.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P0"`,
+		`func (m *ClassicsClassicsItemsTuple0) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P1", "body", m.P1); err != nil {`,
+		`	for i := 0; i < len(m.P1); i++ {`,
+		`		if err := validate.FormatOf("P1"+"."+strconv.Itoa(i), "body", "date", m.P1[i].String(), formats); err != nil {`,
+		`func (m *ClassicsClassicsItemsTuple0) validateP2(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P2", "body", m.P2); err != nil {`,
+		`	if m.P2 != nil {`,
+		`		if err := m.P2.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P2"`,
+		`func (m *ClassicsClassicsItemsTuple0) validateP3(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P3", "body", m.P3); err != nil {`,
+		`	if m.P3 != nil {`,
+		`		if err := m.P3.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P3"`,
+		`type ClassicsClassicsItemsTuple0P0 struct {`,
+		"	Period *string `json:\"period,omitempty\"`",
+		"	Title *string `json:\"title,omitempty\"`",
+		`func (m *ClassicsClassicsItemsTuple0P0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateTitle(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var classicsClassicsItemsTuple0P0TypeTitlePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"Les Misrables\",\"Bleak House\",\"Sherlock Holmes\",\"Siddhartha\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		classicsClassicsItemsTuple0P0TypeTitlePropEnum = append(classicsClassicsItemsTuple0P0TypeTitlePropEnum, v`,
+		`	ClassicsClassicsItemsTuple0P0TitleLesMisrables string = "Les Misrables"`,
+		`	ClassicsClassicsItemsTuple0P0TitleBleakHouse string = "Bleak House"`,
+		`	ClassicsClassicsItemsTuple0P0TitleSherlockHolmes string = "Sherlock Holmes"`,
+		`	ClassicsClassicsItemsTuple0P0TitleSiddhartha string = "Siddhartha"`,
+		`func (m *ClassicsClassicsItemsTuple0P0) validateTitleEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, classicsClassicsItemsTuple0P0TypeTitlePropEnum); err != nil {`,
+		`func (m *ClassicsClassicsItemsTuple0P0) validateTitle(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Title) {`,
+		`	if err := m.validateTitleEnum("P0"+"."+"title", "body", *m.Title); err != nil {`,
+		`type ClassicsClassicsItemsTuple0P2 struct {`,
+		"	Origin *string `json:\"origin,omitempty\"`",
+		"	ClassicsClassicsItemsTuple0P2 map[string]string `json:\"-\"`",
+		`var classicsClassicsItemsTuple0P2ValueEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"bookshop\",\"amazon\",\"library\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		classicsClassicsItemsTuple0P2ValueEnum = append(classicsClassicsItemsTuple0P2ValueEnum, v`,
+		`func (m *ClassicsClassicsItemsTuple0P2) validateClassicsClassicsItemsTuple0P2ValueEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, classicsClassicsItemsTuple0P2ValueEnum); err != nil {`,
+		`func (m *ClassicsClassicsItemsTuple0P2) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateOrigin(formats); err != nil {`,
+		`	for k := range m.ClassicsClassicsItemsTuple0P2 {`,
+		`		if swag.IsZero(m.ClassicsClassicsItemsTuple0P2[k]) {`,
+		`		if err := m.validateClassicsClassicsItemsTuple0P2ValueEnum("P2"+"."+k, "body", m.ClassicsClassicsItemsTuple0P2[k]); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var classicsClassicsItemsTuple0P2TypeOriginPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"print\",\"e-book\",\"collection\",\"museum\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		classicsClassicsItemsTuple0P2TypeOriginPropEnum = append(classicsClassicsItemsTuple0P2TypeOriginPropEnum, v`,
+		`	ClassicsClassicsItemsTuple0P2OriginPrint string = "print"`,
+		`	ClassicsClassicsItemsTuple0P2OriginEBook string = "e-book"`,
+		`	ClassicsClassicsItemsTuple0P2OriginCollection string = "collection"`,
+		`	ClassicsClassicsItemsTuple0P2OriginMuseum string = "museum"`,
+		`func (m *ClassicsClassicsItemsTuple0P2) validateOriginEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, classicsClassicsItemsTuple0P2TypeOriginPropEnum); err != nil {`,
+		`func (m *ClassicsClassicsItemsTuple0P2) validateOrigin(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Origin) {`,
+		`	if err := m.validateOriginEnum("P2"+"."+"origin", "body", *m.Origin); err != nil {`,
+		`type ClassicsClassicsItemsTuple0P3Tuple0 struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *ClassicsClassicsItemsTuple0P3Tuple0P1 `json:\"-\"`",
+		"	P2 *ClassicsClassicsItemsTuple0P3Tuple0P2 `json:\"-\"`",
+		"	P3 *ClassicsClassicsItemsTuple0P3Tuple0P3 `json:\"-\"`",
+		"	P4 []strfmt.ISBN `json:\"-\"`",
+		"	P5 *int64 `json:\"-\"`",
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateP3(formats); err != nil {`,
+		`	if err := m.validateP4(formats); err != nil {`,
+		`	if err := m.validateP5(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P0", "body", m.P0); err != nil {`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P1", "body", m.P1); err != nil {`,
+		`	if m.P1 != nil {`,
+		`		if err := m.P1.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P1"`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0) validateP2(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P2", "body", m.P2); err != nil {`,
+		`	if m.P2 != nil {`,
+		`		if err := m.P2.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P2"`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0) validateP3(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P3", "body", m.P3); err != nil {`,
+		`	if m.P3 != nil {`,
+		`		if err := m.P3.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P3"`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0) validateP4(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P4", "body", m.P4); err != nil {`,
+		`	for i := 0; i < len(m.P4); i++ {`,
+		`		if err := validate.FormatOf("P4"+"."+strconv.Itoa(i), "body", "isbn", m.P4[i].String(), formats); err != nil {`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0) validateP5(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P5", "body", m.P5); err != nil {`,
+		`type ClassicsClassicsItemsTuple0P3Tuple0P1 struct {`,
+		"	Narrative *string `json:\"narrative\"`",
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0P1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateNarrative(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0P1) validateNarrative(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P1"+"."+"narrative", "body", m.Narrative); err != nil {`,
+		`type ClassicsClassicsItemsTuple0P3Tuple0P2 struct {`,
+		"	MarketingBS *string `json:\"marketingBS,omitempty\"`",
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0P2) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type ClassicsClassicsItemsTuple0P3Tuple0P3 struct {`,
+		"	Author *string `json:\"author,omitempty\"`",
+		"	Character *string `json:\"character,omitempty\"`",
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0P3) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAuthor(formats); err != nil {`,
+		`	if err := m.validateCharacter(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0P3) validateAuthor(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Author) {`,
+		`	if err := validate.MinLength("P3"+"."+"author", "body", string(*m.Author), 1); err != nil {`,
+		`func (m *ClassicsClassicsItemsTuple0P3Tuple0P3) validateCharacter(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Character) {`,
+		"	if err := validate.Pattern(\"P3\"+\".\"+\"character\", \"body\", string(*m.Character), `^[A-Z]+$`); err != nil {",
+		`type ClassicsTuple0 struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *ClassicsTuple0P1 `json:\"-\"`",
+		"	P2 *ClassicsTuple0P2 `json:\"-\"`",
+		"	P3 *ClassicsTuple0P3 `json:\"-\"`",
+		"	P4 []strfmt.ISBN `json:\"-\"`",
+		"	P5 *int64 `json:\"-\"`",
+		`func (m *ClassicsTuple0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateP3(formats); err != nil {`,
+		`	if err := m.validateP4(formats); err != nil {`,
+		`	if err := m.validateP5(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ClassicsTuple0) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P0", "body", m.P0); err != nil {`,
+		`func (m *ClassicsTuple0) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P1", "body", m.P1); err != nil {`,
+		`	if m.P1 != nil {`,
+		`		if err := m.P1.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P1"`,
+		`func (m *ClassicsTuple0) validateP2(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P2", "body", m.P2); err != nil {`,
+		`	if m.P2 != nil {`,
+		`		if err := m.P2.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P2"`,
+		`func (m *ClassicsTuple0) validateP3(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P3", "body", m.P3); err != nil {`,
+		`	if m.P3 != nil {`,
+		`		if err := m.P3.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("P3"`,
+		`func (m *ClassicsTuple0) validateP4(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P4", "body", m.P4); err != nil {`,
+		`	for i := 0; i < len(m.P4); i++ {`,
+		`		if err := validate.FormatOf("P4"+"."+strconv.Itoa(i), "body", "isbn", m.P4[i].String(), formats); err != nil {`,
+		`func (m *ClassicsTuple0) validateP5(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P5", "body", m.P5); err != nil {`,
+		`type ClassicsTuple0P1 struct {`,
+		"	Narrative *string `json:\"narrative\"`",
+		`func (m *ClassicsTuple0P1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateNarrative(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ClassicsTuple0P1) validateNarrative(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P1"+"."+"narrative", "body", m.Narrative); err != nil {`,
+		`type ClassicsTuple0P2 struct {`,
+		"	MarketingBS *string `json:\"marketingBS,omitempty\"`",
+		`func (m *ClassicsTuple0P2) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type ClassicsTuple0P3 struct {`,
+		"	Author *string `json:\"author,omitempty\"`",
+		"	Character *string `json:\"character,omitempty\"`",
+		`func (m *ClassicsTuple0P3) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAuthor(formats); err != nil {`,
+		`	if err := m.validateCharacter(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ClassicsTuple0P3) validateAuthor(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Author) {`,
+		`	if err := validate.MinLength("P3"+"."+"author", "body", string(*m.Author), 1); err != nil {`,
+		`func (m *ClassicsTuple0P3) validateCharacter(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Character) {`,
+		"	if err := validate.Pattern(\"P3\"+\".\"+\"character\", \"body\", string(*m.Character), `^[A-Z]+$`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: comics_items2.go
+	flattenRun.AddExpectations("comics_items2.go", []string{
+		`type ComicsItems2 struct {`,
+		"	MarketingBS string `json:\"marketingBS,omitempty\"`",
+		// empty validation
+		"func (m *ComicsItems2) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: classics_items_additional_items_items2.go
+	flattenRun.AddExpectations("classics_items_additional_items_items2.go", []string{
+		`type ClassicsItemsAdditionalItemsItems2 struct {`,
+		"	Origin string `json:\"origin,omitempty\"`",
+		"	ClassicsItemsAdditionalItemsItems2 map[string]string `json:\"-\"`",
+		`var classicsItemsAdditionalItemsItems2ValueEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"bookshop\",\"amazon\",\"library\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		classicsItemsAdditionalItemsItems2ValueEnum = append(classicsItemsAdditionalItemsItems2ValueEnum, v`,
+		`func (m *ClassicsItemsAdditionalItemsItems2) validateClassicsItemsAdditionalItemsItems2ValueEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, classicsItemsAdditionalItemsItems2ValueEnum); err != nil {`,
+		`func (m *ClassicsItemsAdditionalItemsItems2) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateOrigin(formats); err != nil {`,
+		`	for k := range m.ClassicsItemsAdditionalItemsItems2 {`,
+		`		if swag.IsZero(m.ClassicsItemsAdditionalItemsItems2[k]) {`,
+		`		if err := m.validateClassicsItemsAdditionalItemsItems2ValueEnum(k, "body", m.ClassicsItemsAdditionalItemsItems2[k]); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var classicsItemsAdditionalItemsItems2TypeOriginPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"print\",\"e-book\",\"collection\",\"museum\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		classicsItemsAdditionalItemsItems2TypeOriginPropEnum = append(classicsItemsAdditionalItemsItems2TypeOriginPropEnum, v`,
+		`	ClassicsItemsAdditionalItemsItems2OriginPrint string = "print"`,
+		`	ClassicsItemsAdditionalItemsItems2OriginEBook string = "e-book"`,
+		`	ClassicsItemsAdditionalItemsItems2OriginCollection string = "collection"`,
+		`	ClassicsItemsAdditionalItemsItems2OriginMuseum string = "museum"`,
+		`func (m *ClassicsItemsAdditionalItemsItems2) validateOriginEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, classicsItemsAdditionalItemsItems2TypeOriginPropEnum); err != nil {`,
+		`func (m *ClassicsItemsAdditionalItemsItems2) validateOrigin(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Origin) {`,
+		`	if err := m.validateOriginEnum("origin", "body", m.Origin); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: comics.go
+	flattenRun.AddExpectations("comics.go", []string{
+		`type Comics struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *ComicsItems1 `json:\"-\"`",
+		"	P2 *ComicsItems2 `json:\"-\"`",
+		"	P3 *ComicsItems3 `json:\"-\"`",
+		"	P4 []strfmt.ISBN `json:\"-\"`",
+		"	P5 *int64 `json:\"-\"`",
+		`func (m *Comics) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateP3(formats); err != nil {`,
+		`	if err := m.validateP4(formats); err != nil {`,
+		`	if err := m.validateP5(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Comics) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`func (m *Comics) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`	if m.P1 != nil {`,
+		`		if err := m.P1.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("1"`,
+		`func (m *Comics) validateP2(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("2", "body", m.P2); err != nil {`,
+		`	if m.P2 != nil {`,
+		`		if err := m.P2.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("2"`,
+		`func (m *Comics) validateP3(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("3", "body", m.P3); err != nil {`,
+		`	if m.P3 != nil {`,
+		`		if err := m.P3.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("3"`,
+		`func (m *Comics) validateP4(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("4", "body", m.P4); err != nil {`,
+		`	for i := 0; i < len(m.P4); i++ {`,
+		`		if err := validate.FormatOf("4"+"."+strconv.Itoa(i), "body", "isbn", m.P4[i].String(), formats); err != nil {`,
+		`func (m *Comics) validateP5(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("5", "body", m.P5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("comics.go", []string{
+		`type Comics struct {`,
+		"	P0 *string `json:\"-\"`",
+		`	P1 struct {`,
+		"		Narrative *string `json:\"narrative\"`",
+		"	} `json:\"-\"`",
+		`	P2 struct {`,
+		"		MarketingBS *string `json:\"marketingBS\"`",
+		"	} `json:\"-\"`",
+		`	P3 struct {`,
+		"		Author *string `json:\"author\"`",
+		"		Character *string `json:\"character\"`",
+		"	} `json:\"-\"`",
+		"	P4 []strfmt.ISBN `json:\"-\"`",
+		"	P5 *int64 `json:\"-\"`",
+		`func (m *Comics) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateP3(formats); err != nil {`,
+		`	if err := m.validateP4(formats); err != nil {`,
+		`	if err := m.validateP5(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Comics) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`func (m *Comics) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1"+"."+"narrative", "body", m.P1.Narrative); err != nil {`,
+		`func (m *Comics) validateP2(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("2"+"."+"marketingBS", "body", m.P2.MarketingBS); err != nil {`,
+		`func (m *Comics) validateP3(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("3"+"."+"author", "body", m.P3.Author); err != nil {`,
+		`	if err := validate.MinLength("3"+"."+"author", "body", string(*m.P3.Author), 1); err != nil {`,
+		`	if err := validate.Required("3"+"."+"character", "body", m.P3.Character); err != nil {`,
+		"	if err := validate.Pattern(\"3\"+\".\"+\"character\", \"body\", string(*m.P3.Character), `^[A-Z]+$`); err != nil {",
+		`func (m *Comics) validateP4(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("4", "body", m.P4); err != nil {`,
+		`	for i := 0; i < len(m.P4); i++ {`,
+		`		if err := validate.FormatOf("4"+"."+strconv.Itoa(i), "body", "isbn", m.P4[i].String(), formats); err != nil {`,
+		`func (m *Comics) validateP5(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("5", "body", m.P5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: classics_items_additional_items_items0.go
+	flattenRun.AddExpectations("classics_items_additional_items_items0.go", []string{
+		`type ClassicsItemsAdditionalItemsItems0 struct {`,
+		"	Period string `json:\"period,omitempty\"`",
+		"	Title string `json:\"title,omitempty\"`",
+		`func (m *ClassicsItemsAdditionalItemsItems0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateTitle(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var classicsItemsAdditionalItemsItems0TypeTitlePropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"Les Misrables\",\"Bleak House\",\"Sherlock Holmes\",\"Siddhartha\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		classicsItemsAdditionalItemsItems0TypeTitlePropEnum = append(classicsItemsAdditionalItemsItems0TypeTitlePropEnum, v`,
+		`	ClassicsItemsAdditionalItemsItems0TitleLesMisrables string = "Les Misrables"`,
+		`	ClassicsItemsAdditionalItemsItems0TitleBleakHouse string = "Bleak House"`,
+		`	ClassicsItemsAdditionalItemsItems0TitleSherlockHolmes string = "Sherlock Holmes"`,
+		`	ClassicsItemsAdditionalItemsItems0TitleSiddhartha string = "Siddhartha"`,
+		`func (m *ClassicsItemsAdditionalItemsItems0) validateTitleEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, classicsItemsAdditionalItemsItems0TypeTitlePropEnum); err != nil {`,
+		`func (m *ClassicsItemsAdditionalItemsItems0) validateTitle(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Title) {`,
+		`	if err := m.validateTitleEnum("title", "body", m.Title); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: comics_items1.go
+	flattenRun.AddExpectations("comics_items1.go", []string{
+		`type ComicsItems1 struct {`,
+		"	Narrative *string `json:\"narrative\"`",
+		`func (m *ComicsItems1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateNarrative(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ComicsItems1) validateNarrative(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("narrative", "body", m.Narrative); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: comics_items3.go
+	flattenRun.AddExpectations("comics_items3.go", []string{
+		`type ComicsItems3 struct {`,
+		"	Author string `json:\"author,omitempty\"`",
+		"	Character string `json:\"character,omitempty\"`",
+		`func (m *ComicsItems3) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAuthor(formats); err != nil {`,
+		`	if err := m.validateCharacter(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ComicsItems3) validateAuthor(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Author) {`,
+		`	if err := validate.MinLength("author", "body", string(m.Author), 1); err != nil {`,
+		`func (m *ComicsItems3) validateCharacter(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Character) {`,
+		"	if err := validate.Pattern(\"character\", \"body\", string(m.Character), `^[A-Z]+$`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: classics_tuple_additional_items.go
+	flattenRun.AddExpectations("classics_tuple_additional_items.go", []string{
+		`type ClassicsTupleAdditionalItems struct {`,
+		"	P0 *ClassicsItemsAdditionalItemsItems0 `json:\"-\"`",
+		"	P1 []strfmt.Date `json:\"-\"`",
+		"	P2 *ClassicsItemsAdditionalItemsItems2 `json:\"-\"`",
+		"	P3 Comics `json:\"-\"`",
+		`func (m *ClassicsTupleAdditionalItems) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateP3(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ClassicsTupleAdditionalItems) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if m.P0 != nil {`,
+		`		if err := m.P0.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("0"`,
+		`func (m *ClassicsTupleAdditionalItems) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`	for i := 0; i < len(m.P1); i++ {`,
+		`		if err := validate.FormatOf("1"+"."+strconv.Itoa(i), "body", "date", m.P1[i].String(), formats); err != nil {`,
+		`func (m *ClassicsTupleAdditionalItems) validateP2(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("2", "body", m.P2); err != nil {`,
+		`	if m.P2 != nil {`,
+		`		if err := m.P2.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("2"`,
+		`func (m *ClassicsTupleAdditionalItems) validateP3(formats strfmt.Registry) error {`,
+		`	if err := m.P3.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("3"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixture1198() {
+	// testing ../fixtures/bugs/1487/fixture-1198.yaml with expand (--skip-flatten)
+
+	f := newModelFixture("../fixtures/bugs/1198/fixture-1198.yaml", "string-body-api")
+	flattenRun := f.AddRun(false)
+
+	// load expectations for model: pet.go
+	flattenRun.AddExpectations("pet.go", []string{
+		`type Pet struct {`,
+		"	Date interface{} `json:\"date\"`",
+		`func (m *Pet) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateDate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Pet) validateDate(formats strfmt.Registry) error {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixture1042() {
+	// testing ../fixtures/bugs/1487/fixture-1042.yaml with expand (--skip-flatten)
+
+	/* when the specification incorrectly defines the allOf,
+	generated unmarshalling is wrong.
+	This fixture asserts that with correct spec, the generated models are correct.
+
+	*/
+
+	f := newModelFixture("../fixtures/bugs/1042/fixture-1042.yaml", "allOf marshalling")
+	flattenRun := f.AddRun(false)
+
+	// load expectations for model: b.go
+	flattenRun.AddExpectations("b.go", []string{
+		`type B struct {`,
+		`	A`,
+		`	BAllOf1`,
+		`func (m *B) UnmarshalJSON(raw []byte) error {`,
+		`	var aO0 A`,
+		`	if err := swag.ReadJSON(raw, &aO0); err != nil {`,
+		`	m.A = aO0`,
+		`	var aO1 BAllOf1`,
+		`	if err := swag.ReadJSON(raw, &aO1); err != nil {`,
+		`	m.BAllOf1 = aO1`,
+		`func (m B) MarshalJSON() ([]byte, error) {`,
+		//`	var _parts [][]byte`,
+		// slight optimization of allocations
+		`	_parts := make([][]byte, 0, 2)`,
+		`	aO0, err := swag.WriteJSON(m.A`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO0`,
+		`	aO1, err := swag.WriteJSON(m.BAllOf1`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *B) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.A.Validate(formats); err != nil {`,
+		`	if err := m.BAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: b_all_of1.go
+	flattenRun.AddExpectations("b_all_of1.go", []string{
+		`type BAllOf1 struct {`,
+		"	F3 *string `json:\"f3\"`",
+		"	F4 []string `json:\"f4\"`",
+		`func (m *BAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateF3(formats); err != nil {`,
+		`	if err := m.validateF4(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *BAllOf1) validateF3(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("f3", "body", m.F3); err != nil {`,
+		`func (m *BAllOf1) validateF4(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("f4", "body", m.F4); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: a.go
+	flattenRun.AddExpectations("a.go", []string{
+		`type A struct {`,
+		"	F1 string `json:\"f1,omitempty\"`",
+		"	F2 string `json:\"f2,omitempty\"`",
+		// empty validation
+		"func (m *A) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixture1042V2() {
+	// testing ../fixtures/bugs/1487/fixture-1042-2.yaml with expand (--skip-flatten)
+
+	/* when the specification incorrectly defines the allOf,
+	generated unmarshalling is wrong.
+	This fixture asserts that with correct spec, the generated models are correct.
+
+	*/
+
+	f := newModelFixture("../fixtures/bugs/1042/fixture-1042-2.yaml", "allOf marshalling")
+	flattenRun := f.AddRun(false)
+
+	// load expectations for model: error_model.go
+	flattenRun.AddExpectations("error_model.go", []string{
+		`type ErrorModel struct {`,
+		"	Code *int64 `json:\"code\"`",
+		"	Message *string `json:\"message\"`",
+		`func (m *ErrorModel) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateCode(formats); err != nil {`,
+		`	if err := m.validateMessage(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ErrorModel) validateCode(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("code", "body", m.Code); err != nil {`,
+		`	if err := validate.MinimumInt("code", "body", int64(*m.Code), 100, false); err != nil {`,
+		`	if err := validate.MaximumInt("code", "body", int64(*m.Code), 600, false); err != nil {`,
+		`func (m *ErrorModel) validateMessage(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("message", "body", m.Message); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: extended_error_model.go
+	flattenRun.AddExpectations("extended_error_model.go", []string{
+		`type ExtendedErrorModel struct {`,
+		`	ErrorModel`,
+		`	ExtendedErrorModelAllOf1`,
+		`func (m *ExtendedErrorModel) UnmarshalJSON(raw []byte) error {`,
+		`	var aO0 ErrorModel`,
+		`	if err := swag.ReadJSON(raw, &aO0); err != nil {`,
+		`	m.ErrorModel = aO0`,
+		`	var aO1 ExtendedErrorModelAllOf1`,
+		`	if err := swag.ReadJSON(raw, &aO1); err != nil {`,
+		`	m.ExtendedErrorModelAllOf1 = aO1`,
+		`func (m ExtendedErrorModel) MarshalJSON() ([]byte, error) {`,
+		//`	var _parts [][]byte`,
+		// slight optimization of allocations
+		`	_parts := make([][]byte, 0, 2)`,
+		`	aO0, err := swag.WriteJSON(m.ErrorModel`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO0`,
+		`	aO1, err := swag.WriteJSON(m.ExtendedErrorModelAllOf1`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *ExtendedErrorModel) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.ErrorModel.Validate(formats); err != nil {`,
+		`	if err := m.ExtendedErrorModelAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: extended_error_model_all_of1.go
+	flattenRun.AddExpectations("extended_error_model_all_of1.go", []string{
+		`type ExtendedErrorModelAllOf1 struct {`,
+		"	RootCause *string `json:\"rootCause\"`",
+		`func (m *ExtendedErrorModelAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateRootCause(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ExtendedErrorModelAllOf1) validateRootCause(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("rootCause", "body", m.RootCause); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixture979() {
+	// testing ../fixtures/bugs/1487/fixture-979.yaml with expand (--skip-flatten)
+
+	/* checking that properties is enough to figure out an object schema
+	 */
+
+	f := newModelFixture("../fixtures/bugs/979/fixture-979.yaml", "allOf without the explicit type object")
+	flattenRun := f.AddRun(false)
+
+	// load expectations for model: cluster.go
+	flattenRun.AddExpectations("cluster.go", []string{
+		`type Cluster struct {`,
+		`	NewCluster`,
+		`	ClusterAllOf1`,
+		`func (m *Cluster) UnmarshalJSON(raw []byte) error {`,
+		`	var aO0 NewCluster`,
+		`	if err := swag.ReadJSON(raw, &aO0); err != nil {`,
+		`	m.NewCluster = aO0`,
+		`	var aO1 ClusterAllOf1`,
+		`	if err := swag.ReadJSON(raw, &aO1); err != nil {`,
+		`	m.ClusterAllOf1 = aO1`,
+		`func (m Cluster) MarshalJSON() ([]byte, error) {`,
+		//`	var _parts [][]byte`,
+		// slight optimization of allocations
+		`	_parts := make([][]byte, 0, 2)`,
+		`	aO0, err := swag.WriteJSON(m.NewCluster`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO0`,
+		`	aO1, err := swag.WriteJSON(m.ClusterAllOf1`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	_parts = append(_parts, aO1`,
+		`	return swag.ConcatJSON(_parts...), nil`,
+		`func (m *Cluster) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.NewCluster.Validate(formats); err != nil {`,
+		`	if err := m.ClusterAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: new_cluster.go
+	flattenRun.AddExpectations("new_cluster.go", []string{
+		`type NewCluster struct {`,
+		"	DummyProp1 int64 `json:\"dummyProp1,omitempty\"`",
+		// empty validation
+		"func (m *NewCluster) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: cluster_all_of1.go
+	flattenRun.AddExpectations("cluster_all_of1.go", []string{
+		`type ClusterAllOf1 struct {`,
+		"	Result string `json:\"result,omitempty\"`",
+		"	Status string `json:\"status,omitempty\"`",
+		// empty validation
+		"func (m *ClusterAllOf1) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixture842() {
+	// testing ../fixtures/bugs/1487/fixture-842.yaml with expand (--skip-flatten)
+
+	/* codegen fails to produce code that builds
+	 */
+
+	f := newModelFixture("../fixtures/bugs/842/fixture-842.yaml", "polymorphic type containing an array of the base type")
+	flattenRun := f.AddRun(false)
+
+	// load expectations for model: value_array_all_of1.go
+	flattenRun.AddExpectations("value_array_all_of1.go", []string{
+		`type ValueArrayAllOf1 struct {`,
+		`	valuesField []Value`,
+		`func (m *ValueArrayAllOf1) Values() []Value {`,
+		`	return m.valuesField`,
+		`func (m *ValueArrayAllOf1) SetValues(val []Value) {`,
+		`	m.valuesField = val`,
+		`func (m *ValueArrayAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateValues(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ValueArrayAllOf1) validateValues(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("Values", "body", m.Values()); err != nil {`,
+		`	for i := 0; i < len(m.Values()); i++ {`,
+		`		if err := m.valuesField[i].Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("Values" + "." + strconv.Itoa(i)`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: value_array.go
+	flattenRun.AddExpectations("value_array.go", []string{
+		`type ValueArray struct {`,
+		`	ValueArrayAllOf1`,
+		`func (m *ValueArray) ValueType() string {`,
+		`	return "ValueArray"`,
+		`func (m *ValueArray) SetValueType(val string) {`,
+		`func (m *ValueArray) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.ValueArrayAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: value.go
+	flattenRun.AddExpectations("value.go", []string{
+		`type Value interface {`,
+		`	runtime.Validatable`,
+		`	ValueType() string`,
+		`	SetValueType(string`,
+		`type value struct {`,
+		`	valueTypeField string`,
+		`func (m *value) ValueType() string {`,
+		`	return "Value"`,
+		`func (m *value) SetValueType(val string) {`,
+		`func UnmarshalValueSlice(reader io.Reader, consumer runtime.Consumer) ([]Value, error) {`,
+		`	var elements []json.RawMessage`,
+		`	if err := consumer.Consume(reader, &elements); err != nil {`,
+		`		return nil, err`,
+		`	var result []Value`,
+		`	for _, element := range elements {`,
+		`		obj, err := unmarshalValue(element, consumer`,
+		`		if err != nil {`,
+		`			return nil, err`,
+		`		result = append(result, obj`,
+		`	return result, nil`,
+		`func UnmarshalValue(reader io.Reader, consumer runtime.Consumer) (Value, error) {`,
+		`	data, err := ioutil.ReadAll(reader`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return unmarshalValue(data, consumer`,
+		`func unmarshalValue(data []byte, consumer runtime.Consumer) (Value, error) {`,
+		`	buf := bytes.NewBuffer(data`,
+		`	buf2 := bytes.NewBuffer(data`,
+		`	var getType struct {`,
+		"		ValueType string `json:\"ValueType\"`",
+		`	if err := consumer.Consume(buf, &getType); err != nil {`,
+		`		return nil, err`,
+		`	if err := validate.RequiredString("ValueType", "body", getType.ValueType); err != nil {`,
+		`		return nil, err`,
+		`	switch getType.ValueType {`,
+		`	case "Value":`,
+		`		var result value`,
+		`		if err := consumer.Consume(buf2, &result); err != nil {`,
+		`			return nil, err`,
+		`		return &result, nil`,
+		`	case "ValueArray":`,
+		`		var result ValueArray`,
+		`		if err := consumer.Consume(buf2, &result); err != nil {`,
+		`			return nil, err`,
+		`		return &result, nil`,
+		`	return nil, errors.New(422, "invalid ValueType value: %q", getType.ValueType`,
+		// empty validation
+		"func (m *value) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixture607() {
+	// testing ../fixtures/bugs/1487/fixture-607.yaml with expand (--skip-flatten)
+
+	/* broken code produced on polymorphic type
+	 */
+
+	f := newModelFixture("../fixtures/bugs/607/fixture-607.yaml", "broken code when using array of polymorphic type")
+	flattenRun := f.AddRun(false)
+
+	// load expectations for model: range_filter_all_of1.go
+	flattenRun.AddExpectations("range_filter_all_of1.go", []string{
+		`type RangeFilterAllOf1 struct {`,
+		"	Config *RangeFilterAllOf1Config `json:\"config\"`",
+		`func (m *RangeFilterAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *RangeFilterAllOf1) validateConfig(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("config", "body", m.Config); err != nil {`,
+		`	if m.Config != nil {`,
+		`		if err := m.Config.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("config"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: filter.go
+	flattenRun.AddExpectations("filter.go", []string{
+		`type Filter interface {`,
+		`	runtime.Validatable`,
+		`	Type() string`,
+		`	SetType(string`,
+		`type filter struct {`,
+		`	typeField string`,
+		`func (m *filter) Type() string {`,
+		`	return "Filter"`,
+		`func (m *filter) SetType(val string) {`,
+		`func UnmarshalFilterSlice(reader io.Reader, consumer runtime.Consumer) ([]Filter, error) {`,
+		`	var elements []json.RawMessage`,
+		`	if err := consumer.Consume(reader, &elements); err != nil {`,
+		`		return nil, err`,
+		`	var result []Filter`,
+		`	for _, element := range elements {`,
+		`		obj, err := unmarshalFilter(element, consumer`,
+		`		if err != nil {`,
+		`			return nil, err`,
+		`		result = append(result, obj`,
+		`	return result, nil`,
+		`func UnmarshalFilter(reader io.Reader, consumer runtime.Consumer) (Filter, error) {`,
+		`	data, err := ioutil.ReadAll(reader`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return unmarshalFilter(data, consumer`,
+		`func unmarshalFilter(data []byte, consumer runtime.Consumer) (Filter, error) {`,
+		`	buf := bytes.NewBuffer(data`,
+		`	buf2 := bytes.NewBuffer(data`,
+		`	var getType struct {`,
+		"		Type string `json:\"type\"`",
+		`	if err := consumer.Consume(buf, &getType); err != nil {`,
+		`		return nil, err`,
+		`	if err := validate.RequiredString("type", "body", getType.Type); err != nil {`,
+		`		return nil, err`,
+		`	switch getType.Type {`,
+		`	case "AndFilter":`,
+		`		var result AndFilter`,
+		`		if err := consumer.Consume(buf2, &result); err != nil {`,
+		`			return nil, err`,
+		`		return &result, nil`,
+		`	case "Filter":`,
+		`		var result filter`,
+		`		if err := consumer.Consume(buf2, &result); err != nil {`,
+		`			return nil, err`,
+		`		return &result, nil`,
+		`	case "RangeFilter":`,
+		`		var result RangeFilter`,
+		`		if err := consumer.Consume(buf2, &result); err != nil {`,
+		`			return nil, err`,
+		`		return &result, nil`,
+		`	return nil, errors.New(422, "invalid type value: %q", getType.Type`,
+		// empty validation
+		"func (m *filter) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: and_filter_all_of1.go
+	flattenRun.AddExpectations("and_filter_all_of1.go", []string{
+		`type AndFilterAllOf1 struct {`,
+		`	configField []Filter`,
+		`func (m *AndFilterAllOf1) Config() []Filter {`,
+		`	return m.configField`,
+		`func (m *AndFilterAllOf1) SetConfig(val []Filter) {`,
+		`	m.configField = val`,
+		`func (m *AndFilterAllOf1) UnmarshalJSON(raw []byte) error {`,
+		`	var data struct {`,
+		"		Config json.RawMessage `json:\"config\"`",
+		`	buf := bytes.NewBuffer(raw`,
+		`	dec := json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&data); err != nil {`,
+		`	config, err := UnmarshalFilterSlice(bytes.NewBuffer(data.Config), runtime.JSONConsumer()`,
+		`	if err != nil && err != io.EOF {`,
+		`	var result AndFilterAllOf1`,
+		`	result.configField = config`,
+		`	*m = result`,
+		`func (m AndFilterAllOf1) MarshalJSON() ([]byte, error) {`,
+		`	var b1, b2, b3 []byte`,
+		`	var err error`,
+		`	b1, err = json.Marshal(struct {`,
+		`	}{},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	b2, err = json.Marshal(struct {`,
+		"		Config []Filter `json:\"config\"`",
+		`	}{`,
+		`		Config: m.configField,`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return swag.ConcatJSON(b1, b2, b3), nil`,
+		`func (m *AndFilterAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateConfig(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AndFilterAllOf1) validateConfig(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("config", "body", m.Config()); err != nil {`,
+		`	for i := 0; i < len(m.Config()); i++ {`,
+		`		if err := m.configField[i].Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("config" + "." + strconv.Itoa(i)`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: and_filter.go
+	flattenRun.AddExpectations("and_filter.go", []string{
+		`type AndFilter struct {`,
+		`	AndFilterAllOf1`,
+		`func (m *AndFilter) Type() string {`,
+		`	return "AndFilter"`,
+		`func (m *AndFilter) SetType(val string) {`,
+		`func (m *AndFilter) UnmarshalJSON(raw []byte) error {`,
+		`	var data struct {`,
+		`		AndFilterAllOf1`,
+		`	buf := bytes.NewBuffer(raw`,
+		`	dec := json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&data); err != nil {`,
+		`	var base struct {`,
+		"		Type string `json:\"type\"`",
+		`	buf = bytes.NewBuffer(raw`,
+		`	dec = json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&base); err != nil {`,
+		`	var result AndFilter`,
+		`	if base.Type != result.Type() {`,
+		`		return errors.New(422, "invalid type value: %q", base.Type`,
+		`	result.AndFilterAllOf1 = data.AndFilterAllOf1`,
+		`	*m = result`,
+		`func (m AndFilter) MarshalJSON() ([]byte, error) {`,
+		`	var b1, b2, b3 []byte`,
+		`	var err error`,
+		`	b1, err = json.Marshal(struct {`,
+		`		AndFilterAllOf1`,
+		`	}{`,
+		`		AndFilterAllOf1: m.AndFilterAllOf1,`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	b2, err = json.Marshal(struct {`,
+		"		Type string `json:\"type\"`",
+		`	}{`,
+		`		Type: m.Type(),`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return swag.ConcatJSON(b1, b2, b3), nil`,
+		`func (m *AndFilter) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.AndFilterAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: range_filter.go
+	flattenRun.AddExpectations("range_filter.go", []string{
+		`type RangeFilter struct {`,
+		`	RangeFilterAllOf1`,
+		`func (m *RangeFilter) Type() string {`,
+		`	return "RangeFilter"`,
+		`func (m *RangeFilter) SetType(val string) {`,
+		`func (m *RangeFilter) UnmarshalJSON(raw []byte) error {`,
+		`	var data struct {`,
+		`		RangeFilterAllOf1`,
+		`	buf := bytes.NewBuffer(raw`,
+		`	dec := json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&data); err != nil {`,
+		`	var base struct {`,
+		"		Type string `json:\"type\"`",
+		`	buf = bytes.NewBuffer(raw`,
+		`	dec = json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&base); err != nil {`,
+		`	var result RangeFilter`,
+		`	if base.Type != result.Type() {`,
+		`		return errors.New(422, "invalid type value: %q", base.Type`,
+		`	result.RangeFilterAllOf1 = data.RangeFilterAllOf1`,
+		`	*m = result`,
+		`func (m RangeFilter) MarshalJSON() ([]byte, error) {`,
+		`	var b1, b2, b3 []byte`,
+		`	var err error`,
+		`	b1, err = json.Marshal(struct {`,
+		`		RangeFilterAllOf1`,
+		`	}{`,
+		`		RangeFilterAllOf1: m.RangeFilterAllOf1,`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	b2, err = json.Marshal(struct {`,
+		"		Type string `json:\"type\"`",
+		`	}{`,
+		`		Type: m.Type(),`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return swag.ConcatJSON(b1, b2, b3), nil`,
+		`func (m *RangeFilter) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.RangeFilterAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: range_filter_all_of1_config.go
+	flattenRun.AddExpectations("range_filter_all_of1_config.go", []string{
+		`type RangeFilterAllOf1Config struct {`,
+		"	Gt float64 `json:\"gt,omitempty\"`",
+		"	Gte float64 `json:\"gte,omitempty\"`",
+		"	Lt float64 `json:\"lt,omitempty\"`",
+		"	Lte float64 `json:\"lte,omitempty\"`",
+		// empty validation
+		"func (m *RangeFilterAllOf1Config) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixture1336() {
+	// testing ../fixtures/bugs/1487/fixture-1336.yaml with expand (--skip-flatten)
+
+	/* broken code produced on polymorphic type
+	 */
+
+	f := newModelFixture("../fixtures/bugs/1336/fixture-1336.yaml", "broken code when using array of polymorphic type")
+	flattenRun := f.AddRun(false)
+
+	// load expectations for model: node.go
+	flattenRun.AddExpectations("node.go", []string{
+		`type Node interface {`,
+		`	runtime.Validatable`,
+		`	NodeType() string`,
+		`	SetNodeType(string`,
+		`type node struct {`,
+		`	nodeTypeField string`,
+		`func (m *node) NodeType() string {`,
+		`	return "Node"`,
+		`func (m *node) SetNodeType(val string) {`,
+		`func UnmarshalNodeSlice(reader io.Reader, consumer runtime.Consumer) ([]Node, error) {`,
+		`	var elements []json.RawMessage`,
+		`	if err := consumer.Consume(reader, &elements); err != nil {`,
+		`		return nil, err`,
+		`	var result []Node`,
+		`	for _, element := range elements {`,
+		`		obj, err := unmarshalNode(element, consumer`,
+		`		if err != nil {`,
+		`			return nil, err`,
+		`		result = append(result, obj`,
+		`	return result, nil`,
+		`func UnmarshalNode(reader io.Reader, consumer runtime.Consumer) (Node, error) {`,
+		`	data, err := ioutil.ReadAll(reader`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return unmarshalNode(data, consumer`,
+		`func unmarshalNode(data []byte, consumer runtime.Consumer) (Node, error) {`,
+		`	buf := bytes.NewBuffer(data`,
+		`	buf2 := bytes.NewBuffer(data`,
+		`	var getType struct {`,
+		"		NodeType string `json:\"NodeType\"`",
+		`	if err := consumer.Consume(buf, &getType); err != nil {`,
+		`		return nil, err`,
+		`	if err := validate.RequiredString("NodeType", "body", getType.NodeType); err != nil {`,
+		`		return nil, err`,
+		`	switch getType.NodeType {`,
+		`	case "CodeBlockNode":`,
+		`		var result CodeBlockNode`,
+		`		if err := consumer.Consume(buf2, &result); err != nil {`,
+		`			return nil, err`,
+		`		return &result, nil`,
+		`	case "DocBlockNode":`,
+		`		var result DocBlockNode`,
+		`		if err := consumer.Consume(buf2, &result); err != nil {`,
+		`			return nil, err`,
+		`		return &result, nil`,
+		`	case "Node":`,
+		`		var result node`,
+		`		if err := consumer.Consume(buf2, &result); err != nil {`,
+		`			return nil, err`,
+		`		return &result, nil`,
+		`	return nil, errors.New(422, "invalid NodeType value: %q", getType.NodeType`,
+		// empty validation
+		"func (m *node) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: code_block_node_all_of1.go
+	flattenRun.AddExpectations("code_block_node_all_of1.go", []string{
+		`type CodeBlockNodeAllOf1 struct {`,
+		"	Code string `json:\"Code,omitempty\"`",
+		// empty validation
+		"func (m *CodeBlockNodeAllOf1) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: graph.go
+	flattenRun.AddExpectations("graph.go", []string{
+		`type Graph struct {`,
+		`	nodesField []Node`,
+		`func (m *Graph) Nodes() []Node {`,
+		`	return m.nodesField`,
+		`func (m *Graph) SetNodes(val []Node) {`,
+		`	m.nodesField = val`,
+		`func (m *Graph) UnmarshalJSON(raw []byte) error {`,
+		`	var data struct {`,
+		"		Nodes json.RawMessage `json:\"Nodes,omitempty\"`",
+		`	buf := bytes.NewBuffer(raw`,
+		`	dec := json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&data); err != nil {`,
+		`	nodes, err := UnmarshalNodeSlice(bytes.NewBuffer(data.Nodes), runtime.JSONConsumer()`,
+		`	if err != nil && err != io.EOF {`,
+		`	var result Graph`,
+		`	result.nodesField = nodes`,
+		`	*m = result`,
+		`func (m Graph) MarshalJSON() ([]byte, error) {`,
+		`	var b1, b2, b3 []byte`,
+		`	var err error`,
+		`	b1, err = json.Marshal(struct {`,
+		`	}{},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	b2, err = json.Marshal(struct {`,
+		"		Nodes []Node `json:\"Nodes,omitempty\"`",
+		`	}{`,
+		`		Nodes: m.nodesField,`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return swag.ConcatJSON(b1, b2, b3), nil`,
+		`func (m *Graph) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: doc_block_node_all_of1.go
+	flattenRun.AddExpectations("doc_block_node_all_of1.go", []string{
+		`type DocBlockNodeAllOf1 struct {`,
+		"	Doc string `json:\"Doc,omitempty\"`",
+		// empty validation
+		"func (m *DocBlockNodeAllOf1) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: doc_block_node.go
+	flattenRun.AddExpectations("doc_block_node.go", []string{
+		`type DocBlockNode struct {`,
+		`	DocBlockNodeAllOf1`,
+		`func (m *DocBlockNode) NodeType() string {`,
+		`	return "DocBlockNode"`,
+		`func (m *DocBlockNode) SetNodeType(val string) {`,
+		`func (m *DocBlockNode) UnmarshalJSON(raw []byte) error {`,
+		`	var data struct {`,
+		`		DocBlockNodeAllOf1`,
+		`	buf := bytes.NewBuffer(raw`,
+		`	dec := json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&data); err != nil {`,
+		`	var base struct {`,
+		"		NodeType string `json:\"NodeType\"`",
+		`	buf = bytes.NewBuffer(raw`,
+		`	dec = json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&base); err != nil {`,
+		`	var result DocBlockNode`,
+		`	if base.NodeType != result.NodeType() {`,
+		`		return errors.New(422, "invalid NodeType value: %q", base.NodeType`,
+		`	result.DocBlockNodeAllOf1 = data.DocBlockNodeAllOf1`,
+		`	*m = result`,
+		`func (m DocBlockNode) MarshalJSON() ([]byte, error) {`,
+		`	var b1, b2, b3 []byte`,
+		`	var err error`,
+		`	b1, err = json.Marshal(struct {`,
+		`		DocBlockNodeAllOf1`,
+		`	}{`,
+		`		DocBlockNodeAllOf1: m.DocBlockNodeAllOf1,`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	b2, err = json.Marshal(struct {`,
+		"		NodeType string `json:\"NodeType\"`",
+		`	}{`,
+		`		NodeType: m.NodeType(),`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return swag.ConcatJSON(b1, b2, b3), nil`,
+		`func (m *DocBlockNode) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.DocBlockNodeAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: code_block_node.go
+	flattenRun.AddExpectations("code_block_node.go", []string{
+		`type CodeBlockNode struct {`,
+		`	CodeBlockNodeAllOf1`,
+		`func (m *CodeBlockNode) NodeType() string {`,
+		`	return "CodeBlockNode"`,
+		`func (m *CodeBlockNode) SetNodeType(val string) {`,
+		`func (m *CodeBlockNode) UnmarshalJSON(raw []byte) error {`,
+		`	var data struct {`,
+		`		CodeBlockNodeAllOf1`,
+		`	buf := bytes.NewBuffer(raw`,
+		`	dec := json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&data); err != nil {`,
+		`	var base struct {`,
+		"		NodeType string `json:\"NodeType\"`",
+		`	buf = bytes.NewBuffer(raw`,
+		`	dec = json.NewDecoder(buf`,
+		`	dec.UseNumber(`,
+		`	if err := dec.Decode(&base); err != nil {`,
+		`	var result CodeBlockNode`,
+		`	if base.NodeType != result.NodeType() {`,
+		`		return errors.New(422, "invalid NodeType value: %q", base.NodeType`,
+		`	result.CodeBlockNodeAllOf1 = data.CodeBlockNodeAllOf1`,
+		`	*m = result`,
+		`func (m CodeBlockNode) MarshalJSON() ([]byte, error) {`,
+		`	var b1, b2, b3 []byte`,
+		`	var err error`,
+		`	b1, err = json.Marshal(struct {`,
+		`		CodeBlockNodeAllOf1`,
+		`	}{`,
+		`		CodeBlockNodeAllOf1: m.CodeBlockNodeAllOf1,`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	b2, err = json.Marshal(struct {`,
+		"		NodeType string `json:\"NodeType\"`",
+		`	}{`,
+		`		NodeType: m.NodeType(),`,
+		`	},`,
+		`	if err != nil {`,
+		`		return nil, err`,
+		`	return swag.ConcatJSON(b1, b2, b3), nil`,
+		`func (m *CodeBlockNode) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.CodeBlockNodeAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixtureErrors() {
+	// testing ../fixtures/bugs/1487/fixture-errors.yaml with expand (--skip-flatten)
+
+	/*
+		invalid specs supported by go-swagger
+	*/
+
+	f := newModelFixture("../fixtures/bugs/1487/fixture-errors.yaml", "broken spec to exercise error handling")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: node.go
+	flattenRun.AddExpectations("array_without_items.go", []string{
+		`type ArrayWithoutItems []interface{}`,
+		// empty validation
+		"func (m ArrayWithoutItems) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		// NOTE would expect warning for a non-swagger compliant, but nonetheless supposed construct (not implemented)
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("array_without_items.go", flattenRun.ExpectedFor("ArrayWithoutItems").ExpectedLines, todo, noLines, noLines)
+
+	flattenRun.AddExpectations("multiple_types.go", []string{
+		`type MultipleTypes interface{`,
+	},
+		// not expected
+		validatable,
+		// output in log
+		// expect warning
+		warning,
+		noLines)
+
+	expandRun.AddExpectations("multiple_types.go", flattenRun.ExpectedFor("MultipleTypes").ExpectedLines, validatable, noLines, noLines)
+}
+
+func initTodolistSchemavalidation() {
+	// testing todolist.schemavalidation.yaml with flatten and expand (--skip-flatten)
+
+	/*
+	   A very simple api description that makes a json only API to submit to do's.
+
+	*/
+
+	f := newModelFixture("../fixtures/codegen/todolist.schemavalidation.yml", "Private to-do list")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: all_of_validations_meta_all_of6.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of6.go", []string{
+		`type AllOfValidationsMetaAllOf6 struct {`,
+		"	Coords *AllOfValidationsMetaAllOf6Coords `json:\"coords,omitempty\"`",
+		`func (m *AllOfValidationsMetaAllOf6) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateCoords(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf6) validateCoords(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Coords) {`,
+		`	if m.Coords != nil {`,
+		`		if err := m.Coords.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("coords"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_array_validations.go
+	flattenRun.AddExpectations("nested_array_validations.go", []string{
+		`type NestedArrayValidations struct {`,
+		"	Tags [][][]string `json:\"tags\"`",
+		`func (m *NestedArrayValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateTags(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedArrayValidations) validateTags(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Tags) {`,
+		`	iTagsSize := int64(len(m.Tags)`,
+		`	if err := validate.MinItems("tags", "body", iTagsSize, 3); err != nil {`,
+		`	if err := validate.MaxItems("tags", "body", iTagsSize, 10); err != nil {`,
+		`	for i := 0; i < len(m.Tags); i++ {`,
+		`		iiTagsSize := int64(len(m.Tags[i])`,
+		`		if err := validate.MinItems("tags"+"."+strconv.Itoa(i), "body", iiTagsSize, 3); err != nil {`,
+		`		if err := validate.MaxItems("tags"+"."+strconv.Itoa(i), "body", iiTagsSize, 10); err != nil {`,
+		`		for ii := 0; ii < len(m.Tags[i]); ii++ {`,
+		`			iiiTagsSize := int64(len(m.Tags[i][ii])`,
+		`			if err := validate.MinItems("tags"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiTagsSize, 3); err != nil {`,
+		`			if err := validate.MaxItems("tags"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiTagsSize, 10); err != nil {`,
+		`			for iii := 0; iii < len(m.Tags[i][ii]); iii++ {`,
+		`				if err := validate.MinLength("tags"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Tags[i][ii][iii]), 3); err != nil {`,
+		`				if err := validate.MaxLength("tags"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Tags[i][ii][iii]), 10); err != nil {`,
+		"				if err := validate.Pattern(\"tags\"+\".\"+strconv.Itoa(i)+\".\"+strconv.Itoa(ii)+\".\"+strconv.Itoa(iii), \"body\", string(m.Tags[i][ii][iii]), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("nested_array_validations.go", flattenRun.ExpectedFor("NestedArrayValidations").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of4.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of4.go", []string{
+		`type AllOfValidationsMetaAllOf4 struct {`,
+		"	Opts map[string]int32 `json:\"opts,omitempty\"`",
+		`func (m *AllOfValidationsMetaAllOf4) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateOpts(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf4) validateOpts(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Opts) {`,
+		`	for k := range m.Opts {`,
+		`		if swag.IsZero(m.Opts[k]) {`,
+		`		if err := validate.MinimumInt("opts"+"."+k, "body", int64(m.Opts[k]), 2, false); err != nil {`,
+		`		if err := validate.MaximumInt("opts"+"."+k, "body", int64(m.Opts[k]), 50, false); err != nil {`,
+		`		if err := validate.MultipleOf("opts"+"."+k, "body", float64(m.Opts[k]), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: simple_zero_allowed.go
+	flattenRun.AddExpectations("simple_zero_allowed.go", []string{
+		`type SimpleZeroAllowed struct {`,
+		"	ID string `json:\"id,omitempty\"`",
+		"	Name *string `json:\"name\"`",
+		"	Urls []string `json:\"urls\"`",
+		`func (m *SimpleZeroAllowed) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateID(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`	if err := m.validateUrls(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *SimpleZeroAllowed) validateID(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ID) {`,
+		`	if err := validate.MinLength("id", "body", string(m.ID), 2); err != nil {`,
+		`	if err := validate.MaxLength("id", "body", string(m.ID), 50); err != nil {`,
+		"	if err := validate.Pattern(\"id\", \"body\", string(m.ID), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`func (m *SimpleZeroAllowed) validateName(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("name", "body", m.Name); err != nil {`,
+		`	if err := validate.MinLength("name", "body", string(*m.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(*m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(*m.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`func (m *SimpleZeroAllowed) validateUrls(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("urls", "body", m.Urls); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("simple_zero_allowed.go", flattenRun.ExpectedFor("SimpleZeroAllowed").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_all_of_all_of6_coords_all_of0.go
+	flattenRun.AddExpectations("named_all_of_all_of6_coords_all_of0.go", []string{
+		`type NamedAllOfAllOf6CoordsAllOf0 struct {`,
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NamedAllOfAllOf6CoordsAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf6CoordsAllOf0) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_all_of_all_of6.go
+	flattenRun.AddExpectations("named_all_of_all_of6.go", []string{
+		`type NamedAllOfAllOf6 struct {`,
+		"	Coords *NamedAllOfAllOf6Coords `json:\"coords,omitempty\"`",
+		`func (m *NamedAllOfAllOf6) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateCoords(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf6) validateCoords(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Coords) {`,
+		`	if m.Coords != nil {`,
+		`		if err := m.Coords.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("coords"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_array_multi.go
+	flattenRun.AddExpectations("named_array_multi.go", []string{
+		`type NamedArrayMulti struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *float64 `json:\"-\"`",
+		`func (m *NamedArrayMulti) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedArrayMulti) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if err := validate.MinLength("0", "body", string(*m.P0), 3); err != nil {`,
+		`	if err := validate.MaxLength("0", "body", string(*m.P0), 10); err != nil {`,
+		"	if err := validate.Pattern(\"0\", \"body\", string(*m.P0), `\\w+`); err != nil {",
+		`func (m *NamedArrayMulti) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`	if err := validate.Minimum("1", "body", float64(*m.P1), 3, false); err != nil {`,
+		`	if err := validate.Maximum("1", "body", float64(*m.P1), 12, false); err != nil {`,
+		`	if err := validate.MultipleOf("1", "body", float64(*m.P1), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_array_multi.go", flattenRun.ExpectedFor("NamedArrayMulti").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_array.go
+	flattenRun.AddExpectations("named_array.go", []string{
+		`type NamedArray []string`,
+		`func (m NamedArray) Validate(formats strfmt.Registry) error {`,
+		`	iNamedArraySize := int64(len(m)`,
+		`	if err := validate.MinItems("", "body", iNamedArraySize, 3); err != nil {`,
+		`	if err := validate.MaxItems("", "body", iNamedArraySize, 10); err != nil {`,
+		`	for i := 0; i < len(m); i++ {`,
+		`		if err := validate.MinLength(strconv.Itoa(i), "body", string(m[i]), 3); err != nil {`,
+		`		if err := validate.MaxLength(strconv.Itoa(i), "body", string(m[i]), 10); err != nil {`,
+		"		if err := validate.Pattern(strconv.Itoa(i), \"body\", string(m[i]), `\\w+`); err != nil {",
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_array.go", flattenRun.ExpectedFor("NamedArray").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_number.go
+	flattenRun.AddExpectations("named_number.go", []string{
+		`type NamedNumber int32`,
+		`func (m NamedNumber) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.MinimumInt("", "body", int64(m), 0, true); err != nil {`,
+		`	if err := validate.MaximumInt("", "body", int64(m), 500, false); err != nil {`,
+		`	if err := validate.MultipleOf("", "body", float64(m), 1.5); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_number.go", flattenRun.ExpectedFor("NamedNumber").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: nested_map_validations.go
+	flattenRun.AddExpectations("nested_map_validations.go", []string{
+		`type NestedMapValidations struct {`,
+		"	Meta map[string]map[string]map[string]int64 `json:\"meta,omitempty\"`",
+		`func (m *NestedMapValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedMapValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	for k := range m.Meta {`,
+		`		if swag.IsZero(m.Meta[k]) {`,
+		`		for kk := range m.Meta[k] {`,
+		`			if swag.IsZero(m.Meta[k][kk]) {`,
+		`			for kkk := range m.Meta[k][kk] {`,
+		`				if swag.IsZero(m.Meta[k][kk][kkk]) {`,
+		`				if err := validate.MinimumInt("meta"+"."+k+"."+kk+"."+kkk, "body", int64(m.Meta[k][kk][kkk]), 3, false); err != nil {`,
+		`				if err := validate.MaximumInt("meta"+"."+k+"."+kk+"."+kkk, "body", int64(m.Meta[k][kk][kkk]), 6, false); err != nil {`,
+		`				if err := validate.MultipleOf("meta"+"."+k+"."+kk+"."+kkk, "body", float64(m.Meta[k][kk][kkk]), 1); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("nested_map_validations.go", flattenRun.ExpectedFor("NestedMapValidations").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: array_multi_validations_args.go
+	flattenRun.AddExpectations("array_multi_validations_args.go", []string{
+		`type ArrayMultiValidationsArgs struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *float64 `json:\"-\"`",
+		`func (m *ArrayMultiValidationsArgs) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ArrayMultiValidationsArgs) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if err := validate.MinLength("0", "body", string(*m.P0), 3); err != nil {`,
+		`	if err := validate.MaxLength("0", "body", string(*m.P0), 10); err != nil {`,
+		"	if err := validate.Pattern(\"0\", \"body\", string(*m.P0), `\\w+`); err != nil {",
+		`func (m *ArrayMultiValidationsArgs) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`	if err := validate.Minimum("1", "body", float64(*m.P1), 3, false); err != nil {`,
+		`	if err := validate.Maximum("1", "body", float64(*m.P1), 12, false); err != nil {`,
+		`	if err := validate.MultipleOf("1", "body", float64(*m.P1), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_map_complex_additional_properties.go
+	flattenRun.AddExpectations("named_map_complex_additional_properties.go", []string{
+		`type NamedMapComplexAdditionalProperties struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NamedMapComplexAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedMapComplexAdditionalProperties) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NamedMapComplexAdditionalProperties) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_map_complex.go
+	flattenRun.AddExpectations("named_nested_map_complex.go", []string{
+		`type NamedNestedMapComplex map[string]NamedNestedMapComplexAdditionalProperties`,
+		`func (m NamedNestedMapComplex) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_nested_map_complex.go", []string{
+		`type NamedNestedMapComplex map[string]map[string]map[string]NamedNestedMapComplexAnon`,
+		`func (m NamedNestedMapComplex) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		for kk := range m[k] {`,
+		`			if swag.IsZero(m[k][kk]) {`,
+		`			for kkk := range m[k][kk] {`,
+		`				if swag.IsZero(m[k][kk][kkk]) {`,
+		`				if val, ok := m[k][kk][kkk]; ok {`,
+		`					if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type NamedNestedMapComplexAnon struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NamedNestedMapComplexAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedNestedMapComplexAnon) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NamedNestedMapComplexAnon) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of1.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of1.go", []string{
+		`type AllOfValidationsMetaAllOf1 struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		`func (m *AllOfValidationsMetaAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf1) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 2, false); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 50, false); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations_meta_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("nested_map_complex_validations_meta_additional_properties_additional_properties.go", []string{
+		`type NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalProperties map[string]NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties`,
+		`func (m NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalProperties(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: tag.go
+	flattenRun.AddExpectations("tag.go", []string{
+		`type Tag struct {`,
+		"	ID int64 `json:\"id,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		// empty validation
+		"func (m *Tag) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("tag.go", flattenRun.ExpectedFor("Tag").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: nested_object_validations_args.go
+	flattenRun.AddExpectations("nested_object_validations_args.go", []string{
+		`type NestedObjectValidationsArgs struct {`,
+		"	Meta *NestedObjectValidationsArgsMeta `json:\"meta,omitempty\"`",
+		`func (m *NestedObjectValidationsArgs) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedObjectValidationsArgs) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if m.Meta != nil {`,
+		`		if err := m.Meta.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("meta"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_all_of_all_of6_coords_all_of1.go
+	flattenRun.AddExpectations("named_all_of_all_of6_coords_all_of1.go", []string{
+		`type NamedAllOfAllOf6CoordsAllOf1 struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		`func (m *NamedAllOfAllOf6CoordsAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf6CoordsAllOf1) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 2, false); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 50, false); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_all_of_all_of6_coords.go
+	flattenRun.AddExpectations("named_all_of_all_of6_coords.go", []string{
+		`type NamedAllOfAllOf6Coords struct {`,
+		`	NamedAllOfAllOf6CoordsAllOf0`,
+		`	NamedAllOfAllOf6CoordsAllOf1`,
+		`func (m *NamedAllOfAllOf6Coords) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.NamedAllOfAllOf6CoordsAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.NamedAllOfAllOf6CoordsAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: array_multi_validations.go
+	flattenRun.AddExpectations("array_multi_validations.go", []string{
+		`type ArrayMultiValidations struct {`,
+		"	Args ArrayMultiValidationsArgs `json:\"args,omitempty\"`",
+		`func (m *ArrayMultiValidations) Validate(formats strfmt.Registry) error {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("array_multi_validations.go", []string{
+		`type ArrayMultiValidations struct {`,
+		"	Args *ArrayMultiValidationsArgsTuple0 `json:\"args,omitempty\"`",
+		`func (m *ArrayMultiValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateArgs(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ArrayMultiValidations) validateArgs(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Args) {`,
+		`	if m.Args != nil {`,
+		`		if err := m.Args.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("args"`,
+		`type ArrayMultiValidationsArgsTuple0 struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *float64 `json:\"-\"`",
+		`func (m *ArrayMultiValidationsArgsTuple0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ArrayMultiValidationsArgsTuple0) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P0", "body", m.P0); err != nil {`,
+		`	if err := validate.MinLength("P0", "body", string(*m.P0), 3); err != nil {`,
+		`	if err := validate.MaxLength("P0", "body", string(*m.P0), 10); err != nil {`,
+		"	if err := validate.Pattern(\"P0\", \"body\", string(*m.P0), `\\w+`); err != nil {",
+		`func (m *ArrayMultiValidationsArgsTuple0) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P1", "body", m.P1); err != nil {`,
+		`	if err := validate.Minimum("P1", "body", float64(*m.P1), 3, false); err != nil {`,
+		`	if err := validate.Maximum("P1", "body", float64(*m.P1), 12, false); err != nil {`,
+		`	if err := validate.MultipleOf("P1", "body", float64(*m.P1), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: string_validations.go
+	flattenRun.AddExpectations("string_validations.go", []string{
+		`type StringValidations struct {`,
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *StringValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *StringValidations) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("string_validations.go", flattenRun.ExpectedFor("StringValidations").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: required_props.go
+	flattenRun.AddExpectations("required_props.go", []string{
+		`type RequiredProps struct {`,
+		"	Age *int32 `json:\"age\"`",
+		"	CreatedAt *strfmt.DateTime `json:\"createdAt\"`",
+		"	ID *int64 `json:\"id\"`",
+		"	Name *string `json:\"name\"`",
+		"	Score *float32 `json:\"score\"`",
+		"	Tags []string `json:\"tags\"`",
+		`func (m *RequiredProps) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateCreatedAt(formats); err != nil {`,
+		`	if err := m.validateID(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`	if err := m.validateScore(formats); err != nil {`,
+		`	if err := m.validateTags(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *RequiredProps) validateAge(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("age", "body", m.Age); err != nil {`,
+		`func (m *RequiredProps) validateCreatedAt(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("createdAt", "body", m.CreatedAt); err != nil {`,
+		`	if err := validate.FormatOf("createdAt", "body", "date-time", m.CreatedAt.String(), formats); err != nil {`,
+		`func (m *RequiredProps) validateID(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("id", "body", m.ID); err != nil {`,
+		`func (m *RequiredProps) validateName(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("name", "body", m.Name); err != nil {`,
+		`func (m *RequiredProps) validateScore(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("score", "body", m.Score); err != nil {`,
+		`func (m *RequiredProps) validateTags(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("tags", "body", m.Tags); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("required_props.go", flattenRun.ExpectedFor("RequiredProps").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_all_of_all_of5.go
+	flattenRun.AddExpectations("named_all_of_all_of5.go", []string{
+		`type NamedAllOfAllOf5 struct {`,
+		"	ExtOpts map[string]map[string]map[string]int32 `json:\"extOpts,omitempty\"`",
+		`func (m *NamedAllOfAllOf5) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateExtOpts(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf5) validateExtOpts(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ExtOpts) {`,
+		`	for k := range m.ExtOpts {`,
+		`		if swag.IsZero(m.ExtOpts[k]) {`,
+		`		for kk := range m.ExtOpts[k] {`,
+		`			if swag.IsZero(m.ExtOpts[k][kk]) {`,
+		`			for kkk := range m.ExtOpts[k][kk] {`,
+		`				if swag.IsZero(m.ExtOpts[k][kk][kkk]) {`,
+		`				if err := validate.MinimumInt("extOpts"+"."+k+"."+kk+"."+kkk, "body", int64(m.ExtOpts[k][kk][kkk]), 2, false); err != nil {`,
+		`				if err := validate.MaximumInt("extOpts"+"."+k+"."+kk+"."+kkk, "body", int64(m.ExtOpts[k][kk][kkk]), 50, false); err != nil {`,
+		`				if err := validate.MultipleOf("extOpts"+"."+k+"."+kk+"."+kkk, "body", float64(m.ExtOpts[k][kk][kkk]), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_map.go
+	flattenRun.AddExpectations("named_map.go", []string{
+		`type NamedMap map[string]int64`,
+		`func (m NamedMap) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if err := validate.MinimumInt(k, "body", int64(m[k]), 3, false); err != nil {`,
+		`		if err := validate.MaximumInt(k, "body", int64(m[k]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf(k, "body", float64(m[k]), 1); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_map.go", flattenRun.ExpectedFor("NamedMap").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_string.go
+	flattenRun.AddExpectations("named_string.go", []string{
+		`type NamedString string`,
+		`func (m NamedString) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.MinLength("", "body", string(m), 2); err != nil {`,
+		`	if err := validate.MaxLength("", "body", string(m), 50); err != nil {`,
+		"	if err := validate.Pattern(\"\", \"body\", string(m), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_string.go", flattenRun.ExpectedFor("NamedString").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_all_of_all_of3.go
+	flattenRun.AddExpectations("named_all_of_all_of3.go", []string{
+		`type NamedAllOfAllOf3 struct {`,
+		"	Assoc [][][]string `json:\"assoc\"`",
+		`func (m *NamedAllOfAllOf3) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAssoc(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf3) validateAssoc(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Assoc) {`,
+		`	iAssocSize := int64(len(m.Assoc)`,
+		`	if err := validate.MinItems("assoc", "body", iAssocSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("assoc", "body", iAssocSize, 20); err != nil {`,
+		`	for i := 0; i < len(m.Assoc); i++ {`,
+		`		iiAssocSize := int64(len(m.Assoc[i])`,
+		`		if err := validate.MinItems("assoc"+"."+strconv.Itoa(i), "body", iiAssocSize, 5); err != nil {`,
+		`		if err := validate.MaxItems("assoc"+"."+strconv.Itoa(i), "body", iiAssocSize, 20); err != nil {`,
+		`		for ii := 0; ii < len(m.Assoc[i]); ii++ {`,
+		`			iiiAssocSize := int64(len(m.Assoc[i][ii])`,
+		`			if err := validate.MinItems("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiAssocSize, 5); err != nil {`,
+		`			if err := validate.MaxItems("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiAssocSize, 20); err != nil {`,
+		`			for iii := 0; iii < len(m.Assoc[i][ii]); iii++ {`,
+		`				if err := validate.MinLength("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Assoc[i][ii][iii]), 2); err != nil {`,
+		`				if err := validate.MaxLength("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Assoc[i][ii][iii]), 50); err != nil {`,
+		"				if err := validate.Pattern(\"assoc\"+\".\"+strconv.Itoa(i)+\".\"+strconv.Itoa(ii)+\".\"+strconv.Itoa(iii), \"body\", string(m.Assoc[i][ii][iii]), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: map_complex_validations.go
+	flattenRun.AddExpectations("map_complex_validations.go", []string{
+		`type MapComplexValidations struct {`,
+		"	Meta MapComplexValidationsMeta `json:\"meta,omitempty\"`",
+		`func (m *MapComplexValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *MapComplexValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if err := m.Meta.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("meta"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("map_complex_validations.go", []string{
+		`type MapComplexValidations struct {`,
+		"	Meta map[string]MapComplexValidationsMetaAnon `json:\"meta,omitempty\"`",
+		`func (m *MapComplexValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *MapComplexValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	for k := range m.Meta {`,
+		`		if swag.IsZero(m.Meta[k]) {`,
+		`		if val, ok := m.Meta[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`type MapComplexValidationsMetaAnon struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *MapComplexValidationsMetaAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *MapComplexValidationsMetaAnon) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *MapComplexValidationsMetaAnon) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_map_complex_additional_properties_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("named_nested_map_complex_additional_properties_additional_properties_additional_properties.go", []string{
+		`type NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of6_coords.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of6_coords.go", []string{
+		`type AllOfValidationsMetaAllOf6Coords struct {`,
+		`	AllOfValidationsMetaAllOf6CoordsAllOf0`,
+		`	AllOfValidationsMetaAllOf6CoordsAllOf1`,
+		`func (m *AllOfValidationsMetaAllOf6Coords) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.AllOfValidationsMetaAllOf6CoordsAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.AllOfValidationsMetaAllOf6CoordsAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: array_validations.go
+	flattenRun.AddExpectations("array_validations.go", []string{
+		`type ArrayValidations struct {`,
+		"	Tags []string `json:\"tags\"`",
+		`func (m *ArrayValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateTags(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ArrayValidations) validateTags(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Tags) {`,
+		`	iTagsSize := int64(len(m.Tags)`,
+		`	if err := validate.MinItems("tags", "body", iTagsSize, 3); err != nil {`,
+		`	if err := validate.MaxItems("tags", "body", iTagsSize, 10); err != nil {`,
+		`	for i := 0; i < len(m.Tags); i++ {`,
+		`		if err := validate.MinLength("tags"+"."+strconv.Itoa(i), "body", string(m.Tags[i]), 3); err != nil {`,
+		`		if err := validate.MaxLength("tags"+"."+strconv.Itoa(i), "body", string(m.Tags[i]), 10); err != nil {`,
+		"		if err := validate.Pattern(\"tags\"+\".\"+strconv.Itoa(i), \"body\", string(m.Tags[i]), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("array_validations.go", flattenRun.ExpectedFor("ArrayValidations").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: all_of_validations_meta.go
+	flattenRun.AddExpectations("all_of_validations_meta.go", []string{
+		`type AllOfValidationsMeta struct {`,
+		`	AllOfValidationsMetaAllOf0`,
+		`	AllOfValidationsMetaAllOf1`,
+		`	AllOfValidationsMetaAllOf2`,
+		`	AllOfValidationsMetaAllOf3`,
+		`	AllOfValidationsMetaAllOf4`,
+		`	AllOfValidationsMetaAllOf5`,
+		`	AllOfValidationsMetaAllOf6`,
+		`func (m *AllOfValidationsMeta) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.AllOfValidationsMetaAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.AllOfValidationsMetaAllOf1.Validate(formats); err != nil {`,
+		`	if err := m.AllOfValidationsMetaAllOf2.Validate(formats); err != nil {`,
+		`	if err := m.AllOfValidationsMetaAllOf3.Validate(formats); err != nil {`,
+		`	if err := m.AllOfValidationsMetaAllOf4.Validate(formats); err != nil {`,
+		`	if err := m.AllOfValidationsMetaAllOf5.Validate(formats); err != nil {`,
+		`	if err := m.AllOfValidationsMetaAllOf6.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: map_complex_validations_meta_additional_properties.go
+	flattenRun.AddExpectations("map_complex_validations_meta_additional_properties.go", []string{
+		`type MapComplexValidationsMetaAdditionalProperties struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *MapComplexValidationsMetaAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *MapComplexValidationsMetaAdditionalProperties) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *MapComplexValidationsMetaAdditionalProperties) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations_meta_additional_properties.go
+	flattenRun.AddExpectations("nested_map_complex_validations_meta_additional_properties.go", []string{
+		`type NestedMapComplexValidationsMetaAdditionalProperties map[string]NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalProperties`,
+		`func (m NestedMapComplexValidationsMetaAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of6_coords_all_of1.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of6_coords_all_of1.go", []string{
+		`type AllOfValidationsMetaAllOf6CoordsAllOf1 struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		`func (m *AllOfValidationsMetaAllOf6CoordsAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf6CoordsAllOf1) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 2, false); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 50, false); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of3.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of3.go", []string{
+		`type AllOfValidationsMetaAllOf3 struct {`,
+		"	Assoc [][][]string `json:\"assoc\"`",
+		`func (m *AllOfValidationsMetaAllOf3) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAssoc(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf3) validateAssoc(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Assoc) {`,
+		`	iAssocSize := int64(len(m.Assoc)`,
+		`	if err := validate.MinItems("assoc", "body", iAssocSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("assoc", "body", iAssocSize, 20); err != nil {`,
+		`	for i := 0; i < len(m.Assoc); i++ {`,
+		`		iiAssocSize := int64(len(m.Assoc[i])`,
+		`		if err := validate.MinItems("assoc"+"."+strconv.Itoa(i), "body", iiAssocSize, 5); err != nil {`,
+		`		if err := validate.MaxItems("assoc"+"."+strconv.Itoa(i), "body", iiAssocSize, 20); err != nil {`,
+		`		for ii := 0; ii < len(m.Assoc[i]); ii++ {`,
+		`			iiiAssocSize := int64(len(m.Assoc[i][ii])`,
+		`			if err := validate.MinItems("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiAssocSize, 5); err != nil {`,
+		`			if err := validate.MaxItems("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiAssocSize, 20); err != nil {`,
+		`			for iii := 0; iii < len(m.Assoc[i][ii]); iii++ {`,
+		`				if err := validate.MinLength("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Assoc[i][ii][iii]), 2); err != nil {`,
+		`				if err := validate.MaxLength("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Assoc[i][ii][iii]), 50); err != nil {`,
+		"				if err := validate.Pattern(\"assoc\"+\".\"+strconv.Itoa(i)+\".\"+strconv.Itoa(ii)+\".\"+strconv.Itoa(iii), \"body\", string(m.Assoc[i][ii][iii]), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_object_validations.go
+	flattenRun.AddExpectations("nested_object_validations.go", []string{
+		`type NestedObjectValidations struct {`,
+		"	Args *NestedObjectValidationsArgs `json:\"args,omitempty\"`",
+		`func (m *NestedObjectValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateArgs(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedObjectValidations) validateArgs(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Args) {`,
+		`	if m.Args != nil {`,
+		`		if err := m.Args.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("args"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("nested_object_validations.go", []string{
+		`type NestedObjectValidations struct {`,
+		"	Args *NestedObjectValidationsArgs `json:\"args,omitempty\"`",
+		`func (m *NestedObjectValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateArgs(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedObjectValidations) validateArgs(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Args) {`,
+		`	if m.Args != nil {`,
+		`		if err := m.Args.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("args"`,
+		`type NestedObjectValidationsArgs struct {`,
+		"	Meta *NestedObjectValidationsArgsMeta `json:\"meta,omitempty\"`",
+		`func (m *NestedObjectValidationsArgs) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedObjectValidationsArgs) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if m.Meta != nil {`,
+		`		if err := m.Meta.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("args" + "." + "meta"`,
+		`type NestedObjectValidationsArgsMeta struct {`,
+		"	First string `json:\"first,omitempty\"`",
+		"	Fourth [][][]float32 `json:\"fourth\"`",
+		"	Second float64 `json:\"second,omitempty\"`",
+		"	Third []float32 `json:\"third\"`",
+		`func (m *NestedObjectValidationsArgsMeta) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateFirst(formats); err != nil {`,
+		`	if err := m.validateFourth(formats); err != nil {`,
+		`	if err := m.validateSecond(formats); err != nil {`,
+		`	if err := m.validateThird(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedObjectValidationsArgsMeta) validateFirst(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.First) {`,
+		`	if err := validate.MinLength("args"+"."+"meta"+"."+"first", "body", string(m.First), 2); err != nil {`,
+		`	if err := validate.MaxLength("args"+"."+"meta"+"."+"first", "body", string(m.First), 50); err != nil {`,
+		"	if err := validate.Pattern(\"args\"+\".\"+\"meta\"+\".\"+\"first\", \"body\", string(m.First), `^\\w+`); err != nil {",
+		`func (m *NestedObjectValidationsArgsMeta) validateFourth(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Fourth) {`,
+		`	iFourthSize := int64(len(m.Fourth)`,
+		`	if err := validate.MinItems("args"+"."+"meta"+"."+"fourth", "body", iFourthSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("args"+"."+"meta"+"."+"fourth", "body", iFourthSize, 93); err != nil {`,
+		`	for i := 0; i < len(m.Fourth); i++ {`,
+		`		iiFourthSize := int64(len(m.Fourth[i])`,
+		`		if err := validate.MinItems("args"+"."+"meta"+"."+"fourth"+"."+strconv.Itoa(i), "body", iiFourthSize, 5); err != nil {`,
+		`		if err := validate.MaxItems("args"+"."+"meta"+"."+"fourth"+"."+strconv.Itoa(i), "body", iiFourthSize, 93); err != nil {`,
+		`		for ii := 0; ii < len(m.Fourth[i]); ii++ {`,
+		`			iiiFourthSize := int64(len(m.Fourth[i][ii])`,
+		`			if err := validate.MinItems("args"+"."+"meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiFourthSize, 5); err != nil {`,
+		`			if err := validate.MaxItems("args"+"."+"meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiFourthSize, 93); err != nil {`,
+		`			for iii := 0; iii < len(m.Fourth[i][ii]); iii++ {`,
+		`				if err := validate.Minimum("args"+"."+"meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 3, false); err != nil {`,
+		`				if err := validate.Maximum("args"+"."+"meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 6, false); err != nil {`,
+		`				if err := validate.MultipleOf("args"+"."+"meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 0.5); err != nil {`,
+		`func (m *NestedObjectValidationsArgsMeta) validateSecond(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Second) {`,
+		`	if err := validate.Minimum("args"+"."+"meta"+"."+"second", "body", float64(m.Second), 3, false); err != nil {`,
+		`	if err := validate.Maximum("args"+"."+"meta"+"."+"second", "body", float64(m.Second), 51, false); err != nil {`,
+		`	if err := validate.MultipleOf("args"+"."+"meta"+"."+"second", "body", float64(m.Second), 1.5); err != nil {`,
+		`func (m *NestedObjectValidationsArgsMeta) validateThird(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Third) {`,
+		`	iThirdSize := int64(len(m.Third)`,
+		`	if err := validate.MinItems("args"+"."+"meta"+"."+"third", "body", iThirdSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("args"+"."+"meta"+"."+"third", "body", iThirdSize, 93); err != nil {`,
+		`	for i := 0; i < len(m.Third); i++ {`,
+		`		if err := validate.Minimum("args"+"."+"meta"+"."+"third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 3, false); err != nil {`,
+		`		if err := validate.Maximum("args"+"."+"meta"+"."+"third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf("args"+"."+"meta"+"."+"third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 0.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_array_additional.go
+	flattenRun.AddExpectations("named_array_additional.go", []string{
+		`type NamedArrayAdditional struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *float64 `json:\"-\"`",
+		"	NamedArrayAdditionalItems []int64 `json:\"-\"`",
+		`func (m *NamedArrayAdditional) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateNamedArrayAdditionalItems(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedArrayAdditional) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if err := validate.MinLength("0", "body", string(*m.P0), 3); err != nil {`,
+		`	if err := validate.MaxLength("0", "body", string(*m.P0), 10); err != nil {`,
+		"	if err := validate.Pattern(\"0\", \"body\", string(*m.P0), `\\w+`); err != nil {",
+		`func (m *NamedArrayAdditional) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`	if err := validate.Minimum("1", "body", float64(*m.P1), 3, false); err != nil {`,
+		`	if err := validate.Maximum("1", "body", float64(*m.P1), 12, false); err != nil {`,
+		`	if err := validate.MultipleOf("1", "body", float64(*m.P1), 1.5); err != nil {`,
+		`func (m *NamedArrayAdditional) validateNamedArrayAdditionalItems(formats strfmt.Registry) error {`,
+		`	for i := range m.NamedArrayAdditionalItems {`,
+		`		if err := validate.MinimumInt(strconv.Itoa(i+2), "body", int64(m.NamedArrayAdditionalItems[i]), 3, false); err != nil {`,
+		`		if err := validate.MaximumInt(strconv.Itoa(i+2), "body", int64(m.NamedArrayAdditionalItems[i]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf(strconv.Itoa(i+2), "body", float64(m.NamedArrayAdditionalItems[i]), 1); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_array_additional.go", flattenRun.ExpectedFor("NamedArrayAdditional").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: pet.go
+	flattenRun.AddExpectations("pet.go", []string{
+		`type Pet struct {`,
+		"	Category *Category `json:\"category,omitempty\"`",
+		"	ID int64 `json:\"id,omitempty\"`",
+		"	Name *string `json:\"name\"`",
+		"	PhotoUrls []string `json:\"photoUrls\" xml:\"photoUrl\"`",
+		"	Status string `json:\"status,omitempty\"`",
+		"	Tags []*Tag `json:\"tags\" xml:\"tag\"`",
+		`func (m *Pet) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateCategory(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`	if err := m.validatePhotoUrls(formats); err != nil {`,
+		`	if err := m.validateStatus(formats); err != nil {`,
+		`	if err := m.validateTags(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Pet) validateCategory(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Category) {`,
+		`	if m.Category != nil {`,
+		`		if err := m.Category.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("category"`,
+		`func (m *Pet) validateName(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("name", "body", m.Name); err != nil {`,
+		`func (m *Pet) validatePhotoUrls(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("photoUrls", "body", m.PhotoUrls); err != nil {`,
+		`var petTypeStatusPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"available\",\"pending\",\"sold\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		petTypeStatusPropEnum = append(petTypeStatusPropEnum, v`,
+		`	PetStatusAvailable string = "available"`,
+		`	PetStatusPending string = "pending"`,
+		`	PetStatusSold string = "sold"`,
+		`func (m *Pet) validateStatusEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, petTypeStatusPropEnum); err != nil {`,
+		`func (m *Pet) validateStatus(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Status) {`,
+		`	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {`,
+		`func (m *Pet) validateTags(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Tags) {`,
+		`	for i := 0; i < len(m.Tags); i++ {`,
+		`		if swag.IsZero(m.Tags[i]) {`,
+		`		if m.Tags[i] != nil {`,
+		`			if err := m.Tags[i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName("tags" + "." + strconv.Itoa(i)`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("pet.go", []string{
+		`type Pet struct {`,
+		"	Category *PetCategory `json:\"category,omitempty\"`",
+		"	ID int64 `json:\"id,omitempty\"`",
+		"	Name *string `json:\"name\"`",
+		"	PhotoUrls []string `json:\"photoUrls\" xml:\"photoUrl\"`",
+		"	Status string `json:\"status,omitempty\"`",
+		"	Tags []*PetTagsItems0 `json:\"tags\" xml:\"tag\"`",
+		`func (m *Pet) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateCategory(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`	if err := m.validatePhotoUrls(formats); err != nil {`,
+		`	if err := m.validateStatus(formats); err != nil {`,
+		`	if err := m.validateTags(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Pet) validateCategory(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Category) {`,
+		`	if m.Category != nil {`,
+		`		if err := m.Category.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("category"`,
+		`func (m *Pet) validateName(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("name", "body", m.Name); err != nil {`,
+		`func (m *Pet) validatePhotoUrls(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("photoUrls", "body", m.PhotoUrls); err != nil {`,
+		`var petTypeStatusPropEnum []interface{`,
+		`	var res []string`,
+		"	if err := json.Unmarshal([]byte(`[\"available\",\"pending\",\"sold\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		petTypeStatusPropEnum = append(petTypeStatusPropEnum, v`,
+		`	PetStatusAvailable string = "available"`,
+		`	PetStatusPending string = "pending"`,
+		`	PetStatusSold string = "sold"`,
+		`func (m *Pet) validateStatusEnum(path, location string, value string) error {`,
+		`	if err := validate.Enum(path, location, value, petTypeStatusPropEnum); err != nil {`,
+		`func (m *Pet) validateStatus(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Status) {`,
+		`	if err := m.validateStatusEnum("status", "body", m.Status); err != nil {`,
+		`func (m *Pet) validateTags(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Tags) {`,
+		`	for i := 0; i < len(m.Tags); i++ {`,
+		`		if swag.IsZero(m.Tags[i]) {`,
+		`		if m.Tags[i] != nil {`,
+		`			if err := m.Tags[i].Validate(formats); err != nil {`,
+		`				if ve, ok := err.(*errors.Validation); ok {`,
+		`					return ve.ValidateName("tags" + "." + strconv.Itoa(i)`,
+		`type PetCategory struct {`,
+		"	ID int64 `json:\"id,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		// empty validation
+		"func (m *PetCategory) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+		`type PetTagsItems0 struct {`,
+		"	ID int64 `json:\"id,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		// empty validation
+		"func (m *PetTagsItems0) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: map_complex_validations_meta.go
+	flattenRun.AddExpectations("map_complex_validations_meta.go", []string{
+		`type MapComplexValidationsMeta map[string]MapComplexValidationsMetaAdditionalProperties`,
+		`func (m MapComplexValidationsMeta) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", MapComplexValidationsMeta(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: array_additional_validations_args.go
+	flattenRun.AddExpectations("array_additional_validations_args.go", []string{
+		`type ArrayAdditionalValidationsArgs struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *float64 `json:\"-\"`",
+		"	ArrayAdditionalValidationsArgsItems []int64 `json:\"-\"`",
+		`func (m *ArrayAdditionalValidationsArgs) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateArrayAdditionalValidationsArgsItems(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ArrayAdditionalValidationsArgs) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if err := validate.MinLength("0", "body", string(*m.P0), 3); err != nil {`,
+		`	if err := validate.MaxLength("0", "body", string(*m.P0), 10); err != nil {`,
+		"	if err := validate.Pattern(\"0\", \"body\", string(*m.P0), `\\w+`); err != nil {",
+		`func (m *ArrayAdditionalValidationsArgs) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`	if err := validate.Minimum("1", "body", float64(*m.P1), 3, false); err != nil {`,
+		`	if err := validate.Maximum("1", "body", float64(*m.P1), 12, false); err != nil {`,
+		`	if err := validate.MultipleOf("1", "body", float64(*m.P1), 1.5); err != nil {`,
+		`func (m *ArrayAdditionalValidationsArgs) validateArrayAdditionalValidationsArgsItems(formats strfmt.Registry) error {`,
+		`	for i := range m.ArrayAdditionalValidationsArgsItems {`,
+		`		if err := validate.MinimumInt(strconv.Itoa(i+2), "body", int64(m.ArrayAdditionalValidationsArgsItems[i]), 3, false); err != nil {`,
+		`		if err := validate.MaximumInt(strconv.Itoa(i+2), "body", int64(m.ArrayAdditionalValidationsArgsItems[i]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf(strconv.Itoa(i+2), "body", float64(m.ArrayAdditionalValidationsArgsItems[i]), 1); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of2.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of2.go", []string{
+		`type AllOfValidationsMetaAllOf2 struct {`,
+		"	Args []string `json:\"args\"`",
+		`func (m *AllOfValidationsMetaAllOf2) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateArgs(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf2) validateArgs(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Args) {`,
+		`	iArgsSize := int64(len(m.Args)`,
+		`	if err := validate.MinItems("args", "body", iArgsSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("args", "body", iArgsSize, 20); err != nil {`,
+		`	for i := 0; i < len(m.Args); i++ {`,
+		`		if err := validate.MinLength("args"+"."+strconv.Itoa(i), "body", string(m.Args[i]), 2); err != nil {`,
+		`		if err := validate.MaxLength("args"+"."+strconv.Itoa(i), "body", string(m.Args[i]), 50); err != nil {`,
+		"		if err := validate.Pattern(\"args\"+\".\"+strconv.Itoa(i), \"body\", string(m.Args[i]), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of0.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of0.go", []string{
+		`type AllOfValidationsMetaAllOf0 struct {`,
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *AllOfValidationsMetaAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf0) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_all_of_all_of4.go
+	flattenRun.AddExpectations("named_all_of_all_of4.go", []string{
+		`type NamedAllOfAllOf4 struct {`,
+		"	Opts map[string]float64 `json:\"opts,omitempty\"`",
+		`func (m *NamedAllOfAllOf4) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateOpts(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf4) validateOpts(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Opts) {`,
+		`	for k := range m.Opts {`,
+		`		if swag.IsZero(m.Opts[k]) {`,
+		`		if err := validate.Minimum("opts"+"."+k, "body", float64(m.Opts[k]), 2, false); err != nil {`,
+		`		if err := validate.Maximum("opts"+"."+k, "body", float64(m.Opts[k]), 50, false); err != nil {`,
+		`		if err := validate.MultipleOf("opts"+"."+k, "body", float64(m.Opts[k]), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_all_of_all_of0.go
+	flattenRun.AddExpectations("named_all_of_all_of0.go", []string{
+		`type NamedAllOfAllOf0 struct {`,
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NamedAllOfAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf0) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations_meta_additional_properties_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("nested_map_complex_validations_meta_additional_properties_additional_properties_additional_properties.go", []string{
+		`type NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: refed_all_of_validations.go
+	flattenRun.AddExpectations("refed_all_of_validations.go", []string{
+		`type RefedAllOfValidations struct {`,
+		`	NamedString`,
+		`	NamedNumber`,
+		`func (m *RefedAllOfValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.NamedString.Validate(formats); err != nil {`,
+		`	if err := m.NamedNumber.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("refed_all_of_validations.go", []string{
+		`type RefedAllOfValidations struct {`,
+		`	RefedAllOfValidationsAllOf0`,
+		`	RefedAllOfValidationsAllOf1`,
+		`func (m *RefedAllOfValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.RefedAllOfValidationsAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.RefedAllOfValidationsAllOf1.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type RefedAllOfValidationsAllOf0 string`,
+		`func (m RefedAllOfValidationsAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.MinLength("", "body", string(m), 2); err != nil {`,
+		`	if err := validate.MaxLength("", "body", string(m), 50); err != nil {`,
+		"	if err := validate.Pattern(\"\", \"body\", string(m), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`		return errors.CompositeValidationError(res...`,
+		`type RefedAllOfValidationsAllOf1 int32`,
+		`func (m RefedAllOfValidationsAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.MinimumInt("", "body", int64(m), 0, true); err != nil {`,
+		`	if err := validate.MaximumInt("", "body", int64(m), 500, false); err != nil {`,
+		`	if err := validate.MultipleOf("", "body", float64(m), 1.5); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: update_org.go
+	flattenRun.AddExpectations("update_org.go", []string{
+		`type UpdateOrg struct {`,
+		"	Email string `json:\"email,omitempty\"`",
+		"	InvoiceEmail bool `json:\"invoice_email,omitempty\"`",
+		"	TagExpiration *int64 `json:\"tag_expiration,omitempty\"`",
+		`func (m *UpdateOrg) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateTagExpiration(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *UpdateOrg) validateTagExpiration(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.TagExpiration) {`,
+		`	if err := validate.MinimumInt("tag_expiration", "body", int64(*m.TagExpiration), 0, false); err != nil {`,
+		`	if err := validate.MaximumInt("tag_expiration", "body", int64(*m.TagExpiration), 2.592e+06, false); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("update_org.go", flattenRun.ExpectedFor("UpdateOrg").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: number_validations.go
+	flattenRun.AddExpectations("number_validations.go", []string{
+		`type NumberValidations struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		`func (m *NumberValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NumberValidations) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 0, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 500, false); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("number_validations.go", flattenRun.ExpectedFor("NumberValidations").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: nested_map_complex_validations.go
+	flattenRun.AddExpectations("nested_map_complex_validations.go", []string{
+		`type NestedMapComplexValidations struct {`,
+		"	Meta NestedMapComplexValidationsMeta `json:\"meta,omitempty\"`",
+		`func (m *NestedMapComplexValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedMapComplexValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if err := m.Meta.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("meta"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("nested_map_complex_validations.go", []string{
+		`type NestedMapComplexValidations struct {`,
+		"	Meta map[string]map[string]map[string]NestedMapComplexValidationsMetaAnon `json:\"meta,omitempty\"`",
+		`func (m *NestedMapComplexValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedMapComplexValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	for k := range m.Meta {`,
+		`		if swag.IsZero(m.Meta[k]) {`,
+		`		for kk := range m.Meta[k] {`,
+		`			if swag.IsZero(m.Meta[k][kk]) {`,
+		`			for kkk := range m.Meta[k][kk] {`,
+		`				if swag.IsZero(m.Meta[k][kk][kkk]) {`,
+		`				if val, ok := m.Meta[k][kk][kkk]; ok {`,
+		`					if err := val.Validate(formats); err != nil {`,
+		`type NestedMapComplexValidationsMetaAnon struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NestedMapComplexValidationsMetaAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedMapComplexValidationsMetaAnon) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NestedMapComplexValidationsMetaAnon) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: category.go
+	flattenRun.AddExpectations("category.go", []string{
+		`type Category struct {`,
+		"	ID int64 `json:\"id,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		// empty validation
+		"func (m *Category) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("category.go", flattenRun.ExpectedFor("Category").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_all_of_all_of2.go
+	flattenRun.AddExpectations("named_all_of_all_of2.go", []string{
+		`type NamedAllOfAllOf2 struct {`,
+		"	Args []string `json:\"args\"`",
+		`func (m *NamedAllOfAllOf2) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateArgs(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf2) validateArgs(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Args) {`,
+		`	iArgsSize := int64(len(m.Args)`,
+		`	if err := validate.MinItems("args", "body", iArgsSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("args", "body", iArgsSize, 20); err != nil {`,
+		`	for i := 0; i < len(m.Args); i++ {`,
+		`		if err := validate.MinLength("args"+"."+strconv.Itoa(i), "body", string(m.Args[i]), 2); err != nil {`,
+		`		if err := validate.MaxLength("args"+"."+strconv.Itoa(i), "body", string(m.Args[i]), 50); err != nil {`,
+		"		if err := validate.Pattern(\"args\"+\".\"+strconv.Itoa(i), \"body\", string(m.Args[i]), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_map_complex_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("named_nested_map_complex_additional_properties_additional_properties.go", []string{
+		`type NamedNestedMapComplexAdditionalPropertiesAdditionalProperties map[string]NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties`,
+		`func (m NamedNestedMapComplexAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", NamedNestedMapComplexAdditionalPropertiesAdditionalProperties(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_map_complex_additional_properties.go
+	flattenRun.AddExpectations("named_nested_map_complex_additional_properties.go", []string{
+		`type NamedNestedMapComplexAdditionalProperties map[string]NamedNestedMapComplexAdditionalPropertiesAdditionalProperties`,
+		`func (m NamedNestedMapComplexAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_array.go
+	flattenRun.AddExpectations("named_nested_array.go", []string{
+		`type NamedNestedArray [][][]string`,
+		`func (m NamedNestedArray) Validate(formats strfmt.Registry) error {`,
+		`	iNamedNestedArraySize := int64(len(m)`,
+		`	if err := validate.MinItems("", "body", iNamedNestedArraySize, 3); err != nil {`,
+		`	if err := validate.MaxItems("", "body", iNamedNestedArraySize, 10); err != nil {`,
+		`	for i := 0; i < len(m); i++ {`,
+		`		iiNamedNestedArraySize := int64(len(m[i])`,
+		`		if err := validate.MinItems(strconv.Itoa(i), "body", iiNamedNestedArraySize, 3); err != nil {`,
+		`		if err := validate.MaxItems(strconv.Itoa(i), "body", iiNamedNestedArraySize, 10); err != nil {`,
+		`		for ii := 0; ii < len(m[i]); ii++ {`,
+		`			iiiNamedNestedArraySize := int64(len(m[i][ii])`,
+		`			if err := validate.MinItems(strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiNamedNestedArraySize, 3); err != nil {`,
+		`			if err := validate.MaxItems(strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiNamedNestedArraySize, 10); err != nil {`,
+		`			for iii := 0; iii < len(m[i][ii]); iii++ {`,
+		`				if err := validate.MinLength(strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m[i][ii][iii]), 3); err != nil {`,
+		`				if err := validate.MaxLength(strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m[i][ii][iii]), 10); err != nil {`,
+		"				if err := validate.Pattern(strconv.Itoa(i)+\".\"+strconv.Itoa(ii)+\".\"+strconv.Itoa(iii), \"body\", string(m[i][ii][iii]), `\\w+`); err != nil {",
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_nested_array.go", flattenRun.ExpectedFor("NamedNestedArray").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_all_of.go
+	flattenRun.AddExpectations("named_all_of.go", []string{
+		`type NamedAllOf struct {`,
+		`	NamedAllOfAllOf0`,
+		`	NamedAllOfAllOf1`,
+		`	NamedAllOfAllOf2`,
+		`	NamedAllOfAllOf3`,
+		`	NamedAllOfAllOf4`,
+		`	NamedAllOfAllOf5`,
+		`	NamedAllOfAllOf6`,
+		`func (m *NamedAllOf) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.NamedAllOfAllOf0.Validate(formats); err != nil {`,
+		`	if err := m.NamedAllOfAllOf1.Validate(formats); err != nil {`,
+		`	if err := m.NamedAllOfAllOf2.Validate(formats); err != nil {`,
+		`	if err := m.NamedAllOfAllOf3.Validate(formats); err != nil {`,
+		`	if err := m.NamedAllOfAllOf4.Validate(formats); err != nil {`,
+		`	if err := m.NamedAllOfAllOf5.Validate(formats); err != nil {`,
+		`	if err := m.NamedAllOfAllOf6.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_all_of.go", []string{
+		`type NamedAllOf struct {`,
+		"	Name string `json:\"name,omitempty\"`",
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Args []string `json:\"args\"`",
+		"	Assoc [][][]string `json:\"assoc\"`",
+		"	Opts map[string]float64 `json:\"opts,omitempty\"`",
+		"	ExtOpts map[string]map[string]map[string]int32 `json:\"extOpts,omitempty\"`",
+		`	Coords struct {`,
+		"		Name string `json:\"name,omitempty\"`",
+		"		Age int32 `json:\"age,omitempty\"`",
+		"	} `json:\"coords,omitempty\"`",
+		`func (m *NamedAllOf) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateArgs(formats); err != nil {`,
+		`	if err := m.validateAssoc(formats); err != nil {`,
+		`	if err := m.validateOpts(formats); err != nil {`,
+		`	if err := m.validateExtOpts(formats); err != nil {`,
+		`	if err := m.validateCoords(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOf) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`func (m *NamedAllOf) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 2, false); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 50, false); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1.5); err != nil {`,
+		`func (m *NamedAllOf) validateArgs(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Args) {`,
+		`	iArgsSize := int64(len(m.Args)`,
+		`	if err := validate.MinItems("args", "body", iArgsSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("args", "body", iArgsSize, 20); err != nil {`,
+		`	for i := 0; i < len(m.Args); i++ {`,
+		`		if err := validate.MinLength("args"+"."+strconv.Itoa(i), "body", string(m.Args[i]), 2); err != nil {`,
+		`		if err := validate.MaxLength("args"+"."+strconv.Itoa(i), "body", string(m.Args[i]), 50); err != nil {`,
+		"		if err := validate.Pattern(\"args\"+\".\"+strconv.Itoa(i), \"body\", string(m.Args[i]), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`func (m *NamedAllOf) validateAssoc(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Assoc) {`,
+		`	iAssocSize := int64(len(m.Assoc)`,
+		`	if err := validate.MinItems("assoc", "body", iAssocSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("assoc", "body", iAssocSize, 20); err != nil {`,
+		`	for i := 0; i < len(m.Assoc); i++ {`,
+		`		iiAssocSize := int64(len(m.Assoc[i])`,
+		`		if err := validate.MinItems("assoc"+"."+strconv.Itoa(i), "body", iiAssocSize, 5); err != nil {`,
+		`		if err := validate.MaxItems("assoc"+"."+strconv.Itoa(i), "body", iiAssocSize, 20); err != nil {`,
+		`		for ii := 0; ii < len(m.Assoc[i]); ii++ {`,
+		`			iiiAssocSize := int64(len(m.Assoc[i][ii])`,
+		`			if err := validate.MinItems("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiAssocSize, 5); err != nil {`,
+		`			if err := validate.MaxItems("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiAssocSize, 20); err != nil {`,
+		`			for iii := 0; iii < len(m.Assoc[i][ii]); iii++ {`,
+		`				if err := validate.MinLength("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Assoc[i][ii][iii]), 2); err != nil {`,
+		`				if err := validate.MaxLength("assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Assoc[i][ii][iii]), 50); err != nil {`,
+		"				if err := validate.Pattern(\"assoc\"+\".\"+strconv.Itoa(i)+\".\"+strconv.Itoa(ii)+\".\"+strconv.Itoa(iii), \"body\", string(m.Assoc[i][ii][iii]), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`func (m *NamedAllOf) validateOpts(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Opts) {`,
+		`	for k := range m.Opts {`,
+		`		if swag.IsZero(m.Opts[k]) {`,
+		`		if err := validate.Minimum("opts"+"."+k, "body", float64(m.Opts[k]), 2, false); err != nil {`,
+		`		if err := validate.Maximum("opts"+"."+k, "body", float64(m.Opts[k]), 50, false); err != nil {`,
+		`		if err := validate.MultipleOf("opts"+"."+k, "body", float64(m.Opts[k]), 1.5); err != nil {`,
+		`func (m *NamedAllOf) validateExtOpts(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ExtOpts) {`,
+		`	for k := range m.ExtOpts {`,
+		`		if swag.IsZero(m.ExtOpts[k]) {`,
+		`		for kk := range m.ExtOpts[k] {`,
+		`			if swag.IsZero(m.ExtOpts[k][kk]) {`,
+		`			for kkk := range m.ExtOpts[k][kk] {`,
+		`				if swag.IsZero(m.ExtOpts[k][kk][kkk]) {`,
+		`				if err := validate.MinimumInt("extOpts"+"."+k+"."+kk+"."+kkk, "body", int64(m.ExtOpts[k][kk][kkk]), 2, false); err != nil {`,
+		`				if err := validate.MaximumInt("extOpts"+"."+k+"."+kk+"."+kkk, "body", int64(m.ExtOpts[k][kk][kkk]), 50, false); err != nil {`,
+		`				if err := validate.MultipleOf("extOpts"+"."+k+"."+kk+"."+kkk, "body", float64(m.ExtOpts[k][kk][kkk]), 1.5); err != nil {`,
+		`func (m *NamedAllOf) validateCoords(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Coords) {`,
+		`	if err := validate.MinLength("coords"+"."+"name", "body", string(m.Coords.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("coords"+"."+"name", "body", string(m.Coords.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"coords\"+\".\"+\"name\", \"body\", string(m.Coords.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`	if err := validate.MinimumInt("coords"+"."+"age", "body", int64(m.Coords.Age), 2, false); err != nil {`,
+		`	if err := validate.MaximumInt("coords"+"."+"age", "body", int64(m.Coords.Age), 50, false); err != nil {`,
+		`	if err := validate.MultipleOf("coords"+"."+"age", "body", float64(m.Coords.Age), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_map_complex.go
+	flattenRun.AddExpectations("named_map_complex.go", []string{
+		`type NamedMapComplex map[string]NamedMapComplexAdditionalProperties`,
+		`func (m NamedMapComplex) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", NamedMapComplex(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_map_complex.go", []string{
+		`type NamedMapComplex map[string]NamedMapComplexAnon`,
+		`func (m NamedMapComplex) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type NamedMapComplexAnon struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NamedMapComplexAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedMapComplexAnon) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NamedMapComplexAnon) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations_meta.go
+	flattenRun.AddExpectations("nested_map_complex_validations_meta.go", []string{
+		`type NestedMapComplexValidationsMeta map[string]NestedMapComplexValidationsMetaAdditionalProperties`,
+		`func (m NestedMapComplexValidationsMeta) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: array_additional_validations.go
+	flattenRun.AddExpectations("array_additional_validations.go", []string{
+		`type ArrayAdditionalValidations struct {`,
+		"	Args ArrayAdditionalValidationsArgs `json:\"args,omitempty\"`",
+		`func (m *ArrayAdditionalValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateArgs(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ArrayAdditionalValidations) validateArgs(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Args) {`,
+		`	if err := m.Args.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("args"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("array_additional_validations.go", []string{
+		`type ArrayAdditionalValidations struct {`,
+		"	Args *ArrayAdditionalValidationsArgsTuple0 `json:\"args,omitempty\"`",
+		`func (m *ArrayAdditionalValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateArgs(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ArrayAdditionalValidations) validateArgs(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Args) {`,
+		`	if m.Args != nil {`,
+		`		if err := m.Args.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("args"`,
+		`type ArrayAdditionalValidationsArgsTuple0 struct {`,
+		"	P0 *string `json:\"-\"`",
+		"	P1 *float64 `json:\"-\"`",
+		"	ArrayAdditionalValidationsArgsTuple0Items []int64 `json:\"-\"`",
+		`func (m *ArrayAdditionalValidationsArgsTuple0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateArrayAdditionalValidationsArgsTuple0Items(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *ArrayAdditionalValidationsArgsTuple0) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P0", "body", m.P0); err != nil {`,
+		`	if err := validate.MinLength("P0", "body", string(*m.P0), 3); err != nil {`,
+		`	if err := validate.MaxLength("P0", "body", string(*m.P0), 10); err != nil {`,
+		"	if err := validate.Pattern(\"P0\", \"body\", string(*m.P0), `\\w+`); err != nil {",
+		`func (m *ArrayAdditionalValidationsArgsTuple0) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("P1", "body", m.P1); err != nil {`,
+		`	if err := validate.Minimum("P1", "body", float64(*m.P1), 3, false); err != nil {`,
+		`	if err := validate.Maximum("P1", "body", float64(*m.P1), 12, false); err != nil {`,
+		`	if err := validate.MultipleOf("P1", "body", float64(*m.P1), 1.5); err != nil {`,
+		`func (m *ArrayAdditionalValidationsArgsTuple0) validateArrayAdditionalValidationsArgsTuple0Items(formats strfmt.Registry) error {`,
+		`	for i := range m.ArrayAdditionalValidationsArgsTuple0Items {`,
+		`		if err := validate.MinimumInt(strconv.Itoa(i), "body", int64(m.ArrayAdditionalValidationsArgsTuple0Items[i]), 3, false); err != nil {`,
+		`		if err := validate.MaximumInt(strconv.Itoa(i), "body", int64(m.ArrayAdditionalValidationsArgsTuple0Items[i]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf(strconv.Itoa(i), "body", float64(m.ArrayAdditionalValidationsArgsTuple0Items[i]), 1); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_object_validations_args_meta.go
+	flattenRun.AddExpectations("nested_object_validations_args_meta.go", []string{
+		`type NestedObjectValidationsArgsMeta struct {`,
+		"	First string `json:\"first,omitempty\"`",
+		"	Fourth [][][]float32 `json:\"fourth\"`",
+		"	Second float64 `json:\"second,omitempty\"`",
+		"	Third []float32 `json:\"third\"`",
+		`func (m *NestedObjectValidationsArgsMeta) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateFirst(formats); err != nil {`,
+		`	if err := m.validateFourth(formats); err != nil {`,
+		`	if err := m.validateSecond(formats); err != nil {`,
+		`	if err := m.validateThird(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedObjectValidationsArgsMeta) validateFirst(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.First) {`,
+		`	if err := validate.MinLength("first", "body", string(m.First), 2); err != nil {`,
+		`	if err := validate.MaxLength("first", "body", string(m.First), 50); err != nil {`,
+		"	if err := validate.Pattern(\"first\", \"body\", string(m.First), `^\\w+`); err != nil {",
+		`func (m *NestedObjectValidationsArgsMeta) validateFourth(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Fourth) {`,
+		`	iFourthSize := int64(len(m.Fourth)`,
+		`	if err := validate.MinItems("fourth", "body", iFourthSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("fourth", "body", iFourthSize, 93); err != nil {`,
+		`	for i := 0; i < len(m.Fourth); i++ {`,
+		`		iiFourthSize := int64(len(m.Fourth[i])`,
+		`		if err := validate.MinItems("fourth"+"."+strconv.Itoa(i), "body", iiFourthSize, 5); err != nil {`,
+		`		if err := validate.MaxItems("fourth"+"."+strconv.Itoa(i), "body", iiFourthSize, 93); err != nil {`,
+		`		for ii := 0; ii < len(m.Fourth[i]); ii++ {`,
+		`			iiiFourthSize := int64(len(m.Fourth[i][ii])`,
+		`			if err := validate.MinItems("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiFourthSize, 5); err != nil {`,
+		`			if err := validate.MaxItems("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiFourthSize, 93); err != nil {`,
+		`			for iii := 0; iii < len(m.Fourth[i][ii]); iii++ {`,
+		`				if err := validate.Minimum("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 3, false); err != nil {`,
+		`				if err := validate.Maximum("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 6, false); err != nil {`,
+		`				if err := validate.MultipleOf("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 0.5); err != nil {`,
+		`func (m *NestedObjectValidationsArgsMeta) validateSecond(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Second) {`,
+		`	if err := validate.Minimum("second", "body", float64(m.Second), 3, false); err != nil {`,
+		`	if err := validate.Maximum("second", "body", float64(m.Second), 51, false); err != nil {`,
+		`	if err := validate.MultipleOf("second", "body", float64(m.Second), 1.5); err != nil {`,
+		`func (m *NestedObjectValidationsArgsMeta) validateThird(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Third) {`,
+		`	iThirdSize := int64(len(m.Third)`,
+		`	if err := validate.MinItems("third", "body", iThirdSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("third", "body", iThirdSize, 93); err != nil {`,
+		`	for i := 0; i < len(m.Third); i++ {`,
+		`		if err := validate.Minimum("third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 3, false); err != nil {`,
+		`		if err := validate.Maximum("third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf("third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 0.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: map_validations.go
+	flattenRun.AddExpectations("map_validations.go", []string{
+		`type MapValidations struct {`,
+		"	Meta map[string]int64 `json:\"meta,omitempty\"`",
+		`func (m *MapValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *MapValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	for k := range m.Meta {`,
+		`		if swag.IsZero(m.Meta[k]) {`,
+		`		if err := validate.MinimumInt("meta"+"."+k, "body", int64(m.Meta[k]), 3, false); err != nil {`,
+		`		if err := validate.MaximumInt("meta"+"."+k, "body", int64(m.Meta[k]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf("meta"+"."+k, "body", float64(m.Meta[k]), 1); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("map_validations.go", flattenRun.ExpectedFor("MapValidations").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_all_of_all_of1.go
+	flattenRun.AddExpectations("named_all_of_all_of1.go", []string{
+		`type NamedAllOfAllOf1 struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		`func (m *NamedAllOfAllOf1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedAllOfAllOf1) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 2, false); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 50, false); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of5.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of5.go", []string{
+		`type AllOfValidationsMetaAllOf5 struct {`,
+		"	ExtOpts map[string]map[string]map[string]int32 `json:\"extOpts,omitempty\"`",
+		`func (m *AllOfValidationsMetaAllOf5) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateExtOpts(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf5) validateExtOpts(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.ExtOpts) {`,
+		`	for k := range m.ExtOpts {`,
+		`		if swag.IsZero(m.ExtOpts[k]) {`,
+		`		for kk := range m.ExtOpts[k] {`,
+		`			if swag.IsZero(m.ExtOpts[k][kk]) {`,
+		`			for kkk := range m.ExtOpts[k][kk] {`,
+		`				if swag.IsZero(m.ExtOpts[k][kk][kkk]) {`,
+		`				if err := validate.MinimumInt("extOpts"+"."+k+"."+kk+"."+kkk, "body", int64(m.ExtOpts[k][kk][kkk]), 2, false); err != nil {`,
+		`				if err := validate.MaximumInt("extOpts"+"."+k+"."+kk+"."+kkk, "body", int64(m.ExtOpts[k][kk][kkk]), 50, false); err != nil {`,
+		`				if err := validate.MultipleOf("extOpts"+"."+k+"."+kk+"."+kkk, "body", float64(m.ExtOpts[k][kk][kkk]), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations.go
+	flattenRun.AddExpectations("all_of_validations.go", []string{
+		`type AllOfValidations struct {`,
+		"	Meta *AllOfValidationsMeta `json:\"meta,omitempty\"`",
+		`func (m *AllOfValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if m.Meta != nil {`,
+		`		if err := m.Meta.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("meta"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("all_of_validations.go", []string{
+		`type AllOfValidations struct {`,
+		`	Meta struct {`,
+		"		Name string `json:\"name,omitempty\"`",
+		"		Age int32 `json:\"age,omitempty\"`",
+		"		Args []string `json:\"args\"`",
+		"		Assoc [][][]string `json:\"assoc\"`",
+		"		Opts map[string]int32 `json:\"opts,omitempty\"`",
+		"		ExtOpts map[string]map[string]map[string]int32 `json:\"extOpts,omitempty\"`",
+		`		Coords struct {`,
+		"			Name string `json:\"name,omitempty\"`",
+		"			Age int32 `json:\"age,omitempty\"`",
+		"		} `json:\"coords,omitempty\"`",
+		"	} `json:\"meta,omitempty\"`",
+		`func (m *AllOfValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if err := validate.MinLength("meta"+"."+"name", "body", string(m.Meta.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("meta"+"."+"name", "body", string(m.Meta.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"meta\"+\".\"+\"name\", \"body\", string(m.Meta.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`	if err := validate.MinimumInt("meta"+"."+"age", "body", int64(m.Meta.Age), 2, false); err != nil {`,
+		`	if err := validate.MaximumInt("meta"+"."+"age", "body", int64(m.Meta.Age), 50, false); err != nil {`,
+		`	if err := validate.MultipleOf("meta"+"."+"age", "body", float64(m.Meta.Age), 1.5); err != nil {`,
+		`	iArgsSize := int64(len(m.Meta.Args)`,
+		`	if err := validate.MinItems("meta"+"."+"args", "body", iArgsSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("meta"+"."+"args", "body", iArgsSize, 20); err != nil {`,
+		`	for i := 0; i < len(m.Meta.Args); i++ {`,
+		`		if err := validate.MinLength("meta"+"."+"args"+"."+strconv.Itoa(i), "body", string(m.Meta.Args[i]), 2); err != nil {`,
+		`		if err := validate.MaxLength("meta"+"."+"args"+"."+strconv.Itoa(i), "body", string(m.Meta.Args[i]), 50); err != nil {`,
+		"		if err := validate.Pattern(\"meta\"+\".\"+\"args\"+\".\"+strconv.Itoa(i), \"body\", string(m.Meta.Args[i]), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`	iAssocSize := int64(len(m.Meta.Assoc)`,
+		`	if err := validate.MinItems("meta"+"."+"assoc", "body", iAssocSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("meta"+"."+"assoc", "body", iAssocSize, 20); err != nil {`,
+		`	for i := 0; i < len(m.Meta.Assoc); i++ {`,
+		`		iiAssocSize := int64(len(m.Meta.Assoc[i])`,
+		`		if err := validate.MinItems("meta"+"."+"assoc"+"."+strconv.Itoa(i), "body", iiAssocSize, 5); err != nil {`,
+		`		if err := validate.MaxItems("meta"+"."+"assoc"+"."+strconv.Itoa(i), "body", iiAssocSize, 20); err != nil {`,
+		`		for ii := 0; ii < len(m.Meta.Assoc[i]); ii++ {`,
+		`			iiiAssocSize := int64(len(m.Meta.Assoc[i][ii])`,
+		`			if err := validate.MinItems("meta"+"."+"assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiAssocSize, 5); err != nil {`,
+		`			if err := validate.MaxItems("meta"+"."+"assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiAssocSize, 20); err != nil {`,
+		`			for iii := 0; iii < len(m.Meta.Assoc[i][ii]); iii++ {`,
+		`				if err := validate.MinLength("meta"+"."+"assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Meta.Assoc[i][ii][iii]), 2); err != nil {`,
+		`				if err := validate.MaxLength("meta"+"."+"assoc"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", string(m.Meta.Assoc[i][ii][iii]), 50); err != nil {`,
+		"				if err := validate.Pattern(\"meta\"+\".\"+\"assoc\"+\".\"+strconv.Itoa(i)+\".\"+strconv.Itoa(ii)+\".\"+strconv.Itoa(iii), \"body\", string(m.Meta.Assoc[i][ii][iii]), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`	for k := range m.Meta.Opts {`,
+		`		if swag.IsZero(m.Meta.Opts[k]) {`,
+		`		if err := validate.MinimumInt("meta"+"."+"opts"+"."+k, "body", int64(m.Meta.Opts[k]), 2, false); err != nil {`,
+		`		if err := validate.MaximumInt("meta"+"."+"opts"+"."+k, "body", int64(m.Meta.Opts[k]), 50, false); err != nil {`,
+		`		if err := validate.MultipleOf("meta"+"."+"opts"+"."+k, "body", float64(m.Meta.Opts[k]), 1.5); err != nil {`,
+		`	for k := range m.Meta.ExtOpts {`,
+		`		if swag.IsZero(m.Meta.ExtOpts[k]) {`,
+		`		for kk := range m.Meta.ExtOpts[k] {`,
+		`			if swag.IsZero(m.Meta.ExtOpts[k][kk]) {`,
+		`			for kkk := range m.Meta.ExtOpts[k][kk] {`,
+		`				if swag.IsZero(m.Meta.ExtOpts[k][kk][kkk]) {`,
+		`				if err := validate.MinimumInt("meta"+"."+"extOpts"+"."+k+"."+kk+"."+kkk, "body", int64(m.Meta.ExtOpts[k][kk][kkk]), 2, false); err != nil {`,
+		`				if err := validate.MaximumInt("meta"+"."+"extOpts"+"."+k+"."+kk+"."+kkk, "body", int64(m.Meta.ExtOpts[k][kk][kkk]), 50, false); err != nil {`,
+		`				if err := validate.MultipleOf("meta"+"."+"extOpts"+"."+k+"."+kk+"."+kkk, "body", float64(m.Meta.ExtOpts[k][kk][kkk]), 1.5); err != nil {`,
+		`	if err := validate.MinLength("meta"+"."+"coords"+"."+"name", "body", string(m.Meta.Coords.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("meta"+"."+"coords"+"."+"name", "body", string(m.Meta.Coords.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"meta\"+\".\"+\"coords\"+\".\"+\"name\", \"body\", string(m.Meta.Coords.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+		`	if err := validate.MinimumInt("meta"+"."+"coords"+"."+"age", "body", int64(m.Meta.Coords.Age), 2, false); err != nil {`,
+		`	if err := validate.MaximumInt("meta"+"."+"coords"+"."+"age", "body", int64(m.Meta.Coords.Age), 50, false); err != nil {`,
+		`	if err := validate.MultipleOf("meta"+"."+"coords"+"."+"age", "body", float64(m.Meta.Coords.Age), 1.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_object_meta.go
+	flattenRun.AddExpectations("named_nested_object_meta.go", []string{
+		`type NamedNestedObjectMeta struct {`,
+		"	First string `json:\"first,omitempty\"`",
+		"	Fourth [][][]float32 `json:\"fourth\"`",
+		"	Second float64 `json:\"second,omitempty\"`",
+		"	Third []float32 `json:\"third\"`",
+		`func (m *NamedNestedObjectMeta) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateFirst(formats); err != nil {`,
+		`	if err := m.validateFourth(formats); err != nil {`,
+		`	if err := m.validateSecond(formats); err != nil {`,
+		`	if err := m.validateThird(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedNestedObjectMeta) validateFirst(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.First) {`,
+		`	if err := validate.MinLength("first", "body", string(m.First), 2); err != nil {`,
+		`	if err := validate.MaxLength("first", "body", string(m.First), 50); err != nil {`,
+		"	if err := validate.Pattern(\"first\", \"body\", string(m.First), `^\\w+`); err != nil {",
+		`func (m *NamedNestedObjectMeta) validateFourth(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Fourth) {`,
+		`	iFourthSize := int64(len(m.Fourth)`,
+		`	if err := validate.MinItems("fourth", "body", iFourthSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("fourth", "body", iFourthSize, 93); err != nil {`,
+		`	for i := 0; i < len(m.Fourth); i++ {`,
+		`		iiFourthSize := int64(len(m.Fourth[i])`,
+		`		if err := validate.MinItems("fourth"+"."+strconv.Itoa(i), "body", iiFourthSize, 5); err != nil {`,
+		`		if err := validate.MaxItems("fourth"+"."+strconv.Itoa(i), "body", iiFourthSize, 93); err != nil {`,
+		`		for ii := 0; ii < len(m.Fourth[i]); ii++ {`,
+		`			iiiFourthSize := int64(len(m.Fourth[i][ii])`,
+		`			if err := validate.MinItems("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiFourthSize, 5); err != nil {`,
+		`			if err := validate.MaxItems("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiFourthSize, 93); err != nil {`,
+		`			for iii := 0; iii < len(m.Fourth[i][ii]); iii++ {`,
+		`				if err := validate.Minimum("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 3, false); err != nil {`,
+		`				if err := validate.Maximum("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 6, false); err != nil {`,
+		`				if err := validate.MultipleOf("fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 0.5); err != nil {`,
+		`func (m *NamedNestedObjectMeta) validateSecond(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Second) {`,
+		`	if err := validate.Minimum("second", "body", float64(m.Second), 3, false); err != nil {`,
+		`	if err := validate.Maximum("second", "body", float64(m.Second), 51, false); err != nil {`,
+		`	if err := validate.MultipleOf("second", "body", float64(m.Second), 1.5); err != nil {`,
+		`func (m *NamedNestedObjectMeta) validateThird(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Third) {`,
+		`	iThirdSize := int64(len(m.Third)`,
+		`	if err := validate.MinItems("third", "body", iThirdSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("third", "body", iThirdSize, 93); err != nil {`,
+		`	for i := 0; i < len(m.Third); i++ {`,
+		`		if err := validate.Minimum("third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 3, false); err != nil {`,
+		`		if err := validate.Maximum("third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf("third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 0.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_object.go
+	flattenRun.AddExpectations("named_nested_object.go", []string{
+		`type NamedNestedObject struct {`,
+		"	Meta *NamedNestedObjectMeta `json:\"meta,omitempty\"`",
+		`func (m *NamedNestedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedNestedObject) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if m.Meta != nil {`,
+		`		if err := m.Meta.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("meta"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_nested_object.go", []string{
+		`type NamedNestedObject struct {`,
+		"	Meta *NamedNestedObjectMeta `json:\"meta,omitempty\"`",
+		`func (m *NamedNestedObject) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedNestedObject) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if m.Meta != nil {`,
+		`		if err := m.Meta.Validate(formats); err != nil {`,
+		`			if ve, ok := err.(*errors.Validation); ok {`,
+		`				return ve.ValidateName("meta"`,
+		`type NamedNestedObjectMeta struct {`,
+		"	First string `json:\"first,omitempty\"`",
+		"	Fourth [][][]float32 `json:\"fourth\"`",
+		"	Second float64 `json:\"second,omitempty\"`",
+		"	Third []float32 `json:\"third\"`",
+		`func (m *NamedNestedObjectMeta) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateFirst(formats); err != nil {`,
+		`	if err := m.validateFourth(formats); err != nil {`,
+		`	if err := m.validateSecond(formats); err != nil {`,
+		`	if err := m.validateThird(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedNestedObjectMeta) validateFirst(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.First) {`,
+		`	if err := validate.MinLength("meta"+"."+"first", "body", string(m.First), 2); err != nil {`,
+		`	if err := validate.MaxLength("meta"+"."+"first", "body", string(m.First), 50); err != nil {`,
+		"	if err := validate.Pattern(\"meta\"+\".\"+\"first\", \"body\", string(m.First), `^\\w+`); err != nil {",
+		`func (m *NamedNestedObjectMeta) validateFourth(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Fourth) {`,
+		`	iFourthSize := int64(len(m.Fourth)`,
+		`	if err := validate.MinItems("meta"+"."+"fourth", "body", iFourthSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("meta"+"."+"fourth", "body", iFourthSize, 93); err != nil {`,
+		`	for i := 0; i < len(m.Fourth); i++ {`,
+		`		iiFourthSize := int64(len(m.Fourth[i])`,
+		`		if err := validate.MinItems("meta"+"."+"fourth"+"."+strconv.Itoa(i), "body", iiFourthSize, 5); err != nil {`,
+		`		if err := validate.MaxItems("meta"+"."+"fourth"+"."+strconv.Itoa(i), "body", iiFourthSize, 93); err != nil {`,
+		`		for ii := 0; ii < len(m.Fourth[i]); ii++ {`,
+		`			iiiFourthSize := int64(len(m.Fourth[i][ii])`,
+		`			if err := validate.MinItems("meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiFourthSize, 5); err != nil {`,
+		`			if err := validate.MaxItems("meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii), "body", iiiFourthSize, 93); err != nil {`,
+		`			for iii := 0; iii < len(m.Fourth[i][ii]); iii++ {`,
+		`				if err := validate.Minimum("meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 3, false); err != nil {`,
+		`				if err := validate.Maximum("meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 6, false); err != nil {`,
+		`				if err := validate.MultipleOf("meta"+"."+"fourth"+"."+strconv.Itoa(i)+"."+strconv.Itoa(ii)+"."+strconv.Itoa(iii), "body", float64(m.Fourth[i][ii][iii]), 0.5); err != nil {`,
+		`func (m *NamedNestedObjectMeta) validateSecond(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Second) {`,
+		`	if err := validate.Minimum("meta"+"."+"second", "body", float64(m.Second), 3, false); err != nil {`,
+		`	if err := validate.Maximum("meta"+"."+"second", "body", float64(m.Second), 51, false); err != nil {`,
+		`	if err := validate.MultipleOf("meta"+"."+"second", "body", float64(m.Second), 1.5); err != nil {`,
+		`func (m *NamedNestedObjectMeta) validateThird(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Third) {`,
+		`	iThirdSize := int64(len(m.Third)`,
+		`	if err := validate.MinItems("meta"+"."+"third", "body", iThirdSize, 5); err != nil {`,
+		`	if err := validate.MaxItems("meta"+"."+"third", "body", iThirdSize, 93); err != nil {`,
+		`	for i := 0; i < len(m.Third); i++ {`,
+		`		if err := validate.Minimum("meta"+"."+"third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 3, false); err != nil {`,
+		`		if err := validate.Maximum("meta"+"."+"third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 6, false); err != nil {`,
+		`		if err := validate.MultipleOf("meta"+"."+"third"+"."+strconv.Itoa(i), "body", float64(m.Third[i]), 0.5); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: all_of_validations_meta_all_of6_coords_all_of0.go
+	flattenRun.AddExpectations("all_of_validations_meta_all_of6_coords_all_of0.go", []string{
+		`type AllOfValidationsMetaAllOf6CoordsAllOf0 struct {`,
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *AllOfValidationsMetaAllOf6CoordsAllOf0) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AllOfValidationsMetaAllOf6CoordsAllOf0) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 2); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `[A-Za-z0-9][\\w- ]+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_map.go
+	flattenRun.AddExpectations("named_nested_map.go", []string{
+		`type NamedNestedMap map[string]map[string]map[string]int64`,
+		`func (m NamedNestedMap) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		for kk := range m[k] {`,
+		`			if swag.IsZero(m[k][kk]) {`,
+		`			for kkk := range m[k][kk] {`,
+		`				if swag.IsZero(m[k][kk][kkk]) {`,
+		`				if err := validate.MinimumInt(k+"."+kk+"."+kkk, "body", int64(m[k][kk][kkk]), 3, false); err != nil {`,
+		`				if err := validate.MaximumInt(k+"."+kk+"."+kkk, "body", int64(m[k][kk][kkk]), 6, false); err != nil {`,
+		`				if err := validate.MultipleOf(k+"."+kk+"."+kkk, "body", float64(m[k][kk][kkk]), 1); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_nested_map.go", flattenRun.ExpectedFor("NamedNestedMap").ExpectedLines, todo, noLines, noLines)
+}
+
+func initFixtureNestedMaps() {
+	// testing fixture-nested-maps.yaml with flatten and expand (--skip-flatten)
+
+	/*
+	   Test specifically focused on nested maps (e.g.nested additionalProperties)
+
+	*/
+
+	f := newModelFixture("../fixtures/bugs/1487/fixture-nested-maps.yaml", "Nested maps")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: alias_interface.go
+	flattenRun.AddExpectations("alias_interface.go", []string{
+		`type AliasInterface interface{`,
+	},
+		// not expected
+		validatable,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("alias_interface.go", flattenRun.ExpectedFor("AliasInterface").ExpectedLines, validatable, noLines, noLines)
+
+	// load expectations for model: test_nested_aliased_interface.go
+	flattenRun.AddExpectations("test_nested_aliased_interface.go", []string{
+		`type TestNestedAliasedInterface struct {`,
+		"	Meta map[string]map[string]map[string]AliasInterface `json:\"meta,omitempty\"`",
+		// empty validation
+		"func (m *TestNestedAliasedInterface) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("test_nested_aliased_interface.go", []string{
+		`type TestNestedAliasedInterface struct {`,
+		"	Meta map[string]map[string]map[string]interface{} `json:\"meta,omitempty\"`",
+		// empty validation
+		"func (m *TestNestedAliasedInterface) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_validations.go
+	flattenRun.AddExpectations("nested_map_validations.go", []string{
+		`type NestedMapValidations struct {`,
+		"	Meta map[string]map[string]map[string]int64 `json:\"meta,omitempty\"`",
+		`func (m *NestedMapValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedMapValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	for k := range m.Meta {`,
+		`		if swag.IsZero(m.Meta[k]) {`,
+		`		for kk := range m.Meta[k] {`,
+		`			if swag.IsZero(m.Meta[k][kk]) {`,
+		`			for kkk := range m.Meta[k][kk] {`,
+		`				if swag.IsZero(m.Meta[k][kk][kkk]) {`,
+		`				if err := validate.MinimumInt("meta"+"."+k+"."+kk+"."+kkk, "body", int64(m.Meta[k][kk][kkk]), 3, false); err != nil {`,
+		`				if err := validate.MaximumInt("meta"+"."+k+"."+kk+"."+kkk, "body", int64(m.Meta[k][kk][kkk]), 6, false); err != nil {`,
+		`				if err := validate.MultipleOf("meta"+"."+k+"."+kk+"."+kkk, "body", float64(m.Meta[k][kk][kkk]), 1); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("nested_map_validations.go", flattenRun.ExpectedFor("NestedMapValidations").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_nested_map_complex.go
+	flattenRun.AddExpectations("named_nested_map_complex.go", []string{
+		`type NamedNestedMapComplex map[string]NamedNestedMapComplexAdditionalProperties`,
+		`func (m NamedNestedMapComplex) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("named_nested_map_complex.go", []string{
+		`type NamedNestedMapComplex map[string]map[string]map[string]NamedNestedMapComplexAnon`,
+		`func (m NamedNestedMapComplex) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		for kk := range m[k] {`,
+		`			if swag.IsZero(m[k][kk]) {`,
+		`			for kkk := range m[k][kk] {`,
+		`				if swag.IsZero(m[k][kk][kkk]) {`,
+		`				if val, ok := m[k][kk][kkk]; ok {`,
+		`					if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type NamedNestedMapComplexAnon struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NamedNestedMapComplexAnon) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedNestedMapComplexAnon) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NamedNestedMapComplexAnon) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations_meta_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("nested_map_complex_validations_meta_additional_properties_additional_properties.go", []string{
+		`type NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalProperties map[string]NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties`,
+		`func (m NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalProperties(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_no_validations_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("nested_map_no_validations_additional_properties_additional_properties.go", []string{
+		`type NestedMapNoValidationsAdditionalPropertiesAdditionalProperties map[string]NestedMapNoValidationsAdditionalPropertiesAdditionalPropertiesAdditionalProperties`,
+		`func (m NestedMapNoValidationsAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", NestedMapNoValidationsAdditionalPropertiesAdditionalProperties(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: test_nested_interface.go
+	flattenRun.AddExpectations("test_nested_interface.go", []string{
+		`type TestNestedInterface struct {`,
+		"	Meta map[string]map[string]map[string]interface{} `json:\"meta,omitempty\"`",
+		// empty validation
+		"func (m *TestNestedInterface) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("test_nested_interface.go", flattenRun.ExpectedFor("TestNestedInterface").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: named_nested_map_complex_additional_properties_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("named_nested_map_complex_additional_properties_additional_properties_additional_properties.go", []string{
+		`type NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_no_validations_additional_properties.go
+	flattenRun.AddExpectations("nested_map_no_validations_additional_properties.go", []string{
+		`type NestedMapNoValidationsAdditionalProperties map[string]NestedMapNoValidationsAdditionalPropertiesAdditionalProperties`,
+		`func (m NestedMapNoValidationsAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("nested_map_no_validations.go", []string{
+		`type NestedMapNoValidations map[string]map[string]map[string]NestedMapNoValidationsAnon`,
+		`func (m NestedMapNoValidations) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		for kk := range m[k] {`,
+		`			if swag.IsZero(m[k][kk]) {`,
+		`			for kkk := range m[k][kk] {`,
+		`				if swag.IsZero(m[k][kk][kkk]) {`,
+		`				if val, ok := m[k][kk][kkk]; ok {`,
+		`					if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type NestedMapNoValidationsAnon struct {`,
+		"	Age int64 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		// empty validation
+		"func (m *NestedMapNoValidationsAnon) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations_meta_additional_properties.go
+	flattenRun.AddExpectations("nested_map_complex_validations_meta_additional_properties.go", []string{
+		`type NestedMapComplexValidationsMetaAdditionalProperties map[string]NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalProperties`,
+		`func (m NestedMapComplexValidationsMetaAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_no_validations_additional_properties_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("nested_map_no_validations_additional_properties_additional_properties_additional_properties.go", []string{
+		`type NestedMapNoValidationsAdditionalPropertiesAdditionalPropertiesAdditionalProperties struct {`,
+		"	Age int64 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		// empty validation
+		"func (m *NestedMapNoValidationsAdditionalPropertiesAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_no_validations.go
+	flattenRun.AddExpectations("nested_map_no_validations.go", []string{
+		`type NestedMapNoValidations map[string]NestedMapNoValidationsAdditionalProperties`,
+		`func (m NestedMapNoValidations) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations_meta_additional_properties_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("nested_map_complex_validations_meta_additional_properties_additional_properties_additional_properties.go", []string{
+		`type NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties struct {`,
+		"	Age int32 `json:\"age,omitempty\"`",
+		"	Name string `json:\"name,omitempty\"`",
+		`func (m *NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateAge(formats); err != nil {`,
+		`	if err := m.validateName(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties) validateAge(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Age) {`,
+		`	if err := validate.MinimumInt("age", "body", int64(m.Age), 1, true); err != nil {`,
+		`	if err := validate.MaximumInt("age", "body", int64(m.Age), 200, true); err != nil {`,
+		`	if err := validate.MultipleOf("age", "body", float64(m.Age), 1); err != nil {`,
+		`func (m *NestedMapComplexValidationsMetaAdditionalPropertiesAdditionalPropertiesAdditionalProperties) validateName(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Name) {`,
+		`	if err := validate.MinLength("name", "body", string(m.Name), 10); err != nil {`,
+		`	if err := validate.MaxLength("name", "body", string(m.Name), 50); err != nil {`,
+		"	if err := validate.Pattern(\"name\", \"body\", string(m.Name), `\\w+`); err != nil {",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations.go
+	flattenRun.AddExpectations("nested_map_complex_validations.go", []string{
+		`type NestedMapComplexValidations struct {`,
+		"	Meta NestedMapComplexValidationsMeta `json:\"meta,omitempty\"`",
+		`func (m *NestedMapComplexValidations) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateMeta(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *NestedMapComplexValidations) validateMeta(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Meta) {`,
+		`	if err := m.Meta.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("meta"`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_map_complex_additional_properties_additional_properties.go
+	flattenRun.AddExpectations("named_nested_map_complex_additional_properties_additional_properties.go", []string{
+		`type NamedNestedMapComplexAdditionalPropertiesAdditionalProperties map[string]NamedNestedMapComplexAdditionalPropertiesAdditionalPropertiesAdditionalProperties`,
+		`func (m NamedNestedMapComplexAdditionalPropertiesAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("", "body", NamedNestedMapComplexAdditionalPropertiesAdditionalProperties(m)); err != nil {`,
+		`	for k := range m {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: named_nested_map_complex_additional_properties.go
+	flattenRun.AddExpectations("named_nested_map_complex_additional_properties.go", []string{
+		`type NamedNestedMapComplexAdditionalProperties map[string]NamedNestedMapComplexAdditionalPropertiesAdditionalProperties`,
+		`func (m NamedNestedMapComplexAdditionalProperties) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: nested_map_complex_validations_meta.go
+	flattenRun.AddExpectations("nested_map_complex_validations_meta.go", []string{
+		`type NestedMapComplexValidationsMeta map[string]NestedMapComplexValidationsMetaAdditionalProperties`,
+		`func (m NestedMapComplexValidationsMeta) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if val, ok := m[k]; ok {`,
+		`			if err := val.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
+
+func initFixture844Variations() {
+	// testing fixture-844-variations.yaml with flatten and expand (--skip-flatten)
+
+	/*
+	   repro
+	*/
+
+	f := newModelFixture("../fixtures/bugs/1487/fixture-844-variations.yaml", "allOf bugs with empty objects")
+	flattenRun := f.AddRun(false)
+	expandRun := f.AddRun(true)
+
+	// load expectations for model: foo.go
+	flattenRun.AddExpectations("foo.go", []string{
+		`type Foo interface{`,
+	},
+		// not expected
+		validatable,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("foo.go", flattenRun.ExpectedFor("Foo").ExpectedLines, validatable, noLines, noLines)
+
+	// load expectations for model: variation2.go
+	flattenRun.AddExpectations("variation2.go", []string{
+		`type Variation2 struct {`,
+		"	Prop1 EmptyEnum `json:\"prop1,omitempty\"`",
+		// empty validation
+		"func (m *Variation2) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("variation2.go", []string{
+		`type Variation2 struct {`,
+		"	Prop1 interface{} `json:\"prop1,omitempty\"`",
+		// empty validation
+		"func (m *Variation2) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: bar.go
+	flattenRun.AddExpectations("bar.go", []string{
+		`type Bar interface{`,
+	},
+		// not expected
+		validatable,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("bar.go", flattenRun.ExpectedFor("Bar").ExpectedLines, validatable, noLines, noLines)
+
+	// load expectations for model: variation3.go
+	flattenRun.AddExpectations("variation3.go", []string{
+		`type Variation3 struct {`,
+		"	Prop1 []EmptyEnum `json:\"prop1\"`",
+		`func (m *Variation3) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *Variation3) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	iProp1Size := int64(len(m.Prop1)`,
+		`	if err := validate.MinItems("prop1", "body", iProp1Size, 10); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("variation3.go", []string{
+		`type Variation3 struct {`,
+		"	Prop1 []interface{} `json:\"prop1\"`",
+		`func (m *Variation3) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateProp1(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`var variation3Prop1ItemsEnum []interface{`,
+		`	var res []interface{`,
+		"	if err := json.Unmarshal([]byte(`[\"abc\",\"def\"]`), &res); err != nil {",
+		`	for _, v := range res {`,
+		`		variation3Prop1ItemsEnum = append(variation3Prop1ItemsEnum, v`,
+		`func (m *Variation3) validateProp1ItemsEnum(path, location string, value interface{}) error {`,
+		`	if err := validate.Enum(path, location, value, variation3Prop1ItemsEnum); err != nil {`,
+		`func (m *Variation3) validateProp1(formats strfmt.Registry) error {`,
+		`	if swag.IsZero(m.Prop1) {`,
+		`	iProp1Size := int64(len(m.Prop1)`,
+		`	if err := validate.MinItems("prop1", "body", iProp1Size, 10); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: tuple_variation.go
+	flattenRun.AddExpectations("tuple_variation.go", []string{
+		`type TupleVariation struct {`,
+		"	P0 *int64 `json:\"-\"`",
+		"	P1 Bar `json:\"-\"`",
+		"	P2 NonInterface `json:\"-\"`",
+		"	P3 []Bar `json:\"-\"`",
+		"	TupleVariationItems []interface{} `json:\"-\"`",
+		`func (m *TupleVariation) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateP3(formats); err != nil {`,
+		`	if err := m.validateTupleVariationItems(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *TupleVariation) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if err := validate.MaximumInt("0", "body", int64(*m.P0), 10, false); err != nil {`,
+		`func (m *TupleVariation) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`func (m *TupleVariation) validateP2(formats strfmt.Registry) error {`,
+		`	if err := m.P2.Validate(formats); err != nil {`,
+		`		if ve, ok := err.(*errors.Validation); ok {`,
+		`			return ve.ValidateName("2"`,
+		`func (m *TupleVariation) validateP3(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("3", "body", m.P3); err != nil {`,
+		`	iP3Size := int64(len(m.P3)`,
+		`	if err := validate.MaxItems("3", "body", iP3Size, 10); err != nil {`,
+		// empty validation
+		"func (m *TupleVariation) validateTupleVariationItems(formats strfmt.Registry) error {\n\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("tuple_variation.go", []string{
+		`type TupleVariation struct {`,
+		"	P0 *int64 `json:\"-\"`",
+		"	P1 interface{} `json:\"-\"`",
+		"	P2 map[string]strfmt.Date `json:\"-\"`",
+		"	P3 []interface{} `json:\"-\"`",
+		"	TupleVariationItems []interface{} `json:\"-\"`",
+		`func (m *TupleVariation) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateP2(formats); err != nil {`,
+		`	if err := m.validateP3(formats); err != nil {`,
+		`	if err := m.validateTupleVariationItems(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *TupleVariation) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if err := validate.MaximumInt("0", "body", int64(*m.P0), 10, false); err != nil {`,
+		`func (m *TupleVariation) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`func (m *TupleVariation) validateP2(formats strfmt.Registry) error {`,
+		`	for k := range m.P2 {`,
+		`		if swag.IsZero(m.P2[k]) {`,
+		`		if err := validate.FormatOf("2"+"."+k, "body", "date", m.P2[k].String(), formats); err != nil {`,
+		`func (m *TupleVariation) validateP3(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("3", "body", m.P3); err != nil {`,
+		`	iP3Size := int64(len(m.P3)`,
+		`	if err := validate.MaxItems("3", "body", iP3Size, 10); err != nil {`,
+		// empty validation
+		"func (m *TupleVariation) validateTupleVariationItems(formats strfmt.Registry) error {\n\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: add_items_variation.go
+	flattenRun.AddExpectations("add_items_variation.go", []string{
+		`type AddItemsVariation struct {`,
+		"	P0 *int64 `json:\"-\"`",
+		"	P1 Bar `json:\"-\"`",
+		"	AddItemsVariationItems [][]Foo `json:\"-\"`",
+		`func (m *AddItemsVariation) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateAddItemsVariationItems(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AddItemsVariation) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if err := validate.MaximumInt("0", "body", int64(*m.P0), 10, false); err != nil {`,
+		`func (m *AddItemsVariation) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`func (m *AddItemsVariation) validateAddItemsVariationItems(formats strfmt.Registry) error {`,
+		`	for i := range m.AddItemsVariationItems {`,
+		`		if err := validate.UniqueItems(strconv.Itoa(i+2), "body", m.AddItemsVariationItems[i]); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("add_items_variation.go", []string{
+		`type AddItemsVariation struct {`,
+		"	P0 *int64 `json:\"-\"`",
+		"	P1 interface{} `json:\"-\"`",
+		"	AddItemsVariationItems [][]interface{} `json:\"-\"`",
+		`func (m *AddItemsVariation) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.validateP0(formats); err != nil {`,
+		`	if err := m.validateP1(formats); err != nil {`,
+		`	if err := m.validateAddItemsVariationItems(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`func (m *AddItemsVariation) validateP0(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("0", "body", m.P0); err != nil {`,
+		`	if err := validate.MaximumInt("0", "body", int64(*m.P0), 10, false); err != nil {`,
+		`func (m *AddItemsVariation) validateP1(formats strfmt.Registry) error {`,
+		`	if err := validate.Required("1", "body", m.P1); err != nil {`,
+		`func (m *AddItemsVariation) validateAddItemsVariationItems(formats strfmt.Registry) error {`,
+		`	for i := range m.AddItemsVariationItems {`,
+		`		if err := validate.UniqueItems(strconv.Itoa(i+2), "body", m.AddItemsVariationItems[i]); err != nil {`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: non_interface.go
+	flattenRun.AddExpectations("non_interface.go", []string{
+		`type NonInterface map[string]strfmt.Date`,
+		`func (m NonInterface) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m {`,
+		`		if swag.IsZero(m[k]) {`,
+		`		if err := validate.FormatOf(k, "body", "date", m[k].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("non_interface.go", flattenRun.ExpectedFor("NonInterface").ExpectedLines, todo, noLines, noLines)
+
+	// load expectations for model: variation0.go
+	flattenRun.AddExpectations("variation0.go", []string{
+		`type Variation0 struct {`,
+		`	Foo`,
+		`	Bar`,
+		// empty validation
+		"func (m *Variation0) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("variation0.go", []string{
+		`type Variation0 struct {`,
+		`	Variation0AllOf0`,
+		`	Variation0AllOf1`,
+		`type Variation0AllOf0 interface{}`,
+		`type Variation0AllOf1 interface{}`,
+		// empty validation
+		"func (m *Variation0) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: variation1.go
+	flattenRun.AddExpectations("variation1.go", []string{
+		`type Variation1 struct {`,
+		`	Foo`,
+		`	NonInterface`,
+		`func (m *Variation1) Validate(formats strfmt.Registry) error {`,
+		`	if err := m.NonInterface.Validate(formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("variation1.go", []string{
+		`type Variation1 struct {`,
+		`	Variation1AllOf0`,
+		"	AO1 map[string]strfmt.Date `json:\"-\"`",
+		`func (m *Variation1) Validate(formats strfmt.Registry) error {`,
+		`	for k := range m.AO1 {`,
+		`		if swag.IsZero(m.AO1[k]) {`,
+		`		if err := validate.FormatOf(k, "body", "date", m.AO1[k].String(), formats); err != nil {`,
+		`		return errors.CompositeValidationError(res...`,
+		`type Variation1AllOf0 interface{}`,
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+	// load expectations for model: empty_enum.go
+	flattenRun.AddExpectations("empty_enum.go", []string{
+		`type EmptyEnum interface{}`,
+	},
+		// not expected
+		validatable,
+		// output in log
+		noLines,
+		noLines)
+
+	expandRun.AddExpectations("empty_enum.go", flattenRun.ExpectedFor("EmptyEnum").ExpectedLines, validatable, noLines, noLines)
+
+	// load expectations for model: get_o_k_body.go
+	flattenRun.AddExpectations("get_o_k_body.go", []string{
+		`type GetOKBody struct {`,
+		`	Foo`,
+		`	Bar`,
+		// empty validation
+		"func (m *GetOKBody) Validate(formats strfmt.Registry) error {\n	return nil\n}",
+	},
+		// not expected
+		todo,
+		// output in log
+		noLines,
+		noLines)
+
+}
diff --git a/generator/moreschemavalidation_test.go b/generator/moreschemavalidation_test.go
new file mode 100644
index 00000000..627fef45
--- /dev/null
+++ b/generator/moreschemavalidation_test.go
@@ -0,0 +1,406 @@
+// Copyright 2015 go-swagger maintainers
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//    http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package generator
+
+import (
+	"bytes"
+	"io/ioutil"
+	"log"
+	"os"
+	"strings"
+	"testing"
+
+	"github.com/go-openapi/loads"
+	"github.com/go-openapi/spec"
+	"github.com/go-openapi/swag"
+	"github.com/stretchr/testify/assert"
+)
+
+// modelExpectations is a test structure to capture expected codegen lines of code
+type modelExpectations struct {
+	GeneratedFile    string
+	ExpectedLines    []string
+	NotExpectedLines []string
+	ExpectedLogs     []string
+	NotExpectedLogs  []string
+	ExpectFailure    bool
+}
+
+// modelTestRun is a test structure to configure generations options to test a spec
+type modelTestRun struct {
+	FixtureOpts *GenOpts
+	Definitions map[string]*modelExpectations
+}
+
+// AddExpectations adds expected / not expected sets of lines of code to the current run
+func (r *modelTestRun) AddExpectations(file string, expectedCode, notExpectedCode, expectedLogs, notExpectedLogs []string) {
+	k := strings.ToLower(swag.ToJSONName(strings.TrimSuffix(file, ".go")))
+	if def, ok := r.Definitions[k]; ok {
+		def.ExpectedLines = append(def.ExpectedLines, expectedCode...)
+		def.NotExpectedLines = append(def.NotExpectedLines, notExpectedCode...)
+		def.ExpectedLogs = append(def.ExpectedLogs, expectedLogs...)
+		def.NotExpectedLogs = append(def.NotExpectedLogs, notExpectedLogs...)
+		return
+	}
+	r.Definitions[k] = &modelExpectations{
+		GeneratedFile:    file,
+		ExpectedLines:    expectedCode,
+		NotExpectedLines: notExpectedCode,
+		ExpectedLogs:     expectedLogs,
+		NotExpectedLogs:  notExpectedLogs,
+	}
+}
+
+// ExpectedFor returns the map of model expectations from the run for a given model definition
+func (r *modelTestRun) ExpectedFor(definition string) *modelExpectations {
+	if def, ok := r.Definitions[strings.ToLower(definition)]; ok {
+		return def
+	}
+	return nil
+}
+
+// modelFixture is a test structure to launch configurable test runs on a given spec
+type modelFixture struct {
+	SpecFile    string
+	Description string
+	Runs        []*modelTestRun
+}
+
+// Add adds a new run to the provided model fixture
+func (f *modelFixture) AddRun(skipFlattenSpec bool) *modelTestRun {
+	opts := &GenOpts{}
+	opts.IncludeValidator = true
+	opts.IncludeModel = true
+	// sets gen options (e.g. flatten vs expand) - flatten is the default setting
+	opts.ValidateSpec = false
+	opts.FlattenSpec = !skipFlattenSpec
+	opts.Spec = f.SpecFile
+	if err := opts.EnsureDefaults(); err != nil {
+		panic(err)
+	}
+	defs := make(map[string]*modelExpectations, 150)
+	run := &modelTestRun{
+		FixtureOpts: opts,
+		Definitions: defs,
+	}
+	f.Runs = append(f.Runs, run)
+	return run
+}
+
+// ExpectedBy returns the expectations from another run of the current fixture, recalled by its index in the list of planned runs
+func (f *modelFixture) ExpectedFor(index int, definition string) *modelExpectations {
+	if index > len(f.Runs)-1 {
+		return nil
+	}
+	if def, ok := f.Runs[index].Definitions[strings.ToLower(definition)]; ok {
+		return def
+	}
+	return nil
+}
+
+// newModelFixture is a test utility to build a new test plan for a spec file.
+// The returned structure may be then used to add runs and expectations to each run.
+func newModelFixture(specFile string, description string) *modelFixture {
+	// lookup if already here
+	for _, fix := range testedModels {
+		if fix.SpecFile == specFile {
+			return fix
+		}
+	}
+	runs := make([]*modelTestRun, 0, 2)
+	fix := &modelFixture{
+		SpecFile:    specFile,
+		Description: description,
+		Runs:        runs,
+	}
+	testedModels = append(testedModels, fix)
+	return fix
+}
+
+// all tested specs: init at the end of this source file
+// you may append to those with different initXXX() funcs below.
+var (
+	testedModels []*modelFixture
+
+	// convenient vars for (not) matching some lines
+	noLines     []string
+	todo        []string
+	validatable []string
+	warning     []string
+)
+
+func init() {
+	testedModels = make([]*modelFixture, 0, 20)
+	noLines = []string{}
+	todo = []string{`TODO`}
+	validatable = append(todo, `Validate(`)
+	warning = []string{`warning`}
+}
+
+// initModelFixtures loads all tests to be performed
+func initModelFixtures() {
+	initFixtureSimpleAllOf()
+	initFixtureComplexAllOf()
+	initFixtureIsNullable()
+	initFixtureItching()
+	initFixtureAdditionalProps()
+	initFixtureTuple()
+	initFixture1479Part()
+	initFixture1198()
+	initFixture1042()
+	initFixture1042V2()
+	initFixture979()
+	initFixture842()
+	initFixture607()
+	initFixture1336()
+	initFixtureErrors()
+	initFixture844Variations()
+	// a more stringent verification of this known fixture
+	initTodolistSchemavalidation()
+}
+
+/* Template initTxxx() to prepare and load a fixture:
+
+func initTxxx() {
+	// testing xxx.yaml with expand (--skip-flatten)
+	f := newModelFixture("xxx.yaml", "A test blg")
+
+	// makes a run with skipFlattenSpec=false
+	thisRun := f.AddRun(false)
+
+	// loads expectations for model abc
+	thisRun.AddExpectations("abc.go", []string{
+		`line {`,
+		`	more codegen  		`,
+		`}`,
+	},
+		// not expected
+		noLines,
+		// output in Log
+		noLines,
+		noLines)
+
+	// loads expectations for model abcDef
+	thisRun.AddExpectations("abc_def.go", []string{}, []string{}, noLines, noLines)
+}
+
+*/
+
+func TestModelGenerateDefinition(t *testing.T) {
+	// exercise the top level model generation func
+	log.SetOutput(ioutil.Discard)
+	defer func() {
+		log.SetOutput(os.Stdout)
+	}()
+	fixtureSpec := "../fixtures/bugs/1487/fixture-is-nullable.yaml"
+	assert := assert.New(t)
+	gendir, erd := ioutil.TempDir(".", "model-test")
+	defer func() {
+		os.RemoveAll(gendir)
+	}()
+	if assert.NoError(erd) {
+		opts := &GenOpts{}
+		opts.IncludeValidator = true
+		opts.IncludeModel = true
+		// sets gen options (e.g. flatten vs expand) - flatten is the default setting
+		opts.ValidateSpec = false
+		opts.FlattenSpec = true
+		opts.Spec = fixtureSpec
+		opts.ModelPackage = "models"
+		opts.Target = gendir
+		if err := opts.EnsureDefaults(); err != nil {
+			panic(err)
+		}
+
+		var err error
+		err = GenerateDefinition([]string{"thingWithNullableDates"}, opts)
+		assert.NoErrorf(err, "Expected GenerateDefinition() to run without error")
+
+		err = GenerateDefinition(nil, opts)
+		assert.NoErrorf(err, "Expected GenerateDefinition() to run without error")
+
+		opts.TemplateDir = gendir
+		err = GenerateDefinition([]string{"thingWithNullableDates"}, opts)
+		assert.NoErrorf(err, "Expected GenerateDefinition() to run without error")
+
+		err = GenerateDefinition([]string{"thingWithNullableDates"}, nil)
+		assert.Errorf(err, "Expected GenerateDefinition() return an error when no option is passed")
+
+		opts.TemplateDir = "templates"
+		err = GenerateDefinition([]string{"thingWithNullableDates"}, opts)
+		assert.Errorf(err, "Expected GenerateDefinition() to croak about protected templates")
+
+		opts.TemplateDir = ""
+		err = GenerateDefinition([]string{"myAbsentDefinition"}, opts)
+		assert.Errorf(err, "Expected GenerateDefinition() to return an error when the model is not in spec")
+
+		opts.Spec = "pathToNowhere"
+		err = GenerateDefinition([]string{"thingWithNullableDates"}, opts)
+		assert.Errorf(err, "Expected GenerateDefinition() to return an error when the spec is not reachable")
+	}
+}
+
+func TestMoreModelValidations(t *testing.T) {
+	log.SetOutput(ioutil.Discard)
+	defer func() {
+		log.SetOutput(os.Stdout)
+	}()
+	continueOnErrors := false
+	initModelFixtures()
+
+	assert := assert.New(t)
+
+	for _, fixture := range testedModels {
+		if fixture.SpecFile == "" {
+			continue
+		}
+		fixtureSpec := fixture.SpecFile
+		specDoc, err := loads.Spec(fixtureSpec)
+		if !assert.NoErrorf(err, "unexpected failure loading spec %s: %v", fixtureSpec, err) {
+			t.FailNow()
+			return
+		}
+		for _, fixtureRun := range fixture.Runs {
+			// NOTE: could run in parallel, if no package level common structures, such as a cache etc..
+			opts := fixtureRun.FixtureOpts
+			t.Logf("codegen for  %s (%s) - run with FlattenSpec=%t", fixtureSpec, fixture.Description, opts.FlattenSpec)
+
+			// this is the expanded or flattened spec
+			newSpecDoc, er0 := validateAndFlattenSpec(opts, specDoc)
+			if !assert.NoErrorf(er0, "could not expand/flatten fixture %s: %v", fixtureSpec, er0) {
+				t.FailNow()
+				return
+			}
+			definitions := newSpecDoc.Spec().Definitions
+			for k, fixtureExpectations := range fixtureRun.Definitions {
+				// pick definition to test
+				var schema *spec.Schema
+				var definitionName string
+				for def, s := range definitions {
+					// please do not inject in fixtures with case conflicts on defs...
+					// this one is just easier to retrieve model back from file names when capturing
+					// the generated code.
+					if strings.EqualFold(def, k) {
+						schema = &s
+						definitionName = def
+						break
+					}
+				}
+				if !assert.NotNil(schema, "expected to find definition %q in model fixture %s", k, fixtureSpec) {
+					t.FailNow()
+					return
+				}
+
+				// prepare assertions on log output (e.g. generation warnings)
+				var logCapture bytes.Buffer
+				if len(fixtureExpectations.ExpectedLogs) > 0 || len(fixtureExpectations.NotExpectedLogs) > 0 {
+					log.SetOutput(&logCapture)
+				} else {
+					log.SetOutput(ioutil.Discard)
+				}
+
+				// generate the schema for this definition
+				genModel, er1 := makeGenDefinition(definitionName, "models", *schema, newSpecDoc, opts)
+
+				if fixtureExpectations.ExpectFailure && !assert.Errorf(er1, "Expected an error during generation of definition %q from spec fixture %s", k, fixtureSpec) {
+					// expected an error here, and it has not happened
+					if continueOnErrors {
+						t.Fail()
+						continue
+					} else {
+						t.FailNow()
+						return
+					}
+				}
+				if !assert.NoErrorf(er1, "could not generate model definition %q from spec fixture %s: %v", k, fixtureSpec, er1) {
+					// expected smooth generation
+					if continueOnErrors {
+						t.Fail()
+						continue
+					} else {
+						t.FailNow()
+						return
+					}
+				}
+				if len(fixtureExpectations.ExpectedLogs) > 0 || len(fixtureExpectations.NotExpectedLogs) > 0 {
+					// assert logged output
+					res := logCapture.String()
+					for line, logLine := range fixtureExpectations.ExpectedLogs {
+						if !assertInCode(t, strings.TrimSpace(logLine), res) {
+							t.Logf("Log expected did not match for definition %q in fixture %s at (fixture) log line %d", k, fixtureSpec, line)
+						}
+					}
+					for line, logLine := range fixtureExpectations.NotExpectedLogs {
+						if !assertNotInCode(t, strings.TrimSpace(logLine), res) {
+							t.Logf("Log unexpectedly matched for definition %q in fixture %s at (fixture) log line %d", k, fixtureSpec, line)
+						}
+					}
+					if t.Failed() && !continueOnErrors {
+						t.FailNow()
+						return
+					}
+					log.SetOutput(ioutil.Discard)
+				}
+
+				// execute the model template with this schema
+				buf := bytes.NewBuffer(nil)
+				er2 := templates.MustGet("model").Execute(buf, genModel)
+				if !assert.NoErrorf(er2, "could not render model template for definition %q in spec fixture %s: %v", k, fixtureSpec, er2) {
+					if continueOnErrors {
+						t.Fail()
+						continue
+					} else {
+						t.FailNow()
+						return
+					}
+				}
+				outputName := fixtureExpectations.GeneratedFile
+				if outputName == "" {
+					outputName = swag.ToFileName(k) + ".go"
+				}
+
+				// run goimport, gofmt on the generated code
+				formatted, er3 := opts.LanguageOpts.FormatContent(outputName, buf.Bytes())
+				if !assert.NoErrorf(er3, "could not render model template for definition %q in spec fixture %s: %v", k, fixtureSpec, er2) {
+					t.Fail()
+					if continueOnErrors {
+						t.Fail()
+						continue
+					} else {
+						t.FailNow()
+						return
+					}
+				}
+
+				// asserts generated code (see fixture file)
+				res := string(formatted)
+				for line, codeLine := range fixtureExpectations.ExpectedLines {
+					if !assertInCode(t, strings.TrimSpace(codeLine), res) {
+						t.Logf("Code expected did not match for definition %q in fixture %s at (fixture) line %d", k, fixtureSpec, line)
+					}
+				}
+				for line, codeLine := range fixtureExpectations.NotExpectedLines {
+					if !assertNotInCode(t, strings.TrimSpace(codeLine), res) {
+						t.Logf("code unexpectedly matched for definition %q in fixture %s at (fixture) line %d", k, fixtureSpec, line)
+					}
+				}
+				if t.Failed() && !continueOnErrors {
+					t.FailNow()
+					return
+				}
+			}
+		}
+	}
+}
diff --git a/generator/parameter_test.go b/generator/parameter_test.go
index b4067604..5743dd79 100644
--- a/generator/parameter_test.go
+++ b/generator/parameter_test.go
@@ -1449,7 +1449,7 @@ func TestGenParameter_Issue909(t *testing.T) {
 						if assert.NoError(err, "Expected formatting to go well on %s with template %s", fixtureSpec, fixtureTemplate) {
 							res := string(ff)
 							for line, codeLine := range expectedCode {
-								if !assertInCode(t, codeLine, res) {
+								if !assertInCode(t, strings.TrimSpace(codeLine), res) {
 									t.Logf("Code expected did not match for fixture %s at line %d", fixtureSpec, line)
 								}
 							}
@@ -1500,7 +1500,7 @@ func TestGenParameter_Issue1237(t *testing.T) {
 						if assert.NoError(err, "Expected formatting to go well on %s with template %s", fixtureSpec, fixtureTemplate) {
 							res := string(ff)
 							for line, codeLine := range expectedCode {
-								if !assertInCode(t, codeLine, res) {
+								if !assertInCode(t, strings.TrimSpace(codeLine), res) {
 									t.Logf("Code expected did not match for fixture %s at line %d", fixtureSpec, line)
 								}
 							}
@@ -1692,7 +1692,7 @@ func TestGenParameter_Issue1392(t *testing.T) {
 						if assert.NoError(err, "Expected formatting to go well on %s with template %s", fixtureSpec, fixtureTemplate) {
 							res := string(ff)
 							for line, codeLine := range expectedCode {
-								if !assertInCode(t, codeLine, res) {
+								if !assertInCode(t, strings.TrimSpace(codeLine), res) {
 									t.Logf("Code expected did not match for fixture %s at line %d", fixtureSpec, line)
 								}
 							}
diff --git a/generator/structs.go b/generator/structs.go
index c89201f7..e7d4af9d 100644
--- a/generator/structs.go
+++ b/generator/structs.go
@@ -97,25 +97,37 @@ type GenSchema struct {
 }
 
 type sharedValidations struct {
-	Required            bool
-	MaxLength           *int64
-	MinLength           *int64
-	Pattern             string
-	MultipleOf          *float64
-	Minimum             *float64
-	Maximum             *float64
-	ExclusiveMinimum    bool
-	ExclusiveMaximum    bool
-	Enum                []interface{}
-	ItemsEnum           []interface{}
-	HasValidations      bool
+	HasValidations bool
+	Required       bool
+
+	// String validations
+	MaxLength *int64
+	MinLength *int64
+	Pattern   string
+
+	// Number validations
+	MultipleOf       *float64
+	Minimum          *float64
+	Maximum          *float64
+	ExclusiveMinimum bool
+	ExclusiveMaximum bool
+
+	Enum      []interface{}
+	ItemsEnum []interface{}
+
+	// Slice validations
 	MinItems            *int64
 	MaxItems            *int64
 	UniqueItems         bool
 	HasSliceValidations bool
-	NeedsSize           bool
-	NeedsValidation     bool
-	NeedsRequired       bool
+
+	// Not used yet (intended for maxProperties, minProperties validations)
+	NeedsSize bool
+	// Not used: deprecated
+	//NeedsValidation bool
+	//NeedsRequired bool
+
+	// NOTE: "patternProperties" and "dependencies" not supported by Swagger 2.0
 }
 
 // GenResponse represents a response object for code generation
diff --git a/generator/templates/docstring.gotmpl b/generator/templates/docstring.gotmpl
index 853aa493..14714247 100644
--- a/generator/templates/docstring.gotmpl
+++ b/generator/templates/docstring.gotmpl
@@ -1,9 +1,12 @@
 {{define "docstring"}}
-  {{- if .Title }}{{ comment .Title }}{{- if .Description }}
+  {{- if .Title }} 
+    {{- comment .Title }} 
+    {{- if .Description }}
 //
 // {{ comment .Description }}
-{{- end }}
-{{- else if .Description}}{{ comment .Description }}
-{{- else }}{{ humanize .Name }}
-{{- end }}
+    {{- end }}
+  {{- else if .Description}} 
+    {{- comment .Description }}
+  {{- else }}{{ humanize .Name }}
+  {{- end }}
 {{- end }}
diff --git a/generator/templates/schema.gotmpl b/generator/templates/schema.gotmpl
index 6a620cef..e0220570 100644
--- a/generator/templates/schema.gotmpl
+++ b/generator/templates/schema.gotmpl
@@ -1,6 +1,14 @@
 {{ if .IncludeModel -}}
   {{ if and .IsBaseType .IsExported -}}type {{ pascalize .Name }} interface {
-    {{if or .Required .HasValidations }}runtime.Validatable{{ end }}
+    {{- if not (or .IsInterface .IsStream) }}{{/* 
+        A base type is always Validatable. 
+        Under normal conditions, we can't have a base type rendered a .IsStream or .IsInterface: this check is just for sanity check). 
+
+        In the definition of the base type itself, this means that the unexported struct holding
+        the definition of the base type has a Validate() func.
+    */}}
+        runtime.Validatable 
+    {{- end }}
     {{ range .AllOf }}
       {{ if .IsAnonymous }}
         {{ range .Properties }}
@@ -42,17 +50,15 @@
   type {{ camelize .Name }} {{ template "schemaBody" . }}
 
   {{ range .Properties }}
+    // {{ pascalize .Name}} gets the {{ humanize .Name }} of this polymorphic type
     func ({{ $.ReceiverName}} *{{ camelize $.Name}}) {{ pascalize .Name}}() {{ template "schemaType" . }}{
       {{ if eq $.DiscriminatorField .Name }}return {{ printf "%q" $.DiscriminatorValue }}{{ else }}return {{ $.ReceiverName }}.{{camelize .Name}}Field{{end}}
     }
+    // Set{{ pascalize .Name}} sets the {{ humanize .Name }} of this polymorphic type
     func ({{ $.ReceiverName}} *{{ camelize $.Name}}) Set{{ pascalize .Name}}(val {{ template "schemaType" . }}) {
       {{ if ne $.DiscriminatorField .Name }}{{ $.ReceiverName }}.{{camelize .Name}}Field = val{{end}}
     }
   {{ end }}
-  {{if and (not .IsInterface) (or .Required .HasValidations) }}
-    {{ template "schemavalidator" . }}
-  {{ end }}
-
 // Unmarshal{{ pascalize .Name }}Slice unmarshals polymorphic slices of {{ pascalize .Name }}
 func Unmarshal{{ pascalize .Name }}Slice(reader io.Reader, consumer runtime.Consumer) ([]{{ pascalize .Name }}, error) {
   var elements []json.RawMessage
@@ -114,9 +120,11 @@ func unmarshal{{ pascalize .Name }}(data []byte, consumer runtime.Consumer) ({{
     {{ if .Name }}type {{ if not .IsExported }}{{ .Name }}{{ else }}{{ pascalize .Name }}{{ end }}{{ end }} {{ template "schemaBody" . }}
     {{ range .Properties }}
       {{ if .IsBaseType }}
+        // {{ pascalize .Name}} gets the {{ humanize .Name }} of this base type
         func ({{ $.ReceiverName}} *{{ pascalize $.Name}}) {{ pascalize .Name}}() {{ template "schemaType" . }}{
           {{ if eq $.DiscriminatorField .Name }}return {{ printf "%q" $.DiscriminatorValue }}{{ else }}return {{ $.ReceiverName }}.{{camelize .Name}}Field{{end}}
         }
+        // Set{{ pascalize .Name}} sets the {{ humanize .Name }} of this base type
         func ({{ $.ReceiverName}} *{{ pascalize $.Name}}) Set{{ pascalize .Name}}(val {{ template "schemaType" . }}) {
           {{ if ne $.DiscriminatorField .Name }}{{ $.ReceiverName }}.{{camelize .Name}}Field = val{{end}}
         }
@@ -153,9 +161,11 @@ func unmarshal{{ pascalize .Name }}(data []byte, consumer runtime.Consumer) ({{
   {{ if .IsSubType }}
     {{ range .AllOf }}
       {{ range .Properties }}
+        // {{ pascalize .Name}} gets the {{ humanize .Name }} of this subtype
         {{ if .IsBaseType }}func ({{$.ReceiverName}} *{{ pascalize $.Name}}) {{ pascalize .Name}}() {{ template "schemaType" . }}{
           {{ if eq $.DiscriminatorField .Name }}return {{ printf "%q" $.DiscriminatorValue }}{{ else }}return {{ $.ReceiverName }}.{{camelize .Name}}Field{{end}}
         }
+        // Set{{ pascalize .Name}} sets the {{ humanize .Name }} of this subtype
         func ({{$.ReceiverName}} *{{ pascalize $.Name}}) Set{{ pascalize .Name}}(val {{ template "schemaType" . }}) {
           {{ if ne $.DiscriminatorField .Name }}{{ $.ReceiverName }}.{{camelize .Name}}Field = val{{end}}
         }
@@ -171,16 +181,16 @@ func unmarshal{{ pascalize .Name }}(data []byte, consumer runtime.Consumer) ({{
   {{- template "propertyValidationDocString" .AdditionalItems}} {{ pascalize .AdditionalItems.Name }}() []{{ template "schemaType" .AdditionalItems }}
 {{ end }}{{ end -}} 
   {{ template "schemaSerializer" . }}{{ end }} 
-{{- if .IncludeValidator -}} 
-  {{- if and (not .IsInterface) (not .IsBaseType) (or .Required .HasValidations .HasBaseType) -}}
-    {{ template "schemavalidator" . }}
-  {{- else if gt (len .AllOf) 0 -}}
+{{- if .IncludeValidator -}}
+  {{- if and (not (or .IsInterface .IsStream)) (or .Required .HasValidations .HasBaseType) }}
     {{ template "schemavalidator" . }}
-  {{- else if not (or .IsInterface .IsStream .IsBaseType) -}}
-// Validate validates this {{ humanize .Name }}
-func ({{.ReceiverName}} {{ if or .IsTuple .IsComplexObject .IsAdditionalProperties }}*{{ end }}{{ if not .IsExported }}{{ .Name }}{{ else }}{{ pascalize .Name }}{{ end }}) Validate(formats strfmt.Registry) error {
+  {{- else if not (or .IsInterface .IsStream) -}}
+// Validate validates this {{ humanize .Name }}{{/* this schema implements the runtime.Validatable interface but has no validations to check */}}
+func ({{.ReceiverName}} {{ if or .IsTuple .IsComplexObject .IsAdditionalProperties }}*{{ end }}{{ if or (not .IsExported) .Discriminates }}{{ camelize .Name }}{{ else }}{{ pascalize .Name }}{{ end }}) Validate(formats strfmt.Registry) error {
   return nil
 }
+  {{- else -}}
+    {{- /* {{ .Name }} does not implement the runtime.Validatable interface */ -}}
   {{- end -}}
 {{- end }}
 {{- end }}
diff --git a/generator/templates/schemabody.gotmpl b/generator/templates/schemabody.gotmpl
index 08a2b210..3e712057 100644
--- a/generator/templates/schemabody.gotmpl
+++ b/generator/templates/schemabody.gotmpl
@@ -23,33 +23,35 @@
           // {{ template "docstring" .AdditionalProperties }}
           {{- template "propertyValidationDocString" .AdditionalProperties}}
           {{ if and .IsExported (not .IsSubType) -}}{{ pascalize .AdditionalProperties.Name }}{{- else -}}{{ .AdditionalProperties.Name }}{{- end }} map[string]{{ template "schemaType" .AdditionalProperties }} `json:"-"`
-        {{end}}
+        {{ end }}
       {{ end}}
       {{ if .AdditionalItems -}}
         // {{ template "docstring" .AdditionalItems }}
         {{- template "propertyValidationDocString" .AdditionalItems}}
         {{ if and .IsExported (not $.IsSubType) }}{{ pascalize .AdditionalItems.Name }}{{ else }}{{ .AdditionalItems.Name }}{{ end }} []{{ template "schemaType" .AdditionalItems }} `json:"-"`
       {{ end }}
-      {{ else }}
-        {{ if not (and $.IsBaseType .IsExported) }}{{ .GoType }}{{ end }}
-      {{ end }}
+    {{ else }}{{/* named type composition */}}
+      {{ if not (and $.IsBaseType .IsExported) }}{{ .GoType }}{{ end }}
     {{ end }}
+  {{ end }}
   {{range .Properties}}
     {{ if or (not $.IsExported) ($.IsBaseType) (.IsBaseType) }}
       {{ if $.IsTuple }}{{ template "privtuplefield" . }}{{ else }}{{template "privstructfield" . }}{{ end }}{{ else }}{{ if $.IsTuple }}{{ template "tuplefield" . }}{{ else }}{{template "structfield" . }}{{ end }}{{ end}}
-    {{end}}
+  {{ end }}
   {{ if .HasAdditionalProperties }}
     {{- if .AdditionalProperties -}}
     // {{ template "docstring" .AdditionalProperties }}
     {{- template "propertyValidationDocString" .AdditionalProperties}}
       {{ if and .IsExported (not .IsSubType) }}{{ pascalize .AdditionalProperties.Name }}{{ else }}{{ pascalize .AdditionalProperties.Name }}Field{{ end }} map[string]{{ template "schemaType" .AdditionalProperties }} `json:"-"`
-  {{ end }}{{ end }}
+    {{ end }}
+  {{- end }}
   {{ if .AdditionalItems -}}
     // {{ template "docstring" .AdditionalItems }}
     {{- template "propertyValidationDocString" .AdditionalItems}}
-  {{ if and .IsExported (not .IsSubType) }}{{ pascalize .AdditionalItems.Name }}{{ else }}{{ pascalize .AdditionalItems.Name }}Field{{ end }} []{{ template "schemaType" .AdditionalItems }} `json:"-"`
+    {{ if and .IsExported (not .IsSubType) }}{{ pascalize .AdditionalItems.Name }}{{ else }}{{ pascalize .AdditionalItems.Name }}Field{{ end }} []{{ template "schemaType" .AdditionalItems }} `json:"-"`
   {{ end }}
-}{{end}}
+} 
+{{- end }}
 {{ define "subTypeBody" }}struct {
   {{ range .AllOf }}
   {{ if or (and .IsBaseType .IsExported) .IsAnonymous }}{{ range .Properties }}
diff --git a/generator/templates/schemavalidator.gotmpl b/generator/templates/schemavalidator.gotmpl
index fde4c682..7ede836a 100644
--- a/generator/templates/schemavalidator.gotmpl
+++ b/generator/templates/schemavalidator.gotmpl
@@ -40,7 +40,7 @@
     return err
   }
   {{ end }}
-  {{ if .IsCustomFormatter }} 
+  {{ if .IsCustomFormatter }}{{/* the .IsStream case (ioReadCloser) is already excluded, since it does not resolve as primitive */}}
     {{ template "validationCustomformat" . }}
   {{ end }}
 {{ end }}
@@ -76,70 +76,74 @@
     }
   {{ end }}
   {{ if .Items }}
-    {{ if or .Items.Required .Items.HasValidations .Items.IsBaseType .Items.IsAliased }}
+    {{- if and (or .Items.Required .Items.HasValidations .Items.IsBaseType .Items.IsAliased) (not .Items.IsInterface) (not .Items.IsStream) }}
       for {{.IndexVar }} := 0; {{.IndexVar }} < len({{.ValueExpression }}); {{.IndexVar }}++ {
-      {{with .Items }}
-        {{ if and .IsNullable (not .Required) }}
+      {{- with .Items }}
+        {{- if and .IsNullable (not .Required) (not .IsMapNullOverride) }}
           if swag.IsZero({{ .ValueExpression }}) { // not required
             continue
           }
-        {{ end }}
-        {{template "propertyvalidator" . }}
-      {{ end }}
+        {{- end }}
+        {{ template "propertyvalidator" . }}
+      {{- end }}
       }
-    {{ end }}
-  {{ else }}
-    {{ if .IsNullable }}
+    {{- end }}
+  {{- else }}
+    {{- if or .IsAliased (ne .ValueExpression .ReceiverName) }}{{/* prevents generated code to call itself: this is reserved for aliased types */}}
+      {{- if and .IsNullable (not .IsMapNullOverride) }}
     if {{ .ValueExpression }} != nil {
-    {{ end }}
+      {{- end }}
       if err := {{.ValueExpression }}.Validate(formats); err != nil {
         if ve, ok := err.(*errors.Validation); ok {
           return ve.ValidateName({{ if .Path }}{{ .Path }}{{ else }}""{{ end }})
         }
         return err
       }
-    {{ if .IsNullable }}
+      {{- if and .IsNullable (not .IsMapNullOverride) }}
     }
-    {{ end }}
-  {{ end }}
+      {{- end }}
+    {{- end }}
+  {{- end }}
 {{ end }}
-{{ define "mapvalidator" }}
+{{ define "mapvalidator" }}{{/* validates additionalProperties */}}
   {{ if .HasAdditionalProperties }}
-    {{ if .AdditionalProperties.Required }}
+    {{ if and .IsMap .AdditionalProperties.Required }}
     if err := validate.Required({{ if .Path }}{{ .Path }}{{ else }}""{{ end }}, {{ printf "%q" .Location }}, {{ if not .IsAnonymous }}{{ .GoType }}({{ end }}{{.ValueExpression }}{{ if not .IsAnonymous }}){{ end }}); err != nil {
       return err
     }
     {{ end }}
-    {{ if  .AdditionalProperties.NeedsValidation }}
-    for {{.AdditionalProperties.KeyVar }} := range {{ .ValueExpression }} {
+    {{- if  .AdditionalProperties.HasValidations }}
+    for {{ .AdditionalProperties.KeyVar }} := range {{ .ValueExpression }} {
       {{ with .AdditionalProperties }}
         {{ if not .Required }}
       if swag.IsZero({{ .ValueExpression }}) { // not required
         continue
       }
         {{ end }}
-        {{ if .IsPrimitive }}
-          {{ if .IsAliased }}
-            {{ if not .IsAnonymous }}
-              {{ if .IsNullable }}
+        {{- if .IsPrimitive }}
+          {{- if .IsAliased }}
+            {{- if not .IsAnonymous }}
       if val, ok := {{ .ValueExpression }}; ok {
-              {{ end }}
-        if err := val.Validate(formats); err != nil {
-          return err
+              {{- if and .IsNullable (not .IsMapNullOverride) }}
+        if val != nil {
+              {{- end }}
+          if err := val.Validate(formats); err != nil {
+              return err
+          }
+              {{- if and .IsNullable (not .IsMapNullOverride) }}
         }
-              {{ if .IsNullable }}
+              {{- end }}
       }
-              {{ end }}
-            {{ else }}
+            {{- else }}{{/* validation of anonymous objects */}}
               {{ range .AllOf }}
                 {{ range .Properties }}
                   {{ template "propertyvalidator" . }}
                 {{ end }}
-              {{ end }}
+              {{- end }}
               {{ range .Properties }}
                 {{ template "propertyvalidator" . }}
               {{ end }}
-            {{ end }}
+            {{- end }}
             {{ if and .IsTuple .AdditionalItems }}
       // TODO: validating additional items should go here, if you see this raise an issue
       // at https://github.com/go-swagger/go-swagger/issues
@@ -147,8 +151,15 @@
           {{ else }}
             {{ template "primitivefieldvalidator" . }}
           {{ end }}
-        {{ else if .IsCustomFormatter }}
-          {{ template "validationCustomformat" . }}
+        {{- else if and .IsCustomFormatter (or .HasValidations .Required) }}{{/* custom format not captured as primitive */}}
+          {{- if .Required }}
+  if err := validate.Required{{ if and (eq .GoType "string") (not .IsNullable) }}String{{ end }}({{ if .Path }}{{ .Path }}{{ else }}""{{ end }}, {{ printf "%q" .Location }}, {{ if not (or .IsAnonymous .IsNullable) }}{{ .GoType }}({{ end }}{{.ValueExpression }}{{ if not (or .IsAnonymous .IsNullable) }}){{ end }}); err != nil {
+    return err
+  }
+          {{- end }}
+          {{- if not .IsStream }}{{/* TODO: IsStream and CustomFormattershould be mutually exclusive in type resolver */}}
+            {{ template "validationCustomformat" . }}
+          {{- end }}
         {{ else if .IsArray }}
           {{ template "slicevalidator" . }}
         {{ else if .IsMap }}
@@ -157,35 +168,37 @@
       if err := {{ .ReceiverName }}.validate{{ pascalize .Name }}ValueEnum({{ if .Path }}{{ .Path }}{{ else }}""{{ end }}, {{ printf "%q" .Location }}, {{ .ValueExpression }}); err != nil {
         return err
       }
-          {{ end }}
+          {{- end }}
         {{ else if or .IsComplexObject .IsTuple .IsAdditionalProperties .IsAliased }}
-          {{ if not .IsAnonymous }}
-            {{ if .IsNullable }}
-      if val, ok := {{ .ValueExpression }}; ok {
-            {{ end }}
-        if err := val.Validate(formats); err != nil {
-          return err
-        }
-            {{ if .IsNullable }}
+          {{- if not .IsAnonymous }}
+    if val, ok := {{ .ValueExpression }}; ok {
+            {{- if and .IsNullable (not .IsMapNullOverride) }}
+      if val != nil {
+            {{- end }}
+          if err := val.Validate(formats); err != nil {
+              return err
+          }
+            {{- if and .IsNullable (not .IsMapNullOverride) }}
       }
-            {{ end }}
-          {{ else }}
+            {{- end }}
+    }
+          {{- else }}
             {{ range .AllOf }}
               {{ range .Properties }}
                 {{ template "propertyvalidator" . }}
               {{ end }}
-            {{ end }}
+            {{- end }}
             {{ range .Properties }}
               {{ template "propertyvalidator" . }}
-            {{ end }}
-          {{ end }}
+            {{- end }}
+          {{- end }}
           {{ if and .IsTuple .AdditionalItems }}
       // TODO: validating additional items should go here, if you see this raise an issue
       // at https://github.com/go-swagger/go-swagger/issues
           {{ end }}
         {{ end }}
-      {{ end }}
     }
+      {{ end }}
     {{ end }}
     {{ if .Enum }}
     // from map
@@ -193,33 +206,60 @@
       return err
     }
     {{ end }}
-  {{ else if and .Required .IsAliased .IsInterface }}
+  {{- else if .IsAliased }}
+    {{- if and .Required .IsInterface }}
       if err := validate.Required({{ if .Path }}{{ .Path }}{{ else }}""{{ end }}, {{ printf "%q" .Location }}, {{.ValueExpression }}); err != nil {
         return err
       }
-  {{ end }}
+    {{- end }}
+    {{- if and .IsMap .HasValidations }}{{/* validation of aliased maps but does not know about AdditionalProperties: e.g. it comes from a $ref */}}
+      {{- if not .IsAnonymous }}
+        {{- if $.IsMap }}{{/* we come from a map range */}}
+      if val, ok := {{ .ValueExpression }}; ok {  
+        {{- end }}
+        {{- if and .IsNullable (not .IsMapNullOverride) }}
+          {{- if $.IsMap }}
+        if val != nil {
+          {{- else }}
+        if {{ .ValueExpression }} != nil {
+          {{- end }}
+        {{- end }}
+          if err := {{ if $.IsMap }}val{{ else }}{{ .ValueExpression }}{{ end }}.Validate(formats); err != nil {
+              return err
+          }
+        {{- if and .IsNullable (not .IsMapNullOverride) }}
+        }
+        {{- end }}
+        {{- if or $.IsMap }} 
+     }
+        {{- end }}
+      {{- end }}
+    {{- end }}
+  {{- end }}
 {{ end }}
 
 {{define "objectvalidator" }}
-  {{ if not .IsAnonymous }}
-    {{ if and .Required .IsNullable }}
+  {{- if not .IsAnonymous }}
+    {{- if and .Required .IsNullable }}
       if err := validate.Required({{ if .Path }}{{ .Path }}{{ else }}""{{ end }}, {{ printf "%q" .Location }}, {{.ValueExpression }}); err != nil {
         return err
       }
     {{ end }}
-    {{ if .IsNullable }}
+    {{- if or .IsAliased (ne .ValueExpression .ReceiverName) }}{{/* prevents generated code to call itself: case of aliased types */}}
+      {{- if and .IsNullable (not .IsMapNullOverride) }}
       if {{ .ValueExpression }} != nil {
-    {{ end }}
+      {{- end }}
       if err := {{.ValueExpression }}.Validate(formats); err != nil {
         if ve, ok := err.(*errors.Validation); ok {
           return ve.ValidateName({{ if .Path }}{{ .Path }}{{ else }}""{{ end }})
         }
         return err
       }
-    {{ if .IsNullable }}
+      {{- if and .IsNullable (not .IsMapNullOverride) }}
     }
-    {{ end }}
-  {{ else }}
+      {{- end }}
+    {{- end }}
+  {{- else }}
     {{ range .AllOf }}
       {{ range .Properties }}
         {{ template "propertyvalidator" . }}
@@ -228,41 +268,55 @@
     {{ range .Properties }}
       {{ template "propertyvalidator" . }}
     {{ end }}
-  {{ end }}
-  {{ if and .IsTuple .AdditionalItems }}
+  {{- end }}
+  {{- if and .IsTuple .AdditionalItems }}
     // TODO: validating additional items should go here, if you see this raise an issue
     // at https://github.com/go-swagger/go-swagger/issues
-  {{ end }}
+  {{- end }}
 {{ end }}
 
 {{define "propertyvalidator" }}
-  {{ if .IsPrimitive }}
-    {{ if .IsAliased }}
+  {{- if .IsPrimitive }}
+    {{- if .IsAliased }}
       {{ template "objectvalidator" . }}
-    {{ else }}
+    {{- else }}
       {{ template "primitivefieldvalidator" . }}
-    {{ end }}
-  {{ else if .IsCustomFormatter }}
-    {{ template "validationCustomformat" . }}
-  {{ else if .IsArray }}
+    {{- end }}
+    {{- else if and .IsCustomFormatter (or .HasValidations .Required) }}{{/* custom format not captured as primitive */}}
+    {{- if .Required }}
+  if err := validate.Required{{ if and (eq .GoType "string") (not .IsNullable) }}String{{ end }}({{ if .Path }}{{ .Path }}{{ else }}""{{ end }}, {{ printf "%q" .Location }}, {{ if not (or .IsAnonymous .IsNullable) }}{{ .GoType }}({{ end }}{{.ValueExpression }}{{ if not (or .IsAnonymous .IsNullable) }}){{ end }}); err != nil {
+    return err
+  }
+    {{- end }}
+    {{- if not .IsStream }}
+      {{ template "validationCustomformat" . }}
+    {{- end }}
+  {{- else if .IsArray }}
     {{ template "slicevalidator" . }}
-  {{ else if .IsMap }}
+    {{- else if and .IsMap (or (not .IsAliased) (and .IsAliased .IsInterface)) }}{{/* except for interface, the renderinf for aliased maps is performed by objectvalidator */}}
     {{ template "mapvalidator" . }}
-  {{ else if or .IsComplexObject .IsTuple .IsAdditionalProperties .IsAliased }}
+  {{- else if or .IsComplexObject .IsTuple .IsAdditionalProperties .IsAliased }}
     {{ template "objectvalidator" . }}
-  {{ end }}
+  {{- end }}
 {{ end }}
 
 {{ define "fieldvalidator"}}
-  {{ if .IsPrimitive }}
+  {{- if .IsPrimitive }}
     {{ template "primitivefieldvalidator" . }}
-  {{ else if .IsCustomFormatter }}
-    {{ template "validationCustomformat" . }}
-  {{ else if .IsArray }}
+  {{- else if and .IsCustomFormatter (or .HasValidations .Required) }}{{/* custom format not captured as primitive */}}
+    {{- if .Required }}
+  if err := validate.Required{{ if and (eq .GoType "string") (not .IsNullable) }}String{{ end }}({{ if .Path }}{{ .Path }}{{ else }}""{{ end }}, {{ printf "%q" .Location }}, {{ if not (or .IsAnonymous .IsNullable) }}{{ .GoType }}({{ end }}{{.ValueExpression }}{{ if not (or .IsAnonymous .IsNullable) }}){{ end }}); err != nil {
+    return err
+  }
+    {{- end }}
+    {{- if not .IsStream }}
+      {{ template "validationCustomformat" . }}
+    {{- end }}
+  {{- else if .IsArray }}
     {{ template "slicevalidator" . }}
-  {{ else if .IsMap }}
+  {{- else if .IsMap }}
     {{ template "mapvalidator" . }}
-  {{ end }}
+  {{- end }}
 {{ end }}
 
 {{define "schemavalidator" }}
@@ -337,15 +391,17 @@ func ({{ .ReceiverName }} *{{ if .IsExported }}{{ pascalize .Name }}{{ else }}{{
   }
   return nil
 }
-    {{ end }}
+    {{- end }}
   {{ end }}
-
 // Validate validates this {{ humanize .Name }}
 func ({{.ReceiverName }} {{ if or .IsTuple .IsComplexObject .IsAdditionalProperties }}*{{ end }}{{ if .Discriminates }}{{ camelize .Name }}{{ else if .IsExported }}{{ pascalize .Name }}{{ else }}{{ .Name }}{{ end }}) Validate(formats strfmt.Registry) error {
   var res []error
 
   {{ range .AllOf }}
-    {{ if or .Required .HasValidations }}
+    {{- if not .Properties }}
+      // validation for a type composition with {{ .GoType }}
+    {{- end }}
+    {{- if and (or .IsInterface .IsAnonymous .IsBaseType) (or .Required .HasValidations) }}
       {{ template "fieldvalidator" . }}
 
       {{ range .Properties }}
@@ -353,31 +409,34 @@ func ({{.ReceiverName }} {{ if or .IsTuple .IsComplexObject .IsAdditionalPropert
           if err := {{.ReceiverName }}.validate{{ pascalize .Name }}(formats); err != nil {
             res = append(res, err)
           }
-        {{ end }}
-      {{ end }}
-    {{ end }}
-    {{ if and .IsTuple .AdditionalItems }}
+        {{- end }}
+      {{- end }}
+      {{- if and .HasAdditionalProperties (not .IsMap) }}{{/* validates additionalProperties in an object which is not itself a map */}}
+        {{ template "mapvalidator" . }}
+      {{- end }}
+      {{ if and .IsTuple .AdditionalItems }}
       if err := {{ .ReceiverName }}.validate{{ pascalize .Name }}Items(formats); err != nil {
         res = append(res, err)
       }
-    {{ end }}
-    {{ if not (or .IsInterface (or .IsAnonymous .IsBaseType)) }}
+      {{ end }}
+    {{- else if (or .Required .HasValidations) }}
       if err := {{ .ReceiverName }}.{{ pascalize (dropPackage .GoType) }}.Validate(formats); err != nil {
         res = append(res, err)
       }
-    {{ end }}
-  {{ end }}
+    {{- end }}
+  {{- end }}
   {{ template "fieldvalidator" . }}
-
   {{ range .Properties }}
     {{ if and (ne $.DiscriminatorField .Name) (or .Required .HasValidations) }}
       if err := {{.ReceiverName }}.validate{{ pascalize .Name }}(formats); err != nil {
-        // prop
         res = append(res, err)
       }
     {{ end }}
   {{ end }}
-  {{ if and .IsTuple .AdditionalItems }}
+  {{- if and .HasAdditionalProperties (not .IsMap) }}{{/* validates additionalProperties in an object which is not itself a map */}}
+    {{ template "mapvalidator" . }}
+  {{- end }}
+  {{ if and .IsTuple .AdditionalItems }}{{/* validates additionalItems in a tuple */}}
     if err := {{ .ReceiverName }}.validate{{ pascalize .Name }}Items(formats); err != nil {
       res = append(res, err)
     }
diff --git a/generator/templates/tupleserializer.gotmpl b/generator/templates/tupleserializer.gotmpl
index 17426add..18cd6f2c 100644
--- a/generator/templates/tupleserializer.gotmpl
+++ b/generator/templates/tupleserializer.gotmpl
@@ -217,19 +217,22 @@ func ({{.ReceiverName}} {{ pascalize .Name }}) MarshalJSON() ([]byte, error) { {
 }
 {{ end }}
 
-{{ define "allOfSerializer" }}{{ $receiverName := .ReceiverName }}
+{{ define "allOfSerializer" }} 
+  {{- $receiverName := .ReceiverName }}
 // UnmarshalJSON unmarshals this object from a JSON structure
 func ({{.ReceiverName}} *{{ pascalize .Name }}) UnmarshalJSON(raw []byte) error {
-  {{ range .AllOf }}
-    {{ if .Properties }}
-  var data struct {
-      {{ range .Properties}}
-        {{ if not .IsBaseType }}
-          {{ if not $.IsExported }}
+  {{- range .AllOf }}
+    // {{ pascalize .Name }}
+    {{- if and .IsAnonymous .Properties }}{{/* unmarshalling properties in all of anonymous objects */}}
+      {{- $part :=  pascalize .Name }}
+      var data{{ $part }} struct {
+      {{- range .Properties }}
+        {{- if not .IsBaseType }}
+          {{- if not $.IsExported }}
             {{ template "privstructfield" . }}
-          {{ else }}
+          {{- else }}
             {{ pascalize .Name}} {{ template "schemaType" . }} `json:"{{ .Name }}{{ if not .Required }},omitempty{{ end }}"`
-          {{ end }}
+          {{- end }}
         {{ else }}
           {{ if not $.IsExported }}
             {{ template "privstructfield" . }}
@@ -237,7 +240,7 @@ func ({{.ReceiverName}} *{{ pascalize .Name }}) UnmarshalJSON(raw []byte) error
             {{ pascalize .Name}} json.RawMessage `json:"{{ .Name }}{{ if not .Required }},omitempty{{ end }}"`
           {{ end }}
         {{ end }}
-      {{ end }}
+      {{- end }}
       {{ if .HasAdditionalProperties }}
         {{ pascalize .AdditionalProperties.Name }}{{ if not .IsExported }}Field{{ end }} map[string]{{ template "schemaType" .AdditionalProperties }} `json:"-"`
       {{ end }}
@@ -245,14 +248,20 @@ func ({{.ReceiverName}} *{{ pascalize .Name }}) UnmarshalJSON(raw []byte) error
         {{ pascalize .AdditionalItems.Name }}{{ if or (not .IsExported) .IsSubType }}Field{{ end }} []{{ template "schemaType" .AdditionalItems }} `json:"-"`
       {{ end }}
   }
-  if err := swag.ReadJSON(raw, &data); err != nil {
+  if err := swag.ReadJSON(raw, &data{{ $part }}); err != nil {
     return err
   }
       {{ range .Properties }}
-  {{ $receiverName }}.{{ pascalize .Name }} = data.{{ pascalize .Name }}
+  {{ $receiverName }}.{{ pascalize .Name }} = data{{ $part }}.{{ pascalize .Name }}
       {{ end }}
-    {{ end }}
-    {{ if not .IsAnonymous }}
+    {{- else if .IsAnonymous }}
+  var {{ varname .Name }} {{ .GoType }}
+  if err := {{ if .IsBaseType}}Unmarshal{{ .GoType }}(bytes.NewBuffer(raw), &{{ varname .Name }}){{ else }} swag.ReadJSON(raw, &{{ varname .Name }}){{ end }}; err != nil {
+    return err
+  }
+  {{ .ValueExpression }} = {{ varname .Name }}
+    {{- end }}
+    {{- if not .IsAnonymous }}{{/* unmarshalling allOf named objects */}}
   var {{ varname .Name }} {{ .GoType }}
   if err := {{ if .IsBaseType}}Unmarshal{{ .GoType }}(bytes.NewBuffer(raw), &{{ varname .Name }}){{ else }} swag.ReadJSON(raw, &{{ varname .Name }}){{ end }}; err != nil {
     return err
@@ -265,24 +274,25 @@ func ({{.ReceiverName}} *{{ pascalize .Name }}) UnmarshalJSON(raw []byte) error
 
 // MarshalJSON marshals this object to a JSON structure
 func ({{.ReceiverName}} {{ pascalize .Name }}) MarshalJSON() ([]byte, error) {
-  var _parts [][]byte
+  _parts := make([][]byte, 0, {{ len .AllOf }})
   {{ range .AllOf }}
-    {{ if .Properties }}
-  var data struct {
-      {{ range .Properties -}}
-        {{ if not .IsBaseType }}
+    {{- if and .IsAnonymous .Properties }}
+      {{- $part :=  pascalize .Name }}
+  var data{{ $part }} struct {
+      {{- range .Properties }}
+        {{- if not .IsBaseType }}
           {{ if not $.IsExported }}
             {{ template "privstructfield" . }}
           {{ else }}
             {{ pascalize .Name}} {{ template "schemaType" . }} `json:"{{ .Name }}{{ if not .Required }},omitempty{{ end }}"`
           {{ end }}
-        {{ else }}
+        {{- else }}
           {{ if not $.IsExported }}
             {{ template "privstructfield" . }}
           {{ else }}
             {{ pascalize .Name}} json.RawMessage `json:"{{ .Name }}{{ if not .Required }},omitempty{{ end }}"`
           {{ end}}
-        {{ end }}
+        {{- end }}
       {{ end }}
       {{ if .HasAdditionalProperties }}
         {{ pascalize .AdditionalProperties.Name }}{{ if not .IsExported }}Field{{ end }} map[string]{{ template "schemaType" .AdditionalProperties }} `json:"-"`
@@ -293,15 +303,21 @@ func ({{.ReceiverName}} {{ pascalize .Name }}) MarshalJSON() ([]byte, error) {
   }
 
       {{ range .Properties }}
-  data.{{ pascalize .Name }} = {{ $receiverName }}.{{ pascalize .Name }}
+  data{{ $part }}.{{ pascalize .Name }} = {{ $receiverName }}.{{ pascalize .Name }}
       {{ end }}
 
-  jsonData, err := swag.WriteJSON(data)
+  jsonData{{ $part }}, err{{ $part }} := swag.WriteJSON(data{{ $part }})
+  if err{{ $part }} != nil {
+    return nil, err{{ $part }}
+  }
+  _parts = append(_parts, jsonData{{ $part }})
+    {{- else if .IsAnonymous }}{{/* unmarshalling anonymous type composition */}}
+  {{ varname .Name }}, err := swag.WriteJSON({{ .ValueExpression }})
   if err != nil {
     return nil, err
   }
-  _parts = append(_parts, jsonData)
-    {{ end }}
+  _parts = append(_parts, {{ varname .Name }})
+    {{- end }}
     {{ if not .IsAnonymous }}
   {{ varname .Name }}, err := swag.WriteJSON({{ $receiverName }}.{{ stripPackage .GoType "" }})
   if err != nil {
diff --git a/generator/templates/validation/structfield.gotmpl b/generator/templates/validation/structfield.gotmpl
index 62589c2c..52cc3cd5 100644
--- a/generator/templates/validation/structfield.gotmpl
+++ b/generator/templates/validation/structfield.gotmpl
@@ -44,4 +44,11 @@
 // Unique: true
 {{- end }}
 
+{{- if .IsCustomFormatter }}
+// Format: {{ .SwaggerFormat }}
+{{- end }}
+
+{{- if .Enum }}
+// Enum: {{ printf "%v" .Enum }}
+{{- end }}
 {{- end}}
diff --git a/generator/types.go b/generator/types.go
index e10733fa..16831f51 100644
--- a/generator/types.go
+++ b/generator/types.go
@@ -69,6 +69,7 @@ func simpleResolvedType(tn, fmt string, items *spec.Items) (result resolvedType)
 	//_, result.IsPrimitive = primitives[tn]
 
 	if tn == file {
+		// special case of swagger type "file", rendered as io.ReadCloser interface
 		result.IsPrimitive = true
 		result.GoType = typeMapping[binary]
 		result.IsStream = true
@@ -81,6 +82,8 @@ func simpleResolvedType(tn, fmt string, items *spec.Items) (result resolvedType)
 			result.GoType = tpe
 			result.IsPrimitive = true
 			_, result.IsCustomFormatter = customFormatters[tpe]
+			// special case of swagger format "binary", rendered as io.ReadCloser interface
+			// TODO(fredbi): should set IsCustomFormatter=false when binary
 			result.IsStream = fmt == binary
 			return
 		}
@@ -184,6 +187,14 @@ func (t *typeResolver) NewWithModelName(name string) *typeResolver {
 	}
 }
 
+// IsNullable hints the generator as to render the type with a pointer or not.
+//
+// A schema is deemed nullable (i.e. rendered by a pointer) when:
+// - a custom extension says it has to be so
+// - it is an object with properties
+// - it is a composed object (allOf)
+//
+// The interpretation of Required as a mean to make a type nullable is carried on elsewhere.
 func (t *typeResolver) IsNullable(schema *spec.Schema) bool {
 	nullable := t.isNullable(schema)
 	return nullable || len(schema.AllOf) > 0
@@ -202,7 +213,7 @@ func (t *typeResolver) resolveSchemaRef(schema *spec.Schema, isRequired bool) (r
 		ref, er = spec.ResolveRef(t.Doc.Spec(), &schema.Ref)
 		if er != nil {
 			if Debug {
-				log.Print("error resolving", er)
+				log.Printf("error resolving ref %s: %v", schema.Ref.String(), er)
 			}
 			err = er
 			return
@@ -259,6 +270,8 @@ func (t *typeResolver) resolveFormat(schema *spec.Schema, isAnonymous bool, isRe
 			result.SwaggerFormat = schema.Format
 			result.GoType = tpe
 			t.inferAliasing(&result, schema, isAnonymous, isRequired)
+			// special case of swagger format "binary", rendered as io.ReadCloser interface and is therefore not a primitive type
+			// TODO: should set IsCustomFormatter=false in this case.
 			result.IsPrimitive = schFmt != binary
 			result.IsStream = schFmt == binary
 			_, result.IsCustomFormatter = customFormatters[tpe]
@@ -305,6 +318,10 @@ func (t *typeResolver) firstType(schema *spec.Schema) string {
 	if len(schema.Type) == 0 || schema.Type[0] == "" {
 		return object
 	}
+	if len(schema.Type) > 1 {
+		// JSON-Schema multiple types, e.g. {"type": [ "object", "array" ]} are not supported.
+		log.Printf("warning: JSON-Schema type definition as array with several types is not supported in %#v. Taking the first type: %s", schema.Type, schema.Type[0])
+	}
 	return schema.Type[0]
 }
 
@@ -345,7 +362,6 @@ func (t *typeResolver) resolveArray(schema *spec.Schema, isAnonymous, isRequired
 		err = er
 		return
 	}
-
 	rt.IsNullable = t.IsNullable(schema.Items.Schema) && !rt.HasDiscriminator
 	result.GoType = "[]" + rt.GoType
 	if rt.IsNullable && !strings.HasPrefix(rt.GoType, "*") {
@@ -413,19 +429,59 @@ func (t *typeResolver) resolveObject(schema *spec.Schema, isAnonymous bool) (res
 	// account for additional properties
 	if schema.AdditionalProperties != nil && schema.AdditionalProperties.Schema != nil {
 		sch := schema.AdditionalProperties.Schema
-		et, er := t.ResolveSchema(schema.AdditionalProperties.Schema, sch.Ref.String() == "", false)
+		et, er := t.ResolveSchema(sch, sch.Ref.String() == "", false)
 		if er != nil {
 			err = er
 			return
 		}
+
 		result.IsMap = !result.IsComplexObject
+
 		result.SwaggerType = object
 
 		et.IsNullable = t.isNullable(schema.AdditionalProperties.Schema)
-		result.GoType = "map[string]" + et.GoType
 		if et.IsNullable {
 			result.GoType = "map[string]*" + et.GoType
+		} else {
+			result.GoType = "map[string]" + et.GoType
+
 		}
+
+		// Resolving nullability conflicts for:
+		// - map[][]...[]{items}
+		// - map[]{aliased type}
+		//
+		// when IsMap is true.
+		//
+		// IsMapNullOverride is to be handled by generator for special cases
+		// where the map element is considered non nullable and the element itself is.
+		//
+		// This allows to appreciate nullability according to the context.
+		needsOverride := result.IsMap && (et.IsArray || (sch.Ref.String() != "" || et.IsAliased || et.IsAnonymous)) //*&& !et.IsPrimitive*/
+
+		if needsOverride {
+			var er error
+			if et.IsArray {
+				var it resolvedType
+				s := sch
+				// resolve the last items after nested arrays
+				for s.Items != nil && s.Items.Schema != nil {
+					it, er = t.ResolveSchema(s.Items.Schema, sch.Ref.String() == "", false)
+					if er != nil {
+						return
+					}
+					s = s.Items.Schema
+				}
+				// mark an override when nullable status conflicts, i.e. when the original type is not already nullable
+				if !it.IsAnonymous || it.IsAnonymous && it.IsNullable {
+					result.IsMapNullOverride = true
+				}
+			} else {
+				// this locks the generator on the local nullability status
+				result.IsMapNullOverride = true
+			}
+		}
+
 		t.inferAliasing(&result, schema, isAnonymous, false)
 		result.ElemType = &et
 		return
@@ -434,6 +490,8 @@ func (t *typeResolver) resolveObject(schema *spec.Schema, isAnonymous bool) (res
 	if len(schema.Properties) > 0 {
 		return
 	}
+
+	// an object without property is rendered as interface{}
 	result.GoType = iface
 	result.IsMap = true
 	result.SwaggerType = object
@@ -515,7 +573,7 @@ func boolExtension(ext spec.Extensions, key string) *bool {
 }
 
 func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequired bool) (result resolvedType, err error) {
-	logDebug("resolving schema (anon: %t, req: %t) %s\n", isAnonymous, isRequired, t.ModelName /*bbb*/)
+	logDebug("resolving schema (anon: %t, req: %t) %s\n", isAnonymous, isRequired, t.ModelName)
 	if schema == nil {
 		result.IsInterface = true
 		result.GoType = iface
@@ -534,6 +592,7 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 		return
 	}
 
+	// special case of swagger type "file", rendered as io.ReadCloser interface
 	if t.firstType(schema) == file {
 		result.SwaggerType = file
 		result.IsPrimitive = true
@@ -605,7 +664,7 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 	}
 }
 
-// A resolvedType is a swagger type that has been resolved and analyzed for usage
+// resolvedType is a swagger type that has been resolved and analyzed for usage
 // in a template
 type resolvedType struct {
 	IsAnonymous       bool
@@ -617,14 +676,18 @@ type resolvedType struct {
 	IsAliased         bool
 	IsNullable        bool
 	IsStream          bool
-	HasDiscriminator  bool
 	IsEmptyOmitted    bool
 
 	// A tuple gets rendered as an anonymous struct with P{index} as property name
 	IsTuple            bool
 	HasAdditionalItems bool
-	IsComplexObject    bool
-	IsBaseType         bool
+
+	// A complex object gets rendered as a struct
+	IsComplexObject bool
+
+	// A polymorphic type
+	IsBaseType       bool
+	HasDiscriminator bool
 
 	GoType        string
 	Pkg           string
@@ -634,7 +697,12 @@ type resolvedType struct {
 	SwaggerFormat string
 	Extensions    spec.Extensions
 
+	// The type of the element in a slice or map
 	ElemType *resolvedType
+
+	// IsMapNullOverride indicates that a nullable object is used within an
+	// aliased map. In this case, the reference is not rendered with a pointer
+	IsMapNullOverride bool
 }
 
 func (rt *resolvedType) Zero() string {
diff --git a/hack/codegen-nonreg.sh b/hack/codegen-nonreg.sh
index df6d8f31..d9afd527 100755
--- a/hack/codegen-nonreg.sh
+++ b/hack/codegen-nonreg.sh
@@ -57,20 +57,24 @@ if [ ! -f `which swagger` ]; then
   exit 1
 fi
 
-# The following ones fail generation: todo existing_model requires pregeneration
 # NOTE(fredbi): 
-# - issue72: invalid spec
-# - todolist.discriminators.yml: invalid mode generation (issue#1376)
-# - bitbucket.json: model does not compile (anonymous allOf1)
-# - azure-text-analyis.json: invalid specification with duplicate property in allOf construct (provided fixed version for testing)
+# The following ones fail generation: 
+# - todo existing_model requires pregeneration
+# - issue72: model works with --skip-validation. Invalid spec (duplicate operationID)
 # - todolist.simple.yml: invalid default values put on purpose for UT (provided fixed version for testing)
+#
+# The following ones requires some checks to be skipped:
+# - azure-text-analyis.json: works with --skip-validation. Invalid specification with duplicate property in allOf construct (provided fixed version for testing)
+# - azure-text-analyis.json: should work with -skip-validation
+#
+# The following ones used to fail and are ok:
+# - todolist.discriminators.yml: works
+# - bitbucket.json: works nows
+# - cloudbreak.json : now works
 known_failed="@(\
-azure-text-analyis.json|\
-bitbucket.json|\
 existing-model.yml|\
 issue72.json|\
-todolist.simple.yml|\
-cloudbreak.json\
+todolist.simple.yml\
 )"
 # The following ones should fail validation, but produce correct generated code (at least it builds)
 known_skip_validation="@(\
@@ -78,6 +82,7 @@ todolist.enums.yml|\
 todolist.enums.flattened.json|\
 todolist.models.yml|\
 todolist.schemavalidation.yml|\
+azure-text-analyis.json|\
 swagger-gsma.json\
 )"
 
