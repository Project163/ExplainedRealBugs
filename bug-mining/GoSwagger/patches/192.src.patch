diff --git a/docs/generate/spec/meta.md b/docs/generate/spec/meta.md
index c7704c2e..fd46c457 100644
--- a/docs/generate/spec/meta.md
+++ b/docs/generate/spec/meta.md
@@ -73,6 +73,14 @@ Annotation | Format
 //          type: apiKey
 //          name: KEY
 //          in: header
+//     - oauth2:
+//         type: oauth2
+//         authorizationUrl: /oauth2/auth
+//         tokenUrl: /oauth2/token
+//         in: header
+//         scopes:
+//           bar: foo
+//         flow: accessCode
 //
 //     Extensions:
 //     ---
diff --git a/fixtures/goparsing/classification/doc.go b/fixtures/goparsing/classification/doc.go
index c6828a1a..001a499f 100644
--- a/fixtures/goparsing/classification/doc.go
+++ b/fixtures/goparsing/classification/doc.go
@@ -58,6 +58,14 @@
 //          type: apiKey
 //          name: KEY
 //          in: header
+//     - oauth2:
+//         type: oauth2
+//         authorizationUrl: /oauth2/auth
+//         tokenUrl: /oauth2/token
+//         in: header
+//         scopes:
+//           bla: foo
+//         flow: accessCode
 //
 // swagger:meta
 package classification
diff --git a/scan/meta_test.go b/scan/meta_test.go
index f5ab3476..05efd60c 100644
--- a/scan/meta_test.go
+++ b/scan/meta_test.go
@@ -86,13 +86,25 @@ func verifyMeta(t testing.TB, doc *spec.Swagger) {
 	assert.EqualValues(t, []string{"application/json", "application/xml"}, doc.Produces)
 	assert.EqualValues(t, []string{"http", "https"}, doc.Schemes)
 	assert.EqualValues(t, []map[string][]string{{"api_key": {}}}, doc.Security)
-	expectedSecuritySchema := spec.SecurityScheme{
+	expectedSecuritySchemaKey := spec.SecurityScheme{
 		SecuritySchemeProps: spec.SecuritySchemeProps{
 			Type: "apiKey",
 			In:   "header",
 			Name: "KEY",
 		},
 	}
+	expectedSecuritySchemaOAuth := spec.SecurityScheme{
+		SecuritySchemeProps: spec.SecuritySchemeProps{
+			Type:             "oauth2",
+			In:               "header",
+			AuthorizationURL: "/oauth2/auth",
+			TokenURL:         "/oauth2/token",
+			Flow:             "accessCode",
+			Scopes: map[string]string{
+				"bla": "foo",
+			},
+		},
+	}
 	expectedExtensions := spec.Extensions{
 		"x-meta-array": []interface{}{
 			"value1",
@@ -106,7 +118,9 @@ func verifyMeta(t testing.TB, doc *spec.Swagger) {
 		},
 		"x-meta-value": "value",
 	}
-	assert.EqualValues(t, map[string]*spec.SecurityScheme{"api_key": &expectedSecuritySchema}, doc.SecurityDefinitions)
+	assert.NotNil(t, doc.SecurityDefinitions["api_key"])
+	assert.NotNil(t, doc.SecurityDefinitions["oauth2"])
+	assert.EqualValues(t, spec.SecurityDefinitions{"api_key": &expectedSecuritySchemaKey, "oauth2": &expectedSecuritySchemaOAuth}, doc.SecurityDefinitions)
 	assert.EqualValues(t, expectedExtensions, doc.Extensions)
 	assert.Equal(t, "localhost", doc.Host)
 	assert.Equal(t, "/v2", doc.BasePath)
diff --git a/scan/validators.go b/scan/validators.go
index 9fcfd2b9..d6f475b0 100644
--- a/scan/validators.go
+++ b/scan/validators.go
@@ -574,6 +574,7 @@ var (
 	rxSecuritySchemeDescription   = regexp.MustCompile(`[Dd]escription\p{Zs}*:`)
 	rxSecuritySchemeAuthorization = regexp.MustCompile(`[Aa]uthorizationUrl\p{Zs}*:`)
 	rxSecuritySchemeToken         = regexp.MustCompile(`[Tt]okenUrl\p{Zs}*:`)
+	rxSecuritySchemeScopes        = regexp.MustCompile(`[Ss]copes\p{Zs}*:`)
 )
 
 func (ss *setSecurityDefinitions) Parse(lines []string) error {
@@ -582,9 +583,11 @@ func (ss *setSecurityDefinitions) Parse(lines []string) error {
 	}
 
 	result := spec.SecurityDefinitions{}
-	var scheme spec.SecurityScheme
+	var scheme *spec.SecurityScheme
 	var key string
 	var tp []tagParser
+	var groupedLines []string
+	var groupParser *tagParser
 	for i := 0; i < len(lines); i++ {
 		kv := strings.SplitN(lines[i], ":", 2)
 		if len(kv) <= 1 {
@@ -593,36 +596,64 @@ func (ss *setSecurityDefinitions) Parse(lines []string) error {
 
 		k, v := kv[0], strings.TrimSpace(kv[1])
 
-		if v == "" {
+		if v == "" && !rxSecuritySchemeScopes.MatchString(lines[i]) {
+			if len(groupedLines) > 0 {
+				err := groupParser.Parse(groupedLines)
+				if err != nil {
+					return err
+				}
+				groupedLines = []string{}
+			}
 			if key != "" {
-				result[key] = &scheme
+				result[key] = scheme
 			}
-			scheme = spec.SecurityScheme{}
+			scheme = new(spec.SecurityScheme)
 			key = k
 			tp = []tagParser{
-				newSingleLineTagParser("type", newSetField(rxSecuritySchemeType, setSecuritySchemeType(&scheme))),
-				newSingleLineTagParser("name", newSetField(rxSecuritySchemeName, setSecuritySchemeName(&scheme))),
-				newSingleLineTagParser("in", newSetField(rxSecuritySchemeIn, setSecuritySchemeIn(&scheme))),
-				newSingleLineTagParser("flow", newSetField(rxSecuritySchemeFlow, setSecuritySchemeFlow(&scheme))),
-				newSingleLineTagParser("description", newSetField(rxSecuritySchemeDescription, setSecuritySchemeDescription(&scheme))),
-				newSingleLineTagParser("authorizationUrl", newSetField(rxSecuritySchemeAuthorization, setSecuritySchemeAuthorizationURL(&scheme))),
-				newSingleLineTagParser("tokenUrl", newSetField(rxSecuritySchemeToken, setSecuritySchemeTokenURL(&scheme))),
+				newSingleLineTagParser("type", newSetField(rxSecuritySchemeType, setSecuritySchemeType(scheme))),
+				newSingleLineTagParser("name", newSetField(rxSecuritySchemeName, setSecuritySchemeName(scheme))),
+				newSingleLineTagParser("in", newSetField(rxSecuritySchemeIn, setSecuritySchemeIn(scheme))),
+				newSingleLineTagParser("flow", newSetField(rxSecuritySchemeFlow, setSecuritySchemeFlow(scheme))),
+				newSingleLineTagParser("description", newSetField(rxSecuritySchemeDescription, setSecuritySchemeDescription(scheme))),
+				newSingleLineTagParser("authorizationUrl", newSetField(rxSecuritySchemeAuthorization, setSecuritySchemeAuthorizationURL(scheme))),
+				newSingleLineTagParser("tokenUrl", newSetField(rxSecuritySchemeToken, setSecuritySchemeTokenURL(scheme))),
+				newMultiLineTagParser("scopes", newSetMapStringString(rxSecuritySchemeScopes, setSecuritySchemeScopes(scheme))),
 			}
 			continue
 		} else {
+			matched := false
 			for _, p := range tp {
 				if p.Matches(lines[i]) {
-					err := p.Parse([]string{lines[i]})
-					if err != nil {
-						return err
+					if len(groupedLines) > 0 {
+						err := groupParser.Parse(groupedLines)
+						if err != nil {
+							return err
+						}
+						groupedLines = []string{}
+					}
+					groupParser = &p
+					matched = true
+					if !p.MultiLine {
+						groupedLines = append(groupedLines, lines[i])
 					}
 					break
 				}
 			}
+			if !matched && groupParser != nil && groupParser.MultiLine {
+				groupedLines = append(groupedLines, lines[i])
+			}
+		}
+
+	}
+	if len(groupedLines) > 0 {
+		err := groupParser.Parse(groupedLines)
+		if err != nil {
+			return err
 		}
 	}
+
 	if _, ok := result[key]; !ok && key != "" {
-		result[key] = &scheme
+		result[key] = scheme
 	}
 
 	ss.set(result)
@@ -657,6 +688,45 @@ func setSecuritySchemeTokenURL(scheme *spec.SecurityScheme) func(string) {
 	return func(val string) { scheme.TokenURL = val }
 }
 
+func setSecuritySchemeScopes(scheme *spec.SecurityScheme) func(map[string]string) {
+	return func(val map[string]string) { scheme.Scopes = val }
+}
+
+func newSetMapStringString(rx *regexp.Regexp, setter func(map[string]string)) *setMapStringString {
+	return &setMapStringString{
+		rx:  rx,
+		set: setter,
+	}
+}
+
+type setMapStringString struct {
+	set func(map[string]string)
+	rx  *regexp.Regexp
+}
+
+func (sf *setMapStringString) Matches(line string) bool {
+	return sf.rx.MatchString(line)
+}
+
+func (sf *setMapStringString) Parse(lines []string) error {
+	if len(lines) == 0 || (len(lines) == 1 && len(lines[0]) == 0) {
+		return nil
+	}
+
+	values := map[string]string{}
+	for _, line := range lines {
+		kv := strings.SplitN(line, ":", 2)
+		if len(kv) > 1 {
+			values[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
+			break
+		} else {
+			return fmt.Errorf("expecting `key: value`, got key only for string: %s", line)
+		}
+	}
+	sf.set(values)
+	return nil
+}
+
 func newSetField(rx *regexp.Regexp, setter func(string)) *setField {
 	return &setField{
 		rx:  rx,
