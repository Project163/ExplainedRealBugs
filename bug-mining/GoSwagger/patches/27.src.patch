diff --git a/generator/operation.go b/generator/operation.go
index 526704bf..6700e253 100644
--- a/generator/operation.go
+++ b/generator/operation.go
@@ -143,14 +143,15 @@ func (o *operationGenerator) Generate() error {
 			log.Println("generated handler", op.Package+"."+o.cname)
 		}
 
-		if o.IncludeParameters && len(o.Operation.Parameters) > 0 {
+		opParams := o.Doc.ParametersFor(o.Operation.ID)
+		if o.IncludeParameters && len(opParams) > 0 {
 			if err := o.generateParameterModel(); err != nil {
 				return fmt.Errorf("parameters: %s", err)
 			}
 			log.Println("generated parameters", op.Package+"."+o.cname+"Parameters")
 		}
 
-		if len(o.Operation.Parameters) == 0 {
+		if len(opParams) == 0 {
 			log.Println("no parameters for operation", op.Package+"."+o.cname)
 		}
 	}
@@ -208,7 +209,7 @@ func (b *codeGenOpBuilder) MakeOperation() (GenOperation, error) {
 	operation := b.Operation
 	var params, qp, pp, hp, fp []GenParameter
 	var hasQueryParams bool
-	for _, p := range operation.Parameters {
+	for _, p := range b.Doc.ParametersFor(operation.ID) {
 		cp, err := b.MakeParameter(receiver, &resolver, p)
 		if err != nil {
 			return GenOperation{}, err
diff --git a/spec/analyzer.go b/spec/analyzer.go
index 71ef4025..11487b1d 100644
--- a/spec/analyzer.go
+++ b/spec/analyzer.go
@@ -163,11 +163,46 @@ func (s *specAnalyzer) paramsAsMap(parameters []Parameter, res map[string]Parame
 	}
 }
 
+func (s *specAnalyzer) ParametersFor(operationID string) []Parameter {
+	gatherParams := func(pi *PathItem, op *Operation) []Parameter {
+		bag := make(map[string]Parameter)
+		s.paramsAsMap(pi.Parameters, bag)
+		s.paramsAsMap(op.Parameters, bag)
+
+		var res []Parameter
+		for _, v := range bag {
+			res = append(res, v)
+		}
+		return res
+	}
+	for _, pi := range s.spec.Paths.Paths {
+		if pi.Get != nil && pi.Get.ID == operationID {
+			return gatherParams(&pi, pi.Get)
+		}
+		if pi.Head != nil && pi.Head.ID == operationID {
+			return gatherParams(&pi, pi.Head)
+		}
+		if pi.Options != nil && pi.Options.ID == operationID {
+			return gatherParams(&pi, pi.Options)
+		}
+		if pi.Post != nil && pi.Post.ID == operationID {
+			return gatherParams(&pi, pi.Post)
+		}
+		if pi.Patch != nil && pi.Patch.ID == operationID {
+			return gatherParams(&pi, pi.Patch)
+		}
+		if pi.Put != nil && pi.Put.ID == operationID {
+			return gatherParams(&pi, pi.Put)
+		}
+		if pi.Delete != nil && pi.Delete.ID == operationID {
+			return gatherParams(&pi, pi.Delete)
+		}
+	}
+	return nil
+}
+
 func (s *specAnalyzer) ParamsFor(method, path string) map[string]Parameter {
 	res := make(map[string]Parameter)
-	//for _, param := range s.spec.Parameters {
-	//res[fieldNameFromParam(&param)] = param
-	//}
 	if pi, ok := s.spec.Paths.Paths[path]; ok {
 		s.paramsAsMap(pi.Parameters, res)
 		s.paramsAsMap(s.operations[strings.ToUpper(method)][path].Parameters, res)
