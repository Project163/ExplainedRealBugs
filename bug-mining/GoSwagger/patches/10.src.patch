diff --git a/README.md b/README.md
index 94478d1f..33ef1fa8 100644
--- a/README.md
+++ b/README.md
@@ -74,7 +74,7 @@ For a V1 I want to have this feature set completed:
 	-	[x] validate a swagger spec document:
     -	[x] validate against jsonschema
     -	[ ] validate extra rules outlined [here](https://github.com/apigee-127/swagger-tools/blob/master/docs/Swagger_Validation.md)
-      - [ ] definition can't declare a property that's already defined by one of its ancestors (Error)
+      - [x] definition can't declare a property that's already defined by one of its ancestors (Error)
       - [ ] definition's ancestor can't be a descendant of the same model (Error)
       - [x] each api path should be non-verbatim (account for path param names) unique per method (Error)
       - [ ] each security reference should contain only unique scopes (Warning)
diff --git a/fixtures/validation/duplicateprops.json b/fixtures/validation/duplicateprops.json
new file mode 100644
index 00000000..d1756e90
--- /dev/null
+++ b/fixtures/validation/duplicateprops.json
@@ -0,0 +1,137 @@
+{
+    "swagger": "2.0",
+    "info": {
+        "description": "This is a sample server Petstore server.\n\n[Learn about Swagger](http://swagger.wordnik.com) or join the IRC channel `#swagger` on irc.freenode.net.\n\nFor this sample, you can use the api key `special-key` to test the authorization filters\n",
+        "version": "1.0.0",
+        "title": "Swagger Petstore",
+        "termsOfService": "http://helloreverb.com/terms/",
+        "contact": {
+            "name": "apiteam@wordnik.com"
+        },
+        "license": {
+            "name": "Apache 2.0",
+            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
+        }
+    },
+    "host": "petstore.swagger.wordnik.com",
+    "basePath": "/v2",
+    "schemes": [
+        "http"
+    ],
+    "paths": {
+        "/pets": {
+          "get": {
+            "tags": ["pet"],
+            "summary": "list the pets",
+            "operationId": "getPets",
+            "responses": {
+              "default": {
+                "description": "Generic Error"
+              },
+              "200": {
+                "description": "Pets list",
+                "schema": {
+                  "type": "array",
+                  "items": {
+                    "$ref": "Pet"
+                  }
+                }
+              }
+            }
+          }
+        }
+    },
+    "definitions": {
+        "Parent": {
+          "properties": {
+            "id": {
+              "type": "integer",
+              "format": "int64"
+            },
+            "name": {
+              "type": "string"
+            }
+          }
+        },
+        "ValidChild": {
+          "allOf": [{
+            "$ref": "#/definitions/Parent"
+          }, {
+            "properties": {
+              "age": {
+                "type": "integer",
+                "format": "int32"
+              }
+            }
+          }]
+        },
+        "InvalidChild": {
+          "allOf": [{
+            "$ref": "#/definitions/Parent"
+          }, {
+            "properties": {
+              "name": {
+                "type": "string"
+              }
+            }
+          }]
+        },
+        "Category": {
+            "properties": {
+                "id": {
+                    "type": "integer",
+                    "format": "int64"
+                },
+                "name": {
+                    "type": "string"
+                }
+            }
+        },
+        "Pet": {
+            "required": [
+                "name",
+                "photoUrls"
+            ],
+            "properties": {
+                "id": {
+                    "type": "integer",
+                    "format": "int64"
+                },
+                "category": {
+                    "$ref": "#/definitions/Category"
+                },
+                "name": {
+                    "type": "string",
+                    "example": "doggie"
+                },
+                "photoUrls": {
+                    "type": "array",
+                    "items": {
+                        "type": "string"
+                    }
+                },
+                "tags": {
+                    "type": "array",
+                    "items": {
+                        "$ref": "#/definitions/Tag"
+                    }
+                },
+                "status": {
+                    "type": "string",
+                    "description": "pet status in the store"
+                }
+            }
+        },
+        "Tag": {
+            "properties": {
+                "id": {
+                    "type": "integer",
+                    "format": "int64"
+                },
+                "name": {
+                    "type": "string"
+                }
+            }
+        }
+    }
+}
diff --git a/fixtures/validation/nestedduplicateprops.json b/fixtures/validation/nestedduplicateprops.json
new file mode 100644
index 00000000..d19330cf
--- /dev/null
+++ b/fixtures/validation/nestedduplicateprops.json
@@ -0,0 +1,137 @@
+{
+    "swagger": "2.0",
+    "info": {
+        "description": "This is a sample server Petstore server.\n\n[Learn about Swagger](http://swagger.wordnik.com) or join the IRC channel `#swagger` on irc.freenode.net.\n\nFor this sample, you can use the api key `special-key` to test the authorization filters\n",
+        "version": "1.0.0",
+        "title": "Swagger Petstore",
+        "termsOfService": "http://helloreverb.com/terms/",
+        "contact": {
+            "name": "apiteam@wordnik.com"
+        },
+        "license": {
+            "name": "Apache 2.0",
+            "url": "http://www.apache.org/licenses/LICENSE-2.0.html"
+        }
+    },
+    "host": "petstore.swagger.wordnik.com",
+    "basePath": "/v2",
+    "schemes": [
+        "http"
+    ],
+    "paths": {
+        "/pets": {
+          "get": {
+            "tags": ["pet"],
+            "summary": "list the pets",
+            "operationId": "getPets",
+            "responses": {
+              "default": {
+                "description": "Generic Error"
+              },
+              "200": {
+                "description": "Pets list",
+                "schema": {
+                  "type": "array",
+                  "items": {
+                    "$ref": "Pet"
+                  }
+                }
+              }
+            }
+          }
+        }
+    },
+    "definitions": {
+        "Parent": {
+          "properties": {
+            "id": {
+              "type": "integer",
+              "format": "int64"
+            },
+            "name": {
+              "type": "string"
+            }
+          }
+        },
+        "ValidChild": {
+          "allOf": [{
+            "$ref": "#/definitions/Parent"
+          }, {
+            "properties": {
+              "age": {
+                "type": "integer",
+                "format": "int32"
+              }
+            }
+          }]
+        },
+        "InvalidChild": {
+          "allOf": [{
+            "$ref": "#/definitions/ValidChild"
+          }, {
+            "properties": {
+              "name": {
+                "type": "string"
+              }
+            }
+          }]
+        },
+        "Category": {
+            "properties": {
+                "id": {
+                    "type": "integer",
+                    "format": "int64"
+                },
+                "name": {
+                    "type": "string"
+                }
+            }
+        },
+        "Pet": {
+            "required": [
+                "name",
+                "photoUrls"
+            ],
+            "properties": {
+                "id": {
+                    "type": "integer",
+                    "format": "int64"
+                },
+                "category": {
+                    "$ref": "#/definitions/Category"
+                },
+                "name": {
+                    "type": "string",
+                    "example": "doggie"
+                },
+                "photoUrls": {
+                    "type": "array",
+                    "items": {
+                        "type": "string"
+                    }
+                },
+                "tags": {
+                    "type": "array",
+                    "items": {
+                        "$ref": "#/definitions/Tag"
+                    }
+                },
+                "status": {
+                    "type": "string",
+                    "description": "pet status in the store"
+                }
+            }
+        },
+        "Tag": {
+            "properties": {
+                "id": {
+                    "type": "integer",
+                    "format": "int64"
+                },
+                "name": {
+                    "type": "string"
+                }
+            }
+        }
+    }
+}
diff --git a/internal/validate/spec.go b/internal/validate/spec.go
index d0a9a398..64ec5b9c 100644
--- a/internal/validate/spec.go
+++ b/internal/validate/spec.go
@@ -47,11 +47,14 @@ func (s *SpecValidator) Validate(data interface{}) (errs *Result, warnings *Resu
 	if errs.HasErrors() {
 		return // no point in continuing
 	}
+
 	errs.Merge(s.validateReferencesValid()) // error
 	if errs.HasErrors() {
 		return // no point in continuing
 	}
 
+	errs.Merge(s.validateDuplicatePropertyNames())         // error
+	errs.Merge(s.validateCircularAncestry())               // error
 	errs.Merge(s.validateParameters())                     // error -
 	errs.Merge(s.validateItems())                          // error -
 	errs.Merge(s.validateRequiredDefinitions())            // error -
@@ -64,6 +67,72 @@ func (s *SpecValidator) Validate(data interface{}) (errs *Result, warnings *Resu
 	return
 }
 
+type dupProp struct {
+	Name       string
+	Definition string
+}
+
+func (s *SpecValidator) validateDuplicatePropertyNames() *Result {
+	// definition can't declare a property that's already defined by one of its ancestors
+	res := new(Result)
+	for k, sch := range s.spec.Spec().Definitions {
+		if len(sch.AllOf) == 0 {
+			continue
+		}
+		knowns := make(map[string]struct{})
+		dups := s.validateSchemaPropertyNames(k, sch, knowns)
+		if len(dups) > 0 {
+			var pns []string
+			for _, v := range dups {
+				pns = append(pns, v.Definition+"."+v.Name)
+			}
+			res.AddErrors(errors.New(422, "definition %q contains duplicate properties: %v", k, pns))
+		}
+	}
+	return res
+}
+
+func (s *SpecValidator) validateSchemaPropertyNames(nm string, sch spec.Schema, knowns map[string]struct{}) []dupProp {
+	var dups []dupProp
+
+	schn := nm
+	schc := &sch
+	if sch.Ref.GetURL() != nil {
+		// gather property names
+		if sch.Ref.GetURL() != nil {
+			reso, err := spec.ResolveRef(s.spec.Spec(), &sch.Ref)
+			if err != nil {
+				panic(err)
+			}
+			schc = reso
+			schn = sch.Ref.String()
+		}
+	}
+
+	if len(schc.AllOf) > 0 {
+		for _, chld := range schc.AllOf {
+			dups = append(dups, s.validateSchemaPropertyNames(schn, chld, knowns)...)
+		}
+		return dups
+	}
+
+	for k := range schc.Properties {
+		_, ok := knowns[k]
+		if ok {
+			dups = append(dups, dupProp{Name: k, Definition: schn})
+		} else {
+			knowns[k] = struct{}{}
+		}
+	}
+
+	return dups
+}
+
+func (s *SpecValidator) validateCircularAncestry() *Result {
+	// definition's ancestor can't be a descendant of the same model
+	return nil
+}
+
 func (s *SpecValidator) validateItems() *Result {
 	// validate parameter, items, schema and response objects for presence of item if type is array
 	res := new(Result)
diff --git a/internal/validate/spec_test.go b/internal/validate/spec_test.go
index 1b091738..fb0a3163 100644
--- a/internal/validate/spec_test.go
+++ b/internal/validate/spec_test.go
@@ -1,108 +1,41 @@
 package validate
 
 import (
+	"path/filepath"
 	"testing"
 
 	"github.com/go-swagger/go-swagger/internal/testing/petstore"
 	"github.com/go-swagger/go-swagger/spec"
+	"github.com/go-swagger/go-swagger/strfmt"
 	"github.com/stretchr/testify/assert"
 )
 
-func TestValidateItems(t *testing.T) {
-	doc, api := petstore.NewAPI(t)
-	validator := NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
-	validator.spec = doc
-	res := validator.validateItems()
-	assert.Empty(t, res.Errors)
+func TestValidateDuplicatePropertyNames(t *testing.T) {
+	// simple allOf
+	doc, err := spec.JSONSpec(filepath.Join("..", "..", "fixtures", "validation", "duplicateprops.json"))
+	if assert.NoError(t, err) {
+		validator := NewSpecValidator(spec.MustLoadSwagger20Schema(), strfmt.Default)
+		validator.spec = doc
+		res := validator.validateDuplicatePropertyNames()
+		assert.NotEmpty(t, res.Errors)
+		assert.Len(t, res.Errors, 1)
 
-	// in operation parameters
-	sw := doc.Spec()
-	sw.Paths.Paths["/pets"].Get.Parameters[0].Type = "array"
-	res = validator.validateItems()
-	assert.NotEmpty(t, res.Errors)
-
-	sw.Paths.Paths["/pets"].Get.Parameters[0].Items = spec.NewItems().Typed("string", "")
-	res = validator.validateItems()
-	assert.Empty(t, res.Errors)
-
-	sw.Paths.Paths["/pets"].Get.Parameters[0].Items = spec.NewItems().Typed("array", "")
-	res = validator.validateItems()
-	assert.NotEmpty(t, res.Errors)
-
-	sw.Paths.Paths["/pets"].Get.Parameters[0].Items.Items = spec.NewItems().Typed("string", "")
-	res = validator.validateItems()
-	assert.Empty(t, res.Errors)
-
-	// in global parameters
-	sw.Parameters = make(map[string]spec.Parameter)
-	sw.Parameters["other"] = *spec.SimpleArrayParam("other", "array", "csv")
-	res = validator.validateItems()
-	assert.Empty(t, res.Errors)
-
-	pp := spec.SimpleArrayParam("other", "array", "")
-	pp.Items = nil
-	sw.Parameters["other"] = *pp
-	res = validator.validateItems()
-	assert.NotEmpty(t, res.Errors)
-
-	// in shared path object parameters
-	doc, api = petstore.NewAPI(t)
-	validator = NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
-	validator.spec = doc
-	sw = doc.Spec()
-
-	pa := sw.Paths.Paths["/pets"]
-	pa.Parameters = []spec.Parameter{*spec.SimpleArrayParam("another", "array", "csv")}
-	sw.Paths.Paths["/pets"] = pa
-	res = validator.validateItems()
-	assert.Empty(t, res.Errors)
-
-	pa = sw.Paths.Paths["/pets"]
-	pp = spec.SimpleArrayParam("other", "array", "")
-	pp.Items = nil
-	pa.Parameters = []spec.Parameter{*pp}
-	sw.Paths.Paths["/pets"] = pa
-	res = validator.validateItems()
-	assert.NotEmpty(t, res.Errors)
-
-	// in body param schema
-	doc, api = petstore.NewAPI(t)
-	validator = NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
-	validator.spec = doc
-	sw = doc.Spec()
-	pa = sw.Paths.Paths["/pets"]
-	pa.Post.Parameters[0].Schema = spec.ArrayProperty(nil)
-	res = validator.validateItems()
-	assert.NotEmpty(t, res.Errors)
+	}
 
-	// in response headers
-	doc, api = petstore.NewAPI(t)
-	validator = NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
-	validator.spec = doc
-	sw = doc.Spec()
-	pa = sw.Paths.Paths["/pets"]
-	rp := pa.Post.Responses.StatusCodeResponses[200]
-	var hdr spec.Header
-	hdr.Type = "array"
-	rp.Headers = make(map[string]spec.Header)
-	rp.Headers["X-YADA"] = hdr
-	pa.Post.Responses.StatusCodeResponses[200] = rp
-	res = validator.validateItems()
-	assert.NotEmpty(t, res.Errors)
+	// nested allOf
+	doc, err = spec.JSONSpec(filepath.Join("..", "..", "fixtures", "validation", "nestedduplicateprops.json"))
+	if assert.NoError(t, err) {
+		validator := NewSpecValidator(spec.MustLoadSwagger20Schema(), strfmt.Default)
+		validator.spec = doc
+		res := validator.validateDuplicatePropertyNames()
+		assert.NotEmpty(t, res.Errors)
+		assert.Len(t, res.Errors, 1)
 
-	// in response schema
-	doc, api = petstore.NewAPI(t)
-	validator = NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
-	validator.spec = doc
-	sw = doc.Spec()
-	pa = sw.Paths.Paths["/pets"]
-	rp = pa.Post.Responses.StatusCodeResponses[200]
-	rp.Schema = spec.ArrayProperty(nil)
-	pa.Post.Responses.StatusCodeResponses[200] = rp
-	res = validator.validateItems()
-	assert.NotEmpty(t, res.Errors)
+	}
 }
 
+func TestValidateCircularAncestry(t *testing.T) {}
+
 func TestValidateUniqueSecurityScopes(t *testing.T) {
 }
 
@@ -112,6 +45,12 @@ func TestValidateUniqueScopesSecurityDefinitions(t *testing.T) {
 func TestValidateReferenced(t *testing.T) {
 }
 
+func TestValidateReferencesValid(t *testing.T) {
+}
+
+func TestValidateDefaultValueAgainstSchema(t *testing.T) {
+}
+
 func TestValidateRequiredDefinitions(t *testing.T) {
 	doc, api := petstore.NewAPI(t)
 	validator := NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
@@ -213,8 +152,97 @@ func TestValidateParameters(t *testing.T) {
 	assert.Contains(t, res.Errors[0].Error(), "has no parameter definition")
 }
 
-func TestValidateReferencesValid(t *testing.T) {
-}
+func TestValidateItems(t *testing.T) {
+	doc, api := petstore.NewAPI(t)
+	validator := NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
+	validator.spec = doc
+	res := validator.validateItems()
+	assert.Empty(t, res.Errors)
 
-func TestValidateDefaultValueAgainstSchema(t *testing.T) {
+	// in operation parameters
+	sw := doc.Spec()
+	sw.Paths.Paths["/pets"].Get.Parameters[0].Type = "array"
+	res = validator.validateItems()
+	assert.NotEmpty(t, res.Errors)
+
+	sw.Paths.Paths["/pets"].Get.Parameters[0].Items = spec.NewItems().Typed("string", "")
+	res = validator.validateItems()
+	assert.Empty(t, res.Errors)
+
+	sw.Paths.Paths["/pets"].Get.Parameters[0].Items = spec.NewItems().Typed("array", "")
+	res = validator.validateItems()
+	assert.NotEmpty(t, res.Errors)
+
+	sw.Paths.Paths["/pets"].Get.Parameters[0].Items.Items = spec.NewItems().Typed("string", "")
+	res = validator.validateItems()
+	assert.Empty(t, res.Errors)
+
+	// in global parameters
+	sw.Parameters = make(map[string]spec.Parameter)
+	sw.Parameters["other"] = *spec.SimpleArrayParam("other", "array", "csv")
+	res = validator.validateItems()
+	assert.Empty(t, res.Errors)
+
+	pp := spec.SimpleArrayParam("other", "array", "")
+	pp.Items = nil
+	sw.Parameters["other"] = *pp
+	res = validator.validateItems()
+	assert.NotEmpty(t, res.Errors)
+
+	// in shared path object parameters
+	doc, api = petstore.NewAPI(t)
+	validator = NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
+	validator.spec = doc
+	sw = doc.Spec()
+
+	pa := sw.Paths.Paths["/pets"]
+	pa.Parameters = []spec.Parameter{*spec.SimpleArrayParam("another", "array", "csv")}
+	sw.Paths.Paths["/pets"] = pa
+	res = validator.validateItems()
+	assert.Empty(t, res.Errors)
+
+	pa = sw.Paths.Paths["/pets"]
+	pp = spec.SimpleArrayParam("other", "array", "")
+	pp.Items = nil
+	pa.Parameters = []spec.Parameter{*pp}
+	sw.Paths.Paths["/pets"] = pa
+	res = validator.validateItems()
+	assert.NotEmpty(t, res.Errors)
+
+	// in body param schema
+	doc, api = petstore.NewAPI(t)
+	validator = NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
+	validator.spec = doc
+	sw = doc.Spec()
+	pa = sw.Paths.Paths["/pets"]
+	pa.Post.Parameters[0].Schema = spec.ArrayProperty(nil)
+	res = validator.validateItems()
+	assert.NotEmpty(t, res.Errors)
+
+	// in response headers
+	doc, api = petstore.NewAPI(t)
+	validator = NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
+	validator.spec = doc
+	sw = doc.Spec()
+	pa = sw.Paths.Paths["/pets"]
+	rp := pa.Post.Responses.StatusCodeResponses[200]
+	var hdr spec.Header
+	hdr.Type = "array"
+	rp.Headers = make(map[string]spec.Header)
+	rp.Headers["X-YADA"] = hdr
+	pa.Post.Responses.StatusCodeResponses[200] = rp
+	res = validator.validateItems()
+	assert.NotEmpty(t, res.Errors)
+
+	// in response schema
+	doc, api = petstore.NewAPI(t)
+	validator = NewSpecValidator(spec.MustLoadSwagger20Schema(), api.Formats())
+	validator.spec = doc
+	sw = doc.Spec()
+	pa = sw.Paths.Paths["/pets"]
+	rp = pa.Post.Responses.StatusCodeResponses[200]
+	rp.Schema = spec.ArrayProperty(nil)
+	pa.Post.Responses.StatusCodeResponses[200] = rp
+	res = validator.validateItems()
+	assert.NotEmpty(t, res.Errors)
 }
