diff --git a/fixtures/bugs/1596/.gitignore b/fixtures/bugs/1596/.gitignore
new file mode 100644
index 00000000..1e16265b
--- /dev/null
+++ b/fixtures/bugs/1596/.gitignore
@@ -0,0 +1,3 @@
+gen-*
+!gen-fixtures.sh
+*.log
diff --git a/fixtures/bugs/1596/fixture-1596.yaml b/fixtures/bugs/1596/fixture-1596.yaml
new file mode 100644
index 00000000..bf7af904
--- /dev/null
+++ b/fixtures/bugs/1596/fixture-1596.yaml
@@ -0,0 +1,21 @@
+swagger: '2.0'
+
+info:
+  version: 1.0.0
+  title: MyApp
+  description: (Description pending)
+  
+paths:
+  /hello:
+    get:
+      summary: Simple Hello World endpoint
+      tags: ['Hello']
+      responses:
+        '200':
+          description: service is saying hello
+          schema:
+            $ref: '#/definitions/somethingEndingInWindows'
+
+definitions:
+  somethingEndingInWindows:
+    type: object
diff --git a/fixtures/bugs/1596/gen-fixtures.sh b/fixtures/bugs/1596/gen-fixtures.sh
new file mode 100755
index 00000000..70fb12b3
--- /dev/null
+++ b/fixtures/bugs/1596/gen-fixtures.sh
@@ -0,0 +1,48 @@
+#! /bin/bash 
+if [[ ${1} == "--clean" ]] ; then
+    clean=1
+fi
+# A small utility to build fixture servers
+# Fixtures with models only
+testcases="${testcases} fixture-1596.yaml"
+# For this, skip --with-expand (contains polymorphic models):
+#testcases="${testcases} ../../codegen/todolist.models.yml"
+for opts in "--with-flatten=minimal" "--with-flatten=full" "--with-expand" ;do
+	for testcase in ${testcases} ; do
+	    target=./gen-`basename ${testcase%.*}`
+        case ${opts} in
+            "--with-flatten=minimal") 
+                target=${target}"-minimal"
+                ;;
+            "--with-flatten=full") 
+                target=${target}"-full"
+                ;;
+            "--with-expand") 
+                target=${target}"-expand"
+                ;;
+        esac
+	    spec=./${testcase}
+	    serverName="codegensrv"
+	    rm -rf ${target}
+	    mkdir ${target}
+	    echo "Model generation for ${spec} with ${opts}"
+	    swagger generate server --skip-validation ${opts} --spec ${spec} --target ${target} --name=${serverName} --output=${testcase%.*}.log
+	    # 1>x.log 2>&1
+	    #
+	    if [[ $? != 0 ]] ; then
+	        echo "Generation failed for ${spec}"
+	        exit 1
+	    fi
+	    echo "${spec}: Generation OK"
+	    (cd ${target}/cmd/${serverName}-server; go build)
+	    if [[ $? != 0 ]] ; then
+	        echo "Build failed for ${spec}"
+	        exit 1
+	    fi
+	    echo "${spec}: Build OK"
+	    if [[ -n ${clean} ]] ; then 
+	        rm -rf ${target}
+	    fi
+	done
+done
+exit
diff --git a/generator/shared.go b/generator/shared.go
index cc712f34..6c02e3a0 100644
--- a/generator/shared.go
+++ b/generator/shared.go
@@ -48,6 +48,7 @@ type LanguageOpts struct {
 	reservedWordsSet map[string]struct{}
 	initialized      bool
 	formatFunc       func(string, []byte) ([]byte, error)
+	fileNameFunc     func(string) string
 }
 
 // Init the language option
@@ -78,6 +79,14 @@ func (l *LanguageOpts) MangleVarName(name string) string {
 	return nm + "Var"
 }
 
+// MangleFileName makes sure a file name gets a safe name
+func (l *LanguageOpts) MangleFileName(name string) string {
+	if l.fileNameFunc != nil {
+		return l.fileNameFunc(name)
+	}
+	return swag.ToFileName(name)
+}
+
 // FormatContent formats a file with a language specific formatter
 func (l *LanguageOpts) FormatContent(name string, content []byte) ([]byte, error) {
 	if l.formatFunc != nil {
@@ -97,6 +106,49 @@ var golang = GoLangOpts()
 
 // GoLangOpts for rendering items as golang code
 func GoLangOpts() *LanguageOpts {
+	var goOtherReservedSuffixes = map[string]bool{
+		// see:
+		// https://golang.org/src/go/build/syslist.go
+		// https://golang.org/doc/install/source#environment
+
+		// goos
+		"android":   true,
+		"darwin":    true,
+		"dragonfly": true,
+		"freebsd":   true,
+		"linux":     true,
+		"nacl":      true,
+		"netbsd":    true,
+		"openbsd":   true,
+		"plan9":     true,
+		"solaris":   true,
+		"windows":   true,
+		"zos":       true,
+
+		// arch
+		"386":         true,
+		"amd64":       true,
+		"amd64p32":    true,
+		"arm":         true,
+		"armbe":       true,
+		"arm64":       true,
+		"arm64be":     true,
+		"mips":        true,
+		"mipsle":      true,
+		"mips64":      true,
+		"mips64le":    true,
+		"mips64p32":   true,
+		"mips64p32le": true,
+		"ppc":         true,
+		"s390":        true,
+		"s390x":       true,
+		"sparc":       true,
+		"sparc64":     true,
+
+		// other reserved suffixes
+		"test": true,
+	}
+
 	opts := new(LanguageOpts)
 	opts.ReservedWords = []string{
 		"break", "default", "func", "interface", "select",
@@ -113,6 +165,19 @@ func GoLangOpts() *LanguageOpts {
 		opts.Comments = true
 		return imports.Process(ffn, content, opts)
 	}
+	opts.fileNameFunc = func(name string) string {
+		// whenever a generated file name ends with a suffix
+		// that is meaningful to go build, adds a "swagger"
+		// suffix
+		parts := strings.Split(swag.ToFileName(name), "_")
+		if goOtherReservedSuffixes[parts[len(parts)-1]] {
+			// file name ending with a reserved arch or os name
+			// are appended an innocuous suffix "swagger"
+			parts = append(parts, "swagger")
+		}
+		return strings.Join(parts, "_")
+	}
+
 	opts.BaseImportFunc = func(tgt string) string {
 		// On Windows, filepath.Abs("") behaves differently than on Unix.
 		// Windows: yields an error, since Abs() does not know the volume.
diff --git a/generator/shared_test.go b/generator/shared_test.go
index d7fd918d..65ac145a 100644
--- a/generator/shared_test.go
+++ b/generator/shared_test.go
@@ -439,3 +439,19 @@ func TestShared_Issue1429(t *testing.T) {
 	err = analysis.Flatten(*opts.FlattenOpts)
 	assert.NoError(t, err)
 }
+
+func TestShared_MangleFileName(t *testing.T) {
+	// standard : swag.ToFileName()
+	o := LanguageOpts{}
+	o.Init()
+	res := o.MangleFileName("aFileEndingInOsNameWindows")
+	t.Log(res)
+
+	// golang specific
+	res = golang.MangleFileName("aFileEndingInOsNameWindows")
+	t.Log(res)
+	res = golang.MangleFileName("aFileEndingInOsNameWindowsAmd64")
+	t.Log(res)
+	res = golang.MangleFileName("aFileEndingInTest")
+	t.Log(res)
+}
diff --git a/generator/template_repo.go b/generator/template_repo.go
index 34b2eead..bd5cc5b8 100644
--- a/generator/template_repo.go
+++ b/generator/template_repo.go
@@ -28,7 +28,7 @@ var FuncMap template.FuncMap = map[string]interface{}{
 	"camelize":  swag.ToJSONName,
 	"varname":   golang.MangleVarName,
 	"humanize":  swag.ToHumanNameLower,
-	"snakize":   swag.ToFileName,
+	"snakize":   golang.MangleFileName,
 	"dasherize": swag.ToCommandName,
 	"pluralizeFirstWord": func(arg string) string {
 		sentence := strings.Split(arg, " ")
diff --git a/generator/template_repo_test.go b/generator/template_repo_test.go
index be1fc66a..0ba7bf43 100644
--- a/generator/template_repo_test.go
+++ b/generator/template_repo_test.go
@@ -43,6 +43,9 @@ PadSurround1={{ padSurround "padme" "-" 3 12}}
 PadSurround2={{ padSurround "padme" "-" 0 12}}
 Json={{ json .DefaultImports }}
 PrettyJson={{ prettyjson . }}
+Snakize1={{ snakize "endingInOsNameLinux" }}
+Snakize2={{ snakize "endingInArchNameLinuxAmd64" }}
+Snakize3={{ snakize "endingInTest" }}
 `
 )
 
@@ -399,6 +402,9 @@ func TestTemplates_FuncMap(t *testing.T) {
 					assert.Contains(t, rendered.String(), "PadSurround2=padme,-,-,-,-,-,-,-,-,-,-,-\n")
 					assert.Contains(t, rendered.String(), "Json=[\"github.com/go-openapi/errors\",\"github.com/go-openapi/runtime\",\"github.com/go-openapi/swag\",\"github.com/go-openapi/validate\"]")
 					assert.Contains(t, rendered.String(), "\"TargetImportPath\": \"github.com/go-swagger/go-swagger/generator\"")
+					assert.Contains(t, rendered.String(), "Snakize1=ending_in_os_name_linux_swagger\n")
+					assert.Contains(t, rendered.String(), "Snakize2=ending_in_arch_name_linux_amd64_swagger\n")
+					assert.Contains(t, rendered.String(), "Snakize3=ending_in_test_swagger\n")
 					//fmt.Println(rendered.String())
 				}
 			}
