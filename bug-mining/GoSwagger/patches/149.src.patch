diff --git a/cmd/swagger/commands/version_number.go b/cmd/swagger/commands/version_number.go
index 96949110..0194fad7 100644
--- a/cmd/swagger/commands/version_number.go
+++ b/cmd/swagger/commands/version_number.go
@@ -1,6 +1,6 @@
 package commands
 
 func init() {
-  Version = "0.4.0-55-g538e658"
+  Version = "0.4.0-56-g546e54d"
 }
 
diff --git a/fixtures/codegen/todolist.models.yml b/fixtures/codegen/todolist.models.yml
index da13bac3..1546e24f 100644
--- a/fixtures/codegen/todolist.models.yml
+++ b/fixtures/codegen/todolist.models.yml
@@ -23,11 +23,22 @@ paths:
       responses:
         default:
           description: Generic Out
+
 definitions:
+  flag:
+    type: string
+    minLength: 1
+    maxLength: 10
+
+  flags_list:
+    type: array
+    items:
+      $ref: "#/definitions/flag"
+
   ImageTar:
     type: string
     format: binary
-    
+
   Tag:
     type: "object"
     required:
diff --git a/generator/bindata.go b/generator/bindata.go
index 9b1ae095..13861c08 100644
--- a/generator/bindata.go
+++ b/generator/bindata.go
@@ -195,7 +195,7 @@ func templatesClientResponseGotmpl() (*asset, error) {
 	return a, nil
 }
 
-var _templatesDocstringGotmpl = []byte("\x1f\x8b\x08\x00\x00\x09\x6e\x88\x00\xff\xaa\xae\x4e\x49\x4d\xcb\xcc\x4b\x55\x50\x4a\xc9\x4f\x2e\x2e\x29\xca\xcc\x4b\x57\xaa\xad\xad\xae\x56\xc8\x4c\x53\xd0\x0b\xc9\x2c\xc9\x49\x55\x00\x73\x91\xd9\x20\x29\x97\xd4\xe2\xe4\xa2\xcc\x82\x92\xcc\xfc\x3c\xa0\x20\x17\x17\x48\x09\xaa\x18\x50\x24\x35\x2f\x05\xca\xc8\x29\x4e\x45\xd7\x06\x31\x16\x53\x0f\x48\x29\x98\x55\x90\x58\x9c\x9c\x98\x93\x59\x95\xaa\xa0\xe7\x97\x98\x0b\x12\x54\x00\x8a\x66\x94\xe6\x26\xe6\x21\x0b\xc2\xed\x01\xba\x01\xc8\x00\xd2\x80\x00\x00\x00\xff\xff\xd8\xea\xca\x52\xd4\x00\x00\x00")
+var _templatesDocstringGotmpl = []byte("\x1f\x8b\x08\x00\x00\x09\x6e\x88\x00\xff\xaa\xae\x4e\x49\x4d\xcb\xcc\x4b\x55\x50\x4a\xc9\x4f\x2e\x2e\x29\xca\xcc\x4b\x57\xaa\xad\xad\xae\x56\xc8\x4c\x53\xd0\x0b\xc9\x2c\xc9\x49\x55\x00\x73\x91\xd9\x20\x29\x97\xd4\xe2\xe4\xa2\xcc\x82\x92\xcc\xfc\x3c\xa0\x20\x17\x17\x48\x09\xaa\x18\x50\x24\x35\x2f\x05\xca\xc8\x29\x4e\x45\xd7\x06\x31\x16\x53\x0f\x48\x29\x98\x95\x51\x9a\x9b\x98\x97\x59\x95\xaa\xa0\xe7\x97\x98\x9b\x8a\x6c\x22\xd0\x36\x20\x03\x48\x03\x02\x00\x00\xff\xff\x32\x9e\xda\x0e\xbe\x00\x00\x00")
 
 func templatesDocstringGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -210,7 +210,7 @@ func templatesDocstringGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/docstring.gotmpl", size: 212, mode: os.FileMode(420), modTime: time.Unix(1451156780, 0)}
+	info := bindataFileInfo{name: "templates/docstring.gotmpl", size: 190, mode: os.FileMode(420), modTime: time.Unix(1457279147, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -235,7 +235,7 @@ func templatesHeaderGotmpl() (*asset, error) {
 	return a, nil
 }
 
-var _templatesModelGotmpl = []byte("\x1f\x8b\x08\x00\x00\x09\x6e\x88\x00\xff\xd4\x90\xbd\x4e\x03\x31\x10\x84\x7b\x3f\xc5\xea\xca\x14\xbe\x9e\x2e\x88\x20\xa5\x41\x08\x78\x81\xd5\x79\xb9\xb3\xe4\x3f\xbc\x2b\x11\x88\xfc\xee\xf8\x72\xe4\x7e\x90\xa0\xa7\xb3\x77\x66\x67\x47\xdf\xf9\x0c\x42\x3e\x39\x14\x82\x66\x20\x34\x94\x1b\xd0\x50\x8a\x52\x55\xb2\xaf\x40\x6f\xa0\x1f\xd0\x57\x75\x9f\xec\x13\x71\x8a\x81\xa9\xa9\x86\xb6\x85\xfd\xe3\xf1\x3a\x01\xcb\x20\x03\x41\xbe\xfe\x25\x02\x86\xd1\x01\x1d\x3a\xa7\x6b\x18\xb9\x3a\x2e\x65\x8a\xd5\x47\x3e\x9c\x52\xcc\x42\x66\xcc\xda\xd5\xe9\x74\xa6\x14\xd8\x74\x32\xb1\x63\xc9\x36\xf4\x53\xad\x69\x3b\x44\x19\x13\x6e\x91\xe9\xe5\x23\x8d\x4b\x8a\xdf\xb1\xef\x29\xdf\xf8\x68\xc8\xc1\x2a\x6e\xb9\x3c\x7b\x8c\xe5\x2e\x5b\x6f\x03\x4a\xcc\xf0\xe3\xb4\xbe\x5b\xab\xf7\x96\x9c\xf9\x4e\x09\x9b\x87\xda\xb5\xcb\x7b\x53\x99\xbb\x81\x3c\xae\x30\x66\x0c\x3d\x81\x3e\x9c\x24\xe3\xf3\x45\xe4\x5f\x40\xa8\x0b\x89\x84\x5c\xa1\xd9\x4f\xfa\x27\x4c\x66\x14\x7f\x92\x58\xec\x5f\x01\x00\x00\xff\xff\x7a\x82\x53\x94\x75\x02\x00\x00")
+var _templatesModelGotmpl = []byte("\x1f\x8b\x08\x00\x00\x09\x6e\x88\x00\xff\xd4\x90\x3f\x4f\xc3\x30\x10\xc5\x77\x7f\x8a\x53\xc6\x0e\xc9\xce\x56\x44\x91\xba\x20\x04\x7c\x81\x53\x7c\x24\x96\xfc\x0f\xdf\x49\x14\x2a\x7f\x77\xec\xa6\x69\x92\x01\x76\xb6\xf3\xbd\xe7\x9f\x9f\xdf\xf9\x0c\x42\x2e\x5a\x14\x82\x66\x24\xd4\x94\x1a\x68\x21\x67\xa5\x8a\x64\xde\x81\x3e\xa0\x7d\x42\x57\xd4\x7d\x34\x2f\xc4\x31\x78\xa6\xa6\x18\xba\x0e\xf6\xcf\xc7\x79\x03\x86\x41\x46\x82\x34\x9f\x25\x00\xfa\xea\x80\x1e\xad\x6d\x0b\x8c\x6c\x59\xe7\x3c\x61\xdb\x23\x1f\x4e\x31\x24\x21\x5d\x59\xbb\xb2\x8d\xc8\xc5\x6a\xbe\xe9\xfa\x60\xce\xb0\x49\xa7\x43\xcf\x92\x8c\x1f\xa6\x80\x13\xc7\x07\xa9\xac\x7b\x64\x7a\xfb\x8a\xf5\x92\xe2\x4f\x1c\x06\x4a\x77\x2e\x68\xb2\x15\x31\xe3\x96\x0c\x37\x8f\x36\xdc\x27\xe3\x8c\x47\x09\x69\xed\xbd\xcc\x0f\x6b\xf5\xd1\x90\xd5\x57\x8a\xdf\x0c\x6a\xd7\x2d\xf3\x26\x32\xf7\x23\x39\x5c\x15\x9a\xd0\x0f\xe5\x7f\x87\x93\x24\x7c\xbd\x88\xfc\x4b\x25\xea\x5f\x76\x72\xab\xe2\xcf\x26\x16\xfb\x4f\x00\x00\x00\xff\xff\xab\x83\x97\xf5\x7f\x02\x00\x00")
 
 func templatesModelGotmplBytes() ([]byte, error) {
 	return bindataRead(
@@ -250,7 +250,7 @@ func templatesModelGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/model.gotmpl", size: 629, mode: os.FileMode(420), modTime: time.Unix(1457243576, 0)}
+	info := bindataFileInfo{name: "templates/model.gotmpl", size: 639, mode: os.FileMode(420), modTime: time.Unix(1457278589, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
@@ -350,7 +350,7 @@ func templatesSchemavalidatorGotmpl() (*asset, error) {
 		return nil, err
 	}
 
-	info := bindataFileInfo{name: "templates/schemavalidator.gotmpl", size: 19494, mode: os.FileMode(420), modTime: time.Unix(1457211961, 0)}
+	info := bindataFileInfo{name: "templates/schemavalidator.gotmpl", size: 19494, mode: os.FileMode(420), modTime: time.Unix(1457278070, 0)}
 	a := &asset{bytes: bytes, info: info}
 	return a, nil
 }
diff --git a/generator/enum_test.go b/generator/enum_test.go
index 3e2b58e2..41dc1875 100644
--- a/generator/enum_test.go
+++ b/generator/enum_test.go
@@ -404,7 +404,6 @@ func TestEnum_Issue352(t *testing.T) {
 				if assert.NoError(t, err) {
 					res := string(ff)
 					assertInCode(t, ", value SlpActionEnum", res)
-					fmt.Println(res)
 				}
 			}
 		}
diff --git a/generator/model_test.go b/generator/model_test.go
index c1b8e354..c0944bd8 100644
--- a/generator/model_test.go
+++ b/generator/model_test.go
@@ -99,7 +99,7 @@ The description of the property
 
 	gmp.Description = ""
 	gmp.Name = "theModel"
-	expected = `TheModel the model
+	expected = `the model
 `
 	tt.assertRender(gmp, expected)
 }
@@ -1408,7 +1408,7 @@ func TestGenModel_Issue222(t *testing.T) {
 				if assert.NoError(t, err) {
 					res := string(ct)
 					assertInCode(t, "Price) Validate(formats strfmt.Registry) error", res)
-					assertInCode(t, "Currency *Currency `json:\"currency,omitempty\"`", res)
+					assertInCode(t, "Currency Currency `json:\"currency,omitempty\"`", res)
 					assertInCode(t, "m.Currency.Validate(formats); err != nil", res)
 				}
 			}
@@ -1543,3 +1543,23 @@ func TestGenModel_Issue340(t *testing.T) {
 		}
 	}
 }
+
+func TestGenModel_Issue381(t *testing.T) {
+	specDoc, err := spec.Load("../fixtures/codegen/todolist.models.yml")
+	if assert.NoError(t, err) {
+		definitions := specDoc.Spec().Definitions
+		k := "flags_list"
+		genModel, err := makeGenDefinition(k, "models", definitions[k], specDoc)
+		if assert.NoError(t, err) {
+			buf := bytes.NewBuffer(nil)
+			err := modelTemplate.Execute(buf, genModel)
+			if assert.NoError(t, err) {
+				ct, err := formatGoFile("flags_list.go", buf.Bytes())
+				if assert.NoError(t, err) {
+					res := string(ct)
+					assertNotInCode(t, "m[i] != nil", res)
+				}
+			}
+		}
+	}
+}
diff --git a/generator/templates/docstring.gotmpl b/generator/templates/docstring.gotmpl
index c9e1c553..68397643 100644
--- a/generator/templates/docstring.gotmpl
+++ b/generator/templates/docstring.gotmpl
@@ -1,4 +1,4 @@
 {{define "docstring"}}{{ if .Title }}{{ .Title }}{{ if .Description }}
 
-{{ .Description }}{{ end }}{{ else if .Description}}{{ .Description }}{{ else }}{{ pascalize .Name }} {{ humanize .Name }}{{ end }}
+{{ .Description }}{{ end }}{{ else if .Description}}{{ .Description }}{{ else }}{{ humanize .Name }}{{ end }}
 {{end}}
diff --git a/generator/templates/model.gotmpl b/generator/templates/model.gotmpl
index a0da8f13..4756d445 100644
--- a/generator/templates/model.gotmpl
+++ b/generator/templates/model.gotmpl
@@ -1,6 +1,6 @@
 {{ template "header" . }}
 
-{{ if eq .Name "ApiResponse" }}// APIResponse is the response to an API call.{{ else }}{{ if .IsExported }}/*{{ .Name }} {{ template "docstring" . }}{{ if not .IsBaseType }}
+{{ if eq .Name "ApiResponse" }}// APIResponse is the response to an API call.{{ else }}{{ if .IsExported }}/*{{ pascalize .Name }} {{ template "docstring" . }}{{ if not .IsBaseType }}
 swagger:model {{ .Name }}{{ else }}
 swagger:discriminator {{ .Name }} {{ .DiscriminatorField }}{{ end }}{{ end }}
 */{{ end }}
diff --git a/generator/types.go b/generator/types.go
index 1b8d96b1..d2a6e78e 100644
--- a/generator/types.go
+++ b/generator/types.go
@@ -29,6 +29,18 @@ import (
 // 	"swagger.*": "github.com/go-swagger/go-swagger/httpkit",
 // }
 
+const (
+	iface   = "interface{}"
+	array   = "array"
+	file    = "file"
+	number  = "number"
+	integer = "integer"
+	boolean = "boolean"
+	str     = "string"
+	object  = "object"
+	binary  = "binary"
+)
+
 var zeroes = map[string]string{
 	"string":            "\"\"",
 	"int8":              "0",
@@ -160,7 +172,7 @@ func simpleResolvedType(tn, fmt string, items *spec.Items) (result resolvedType)
 			result.GoType = tpe
 			result.IsPrimitive = true
 			_, result.IsCustomFormatter = customFormatters[tpe]
-			result.IsStream = fmt == "binary"
+			result.IsStream = fmt == binary
 			return
 		}
 	}
@@ -172,13 +184,13 @@ func simpleResolvedType(tn, fmt string, items *spec.Items) (result resolvedType)
 		return
 	}
 
-	if tn == "array" {
+	if tn == array {
 		result.IsArray = true
 		result.IsPrimitive = false
 		result.IsCustomFormatter = false
 		result.IsNullable = false
 		if items == nil {
-			result.GoType = "[]interface{}"
+			result.GoType = "[]" + iface
 			return
 		}
 		res := simpleResolvedType(items.Type, items.Format, items.Items)
@@ -194,9 +206,10 @@ func typeForHeader(header spec.Header) resolvedType {
 	return simpleResolvedType(header.Type, header.Format, header.Items)
 }
 
-func typeForParameter(param spec.Parameter) string {
-	return resolveSimpleType(param.Type, param.Format, param.Items)
-}
+//
+// func typeForParameter(param spec.Parameter) string {
+// 	return resolveSimpleType(param.Type, param.Format, param.Items)
+// }
 
 func resolveSimpleType(tn, fmt string, items *spec.Items) string {
 	if fmt != "" {
@@ -257,9 +270,9 @@ func (t *typeResolver) resolveSchemaRef(schema *spec.Schema, isRequired bool) (r
 		if gn, ok := ref.Extensions["x-go-name"]; ok {
 			tn = gn.(string)
 			nm = tn
-		} else {
+		} /*else {
 			tn = swag.ToGoName(nm)
-		}
+		}*/
 
 		res, er := t.ResolveSchema(ref, false, isRequired)
 		if er != nil {
@@ -283,14 +296,14 @@ func (t *typeResolver) resolveFormat(schema *spec.Schema, isRequired bool) (retu
 		schFmt := strings.Replace(schema.Format, "-", "", -1)
 		if tpe, ok := typeMapping[schFmt]; ok {
 			returns = true
-			result.SwaggerType = "string"
+			result.SwaggerType = str
 			if len(schema.Type) > 0 {
 				result.SwaggerType = schema.Type[0]
 			}
 			result.SwaggerFormat = schema.Format
 			result.GoType = tpe
-			result.IsPrimitive = schFmt != "binary"
-			result.IsStream = schFmt == "binary"
+			result.IsPrimitive = schFmt != binary
+			result.IsStream = schFmt == binary
 			result.IsNullable = !isRequired || t.IsNullable(schema)
 			_, result.IsCustomFormatter = customFormatters[tpe]
 			return
@@ -311,7 +324,7 @@ func (t *typeResolver) checkIsNullable(extension string, schema *spec.Schema) bo
 
 func (t *typeResolver) firstType(schema *spec.Schema) string {
 	if len(schema.Type) == 0 || schema.Type[0] == "" {
-		return "object"
+		return object
 	}
 	return schema.Type[0]
 }
@@ -323,14 +336,14 @@ func (t *typeResolver) resolveArray(schema *spec.Schema, isAnonymous, isRequired
 		result.HasAdditionalItems = (schema.AdditionalItems.Allows || schema.AdditionalItems.Schema != nil)
 	}
 	if schema.Items == nil {
-		result.GoType = "[]interface{}"
-		result.SwaggerType = "array"
+		result.GoType = "[]" + iface
+		result.SwaggerType = array
 		return
 	}
 	if len(schema.Items.Schemas) > 0 {
 		result.IsArray = false
 		result.IsTuple = true
-		result.SwaggerType = "array"
+		result.SwaggerType = array
 		return
 	}
 	rt, er := t.ResolveSchema(schema.Items.Schema, true, true)
@@ -339,10 +352,10 @@ func (t *typeResolver) resolveArray(schema *spec.Schema, isAnonymous, isRequired
 		return
 	}
 	result.GoType = "[]" + rt.GoType
-	if rt.IsNullable && !rt.HasDiscriminator && !strings.HasPrefix(rt.GoType, "*") {
+	if (rt.IsNullable || rt.IsAliased) && !rt.HasDiscriminator && !strings.HasPrefix(rt.GoType, "*") {
 		result.GoType = "[]*" + rt.GoType
 	}
-	result.SwaggerType = "array"
+	result.SwaggerType = array
 	return
 }
 
@@ -361,7 +374,7 @@ func (t *typeResolver) resolveObject(schema *spec.Schema, isAnonymous bool) (res
 
 	result.IsBaseType = schema.Discriminator != ""
 	if !isAnonymous {
-		result.SwaggerType = "object"
+		result.SwaggerType = object
 		result.GoType = t.goTypeName(t.ModelName)
 	}
 	if len(schema.AllOf) > 0 {
@@ -374,7 +387,7 @@ func (t *typeResolver) resolveObject(schema *spec.Schema, isAnonymous bool) (res
 			}
 		}
 		result.IsNullable = isNullable
-		result.SwaggerType = "object"
+		result.SwaggerType = object
 		return
 	}
 
@@ -395,7 +408,7 @@ func (t *typeResolver) resolveObject(schema *spec.Schema, isAnonymous bool) (res
 			return
 		}
 		result.IsMap = !result.IsComplexObject
-		result.SwaggerType = "object"
+		result.SwaggerType = object
 		result.IsNullable = false
 		result.GoType = "map[string]" + et.GoType
 		if et.IsNullable && et.IsComplexObject && !et.IsBaseType {
@@ -407,10 +420,10 @@ func (t *typeResolver) resolveObject(schema *spec.Schema, isAnonymous bool) (res
 	if len(schema.Properties) > 0 {
 		return
 	}
-	result.GoType = "interface{}"
+	result.GoType = iface
 	result.IsMap = true
 	result.IsMap = !result.IsComplexObject
-	result.SwaggerType = "object"
+	result.SwaggerType = object
 	result.IsNullable = false
 	result.IsInterface = len(schema.Properties) == 0
 	return
@@ -431,7 +444,7 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 	// fmt.Println("resolver", string(tt))
 	if schema == nil {
 		result.IsInterface = true
-		result.GoType = "interface{}"
+		result.GoType = iface
 		return
 	}
 
@@ -442,7 +455,7 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 			result.IsMap = false
 			result.IsComplexObject = true
 		}
-		result.IsNullable = true
+		// result.IsNullable = true //|| !result.IsPrimitive
 		return
 	}
 
@@ -454,28 +467,28 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 	result.IsNullable = !isRequired || t.isNullable(schema)
 	tpe := t.firstType(schema)
 	switch tpe {
-	case "array":
+	case array:
 		return t.resolveArray(schema, isAnonymous, result.IsNullable)
 
-	case "file", "number", "integer", "boolean":
+	case file, number, integer, boolean:
 		result.GoType = typeMapping[tpe]
 		result.SwaggerType = tpe
-		if tpe != "file" {
+		if tpe != file {
 			result.IsPrimitive = true
 			result.IsCustomFormatter = false
 			//bothNil := schema.Minimum == nil && schema.Maximum == nil
 			isMin := schema.Minimum != nil && *schema.Minimum > 0
 			isMax := schema.Minimum == nil && (schema.Maximum != nil && *schema.Maximum < 0) // || *schema.Minimum < 0) &&
 			isMinMax := (schema.Minimum != nil && schema.Maximum != nil && *schema.Minimum < 0 && *schema.Minimum < *schema.Maximum)
-			if tpe != "boolean" && (isMin || isMax || isMinMax) {
+			if tpe != boolean && (isMin || isMax || isMinMax) {
 				result.IsNullable = false
 			}
 		}
 		return
 
-	case "string":
-		result.GoType = "string"
-		result.SwaggerType = "string"
+	case str:
+		result.GoType = str
+		result.SwaggerType = str
 		if !isAnonymous && t.ModelName != "" {
 			result.AliasedType = result.GoType
 			result.IsAliased = true
@@ -494,10 +507,10 @@ func (t *typeResolver) ResolveSchema(schema *spec.Schema, isAnonymous, isRequire
 		}
 		return
 
-	case "object":
-		rt, err := t.resolveObject(schema, isAnonymous)
-		if err != nil {
-			return resolvedType{}, err
+	case object:
+		rt, err2 := t.resolveObject(schema, isAnonymous)
+		if err2 != nil {
+			return resolvedType{}, err2
 		}
 		rt.HasDiscriminator = schema.Discriminator != ""
 		return rt, nil
