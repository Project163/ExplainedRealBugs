diff --git a/README.md b/README.md
index de088b2b..78ca5f44 100644
--- a/README.md
+++ b/README.md
@@ -6,8 +6,6 @@ Swagger 2.0 [![Circle CI](https://circleci.com/gh/go-swagger/go-swagger/tree/mas
 Development of this toolkit is sponsored by VMware:  
 [![VMWare](https://avatars2.githubusercontent.com/u/473334?v=3&s=200)](https://vmware.github.io)  
 
-This API is not stable yet, when it is stable it will be distributed over gopkg.in
-
 There is a code coverage report available in the artifacts section of a build. Unfortunately using coveralls made the
 build unstable.
 
@@ -23,7 +21,6 @@ Swagger helps companies like Apigee, Getty Images, Intuit, LivingSocial, McKesso
 Docs
 ----
 
-
 https://goswagger.io
 
 Install or update:
@@ -48,11 +45,6 @@ To generate a [swagger spec document for a go application](http://goswagger.io/g
 
 		swagger generate spec -o ./swagger.json
 
-Much improved documentation is in the works and will actually explain how to use this tool in much more depth.
-To learn about which annotations are available and how to use them for generating a spec from any go application
-(generating a spec is not opinionated), you can take a look at the files used for [testing the parser](https://github.com/go-swagger/go-swagger/tree/master/fixtures/goparsing/classification).
-
-
 There are several other sub commands available for the generate command
 
 		Sub command | Description
@@ -87,7 +79,6 @@ For a V1 I want to have this feature set completed:
       - [x] definition's ancestor can't be a descendant of the same model (Error)
       - [x] each api path should be non-verbatim (account for path param names) unique per method (Error)
       - [ ] each security reference should contain only unique scopes (Warning)
-      - [ ] each security scope in a security definition should be unique (Warning)
       - [x] each path parameter should correspond to a parameter placeholder and vice versa (Error)
       - [x] path parameter declarations do not allow empty names _(`/path/{}` is not valid)_ (Error)
       - [x] each definition property listed in the required array must be defined in the properties of the model (Error)
diff --git a/fixtures/analysis/references.yml b/fixtures/analysis/references.yml
new file mode 100644
index 00000000..2bffbc1e
--- /dev/null
+++ b/fixtures/analysis/references.yml
@@ -0,0 +1,78 @@
+---
+swagger: "2.0"
+info:
+  version: "0.1.0"
+  title: reference analysis
+
+parameters:
+  idParam:
+    name: id
+    in: path
+    type: integer
+    format: int32
+  limitParam:
+    name: limit
+    in: query
+    type: integer
+    format: int32
+    required: false
+
+responses:
+  notFound:
+    schema:
+      $ref: "#/definitions/error"
+
+paths:
+  "/some/where/{id}":
+    parameters:
+      - $ref: "#/parameters/idParam"
+      - name: bodyId
+        in: body
+        schema:
+          type: object
+    get:
+      parameters:
+      - $ref: "#/parameters/limitParam"
+      - name: body
+        in: body
+        schema:
+          type: object
+      responses:
+        default:
+          schema:
+            type: object
+        404:
+          $ref: "#/responses/notFound"
+        200:
+          schema:
+            $ref: "#/definitions/tag"
+definitions:
+  tag:
+    type: object
+    properties:
+      id:
+        type: integer
+        format: int64
+      value:
+        type: string
+      audit:
+        $ref: "#/definitions/record"
+  record:
+    type: object
+    properties:
+      createdAt:
+        type: string
+        format: date-time
+  error:
+    type: object
+    required:
+      - id
+      - message
+    properties:
+      id:
+        type: integer
+        format: int64
+        readOnly: true
+      message:
+        type: string
+        readOnly: true
diff --git a/internal/validate/spec.go b/internal/validate/spec.go
index 1eb3bec5..4a0b6365 100644
--- a/internal/validate/spec.go
+++ b/internal/validate/spec.go
@@ -22,6 +22,7 @@ import (
 	"strings"
 
 	"github.com/go-swagger/go-swagger/errors"
+	"github.com/go-swagger/go-swagger/jsonpointer"
 	"github.com/go-swagger/go-swagger/spec"
 	"github.com/go-swagger/go-swagger/strfmt"
 )
@@ -84,9 +85,8 @@ func (s *SpecValidator) Validate(data interface{}) (errs *Result, warnings *Resu
 	errs.Merge(s.validateExamplesValidAgainstSchema())     // error -
 	errs.Merge(s.validateNonEmptyPathParamNames())
 
-	warnings.Merge(s.validateUniqueSecurityScopes())            // warning
-	warnings.Merge(s.validateUniqueScopesSecurityDefinitions()) // warning
-	warnings.Merge(s.validateReferenced())                      // warning
+	warnings.Merge(s.validateUniqueSecurityScopes()) // warning
+	warnings.Merge(s.validateReferenced())           // warning
 
 	return
 }
@@ -312,11 +312,7 @@ func (s *SpecValidator) validateUniqueSecurityScopes() *Result {
 	// Each authorization/security reference should contain only unique scopes.
 	// (Example: For an oauth2 authorization/security requirement, when listing the required scopes,
 	// each scope should only be listed once.)
-	return nil
-}
 
-func (s *SpecValidator) validateUniqueScopesSecurityDefinitions() *Result {
-	// Each authorization/security scope in an authorization/security definition should be unique.
 	return nil
 }
 
@@ -354,8 +350,92 @@ func (s *SpecValidator) validatePathParamPresence(path string, fromPath, fromOpe
 }
 
 func (s *SpecValidator) validateReferenced() *Result {
+	var res Result
+	res.Merge(s.validateReferencedParameters())
+	res.Merge(s.validateReferencedResponses())
+	res.Merge(s.validateReferencedDefinitions())
+	return &res
+}
+
+func (s *SpecValidator) validateReferencedParameters() *Result {
 	// Each referenceable definition must have references.
-	return nil
+	params := s.spec.Spec().Parameters
+	if len(params) == 0 {
+		return nil
+	}
+
+	expected := make(map[string]struct{})
+	for k := range params {
+		expected["#/parameters/"+jsonpointer.Escape(k)] = struct{}{}
+	}
+	for _, k := range s.spec.AllParameterReferences() {
+		if _, ok := expected[k]; ok {
+			delete(expected, k)
+		}
+	}
+
+	if len(expected) == 0 {
+		return nil
+	}
+	var result Result
+	for k := range expected {
+		result.AddErrors(errors.New(422, "parameter %q is not used anywhere", k))
+	}
+	return &result
+}
+
+func (s *SpecValidator) validateReferencedResponses() *Result {
+	// Each referenceable definition must have references.
+	responses := s.spec.Spec().Responses
+	if len(responses) == 0 {
+		return nil
+	}
+
+	expected := make(map[string]struct{})
+	for k := range responses {
+		expected["#/responses/"+jsonpointer.Escape(k)] = struct{}{}
+	}
+	for _, k := range s.spec.AllResponseReferences() {
+		if _, ok := expected[k]; ok {
+			delete(expected, k)
+		}
+	}
+
+	if len(expected) == 0 {
+		return nil
+	}
+	var result Result
+	for k := range expected {
+		result.AddErrors(errors.New(422, "response %q is not used anywhere", k))
+	}
+	return &result
+}
+
+func (s *SpecValidator) validateReferencedDefinitions() *Result {
+	// Each referenceable definition must have references.
+	defs := s.spec.Spec().Definitions
+	if len(defs) == 0 {
+		return nil
+	}
+
+	expected := make(map[string]struct{})
+	for k := range defs {
+		expected["#/definitions/"+jsonpointer.Escape(k)] = struct{}{}
+	}
+	for _, k := range s.spec.AllDefinitionReferences() {
+		if _, ok := expected[k]; ok {
+			delete(expected, k)
+		}
+	}
+
+	if len(expected) == 0 {
+		return nil
+	}
+	var result Result
+	for k := range expected {
+		result.AddErrors(errors.New(422, "definition %q is not used anywhere", k))
+	}
+	return &result
 }
 
 func (s *SpecValidator) validateRequiredDefinitions() *Result {
@@ -664,6 +744,3 @@ func (s *SpecValidator) validateDefaultValueItemsAgainstSchema(path, in string,
 	}
 	return res
 }
-
-func (s *SpecValidator) isSwaggerType(tpe, format string, value interface{}) {
-}
diff --git a/internal/validate/spec_test.go b/internal/validate/spec_test.go
index 78756ec0..470db85d 100644
--- a/internal/validate/spec_test.go
+++ b/internal/validate/spec_test.go
@@ -93,10 +93,23 @@ func TestValidateCircularAncestry(t *testing.T) {
 func TestValidateUniqueSecurityScopes(t *testing.T) {
 }
 
-func TestValidateUniqueScopesSecurityDefinitions(t *testing.T) {
-}
-
 func TestValidateReferenced(t *testing.T) {
+	doc, err := spec.YAMLSpec(filepath.Join("..", "..", "fixtures", "validation", "valid-referenced.yml"))
+	if assert.NoError(t, err) {
+		validator := NewSpecValidator(spec.MustLoadSwagger20Schema(), strfmt.Default)
+		validator.spec = doc
+		res := validator.validateReferenced()
+		assert.Empty(t, res.Errors)
+	}
+
+	doc, err = spec.YAMLSpec(filepath.Join("..", "..", "fixtures", "validation", "invalid-referenced.yml"))
+	if assert.NoError(t, err) {
+		validator := NewSpecValidator(spec.MustLoadSwagger20Schema(), strfmt.Default)
+		validator.spec = doc
+		res := validator.validateReferenced()
+		assert.NotEmpty(t, res.Errors)
+		assert.Len(t, res.Errors, 3)
+	}
 }
 
 func TestValidateBodyFormDataParams(t *testing.T) {
diff --git a/spec/analyzer.go b/spec/analyzer.go
index 74220633..b76dd5a2 100644
--- a/spec/analyzer.go
+++ b/spec/analyzer.go
@@ -25,9 +25,35 @@ import (
 )
 
 type referenceAnalysis struct {
-	schemas    map[string]SchemaRef
-	responses  map[string]*Response
-	parameters map[string]*Parameter
+	schemas    map[string]Ref
+	responses  map[string]Ref
+	parameters map[string]Ref
+	referenced struct {
+		schemas    map[string]SchemaRef
+		responses  map[string]*Response
+		parameters map[string]*Parameter
+	}
+}
+
+func (r *referenceAnalysis) addSchemaRef(key string, ref SchemaRef) {
+	if r.schemas == nil {
+		r.schemas = make(map[string]Ref)
+	}
+	r.schemas["#"+key] = ref.Schema.Ref
+}
+
+func (r *referenceAnalysis) addResponseRef(key string, resp *Response) {
+	if r.responses == nil {
+		r.responses = make(map[string]Ref)
+	}
+	r.responses["#"+key] = resp.Ref
+}
+
+func (r *referenceAnalysis) addParamRef(key string, param *Parameter) {
+	if r.parameters == nil {
+		r.parameters = make(map[string]Ref)
+	}
+	r.parameters["#"+key] = param.Ref
 }
 
 // specAnalyzer takes a swagger spec object and turns it into a registry
@@ -38,7 +64,7 @@ type specAnalyzer struct {
 	produces    map[string]struct{}
 	authSchemes map[string]struct{}
 	operations  map[string]map[string]*Operation
-	referenced  referenceAnalysis
+	references  referenceAnalysis
 	allSchemas  map[string]SchemaRef
 	allOfs      map[string]SchemaRef
 }
@@ -74,9 +100,14 @@ func (s *specAnalyzer) initialize() {
 	for name, schema := range s.spec.Definitions {
 		s.analyzeSchema(name, schema, "/definitions")
 	}
+	// TODO: after analyzing all things and flattening shemas etc
+	// resolve all the collected references to their final representations
+	// best put in a separate method because this could get expensive
 }
 
-func (s *specAnalyzer) analyzeOperations(path string, op *PathItem) {
+func (s *specAnalyzer) analyzeOperations(path string, pi *PathItem) {
+	// TODO: resolve refs here?
+	op := pi
 	s.analyzeOperation("GET", path, op.Get)
 	s.analyzeOperation("PUT", path, op.Put)
 	s.analyzeOperation("POST", path, op.Post)
@@ -85,8 +116,12 @@ func (s *specAnalyzer) analyzeOperations(path string, op *PathItem) {
 	s.analyzeOperation("HEAD", path, op.Head)
 	s.analyzeOperation("OPTIONS", path, op.Options)
 	for i, param := range op.Parameters {
+		refPref := slashpath.Join("/paths", jsonpointer.Escape(path), "parameters", strconv.Itoa(i))
+		if param.Ref.String() != "" {
+			s.references.addParamRef(refPref, &param)
+		}
 		if param.Schema != nil {
-			s.analyzeSchema("schema", *param.Schema, slashpath.Join("/paths", jsonpointer.Escape(path), "parameters", strconv.Itoa(i)))
+			s.analyzeSchema("schema", *param.Schema, refPref)
 		}
 	}
 }
@@ -113,17 +148,31 @@ func (s *specAnalyzer) analyzeOperation(method, path string, op *Operation) {
 	s.operations[method][path] = op
 	prefix := slashpath.Join("/paths", jsonpointer.Escape(path), strings.ToLower(method))
 	for i, param := range op.Parameters {
+		refPref := slashpath.Join(prefix, "parameters", strconv.Itoa(i))
+		if param.Ref.String() != "" {
+			s.references.addParamRef(refPref, &param)
+		}
 		if param.In == "body" && param.Schema != nil {
-			s.analyzeSchema("schema", *param.Schema, slashpath.Join(prefix, "parameters", strconv.Itoa(i)))
+			s.analyzeSchema("schema", *param.Schema, refPref)
 		}
 	}
 	if op.Responses != nil {
-		if op.Responses.Default != nil && op.Responses.Default.Schema != nil {
-			s.analyzeSchema("schema", *op.Responses.Default.Schema, slashpath.Join(prefix, "responses", "default"))
+		if op.Responses.Default != nil {
+			refPref := slashpath.Join(prefix, "responses", "default")
+			if op.Responses.Default.Ref.String() != "" {
+				s.references.addResponseRef(refPref, op.Responses.Default)
+			}
+			if op.Responses.Default.Schema != nil {
+				s.analyzeSchema("schema", *op.Responses.Default.Schema, refPref)
+			}
 		}
 		for k, res := range op.Responses.StatusCodeResponses {
+			refPref := slashpath.Join(prefix, "responses", strconv.Itoa(k))
+			if res.Ref.String() != "" {
+				s.references.addResponseRef(refPref, &res)
+			}
 			if res.Schema != nil {
-				s.analyzeSchema("schema", *res.Schema, slashpath.Join(prefix, "responses", strconv.Itoa(k)))
+				s.analyzeSchema("schema", *res.Schema, refPref)
 			}
 		}
 	}
@@ -131,11 +180,15 @@ func (s *specAnalyzer) analyzeOperation(method, path string, op *Operation) {
 
 func (s *specAnalyzer) analyzeSchema(name string, schema Schema, prefix string) {
 	refURI := slashpath.Join(prefix, jsonpointer.Escape(name))
-	s.allSchemas["#"+refURI] = SchemaRef{
+	schRef := SchemaRef{
 		Name:   name,
 		Schema: &schema,
 		Ref:    MustCreateRef("#" + refURI),
 	}
+	s.allSchemas["#"+refURI] = schRef
+	if schema.Ref.String() != "" {
+		s.references.addSchemaRef(refURI, schRef)
+	}
 	for k, v := range schema.Definitions {
 		s.analyzeSchema(k, v, slashpath.Join(refURI, "definitions"))
 	}
@@ -399,3 +452,24 @@ func (s *specAnalyzer) AllDefinitions() (result []SchemaRef) {
 	}
 	return
 }
+
+func (s *specAnalyzer) AllDefinitionReferences() (result []string) {
+	for _, v := range s.references.schemas {
+		result = append(result, v.String())
+	}
+	return
+}
+
+func (s *specAnalyzer) AllParameterReferences() (result []string) {
+	for _, v := range s.references.parameters {
+		result = append(result, v.String())
+	}
+	return
+}
+
+func (s *specAnalyzer) AllResponseReferences() (result []string) {
+	for _, v := range s.references.responses {
+		result = append(result, v.String())
+	}
+	return
+}
diff --git a/spec/analyzer_test.go b/spec/analyzer_test.go
index de266b47..00061c3f 100644
--- a/spec/analyzer_test.go
+++ b/spec/analyzer_test.go
@@ -39,13 +39,8 @@ func newAnalyzer(spec *Swagger) *specAnalyzer {
 		produces:    make(map[string]struct{}),
 		authSchemes: make(map[string]struct{}),
 		operations:  make(map[string]map[string]*Operation),
-		referenced: referenceAnalysis{
-			schemas:    make(map[string]SchemaRef),
-			responses:  make(map[string]*Response),
-			parameters: make(map[string]*Parameter),
-		},
-		allSchemas: make(map[string]SchemaRef),
-		allOfs:     make(map[string]SchemaRef),
+		allSchemas:  make(map[string]SchemaRef),
+		allOfs:      make(map[string]SchemaRef),
 	}
 	a.initialize()
 	return a
@@ -183,7 +178,33 @@ func TestDefinitionAnalysis(t *testing.T) {
 	}
 }
 
-func assertSchemaRefExists(t *testing.T, data map[string]SchemaRef, key string) bool {
+func TestReferenceAnalysis(t *testing.T) {
+	doc, err := Load(filepath.Join("..", "fixtures", "analysis", "references.yml"))
+	if assert.NoError(t, err) {
+		definitions := doc.references
+
+		// parameters
+		assertRefExists(t, definitions.parameters, "#/paths/~1some~1where~1{id}/parameters/0")
+		assertRefExists(t, definitions.parameters, "#/paths/~1some~1where~1{id}/get/parameters/0")
+
+		// responses
+		assertRefExists(t, definitions.responses, "#/paths/~1some~1where~1{id}/get/responses/404")
+
+		//// definitions
+		assertRefExists(t, definitions.schemas, "#/responses/notFound/schema")
+		assertRefExists(t, definitions.schemas, "#/paths/~1some~1where~1{id}/get/responses/200/schema")
+		assertRefExists(t, definitions.schemas, "#/definitions/tag/properties/audit")
+	}
+}
+
+func assertRefExists(t testing.TB, data map[string]Ref, key string) bool {
+	if _, ok := data[key]; !ok {
+		return assert.Fail(t, fmt.Sprintf("expected %q to exist in the ref bag", key))
+	}
+	return true
+}
+
+func assertSchemaRefExists(t testing.TB, data map[string]SchemaRef, key string) bool {
 	if _, ok := data[key]; !ok {
 		return assert.Fail(t, fmt.Sprintf("expected %q to exist in schema ref bag", key))
 	}
diff --git a/spec/spec.go b/spec/spec.go
index 96f8b020..b8708e42 100644
--- a/spec/spec.go
+++ b/spec/spec.go
@@ -151,13 +151,8 @@ func New(data json.RawMessage, version string) (*Document, error) {
 			produces:    make(map[string]struct{}),
 			authSchemes: make(map[string]struct{}),
 			operations:  make(map[string]map[string]*Operation),
-			referenced: referenceAnalysis{
-				schemas:    make(map[string]SchemaRef),
-				responses:  make(map[string]*Response),
-				parameters: make(map[string]*Parameter),
-			},
-			allSchemas: make(map[string]SchemaRef),
-			allOfs:     make(map[string]SchemaRef),
+			allSchemas:  make(map[string]SchemaRef),
+			allOfs:      make(map[string]SchemaRef),
 		},
 		spec: spec,
 		raw:  data,
@@ -183,13 +178,8 @@ func (d *Document) Expanded() (*Document, error) {
 			produces:    make(map[string]struct{}),
 			authSchemes: make(map[string]struct{}),
 			operations:  make(map[string]map[string]*Operation),
-			referenced: referenceAnalysis{
-				schemas:    make(map[string]SchemaRef),
-				responses:  make(map[string]*Response),
-				parameters: make(map[string]*Parameter),
-			},
-			allSchemas: make(map[string]SchemaRef),
-			allOfs:     make(map[string]SchemaRef),
+			allSchemas:  make(map[string]SchemaRef),
+			allOfs:      make(map[string]SchemaRef),
 		},
 		spec: spec,
 		raw:  d.raw,
@@ -236,19 +226,14 @@ func (d *Document) Reload() *Document {
 		produces:    make(map[string]struct{}),
 		authSchemes: make(map[string]struct{}),
 		operations:  make(map[string]map[string]*Operation),
-		referenced: referenceAnalysis{
-			schemas:    make(map[string]SchemaRef),
-			responses:  make(map[string]*Response),
-			parameters: make(map[string]*Parameter),
-		},
-		allSchemas: make(map[string]SchemaRef),
-		allOfs:     make(map[string]SchemaRef),
+		allSchemas:  make(map[string]SchemaRef),
+		allOfs:      make(map[string]SchemaRef),
 	}
 	d.initialize()
 	return d
 }
 
-// Prisitine creates a new pristine document instance based on the input data
+// Pristine creates a new pristine document instance based on the input data
 func (d *Document) Pristine() *Document {
 	dd, _ := New(d.Raw(), d.Version())
 	return dd
diff --git a/vendor/manifest b/vendor/manifest
index 8efab25c..34827eb3 100644
--- a/vendor/manifest
+++ b/vendor/manifest
@@ -136,6 +136,13 @@
 			"revision": "48afeb21e2fcbcff0f30bd5ad6b97747b0fae38e",
 			"branch": "master"
 		},
+		{
+			"importpath": "golang.org/x/net/context",
+			"repository": "https://go.googlesource.com/net",
+			"revision": "5d0a0f8cd486626821d2ba44d471ab1c9271d38f",
+			"branch": "master",
+			"path": "/context"
+		},
 		{
 			"importpath": "golang.org/x/net/netutil",
 			"repository": "https://go.googlesource.com/net",
