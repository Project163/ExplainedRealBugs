diff --git a/fixtures/goparsing/classification/models/nomodel.go b/fixtures/goparsing/classification/models/nomodel.go
index ff6b340d..a353fd1d 100644
--- a/fixtures/goparsing/classification/models/nomodel.go
+++ b/fixtures/goparsing/classification/models/nomodel.go
@@ -51,6 +51,22 @@ type NoModel struct {
 	// items.pattern: \w+
 	FooSlice []string `json:"foo_slice"`
 
+	// a BarSlice has bars which are strings
+	//
+	// min items: 3
+	// max items: 10
+	// unique: true
+	// items.minItems: 4
+	// items.maxItems: 9
+	// items.items.minItems: 5
+	// items.items.maxItems: 8
+	// items.items.items.minLength: 3
+	// items.items.items.maxLength: 10
+	// items.items.items.pattern: \w+
+	// collection format: pipe
+	// in: query
+	BarSlice [][][]string `json:"bar_slice"`
+
 	// the items for this order
 	Items []struct {
 		// ID of this no model instance.
diff --git a/fixtures/goparsing/classification/operations/noparams.go b/fixtures/goparsing/classification/operations/noparams.go
index 494c9c91..a241f93a 100644
--- a/fixtures/goparsing/classification/operations/noparams.go
+++ b/fixtures/goparsing/classification/operations/noparams.go
@@ -78,6 +78,22 @@ type NoParams struct {
 	// in: query
 	FooSlice []string `json:"foo_slice"`
 
+	// a BarSlice has bars which are strings
+	//
+	// min items: 3
+	// max items: 10
+	// unique: true
+	// items.minItems: 4
+	// items.maxItems: 9
+	// items.items.minItems: 5
+	// items.items.maxItems: 8
+	// items.items.items.minLength: 3
+	// items.items.items.maxLength: 10
+	// items.items.items.pattern: \w+
+	// collection format: pipe
+	// in: query
+	BarSlice [][][]string `json:"bar_slice"`
+
 	// the items for this order
 	//
 	// in: body
diff --git a/fixtures/goparsing/classification/operations/responses.go b/fixtures/goparsing/classification/operations/responses.go
index fda5c166..663fbbdb 100644
--- a/fixtures/goparsing/classification/operations/responses.go
+++ b/fixtures/goparsing/classification/operations/responses.go
@@ -85,6 +85,21 @@ type SomeResponse struct {
 	// collection format: pipe
 	FooSlice []string `json:"foo_slice"`
 
+	// a BarSlice has bars which are strings
+	//
+	// min items: 3
+	// max items: 10
+	// unique: true
+	// items.minItems: 4
+	// items.maxItems: 9
+	// items.items.minItems: 5
+	// items.items.maxItems: 8
+	// items.items.items.minLength: 3
+	// items.items.items.maxLength: 10
+	// items.items.items.pattern: \w+
+	// collection format: pipe
+	BarSlice [][][]string `json:"bar_slice"`
+
 	// the items for this order
 	//
 	// in: body
diff --git a/scan/parameters.go b/scan/parameters.go
index 7a8e7da2..f44aaf66 100644
--- a/scan/parameters.go
+++ b/scan/parameters.go
@@ -26,6 +26,8 @@ type paramTypable struct {
 	param *spec.Parameter
 }
 
+func (pt paramTypable) Level() int { return 0 }
+
 func (pt paramTypable) Typed(tpe, format string) {
 	pt.param.Typed(tpe, format)
 }
@@ -47,14 +49,14 @@ func (pt paramTypable) Items() swaggerTypable {
 			pt.param.Schema.Items.Schema = new(spec.Schema)
 		}
 		pt.param.Schema.Typed("array", "")
-		return schemaTypable{pt.param.Schema.Items.Schema}
+		return schemaTypable{pt.param.Schema.Items.Schema, 0}
 	}
 
 	if pt.param.Items == nil {
 		pt.param.Items = new(spec.Items)
 	}
 	pt.param.Type = "array"
-	return itemsTypable{pt.param.Items}
+	return itemsTypable{pt.param.Items, 1}
 }
 
 func (pt paramTypable) Schema() *spec.Schema {
@@ -69,8 +71,11 @@ func (pt paramTypable) Schema() *spec.Schema {
 
 type itemsTypable struct {
 	items *spec.Items
+	level int
 }
 
+func (pt itemsTypable) Level() int { return pt.level }
+
 func (pt itemsTypable) Typed(tpe, format string) {
 	pt.items.Typed(tpe, format)
 }
@@ -88,7 +93,7 @@ func (pt itemsTypable) Items() swaggerTypable {
 		pt.items.Items = new(spec.Items)
 	}
 	pt.items.Type = "array"
-	return itemsTypable{pt.items.Items}
+	return itemsTypable{pt.items.Items, pt.level + 1}
 }
 
 type paramValidations struct {
@@ -291,8 +296,9 @@ func (pp *paramStructParser) parseStructType(gofile *ast.File, operation *spec.O
 
 					if strings.TrimSpace(tv) != "" {
 						st := reflect.StructTag(tv)
-						if st.Get("json") != "" {
-							nm = strings.Split(st.Get("json"), ",")[0]
+						jsonTag := st.Get("json")
+						if jsonTag != "" && jsonTag != "-" {
+							nm = strings.Split(jsonTag, ",")[0]
 						}
 					}
 				}
@@ -314,7 +320,7 @@ func (pp *paramStructParser) parseStructType(gofile *ast.File, operation *spec.O
 				ps.In = in
 				var pty swaggerTypable = paramTypable{&ps}
 				if in == "body" {
-					pty = schemaTypable{pty.Schema()}
+					pty = schemaTypable{pty.Schema(), 0}
 				}
 				if err := parseProperty(pp.scp, gofile, fld.Type, pty); err != nil {
 					return err
@@ -337,29 +343,46 @@ func (pp *paramStructParser) parseStructType(gofile *ast.File, operation *spec.O
 						newSingleLineTagParser("required", &setRequiredParam{&ps}),
 						newSingleLineTagParser("in", &matchOnlyParam{&ps, rxIn}),
 					}
-					itemsTaggers := func() []tagParser {
+
+					itemsTaggers := func(items *spec.Items, level int) []tagParser {
+						// the expression is 1-index based not 0-index
+						itemsPrefix := fmt.Sprintf(rxItemsPrefixFmt, level+1)
+
 						return []tagParser{
-							newSingleLineTagParser("itemsMaximum", &setMaximum{itemsValidations{ps.Items}, rxf(rxMaximumFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsMinimum", &setMinimum{itemsValidations{ps.Items}, rxf(rxMinimumFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsMultipleOf", &setMultipleOf{itemsValidations{ps.Items}, rxf(rxMultipleOfFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsMinLength", &setMinLength{itemsValidations{ps.Items}, rxf(rxMinLengthFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsMaxLength", &setMaxLength{itemsValidations{ps.Items}, rxf(rxMaxLengthFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsPattern", &setPattern{itemsValidations{ps.Items}, rxf(rxPatternFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsCollectionFormat", &setCollectionFormat{itemsValidations{ps.Items}, rxf(rxCollectionFormatFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsMinItems", &setMinItems{itemsValidations{ps.Items}, rxf(rxMinItemsFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsMaxItems", &setMaxItems{itemsValidations{ps.Items}, rxf(rxMaxItemsFmt, rxItemsPrefix)}),
-							newSingleLineTagParser("itemsUnique", &setUnique{itemsValidations{ps.Items}, rxf(rxUniqueFmt, rxItemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMaximum", level), &setMaximum{itemsValidations{items}, rxf(rxMaximumFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMinimum", level), &setMinimum{itemsValidations{items}, rxf(rxMinimumFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMultipleOf", level), &setMultipleOf{itemsValidations{items}, rxf(rxMultipleOfFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMinLength", level), &setMinLength{itemsValidations{items}, rxf(rxMinLengthFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMaxLength", level), &setMaxLength{itemsValidations{items}, rxf(rxMaxLengthFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dPattern", level), &setPattern{itemsValidations{items}, rxf(rxPatternFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dCollectionFormat", level), &setCollectionFormat{itemsValidations{items}, rxf(rxCollectionFormatFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMinItems", level), &setMinItems{itemsValidations{items}, rxf(rxMinItemsFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMaxItems", level), &setMaxItems{itemsValidations{items}, rxf(rxMaxItemsFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dUnique", level), &setUnique{itemsValidations{items}, rxf(rxUniqueFmt, itemsPrefix)}),
 						}
 					}
 
 					// check if this is a primitive, if so parse the validations from the
 					// doc comments of the slice declaration.
-					if ftpe, ok := fld.Type.(*ast.ArrayType); ok {
-						if iftpe, ok := ftpe.Elt.(*ast.Ident); ok && iftpe.Obj == nil {
-							if ps.Items != nil {
-								// items matchers should go before the default matchers so they match first
-								sp.taggers = append(itemsTaggers(), sp.taggers...)
+					if ftped, ok := fld.Type.(*ast.ArrayType); ok {
+						ftpe := ftped
+						items, level := ps.Items, 0
+						for items != nil {
+							switch iftpe := ftpe.Elt.(type) {
+							case *ast.ArrayType:
+								eleTaggers := itemsTaggers(items, level)
+								sp.taggers = append(eleTaggers, sp.taggers...)
+								ftpe = iftpe
+							case *ast.Ident:
+								if iftpe.Obj == nil {
+									sp.taggers = append(itemsTaggers(items, level), sp.taggers...)
+								}
+								break
+							default:
+								return fmt.Errorf("unknown field type ele for %q", nm)
 							}
+							items = items.Items
+							level = level + 1
 						}
 					}
 
diff --git a/scan/parameters_test.go b/scan/parameters_test.go
index 461916a3..6d57b16e 100644
--- a/scan/parameters_test.go
+++ b/scan/parameters_test.go
@@ -60,7 +60,7 @@ func TestParamsParser(t *testing.T) {
 
 	op, ok := noParamOps["someOperation"]
 	assert.True(t, ok)
-	assert.Len(t, op.Parameters, 6)
+	assert.Len(t, op.Parameters, 7)
 
 	for _, param := range op.Parameters {
 		switch param.Name {
@@ -160,6 +160,34 @@ func TestParamsParser(t *testing.T) {
 			assert.True(t, ok)
 			assert.Equal(t, "Notes to add to this item.\nThis can be used to add special instructions.", iprop.Description)
 
+		case "bar_slice":
+			assert.Equal(t, "a BarSlice has bars which are strings", param.Description)
+			assert.Equal(t, "BarSlice", param.Extensions["x-go-name"])
+			assert.Equal(t, "query", param.In)
+			assert.Equal(t, "array", param.Type)
+			assert.False(t, param.Required)
+			assert.True(t, param.UniqueItems)
+			assert.Equal(t, "pipe", param.CollectionFormat)
+			assert.NotNil(t, param.Items, "bar_slice should have had an items property")
+			assert.EqualValues(t, 3, *param.MinItems, "'bar_slice' should have had 3 min items")
+			assert.EqualValues(t, 10, *param.MaxItems, "'bar_slice' should have had 10 max items")
+			itprop := param.Items
+			if assert.NotNil(t, itprop) {
+				assert.EqualValues(t, 4, *itprop.MinItems, "'bar_slice.items.minItems' should have been 4")
+				assert.EqualValues(t, 9, *itprop.MaxItems, "'bar_slice.items.maxItems' should have been 9")
+				itprop2 := itprop.Items
+				if assert.NotNil(t, itprop2) {
+					assert.EqualValues(t, 5, *itprop2.MinItems, "'bar_slice.items.items.minItems' should have been 5")
+					assert.EqualValues(t, 8, *itprop2.MaxItems, "'bar_slice.items.items.maxItems' should have been 8")
+					itprop3 := itprop2.Items
+					if assert.NotNil(t, itprop3) {
+						assert.EqualValues(t, 3, *itprop3.MinLength, "'bar_slice.items.items.items.minLength' should have been 3")
+						assert.EqualValues(t, 10, *itprop3.MaxLength, "'bar_slice.items.items.items.maxLength' should have been 10")
+						assert.EqualValues(t, "\\w+", itprop3.Pattern, "'bar_slice.items.items.items.pattern' should have \\w+")
+					}
+				}
+			}
+
 		default:
 			assert.Fail(t, "unkown property: "+param.Name)
 		}
diff --git a/scan/responses.go b/scan/responses.go
index de813755..522911c4 100644
--- a/scan/responses.go
+++ b/scan/responses.go
@@ -18,6 +18,8 @@ type responseTypable struct {
 	response *spec.Response
 }
 
+func (ht responseTypable) Level() int { return 0 }
+
 func (ht responseTypable) Typed(tpe, format string) {
 	ht.header.Typed(tpe, format)
 }
@@ -35,14 +37,14 @@ func (ht responseTypable) Items() swaggerTypable {
 			ht.response.Schema.Items.Schema = new(spec.Schema)
 		}
 		ht.response.Schema.Typed("array", "")
-		return schemaTypable{ht.response.Schema.Items.Schema}
+		return schemaTypable{ht.response.Schema.Items.Schema, 0}
 	}
 
 	if ht.header.Items == nil {
 		ht.header.Items = new(spec.Items)
 	}
 	ht.header.Type = "array"
-	return itemsTypable{ht.header.Items}
+	return itemsTypable{ht.header.Items, 1}
 }
 
 func (ht responseTypable) SetRef(ref spec.Ref) {
@@ -296,29 +298,45 @@ func (rp *responseParser) parseStructType(gofile *ast.File, response *spec.Respo
 					newSingleLineTagParser("maxItems", &setMaxItems{headerValidations{&ps}, rxf(rxMaxItemsFmt, "")}),
 					newSingleLineTagParser("unique", &setUnique{headerValidations{&ps}, rxf(rxUniqueFmt, "")}),
 				}
-				itemsTaggers := func() []tagParser {
+				itemsTaggers := func(items *spec.Items, level int) []tagParser {
+					// the expression is 1-index based not 0-index
+					itemsPrefix := fmt.Sprintf(rxItemsPrefixFmt, level+1)
+
 					return []tagParser{
-						newSingleLineTagParser("itemsMaximum", &setMaximum{itemsValidations{ps.Items}, rxf(rxMaximumFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsMinimum", &setMinimum{itemsValidations{ps.Items}, rxf(rxMinimumFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsMultipleOf", &setMultipleOf{itemsValidations{ps.Items}, rxf(rxMultipleOfFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsMinLength", &setMinLength{itemsValidations{ps.Items}, rxf(rxMinLengthFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsMaxLength", &setMaxLength{itemsValidations{ps.Items}, rxf(rxMaxLengthFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsPattern", &setPattern{itemsValidations{ps.Items}, rxf(rxPatternFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsCollectionFormat", &setCollectionFormat{itemsValidations{ps.Items}, rxf(rxCollectionFormatFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsMinItems", &setMinItems{itemsValidations{ps.Items}, rxf(rxMinItemsFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsMaxItems", &setMaxItems{itemsValidations{ps.Items}, rxf(rxMaxItemsFmt, rxItemsPrefix)}),
-						newSingleLineTagParser("itemsUnique", &setUnique{itemsValidations{ps.Items}, rxf(rxUniqueFmt, rxItemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dMaximum", level), &setMaximum{itemsValidations{items}, rxf(rxMaximumFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dMinimum", level), &setMinimum{itemsValidations{items}, rxf(rxMinimumFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dMultipleOf", level), &setMultipleOf{itemsValidations{items}, rxf(rxMultipleOfFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dMinLength", level), &setMinLength{itemsValidations{items}, rxf(rxMinLengthFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dMaxLength", level), &setMaxLength{itemsValidations{items}, rxf(rxMaxLengthFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dPattern", level), &setPattern{itemsValidations{items}, rxf(rxPatternFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dCollectionFormat", level), &setCollectionFormat{itemsValidations{items}, rxf(rxCollectionFormatFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dMinItems", level), &setMinItems{itemsValidations{items}, rxf(rxMinItemsFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dMaxItems", level), &setMaxItems{itemsValidations{items}, rxf(rxMaxItemsFmt, itemsPrefix)}),
+						newSingleLineTagParser(fmt.Sprintf("items%dUnique", level), &setUnique{itemsValidations{items}, rxf(rxUniqueFmt, itemsPrefix)}),
 					}
 				}
 
 				// check if this is a primitive, if so parse the validations from the
 				// doc comments of the slice declaration.
-				if ftpe, ok := fld.Type.(*ast.ArrayType); ok {
-					if iftpe, ok := ftpe.Elt.(*ast.Ident); ok && iftpe.Obj == nil {
-						if ps.Items != nil {
-							// items matchers should go before the default matchers so they match first
-							sp.taggers = append(itemsTaggers(), sp.taggers...)
+				if ftped, ok := fld.Type.(*ast.ArrayType); ok {
+					ftpe := ftped
+					items, level := ps.Items, 0
+					for items != nil {
+						switch iftpe := ftpe.Elt.(type) {
+						case *ast.ArrayType:
+							eleTaggers := itemsTaggers(items, level)
+							sp.taggers = append(eleTaggers, sp.taggers...)
+							ftpe = iftpe
+						case *ast.Ident:
+							if iftpe.Obj == nil {
+								sp.taggers = append(itemsTaggers(items, level), sp.taggers...)
+							}
+							break
+						default:
+							return fmt.Errorf("unknown field type ele for %q", nm)
 						}
+						items = items.Items
+						level = level + 1
 					}
 				}
 
diff --git a/scan/responses_test.go b/scan/responses_test.go
index 94bf315e..1165e09d 100644
--- a/scan/responses_test.go
+++ b/scan/responses_test.go
@@ -51,7 +51,7 @@ func TestParseResponses(t *testing.T) {
 
 	res, ok := responses["someResponse"]
 	assert.True(t, ok)
-	assert.Len(t, res.Headers, 5)
+	assert.Len(t, res.Headers, 6)
 
 	for k, header := range res.Headers {
 		switch k {
@@ -103,6 +103,31 @@ func TestParseResponses(t *testing.T) {
 			assert.EqualValues(t, 10, *itprop.MaxLength, "'foo_slice.items.maxLength' should have been 10")
 			assert.EqualValues(t, "\\w+", itprop.Pattern, "'foo_slice.items.pattern' should have \\w+")
 
+		case "bar_slice":
+			assert.Equal(t, "a BarSlice has bars which are strings", header.Description)
+			assert.Equal(t, "array", header.Type)
+			assert.True(t, header.UniqueItems)
+			assert.Equal(t, "pipe", header.CollectionFormat)
+			assert.NotNil(t, header.Items, "bar_slice should have had an items property")
+			assert.EqualValues(t, 3, *header.MinItems, "'bar_slice' should have had 3 min items")
+			assert.EqualValues(t, 10, *header.MaxItems, "'bar_slice' should have had 10 max items")
+			itprop := header.Items
+			if assert.NotNil(t, itprop) {
+				assert.EqualValues(t, 4, *itprop.MinItems, "'bar_slice.items.minItems' should have been 4")
+				assert.EqualValues(t, 9, *itprop.MaxItems, "'bar_slice.items.maxItems' should have been 9")
+				itprop2 := itprop.Items
+				if assert.NotNil(t, itprop2) {
+					assert.EqualValues(t, 5, *itprop2.MinItems, "'bar_slice.items.items.minItems' should have been 5")
+					assert.EqualValues(t, 8, *itprop2.MaxItems, "'bar_slice.items.items.maxItems' should have been 8")
+					itprop3 := itprop2.Items
+					if assert.NotNil(t, itprop3) {
+						assert.EqualValues(t, 3, *itprop3.MinLength, "'bar_slice.items.items.items.minLength' should have been 3")
+						assert.EqualValues(t, 10, *itprop3.MaxLength, "'bar_slice.items.items.items.maxLength' should have been 10")
+						assert.EqualValues(t, "\\w+", itprop3.Pattern, "'bar_slice.items.items.items.pattern' should have \\w+")
+					}
+				}
+			}
+
 		default:
 			assert.Fail(t, "unkown property: "+k)
 		}
diff --git a/scan/scanner.go b/scan/scanner.go
index 441c1441..798147ed 100644
--- a/scan/scanner.go
+++ b/scan/scanner.go
@@ -33,7 +33,7 @@ const (
 	rxMinItemsFmt = "%s[Mm]in(?:imum)?(?:\\p{Zs}*|[\\p{Pd}\\p{Pc}]|\\.)?[Ii]tems\\p{Zs}*:\\p{Zs}*(\\p{N}+)$"
 	rxUniqueFmt   = "%s[Uu]nique\\p{Zs}*:\\p{Zs}*(true|false)$"
 
-	rxItemsPrefix = "(?:[Ii]tems[\\.\\p{Zs}]?)+"
+	rxItemsPrefixFmt = "(?:[Ii]tems[\\.\\p{Zs}]*){%d}"
 )
 
 var (
@@ -329,6 +329,7 @@ type swaggerTypable interface {
 	SetRef(spec.Ref)
 	Items() swaggerTypable
 	Schema() *spec.Schema
+	Level() int
 }
 
 func swaggerSchemaForType(typeName string, prop swaggerTypable) error {
diff --git a/scan/scanner_test.go b/scan/scanner_test.go
index 607f2fd0..b455156a 100644
--- a/scan/scanner_test.go
+++ b/scan/scanner_test.go
@@ -561,11 +561,11 @@ func TestSchemaValueExtractors(t *testing.T) {
 	verifySwaggerMultiArgSwaggerTag(t, rxParametersOverride, parameters, validParams, invalidParams)
 
 	verifyMinMax(t, rxf(rxMinimumFmt, ""), "min", []string{"", ">", "="})
-	verifyMinMax(t, rxf(rxMinimumFmt, rxItemsPrefix), "items.min", []string{"", ">", "="})
+	verifyMinMax(t, rxf(rxMinimumFmt, fmt.Sprintf(rxItemsPrefixFmt, 1)), "items.min", []string{"", ">", "="})
 	verifyMinMax(t, rxf(rxMaximumFmt, ""), "max", []string{"", "<", "="})
-	verifyMinMax(t, rxf(rxMaximumFmt, rxItemsPrefix), "items.max", []string{"", "<", "="})
+	verifyMinMax(t, rxf(rxMaximumFmt, fmt.Sprintf(rxItemsPrefixFmt, 1)), "items.max", []string{"", "<", "="})
 	verifyNumeric2Words(t, rxf(rxMultipleOfFmt, ""), "multiple", "of")
-	verifyNumeric2Words(t, rxf(rxMultipleOfFmt, rxItemsPrefix), "items.multiple", "of")
+	verifyNumeric2Words(t, rxf(rxMultipleOfFmt, fmt.Sprintf(rxItemsPrefixFmt, 1)), "items.multiple", "of")
 
 	verifyIntegerMinMaxManyWords(t, rxf(rxMinLengthFmt, ""), "min", []string{"len", "length"})
 	// pattern
diff --git a/scan/schema.go b/scan/schema.go
index c35cbcd2..3b717c90 100644
--- a/scan/schema.go
+++ b/scan/schema.go
@@ -15,6 +15,7 @@ import (
 
 type schemaTypable struct {
 	schema *spec.Schema
+	level  int
 }
 
 func (st schemaTypable) Typed(tpe, format string) {
@@ -38,8 +39,9 @@ func (st schemaTypable) Items() swaggerTypable {
 	}
 
 	st.schema.Typed("array", "")
-	return schemaTypable{st.schema.Items.Schema}
+	return schemaTypable{st.schema.Items.Schema, st.level + 1}
 }
+func (st schemaTypable) Level() int { return st.level }
 
 type schemaValidations struct {
 	current *spec.Schema
@@ -373,7 +375,7 @@ func (scp *schemaParser) parseStructType(gofile *ast.File, bschema *spec.Schema,
 				}
 
 				ps := schema.Properties[nm]
-				if err := parseProperty(scp, gofile, fld.Type, schemaTypable{&ps}); err != nil {
+				if err := parseProperty(scp, gofile, fld.Type, schemaTypable{&ps, 0}); err != nil {
 					return err
 				}
 
@@ -394,26 +396,43 @@ func (scp *schemaParser) parseStructType(gofile *ast.File, bschema *spec.Schema,
 						newSingleLineTagParser("readOnly", &setReadOnlySchema{&ps}),
 					}
 
+					itemsTaggers := func(items *spec.Schema, level int) []tagParser {
+						// the expression is 1-index based not 0-index
+						itemsPrefix := fmt.Sprintf(rxItemsPrefixFmt, level+1)
+						return []tagParser{
+							newSingleLineTagParser(fmt.Sprintf("items%dMaximum", level), &setMaximum{schemaValidations{items}, rxf(rxMaximumFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMinimum", level), &setMinimum{schemaValidations{items}, rxf(rxMinimumFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMultipleOf", level), &setMultipleOf{schemaValidations{items}, rxf(rxMultipleOfFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMinLength", level), &setMinLength{schemaValidations{items}, rxf(rxMinLengthFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMaxLength", level), &setMaxLength{schemaValidations{items}, rxf(rxMaxLengthFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dPattern", level), &setPattern{schemaValidations{items}, rxf(rxPatternFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMinItems", level), &setMinItems{schemaValidations{items}, rxf(rxMinItemsFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dMaxItems", level), &setMaxItems{schemaValidations{items}, rxf(rxMaxItemsFmt, itemsPrefix)}),
+							newSingleLineTagParser(fmt.Sprintf("items%dUnique", level), &setUnique{schemaValidations{items}, rxf(rxUniqueFmt, itemsPrefix)}),
+						}
+
+					}
 					// check if this is a primitive, if so parse the validations from the
 					// doc comments of the slice declaration.
-					if ftpe, ok := fld.Type.(*ast.ArrayType); ok {
-						if iftpe, ok := ftpe.Elt.(*ast.Ident); ok && iftpe.Obj == nil {
-							if ps.Items != nil && ps.Items.Schema != nil {
-								itemsTaggers := []tagParser{
-									newSingleLineTagParser("itemsMaximum", &setMaximum{schemaValidations{ps.Items.Schema}, rxf(rxMaximumFmt, rxItemsPrefix)}),
-									newSingleLineTagParser("itemsMinimum", &setMinimum{schemaValidations{ps.Items.Schema}, rxf(rxMinimumFmt, rxItemsPrefix)}),
-									newSingleLineTagParser("itemsMultipleOf", &setMultipleOf{schemaValidations{ps.Items.Schema}, rxf(rxMultipleOfFmt, rxItemsPrefix)}),
-									newSingleLineTagParser("itemsMinLength", &setMinLength{schemaValidations{ps.Items.Schema}, rxf(rxMinLengthFmt, rxItemsPrefix)}),
-									newSingleLineTagParser("itemsMaxLength", &setMaxLength{schemaValidations{ps.Items.Schema}, rxf(rxMaxLengthFmt, rxItemsPrefix)}),
-									newSingleLineTagParser("itemsPattern", &setPattern{schemaValidations{ps.Items.Schema}, rxf(rxPatternFmt, rxItemsPrefix)}),
-									newSingleLineTagParser("itemsMinItems", &setMinItems{schemaValidations{ps.Items.Schema}, rxf(rxMinItemsFmt, rxItemsPrefix)}),
-									newSingleLineTagParser("itemsMaxItems", &setMaxItems{schemaValidations{ps.Items.Schema}, rxf(rxMaxItemsFmt, rxItemsPrefix)}),
-									newSingleLineTagParser("itemsUnique", &setUnique{schemaValidations{ps.Items.Schema}, rxf(rxUniqueFmt, rxItemsPrefix)}),
+					if ftped, ok := fld.Type.(*ast.ArrayType); ok {
+						ftpe := ftped
+						items, level := ps.Items, 0
+						for items != nil && items.Schema != nil {
+							switch iftpe := ftpe.Elt.(type) {
+							case *ast.ArrayType:
+								eleTaggers := itemsTaggers(items.Schema, level)
+								sp.taggers = append(eleTaggers, sp.taggers...)
+								ftpe = iftpe
+							case *ast.Ident:
+								if iftpe.Obj == nil {
+									sp.taggers = append(itemsTaggers(items.Schema, level), sp.taggers...)
 								}
-
-								// items matchers should go before the default matchers so they match first
-								sp.taggers = append(itemsTaggers, sp.taggers...)
+								break
+								//default:
+								//return fmt.Errorf("unknown field type (%T) ele for %q", iftpe, nm)
 							}
+							items = items.Schema.Items
+							level = level + 1
 						}
 					}
 				} else {
@@ -648,7 +667,7 @@ func parseProperty(scp *schemaParser, gofile *ast.File, fld ast.Expr, prop swagg
 				if sch.AdditionalProperties.Schema == nil {
 					sch.AdditionalProperties.Schema = new(spec.Schema)
 				}
-				parseProperty(scp, gofile, ftpe.Value, schemaTypable{sch.AdditionalProperties.Schema})
+				parseProperty(scp, gofile, ftpe.Value, schemaTypable{sch.AdditionalProperties.Schema, 0})
 				sch.Typed("object", "")
 			}
 		}
diff --git a/scan/schema_test.go b/scan/schema_test.go
index e2aad76d..0df4378f 100644
--- a/scan/schema_test.go
+++ b/scan/schema_test.go
@@ -64,6 +64,32 @@ func TestSchemaParser(t *testing.T) {
 	assert.EqualValues(t, 10, *itprop.MaxLength, "'foo_slice.items.maxLength' should have been 10")
 	assert.EqualValues(t, "\\w+", itprop.Pattern, "'foo_slice.items.pattern' should have \\w+")
 
+	assertArrayProperty(t, &schema, "array", "bar_slice", "", "BarSlice")
+	prop, ok = schema.Properties["bar_slice"]
+	assert.Equal(t, "a BarSlice has bars which are strings", prop.Description)
+	assert.True(t, ok, "should have a 'bar_slice' property")
+	assert.NotNil(t, prop.Items, "bar_slice should have had an items property")
+	assert.NotNil(t, prop.Items.Schema, "bar_slice.items should have had a schema property")
+	assert.True(t, prop.UniqueItems, "'bar_slice' should have unique items")
+	assert.EqualValues(t, 3, *prop.MinItems, "'bar_slice' should have had 3 min items")
+	assert.EqualValues(t, 10, *prop.MaxItems, "'bar_slice' should have had 10 max items")
+	itprop = prop.Items.Schema
+	if assert.NotNil(t, itprop) {
+		assert.EqualValues(t, 4, *itprop.MinItems, "'bar_slice.items.minItems' should have been 4")
+		assert.EqualValues(t, 9, *itprop.MaxItems, "'bar_slice.items.maxItems' should have been 9")
+		itprop2 := itprop.Items.Schema
+		if assert.NotNil(t, itprop2) {
+			assert.EqualValues(t, 5, *itprop2.MinItems, "'bar_slice.items.items.minItems' should have been 5")
+			assert.EqualValues(t, 8, *itprop2.MaxItems, "'bar_slice.items.items.maxItems' should have been 8")
+			itprop3 := itprop2.Items.Schema
+			if assert.NotNil(t, itprop3) {
+				assert.EqualValues(t, 3, *itprop3.MinLength, "'bar_slice.items.items.items.minLength' should have been 3")
+				assert.EqualValues(t, 10, *itprop3.MaxLength, "'bar_slice.items.items.items.maxLength' should have been 10")
+				assert.EqualValues(t, "\\w+", itprop3.Pattern, "'bar_slice.items.items.items.pattern' should have \\w+")
+			}
+		}
+	}
+
 	assertArrayProperty(t, &schema, "object", "items", "", "Items")
 	prop, ok = schema.Properties["items"]
 	assert.True(t, ok, "should have an 'items' slice")
